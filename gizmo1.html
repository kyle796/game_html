<!DOCTYPE html>
<html lang="en">
    <head>
        <script>
            !function(e, t, n, o) {
                "use strict";
                var i, r, c = !1, u = {};
                function s(e, t, n, o, i) {
                    o = o || 0,
                    i = i || 0,
                    this.identifier = t,
                    this.target = e,
                    this.clientX = n.clientX + o,
                    this.clientY = n.clientY + i,
                    this.screenX = n.screenX + o,
                    this.screenY = n.screenY + i,
                    this.pageX = n.pageX + o,
                    this.pageY = n.pageY + i
                }
                function a() {
                    var e = [];
                    return e.item = function(e) {
                        return this[e] || null
                    }
                    ,
                    e.identifiedTouch = function(e) {
                        return this[e + 1] || null
                    }
                    ,
                    e
                }
                function d(e) {
                    e.preventDefault(),
                    e.stopPropagation()
                }
                function h(e) {
                    return function(t) {
                        d(t),
                        1 === t.which && (("mousedown" == t.type || !r || r && !r.dispatchEvent) && (r = t.target),
                        c && !t.shiftKey && (l("touchend", t),
                        c = !1),
                        l(e, t),
                        !c && t.shiftKey && (c = !0,
                        i = {
                            pageX: t.pageX,
                            pageY: t.pageY,
                            clientX: t.clientX,
                            clientY: t.clientY,
                            screenX: t.screenX,
                            screenY: t.screenY
                        },
                        l("touchstart", t)),
                        "mouseup" == t.type && (i = null,
                        c = !1,
                        r = null))
                    }
                }
                function l(e, n) {
                    var o = t.createEvent("Event");
                    o.initEvent(e, !0, !0),
                    o.altKey = n.altKey,
                    o.ctrlKey = n.ctrlKey,
                    o.metaKey = n.metaKey,
                    o.shiftKey = n.shiftKey,
                    o.touches = p(n, e),
                    o.targetTouches = p(n, e),
                    o.changedTouches = function(e, t) {
                        var n = f(e);
                        !c || "mouseup" == e.type || "touchstart" != t && "touchend" != t || n.splice(0, 1);
                        return n
                    }(n, e),
                    r.dispatchEvent(o)
                }
                function f(e) {
                    var t = new a;
                    if (c) {
                        var n = m.multiTouchOffset
                          , o = i.pageX - e.pageX
                          , u = i.pageY - e.pageY;
                        t.push(new s(r,1,i,-1 * o - n,-1 * u + n)),
                        t.push(new s(r,2,i,o + n,u - n))
                    } else
                        t.push(new s(r,1,e,0,0));
                    return t
                }
                function p(e, t) {
                    if ("mouseup" == e.type)
                        return new a;
                    var n = f(e);
                    return c && "mouseup" != e.type && "touchend" == t && n.splice(1, 1),
                    n
                }
                function v(e) {
                    var n, o, i, r;
                    for (o = 0; o < e.touches.length; o++)
                        for (var c in n = e.touches[o],
                        (i = u[n.identifier]) || (i = u[n.identifier] = t.createElement("div"),
                        t.body.appendChild(i)),
                        r = m.template(n))
                            i.style[c] = r[c];
                    if ("touchend" == e.type || "touchcancel" == e.type)
                        for (o = 0; o < e.changedTouches.length; o++)
                            n = e.changedTouches[o],
                            (i = u[n.identifier]) && (i.parentNode.removeChild(i),
                            delete u[n.identifier])
                }
                function m() {
                    "ontouchstart"in e || e.Modernizr && e.Modernizr.touch || (navigator.msMaxTouchPoints || navigator.maxTouchPoints) > 2 || (!function() {
                        for (var n = [e, t.documentElement], i = ["ontouchstart", "ontouchmove", "ontouchcancel", "ontouchend"], r = 0; r < n.length; r++)
                            for (var c = 0; c < i.length; c++)
                                n[r] && n[r][i[c]] == o && (n[r][i[c]] = null)
                    }(),
                    e.addEventListener("mousedown", h("touchstart"), !0),
                    e.addEventListener("mousemove", h("touchmove"), !0),
                    e.addEventListener("mouseup", h("touchend"), !0),
                    e.addEventListener("mouseenter", d, !0),
                    e.addEventListener("mouseleave", d, !0),
                    e.addEventListener("mouseout", d, !0),
                    e.addEventListener("mouseover", d, !0),
                    e.addEventListener("touchstart", v, !1),
                    e.addEventListener("touchmove", v, !1),
                    e.addEventListener("touchend", v, !1),
                    e.addEventListener("touchcancel", v, !1))
                }
                t.createTouch || (t.createTouch = function(t, n, i, r, c, u, a, d, h) {
                    return d != o && h != o || (d = r - e.pageXOffset,
                    h = c - e.pageYOffset),
                    new s(n,i,{
                        pageX: r,
                        pageY: c,
                        screenX: u,
                        screenY: a,
                        clientX: d,
                        clientY: h
                    })
                }
                ),
                t.createTouchList || (t.createTouchList = function() {
                    for (var e = new a, t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    return e.length = arguments.length,
                    e
                }
                ),
                m.multiTouchOffset = 75,
                m.template = function(e) {
                    var t = "translate(" + (e.clientX - 15) + "px, " + (e.clientY - 15) + "px)";
                    return {
                        position: "fixed",
                        left: 0,
                        top: 0,
                        background: "#fff",
                        border: "solid 1px #999",
                        opacity: .6,
                        borderRadius: "100%",
                        height: "30px",
                        width: "30px",
                        padding: 0,
                        margin: 0,
                        display: "block",
                        overflow: "hidden",
                        pointerEvents: "none",
                        webkitUserSelect: "none",
                        mozUserSelect: "none",
                        userSelect: "none",
                        webkitTransform: t,
                        mozTransform: t,
                        transform: t
                    }
                }
                ,
                "function" == typeof define && define.amd ? define((function() {
                    return m
                }
                )) : "undefined" != typeof module && module.exports ? module.exports = m : e.TouchEmulator = m
            }(window, document);
            TouchEmulator();
        </script>
        <meta charset="utf-8">
        <meta content="width=device-width,minimum-scale=1.0" name="viewport">
        <title>Gizmo</title>
        <style>
            *,:after,:before {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            ::backdrop {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            /*
! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com
*/
            *,:after,:before {
                border: 0 solid #e5e7eb;
                box-sizing: border-box
            }

            :after,:before {
                --tw-content: ""
            }

            :host,html {
                line-height: 1.5;
                -webkit-text-size-adjust: 100%;
                font-family: ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;
                font-feature-settings: normal;
                font-variation-settings: normal;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
                -webkit-tap-highlight-color: transparent
            }

            body {
                line-height: inherit;
                margin: 0
            }

            hr {
                border-top-width: 1px;
                color: inherit;
                height: 0
            }

            abbr:where([title]) {
                -webkit-text-decoration: underline dotted;
                text-decoration: underline dotted
            }

            h1,h2,h3,h4,h5,h6 {
                font-size: inherit;
                font-weight: inherit
            }

            a {
                color: inherit;
                text-decoration: inherit
            }

            b,strong {
                font-weight: bolder
            }

            code,kbd,pre,samp {
                font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;
                font-feature-settings: normal;
                font-size: 1em;
                font-variation-settings: normal
            }

            small {
                font-size: 80%
            }

            sub,sup {
                font-size: 75%;
                line-height: 0;
                position: relative;
                vertical-align: baseline
            }

            sub {
                bottom: -.25em
            }

            sup {
                top: -.5em
            }

            table {
                border-collapse: collapse;
                border-color: inherit;
                text-indent: 0
            }

            button,input,optgroup,select,textarea {
                color: inherit;
                font-family: inherit;
                font-feature-settings: inherit;
                font-size: 100%;
                font-variation-settings: inherit;
                font-weight: inherit;
                letter-spacing: inherit;
                line-height: inherit;
                margin: 0;
                padding: 0
            }

            button,select {
                text-transform: none
            }

            button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]) {
                -webkit-appearance: button;
                background-color: transparent;
                background-image: none
            }

            :-moz-focusring {
                outline: auto
            }

            :-moz-ui-invalid {
                box-shadow: none
            }

            progress {
                vertical-align: baseline
            }

            ::-webkit-inner-spin-button,::-webkit-outer-spin-button {
                height: auto
            }

            [type=search] {
                -webkit-appearance: textfield;
                outline-offset: -2px
            }

            ::-webkit-search-decoration {
                -webkit-appearance: none
            }

            ::-webkit-file-upload-button {
                -webkit-appearance: button;
                font: inherit
            }

            summary {
                display: list-item
            }

            blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre {
                margin: 0
            }

            fieldset {
                margin: 0
            }

            fieldset,legend {
                padding: 0
            }

            menu,ol,ul {
                list-style: none;
                margin: 0;
                padding: 0
            }

            dialog {
                padding: 0
            }

            textarea {
                resize: vertical
            }

            input::-moz-placeholder,textarea::-moz-placeholder {
                color: #9ca3af;
                opacity: 1
            }

            input::placeholder,textarea::placeholder {
                color: #9ca3af;
                opacity: 1
            }

            [role=button],button {
                cursor: pointer
            }

            :disabled {
                cursor: default
            }

            audio,canvas,embed,iframe,img,object,svg,video {
                display: block;
                vertical-align: middle
            }

            img,video {
                height: auto;
                max-width: 100%
            }

            [hidden]:where(:not([hidden=until-found])) {
                display: none
            }

            .visible {
                visibility: visible
            }

            .absolute {
                position: absolute
            }

            .inset-0 {
                inset: 0
            }

            .bottom-0 {
                bottom: 0
            }

            .left-0 {
                left: 0
            }

            .right-0 {
                right: 0
            }

            .z-10 {
                z-index: 10
            }

            .flex {
                display: flex
            }

            .grid {
                display: grid
            }

            .h-screen {
                height: 100vh
            }

            .w-screen {
                width: 100vw
            }

            @keyframes pulse {
                50% {
                    opacity: .5
                }
            }

            .animate-pulse {
                animation: pulse 2s cubic-bezier(.4,0,.6,1) infinite
            }

            .items-center {
                align-items: center
            }

            .justify-center {
                justify-content: center
            }

            .bg-black {
                --tw-bg-opacity: 1;
                background-color: rgb(0 0 0/var(--tw-bg-opacity,1))
            }

            .bg-opacity-50 {
                --tw-bg-opacity: 0.5
            }

            .bg-opacity-70 {
                --tw-bg-opacity: 0.7
            }

            .p-2 {
                padding: .5rem
            }

            .text-center {
                text-align: center
            }

            .font-mono {
                font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace
            }

            .text-2xl {
                font-size: 1.5rem;
                line-height: 2rem
            }

            .text-sm {
                font-size: .875rem;
                line-height: 1.25rem
            }

            .text-white {
                --tw-text-opacity: 1;
                color: rgb(255 255 255/var(--tw-text-opacity,1))
            }

            * {
                -webkit-user-select: none;
                -moz-user-select: none;
                user-select: none
            }

            img {
                pointer-events: none;
                -webkit-touch-callout: none
            }

            /*# sourceMappingURL=app.css.map */
        </style>
        <meta content="https://content.gizmo.party/cabf3a19-fe65-4c9f-9665-3b6d922f4da2" name="gizmo-preload">
        <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' blob: data: *.gizmo.party *.content.gizmo.party; media-src 'self' data: *.gizmo.party *.content.gizmo.party; connect-src 'self' blob: *.gizmo.party *.content.gizmo.party; script-src 'self' blob: 'unsafe-eval' 'unsafe-inline' runtime.gizmo.party; style-src 'self' 'unsafe-inline'; worker-src 'self' blob:; font-src 'self' data:; object-src 'none'; base-uri 'none'; upgrade-insecure-requests; block-all-mixed-content">
    </head>
    <body>
        <div id="application">
            <script type="module">
                var _N = Object.create
                  , cA = Object.defineProperty
                  , SN = Object.getOwnPropertyDescriptor
                  , ME = Object.getOwnPropertyNames
                  , xN = Object.getPrototypeOf
                  , AN = Object.prototype.hasOwnProperty
                  , un = (e, t) => function() {
                    return t || (0,
                    e[ME(e)[0]])((t = {
                        exports: {}
                    }).exports, t),
                    t.exports
                }
                  , TN = e => {
                    let t = {};
                    for (var n in e)
                        cA(t, n, {
                            get: e[n],
                            enumerable: !0
                        });
                    return t
                }
                  , MN = (e, t, n, i) => {
                    if (t && typeof t == "object" || typeof t == "function")
                        for (var s = ME(t), a = 0, o = s.length, c; a < o; a++)
                            c = s[a],
                            !AN.call(e, c) && c !== n && cA(e, c, {
                                get: (u => t[u]).bind(null, c),
                                enumerable: !(i = SN(t, c)) || i.enumerable
                            });
                    return e
                }
                  , _r = (e, t, n) => (n = e != null ? _N(xN(e)) : {},
                MN(t || !e || !e.__esModule ? cA(n, "default", {
                    value: e,
                    enumerable: !0
                }) : n, e))
                  , uA = un({
                    "node_modules/@gizmo/runtime/dist/src/utils/cancellable.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.setTimeoutCancellable = n;
                        var t = class {
                            callback;
                            _cancelled = !1;
                            constructor(i) {
                                this.callback = i
                            }
                            cancel = () => {
                                if (this._cancelled)
                                    return;
                                this._cancelled = !0;
                                const i = this.callback;
                                this.callback = void 0,
                                i?.()
                            }
                            ;
                            get isCancelled() {
                                return this._cancelled
                            }
                        }
                        ;
                        e.Cancellable = t;
                        function n(i, s) {
                            const a = setTimeout(i, s);
                            return new t( () => {
                                clearTimeout(a)
                            }
                            )
                        }
                    }
                    )
                })
                  , bE = un({
                    "node_modules/@gizmo/runtime/dist/src/utils/emitter.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        var t = class extends EventTarget {
                            emit(i, s) {
                                this.dispatchEvent(new n(i,s))
                            }
                        }
                        ;
                        e.EventEmitter = t;
                        var n = class extends Event {
                            payload;
                            constructor(i, s) {
                                super(i),
                                this.payload = s
                            }
                        }
                        ;
                        e.EventEmitterEvent = n
                    }
                    )
                })
                  , bN = un({
                    "node_modules/@gizmo/runtime/dist/src/channel.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        const t = uA()
                          , n = bE();
                        var i = class {
                            emitter = new n.EventEmitter;
                            emit(s) {
                                this.emitter.emit(s.endpoint, s.payload)
                            }
                            subscribe(s, a) {
                                const o = c => {
                                    const u = c.payload;
                                    a(u)
                                }
                                ;
                                return this.emitter.addEventListener(s, o),
                                new t.Cancellable( () => {
                                    this.emitter.removeEventListener(s, o)
                                }
                                )
                            }
                            once(s, a) {
                                const o = this.subscribe(s, c => {
                                    o.cancel(),
                                    a(c)
                                }
                                );
                                return o
                            }
                        }
                        ;
                        e.ReceiveChannel = i
                    }
                    )
                })
                  , EE = un({
                    "node_modules/@gizmo/runtime/dist/src/utils/observable.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        const t = uA()
                          , n = bE();
                        var i = class {
                            emitter = new n.EventEmitter;
                            send(s) {
                                this.emitter.emit("value", s)
                            }
                            subscribe(s) {
                                const a = o => {
                                    const c = o.payload;
                                    s(c)
                                }
                                ;
                                return this.emitter.addEventListener("value", a),
                                new t.Cancellable( () => {
                                    this.emitter.removeEventListener("value", a)
                                }
                                )
                            }
                        }
                        ;
                        e.PassthroughSubject = i
                    }
                    )
                })
                  , CE = un({
                    "node_modules/@gizmo/runtime/dist/src/tweaks/color.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.colorToHexString = t,
                        e.colorFromString = n;
                        function t(m) {
                            return m.a === 1 ? `#${a(m).toString(16).padStart(6, "0").toUpperCase()}` : `#${o(m).toString(16).padStart(8, "0").toUpperCase()}`
                        }
                        function n(m) {
                            if (m) {
                                if (m.startsWith("rgb(") || m.startsWith("rgba("))
                                    return c(m);
                                if (m.startsWith("#") && (m = m.slice(1)),
                                m.length === 6)
                                    return i(parseInt(m, 16));
                                if (m.length === 8)
                                    return s(parseInt(m, 16))
                            }
                        }
                        function i(m) {
                            m >>>= 0;
                            const v = (m & 16711680) >>> 16
                              , y = (m & 65280) >>> 8
                              , S = m & 255;
                            return {
                                r: v,
                                g: y,
                                b: S,
                                a: 1
                            }
                        }
                        function s(m) {
                            m >>>= 0;
                            const v = (m & 4278190080) >>> 24
                              , y = (m & 16711680) >>> 16
                              , S = (m & 65280) >>> 8
                              , A = m & 255;
                            return {
                                r: v,
                                g: y,
                                b: S,
                                a: A / 255
                            }
                        }
                        function a(m) {
                            let v = (m.r & 255) << 16;
                            return v = v | (m.g & 255) << 8,
                            v = v | m.b & 255,
                            v >>> 0
                        }
                        function o(m) {
                            let v = (m.r & 255) << 24;
                            return v = v | (m.g & 255) << 16,
                            v = v | (m.b & 255) << 8,
                            v = v | m.a * 255 & 255,
                            v >>> 0
                        }
                        function c(m) {
                            if (m) {
                                if (m.startsWith("rgb(") && m.endsWith(")")) {
                                    const v = m.substring(4, m.length - 1).split(", ");
                                    return f(+(v[0] ?? 0), +(v[1] ?? 0), +(v[2] ?? 0), 1)
                                }
                                if (m.startsWith("rgba(") && m.endsWith(")")) {
                                    const v = m.substring(5, m.length - 1).split(", ");
                                    return f(+(v[0] ?? 0), +(v[1] ?? 0), +(v[2] ?? 0), +(v[3] ?? 1))
                                }
                            }
                        }
                        function u(m, v, y) {
                            return Math.max(Math.min(m, y), v)
                        }
                        function f(m, v, y, S) {
                            return {
                                r: u(m, 0, 255),
                                g: u(v, 0, 255),
                                b: u(y, 0, 255),
                                a: u(S, 0, 1)
                            }
                        }
                    }
                    )
                })
                  , EN = un({
                    "node_modules/@gizmo/runtime/dist/src/tweaks/validation.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.processConfig = n;
                        const t = CE();
                        function n(v) {
                            const y = {};
                            for (const [S,A] of Object.entries(v))
                                try {
                                    y[S] = i(S, A)
                                } catch (M) {
                                    console.error("Error validating tweaks config:", M)
                                }
                            return y
                        }
                        function i(v, y) {
                            switch (f(y, v, "name", "string"),
                            f(y, v, "index", "number"),
                            y.type) {
                            case "slider":
                                return s(v, y);
                            case "toggle":
                                return a(v, y);
                            case "color":
                                return o(v, y);
                            case "text":
                                return c(v, y);
                            default:
                                throw new Error(`Invalid config type: ${y.type}`)
                            }
                        }
                        function s(v, y) {
                            if (u(y, v, "value", "number"),
                            u(y, v, "min", "number"),
                            u(y, v, "max", "number"),
                            u(y, v, "step", "number"),
                            y.min >= y.max)
                                throw new Error(`Invalid slider config for "${v}", expected min (${y.min}) < max (${y.max})`);
                            if (y.step <= 0)
                                throw new Error(`Invalid slider config for "${v}", expected step (${y.step}) > 0`);
                            if (y.value < y.min)
                                throw new Error(`Invalid slider config for "${v}", expected value (${y.value}) >= min (${y.min})`);
                            if (y.value > y.max)
                                throw new Error(`Invalid slider config for "${v}", expected value (${y.value}) <= max (${y.max})`);
                            return y
                        }
                        function a(v, y) {
                            return u(y, v, "value", "boolean"),
                            y
                        }
                        function o(v, y) {
                            u(y, v, "value", "string");
                            const S = (0,
                            t.colorFromString)(y.value);
                            if (!S)
                                throw new Error(`Tweaks config has incorrect color value for ${v}, got ${y.value} but expected color hex, rgb(), rgba()`);
                            return {
                                ...y,
                                value: (0,
                                t.colorToHexString)(S)
                            }
                        }
                        function c(v, y) {
                            return u(y, v, "value", "string"),
                            y
                        }
                        function u(v, y, S, A) {
                            const M = v[S];
                            if (typeof M !== A)
                                throw new m(y,S,A,M)
                        }
                        function f(v, y, S, A) {
                            const M = v[S];
                            if (M !== void 0 && typeof M !== A)
                                throw new m(y,S,A,M)
                        }
                        var m = class extends Error {
                            constructor(v, y, S, A) {
                                super(`Tweaks config has incorrect value type for ${v} ${y}, expected ${S} got ${typeof A}`)
                            }
                        }
                    }
                    )
                })
                  , CN = un({
                    "node_modules/@gizmo/runtime/dist/src/tweaks/tweaks.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.createTweaks = s;
                        const t = EE()
                          , n = CE()
                          , i = EN();
                        function s(u, f) {
                            const m = (0,
                            i.processConfig)(u)
                              , v = new a(f,m)
                              , y = {};
                            for (const S of Object.keys(u))
                                y[S] = {
                                    useState: () => v.useState(S)
                                };
                            return [y, m]
                        }
                        var a = class {
                            observable;
                            values;
                            subject = new t.PassthroughSubject;
                            constructor(u, f) {
                                this.observable = u,
                                this.values = o(f),
                                this.observable.subscribe(m => {
                                    for (const [v,y] of Object.entries(m.values)) {
                                        const S = f[v];
                                        if (S === void 0)
                                            return;
                                        const A = c(S, y);
                                        if (A === void 0)
                                            return;
                                        this.values[v] !== A && (this.values[v] = A,
                                        this.subject.send(v))
                                    }
                                }
                                )
                            }
                            getValue(u) {
                                const f = this.values[u];
                                if (f === void 0)
                                    throw new Error(`Tweak key not found in values: ${u}`);
                                return f
                            }
                            useState(u) {
                                const f = window.React;
                                if (!f || !f.useReducer || !f.useEffect)
                                    return console.warn("React not found on window"),
                                    this.getValue(u);
                                const [m,v] = f.useReducer( () => this.getValue(u), this.getValue(u));
                                return f.useEffect( () => {
                                    const y = this.subject.subscribe(S => {
                                        S === u && v()
                                    }
                                    );
                                    return () => {
                                        y.cancel()
                                    }
                                }
                                ),
                                m
                            }
                        }
                        ;
                        function o(u) {
                            const f = {};
                            for (const m of Object.entries(u))
                                f[m[0]] = m[1].value;
                            return f
                        }
                        function c(u, f) {
                            switch (u.type) {
                            case "slider":
                                {
                                    const m = parseFloat(f);
                                    return isNaN(m) ? void 0 : m
                                }
                            case "toggle":
                                return f === "true";
                            case "color":
                                {
                                    const m = (0,
                                    n.colorFromString)(f);
                                    return m ? (0,
                                    n.colorToHexString)(m) : void 0
                                }
                            case "text":
                                return f
                            }
                        }
                    }
                    )
                })
                  , wE = un({
                    "node_modules/@gizmo/runtime/dist/src/index.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        const t = bN()
                          , n = CN()
                          , i = uA()
                          , s = EE();
                        var a = class {
                            receiveChannel = new t.ReceiveChannel;
                            seq = 0;
                            tweaksListener = void 0;
                            tweaksInstance = void 0;
                            tweaksDidWarn = !1;
                            tweaks(o) {
                                if (this.tweaksInstance)
                                    return this.tweaksDidWarn || (this.tweaksDidWarn = !0,
                                    console.warn("tweaks() is expected to only be called once, returning previous value")),
                                    this.tweaksInstance;
                                const c = new s.PassthroughSubject
                                  , [u,f] = (0,
                                n.createTweaks)(o, c);
                                return this.tweaksInstance = u,
                                this.tweaksListener?.cancel(),
                                this.tweaksListener = this.addTweaksListener(f, m => {
                                    c.send(m)
                                }
                                ),
                                u
                            }
                            receiveMessage(o) {
                                return this.receiveChannel.emit(o),
                                Promise.resolve()
                            }
                            performHaptic(o) {
                                typeof o == "object" && "style"in o && typeof o.style == "string" && (o = o.style),
                                window.webkit?.messageHandlers?.hapticHandler?.postMessage(this.makeMessage({
                                    kind: "impact",
                                    style: o
                                }))
                            }
                            generateText(o) {
                                const c = window.webkit?.messageHandlers?.textGenerationHandler;
                                return c ? this.performHandlerRequest(c, {
                                    prompt: o.prompt,
                                    imageData: o.imageData
                                }, 3e4) : Promise.reject(new Error("Not available"))
                            }
                            addShakeListener(o) {
                                const c = window.webkit?.messageHandlers?.deviceMotionHandler;
                                if (!c)
                                    return console.warn("Shake handler not available"),
                                    () => {}
                                    ;
                                const u = this.createSubscription(c, {
                                    type: "shake"
                                }, () => {
                                    o()
                                }
                                );
                                return () => {
                                    u.cancel()
                                }
                            }
                            addMotionListener(o) {
                                const c = window.webkit?.messageHandlers?.deviceMotionHandler;
                                if (!c)
                                    return console.warn("Motion handler not available"),
                                    () => {}
                                    ;
                                const u = this.createSubscription(c, {
                                    type: "motion"
                                }, f => {
                                    f.motion && o(f.motion)
                                }
                                );
                                return () => {
                                    u.cancel()
                                }
                            }
                            addTweaksListener(o, c) {
                                const u = window.webkit?.messageHandlers?.tweaksHandler;
                                return u ? this.createSubscription(u, {
                                    type: "initialize",
                                    config: JSON.stringify(o)
                                }, f => {
                                    c(f)
                                }
                                ) : new i.Cancellable(void 0)
                            }
                            createSubscription(o, c, u) {
                                const f = this.makeSubscriptionMessage(c)
                                  , m = this.receiveChannel.subscribe(f.endpoint, v => {
                                    if (v.error !== void 0) {
                                        console.error(`Subscription error: ${v.error}`);
                                        return
                                    }
                                    u(v)
                                }
                                );
                                return o.postMessage(f),
                                new i.Cancellable( () => {
                                    m.cancel(),
                                    o.postMessage({
                                        endpoint: f.endpoint,
                                        payload: "unsubscribe"
                                    })
                                }
                                )
                            }
                            performHandlerRequest(o, c, u) {
                                return new Promise( (f, m) => {
                                    const v = this.makeMessage(c)
                                      , y = this.receiveChannel.once(v.endpoint, A => {
                                        S.cancel(),
                                        A.error !== void 0 ? m(new Error(`Error: ${A.error}`)) : f(A)
                                    }
                                    )
                                      , S = (0,
                                    i.setTimeoutCancellable)( () => {
                                        y.cancel(),
                                        m(new Error("Request timed out"))
                                    }
                                    , u);
                                    o.postMessage(v)
                                }
                                )
                            }
                            makeMessage(o) {
                                return {
                                    endpoint: (this.seq++).toString(),
                                    payload: o
                                }
                            }
                            makeSubscriptionMessage(o) {
                                return {
                                    endpoint: (this.seq++).toString(),
                                    payload: {
                                        subscribe: o
                                    }
                                }
                            }
                        }
                        ;
                        e.gizmoRuntime = new a
                    }
                    )
                })
                  , wN = un({
                    "node_modules/react/cjs/react.production.js": (e => {
                        var t = Symbol.for("react.transitional.element")
                          , n = Symbol.for("react.portal")
                          , i = Symbol.for("react.fragment")
                          , s = Symbol.for("react.strict_mode")
                          , a = Symbol.for("react.profiler")
                          , o = Symbol.for("react.consumer")
                          , c = Symbol.for("react.context")
                          , u = Symbol.for("react.forward_ref")
                          , f = Symbol.for("react.suspense")
                          , m = Symbol.for("react.memo")
                          , v = Symbol.for("react.lazy")
                          , y = Symbol.for("react.activity")
                          , S = Symbol.iterator;
                        function A(H) {
                            return H === null || typeof H != "object" ? null : (H = S && H[S] || H["@@iterator"],
                            typeof H == "function" ? H : null)
                        }
                        var M = {
                            isMounted: function() {
                                return !1
                            },
                            enqueueForceUpdate: function() {},
                            enqueueReplaceState: function() {},
                            enqueueSetState: function() {}
                        }
                          , x = Object.assign
                          , T = {};
                        function D(H, ie, se) {
                            this.props = H,
                            this.context = ie,
                            this.refs = T,
                            this.updater = se || M
                        }
                        D.prototype.isReactComponent = {},
                        D.prototype.setState = function(H, ie) {
                            if (typeof H != "object" && typeof H != "function" && H != null)
                                throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
                            this.updater.enqueueSetState(this, H, ie, "setState")
                        }
                        ,
                        D.prototype.forceUpdate = function(H) {
                            this.updater.enqueueForceUpdate(this, H, "forceUpdate")
                        }
                        ;
                        function w() {}
                        w.prototype = D.prototype;
                        function U(H, ie, se) {
                            this.props = H,
                            this.context = ie,
                            this.refs = T,
                            this.updater = se || M
                        }
                        var O = U.prototype = new w;
                        O.constructor = U,
                        x(O, D.prototype),
                        O.isPureReactComponent = !0;
                        var L = Array.isArray;
                        function N() {}
                        var z = {
                            H: null,
                            A: null,
                            T: null,
                            S: null
                        }
                          , I = Object.prototype.hasOwnProperty;
                        function B(H, ie, se) {
                            var K = se.ref;
                            return {
                                $$typeof: t,
                                type: H,
                                key: ie,
                                ref: K !== void 0 ? K : null,
                                props: se
                            }
                        }
                        function G(H, ie) {
                            return B(H.type, ie, H.props)
                        }
                        function X(H) {
                            return typeof H == "object" && H !== null && H.$$typeof === t
                        }
                        function q(H) {
                            var ie = {
                                "=": "=0",
                                ":": "=2"
                            };
                            return "$" + H.replace(/[=:]/g, function(se) {
                                return ie[se]
                            })
                        }
                        var Q = /\/+/g;
                        function oe(H, ie) {
                            return typeof H == "object" && H !== null && H.key != null ? q("" + H.key) : ie.toString(36)
                        }
                        function k(H) {
                            switch (H.status) {
                            case "fulfilled":
                                return H.value;
                            case "rejected":
                                throw H.reason;
                            default:
                                switch (typeof H.status == "string" ? H.then(N, N) : (H.status = "pending",
                                H.then(function(ie) {
                                    H.status === "pending" && (H.status = "fulfilled",
                                    H.value = ie)
                                }, function(ie) {
                                    H.status === "pending" && (H.status = "rejected",
                                    H.reason = ie)
                                })),
                                H.status) {
                                case "fulfilled":
                                    return H.value;
                                case "rejected":
                                    throw H.reason
                                }
                            }
                            throw H
                        }
                        function W(H, ie, se, K, le) {
                            var ue = typeof H;
                            (ue === "undefined" || ue === "boolean") && (H = null);
                            var de = !1;
                            if (H === null)
                                de = !0;
                            else
                                switch (ue) {
                                case "bigint":
                                case "string":
                                case "number":
                                    de = !0;
                                    break;
                                case "object":
                                    switch (H.$$typeof) {
                                    case t:
                                    case n:
                                        de = !0;
                                        break;
                                    case v:
                                        return de = H._init,
                                        W(de(H._payload), ie, se, K, le)
                                    }
                                }
                            if (de)
                                return le = le(H),
                                de = K === "" ? "." + oe(H, 0) : K,
                                L(le) ? (se = "",
                                de != null && (se = de.replace(Q, "$&/") + "/"),
                                W(le, ie, se, "", function(Ee) {
                                    return Ee
                                })) : le != null && (X(le) && (le = G(le, se + (le.key == null || H && H.key === le.key ? "" : ("" + le.key).replace(Q, "$&/") + "/") + de)),
                                ie.push(le)),
                                1;
                            de = 0;
                            var qe = K === "" ? "." : K + ":";
                            if (L(H))
                                for (var ze = 0; ze < H.length; ze++)
                                    K = H[ze],
                                    ue = qe + oe(K, ze),
                                    de += W(K, ie, se, ue, le);
                            else if (ze = A(H),
                            typeof ze == "function")
                                for (H = ze.call(H),
                                ze = 0; !(K = H.next()).done; )
                                    K = K.value,
                                    ue = qe + oe(K, ze++),
                                    de += W(K, ie, se, ue, le);
                            else if (ue === "object") {
                                if (typeof H.then == "function")
                                    return W(k(H), ie, se, K, le);
                                throw ie = String(H),
                                Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(H).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.")
                            }
                            return de
                        }
                        function V(H, ie, se) {
                            if (H == null)
                                return H;
                            var K = []
                              , le = 0;
                            return W(H, K, "", "", function(ue) {
                                return ie.call(se, ue, le++)
                            }),
                            K
                        }
                        function Z(H) {
                            if (H._status === -1) {
                                var ie = H._result;
                                ie = ie(),
                                ie.then(function(se) {
                                    (H._status === 0 || H._status === -1) && (H._status = 1,
                                    H._result = se)
                                }, function(se) {
                                    (H._status === 0 || H._status === -1) && (H._status = 2,
                                    H._result = se)
                                }),
                                H._status === -1 && (H._status = 0,
                                H._result = ie)
                            }
                            if (H._status === 1)
                                return H._result.default;
                            throw H._result
                        }
                        var j = typeof reportError == "function" ? reportError : function(H) {
                            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                var ie = new window.ErrorEvent("error",{
                                    bubbles: !0,
                                    cancelable: !0,
                                    message: typeof H == "object" && H !== null && typeof H.message == "string" ? String(H.message) : String(H),
                                    error: H
                                });
                                if (!window.dispatchEvent(ie))
                                    return
                            } else if (typeof process == "object" && typeof process.emit == "function") {
                                process.emit("uncaughtException", H);
                                return
                            }
                            console.error(H)
                        }
                          , ee = {
                            map: V,
                            forEach: function(H, ie, se) {
                                V(H, function() {
                                    ie.apply(this, arguments)
                                }, se)
                            },
                            count: function(H) {
                                var ie = 0;
                                return V(H, function() {
                                    ie++
                                }),
                                ie
                            },
                            toArray: function(H) {
                                return V(H, function(ie) {
                                    return ie
                                }) || []
                            },
                            only: function(H) {
                                if (!X(H))
                                    throw Error("React.Children.only expected to receive a single React element child.");
                                return H
                            }
                        };
                        e.Activity = y,
                        e.Children = ee,
                        e.Component = D,
                        e.Fragment = i,
                        e.Profiler = a,
                        e.PureComponent = U,
                        e.StrictMode = s,
                        e.Suspense = f,
                        e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = z,
                        e.__COMPILER_RUNTIME = {
                            __proto__: null,
                            c: function(H) {
                                return z.H.useMemoCache(H)
                            }
                        },
                        e.cache = function(H) {
                            return function() {
                                return H.apply(null, arguments)
                            }
                        }
                        ,
                        e.cacheSignal = function() {
                            return null
                        }
                        ,
                        e.cloneElement = function(H, ie, se) {
                            if (H == null)
                                throw Error("The argument must be a React element, but you passed " + H + ".");
                            var K = x({}, H.props)
                              , le = H.key;
                            if (ie != null)
                                for (ue in ie.key !== void 0 && (le = "" + ie.key),
                                ie)
                                    !I.call(ie, ue) || ue === "key" || ue === "__self" || ue === "__source" || ue === "ref" && ie.ref === void 0 || (K[ue] = ie[ue]);
                            var ue = arguments.length - 2;
                            if (ue === 1)
                                K.children = se;
                            else if (1 < ue) {
                                for (var de = Array(ue), qe = 0; qe < ue; qe++)
                                    de[qe] = arguments[qe + 2];
                                K.children = de
                            }
                            return B(H.type, le, K)
                        }
                        ,
                        e.createContext = function(H) {
                            return H = {
                                $$typeof: c,
                                _currentValue: H,
                                _currentValue2: H,
                                _threadCount: 0,
                                Provider: null,
                                Consumer: null
                            },
                            H.Provider = H,
                            H.Consumer = {
                                $$typeof: o,
                                _context: H
                            },
                            H
                        }
                        ,
                        e.createElement = function(H, ie, se) {
                            var K, le = {}, ue = null;
                            if (ie != null)
                                for (K in ie.key !== void 0 && (ue = "" + ie.key),
                                ie)
                                    I.call(ie, K) && K !== "key" && K !== "__self" && K !== "__source" && (le[K] = ie[K]);
                            var de = arguments.length - 2;
                            if (de === 1)
                                le.children = se;
                            else if (1 < de) {
                                for (var qe = Array(de), ze = 0; ze < de; ze++)
                                    qe[ze] = arguments[ze + 2];
                                le.children = qe
                            }
                            if (H && H.defaultProps)
                                for (K in de = H.defaultProps,
                                de)
                                    le[K] === void 0 && (le[K] = de[K]);
                            return B(H, ue, le)
                        }
                        ,
                        e.createRef = function() {
                            return {
                                current: null
                            }
                        }
                        ,
                        e.forwardRef = function(H) {
                            return {
                                $$typeof: u,
                                render: H
                            }
                        }
                        ,
                        e.isValidElement = X,
                        e.lazy = function(H) {
                            return {
                                $$typeof: v,
                                _payload: {
                                    _status: -1,
                                    _result: H
                                },
                                _init: Z
                            }
                        }
                        ,
                        e.memo = function(H, ie) {
                            return {
                                $$typeof: m,
                                type: H,
                                compare: ie === void 0 ? null : ie
                            }
                        }
                        ,
                        e.startTransition = function(H) {
                            var ie = z.T
                              , se = {};
                            z.T = se;
                            try {
                                var K = H()
                                  , le = z.S;
                                le !== null && le(se, K),
                                typeof K == "object" && K !== null && typeof K.then == "function" && K.then(N, j)
                            } catch (ue) {
                                j(ue)
                            } finally {
                                ie !== null && se.types !== null && (ie.types = se.types),
                                z.T = ie
                            }
                        }
                        ,
                        e.unstable_useCacheRefresh = function() {
                            return z.H.useCacheRefresh()
                        }
                        ,
                        e.use = function(H) {
                            return z.H.use(H)
                        }
                        ,
                        e.useActionState = function(H, ie, se) {
                            return z.H.useActionState(H, ie, se)
                        }
                        ,
                        e.useCallback = function(H, ie) {
                            return z.H.useCallback(H, ie)
                        }
                        ,
                        e.useContext = function(H) {
                            return z.H.useContext(H)
                        }
                        ,
                        e.useDebugValue = function() {}
                        ,
                        e.useDeferredValue = function(H, ie) {
                            return z.H.useDeferredValue(H, ie)
                        }
                        ,
                        e.useEffect = function(H, ie) {
                            return z.H.useEffect(H, ie)
                        }
                        ,
                        e.useEffectEvent = function(H) {
                            return z.H.useEffectEvent(H)
                        }
                        ,
                        e.useId = function() {
                            return z.H.useId()
                        }
                        ,
                        e.useImperativeHandle = function(H, ie, se) {
                            return z.H.useImperativeHandle(H, ie, se)
                        }
                        ,
                        e.useInsertionEffect = function(H, ie) {
                            return z.H.useInsertionEffect(H, ie)
                        }
                        ,
                        e.useLayoutEffect = function(H, ie) {
                            return z.H.useLayoutEffect(H, ie)
                        }
                        ,
                        e.useMemo = function(H, ie) {
                            return z.H.useMemo(H, ie)
                        }
                        ,
                        e.useOptimistic = function(H, ie) {
                            return z.H.useOptimistic(H, ie)
                        }
                        ,
                        e.useReducer = function(H, ie, se) {
                            return z.H.useReducer(H, ie, se)
                        }
                        ,
                        e.useRef = function(H) {
                            return z.H.useRef(H)
                        }
                        ,
                        e.useState = function(H) {
                            return z.H.useState(H)
                        }
                        ,
                        e.useSyncExternalStore = function(H, ie, se) {
                            return z.H.useSyncExternalStore(H, ie, se)
                        }
                        ,
                        e.useTransition = function() {
                            return z.H.useTransition()
                        }
                        ,
                        e.version = "19.2.0"
                    }
                    )
                })
                  , cp = un({
                    "node_modules/react/index.js": ( (e, t) => {
                        t.exports = wN()
                    }
                    )
                })
                  , DN = un({
                    "node_modules/react-dom/node_modules/scheduler/cjs/scheduler.production.js": (e => {
                        function t(k, W) {
                            var V = k.length;
                            k.push(W);
                            e: for (; 0 < V; ) {
                                var Z = V - 1 >>> 1
                                  , j = k[Z];
                                if (0 < s(j, W))
                                    k[Z] = W,
                                    k[V] = j,
                                    V = Z;
                                else
                                    break e
                            }
                        }
                        function n(k) {
                            return k.length === 0 ? null : k[0]
                        }
                        function i(k) {
                            if (k.length === 0)
                                return null;
                            var W = k[0]
                              , V = k.pop();
                            if (V !== W) {
                                k[0] = V;
                                e: for (var Z = 0, j = k.length, ee = j >>> 1; Z < ee; ) {
                                    var H = 2 * (Z + 1) - 1
                                      , ie = k[H]
                                      , se = H + 1
                                      , K = k[se];
                                    if (0 > s(ie, V))
                                        se < j && 0 > s(K, ie) ? (k[Z] = K,
                                        k[se] = V,
                                        Z = se) : (k[Z] = ie,
                                        k[H] = V,
                                        Z = H);
                                    else if (se < j && 0 > s(K, V))
                                        k[Z] = K,
                                        k[se] = V,
                                        Z = se;
                                    else
                                        break e
                                }
                            }
                            return W
                        }
                        function s(k, W) {
                            var V = k.sortIndex - W.sortIndex;
                            return V !== 0 ? V : k.id - W.id
                        }
                        if (typeof performance == "object" && typeof performance.now == "function") {
                            var a = performance;
                            e.unstable_now = function() {
                                return a.now()
                            }
                        } else {
                            var o = Date
                              , c = o.now();
                            e.unstable_now = function() {
                                return o.now() - c
                            }
                        }
                        var u = []
                          , f = []
                          , m = 1
                          , v = null
                          , y = 3
                          , S = !1
                          , A = !1
                          , M = !1
                          , x = !1
                          , T = typeof setTimeout == "function" ? setTimeout : null
                          , D = typeof clearTimeout == "function" ? clearTimeout : null
                          , w = typeof setImmediate < "u" ? setImmediate : null;
                        function U(k) {
                            for (var W = n(f); W !== null; ) {
                                if (W.callback === null)
                                    i(f);
                                else if (W.startTime <= k)
                                    i(f),
                                    W.sortIndex = W.expirationTime,
                                    t(u, W);
                                else
                                    break;
                                W = n(f)
                            }
                        }
                        function O(k) {
                            if (M = !1,
                            U(k),
                            !A)
                                if (n(u) !== null)
                                    A = !0,
                                    L || (L = !0,
                                    X());
                                else {
                                    var W = n(f);
                                    W !== null && oe(O, W.startTime - k)
                                }
                        }
                        var L = !1
                          , N = -1
                          , z = 5
                          , I = -1;
                        function B() {
                            return x ? !0 : !(e.unstable_now() - I < z)
                        }
                        function G() {
                            if (x = !1,
                            L) {
                                var k = e.unstable_now();
                                I = k;
                                var W = !0;
                                try {
                                    e: {
                                        A = !1,
                                        M && (M = !1,
                                        D(N),
                                        N = -1),
                                        S = !0;
                                        var V = y;
                                        try {
                                            t: {
                                                for (U(k),
                                                v = n(u); v !== null && !(v.expirationTime > k && B()); ) {
                                                    var Z = v.callback;
                                                    if (typeof Z == "function") {
                                                        v.callback = null,
                                                        y = v.priorityLevel;
                                                        var j = Z(v.expirationTime <= k);
                                                        if (k = e.unstable_now(),
                                                        typeof j == "function") {
                                                            v.callback = j,
                                                            U(k),
                                                            W = !0;
                                                            break t
                                                        }
                                                        v === n(u) && i(u),
                                                        U(k)
                                                    } else
                                                        i(u);
                                                    v = n(u)
                                                }
                                                if (v !== null)
                                                    W = !0;
                                                else {
                                                    var ee = n(f);
                                                    ee !== null && oe(O, ee.startTime - k),
                                                    W = !1
                                                }
                                            }
                                            break e
                                        } finally {
                                            v = null,
                                            y = V,
                                            S = !1
                                        }
                                        W = void 0
                                    }
                                } finally {
                                    W ? X() : L = !1
                                }
                            }
                        }
                        var X;
                        if (typeof w == "function")
                            X = function() {
                                w(G)
                            }
                            ;
                        else if (typeof MessageChannel < "u") {
                            var q = new MessageChannel
                              , Q = q.port2;
                            q.port1.onmessage = G,
                            X = function() {
                                Q.postMessage(null)
                            }
                        } else
                            X = function() {
                                T(G, 0)
                            }
                            ;
                        function oe(k, W) {
                            N = T(function() {
                                k(e.unstable_now())
                            }, W)
                        }
                        e.unstable_IdlePriority = 5,
                        e.unstable_ImmediatePriority = 1,
                        e.unstable_LowPriority = 4,
                        e.unstable_NormalPriority = 3,
                        e.unstable_Profiling = null,
                        e.unstable_UserBlockingPriority = 2,
                        e.unstable_cancelCallback = function(k) {
                            k.callback = null
                        }
                        ,
                        e.unstable_forceFrameRate = function(k) {
                            0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : z = 0 < k ? Math.floor(1e3 / k) : 5
                        }
                        ,
                        e.unstable_getCurrentPriorityLevel = function() {
                            return y
                        }
                        ,
                        e.unstable_next = function(k) {
                            switch (y) {
                            case 1:
                            case 2:
                            case 3:
                                var W = 3;
                                break;
                            default:
                                W = y
                            }
                            var V = y;
                            y = W;
                            try {
                                return k()
                            } finally {
                                y = V
                            }
                        }
                        ,
                        e.unstable_requestPaint = function() {
                            x = !0
                        }
                        ,
                        e.unstable_runWithPriority = function(k, W) {
                            switch (k) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                k = 3
                            }
                            var V = y;
                            y = k;
                            try {
                                return W()
                            } finally {
                                y = V
                            }
                        }
                        ,
                        e.unstable_scheduleCallback = function(k, W, V) {
                            var Z = e.unstable_now();
                            switch (typeof V == "object" && V !== null ? (V = V.delay,
                            V = typeof V == "number" && 0 < V ? Z + V : Z) : V = Z,
                            k) {
                            case 1:
                                var j = -1;
                                break;
                            case 2:
                                j = 250;
                                break;
                            case 5:
                                j = 1073741823;
                                break;
                            case 4:
                                j = 1e4;
                                break;
                            default:
                                j = 5e3
                            }
                            return j = V + j,
                            k = {
                                id: m++,
                                callback: W,
                                priorityLevel: k,
                                startTime: V,
                                expirationTime: j,
                                sortIndex: -1
                            },
                            V > Z ? (k.sortIndex = V,
                            t(f, k),
                            n(u) === null && k === n(f) && (M ? (D(N),
                            N = -1) : M = !0,
                            oe(O, V - Z))) : (k.sortIndex = j,
                            t(u, k),
                            A || S || (A = !0,
                            L || (L = !0,
                            X()))),
                            k
                        }
                        ,
                        e.unstable_shouldYield = B,
                        e.unstable_wrapCallback = function(k) {
                            var W = y;
                            return function() {
                                var V = y;
                                y = W;
                                try {
                                    return k.apply(this, arguments)
                                } finally {
                                    y = V
                                }
                            }
                        }
                    }
                    )
                })
                  , RN = un({
                    "node_modules/react-dom/node_modules/scheduler/index.js": ( (e, t) => {
                        t.exports = DN()
                    }
                    )
                })
                  , UN = un({
                    "node_modules/react-dom/cjs/react-dom.production.js": (e => {
                        var t = cp();
                        function n(f) {
                            var m = "https://react.dev/errors/" + f;
                            if (1 < arguments.length) {
                                m += "?args[]=" + encodeURIComponent(arguments[1]);
                                for (var v = 2; v < arguments.length; v++)
                                    m += "&args[]=" + encodeURIComponent(arguments[v])
                            }
                            return "Minified React error #" + f + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                        }
                        function i() {}
                        var s = {
                            d: {
                                f: i,
                                r: function() {
                                    throw Error(n(522))
                                },
                                D: i,
                                C: i,
                                L: i,
                                m: i,
                                X: i,
                                S: i,
                                M: i
                            },
                            p: 0,
                            findDOMNode: null
                        }
                          , a = Symbol.for("react.portal");
                        function o(f, m, v) {
                            var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                            return {
                                $$typeof: a,
                                key: y == null ? null : "" + y,
                                children: f,
                                containerInfo: m,
                                implementation: v
                            }
                        }
                        var c = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
                        function u(f, m) {
                            if (f === "font")
                                return "";
                            if (typeof m == "string")
                                return m === "use-credentials" ? m : ""
                        }
                        e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = s,
                        e.createPortal = function(f, m) {
                            var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
                            if (!m || m.nodeType !== 1 && m.nodeType !== 9 && m.nodeType !== 11)
                                throw Error(n(299));
                            return o(f, m, null, v)
                        }
                        ,
                        e.flushSync = function(f) {
                            var m = c.T
                              , v = s.p;
                            try {
                                if (c.T = null,
                                s.p = 2,
                                f)
                                    return f()
                            } finally {
                                c.T = m,
                                s.p = v,
                                s.d.f()
                            }
                        }
                        ,
                        e.preconnect = function(f, m) {
                            typeof f == "string" && (m ? (m = m.crossOrigin,
                            m = typeof m == "string" ? m === "use-credentials" ? m : "" : void 0) : m = null,
                            s.d.C(f, m))
                        }
                        ,
                        e.prefetchDNS = function(f) {
                            typeof f == "string" && s.d.D(f)
                        }
                        ,
                        e.preinit = function(f, m) {
                            if (typeof f == "string" && m && typeof m.as == "string") {
                                var v = m.as
                                  , y = u(v, m.crossOrigin)
                                  , S = typeof m.integrity == "string" ? m.integrity : void 0
                                  , A = typeof m.fetchPriority == "string" ? m.fetchPriority : void 0;
                                v === "style" ? s.d.S(f, typeof m.precedence == "string" ? m.precedence : void 0, {
                                    crossOrigin: y,
                                    integrity: S,
                                    fetchPriority: A
                                }) : v === "script" && s.d.X(f, {
                                    crossOrigin: y,
                                    integrity: S,
                                    fetchPriority: A,
                                    nonce: typeof m.nonce == "string" ? m.nonce : void 0
                                })
                            }
                        }
                        ,
                        e.preinitModule = function(f, m) {
                            if (typeof f == "string")
                                if (typeof m == "object" && m !== null) {
                                    if (m.as == null || m.as === "script") {
                                        var v = u(m.as, m.crossOrigin);
                                        s.d.M(f, {
                                            crossOrigin: v,
                                            integrity: typeof m.integrity == "string" ? m.integrity : void 0,
                                            nonce: typeof m.nonce == "string" ? m.nonce : void 0
                                        })
                                    }
                                } else
                                    m ?? s.d.M(f)
                        }
                        ,
                        e.preload = function(f, m) {
                            if (typeof f == "string" && typeof m == "object" && m !== null && typeof m.as == "string") {
                                var v = m.as
                                  , y = u(v, m.crossOrigin);
                                s.d.L(f, v, {
                                    crossOrigin: y,
                                    integrity: typeof m.integrity == "string" ? m.integrity : void 0,
                                    nonce: typeof m.nonce == "string" ? m.nonce : void 0,
                                    type: typeof m.type == "string" ? m.type : void 0,
                                    fetchPriority: typeof m.fetchPriority == "string" ? m.fetchPriority : void 0,
                                    referrerPolicy: typeof m.referrerPolicy == "string" ? m.referrerPolicy : void 0,
                                    imageSrcSet: typeof m.imageSrcSet == "string" ? m.imageSrcSet : void 0,
                                    imageSizes: typeof m.imageSizes == "string" ? m.imageSizes : void 0,
                                    media: typeof m.media == "string" ? m.media : void 0
                                })
                            }
                        }
                        ,
                        e.preloadModule = function(f, m) {
                            if (typeof f == "string")
                                if (m) {
                                    var v = u(m.as, m.crossOrigin);
                                    s.d.m(f, {
                                        as: typeof m.as == "string" && m.as !== "script" ? m.as : void 0,
                                        crossOrigin: v,
                                        integrity: typeof m.integrity == "string" ? m.integrity : void 0
                                    })
                                } else
                                    s.d.m(f)
                        }
                        ,
                        e.requestFormReset = function(f) {
                            s.d.r(f)
                        }
                        ,
                        e.unstable_batchedUpdates = function(f, m) {
                            return f(m)
                        }
                        ,
                        e.useFormState = function(f, m, v) {
                            return c.H.useFormState(f, m, v)
                        }
                        ,
                        e.useFormStatus = function() {
                            return c.H.useHostTransitionStatus()
                        }
                        ,
                        e.version = "19.2.0"
                    }
                    )
                })
                  , ON = un({
                    "node_modules/react-dom/index.js": ( (e, t) => {
                        function n() {
                            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                                try {
                                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                                } catch (i) {
                                    console.error(i)
                                }
                        }
                        n(),
                        t.exports = UN()
                    }
                    )
                })
                  , NN = un({
                    "node_modules/react-dom/cjs/react-dom-client.production.js": (e => {
                        var t = RN()
                          , n = cp()
                          , i = ON();
                        function s(r) {
                            var l = "https://react.dev/errors/" + r;
                            if (1 < arguments.length) {
                                l += "?args[]=" + encodeURIComponent(arguments[1]);
                                for (var p = 2; p < arguments.length; p++)
                                    l += "&args[]=" + encodeURIComponent(arguments[p])
                            }
                            return "Minified React error #" + r + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                        }
                        function a(r) {
                            return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11)
                        }
                        function o(r) {
                            var l = r
                              , p = r;
                            if (r.alternate)
                                for (; l.return; )
                                    l = l.return;
                            else {
                                r = l;
                                do
                                    l = r,
                                    (l.flags & 4098) !== 0 && (p = l.return),
                                    r = l.return;
                                while (r)
                            }
                            return l.tag === 3 ? p : null
                        }
                        function c(r) {
                            if (r.tag === 13) {
                                var l = r.memoizedState;
                                if (l === null && (r = r.alternate,
                                r !== null && (l = r.memoizedState)),
                                l !== null)
                                    return l.dehydrated
                            }
                            return null
                        }
                        function u(r) {
                            if (r.tag === 31) {
                                var l = r.memoizedState;
                                if (l === null && (r = r.alternate,
                                r !== null && (l = r.memoizedState)),
                                l !== null)
                                    return l.dehydrated
                            }
                            return null
                        }
                        function f(r) {
                            if (o(r) !== r)
                                throw Error(s(188))
                        }
                        function m(r) {
                            var l = r.alternate;
                            if (!l) {
                                if (l = o(r),
                                l === null)
                                    throw Error(s(188));
                                return l !== r ? null : r
                            }
                            for (var p = r, g = l; ; ) {
                                var b = p.return;
                                if (b === null)
                                    break;
                                var C = b.alternate;
                                if (C === null) {
                                    if (g = b.return,
                                    g !== null) {
                                        p = g;
                                        continue
                                    }
                                    break
                                }
                                if (b.child === C.child) {
                                    for (C = b.child; C; ) {
                                        if (C === p)
                                            return f(b),
                                            r;
                                        if (C === g)
                                            return f(b),
                                            l;
                                        C = C.sibling
                                    }
                                    throw Error(s(188))
                                }
                                if (p.return !== g.return)
                                    p = b,
                                    g = C;
                                else {
                                    for (var F = !1, J = b.child; J; ) {
                                        if (J === p) {
                                            F = !0,
                                            p = b,
                                            g = C;
                                            break
                                        }
                                        if (J === g) {
                                            F = !0,
                                            g = b,
                                            p = C;
                                            break
                                        }
                                        J = J.sibling
                                    }
                                    if (!F) {
                                        for (J = C.child; J; ) {
                                            if (J === p) {
                                                F = !0,
                                                p = C,
                                                g = b;
                                                break
                                            }
                                            if (J === g) {
                                                F = !0,
                                                g = C,
                                                p = b;
                                                break
                                            }
                                            J = J.sibling
                                        }
                                        if (!F)
                                            throw Error(s(189))
                                    }
                                }
                                if (p.alternate !== g)
                                    throw Error(s(190))
                            }
                            if (p.tag !== 3)
                                throw Error(s(188));
                            return p.stateNode.current === p ? r : l
                        }
                        function v(r) {
                            var l = r.tag;
                            if (l === 5 || l === 26 || l === 27 || l === 6)
                                return r;
                            for (r = r.child; r !== null; ) {
                                if (l = v(r),
                                l !== null)
                                    return l;
                                r = r.sibling
                            }
                            return null
                        }
                        var y = Object.assign
                          , S = Symbol.for("react.element")
                          , A = Symbol.for("react.transitional.element")
                          , M = Symbol.for("react.portal")
                          , x = Symbol.for("react.fragment")
                          , T = Symbol.for("react.strict_mode")
                          , D = Symbol.for("react.profiler")
                          , w = Symbol.for("react.consumer")
                          , U = Symbol.for("react.context")
                          , O = Symbol.for("react.forward_ref")
                          , L = Symbol.for("react.suspense")
                          , N = Symbol.for("react.suspense_list")
                          , z = Symbol.for("react.memo")
                          , I = Symbol.for("react.lazy")
                          , B = Symbol.for("react.activity")
                          , G = Symbol.for("react.memo_cache_sentinel")
                          , X = Symbol.iterator;
                        function q(r) {
                            return r === null || typeof r != "object" ? null : (r = X && r[X] || r["@@iterator"],
                            typeof r == "function" ? r : null)
                        }
                        var Q = Symbol.for("react.client.reference");
                        function oe(r) {
                            if (r == null)
                                return null;
                            if (typeof r == "function")
                                return r.$$typeof === Q ? null : r.displayName || r.name || null;
                            if (typeof r == "string")
                                return r;
                            switch (r) {
                            case x:
                                return "Fragment";
                            case D:
                                return "Profiler";
                            case T:
                                return "StrictMode";
                            case L:
                                return "Suspense";
                            case N:
                                return "SuspenseList";
                            case B:
                                return "Activity"
                            }
                            if (typeof r == "object")
                                switch (r.$$typeof) {
                                case M:
                                    return "Portal";
                                case U:
                                    return r.displayName || "Context";
                                case w:
                                    return (r._context.displayName || "Context") + ".Consumer";
                                case O:
                                    var l = r.render;
                                    return r = r.displayName,
                                    r || (r = l.displayName || l.name || "",
                                    r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"),
                                    r;
                                case z:
                                    return l = r.displayName || null,
                                    l !== null ? l : oe(r.type) || "Memo";
                                case I:
                                    l = r._payload,
                                    r = r._init;
                                    try {
                                        return oe(r(l))
                                    } catch {}
                                }
                            return null
                        }
                        var k = Array.isArray
                          , W = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                          , V = i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                          , Z = {
                            pending: !1,
                            data: null,
                            method: null,
                            action: null
                        }
                          , j = []
                          , ee = -1;
                        function H(r) {
                            return {
                                current: r
                            }
                        }
                        function ie(r) {
                            0 > ee || (r.current = j[ee],
                            j[ee] = null,
                            ee--)
                        }
                        function se(r, l) {
                            ee++,
                            j[ee] = r.current,
                            r.current = l
                        }
                        var K = H(null)
                          , le = H(null)
                          , ue = H(null)
                          , de = H(null);
                        function qe(r, l) {
                            switch (se(ue, l),
                            se(le, r),
                            se(K, null),
                            l.nodeType) {
                            case 9:
                            case 11:
                                r = (r = l.documentElement) && (r = r.namespaceURI) ? Zb(r) : 0;
                                break;
                            default:
                                if (r = l.tagName,
                                l = l.namespaceURI)
                                    l = Zb(l),
                                    r = Kb(l, r);
                                else
                                    switch (r) {
                                    case "svg":
                                        r = 1;
                                        break;
                                    case "math":
                                        r = 2;
                                        break;
                                    default:
                                        r = 0
                                    }
                            }
                            ie(K),
                            se(K, r)
                        }
                        function ze() {
                            ie(K),
                            ie(le),
                            ie(ue)
                        }
                        function Ee(r) {
                            r.memoizedState !== null && se(de, r);
                            var l = K.current
                              , p = Kb(l, r.type);
                            l !== p && (se(le, r),
                            se(K, p))
                        }
                        function re(r) {
                            le.current === r && (ie(K),
                            ie(le)),
                            de.current === r && (ie(de),
                            Yv._currentValue = Z)
                        }
                        var Le, he;
                        function ye(r) {
                            if (Le === void 0)
                                try {
                                    throw Error()
                                } catch (p) {
                                    var l = p.stack.trim().match(/\n( *(at )?)/);
                                    Le = l && l[1] || "",
                                    he = -1 < p.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < p.stack.indexOf("@") ? "@unknown:0:0" : ""
                                }
                            return `
` + Le + r + he
                        }
                        var xe = !1;
                        function ge(r, l) {
                            if (!r || xe)
                                return "";
                            xe = !0;
                            var p = Error.prepareStackTrace;
                            Error.prepareStackTrace = void 0;
                            try {
                                var g = {
                                    DetermineComponentFrameRoot: function() {
                                        try {
                                            if (l) {
                                                var st = function() {
                                                    throw Error()
                                                };
                                                if (Object.defineProperty(st.prototype, "props", {
                                                    set: function() {
                                                        throw Error()
                                                    }
                                                }),
                                                typeof Reflect == "object" && Reflect.construct) {
                                                    try {
                                                        Reflect.construct(st, [])
                                                    } catch (Ye) {
                                                        var Ve = Ye
                                                    }
                                                    Reflect.construct(r, [], st)
                                                } else {
                                                    try {
                                                        st.call()
                                                    } catch (Ye) {
                                                        Ve = Ye
                                                    }
                                                    r.call(st.prototype)
                                                }
                                            } else {
                                                try {
                                                    throw Error()
                                                } catch (Ye) {
                                                    Ve = Ye
                                                }
                                                (st = r()) && typeof st.catch == "function" && st.catch(function() {})
                                            }
                                        } catch (Ye) {
                                            if (Ye && Ve && typeof Ye.stack == "string")
                                                return [Ye.stack, Ve.stack]
                                        }
                                        return [null, null]
                                    }
                                };
                                g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                                var b = Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot, "name");
                                b && b.configurable && Object.defineProperty(g.DetermineComponentFrameRoot, "name", {
                                    value: "DetermineComponentFrameRoot"
                                });
                                var C = g.DetermineComponentFrameRoot()
                                  , F = C[0]
                                  , J = C[1];
                                if (F && J) {
                                    var ve = F.split(`
`)
                                      , Pe = J.split(`
`);
                                    for (b = g = 0; g < ve.length && !ve[g].includes("DetermineComponentFrameRoot"); )
                                        g++;
                                    for (; b < Pe.length && !Pe[b].includes("DetermineComponentFrameRoot"); )
                                        b++;
                                    if (g === ve.length || b === Pe.length)
                                        for (g = ve.length - 1,
                                        b = Pe.length - 1; 1 <= g && 0 <= b && ve[g] !== Pe[b]; )
                                            b--;
                                    for (; 1 <= g && 0 <= b; g--,
                                    b--)
                                        if (ve[g] !== Pe[b]) {
                                            if (g !== 1 || b !== 1)
                                                do
                                                    if (g--,
                                                    b--,
                                                    0 > b || ve[g] !== Pe[b]) {
                                                        var Ke = `
` + ve[g].replace(" at new ", " at ");
                                                        return r.displayName && Ke.includes("<anonymous>") && (Ke = Ke.replace("<anonymous>", r.displayName)),
                                                        Ke
                                                    }
                                                while (1 <= g && 0 <= b);
                                            break
                                        }
                                }
                            } finally {
                                xe = !1,
                                Error.prepareStackTrace = p
                            }
                            return (p = r ? r.displayName || r.name : "") ? ye(p) : ""
                        }
                        function Te(r, l) {
                            switch (r.tag) {
                            case 26:
                            case 27:
                            case 5:
                                return ye(r.type);
                            case 16:
                                return ye("Lazy");
                            case 13:
                                return r.child !== l && l !== null ? ye("Suspense Fallback") : ye("Suspense");
                            case 19:
                                return ye("SuspenseList");
                            case 0:
                            case 15:
                                return ge(r.type, !1);
                            case 11:
                                return ge(r.type.render, !1);
                            case 1:
                                return ge(r.type, !0);
                            case 31:
                                return ye("Activity");
                            default:
                                return ""
                            }
                        }
                        function Ae(r) {
                            try {
                                var l = ""
                                  , p = null;
                                do
                                    l += Te(r, p),
                                    p = r,
                                    r = r.return;
                                while (r);
                                return l
                            } catch (g) {
                                return `
Error generating stack: ` + g.message + `
` + g.stack
                            }
                        }
                        var we = Object.prototype.hasOwnProperty
                          , it = t.unstable_scheduleCallback
                          , je = t.unstable_cancelCallback
                          , $ = t.unstable_shouldYield
                          , Y = t.unstable_requestPaint
                          , pe = t.unstable_now
                          , He = t.unstable_getCurrentPriorityLevel
                          , Re = t.unstable_ImmediatePriority
                          , De = t.unstable_UserBlockingPriority
                          , rt = t.unstable_NormalPriority
                          , $e = t.unstable_LowPriority
                          , ct = t.unstable_IdlePriority
                          , gt = t.log
                          , Ie = t.unstable_setDisableYieldValue
                          , Je = null
                          , Ze = null;
                        function ht(r) {
                            if (typeof gt == "function" && Ie(r),
                            Ze && typeof Ze.setStrictMode == "function")
                                try {
                                    Ze.setStrictMode(Je, r)
                                } catch {}
                        }
                        var lt = Math.clz32 ? Math.clz32 : ot
                          , At = Math.log
                          , fe = Math.LN2;
                        function ot(r) {
                            return r >>>= 0,
                            r === 0 ? 32 : 31 - (At(r) / fe | 0) | 0
                        }
                        var tt = 256
                          , xt = 262144
                          , Qe = 4194304;
                        function Ne(r) {
                            var l = r & 42;
                            if (l !== 0)
                                return l;
                            switch (r & -r) {
                            case 1:
                                return 1;
                            case 2:
                                return 2;
                            case 4:
                                return 4;
                            case 8:
                                return 8;
                            case 16:
                                return 16;
                            case 32:
                                return 32;
                            case 64:
                                return 64;
                            case 128:
                                return 128;
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                                return r & 261888;
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return r & 3932160;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                return r & 62914560;
                            case 67108864:
                                return 67108864;
                            case 134217728:
                                return 134217728;
                            case 268435456:
                                return 268435456;
                            case 536870912:
                                return 536870912;
                            case 1073741824:
                                return 0;
                            default:
                                return r
                            }
                        }
                        function dt(r, l, p) {
                            var g = r.pendingLanes;
                            if (g === 0)
                                return 0;
                            var b = 0
                              , C = r.suspendedLanes
                              , F = r.pingedLanes;
                            r = r.warmLanes;
                            var J = g & 134217727;
                            return J !== 0 ? (g = J & ~C,
                            g !== 0 ? b = Ne(g) : (F &= J,
                            F !== 0 ? b = Ne(F) : p || (p = J & ~r,
                            p !== 0 && (b = Ne(p))))) : (J = g & ~C,
                            J !== 0 ? b = Ne(J) : F !== 0 ? b = Ne(F) : p || (p = g & ~r,
                            p !== 0 && (b = Ne(p)))),
                            b === 0 ? 0 : l !== 0 && l !== b && (l & C) === 0 && (C = b & -b,
                            p = l & -l,
                            C >= p || C === 32 && (p & 4194048) !== 0) ? l : b
                        }
                        function _t(r, l) {
                            return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & l) === 0
                        }
                        function Ct(r, l) {
                            switch (r) {
                            case 1:
                            case 2:
                            case 4:
                            case 8:
                            case 64:
                                return l + 250;
                            case 16:
                            case 32:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return l + 5e3;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                return -1;
                            case 67108864:
                            case 134217728:
                            case 268435456:
                            case 536870912:
                            case 1073741824:
                                return -1;
                            default:
                                return -1
                            }
                        }
                        function Ot() {
                            var r = Qe;
                            return Qe <<= 1,
                            (Qe & 62914560) === 0 && (Qe = 4194304),
                            r
                        }
                        function Mn(r) {
                            for (var l = [], p = 0; 31 > p; p++)
                                l.push(r);
                            return l
                        }
                        function Un(r, l) {
                            r.pendingLanes |= l,
                            l !== 268435456 && (r.suspendedLanes = 0,
                            r.pingedLanes = 0,
                            r.warmLanes = 0)
                        }
                        function On(r, l, p, g, b, C) {
                            var F = r.pendingLanes;
                            r.pendingLanes = p,
                            r.suspendedLanes = 0,
                            r.pingedLanes = 0,
                            r.warmLanes = 0,
                            r.expiredLanes &= p,
                            r.entangledLanes &= p,
                            r.errorRecoveryDisabledLanes &= p,
                            r.shellSuspendCounter = 0;
                            var J = r.entanglements
                              , ve = r.expirationTimes
                              , Pe = r.hiddenUpdates;
                            for (p = F & ~p; 0 < p; ) {
                                var Ke = 31 - lt(p)
                                  , st = 1 << Ke;
                                J[Ke] = 0,
                                ve[Ke] = -1;
                                var Ve = Pe[Ke];
                                if (Ve !== null)
                                    for (Pe[Ke] = null,
                                    Ke = 0; Ke < Ve.length; Ke++) {
                                        var Ye = Ve[Ke];
                                        Ye !== null && (Ye.lane &= -536870913)
                                    }
                                p &= ~st
                            }
                            g !== 0 && ki(r, g, 0),
                            C !== 0 && b === 0 && r.tag !== 0 && (r.suspendedLanes |= C & ~(F & ~l))
                        }
                        function ki(r, l, p) {
                            r.pendingLanes |= l,
                            r.suspendedLanes &= ~l;
                            var g = 31 - lt(l);
                            r.entangledLanes |= l,
                            r.entanglements[g] = r.entanglements[g] | 1073741824 | p & 261930
                        }
                        function Bs(r, l) {
                            var p = r.entangledLanes |= l;
                            for (r = r.entanglements; p; ) {
                                var g = 31 - lt(p)
                                  , b = 1 << g;
                                b & l | r[g] & l && (r[g] |= l),
                                p &= ~b
                            }
                        }
                        function Ls(r, l) {
                            var p = l & -l;
                            return p = (p & 42) !== 0 ? 1 : Ai(p),
                            (p & (r.suspendedLanes | l)) !== 0 ? 0 : p
                        }
                        function Ai(r) {
                            switch (r) {
                            case 2:
                                r = 1;
                                break;
                            case 8:
                                r = 4;
                                break;
                            case 32:
                                r = 16;
                                break;
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                r = 128;
                                break;
                            case 268435456:
                                r = 134217728;
                                break;
                            default:
                                r = 0
                            }
                            return r
                        }
                        function _s(r) {
                            return r &= -r,
                            2 < r ? 8 < r ? (r & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                        }
                        function ei() {
                            var r = V.p;
                            return r !== 0 ? r : (r = window.event,
                            r === void 0 ? 32 : yE(r.type))
                        }
                        function ti(r, l) {
                            var p = V.p;
                            try {
                                return V.p = r,
                                l()
                            } finally {
                                V.p = p
                            }
                        }
                        var Oi = Math.random().toString(36).slice(2)
                          , Qt = "__reactFiber$" + Oi
                          , Xi = "__reactProps$" + Oi
                          , lr = "__reactContainer$" + Oi
                          , Cr = "__reactEvents$" + Oi
                          , Sl = "__reactListeners$" + Oi
                          , Ch = "__reactHandles$" + Oi
                          , te = "__reactResources$" + Oi
                          , Se = "__reactMarker$" + Oi;
                        function Ge(r) {
                            delete r[Qt],
                            delete r[Xi],
                            delete r[Cr],
                            delete r[Sl],
                            delete r[Ch]
                        }
                        function Ue(r) {
                            var l = r[Qt];
                            if (l)
                                return l;
                            for (var p = r.parentNode; p; ) {
                                if (l = p[lr] || p[Qt]) {
                                    if (p = l.alternate,
                                    l.child !== null || p !== null && p.child !== null)
                                        for (r = sE(r); r !== null; ) {
                                            if (p = r[Qt])
                                                return p;
                                            r = sE(r)
                                        }
                                    return l
                                }
                                r = p,
                                p = r.parentNode
                            }
                            return null
                        }
                        function ce(r) {
                            if (r = r[Qt] || r[lr]) {
                                var l = r.tag;
                                if (l === 5 || l === 6 || l === 13 || l === 31 || l === 26 || l === 27 || l === 3)
                                    return r
                            }
                            return null
                        }
                        function at(r) {
                            var l = r.tag;
                            if (l === 5 || l === 26 || l === 27 || l === 6)
                                return r.stateNode;
                            throw Error(s(33))
                        }
                        function yt(r) {
                            var l = r[te];
                            return l || (l = r[te] = {
                                hoistableStyles: new Map,
                                hoistableScripts: new Map
                            }),
                            l
                        }
                        function pt(r) {
                            r[Se] = !0
                        }
                        var St = new Set
                          , Lt = {};
                        function Ut(r, l) {
                            Dt(r, l),
                            Dt(r + "Capture", l)
                        }
                        function Dt(r, l) {
                            for (Lt[r] = l,
                            r = 0; r < l.length; r++)
                                St.add(l[r])
                        }
                        var Kt = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
                          , bn = {}
                          , _n = {};
                        function Wn(r) {
                            return we.call(_n, r) ? !0 : we.call(bn, r) ? !1 : Kt.test(r) ? _n[r] = !0 : (bn[r] = !0,
                            !1)
                        }
                        function dn(r, l, p) {
                            if (Wn(l))
                                if (p === null)
                                    r.removeAttribute(l);
                                else {
                                    switch (typeof p) {
                                    case "undefined":
                                    case "function":
                                    case "symbol":
                                        r.removeAttribute(l);
                                        return;
                                    case "boolean":
                                        var g = l.toLowerCase().slice(0, 5);
                                        if (g !== "data-" && g !== "aria-") {
                                            r.removeAttribute(l);
                                            return
                                        }
                                    }
                                    r.setAttribute(l, "" + p)
                                }
                        }
                        function Et(r, l, p) {
                            if (p === null)
                                r.removeAttribute(l);
                            else {
                                switch (typeof p) {
                                case "undefined":
                                case "function":
                                case "symbol":
                                case "boolean":
                                    r.removeAttribute(l);
                                    return
                                }
                                r.setAttribute(l, "" + p)
                            }
                        }
                        function vn(r, l, p, g) {
                            if (g === null)
                                r.removeAttribute(p);
                            else {
                                switch (typeof g) {
                                case "undefined":
                                case "function":
                                case "symbol":
                                case "boolean":
                                    r.removeAttribute(p);
                                    return
                                }
                                r.setAttributeNS(l, p, "" + g)
                            }
                        }
                        function Ht(r) {
                            switch (typeof r) {
                            case "bigint":
                            case "boolean":
                            case "number":
                            case "string":
                            case "undefined":
                                return r;
                            case "object":
                                return r;
                            default:
                                return ""
                            }
                        }
                        function Ni(r) {
                            var l = r.type;
                            return (r = r.nodeName) && r.toLowerCase() === "input" && (l === "checkbox" || l === "radio")
                        }
                        function Ua(r, l, p) {
                            var g = Object.getOwnPropertyDescriptor(r.constructor.prototype, l);
                            if (!r.hasOwnProperty(l) && typeof g < "u" && typeof g.get == "function" && typeof g.set == "function") {
                                var b = g.get
                                  , C = g.set;
                                return Object.defineProperty(r, l, {
                                    configurable: !0,
                                    get: function() {
                                        return b.call(this)
                                    },
                                    set: function(F) {
                                        p = "" + F,
                                        C.call(this, F)
                                    }
                                }),
                                Object.defineProperty(r, l, {
                                    enumerable: g.enumerable
                                }),
                                {
                                    getValue: function() {
                                        return p
                                    },
                                    setValue: function(F) {
                                        p = "" + F
                                    },
                                    stopTracking: function() {
                                        r._valueTracker = null,
                                        delete r[l]
                                    }
                                }
                            }
                        }
                        function Ti(r) {
                            if (!r._valueTracker) {
                                var l = Ni(r) ? "checked" : "value";
                                r._valueTracker = Ua(r, l, "" + r[l])
                            }
                        }
                        function Oa(r) {
                            if (!r)
                                return !1;
                            var l = r._valueTracker;
                            if (!l)
                                return !0;
                            var p = l.getValue()
                              , g = "";
                            return r && (g = Ni(r) ? r.checked ? "true" : "false" : r.value),
                            r = g,
                            r !== p ? (l.setValue(r),
                            !0) : !1
                        }
                        function Jt(r) {
                            if (r = r || (typeof document < "u" ? document : void 0),
                            typeof r > "u")
                                return null;
                            try {
                                return r.activeElement || r.body
                            } catch {
                                return r.body
                            }
                        }
                        var Ss = /[\n"\\]/g;
                        function Nn(r) {
                            return r.replace(Ss, function(l) {
                                return "\\" + l.charCodeAt(0).toString(16) + " "
                            })
                        }
                        function qn(r, l, p, g, b, C, F, J) {
                            r.name = "",
                            F != null && typeof F != "function" && typeof F != "symbol" && typeof F != "boolean" ? r.type = F : r.removeAttribute("type"),
                            l != null ? F === "number" ? (l === 0 && r.value === "" || r.value != l) && (r.value = "" + Ht(l)) : r.value !== "" + Ht(l) && (r.value = "" + Ht(l)) : F !== "submit" && F !== "reset" || r.removeAttribute("value"),
                            l != null ? Na(r, F, Ht(l)) : p != null ? Na(r, F, Ht(p)) : g != null && r.removeAttribute("value"),
                            b == null && C != null && (r.defaultChecked = !!C),
                            b != null && (r.checked = b && typeof b != "function" && typeof b != "symbol"),
                            J != null && typeof J != "function" && typeof J != "symbol" && typeof J != "boolean" ? r.name = "" + Ht(J) : r.removeAttribute("name")
                        }
                        function ls(r, l, p, g, b, C, F, J) {
                            if (C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" && (r.type = C),
                            l != null || p != null) {
                                if (!(C !== "submit" && C !== "reset" || l != null)) {
                                    Ti(r);
                                    return
                                }
                                p = p != null ? "" + Ht(p) : "",
                                l = l != null ? "" + Ht(l) : p,
                                J || l === r.value || (r.value = l),
                                r.defaultValue = l
                            }
                            g = g ?? b,
                            g = typeof g != "function" && typeof g != "symbol" && !!g,
                            r.checked = J ? r.checked : !!g,
                            r.defaultChecked = !!g,
                            F != null && typeof F != "function" && typeof F != "symbol" && typeof F != "boolean" && (r.name = F),
                            Ti(r)
                        }
                        function Na(r, l, p) {
                            l === "number" && Jt(r.ownerDocument) === r || r.defaultValue === "" + p || (r.defaultValue = "" + p)
                        }
                        function $i(r, l, p, g) {
                            if (r = r.options,
                            l) {
                                l = {};
                                for (var b = 0; b < p.length; b++)
                                    l["$" + p[b]] = !0;
                                for (p = 0; p < r.length; p++)
                                    b = l.hasOwnProperty("$" + r[p].value),
                                    r[p].selected !== b && (r[p].selected = b),
                                    b && g && (r[p].defaultSelected = !0)
                            } else {
                                for (p = "" + Ht(p),
                                l = null,
                                b = 0; b < r.length; b++) {
                                    if (r[b].value === p) {
                                        r[b].selected = !0,
                                        g && (r[b].defaultSelected = !0);
                                        return
                                    }
                                    l !== null || r[b].disabled || (l = r[b])
                                }
                                l !== null && (l.selected = !0)
                            }
                        }
                        function yc(r, l, p) {
                            if (l != null && (l = "" + Ht(l),
                            l !== r.value && (r.value = l),
                            p == null)) {
                                r.defaultValue !== l && (r.defaultValue = l);
                                return
                            }
                            r.defaultValue = p != null ? "" + Ht(p) : ""
                        }
                        function no(r, l, p, g) {
                            if (l == null) {
                                if (g != null) {
                                    if (p != null)
                                        throw Error(s(92));
                                    if (k(g)) {
                                        if (1 < g.length)
                                            throw Error(s(93));
                                        g = g[0]
                                    }
                                    p = g
                                }
                                p ??= "",
                                l = p
                            }
                            p = Ht(l),
                            r.defaultValue = p,
                            g = r.textContent,
                            g === p && g !== "" && g !== null && (r.value = g),
                            Ti(r)
                        }
                        function io(r, l) {
                            if (l) {
                                var p = r.firstChild;
                                if (p && p === r.lastChild && p.nodeType === 3) {
                                    p.nodeValue = l;
                                    return
                                }
                            }
                            r.textContent = l
                        }
                        var xl = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
                        function wr(r, l, p) {
                            var g = l.indexOf("--") === 0;
                            p == null || typeof p == "boolean" || p === "" ? g ? r.setProperty(l, "") : l === "float" ? r.cssFloat = "" : r[l] = "" : g ? r.setProperty(l, p) : typeof p != "number" || p === 0 || xl.has(l) ? l === "float" ? r.cssFloat = p : r[l] = ("" + p).trim() : r[l] = p + "px"
                        }
                        function mu(r, l, p) {
                            if (l != null && typeof l != "object")
                                throw Error(s(62));
                            if (r = r.style,
                            p != null) {
                                for (var g in p)
                                    !p.hasOwnProperty(g) || l != null && l.hasOwnProperty(g) || (g.indexOf("--") === 0 ? r.setProperty(g, "") : g === "float" ? r.cssFloat = "" : r[g] = "");
                                for (var b in l)
                                    g = l[b],
                                    l.hasOwnProperty(b) && p[b] !== g && wr(r, b, g)
                            } else
                                for (var C in l)
                                    l.hasOwnProperty(C) && wr(r, C, l[C])
                        }
                        function so(r) {
                            if (r.indexOf("-") === -1)
                                return !1;
                            switch (r) {
                            case "annotation-xml":
                            case "color-profile":
                            case "font-face":
                            case "font-face-src":
                            case "font-face-uri":
                            case "font-face-format":
                            case "font-face-name":
                            case "missing-glyph":
                                return !1;
                            default:
                                return !0
                            }
                        }
                        var Bo = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
                          , Lo = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
                        function Dr(r) {
                            return Lo.test("" + r) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : r
                        }
                        function Ba() {}
                        var Rr = null;
                        function Al(r) {
                            return r = r.target || r.srcElement || window,
                            r.correspondingUseElement && (r = r.correspondingUseElement),
                            r.nodeType === 3 ? r.parentNode : r
                        }
                        var Ur = null
                          , Or = null;
                        function Tl(r) {
                            var l = ce(r);
                            if (l && (r = l.stateNode)) {
                                var p = r[Xi] || null;
                                e: switch (r = l.stateNode,
                                l.type) {
                                case "input":
                                    if (qn(r, p.value, p.defaultValue, p.defaultValue, p.checked, p.defaultChecked, p.type, p.name),
                                    l = p.name,
                                    p.type === "radio" && l != null) {
                                        for (p = r; p.parentNode; )
                                            p = p.parentNode;
                                        for (p = p.querySelectorAll('input[name="' + Nn("" + l) + '"][type="radio"]'),
                                        l = 0; l < p.length; l++) {
                                            var g = p[l];
                                            if (g !== r && g.form === r.form) {
                                                var b = g[Xi] || null;
                                                if (!b)
                                                    throw Error(s(90));
                                                qn(g, b.value, b.defaultValue, b.defaultValue, b.checked, b.defaultChecked, b.type, b.name)
                                            }
                                        }
                                        for (l = 0; l < p.length; l++)
                                            g = p[l],
                                            g.form === r.form && Oa(g)
                                    }
                                    break e;
                                case "textarea":
                                    yc(r, p.value, p.defaultValue);
                                    break e;
                                case "select":
                                    l = p.value,
                                    l != null && $i(r, !!p.multiple, l, !1)
                                }
                            }
                        }
                        var Ml = !1;
                        function vu(r, l, p) {
                            if (Ml)
                                return r(l, p);
                            Ml = !0;
                            try {
                                return r(l)
                            } finally {
                                if (Ml = !1,
                                (Ur !== null || Or !== null) && (ne(),
                                Ur && (l = Ur,
                                r = Or,
                                Or = Ur = null,
                                Tl(l),
                                r)))
                                    for (l = 0; l < r.length; l++)
                                        Tl(r[l])
                            }
                        }
                        function es(r, l) {
                            var p = r.stateNode;
                            if (p === null)
                                return null;
                            var g = p[Xi] || null;
                            if (g === null)
                                return null;
                            p = g[l];
                            e: switch (l) {
                            case "onClick":
                            case "onClickCapture":
                            case "onDoubleClick":
                            case "onDoubleClickCapture":
                            case "onMouseDown":
                            case "onMouseDownCapture":
                            case "onMouseMove":
                            case "onMouseMoveCapture":
                            case "onMouseUp":
                            case "onMouseUpCapture":
                            case "onMouseEnter":
                                (g = !g.disabled) || (r = r.type,
                                g = !(r === "button" || r === "input" || r === "select" || r === "textarea")),
                                r = !g;
                                break e;
                            default:
                                r = !1
                            }
                            if (r)
                                return null;
                            if (p && typeof p != "function")
                                throw Error(s(231, l, typeof p));
                            return p
                        }
                        var la = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
                          , _c = !1;
                        if (la)
                            try {
                                var bl = {};
                                Object.defineProperty(bl, "passive", {
                                    get: function() {
                                        _c = !0
                                    }
                                }),
                                window.addEventListener("test", bl, bl),
                                window.removeEventListener("test", bl, bl)
                            } catch {
                                _c = !1
                            }
                        var cr = null
                          , Sc = null
                          , Nr = null;
                        function ao() {
                            if (Nr)
                                return Nr;
                            var r, l = Sc, p = l.length, g, b = "value"in cr ? cr.value : cr.textContent, C = b.length;
                            for (r = 0; r < p && l[r] === b[r]; r++)
                                ;
                            var F = p - r;
                            for (g = 1; g <= F && l[p - g] === b[C - g]; g++)
                                ;
                            return Nr = b.slice(r, 1 < g ? 1 - g : void 0)
                        }
                        function La(r) {
                            var l = r.keyCode;
                            return "charCode"in r ? (r = r.charCode,
                            r === 0 && l === 13 && (r = 13)) : r = l,
                            r === 10 && (r = 13),
                            32 <= r || r === 13 ? r : 0
                        }
                        function ca() {
                            return !0
                        }
                        function gu() {
                            return !1
                        }
                        function Wi(r) {
                            function l(p, g, b, C, F) {
                                this._reactName = p,
                                this._targetInst = b,
                                this.type = g,
                                this.nativeEvent = C,
                                this.target = F,
                                this.currentTarget = null;
                                for (var J in r)
                                    r.hasOwnProperty(J) && (p = r[J],
                                    this[J] = p ? p(C) : C[J]);
                                return this.isDefaultPrevented = (C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1) ? ca : gu,
                                this.isPropagationStopped = gu,
                                this
                            }
                            return y(l.prototype, {
                                preventDefault: function() {
                                    this.defaultPrevented = !0;
                                    var p = this.nativeEvent;
                                    p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1),
                                    this.isDefaultPrevented = ca)
                                },
                                stopPropagation: function() {
                                    var p = this.nativeEvent;
                                    p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0),
                                    this.isPropagationStopped = ca)
                                },
                                persist: function() {},
                                isPersistent: ca
                            }),
                            l
                        }
                        var ur = {
                            eventPhase: 0,
                            bubbles: 0,
                            cancelable: 0,
                            timeStamp: function(r) {
                                return r.timeStamp || Date.now()
                            },
                            defaultPrevented: 0,
                            isTrusted: 0
                        }, Br = Wi(ur), ua = y({}, ur, {
                            view: 0,
                            detail: 0
                        }), ro = Wi(ua), El, ts, Cl, oo = y({}, ua, {
                            screenX: 0,
                            screenY: 0,
                            clientX: 0,
                            clientY: 0,
                            pageX: 0,
                            pageY: 0,
                            ctrlKey: 0,
                            shiftKey: 0,
                            altKey: 0,
                            metaKey: 0,
                            getModifierState: wh,
                            button: 0,
                            buttons: 0,
                            relatedTarget: function(r) {
                                return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget
                            },
                            movementX: function(r) {
                                return "movementX"in r ? r.movementX : (r !== Cl && (Cl && r.type === "mousemove" ? (El = r.screenX - Cl.screenX,
                                ts = r.screenY - Cl.screenY) : ts = El = 0,
                                Cl = r),
                                El)
                            },
                            movementY: function(r) {
                                return "movementY"in r ? r.movementY : ts
                            }
                        }), xc = Wi(oo), Yi = y({}, oo, {
                            dataTransfer: 0
                        }), fd = Wi(Yi), xs = y({}, ua, {
                            relatedTarget: 0
                        }), Is = Wi(xs), As = y({}, ur, {
                            animationName: 0,
                            elapsedTime: 0,
                            pseudoElement: 0
                        }), Lr = Wi(As), wl = y({}, ur, {
                            clipboardData: function(r) {
                                return "clipboardData"in r ? r.clipboardData : window.clipboardData
                            }
                        }), Rm = Wi(wl), T0 = y({}, ur, {
                            data: 0
                        }), Um = Wi(T0), M0 = {
                            Esc: "Escape",
                            Spacebar: " ",
                            Left: "ArrowLeft",
                            Up: "ArrowUp",
                            Right: "ArrowRight",
                            Down: "ArrowDown",
                            Del: "Delete",
                            Win: "OS",
                            Menu: "ContextMenu",
                            Apps: "ContextMenu",
                            Scroll: "ScrollLock",
                            MozPrintableKey: "Unidentified"
                        }, Om = {
                            8: "Backspace",
                            9: "Tab",
                            12: "Clear",
                            13: "Enter",
                            16: "Shift",
                            17: "Control",
                            18: "Alt",
                            19: "Pause",
                            20: "CapsLock",
                            27: "Escape",
                            32: " ",
                            33: "PageUp",
                            34: "PageDown",
                            35: "End",
                            36: "Home",
                            37: "ArrowLeft",
                            38: "ArrowUp",
                            39: "ArrowRight",
                            40: "ArrowDown",
                            45: "Insert",
                            46: "Delete",
                            112: "F1",
                            113: "F2",
                            114: "F3",
                            115: "F4",
                            116: "F5",
                            117: "F6",
                            118: "F7",
                            119: "F8",
                            120: "F9",
                            121: "F10",
                            122: "F11",
                            123: "F12",
                            144: "NumLock",
                            145: "ScrollLock",
                            224: "Meta"
                        }, Nm = {
                            Alt: "altKey",
                            Control: "ctrlKey",
                            Meta: "metaKey",
                            Shift: "shiftKey"
                        };
                        function b0(r) {
                            var l = this.nativeEvent;
                            return l.getModifierState ? l.getModifierState(r) : (r = Nm[r]) ? !!l[r] : !1
                        }
                        function wh() {
                            return b0
                        }
                        var Bm = y({}, ua, {
                            key: function(r) {
                                if (r.key) {
                                    var l = M0[r.key] || r.key;
                                    if (l !== "Unidentified")
                                        return l
                                }
                                return r.type === "keypress" ? (r = La(r),
                                r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? Om[r.keyCode] || "Unidentified" : ""
                            },
                            code: 0,
                            location: 0,
                            ctrlKey: 0,
                            shiftKey: 0,
                            altKey: 0,
                            metaKey: 0,
                            repeat: 0,
                            locale: 0,
                            getModifierState: wh,
                            charCode: function(r) {
                                return r.type === "keypress" ? La(r) : 0
                            },
                            keyCode: function(r) {
                                return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
                            },
                            which: function(r) {
                                return r.type === "keypress" ? La(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
                            }
                        })
                          , Lm = Wi(Bm)
                          , E0 = y({}, oo, {
                            pointerId: 0,
                            width: 0,
                            height: 0,
                            pressure: 0,
                            tangentialPressure: 0,
                            tiltX: 0,
                            tiltY: 0,
                            twist: 0,
                            pointerType: 0,
                            isPrimary: 0
                        })
                          , dd = Wi(E0)
                          , C0 = y({}, ua, {
                            touches: 0,
                            targetTouches: 0,
                            changedTouches: 0,
                            altKey: 0,
                            metaKey: 0,
                            ctrlKey: 0,
                            shiftKey: 0,
                            getModifierState: wh
                        })
                          , Io = Wi(C0)
                          , Im = y({}, ur, {
                            propertyName: 0,
                            elapsedTime: 0,
                            pseudoElement: 0
                        })
                          , Cx = Wi(Im)
                          , w0 = y({}, oo, {
                            deltaX: function(r) {
                                return "deltaX"in r ? r.deltaX : "wheelDeltaX"in r ? -r.wheelDeltaX : 0
                            },
                            deltaY: function(r) {
                                return "deltaY"in r ? r.deltaY : "wheelDeltaY"in r ? -r.wheelDeltaY : "wheelDelta"in r ? -r.wheelDelta : 0
                            },
                            deltaZ: 0,
                            deltaMode: 0
                        })
                          , Dl = Wi(w0)
                          , Po = y({}, ur, {
                            newState: 0,
                            oldState: 0
                        })
                          , Pm = Wi(Po)
                          , zm = [9, 13, 27, 32]
                          , Ac = la && "CompositionEvent"in window
                          , Rl = null;
                        la && "documentMode"in document && (Rl = document.documentMode);
                        var Tc = la && "TextEvent"in window && !Rl
                          , Ts = la && (!Ac || Rl && 8 < Rl && 11 >= Rl)
                          , Dh = " "
                          , Fm = !1;
                        function pd(r, l) {
                            switch (r) {
                            case "keyup":
                                return zm.indexOf(l.keyCode) !== -1;
                            case "keydown":
                                return l.keyCode !== 229;
                            case "keypress":
                            case "mousedown":
                            case "focusout":
                                return !0;
                            default:
                                return !1
                            }
                        }
                        function yu(r) {
                            return r = r.detail,
                            typeof r == "object" && "data"in r ? r.data : null
                        }
                        var Ul = !1;
                        function md(r, l) {
                            switch (r) {
                            case "compositionend":
                                return yu(l);
                            case "keypress":
                                return l.which !== 32 ? null : (Fm = !0,
                                Dh);
                            case "textInput":
                                return r = l.data,
                                r === Dh && Fm ? null : r;
                            default:
                                return null
                            }
                        }
                        function D0(r, l) {
                            if (Ul)
                                return r === "compositionend" || !Ac && pd(r, l) ? (r = ao(),
                                Nr = Sc = cr = null,
                                Ul = !1,
                                r) : null;
                            switch (r) {
                            case "paste":
                                return null;
                            case "keypress":
                                if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
                                    if (l.char && 1 < l.char.length)
                                        return l.char;
                                    if (l.which)
                                        return String.fromCharCode(l.which)
                                }
                                return null;
                            case "compositionend":
                                return Ts && l.locale !== "ko" ? null : l.data;
                            default:
                                return null
                            }
                        }
                        var Ia = {
                            color: !0,
                            date: !0,
                            datetime: !0,
                            "datetime-local": !0,
                            email: !0,
                            month: !0,
                            number: !0,
                            password: !0,
                            range: !0,
                            search: !0,
                            tel: !0,
                            text: !0,
                            time: !0,
                            url: !0,
                            week: !0
                        };
                        function Hm(r) {
                            var l = r && r.nodeName && r.nodeName.toLowerCase();
                            return l === "input" ? !!Ia[r.type] : l === "textarea"
                        }
                        function vd(r, l, p, g) {
                            Ur ? Or ? Or.push(g) : Or = [g] : Ur = g,
                            l = Sy(l, "onChange"),
                            0 < l.length && (p = new Br("onChange","change",null,p,g),
                            r.push({
                                event: p,
                                listeners: l
                            }))
                        }
                        var _u = null
                          , Su = null;
                        function Gm(r) {
                            kb(r, 0)
                        }
                        function xu(r) {
                            var l = at(r);
                            if (Oa(l))
                                return r
                        }
                        function Vm(r, l) {
                            if (r === "change")
                                return l
                        }
                        var Rh = !1;
                        if (la) {
                            var Mc;
                            if (la) {
                                var ui = "oninput"in document;
                                if (!ui) {
                                    var R0 = document.createElement("div");
                                    R0.setAttribute("oninput", "return;"),
                                    ui = typeof R0.oninput == "function"
                                }
                                Mc = ui
                            } else
                                Mc = !1;
                            Rh = Mc && (!document.documentMode || 9 < document.documentMode)
                        }
                        function U0() {
                            _u && (_u.detachEvent("onpropertychange", km),
                            Su = _u = null)
                        }
                        function km(r) {
                            if (r.propertyName === "value" && xu(Su)) {
                                var l = [];
                                vd(l, Su, r, Al(r)),
                                vu(Gm, l)
                            }
                        }
                        function Uh(r, l, p) {
                            r === "focusin" ? (U0(),
                            _u = l,
                            Su = p,
                            _u.attachEvent("onpropertychange", km)) : r === "focusout" && U0()
                        }
                        function Ol(r) {
                            if (r === "selectionchange" || r === "keyup" || r === "keydown")
                                return xu(Su)
                        }
                        function O0(r, l) {
                            if (r === "click")
                                return xu(l)
                        }
                        function N0(r, l) {
                            if (r === "input" || r === "change")
                                return xu(l)
                        }
                        function bc(r, l) {
                            return r === l && (r !== 0 || 1 / r === 1 / l) || r !== r && l !== l
                        }
                        var hi = typeof Object.is == "function" ? Object.is : bc;
                        function Au(r, l) {
                            if (hi(r, l))
                                return !0;
                            if (typeof r != "object" || r === null || typeof l != "object" || l === null)
                                return !1;
                            var p = Object.keys(r)
                              , g = Object.keys(l);
                            if (p.length !== g.length)
                                return !1;
                            for (g = 0; g < p.length; g++) {
                                var b = p[g];
                                if (!we.call(l, b) || !hi(r[b], l[b]))
                                    return !1
                            }
                            return !0
                        }
                        function Xm(r) {
                            for (; r && r.firstChild; )
                                r = r.firstChild;
                            return r
                        }
                        function Wm(r, l) {
                            var p = Xm(r);
                            r = 0;
                            for (var g; p; ) {
                                if (p.nodeType === 3) {
                                    if (g = r + p.textContent.length,
                                    r <= l && g >= l)
                                        return {
                                            node: p,
                                            offset: l - r
                                        };
                                    r = g
                                }
                                e: {
                                    for (; p; ) {
                                        if (p.nextSibling) {
                                            p = p.nextSibling;
                                            break e
                                        }
                                        p = p.parentNode
                                    }
                                    p = void 0
                                }
                                p = Xm(p)
                            }
                        }
                        function gd(r, l) {
                            return r && l ? r === l ? !0 : r && r.nodeType === 3 ? !1 : l && l.nodeType === 3 ? gd(r, l.parentNode) : "contains"in r ? r.contains(l) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(l) & 16) : !1 : !1
                        }
                        function yd(r) {
                            r = r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null ? r.ownerDocument.defaultView : window;
                            for (var l = Jt(r.document); l instanceof r.HTMLIFrameElement; ) {
                                try {
                                    var p = typeof l.contentWindow.location.href == "string"
                                } catch {
                                    p = !1
                                }
                                if (p)
                                    r = l.contentWindow;
                                else
                                    break;
                                l = Jt(r.document)
                            }
                            return l
                        }
                        function Tu(r) {
                            var l = r && r.nodeName && r.nodeName.toLowerCase();
                            return l && (l === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || l === "textarea" || r.contentEditable === "true")
                        }
                        var B0 = la && "documentMode"in document && 11 >= document.documentMode
                          , Mu = null
                          , _d = null
                          , bu = null
                          , Pa = !1;
                        function Sd(r, l, p) {
                            var g = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
                            Pa || Mu == null || Mu !== Jt(g) || (g = Mu,
                            "selectionStart"in g && Tu(g) ? g = {
                                start: g.selectionStart,
                                end: g.selectionEnd
                            } : (g = (g.ownerDocument && g.ownerDocument.defaultView || window).getSelection(),
                            g = {
                                anchorNode: g.anchorNode,
                                anchorOffset: g.anchorOffset,
                                focusNode: g.focusNode,
                                focusOffset: g.focusOffset
                            }),
                            bu && Au(bu, g) || (bu = g,
                            g = Sy(_d, "onSelect"),
                            0 < g.length && (l = new Br("onSelect","select",null,l,p),
                            r.push({
                                event: l,
                                listeners: g
                            }),
                            l.target = Mu)))
                        }
                        function Nl(r, l) {
                            var p = {};
                            return p[r.toLowerCase()] = l.toLowerCase(),
                            p["Webkit" + r] = "webkit" + l,
                            p["Moz" + r] = "moz" + l,
                            p
                        }
                        var Eu = {
                            animationend: Nl("Animation", "AnimationEnd"),
                            animationiteration: Nl("Animation", "AnimationIteration"),
                            animationstart: Nl("Animation", "AnimationStart"),
                            transitionrun: Nl("Transition", "TransitionRun"),
                            transitionstart: Nl("Transition", "TransitionStart"),
                            transitioncancel: Nl("Transition", "TransitionCancel"),
                            transitionend: Nl("Transition", "TransitionEnd")
                        }
                          , Oh = {}
                          , Qs = {};
                        la && (Qs = document.createElement("div").style,
                        "AnimationEvent"in window || (delete Eu.animationend.animation,
                        delete Eu.animationiteration.animation,
                        delete Eu.animationstart.animation),
                        "TransitionEvent"in window || delete Eu.transitionend.transition);
                        function Bl(r) {
                            if (Oh[r])
                                return Oh[r];
                            if (!Eu[r])
                                return r;
                            var l = Eu[r], p;
                            for (p in l)
                                if (l.hasOwnProperty(p) && p in Qs)
                                    return Oh[r] = l[p];
                            return r
                        }
                        var ha = Bl("animationend")
                          , Ym = Bl("animationiteration")
                          , lo = Bl("animationstart")
                          , Cu = Bl("transitionrun")
                          , Ll = Bl("transitionstart")
                          , qm = Bl("transitioncancel")
                          , xd = Bl("transitionend")
                          , zo = new Map
                          , Ad = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
                        Ad.push("scrollEnd");
                        function Ps(r, l) {
                            zo.set(r, l),
                            Ut(l, [r])
                        }
                        var Il = typeof reportError == "function" ? reportError : function(r) {
                            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                var l = new window.ErrorEvent("error",{
                                    bubbles: !0,
                                    cancelable: !0,
                                    message: typeof r == "object" && r !== null && typeof r.message == "string" ? String(r.message) : String(r),
                                    error: r
                                });
                                if (!window.dispatchEvent(l))
                                    return
                            } else if (typeof process == "object" && typeof process.emit == "function") {
                                process.emit("uncaughtException", r);
                                return
                            }
                            console.error(r)
                        }
                          , cs = []
                          , Ec = 0
                          , Td = 0;
                        function Pl() {
                            for (var r = Ec, l = Td = Ec = 0; l < r; ) {
                                var p = cs[l];
                                cs[l++] = null;
                                var g = cs[l];
                                cs[l++] = null;
                                var b = cs[l];
                                cs[l++] = null;
                                var C = cs[l];
                                if (cs[l++] = null,
                                g !== null && b !== null) {
                                    var F = g.pending;
                                    F === null ? b.next = b : (b.next = F.next,
                                    F.next = b),
                                    g.pending = b
                                }
                                C !== 0 && Md(p, b, C)
                            }
                        }
                        function Nh(r, l, p, g) {
                            cs[Ec++] = r,
                            cs[Ec++] = l,
                            cs[Ec++] = p,
                            cs[Ec++] = g,
                            Td |= g,
                            r.lanes |= g,
                            r = r.alternate,
                            r !== null && (r.lanes |= g)
                        }
                        function wu(r, l, p, g) {
                            return Nh(r, l, p, g),
                            Du(r)
                        }
                        function zl(r, l) {
                            return Nh(r, null, null, l),
                            Du(r)
                        }
                        function Md(r, l, p) {
                            r.lanes |= p;
                            var g = r.alternate;
                            g !== null && (g.lanes |= p);
                            for (var b = !1, C = r.return; C !== null; )
                                C.childLanes |= p,
                                g = C.alternate,
                                g !== null && (g.childLanes |= p),
                                C.tag === 22 && (r = C.stateNode,
                                r === null || r._visibility & 1 || (b = !0)),
                                r = C,
                                C = C.return;
                            return r.tag === 3 ? (C = r.stateNode,
                            b && l !== null && (b = 31 - lt(p),
                            r = C.hiddenUpdates,
                            g = r[b],
                            g === null ? r[b] = [l] : g.push(l),
                            l.lane = p | 536870912),
                            C) : null
                        }
                        function Du(r) {
                            if (50 < kc)
                                throw kc = 0,
                                Xc = null,
                                Error(s(185));
                            for (var l = r.return; l !== null; )
                                r = l,
                                l = r.return;
                            return r.tag === 3 ? r.stateNode : null
                        }
                        var Fl = {};
                        function L0(r, l, p, g) {
                            this.tag = r,
                            this.key = p,
                            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                            this.index = 0,
                            this.refCleanup = this.ref = null,
                            this.pendingProps = l,
                            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                            this.mode = g,
                            this.subtreeFlags = this.flags = 0,
                            this.deletions = null,
                            this.childLanes = this.lanes = 0,
                            this.alternate = null
                        }
                        function Zs(r, l, p, g) {
                            return new L0(r,l,p,g)
                        }
                        function Ks(r) {
                            return r = r.prototype,
                            !(!r || !r.isReactComponent)
                        }
                        function co(r, l) {
                            var p = r.alternate;
                            return p === null ? (p = Zs(r.tag, l, r.key, r.mode),
                            p.elementType = r.elementType,
                            p.type = r.type,
                            p.stateNode = r.stateNode,
                            p.alternate = r,
                            r.alternate = p) : (p.pendingProps = l,
                            p.type = r.type,
                            p.flags = 0,
                            p.subtreeFlags = 0,
                            p.deletions = null),
                            p.flags = r.flags & 65011712,
                            p.childLanes = r.childLanes,
                            p.lanes = r.lanes,
                            p.child = r.child,
                            p.memoizedProps = r.memoizedProps,
                            p.memoizedState = r.memoizedState,
                            p.updateQueue = r.updateQueue,
                            l = r.dependencies,
                            p.dependencies = l === null ? null : {
                                lanes: l.lanes,
                                firstContext: l.firstContext
                            },
                            p.sibling = r.sibling,
                            p.index = r.index,
                            p.ref = r.ref,
                            p.refCleanup = r.refCleanup,
                            p
                        }
                        function zs(r, l) {
                            r.flags &= 65011714;
                            var p = r.alternate;
                            return p === null ? (r.childLanes = 0,
                            r.lanes = l,
                            r.child = null,
                            r.subtreeFlags = 0,
                            r.memoizedProps = null,
                            r.memoizedState = null,
                            r.updateQueue = null,
                            r.dependencies = null,
                            r.stateNode = null) : (r.childLanes = p.childLanes,
                            r.lanes = p.lanes,
                            r.child = p.child,
                            r.subtreeFlags = 0,
                            r.deletions = null,
                            r.memoizedProps = p.memoizedProps,
                            r.memoizedState = p.memoizedState,
                            r.updateQueue = p.updateQueue,
                            r.type = p.type,
                            l = p.dependencies,
                            r.dependencies = l === null ? null : {
                                lanes: l.lanes,
                                firstContext: l.firstContext
                            }),
                            r
                        }
                        function Bh(r, l, p, g, b, C) {
                            var F = 0;
                            if (g = r,
                            typeof r == "function")
                                Ks(r) && (F = 1);
                            else if (typeof r == "string")
                                F = sN(r, p, K.current) ? 26 : r === "html" || r === "head" || r === "body" ? 27 : 5;
                            else
                                e: switch (r) {
                                case B:
                                    return r = Zs(31, p, l, b),
                                    r.elementType = B,
                                    r.lanes = C,
                                    r;
                                case x:
                                    return Fo(p.children, b, C, l);
                                case T:
                                    F = 8,
                                    b |= 24;
                                    break;
                                case D:
                                    return r = Zs(12, p, l, b | 2),
                                    r.elementType = D,
                                    r.lanes = C,
                                    r;
                                case L:
                                    return r = Zs(13, p, l, b),
                                    r.elementType = L,
                                    r.lanes = C,
                                    r;
                                case N:
                                    return r = Zs(19, p, l, b),
                                    r.elementType = N,
                                    r.lanes = C,
                                    r;
                                default:
                                    if (typeof r == "object" && r !== null)
                                        switch (r.$$typeof) {
                                        case U:
                                            F = 10;
                                            break e;
                                        case w:
                                            F = 9;
                                            break e;
                                        case O:
                                            F = 11;
                                            break e;
                                        case z:
                                            F = 14;
                                            break e;
                                        case I:
                                            F = 16,
                                            g = null;
                                            break e
                                        }
                                    F = 29,
                                    p = Error(s(130, r === null ? "null" : typeof r, "")),
                                    g = null
                                }
                            return l = Zs(F, p, l, b),
                            l.elementType = r,
                            l.type = g,
                            l.lanes = C,
                            l
                        }
                        function Fo(r, l, p, g) {
                            return r = Zs(7, r, g, l),
                            r.lanes = p,
                            r
                        }
                        function bd(r, l, p) {
                            return r = Zs(6, r, null, l),
                            r.lanes = p,
                            r
                        }
                        function I0(r) {
                            var l = Zs(18, null, null, 0);
                            return l.stateNode = r,
                            l
                        }
                        function Ir(r, l, p) {
                            return l = Zs(4, r.children !== null ? r.children : [], r.key, l),
                            l.lanes = p,
                            l.stateNode = {
                                containerInfo: r.containerInfo,
                                pendingChildren: null,
                                implementation: r.implementation
                            },
                            l
                        }
                        var jm = new WeakMap;
                        function fa(r, l) {
                            if (typeof r == "object" && r !== null) {
                                var p = jm.get(r);
                                return p !== void 0 ? p : (l = {
                                    value: r,
                                    source: l,
                                    stack: Ae(l)
                                },
                                jm.set(r, l),
                                l)
                            }
                            return {
                                value: r,
                                source: l,
                                stack: Ae(l)
                            }
                        }
                        var Pr = []
                          , Cc = 0
                          , Lh = null
                          , Ru = 0
                          , za = []
                          , da = 0
                          , uo = null
                          , ho = 1
                          , fo = "";
                        function Ho(r, l) {
                            Pr[Cc++] = Ru,
                            Pr[Cc++] = Lh,
                            Lh = r,
                            Ru = l
                        }
                        function Qm(r, l, p) {
                            za[da++] = ho,
                            za[da++] = fo,
                            za[da++] = uo,
                            uo = r;
                            var g = ho;
                            r = fo;
                            var b = 32 - lt(g) - 1;
                            g &= ~(1 << b),
                            p += 1;
                            var C = 32 - lt(l) + b;
                            if (30 < C) {
                                var F = b - b % 5;
                                C = (g & (1 << F) - 1).toString(32),
                                g >>= F,
                                b -= F,
                                ho = 1 << 32 - lt(l) + b | p << b | g,
                                fo = C + r
                            } else
                                ho = 1 << C | p << b | g,
                                fo = r
                        }
                        function Ed(r) {
                            r.return !== null && (Ho(r, 1),
                            Qm(r, 1, 0))
                        }
                        function Hl(r) {
                            for (; r === Lh; )
                                Lh = Pr[--Cc],
                                Pr[Cc] = null,
                                Ru = Pr[--Cc],
                                Pr[Cc] = null;
                            for (; r === uo; )
                                uo = za[--da],
                                za[da] = null,
                                fo = za[--da],
                                za[da] = null,
                                ho = za[--da],
                                za[da] = null
                        }
                        function Ih(r, l) {
                            za[da++] = ho,
                            za[da++] = fo,
                            za[da++] = uo,
                            ho = l.id,
                            fo = l.overflow,
                            uo = r
                        }
                        var us = null
                          , ni = null
                          , gn = !1
                          , Go = null
                          , hs = !1
                          , Cd = Error(s(519));
                        function pn(r) {
                            var l = Error(s(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
                            throw Ph(fa(l, r)),
                            Cd
                        }
                        function wd(r) {
                            var l = r.stateNode
                              , p = r.type
                              , g = r.memoizedProps;
                            switch (l[Qt] = r,
                            l[Xi] = g,
                            p) {
                            case "dialog":
                                yn("cancel", l),
                                yn("close", l);
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                yn("load", l);
                                break;
                            case "video":
                            case "audio":
                                for (p = 0; p < Gv.length; p++)
                                    yn(Gv[p], l);
                                break;
                            case "source":
                                yn("error", l);
                                break;
                            case "img":
                            case "image":
                            case "link":
                                yn("error", l),
                                yn("load", l);
                                break;
                            case "details":
                                yn("toggle", l);
                                break;
                            case "input":
                                yn("invalid", l),
                                ls(l, g.value, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name, !0);
                                break;
                            case "select":
                                yn("invalid", l);
                                break;
                            case "textarea":
                                yn("invalid", l),
                                no(l, g.value, g.defaultValue, g.children)
                            }
                            p = g.children,
                            typeof p != "string" && typeof p != "number" && typeof p != "bigint" || l.textContent === "" + p || g.suppressHydrationWarning === !0 || jb(l.textContent, p) ? (g.popover != null && (yn("beforetoggle", l),
                            yn("toggle", l)),
                            g.onScroll != null && yn("scroll", l),
                            g.onScrollEnd != null && yn("scrollend", l),
                            g.onClick != null && (l.onclick = Ba),
                            l = !0) : l = !1,
                            l || pn(r, !0)
                        }
                        function P0(r) {
                            for (us = r.return; us; )
                                switch (us.tag) {
                                case 5:
                                case 31:
                                case 13:
                                    hs = !1;
                                    return;
                                case 27:
                                case 3:
                                    hs = !0;
                                    return;
                                default:
                                    us = us.return
                                }
                        }
                        function wc(r) {
                            if (r !== us)
                                return !1;
                            if (!gn)
                                return P0(r),
                                gn = !0,
                                !1;
                            var l = r.tag, p;
                            if ((p = l !== 3 && l !== 27) && ((p = l === 5) && (p = r.type,
                            p = !(p !== "form" && p !== "button") || qx(r.type, r.memoizedProps)),
                            p = !p),
                            p && ni && pn(r),
                            P0(r),
                            l === 13) {
                                if (r = r.memoizedState,
                                r = r !== null ? r.dehydrated : null,
                                !r)
                                    throw Error(s(317));
                                ni = iE(r)
                            } else if (l === 31) {
                                if (r = r.memoizedState,
                                r = r !== null ? r.dehydrated : null,
                                !r)
                                    throw Error(s(317));
                                ni = iE(r)
                            } else
                                l === 27 ? (l = ni,
                                Qu(r.type) ? (r = Jx,
                                Jx = null,
                                ni = r) : ni = l) : ni = us ? To(r.stateNode.nextSibling) : null;
                            return !0
                        }
                        function Dc() {
                            ni = us = null,
                            gn = !1
                        }
                        function Zm() {
                            var r = Go;
                            return r !== null && (Xs === null ? Xs = r : Xs.push.apply(Xs, r),
                            Go = null),
                            r
                        }
                        function Ph(r) {
                            Go === null ? Go = [r] : Go.push(r)
                        }
                        var Km = H(null)
                          , Vo = null
                          , Fs = null;
                        function ko(r, l, p) {
                            se(Km, l._currentValue),
                            l._currentValue = p
                        }
                        function hr(r) {
                            r._currentValue = Km.current,
                            ie(Km)
                        }
                        function Xo(r, l, p) {
                            for (; r !== null; ) {
                                var g = r.alternate;
                                if ((r.childLanes & l) !== l ? (r.childLanes |= l,
                                g !== null && (g.childLanes |= l)) : g !== null && (g.childLanes & l) !== l && (g.childLanes |= l),
                                r === p)
                                    break;
                                r = r.return
                            }
                        }
                        function Dd(r, l, p, g) {
                            var b = r.child;
                            for (b !== null && (b.return = r); b !== null; ) {
                                var C = b.dependencies;
                                if (C !== null) {
                                    var F = b.child;
                                    C = C.firstContext;
                                    e: for (; C !== null; ) {
                                        var J = C;
                                        C = b;
                                        for (var ve = 0; ve < l.length; ve++)
                                            if (J.context === l[ve]) {
                                                C.lanes |= p,
                                                J = C.alternate,
                                                J !== null && (J.lanes |= p),
                                                Xo(C.return, p, r),
                                                g || (F = null);
                                                break e
                                            }
                                        C = J.next
                                    }
                                } else if (b.tag === 18) {
                                    if (F = b.return,
                                    F === null)
                                        throw Error(s(341));
                                    F.lanes |= p,
                                    C = F.alternate,
                                    C !== null && (C.lanes |= p),
                                    Xo(F, p, r),
                                    F = null
                                } else
                                    F = b.child;
                                if (F !== null)
                                    F.return = b;
                                else
                                    for (F = b; F !== null; ) {
                                        if (F === r) {
                                            F = null;
                                            break
                                        }
                                        if (b = F.sibling,
                                        b !== null) {
                                            b.return = F.return,
                                            F = b;
                                            break
                                        }
                                        F = F.return
                                    }
                                b = F
                            }
                        }
                        function Gl(r, l, p, g) {
                            r = null;
                            for (var b = l, C = !1; b !== null; ) {
                                if (!C) {
                                    if ((b.flags & 524288) !== 0)
                                        C = !0;
                                    else if ((b.flags & 262144) !== 0)
                                        break
                                }
                                if (b.tag === 10) {
                                    var F = b.alternate;
                                    if (F === null)
                                        throw Error(s(387));
                                    if (F = F.memoizedProps,
                                    F !== null) {
                                        var J = b.type;
                                        hi(b.pendingProps.value, F.value) || (r !== null ? r.push(J) : r = [J])
                                    }
                                } else if (b === de.current) {
                                    if (F = b.alternate,
                                    F === null)
                                        throw Error(s(387));
                                    F.memoizedState.memoizedState !== b.memoizedState.memoizedState && (r !== null ? r.push(Yv) : r = [Yv])
                                }
                                b = b.return
                            }
                            r !== null && Dd(l, r, p, g),
                            l.flags |= 262144
                        }
                        function Uu(r) {
                            for (r = r.firstContext; r !== null; ) {
                                if (!hi(r.context._currentValue, r.memoizedValue))
                                    return !0;
                                r = r.next
                            }
                            return !1
                        }
                        function Rc(r) {
                            Vo = r,
                            Fs = null,
                            r = r.dependencies,
                            r !== null && (r.firstContext = null)
                        }
                        function fs(r) {
                            return Jm(Vo, r)
                        }
                        function zh(r, l) {
                            return Vo === null && Rc(r),
                            Jm(r, l)
                        }
                        function Jm(r, l) {
                            var p = l._currentValue;
                            if (l = {
                                context: l,
                                memoizedValue: p,
                                next: null
                            },
                            Fs === null) {
                                if (r === null)
                                    throw Error(s(308));
                                Fs = l,
                                r.dependencies = {
                                    lanes: 0,
                                    firstContext: l
                                },
                                r.flags |= 524288
                            } else
                                Fs = Fs.next = l;
                            return p
                        }
                        var z0 = typeof AbortController < "u" ? AbortController : function() {
                            var r = []
                              , l = this.signal = {
                                aborted: !1,
                                addEventListener: function(p, g) {
                                    r.push(g)
                                }
                            };
                            this.abort = function() {
                                l.aborted = !0,
                                r.forEach(function(p) {
                                    return p()
                                })
                            }
                        }
                          , F0 = t.unstable_scheduleCallback
                          , $m = t.unstable_NormalPriority
                          , It = {
                            $$typeof: U,
                            Consumer: null,
                            Provider: null,
                            _currentValue: null,
                            _currentValue2: null,
                            _threadCount: 0
                        };
                        function ev() {
                            return {
                                controller: new z0,
                                data: new Map,
                                refCount: 0
                            }
                        }
                        function Ms(r) {
                            r.refCount--,
                            r.refCount === 0 && F0($m, function() {
                                r.controller.abort()
                            })
                        }
                        var Uc = null
                          , tv = 0
                          , Wo = 0
                          , zr = null;
                        function Ou(r, l) {
                            if (Uc === null) {
                                var p = Uc = [];
                                tv = 0,
                                Wo = Fx(),
                                zr = {
                                    status: "pending",
                                    value: void 0,
                                    then: function(g) {
                                        p.push(g)
                                    }
                                }
                            }
                            return tv++,
                            l.then(nv, nv),
                            l
                        }
                        function nv() {
                            if (--tv === 0 && Uc !== null) {
                                zr !== null && (zr.status = "fulfilled");
                                var r = Uc;
                                Uc = null,
                                Wo = 0,
                                zr = null;
                                for (var l = 0; l < r.length; l++)
                                    (0,
                                    r[l])()
                            }
                        }
                        function iv(r, l) {
                            var p = []
                              , g = {
                                status: "pending",
                                value: null,
                                reason: null,
                                then: function(b) {
                                    p.push(b)
                                }
                            };
                            return r.then(function() {
                                g.status = "fulfilled",
                                g.value = l;
                                for (var b = 0; b < p.length; b++)
                                    (0,
                                    p[b])(l)
                            }, function(b) {
                                for (g.status = "rejected",
                                g.reason = b,
                                b = 0; b < p.length; b++)
                                    (0,
                                    p[b])(void 0)
                            }),
                            g
                        }
                        var H0 = W.S;
                        W.S = function(r, l) {
                            Yu = pe(),
                            typeof l == "object" && l !== null && typeof l.then == "function" && Ou(r, l),
                            H0 !== null && H0(r, l)
                        }
                        ;
                        var Vl = H(null);
                        function po() {
                            var r = Vl.current;
                            return r !== null ? r : zn.pooledCache
                        }
                        function Nu(r, l) {
                            l === null ? se(Vl, Vl.current) : se(Vl, l.pool)
                        }
                        function Rd() {
                            var r = po();
                            return r === null ? null : {
                                parent: It._currentValue,
                                pool: r
                            }
                        }
                        var kl = Error(s(460))
                          , Fh = Error(s(474))
                          , Fr = Error(s(542))
                          , Hh = {
                            then: function() {}
                        };
                        function G0(r) {
                            return r = r.status,
                            r === "fulfilled" || r === "rejected"
                        }
                        function sv(r, l, p) {
                            switch (p = r[p],
                            p === void 0 ? r.push(l) : p !== l && (l.then(Ba, Ba),
                            l = p),
                            l.status) {
                            case "fulfilled":
                                return l.value;
                            case "rejected":
                                throw r = l.reason,
                                av(r),
                                r;
                            default:
                                if (typeof l.status == "string")
                                    l.then(Ba, Ba);
                                else {
                                    if (r = zn,
                                    r !== null && 100 < r.shellSuspendCounter)
                                        throw Error(s(482));
                                    r = l,
                                    r.status = "pending",
                                    r.then(function(g) {
                                        if (l.status === "pending") {
                                            var b = l;
                                            b.status = "fulfilled",
                                            b.value = g
                                        }
                                    }, function(g) {
                                        if (l.status === "pending") {
                                            var b = l;
                                            b.status = "rejected",
                                            b.reason = g
                                        }
                                    })
                                }
                                switch (l.status) {
                                case "fulfilled":
                                    return l.value;
                                case "rejected":
                                    throw r = l.reason,
                                    av(r),
                                    r
                                }
                                throw Ft = l,
                                kl
                            }
                        }
                        function Oc(r) {
                            try {
                                var l = r._init;
                                return l(r._payload)
                            } catch (p) {
                                throw p !== null && typeof p == "object" && typeof p.then == "function" ? (Ft = p,
                                kl) : p
                            }
                        }
                        var Ft = null;
                        function Ud() {
                            if (Ft === null)
                                throw Error(s(459));
                            var r = Ft;
                            return Ft = null,
                            r
                        }
                        function av(r) {
                            if (r === kl || r === Fr)
                                throw Error(s(483))
                        }
                        var Xl = null
                          , Wl = 0;
                        function Od(r) {
                            var l = Wl;
                            return Wl += 1,
                            Xl === null && (Xl = []),
                            sv(Xl, r, l)
                        }
                        function Gh(r, l) {
                            l = l.props.ref,
                            r.ref = l !== void 0 ? l : null
                        }
                        function Vh(r, l) {
                            throw l.$$typeof === S ? Error(s(525)) : (r = Object.prototype.toString.call(l),
                            Error(s(31, r === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : r)))
                        }
                        function Bu(r) {
                            function l(be, _e) {
                                if (r) {
                                    var Be = be.deletions;
                                    Be === null ? (be.deletions = [_e],
                                    be.flags |= 16) : Be.push(_e)
                                }
                            }
                            function p(be, _e) {
                                if (!r)
                                    return null;
                                for (; _e !== null; )
                                    l(be, _e),
                                    _e = _e.sibling;
                                return null
                            }
                            function g(be) {
                                for (var _e = new Map; be !== null; )
                                    be.key !== null ? _e.set(be.key, be) : _e.set(be.index, be),
                                    be = be.sibling;
                                return _e
                            }
                            function b(be, _e) {
                                return be = co(be, _e),
                                be.index = 0,
                                be.sibling = null,
                                be
                            }
                            function C(be, _e, Be) {
                                return be.index = Be,
                                r ? (Be = be.alternate,
                                Be !== null ? (Be = Be.index,
                                Be < _e ? (be.flags |= 67108866,
                                _e) : Be) : (be.flags |= 67108866,
                                _e)) : (be.flags |= 1048576,
                                _e)
                            }
                            function F(be) {
                                return r && be.alternate === null && (be.flags |= 67108866),
                                be
                            }
                            function J(be, _e, Be, nt) {
                                return _e === null || _e.tag !== 6 ? (_e = bd(Be, be.mode, nt),
                                _e.return = be,
                                _e) : (_e = b(_e, Be),
                                _e.return = be,
                                _e)
                            }
                            function ve(be, _e, Be, nt) {
                                var zt = Be.type;
                                return zt === x ? Ke(be, _e, Be.props.children, nt, Be.key) : _e !== null && (_e.elementType === zt || typeof zt == "object" && zt !== null && zt.$$typeof === I && Oc(zt) === _e.type) ? (_e = b(_e, Be.props),
                                Gh(_e, Be),
                                _e.return = be,
                                _e) : (_e = Bh(Be.type, Be.key, Be.props, null, be.mode, nt),
                                Gh(_e, Be),
                                _e.return = be,
                                _e)
                            }
                            function Pe(be, _e, Be, nt) {
                                return _e === null || _e.tag !== 4 || _e.stateNode.containerInfo !== Be.containerInfo || _e.stateNode.implementation !== Be.implementation ? (_e = Ir(Be, be.mode, nt),
                                _e.return = be,
                                _e) : (_e = b(_e, Be.children || []),
                                _e.return = be,
                                _e)
                            }
                            function Ke(be, _e, Be, nt, zt) {
                                return _e === null || _e.tag !== 7 ? (_e = Fo(Be, be.mode, nt, zt),
                                _e.return = be,
                                _e) : (_e = b(_e, Be),
                                _e.return = be,
                                _e)
                            }
                            function st(be, _e, Be) {
                                if (typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint")
                                    return _e = bd("" + _e, be.mode, Be),
                                    _e.return = be,
                                    _e;
                                if (typeof _e == "object" && _e !== null) {
                                    switch (_e.$$typeof) {
                                    case A:
                                        return Be = Bh(_e.type, _e.key, _e.props, null, be.mode, Be),
                                        Gh(Be, _e),
                                        Be.return = be,
                                        Be;
                                    case M:
                                        return _e = Ir(_e, be.mode, Be),
                                        _e.return = be,
                                        _e;
                                    case I:
                                        return _e = Oc(_e),
                                        st(be, _e, Be)
                                    }
                                    if (k(_e) || q(_e))
                                        return _e = Fo(_e, be.mode, Be, null),
                                        _e.return = be,
                                        _e;
                                    if (typeof _e.then == "function")
                                        return st(be, Od(_e), Be);
                                    if (_e.$$typeof === U)
                                        return st(be, zh(be, _e), Be);
                                    Vh(be, _e)
                                }
                                return null
                            }
                            function Ve(be, _e, Be, nt) {
                                var zt = _e !== null ? _e.key : null;
                                if (typeof Be == "string" && Be !== "" || typeof Be == "number" || typeof Be == "bigint")
                                    return zt !== null ? null : J(be, _e, "" + Be, nt);
                                if (typeof Be == "object" && Be !== null) {
                                    switch (Be.$$typeof) {
                                    case A:
                                        return Be.key === zt ? ve(be, _e, Be, nt) : null;
                                    case M:
                                        return Be.key === zt ? Pe(be, _e, Be, nt) : null;
                                    case I:
                                        return Be = Oc(Be),
                                        Ve(be, _e, Be, nt)
                                    }
                                    if (k(Be) || q(Be))
                                        return zt !== null ? null : Ke(be, _e, Be, nt, null);
                                    if (typeof Be.then == "function")
                                        return Ve(be, _e, Od(Be), nt);
                                    if (Be.$$typeof === U)
                                        return Ve(be, _e, zh(be, Be), nt);
                                    Vh(be, Be)
                                }
                                return null
                            }
                            function Ye(be, _e, Be, nt, zt) {
                                if (typeof nt == "string" && nt !== "" || typeof nt == "number" || typeof nt == "bigint")
                                    return be = be.get(Be) || null,
                                    J(_e, be, "" + nt, zt);
                                if (typeof nt == "object" && nt !== null) {
                                    switch (nt.$$typeof) {
                                    case A:
                                        return be = be.get(nt.key === null ? Be : nt.key) || null,
                                        ve(_e, be, nt, zt);
                                    case M:
                                        return be = be.get(nt.key === null ? Be : nt.key) || null,
                                        Pe(_e, be, nt, zt);
                                    case I:
                                        return nt = Oc(nt),
                                        Ye(be, _e, Be, nt, zt)
                                    }
                                    if (k(nt) || q(nt))
                                        return be = be.get(Be) || null,
                                        Ke(_e, be, nt, zt, null);
                                    if (typeof nt.then == "function")
                                        return Ye(be, _e, Be, Od(nt), zt);
                                    if (nt.$$typeof === U)
                                        return Ye(be, _e, Be, zh(_e, nt), zt);
                                    Vh(_e, nt)
                                }
                                return null
                            }
                            function wt(be, _e, Be, nt) {
                                for (var zt = null, Hn = null, Nt = _e, on = _e = 0, An = null; Nt !== null && on < Be.length; on++) {
                                    Nt.index > on ? (An = Nt,
                                    Nt = null) : An = Nt.sibling;
                                    var Gn = Ve(be, Nt, Be[on], nt);
                                    if (Gn === null) {
                                        Nt === null && (Nt = An);
                                        break
                                    }
                                    r && Nt && Gn.alternate === null && l(be, Nt),
                                    _e = C(Gn, _e, on),
                                    Hn === null ? zt = Gn : Hn.sibling = Gn,
                                    Hn = Gn,
                                    Nt = An
                                }
                                if (on === Be.length)
                                    return p(be, Nt),
                                    gn && Ho(be, on),
                                    zt;
                                if (Nt === null) {
                                    for (; on < Be.length; on++)
                                        Nt = st(be, Be[on], nt),
                                        Nt !== null && (_e = C(Nt, _e, on),
                                        Hn === null ? zt = Nt : Hn.sibling = Nt,
                                        Hn = Nt);
                                    return gn && Ho(be, on),
                                    zt
                                }
                                for (Nt = g(Nt); on < Be.length; on++)
                                    An = Ye(Nt, be, on, Be[on], nt),
                                    An !== null && (r && An.alternate !== null && Nt.delete(An.key === null ? on : An.key),
                                    _e = C(An, _e, on),
                                    Hn === null ? zt = An : Hn.sibling = An,
                                    Hn = An);
                                return r && Nt.forEach(function(eh) {
                                    return l(be, eh)
                                }),
                                gn && Ho(be, on),
                                zt
                            }
                            function Gt(be, _e, Be, nt) {
                                if (Be == null)
                                    throw Error(s(151));
                                for (var zt = null, Hn = null, Nt = _e, on = _e = 0, An = null, Gn = Be.next(); Nt !== null && !Gn.done; on++,
                                Gn = Be.next()) {
                                    Nt.index > on ? (An = Nt,
                                    Nt = null) : An = Nt.sibling;
                                    var eh = Ve(be, Nt, Gn.value, nt);
                                    if (eh === null) {
                                        Nt === null && (Nt = An);
                                        break
                                    }
                                    r && Nt && eh.alternate === null && l(be, Nt),
                                    _e = C(eh, _e, on),
                                    Hn === null ? zt = eh : Hn.sibling = eh,
                                    Hn = eh,
                                    Nt = An
                                }
                                if (Gn.done)
                                    return p(be, Nt),
                                    gn && Ho(be, on),
                                    zt;
                                if (Nt === null) {
                                    for (; !Gn.done; on++,
                                    Gn = Be.next())
                                        Gn = st(be, Gn.value, nt),
                                        Gn !== null && (_e = C(Gn, _e, on),
                                        Hn === null ? zt = Gn : Hn.sibling = Gn,
                                        Hn = Gn);
                                    return gn && Ho(be, on),
                                    zt
                                }
                                for (Nt = g(Nt); !Gn.done; on++,
                                Gn = Be.next())
                                    Gn = Ye(Nt, be, on, Gn.value, nt),
                                    Gn !== null && (r && Gn.alternate !== null && Nt.delete(Gn.key === null ? on : Gn.key),
                                    _e = C(Gn, _e, on),
                                    Hn === null ? zt = Gn : Hn.sibling = Gn,
                                    Hn = Gn);
                                return r && Nt.forEach(function(yN) {
                                    return l(be, yN)
                                }),
                                gn && Ho(be, on),
                                zt
                            }
                            function ai(be, _e, Be, nt) {
                                if (typeof Be == "object" && Be !== null && Be.type === x && Be.key === null && (Be = Be.props.children),
                                typeof Be == "object" && Be !== null) {
                                    switch (Be.$$typeof) {
                                    case A:
                                        e: {
                                            for (var zt = Be.key; _e !== null; ) {
                                                if (_e.key === zt) {
                                                    if (zt = Be.type,
                                                    zt === x) {
                                                        if (_e.tag === 7) {
                                                            p(be, _e.sibling),
                                                            nt = b(_e, Be.props.children),
                                                            nt.return = be,
                                                            be = nt;
                                                            break e
                                                        }
                                                    } else if (_e.elementType === zt || typeof zt == "object" && zt !== null && zt.$$typeof === I && Oc(zt) === _e.type) {
                                                        p(be, _e.sibling),
                                                        nt = b(_e, Be.props),
                                                        Gh(nt, Be),
                                                        nt.return = be,
                                                        be = nt;
                                                        break e
                                                    }
                                                    p(be, _e);
                                                    break
                                                } else
                                                    l(be, _e);
                                                _e = _e.sibling
                                            }
                                            Be.type === x ? (nt = Fo(Be.props.children, be.mode, nt, Be.key),
                                            nt.return = be,
                                            be = nt) : (nt = Bh(Be.type, Be.key, Be.props, null, be.mode, nt),
                                            Gh(nt, Be),
                                            nt.return = be,
                                            be = nt)
                                        }
                                        return F(be);
                                    case M:
                                        e: {
                                            for (zt = Be.key; _e !== null; ) {
                                                if (_e.key === zt)
                                                    if (_e.tag === 4 && _e.stateNode.containerInfo === Be.containerInfo && _e.stateNode.implementation === Be.implementation) {
                                                        p(be, _e.sibling),
                                                        nt = b(_e, Be.children || []),
                                                        nt.return = be,
                                                        be = nt;
                                                        break e
                                                    } else {
                                                        p(be, _e);
                                                        break
                                                    }
                                                else
                                                    l(be, _e);
                                                _e = _e.sibling
                                            }
                                            nt = Ir(Be, be.mode, nt),
                                            nt.return = be,
                                            be = nt
                                        }
                                        return F(be);
                                    case I:
                                        return Be = Oc(Be),
                                        ai(be, _e, Be, nt)
                                    }
                                    if (k(Be))
                                        return wt(be, _e, Be, nt);
                                    if (q(Be)) {
                                        if (zt = q(Be),
                                        typeof zt != "function")
                                            throw Error(s(150));
                                        return Be = zt.call(Be),
                                        Gt(be, _e, Be, nt)
                                    }
                                    if (typeof Be.then == "function")
                                        return ai(be, _e, Od(Be), nt);
                                    if (Be.$$typeof === U)
                                        return ai(be, _e, zh(be, Be), nt);
                                    Vh(be, Be)
                                }
                                return typeof Be == "string" && Be !== "" || typeof Be == "number" || typeof Be == "bigint" ? (Be = "" + Be,
                                _e !== null && _e.tag === 6 ? (p(be, _e.sibling),
                                nt = b(_e, Be),
                                nt.return = be,
                                be = nt) : (p(be, _e),
                                nt = bd(Be, be.mode, nt),
                                nt.return = be,
                                be = nt),
                                F(be)) : p(be, _e)
                            }
                            return function(be, _e, Be, nt) {
                                try {
                                    Wl = 0;
                                    var zt = ai(be, _e, Be, nt);
                                    return Xl = null,
                                    zt
                                } catch (Nt) {
                                    if (Nt === kl || Nt === Fr)
                                        throw Nt;
                                    var Hn = Zs(29, Nt, null, be.mode);
                                    return Hn.lanes = nt,
                                    Hn.return = be,
                                    Hn
                                }
                            }
                        }
                        var Nc = Bu(!0)
                          , V0 = Bu(!1)
                          , Yl = !1;
                        function rv(r) {
                            r.updateQueue = {
                                baseState: r.memoizedState,
                                firstBaseUpdate: null,
                                lastBaseUpdate: null,
                                shared: {
                                    pending: null,
                                    lanes: 0,
                                    hiddenCallbacks: null
                                },
                                callbacks: null
                            }
                        }
                        function ov(r, l) {
                            r = r.updateQueue,
                            l.updateQueue === r && (l.updateQueue = {
                                baseState: r.baseState,
                                firstBaseUpdate: r.firstBaseUpdate,
                                lastBaseUpdate: r.lastBaseUpdate,
                                shared: r.shared,
                                callbacks: null
                            })
                        }
                        function Yo(r) {
                            return {
                                lane: r,
                                tag: 0,
                                payload: null,
                                callback: null,
                                next: null
                            }
                        }
                        function ql(r, l, p) {
                            var g = r.updateQueue;
                            if (g === null)
                                return null;
                            if (g = g.shared,
                            (Sn & 2) !== 0) {
                                var b = g.pending;
                                return b === null ? l.next = l : (l.next = b.next,
                                b.next = l),
                                g.pending = l,
                                l = Du(r),
                                Md(r, null, p),
                                l
                            }
                            return Nh(r, g, l, p),
                            Du(r)
                        }
                        function jl(r, l, p) {
                            if (l = l.updateQueue,
                            l !== null && (l = l.shared,
                            (p & 4194048) !== 0)) {
                                var g = l.lanes;
                                g &= r.pendingLanes,
                                p |= g,
                                l.lanes = p,
                                Bs(r, p)
                            }
                        }
                        function Nd(r, l) {
                            var p = r.updateQueue
                              , g = r.alternate;
                            if (g !== null && (g = g.updateQueue,
                            p === g)) {
                                var b = null
                                  , C = null;
                                if (p = p.firstBaseUpdate,
                                p !== null) {
                                    do {
                                        var F = {
                                            lane: p.lane,
                                            tag: p.tag,
                                            payload: p.payload,
                                            callback: null,
                                            next: null
                                        };
                                        C === null ? b = C = F : C = C.next = F,
                                        p = p.next
                                    } while (p !== null);
                                    C === null ? b = C = l : C = C.next = l
                                } else
                                    b = C = l;
                                p = {
                                    baseState: g.baseState,
                                    firstBaseUpdate: b,
                                    lastBaseUpdate: C,
                                    shared: g.shared,
                                    callbacks: g.callbacks
                                },
                                r.updateQueue = p;
                                return
                            }
                            r = p.lastBaseUpdate,
                            r === null ? p.firstBaseUpdate = l : r.next = l,
                            p.lastBaseUpdate = l
                        }
                        var lv = !1;
                        function kh() {
                            if (lv) {
                                var r = zr;
                                if (r !== null)
                                    throw r
                            }
                        }
                        function Bc(r, l, p, g) {
                            lv = !1;
                            var b = r.updateQueue;
                            Yl = !1;
                            var C = b.firstBaseUpdate
                              , F = b.lastBaseUpdate
                              , J = b.shared.pending;
                            if (J !== null) {
                                b.shared.pending = null;
                                var ve = J
                                  , Pe = ve.next;
                                ve.next = null,
                                F === null ? C = Pe : F.next = Pe,
                                F = ve;
                                var Ke = r.alternate;
                                Ke !== null && (Ke = Ke.updateQueue,
                                J = Ke.lastBaseUpdate,
                                J !== F && (J === null ? Ke.firstBaseUpdate = Pe : J.next = Pe,
                                Ke.lastBaseUpdate = ve))
                            }
                            if (C !== null) {
                                var st = b.baseState;
                                F = 0,
                                Ke = Pe = ve = null,
                                J = C;
                                do {
                                    var Ve = J.lane & -536870913
                                      , Ye = Ve !== J.lane;
                                    if (Ye ? (mn & Ve) === Ve : (g & Ve) === Ve) {
                                        Ve !== 0 && Ve === Wo && (lv = !0),
                                        Ke !== null && (Ke = Ke.next = {
                                            lane: 0,
                                            tag: J.tag,
                                            payload: J.payload,
                                            callback: null,
                                            next: null
                                        });
                                        e: {
                                            var wt = r
                                              , Gt = J;
                                            Ve = l;
                                            var ai = p;
                                            switch (Gt.tag) {
                                            case 1:
                                                if (wt = Gt.payload,
                                                typeof wt == "function") {
                                                    st = wt.call(ai, st, Ve);
                                                    break e
                                                }
                                                st = wt;
                                                break e;
                                            case 3:
                                                wt.flags = wt.flags & -65537 | 128;
                                            case 0:
                                                if (wt = Gt.payload,
                                                Ve = typeof wt == "function" ? wt.call(ai, st, Ve) : wt,
                                                Ve == null)
                                                    break e;
                                                st = y({}, st, Ve);
                                                break e;
                                            case 2:
                                                Yl = !0
                                            }
                                        }
                                        Ve = J.callback,
                                        Ve !== null && (r.flags |= 64,
                                        Ye && (r.flags |= 8192),
                                        Ye = b.callbacks,
                                        Ye === null ? b.callbacks = [Ve] : Ye.push(Ve))
                                    } else
                                        Ye = {
                                            lane: Ve,
                                            tag: J.tag,
                                            payload: J.payload,
                                            callback: J.callback,
                                            next: null
                                        },
                                        Ke === null ? (Pe = Ke = Ye,
                                        ve = st) : Ke = Ke.next = Ye,
                                        F |= Ve;
                                    if (J = J.next,
                                    J === null) {
                                        if (J = b.shared.pending,
                                        J === null)
                                            break;
                                        Ye = J,
                                        J = Ye.next,
                                        Ye.next = null,
                                        b.lastBaseUpdate = Ye,
                                        b.shared.pending = null
                                    }
                                } while (!0);
                                Ke === null && (ve = st),
                                b.baseState = ve,
                                b.firstBaseUpdate = Pe,
                                b.lastBaseUpdate = Ke,
                                C === null && (b.shared.lanes = 0),
                                Qa |= F,
                                r.lanes = F,
                                r.memoizedState = st
                            }
                        }
                        function mo(r, l) {
                            if (typeof r != "function")
                                throw Error(s(191, r));
                            r.call(l)
                        }
                        function bs(r, l) {
                            var p = r.callbacks;
                            if (p !== null)
                                for (r.callbacks = null,
                                r = 0; r < p.length; r++)
                                    mo(p[r], l)
                        }
                        var Fa = H(null)
                          , Js = H(0);
                        function cv(r, l) {
                            r = zi,
                            se(Js, r),
                            se(Fa, l),
                            zi = r | l.baseLanes
                        }
                        function uv() {
                            se(Js, zi),
                            se(Fa, Fa.current)
                        }
                        function Hs() {
                            zi = Js.current,
                            ie(Fa),
                            ie(Js)
                        }
                        var ns = H(null)
                          , fr = null;
                        function Ql(r) {
                            var l = r.alternate;
                            se(Mi, Mi.current & 1),
                            se(ns, r),
                            fr === null && (l === null || Fa.current !== null || l.memoizedState !== null) && (fr = r)
                        }
                        function hv(r) {
                            se(Mi, Mi.current),
                            se(ns, r),
                            fr === null && (fr = r)
                        }
                        function k0(r) {
                            r.tag === 22 ? (se(Mi, Mi.current),
                            se(ns, r),
                            fr === null && (fr = r)) : qo(r)
                        }
                        function qo() {
                            se(Mi, Mi.current),
                            se(ns, ns.current)
                        }
                        function Ha(r) {
                            ie(ns),
                            fr === r && (fr = null),
                            ie(Mi)
                        }
                        var Mi = H(0);
                        function Bd(r) {
                            for (var l = r; l !== null; ) {
                                if (l.tag === 13) {
                                    var p = l.memoizedState;
                                    if (p !== null && (p = p.dehydrated,
                                    p === null || Zx(p) || Kx(p)))
                                        return l
                                } else if (l.tag === 19 && (l.memoizedProps.revealOrder === "forwards" || l.memoizedProps.revealOrder === "backwards" || l.memoizedProps.revealOrder === "unstable_legacy-backwards" || l.memoizedProps.revealOrder === "together")) {
                                    if ((l.flags & 128) !== 0)
                                        return l
                                } else if (l.child !== null) {
                                    l.child.return = l,
                                    l = l.child;
                                    continue
                                }
                                if (l === r)
                                    break;
                                for (; l.sibling === null; ) {
                                    if (l.return === null || l.return === r)
                                        return null;
                                    l = l.return
                                }
                                l.sibling.return = l.return,
                                l = l.sibling
                            }
                            return null
                        }
                        var pa = 0
                          , Vt = null
                          , jn = null
                          , qi = null
                          , Ld = !1
                          , vo = !1
                          , Lc = !1
                          , Id = 0
                          , Xh = 0
                          , go = null
                          , wx = 0;
                        function bi() {
                            throw Error(s(321))
                        }
                        function fv(r, l) {
                            if (l === null)
                                return !1;
                            for (var p = 0; p < l.length && p < r.length; p++)
                                if (!hi(r[p], l[p]))
                                    return !1;
                            return !0
                        }
                        function dv(r, l, p, g, b, C) {
                            return pa = C,
                            Vt = l,
                            l.memoizedState = null,
                            l.updateQueue = null,
                            l.lanes = 0,
                            W.H = r === null || r.memoizedState === null ? cy : Pu,
                            Lc = !1,
                            C = p(g, b),
                            Lc = !1,
                            vo && (C = W0(l, p, g, b)),
                            X0(r),
                            C
                        }
                        function X0(r) {
                            W.H = Qh;
                            var l = jn !== null && jn.next !== null;
                            if (pa = 0,
                            qi = jn = Vt = null,
                            Ld = !1,
                            Xh = 0,
                            go = null,
                            l)
                                throw Error(s(300));
                            r === null || fi || (r = r.dependencies,
                            r !== null && Uu(r) && (fi = !0))
                        }
                        function W0(r, l, p, g) {
                            Vt = r;
                            var b = 0;
                            do {
                                if (vo && (go = null),
                                Xh = 0,
                                vo = !1,
                                25 <= b)
                                    throw Error(s(301));
                                if (b += 1,
                                qi = jn = null,
                                r.updateQueue != null) {
                                    var C = r.updateQueue;
                                    C.lastEffect = null,
                                    C.events = null,
                                    C.stores = null,
                                    C.memoCache != null && (C.memoCache.index = 0)
                                }
                                W.H = Zh,
                                C = l(p, g)
                            } while (vo);
                            return C
                        }
                        function Dx() {
                            var r = W.H
                              , l = r.useState()[0];
                            return l = typeof l.then == "function" ? Yh(l) : l,
                            r = r.useState()[0],
                            (jn !== null ? jn.memoizedState : null) !== r && (Vt.flags |= 1024),
                            l
                        }
                        function pv() {
                            var r = Id !== 0;
                            return Id = 0,
                            r
                        }
                        function mv(r, l, p) {
                            l.updateQueue = r.updateQueue,
                            l.flags &= -2053,
                            r.lanes &= ~p
                        }
                        function vv(r) {
                            if (Ld) {
                                for (r = r.memoizedState; r !== null; ) {
                                    var l = r.queue;
                                    l !== null && (l.pending = null),
                                    r = r.next
                                }
                                Ld = !1
                            }
                            pa = 0,
                            qi = jn = Vt = null,
                            vo = !1,
                            Xh = Id = 0,
                            go = null
                        }
                        function $s() {
                            var r = {
                                memoizedState: null,
                                baseState: null,
                                baseQueue: null,
                                queue: null,
                                next: null
                            };
                            return qi === null ? Vt.memoizedState = qi = r : qi = qi.next = r,
                            qi
                        }
                        function Bi() {
                            if (jn === null) {
                                var r = Vt.alternate;
                                r = r !== null ? r.memoizedState : null
                            } else
                                r = jn.next;
                            var l = qi === null ? Vt.memoizedState : qi.next;
                            if (l !== null)
                                qi = l,
                                jn = r;
                            else {
                                if (r === null)
                                    throw Vt.alternate === null ? Error(s(467)) : Error(s(310));
                                jn = r,
                                r = {
                                    memoizedState: jn.memoizedState,
                                    baseState: jn.baseState,
                                    baseQueue: jn.baseQueue,
                                    queue: jn.queue,
                                    next: null
                                },
                                qi === null ? Vt.memoizedState = qi = r : qi = qi.next = r
                            }
                            return qi
                        }
                        function Wh() {
                            return {
                                lastEffect: null,
                                events: null,
                                stores: null,
                                memoCache: null
                            }
                        }
                        function Yh(r) {
                            var l = Xh;
                            return Xh += 1,
                            go === null && (go = []),
                            r = sv(go, r, l),
                            l = Vt,
                            (qi === null ? l.memoizedState : qi.next) === null && (l = l.alternate,
                            W.H = l === null || l.memoizedState === null ? cy : Pu),
                            r
                        }
                        function Pd(r) {
                            if (r !== null && typeof r == "object") {
                                if (typeof r.then == "function")
                                    return Yh(r);
                                if (r.$$typeof === U)
                                    return fs(r)
                            }
                            throw Error(s(438, String(r)))
                        }
                        function gv(r) {
                            var l = null
                              , p = Vt.updateQueue;
                            if (p !== null && (l = p.memoCache),
                            l == null) {
                                var g = Vt.alternate;
                                g !== null && (g = g.updateQueue,
                                g !== null && (g = g.memoCache,
                                g != null && (l = {
                                    data: g.data.map(function(b) {
                                        return b.slice()
                                    }),
                                    index: 0
                                })))
                            }
                            if (l ??= {
                                data: [],
                                index: 0
                            },
                            p === null && (p = Wh(),
                            Vt.updateQueue = p),
                            p.memoCache = l,
                            p = l.data[l.index],
                            p === void 0)
                                for (p = l.data[l.index] = Array(r),
                                g = 0; g < r; g++)
                                    p[g] = G;
                            return l.index++,
                            p
                        }
                        function jo(r, l) {
                            return typeof l == "function" ? l(r) : l
                        }
                        function zd(r) {
                            var l = Bi();
                            return yv(l, jn, r)
                        }
                        function yv(r, l, p) {
                            var g = r.queue;
                            if (g === null)
                                throw Error(s(311));
                            g.lastRenderedReducer = p;
                            var b = r.baseQueue
                              , C = g.pending;
                            if (C !== null) {
                                if (b !== null) {
                                    var F = b.next;
                                    b.next = C.next,
                                    C.next = F
                                }
                                l.baseQueue = b = C,
                                g.pending = null
                            }
                            if (C = r.baseState,
                            b === null)
                                r.memoizedState = C;
                            else {
                                l = b.next;
                                var J = F = null
                                  , ve = null
                                  , Pe = l
                                  , Ke = !1;
                                do {
                                    var st = Pe.lane & -536870913;
                                    if (st !== Pe.lane ? (mn & st) === st : (pa & st) === st) {
                                        var Ve = Pe.revertLane;
                                        if (Ve === 0)
                                            ve !== null && (ve = ve.next = {
                                                lane: 0,
                                                revertLane: 0,
                                                gesture: null,
                                                action: Pe.action,
                                                hasEagerState: Pe.hasEagerState,
                                                eagerState: Pe.eagerState,
                                                next: null
                                            }),
                                            st === Wo && (Ke = !0);
                                        else if ((pa & Ve) === Ve) {
                                            Pe = Pe.next,
                                            Ve === Wo && (Ke = !0);
                                            continue
                                        } else
                                            st = {
                                                lane: 0,
                                                revertLane: Pe.revertLane,
                                                gesture: null,
                                                action: Pe.action,
                                                hasEagerState: Pe.hasEagerState,
                                                eagerState: Pe.eagerState,
                                                next: null
                                            },
                                            ve === null ? (J = ve = st,
                                            F = C) : ve = ve.next = st,
                                            Vt.lanes |= Ve,
                                            Qa |= Ve;
                                        st = Pe.action,
                                        Lc && p(C, st),
                                        C = Pe.hasEagerState ? Pe.eagerState : p(C, st)
                                    } else
                                        Ve = {
                                            lane: st,
                                            revertLane: Pe.revertLane,
                                            gesture: Pe.gesture,
                                            action: Pe.action,
                                            hasEagerState: Pe.hasEagerState,
                                            eagerState: Pe.eagerState,
                                            next: null
                                        },
                                        ve === null ? (J = ve = Ve,
                                        F = C) : ve = ve.next = Ve,
                                        Vt.lanes |= st,
                                        Qa |= st;
                                    Pe = Pe.next
                                } while (Pe !== null && Pe !== l);
                                if (ve === null ? F = C : ve.next = J,
                                !hi(C, r.memoizedState) && (fi = !0,
                                Ke && (p = zr,
                                p !== null)))
                                    throw p;
                                r.memoizedState = C,
                                r.baseState = F,
                                r.baseQueue = ve,
                                g.lastRenderedState = C
                            }
                            return b === null && (g.lanes = 0),
                            [r.memoizedState, g.dispatch]
                        }
                        function Fd(r) {
                            var l = Bi()
                              , p = l.queue;
                            if (p === null)
                                throw Error(s(311));
                            p.lastRenderedReducer = r;
                            var g = p.dispatch
                              , b = p.pending
                              , C = l.memoizedState;
                            if (b !== null) {
                                p.pending = null;
                                var F = b = b.next;
                                do
                                    C = r(C, F.action),
                                    F = F.next;
                                while (F !== b);
                                hi(C, l.memoizedState) || (fi = !0),
                                l.memoizedState = C,
                                l.baseQueue === null && (l.baseState = C),
                                p.lastRenderedState = C
                            }
                            return [C, g]
                        }
                        function _v(r, l, p) {
                            var g = Vt
                              , b = Bi()
                              , C = gn;
                            if (C) {
                                if (p === void 0)
                                    throw Error(s(407));
                                p = p()
                            } else
                                p = l();
                            var F = !hi((jn || b).memoizedState, p);
                            if (F && (b.memoizedState = p,
                            fi = !0),
                            b = b.queue,
                            Mv(xv.bind(null, g, b, r), [r]),
                            b.getSnapshot !== l || F || qi !== null && qi.memoizedState.tag & 1) {
                                if (g.flags |= 2048,
                                Lu(9, {
                                    destroy: void 0
                                }, Sv.bind(null, g, b, p, l), null),
                                zn === null)
                                    throw Error(s(349));
                                C || (pa & 127) !== 0 || Y0(g, l, p)
                            }
                            return p
                        }
                        function Y0(r, l, p) {
                            r.flags |= 16384,
                            r = {
                                getSnapshot: l,
                                value: p
                            },
                            l = Vt.updateQueue,
                            l === null ? (l = Wh(),
                            Vt.updateQueue = l,
                            l.stores = [r]) : (p = l.stores,
                            p === null ? l.stores = [r] : p.push(r))
                        }
                        function Sv(r, l, p, g) {
                            l.value = p,
                            l.getSnapshot = g,
                            Av(l) && Hd(r)
                        }
                        function xv(r, l, p) {
                            return p(function() {
                                Av(l) && Hd(r)
                            })
                        }
                        function Av(r) {
                            var l = r.getSnapshot;
                            r = r.value;
                            try {
                                var p = l();
                                return !hi(r, p)
                            } catch {
                                return !0
                            }
                        }
                        function Hd(r) {
                            var l = zl(r, 2);
                            l !== null && d(l, r, 2)
                        }
                        function qh(r) {
                            var l = $s();
                            if (typeof r == "function") {
                                var p = r;
                                if (r = p(),
                                Lc) {
                                    ht(!0);
                                    try {
                                        p()
                                    } finally {
                                        ht(!1)
                                    }
                                }
                            }
                            return l.memoizedState = l.baseState = r,
                            l.queue = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: jo,
                                lastRenderedState: r
                            },
                            l
                        }
                        function q0(r, l, p, g) {
                            return r.baseState = p,
                            yv(r, jn, typeof g == "function" ? g : jo)
                        }
                        function Rx(r, l, p, g, b) {
                            if (Qo(r))
                                throw Error(s(485));
                            if (r = l.action,
                            r !== null) {
                                var C = {
                                    payload: b,
                                    action: r,
                                    next: null,
                                    isTransition: !0,
                                    status: "pending",
                                    value: null,
                                    reason: null,
                                    listeners: [],
                                    then: function(F) {
                                        C.listeners.push(F)
                                    }
                                };
                                W.T !== null ? p(!0) : C.isTransition = !1,
                                g(C),
                                p = l.pending,
                                p === null ? (C.next = l.pending = C,
                                j0(l, C)) : (C.next = p.next,
                                l.pending = p.next = C)
                            }
                        }
                        function j0(r, l) {
                            var p = l.action
                              , g = l.payload
                              , b = r.state;
                            if (l.isTransition) {
                                var C = W.T
                                  , F = {};
                                W.T = F;
                                try {
                                    var J = p(b, g)
                                      , ve = W.S;
                                    ve !== null && ve(F, J),
                                    Q0(r, l, J)
                                } catch (Pe) {
                                    Gd(r, l, Pe)
                                } finally {
                                    C !== null && F.types !== null && (C.types = F.types),
                                    W.T = C
                                }
                            } else
                                try {
                                    C = p(b, g),
                                    Q0(r, l, C)
                                } catch (Pe) {
                                    Gd(r, l, Pe)
                                }
                        }
                        function Q0(r, l, p) {
                            p !== null && typeof p == "object" && typeof p.then == "function" ? p.then(function(g) {
                                Tv(r, l, g)
                            }, function(g) {
                                return Gd(r, l, g)
                            }) : Tv(r, l, p)
                        }
                        function Tv(r, l, p) {
                            l.status = "fulfilled",
                            l.value = p,
                            Z0(l),
                            r.state = p,
                            l = r.pending,
                            l !== null && (p = l.next,
                            p === l ? r.pending = null : (p = p.next,
                            l.next = p,
                            j0(r, p)))
                        }
                        function Gd(r, l, p) {
                            var g = r.pending;
                            if (r.pending = null,
                            g !== null) {
                                g = g.next;
                                do
                                    l.status = "rejected",
                                    l.reason = p,
                                    Z0(l),
                                    l = l.next;
                                while (l !== g)
                            }
                            r.action = null
                        }
                        function Z0(r) {
                            r = r.listeners;
                            for (var l = 0; l < r.length; l++)
                                (0,
                                r[l])()
                        }
                        function K0(r, l) {
                            return l
                        }
                        function J0(r, l) {
                            if (gn) {
                                var p = zn.formState;
                                if (p !== null) {
                                    e: {
                                        var g = Vt;
                                        if (gn) {
                                            if (ni) {
                                                t: {
                                                    for (var b = ni, C = hs; b.nodeType !== 8; ) {
                                                        if (!C) {
                                                            b = null;
                                                            break t
                                                        }
                                                        if (b = To(b.nextSibling),
                                                        b === null) {
                                                            b = null;
                                                            break t
                                                        }
                                                    }
                                                    C = b.data,
                                                    b = C === "F!" || C === "F" ? b : null
                                                }
                                                if (b) {
                                                    ni = To(b.nextSibling),
                                                    g = b.data === "F!";
                                                    break e
                                                }
                                            }
                                            pn(g)
                                        }
                                        g = !1
                                    }
                                    g && (l = p[0])
                                }
                            }
                            return p = $s(),
                            p.memoizedState = p.baseState = l,
                            g = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: K0,
                                lastRenderedState: l
                            },
                            p.queue = g,
                            p = ly.bind(null, Vt, g),
                            g.dispatch = p,
                            g = qh(!1),
                            C = jh.bind(null, Vt, !1, g.queue),
                            g = $s(),
                            b = {
                                state: l,
                                dispatch: null,
                                action: r,
                                pending: null
                            },
                            g.queue = b,
                            p = Rx.bind(null, Vt, b, C, p),
                            b.dispatch = p,
                            g.memoizedState = r,
                            [l, p, !1]
                        }
                        function $0(r) {
                            var l = Bi();
                            return ey(l, jn, r)
                        }
                        function ey(r, l, p) {
                            if (l = yv(r, l, K0)[0],
                            r = zd(jo)[0],
                            typeof l == "object" && l !== null && typeof l.then == "function")
                                try {
                                    var g = Yh(l)
                                } catch (F) {
                                    throw F === kl ? Fr : F
                                }
                            else
                                g = l;
                            l = Bi();
                            var b = l.queue
                              , C = b.dispatch;
                            return p !== l.memoizedState && (Vt.flags |= 2048,
                            Lu(9, {
                                destroy: void 0
                            }, Ux.bind(null, b, p), null)),
                            [g, C, r]
                        }
                        function Ux(r, l) {
                            r.action = l
                        }
                        function ty(r) {
                            var l = Bi()
                              , p = jn;
                            if (p !== null)
                                return ey(l, p, r);
                            Bi(),
                            l = l.memoizedState,
                            p = Bi();
                            var g = p.queue.dispatch;
                            return p.memoizedState = r,
                            [l, g, !1]
                        }
                        function Lu(r, l, p, g) {
                            return r = {
                                tag: r,
                                create: p,
                                deps: g,
                                inst: l,
                                next: null
                            },
                            l = Vt.updateQueue,
                            l === null && (l = Wh(),
                            Vt.updateQueue = l),
                            p = l.lastEffect,
                            p === null ? l.lastEffect = r.next = r : (g = p.next,
                            p.next = r,
                            r.next = g,
                            l.lastEffect = r),
                            r
                        }
                        function ny() {
                            return Bi().memoizedState
                        }
                        function Vd(r, l, p, g) {
                            var b = $s();
                            Vt.flags |= r,
                            b.memoizedState = Lu(1 | l, {
                                destroy: void 0
                            }, p, g === void 0 ? null : g)
                        }
                        function kd(r, l, p, g) {
                            var b = Bi();
                            g = g === void 0 ? null : g;
                            var C = b.memoizedState.inst;
                            jn !== null && g !== null && fv(g, jn.memoizedState.deps) ? b.memoizedState = Lu(l, C, p, g) : (Vt.flags |= r,
                            b.memoizedState = Lu(1 | l, C, p, g))
                        }
                        function iy(r, l) {
                            Vd(8390656, 8, r, l)
                        }
                        function Mv(r, l) {
                            kd(2048, 8, r, l)
                        }
                        function sy(r) {
                            Vt.flags |= 4;
                            var l = Vt.updateQueue;
                            if (l === null)
                                l = Wh(),
                                Vt.updateQueue = l,
                                l.events = [r];
                            else {
                                var p = l.events;
                                p === null ? l.events = [r] : p.push(r)
                            }
                        }
                        function ay(r) {
                            var l = Bi().memoizedState;
                            return sy({
                                ref: l,
                                nextImpl: r
                            }),
                            function() {
                                if ((Sn & 2) !== 0)
                                    throw Error(s(440));
                                return l.impl.apply(void 0, arguments)
                            }
                        }
                        function ry(r, l) {
                            return kd(4, 2, r, l)
                        }
                        function Ga(r, l) {
                            return kd(4, 4, r, l)
                        }
                        function bv(r, l) {
                            if (typeof l == "function") {
                                r = r();
                                var p = l(r);
                                return function() {
                                    typeof p == "function" ? p() : l(null)
                                }
                            }
                            if (l != null)
                                return r = r(),
                                l.current = r,
                                function() {
                                    l.current = null
                                }
                        }
                        function Xd(r, l, p) {
                            p = p != null ? p.concat([r]) : null,
                            kd(4, 4, bv.bind(null, l, r), p)
                        }
                        function Wd() {}
                        function Ev(r, l) {
                            var p = Bi();
                            l = l === void 0 ? null : l;
                            var g = p.memoizedState;
                            return l !== null && fv(l, g[1]) ? g[0] : (p.memoizedState = [r, l],
                            r)
                        }
                        function Cv(r, l) {
                            var p = Bi();
                            l = l === void 0 ? null : l;
                            var g = p.memoizedState;
                            if (l !== null && fv(l, g[1]))
                                return g[0];
                            if (g = r(),
                            Lc) {
                                ht(!0);
                                try {
                                    r()
                                } finally {
                                    ht(!1)
                                }
                            }
                            return p.memoizedState = [g, l],
                            g
                        }
                        function wv(r, l, p) {
                            return p === void 0 || (pa & 1073741824) !== 0 && (mn & 261930) === 0 ? r.memoizedState = l : (r.memoizedState = p,
                            r = h(),
                            Vt.lanes |= r,
                            Qa |= r,
                            p)
                        }
                        function Dv(r, l, p, g) {
                            return hi(p, l) ? p : Fa.current !== null ? (r = wv(r, p, g),
                            hi(r, l) || (fi = !0),
                            r) : (pa & 42) === 0 || (pa & 1073741824) !== 0 && (mn & 261930) === 0 ? (fi = !0,
                            r.memoizedState = p) : (r = h(),
                            Vt.lanes |= r,
                            Qa |= r,
                            l)
                        }
                        function Rv(r, l, p, g, b) {
                            var C = V.p;
                            V.p = C !== 0 && 8 > C ? C : 8;
                            var F = W.T
                              , J = {};
                            W.T = J,
                            jh(r, !1, l, p);
                            try {
                                var ve = b()
                                  , Pe = W.S;
                                if (Pe !== null && Pe(J, ve),
                                ve !== null && typeof ve == "object" && typeof ve.then == "function") {
                                    var Ke = iv(ve, g);
                                    Iu(r, l, Ke, xa(r))
                                } else
                                    Iu(r, l, g, xa(r))
                            } catch (st) {
                                Iu(r, l, {
                                    then: function() {},
                                    status: "rejected",
                                    reason: st
                                }, xa())
                            } finally {
                                V.p = C,
                                F !== null && J.types !== null && (F.types = J.types),
                                W.T = F
                            }
                        }
                        function Ox() {}
                        function Uv(r, l, p, g) {
                            if (r.tag !== 5)
                                throw Error(s(476));
                            var b = oy(r).queue;
                            Rv(r, b, l, Z, p === null ? Ox : function() {
                                return Ov(r),
                                p(g)
                            }
                            )
                        }
                        function oy(r) {
                            var l = r.memoizedState;
                            if (l !== null)
                                return l;
                            l = {
                                memoizedState: Z,
                                baseState: Z,
                                baseQueue: null,
                                queue: {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: jo,
                                    lastRenderedState: Z
                                },
                                next: null
                            };
                            var p = {};
                            return l.next = {
                                memoizedState: p,
                                baseState: p,
                                baseQueue: null,
                                queue: {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: jo,
                                    lastRenderedState: p
                                },
                                next: null
                            },
                            r.memoizedState = l,
                            r = r.alternate,
                            r !== null && (r.memoizedState = l),
                            l
                        }
                        function Ov(r) {
                            var l = oy(r);
                            l.next === null && (l = r.alternate.memoizedState),
                            Iu(r, l.next.queue, {}, xa())
                        }
                        function Nv() {
                            return fs(Yv)
                        }
                        function Es() {
                            return Bi().memoizedState
                        }
                        function Bv() {
                            return Bi().memoizedState
                        }
                        function Nx(r) {
                            for (var l = r.return; l !== null; ) {
                                switch (l.tag) {
                                case 24:
                                case 3:
                                    var p = xa();
                                    r = Yo(p);
                                    var g = ql(l, r, p);
                                    g !== null && (d(g, l, p),
                                    jl(g, l, p)),
                                    l = {
                                        cache: ev()
                                    },
                                    r.payload = l;
                                    return
                                }
                                l = l.return
                            }
                        }
                        function Bx(r, l, p) {
                            var g = xa();
                            p = {
                                lane: g,
                                revertLane: 0,
                                gesture: null,
                                action: p,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            },
                            Qo(r) ? Ic(l, p) : (p = wu(r, l, p, g),
                            p !== null && (d(p, r, g),
                            ma(p, l, g)))
                        }
                        function ly(r, l, p) {
                            var g = xa();
                            Iu(r, l, p, g)
                        }
                        function Iu(r, l, p, g) {
                            var b = {
                                lane: g,
                                revertLane: 0,
                                gesture: null,
                                action: p,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            };
                            if (Qo(r))
                                Ic(l, b);
                            else {
                                var C = r.alternate;
                                if (r.lanes === 0 && (C === null || C.lanes === 0) && (C = l.lastRenderedReducer,
                                C !== null))
                                    try {
                                        var F = l.lastRenderedState
                                          , J = C(F, p);
                                        if (b.hasEagerState = !0,
                                        b.eagerState = J,
                                        hi(J, F))
                                            return Nh(r, l, b, 0),
                                            zn === null && Pl(),
                                            !1
                                    } catch {}
                                if (p = wu(r, l, b, g),
                                p !== null)
                                    return d(p, r, g),
                                    ma(p, l, g),
                                    !0
                            }
                            return !1
                        }
                        function jh(r, l, p, g) {
                            if (g = {
                                lane: 2,
                                revertLane: Fx(),
                                gesture: null,
                                action: g,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            },
                            Qo(r)) {
                                if (l)
                                    throw Error(s(479))
                            } else
                                l = wu(r, p, g, 2),
                                l !== null && d(l, r, 2)
                        }
                        function Qo(r) {
                            var l = r.alternate;
                            return r === Vt || l !== null && l === Vt
                        }
                        function Ic(r, l) {
                            vo = Ld = !0;
                            var p = r.pending;
                            p === null ? l.next = l : (l.next = p.next,
                            p.next = l),
                            r.pending = l
                        }
                        function ma(r, l, p) {
                            if ((p & 4194048) !== 0) {
                                var g = l.lanes;
                                g &= r.pendingLanes,
                                p |= g,
                                l.lanes = p,
                                Bs(r, p)
                            }
                        }
                        var Qh = {
                            readContext: fs,
                            use: Pd,
                            useCallback: bi,
                            useContext: bi,
                            useEffect: bi,
                            useImperativeHandle: bi,
                            useLayoutEffect: bi,
                            useInsertionEffect: bi,
                            useMemo: bi,
                            useReducer: bi,
                            useRef: bi,
                            useState: bi,
                            useDebugValue: bi,
                            useDeferredValue: bi,
                            useTransition: bi,
                            useSyncExternalStore: bi,
                            useId: bi,
                            useHostTransitionStatus: bi,
                            useFormState: bi,
                            useActionState: bi,
                            useOptimistic: bi,
                            useMemoCache: bi,
                            useCacheRefresh: bi
                        };
                        Qh.useEffectEvent = bi;
                        var cy = {
                            readContext: fs,
                            use: Pd,
                            useCallback: function(r, l) {
                                return $s().memoizedState = [r, l === void 0 ? null : l],
                                r
                            },
                            useContext: fs,
                            useEffect: iy,
                            useImperativeHandle: function(r, l, p) {
                                p = p != null ? p.concat([r]) : null,
                                Vd(4194308, 4, bv.bind(null, l, r), p)
                            },
                            useLayoutEffect: function(r, l) {
                                return Vd(4194308, 4, r, l)
                            },
                            useInsertionEffect: function(r, l) {
                                Vd(4, 2, r, l)
                            },
                            useMemo: function(r, l) {
                                var p = $s();
                                l = l === void 0 ? null : l;
                                var g = r();
                                if (Lc) {
                                    ht(!0);
                                    try {
                                        r()
                                    } finally {
                                        ht(!1)
                                    }
                                }
                                return p.memoizedState = [g, l],
                                g
                            },
                            useReducer: function(r, l, p) {
                                var g = $s();
                                if (p !== void 0) {
                                    var b = p(l);
                                    if (Lc) {
                                        ht(!0);
                                        try {
                                            p(l)
                                        } finally {
                                            ht(!1)
                                        }
                                    }
                                } else
                                    b = l;
                                return g.memoizedState = g.baseState = b,
                                r = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: r,
                                    lastRenderedState: b
                                },
                                g.queue = r,
                                r = r.dispatch = Bx.bind(null, Vt, r),
                                [g.memoizedState, r]
                            },
                            useRef: function(r) {
                                var l = $s();
                                return r = {
                                    current: r
                                },
                                l.memoizedState = r
                            },
                            useState: function(r) {
                                r = qh(r);
                                var l = r.queue
                                  , p = ly.bind(null, Vt, l);
                                return l.dispatch = p,
                                [r.memoizedState, p]
                            },
                            useDebugValue: Wd,
                            useDeferredValue: function(r, l) {
                                var p = $s();
                                return wv(p, r, l)
                            },
                            useTransition: function() {
                                var r = qh(!1);
                                return r = Rv.bind(null, Vt, r.queue, !0, !1),
                                $s().memoizedState = r,
                                [!1, r]
                            },
                            useSyncExternalStore: function(r, l, p) {
                                var g = Vt
                                  , b = $s();
                                if (gn) {
                                    if (p === void 0)
                                        throw Error(s(407));
                                    p = p()
                                } else {
                                    if (p = l(),
                                    zn === null)
                                        throw Error(s(349));
                                    (mn & 127) !== 0 || Y0(g, l, p)
                                }
                                b.memoizedState = p;
                                var C = {
                                    value: p,
                                    getSnapshot: l
                                };
                                return b.queue = C,
                                iy(xv.bind(null, g, C, r), [r]),
                                g.flags |= 2048,
                                Lu(9, {
                                    destroy: void 0
                                }, Sv.bind(null, g, C, p, l), null),
                                p
                            },
                            useId: function() {
                                var r = $s()
                                  , l = zn.identifierPrefix;
                                if (gn) {
                                    var p = fo
                                      , g = ho;
                                    p = (g & ~(1 << 32 - lt(g) - 1)).toString(32) + p,
                                    l = "_" + l + "R_" + p,
                                    p = Id++,
                                    0 < p && (l += "H" + p.toString(32)),
                                    l += "_"
                                } else
                                    p = wx++,
                                    l = "_" + l + "r_" + p.toString(32) + "_";
                                return r.memoizedState = l
                            },
                            useHostTransitionStatus: Nv,
                            useFormState: J0,
                            useActionState: J0,
                            useOptimistic: function(r) {
                                var l = $s();
                                l.memoizedState = l.baseState = r;
                                var p = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: null,
                                    lastRenderedState: null
                                };
                                return l.queue = p,
                                l = jh.bind(null, Vt, !0, p),
                                p.dispatch = l,
                                [r, l]
                            },
                            useMemoCache: gv,
                            useCacheRefresh: function() {
                                return $s().memoizedState = Nx.bind(null, Vt)
                            },
                            useEffectEvent: function(r) {
                                var l = $s()
                                  , p = {
                                    impl: r
                                };
                                return l.memoizedState = p,
                                function() {
                                    if ((Sn & 2) !== 0)
                                        throw Error(s(440));
                                    return p.impl.apply(void 0, arguments)
                                }
                            }
                        }
                          , Pu = {
                            readContext: fs,
                            use: Pd,
                            useCallback: Ev,
                            useContext: fs,
                            useEffect: Mv,
                            useImperativeHandle: Xd,
                            useInsertionEffect: ry,
                            useLayoutEffect: Ga,
                            useMemo: Cv,
                            useReducer: zd,
                            useRef: ny,
                            useState: function() {
                                return zd(jo)
                            },
                            useDebugValue: Wd,
                            useDeferredValue: function(r, l) {
                                var p = Bi();
                                return Dv(p, jn.memoizedState, r, l)
                            },
                            useTransition: function() {
                                var r = zd(jo)[0]
                                  , l = Bi().memoizedState;
                                return [typeof r == "boolean" ? r : Yh(r), l]
                            },
                            useSyncExternalStore: _v,
                            useId: Es,
                            useHostTransitionStatus: Nv,
                            useFormState: $0,
                            useActionState: $0,
                            useOptimistic: function(r, l) {
                                var p = Bi();
                                return q0(p, jn, r, l)
                            },
                            useMemoCache: gv,
                            useCacheRefresh: Bv
                        };
                        Pu.useEffectEvent = ay;
                        var Zh = {
                            readContext: fs,
                            use: Pd,
                            useCallback: Ev,
                            useContext: fs,
                            useEffect: Mv,
                            useImperativeHandle: Xd,
                            useInsertionEffect: ry,
                            useLayoutEffect: Ga,
                            useMemo: Cv,
                            useReducer: Fd,
                            useRef: ny,
                            useState: function() {
                                return Fd(jo)
                            },
                            useDebugValue: Wd,
                            useDeferredValue: function(r, l) {
                                var p = Bi();
                                return jn === null ? wv(p, r, l) : Dv(p, jn.memoizedState, r, l)
                            },
                            useTransition: function() {
                                var r = Fd(jo)[0]
                                  , l = Bi().memoizedState;
                                return [typeof r == "boolean" ? r : Yh(r), l]
                            },
                            useSyncExternalStore: _v,
                            useId: Es,
                            useHostTransitionStatus: Nv,
                            useFormState: ty,
                            useActionState: ty,
                            useOptimistic: function(r, l) {
                                var p = Bi();
                                return jn !== null ? q0(p, jn, r, l) : (p.baseState = r,
                                [r, p.queue.dispatch])
                            },
                            useMemoCache: gv,
                            useCacheRefresh: Bv
                        };
                        Zh.useEffectEvent = ay;
                        function zu(r, l, p, g) {
                            l = r.memoizedState,
                            p = p(g, l),
                            p = p == null ? l : y({}, l, p),
                            r.memoizedState = p,
                            r.lanes === 0 && (r.updateQueue.baseState = p)
                        }
                        var Kh = {
                            enqueueSetState: function(r, l, p) {
                                r = r._reactInternals;
                                var g = xa()
                                  , b = Yo(g);
                                b.payload = l,
                                p != null && (b.callback = p),
                                l = ql(r, b, g),
                                l !== null && (d(l, r, g),
                                jl(l, r, g))
                            },
                            enqueueReplaceState: function(r, l, p) {
                                r = r._reactInternals;
                                var g = xa()
                                  , b = Yo(g);
                                b.tag = 1,
                                b.payload = l,
                                p != null && (b.callback = p),
                                l = ql(r, b, g),
                                l !== null && (d(l, r, g),
                                jl(l, r, g))
                            },
                            enqueueForceUpdate: function(r, l) {
                                r = r._reactInternals;
                                var p = xa()
                                  , g = Yo(p);
                                g.tag = 2,
                                l != null && (g.callback = l),
                                l = ql(r, g, p),
                                l !== null && (d(l, r, p),
                                jl(l, r, p))
                            }
                        };
                        function uy(r, l, p, g, b, C, F) {
                            return r = r.stateNode,
                            typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(g, C, F) : l.prototype && l.prototype.isPureReactComponent ? !Au(p, g) || !Au(b, C) : !0
                        }
                        function hy(r, l, p, g) {
                            r = l.state,
                            typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(p, g),
                            typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(p, g),
                            l.state !== r && Kh.enqueueReplaceState(l, l.state, null)
                        }
                        function Cs(r, l) {
                            var p = l;
                            if ("ref"in l) {
                                p = {};
                                for (var g in l)
                                    g !== "ref" && (p[g] = l[g])
                            }
                            if (r = r.defaultProps) {
                                p === l && (p = y({}, p));
                                for (var b in r)
                                    p[b] === void 0 && (p[b] = r[b])
                            }
                            return p
                        }
                        function fy(r) {
                            Il(r)
                        }
                        function Lx(r) {
                            console.error(r)
                        }
                        function Lv(r) {
                            Il(r)
                        }
                        function Yd(r, l) {
                            try {
                                var p = r.onUncaughtError;
                                p(l.value, {
                                    componentStack: l.stack
                                })
                            } catch (g) {
                                setTimeout(function() {
                                    throw g
                                })
                            }
                        }
                        function dy(r, l, p) {
                            try {
                                var g = r.onCaughtError;
                                g(p.value, {
                                    componentStack: p.stack,
                                    errorBoundary: l.tag === 1 ? l.stateNode : null
                                })
                            } catch (b) {
                                setTimeout(function() {
                                    throw b
                                })
                            }
                        }
                        function Iv(r, l, p) {
                            return p = Yo(p),
                            p.tag = 3,
                            p.payload = {
                                element: null
                            },
                            p.callback = function() {
                                Yd(r, l)
                            }
                            ,
                            p
                        }
                        function Fu(r) {
                            return r = Yo(r),
                            r.tag = 3,
                            r
                        }
                        function va(r, l, p, g) {
                            var b = p.type.getDerivedStateFromError;
                            if (typeof b == "function") {
                                var C = g.value;
                                r.payload = function() {
                                    return b(C)
                                }
                                ,
                                r.callback = function() {
                                    dy(l, p, g)
                                }
                            }
                            var F = p.stateNode;
                            F !== null && typeof F.componentDidCatch == "function" && (r.callback = function() {
                                dy(l, p, g),
                                typeof b != "function" && (Ao === null ? Ao = new Set([this]) : Ao.add(this));
                                var J = g.stack;
                                this.componentDidCatch(g.value, {
                                    componentStack: J !== null ? J : ""
                                })
                            }
                            )
                        }
                        function Va(r, l, p, g, b) {
                            if (p.flags |= 32768,
                            g !== null && typeof g == "object" && typeof g.then == "function") {
                                if (l = p.alternate,
                                l !== null && Gl(l, p, b, !0),
                                p = ns.current,
                                p !== null) {
                                    switch (p.tag) {
                                    case 31:
                                    case 13:
                                        return fr === null ? qt() : p.alternate === null && Fn === 0 && (Fn = 3),
                                        p.flags &= -257,
                                        p.flags |= 65536,
                                        p.lanes = b,
                                        g === Hh ? p.flags |= 16384 : (l = p.updateQueue,
                                        l === null ? p.updateQueue = new Set([g]) : l.add(g),
                                        Ix(r, g, b)),
                                        !1;
                                    case 22:
                                        return p.flags |= 65536,
                                        g === Hh ? p.flags |= 16384 : (l = p.updateQueue,
                                        l === null ? (l = {
                                            transitions: null,
                                            markerInstances: null,
                                            retryQueue: new Set([g])
                                        },
                                        p.updateQueue = l) : (p = l.retryQueue,
                                        p === null ? l.retryQueue = new Set([g]) : p.add(g)),
                                        Ix(r, g, b)),
                                        !1
                                    }
                                    throw Error(s(435, p.tag))
                                }
                                return Ix(r, g, b),
                                qt(),
                                !1
                            }
                            if (gn)
                                return l = ns.current,
                                l !== null ? ((l.flags & 65536) === 0 && (l.flags |= 256),
                                l.flags |= 65536,
                                l.lanes = b,
                                g !== Cd && (r = Error(s(422), {
                                    cause: g
                                }),
                                Ph(fa(r, p)))) : (g !== Cd && (l = Error(s(423), {
                                    cause: g
                                }),
                                Ph(fa(l, p))),
                                r = r.current.alternate,
                                r.flags |= 65536,
                                b &= -b,
                                r.lanes |= b,
                                g = fa(g, p),
                                b = Iv(r.stateNode, g, b),
                                Nd(r, b),
                                Fn !== 4 && (Fn = 2)),
                                !1;
                            var C = Error(s(520), {
                                cause: g
                            });
                            if (C = fa(C, p),
                            Xr === null ? Xr = [C] : Xr.push(C),
                            Fn !== 4 && (Fn = 2),
                            l === null)
                                return !0;
                            g = fa(g, p),
                            p = l;
                            do {
                                switch (p.tag) {
                                case 3:
                                    return p.flags |= 65536,
                                    r = b & -b,
                                    p.lanes |= r,
                                    r = Iv(p.stateNode, g, r),
                                    Nd(p, r),
                                    !1;
                                case 1:
                                    if (l = p.type,
                                    C = p.stateNode,
                                    (p.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || C !== null && typeof C.componentDidCatch == "function" && (Ao === null || !Ao.has(C))))
                                        return p.flags |= 65536,
                                        b &= -b,
                                        p.lanes |= b,
                                        b = Fu(b),
                                        va(b, r, p, g),
                                        Nd(p, b),
                                        !1
                                }
                                p = p.return
                            } while (p !== null);
                            return !1
                        }
                        var qd = Error(s(461))
                          , fi = !1;
                        function Ei(r, l, p, g) {
                            l.child = r === null ? V0(l, null, p, g) : Nc(l, r.child, p, g)
                        }
                        function Jh(r, l, p, g, b) {
                            p = p.render;
                            var C = l.ref;
                            if ("ref"in g) {
                                var F = {};
                                for (var J in g)
                                    J !== "ref" && (F[J] = g[J])
                            } else
                                F = g;
                            return Rc(l),
                            g = dv(r, l, p, F, C, b),
                            J = pv(),
                            r !== null && !fi ? (mv(r, l, b),
                            Vr(r, l, b)) : (gn && J && Ed(l),
                            l.flags |= 1,
                            Ei(r, l, g, b),
                            l.child)
                        }
                        function $h(r, l, p, g, b) {
                            if (r === null) {
                                var C = p.type;
                                return typeof C == "function" && !Ks(C) && C.defaultProps === void 0 && p.compare === null ? (l.tag = 15,
                                l.type = C,
                                ka(r, l, C, g, b)) : (r = Bh(p.type, null, g, l, l.mode, b),
                                r.ref = l.ref,
                                r.return = l,
                                l.child = r)
                            }
                            if (C = r.child,
                            !Kl(r, b)) {
                                var F = C.memoizedProps;
                                if (p = p.compare,
                                p = p !== null ? p : Au,
                                p(F, g) && r.ref === l.ref)
                                    return Vr(r, l, b)
                            }
                            return l.flags |= 1,
                            r = co(C, g),
                            r.ref = l.ref,
                            r.return = l,
                            l.child = r
                        }
                        function ka(r, l, p, g, b) {
                            if (r !== null) {
                                var C = r.memoizedProps;
                                if (Au(C, g) && r.ref === l.ref)
                                    if (fi = !1,
                                    l.pendingProps = g = C,
                                    Kl(r, b))
                                        (r.flags & 131072) !== 0 && (fi = !0);
                                    else
                                        return l.lanes = r.lanes,
                                        Vr(r, l, b)
                            }
                            return Hu(r, l, p, g, b)
                        }
                        function Xa(r, l, p, g) {
                            var b = g.children
                              , C = r !== null ? r.memoizedState : null;
                            if (r === null && l.stateNode === null && (l.stateNode = {
                                _visibility: 1,
                                _pendingMarkers: null,
                                _retryCache: null,
                                _transitions: null
                            }),
                            g.mode === "hidden") {
                                if ((l.flags & 128) !== 0) {
                                    if (C = C !== null ? C.baseLanes | p : p,
                                    r !== null) {
                                        for (g = l.child = r.child,
                                        b = 0; g !== null; )
                                            b = b | g.lanes | g.childLanes,
                                            g = g.sibling;
                                        g = b & ~C
                                    } else
                                        g = 0,
                                        l.child = null;
                                    return yo(r, l, C, p, g)
                                }
                                if ((p & 536870912) !== 0)
                                    l.memoizedState = {
                                        baseLanes: 0,
                                        cachePool: null
                                    },
                                    r !== null && Nu(l, C !== null ? C.cachePool : null),
                                    C !== null ? cv(l, C) : uv(),
                                    k0(l);
                                else
                                    return g = l.lanes = 536870912,
                                    yo(r, l, C !== null ? C.baseLanes | p : p, p, g)
                            } else
                                C !== null ? (Nu(l, C.cachePool),
                                cv(l, C),
                                qo(l),
                                l.memoizedState = null) : (r !== null && Nu(l, null),
                                uv(),
                                qo(l));
                            return Ei(r, l, b, p),
                            l.child
                        }
                        function Hr(r, l) {
                            return r !== null && r.tag === 22 || l.stateNode !== null || (l.stateNode = {
                                _visibility: 1,
                                _pendingMarkers: null,
                                _retryCache: null,
                                _transitions: null
                            }),
                            l.sibling
                        }
                        function yo(r, l, p, g, b) {
                            var C = po();
                            return C = C === null ? null : {
                                parent: It._currentValue,
                                pool: C
                            },
                            l.memoizedState = {
                                baseLanes: p,
                                cachePool: C
                            },
                            r !== null && Nu(l, null),
                            uv(),
                            k0(l),
                            r !== null && Gl(r, l, g, !0),
                            l.childLanes = b,
                            null
                        }
                        function dr(r, l) {
                            return l = Gu({
                                mode: l.mode,
                                children: l.children
                            }, r.mode),
                            l.ref = r.ref,
                            r.child = l,
                            l.return = r,
                            l
                        }
                        function ds(r, l, p) {
                            return Nc(l, r.child, null, p),
                            r = dr(l, l.pendingProps),
                            r.flags |= 2,
                            Ha(l),
                            l.memoizedState = null,
                            r
                        }
                        function ef(r, l, p) {
                            var g = l.pendingProps
                              , b = (l.flags & 128) !== 0;
                            if (l.flags &= -129,
                            r === null) {
                                if (gn) {
                                    if (g.mode === "hidden")
                                        return r = dr(l, g),
                                        l.lanes = 536870912,
                                        Hr(null, r);
                                    if (hv(l),
                                    (r = ni) ? (r = nE(r, hs),
                                    r = r !== null && r.data === "&" ? r : null,
                                    r !== null && (l.memoizedState = {
                                        dehydrated: r,
                                        treeContext: uo !== null ? {
                                            id: ho,
                                            overflow: fo
                                        } : null,
                                        retryLane: 536870912,
                                        hydrationErrors: null
                                    },
                                    p = I0(r),
                                    p.return = l,
                                    l.child = p,
                                    us = l,
                                    ni = null)) : r = null,
                                    r === null)
                                        throw pn(l);
                                    return l.lanes = 536870912,
                                    null
                                }
                                return dr(l, g)
                            }
                            var C = r.memoizedState;
                            if (C !== null) {
                                var F = C.dehydrated;
                                if (hv(l),
                                b)
                                    if (l.flags & 256)
                                        l.flags &= -257,
                                        l = ds(r, l, p);
                                    else if (l.memoizedState !== null)
                                        l.child = r.child,
                                        l.flags |= 128,
                                        l = null;
                                    else
                                        throw Error(s(558));
                                else if (fi || Gl(r, l, p, !1),
                                b = (p & r.childLanes) !== 0,
                                fi || b) {
                                    if (g = zn,
                                    g !== null && (F = Ls(g, p),
                                    F !== 0 && F !== C.retryLane))
                                        throw C.retryLane = F,
                                        zl(r, F),
                                        d(g, r, F),
                                        qd;
                                    qt(),
                                    l = ds(r, l, p)
                                } else
                                    r = C.treeContext,
                                    ni = To(F.nextSibling),
                                    us = l,
                                    gn = !0,
                                    Go = null,
                                    hs = !1,
                                    r !== null && Ih(l, r),
                                    l = dr(l, g),
                                    l.flags |= 4096;
                                return l
                            }
                            return r = co(r.child, {
                                mode: g.mode,
                                children: g.children
                            }),
                            r.ref = l.ref,
                            l.child = r,
                            r.return = l,
                            r
                        }
                        function Gr(r, l) {
                            var p = l.ref;
                            if (p === null)
                                r !== null && r.ref !== null && (l.flags |= 4194816);
                            else {
                                if (typeof p != "function" && typeof p != "object")
                                    throw Error(s(284));
                                (r === null || r.ref !== p) && (l.flags |= 4194816)
                            }
                        }
                        function Hu(r, l, p, g, b) {
                            return Rc(l),
                            p = dv(r, l, p, g, void 0, b),
                            g = pv(),
                            r !== null && !fi ? (mv(r, l, b),
                            Vr(r, l, b)) : (gn && g && Ed(l),
                            l.flags |= 1,
                            Ei(r, l, p, b),
                            l.child)
                        }
                        function Gs(r, l, p, g, b, C) {
                            return Rc(l),
                            l.updateQueue = null,
                            p = W0(l, g, p, b),
                            X0(r),
                            g = pv(),
                            r !== null && !fi ? (mv(r, l, C),
                            Vr(r, l, C)) : (gn && g && Ed(l),
                            l.flags |= 1,
                            Ei(r, l, p, C),
                            l.child)
                        }
                        function ws(r, l, p, g, b) {
                            if (Rc(l),
                            l.stateNode === null) {
                                var C = Fl
                                  , F = p.contextType;
                                typeof F == "object" && F !== null && (C = fs(F)),
                                C = new p(g,C),
                                l.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null,
                                C.updater = Kh,
                                l.stateNode = C,
                                C._reactInternals = l,
                                C = l.stateNode,
                                C.props = g,
                                C.state = l.memoizedState,
                                C.refs = {},
                                rv(l),
                                F = p.contextType,
                                C.context = typeof F == "object" && F !== null ? fs(F) : Fl,
                                C.state = l.memoizedState,
                                F = p.getDerivedStateFromProps,
                                typeof F == "function" && (zu(l, p, F, g),
                                C.state = l.memoizedState),
                                typeof p.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (F = C.state,
                                typeof C.componentWillMount == "function" && C.componentWillMount(),
                                typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(),
                                F !== C.state && Kh.enqueueReplaceState(C, C.state, null),
                                Bc(l, g, C, b),
                                kh(),
                                C.state = l.memoizedState),
                                typeof C.componentDidMount == "function" && (l.flags |= 4194308),
                                g = !0
                            } else if (r === null) {
                                C = l.stateNode;
                                var J = l.memoizedProps
                                  , ve = Cs(p, J);
                                C.props = ve;
                                var Pe = C.context
                                  , Ke = p.contextType;
                                F = Fl,
                                typeof Ke == "object" && Ke !== null && (F = fs(Ke));
                                var st = p.getDerivedStateFromProps;
                                Ke = typeof st == "function" || typeof C.getSnapshotBeforeUpdate == "function",
                                J = l.pendingProps !== J,
                                Ke || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || (J || Pe !== F) && hy(l, C, g, F),
                                Yl = !1;
                                var Ve = l.memoizedState;
                                C.state = Ve,
                                Bc(l, g, C, b),
                                kh(),
                                Pe = l.memoizedState,
                                J || Ve !== Pe || Yl ? (typeof st == "function" && (zu(l, p, st, g),
                                Pe = l.memoizedState),
                                (ve = Yl || uy(l, p, ve, g, Ve, Pe, F)) ? (Ke || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (typeof C.componentWillMount == "function" && C.componentWillMount(),
                                typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount()),
                                typeof C.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof C.componentDidMount == "function" && (l.flags |= 4194308),
                                l.memoizedProps = g,
                                l.memoizedState = Pe),
                                C.props = g,
                                C.state = Pe,
                                C.context = F,
                                g = ve) : (typeof C.componentDidMount == "function" && (l.flags |= 4194308),
                                g = !1)
                            } else {
                                C = l.stateNode,
                                ov(r, l),
                                F = l.memoizedProps,
                                Ke = Cs(p, F),
                                C.props = Ke,
                                st = l.pendingProps,
                                Ve = C.context,
                                Pe = p.contextType,
                                ve = Fl,
                                typeof Pe == "object" && Pe !== null && (ve = fs(Pe)),
                                J = p.getDerivedStateFromProps,
                                (Pe = typeof J == "function" || typeof C.getSnapshotBeforeUpdate == "function") || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || (F !== st || Ve !== ve) && hy(l, C, g, ve),
                                Yl = !1,
                                Ve = l.memoizedState,
                                C.state = Ve,
                                Bc(l, g, C, b),
                                kh();
                                var Ye = l.memoizedState;
                                F !== st || Ve !== Ye || Yl || r !== null && r.dependencies !== null && Uu(r.dependencies) ? (typeof J == "function" && (zu(l, p, J, g),
                                Ye = l.memoizedState),
                                (Ke = Yl || uy(l, p, Ke, g, Ve, Ye, ve) || r !== null && r.dependencies !== null && Uu(r.dependencies)) ? (Pe || typeof C.UNSAFE_componentWillUpdate != "function" && typeof C.componentWillUpdate != "function" || (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(g, Ye, ve),
                                typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(g, Ye, ve)),
                                typeof C.componentDidUpdate == "function" && (l.flags |= 4),
                                typeof C.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof C.componentDidUpdate != "function" || F === r.memoizedProps && Ve === r.memoizedState || (l.flags |= 4),
                                typeof C.getSnapshotBeforeUpdate != "function" || F === r.memoizedProps && Ve === r.memoizedState || (l.flags |= 1024),
                                l.memoizedProps = g,
                                l.memoizedState = Ye),
                                C.props = g,
                                C.state = Ye,
                                C.context = ve,
                                g = Ke) : (typeof C.componentDidUpdate != "function" || F === r.memoizedProps && Ve === r.memoizedState || (l.flags |= 4),
                                typeof C.getSnapshotBeforeUpdate != "function" || F === r.memoizedProps && Ve === r.memoizedState || (l.flags |= 1024),
                                g = !1)
                            }
                            return C = g,
                            Gr(r, l),
                            g = (l.flags & 128) !== 0,
                            C || g ? (C = l.stateNode,
                            p = g && typeof p.getDerivedStateFromError != "function" ? null : C.render(),
                            l.flags |= 1,
                            r !== null && g ? (l.child = Nc(l, r.child, null, b),
                            l.child = Nc(l, null, p, b)) : Ei(r, l, p, b),
                            l.memoizedState = C.state,
                            r = l.child) : r = Vr(r, l, b),
                            r
                        }
                        function En(r, l, p, g) {
                            return Dc(),
                            l.flags |= 256,
                            Ei(r, l, p, g),
                            l.child
                        }
                        var Wa = {
                            dehydrated: null,
                            treeContext: null,
                            retryLane: 0,
                            hydrationErrors: null
                        };
                        function pr(r) {
                            return {
                                baseLanes: r,
                                cachePool: Rd()
                            }
                        }
                        function tf(r, l, p) {
                            return r = r !== null ? r.childLanes & ~p : 0,
                            l && (r |= xn),
                            r
                        }
                        function Ya(r, l, p) {
                            var g = l.pendingProps, b = !1, C = (l.flags & 128) !== 0, F;
                            if ((F = C) || (F = r !== null && r.memoizedState === null ? !1 : (Mi.current & 2) !== 0),
                            F && (b = !0,
                            l.flags &= -129),
                            F = (l.flags & 32) !== 0,
                            l.flags &= -33,
                            r === null) {
                                if (gn) {
                                    if (b ? Ql(l) : qo(l),
                                    (r = ni) ? (r = nE(r, hs),
                                    r = r !== null && r.data !== "&" ? r : null,
                                    r !== null && (l.memoizedState = {
                                        dehydrated: r,
                                        treeContext: uo !== null ? {
                                            id: ho,
                                            overflow: fo
                                        } : null,
                                        retryLane: 536870912,
                                        hydrationErrors: null
                                    },
                                    p = I0(r),
                                    p.return = l,
                                    l.child = p,
                                    us = l,
                                    ni = null)) : r = null,
                                    r === null)
                                        throw pn(l);
                                    return Kx(r) ? l.lanes = 32 : l.lanes = 536870912,
                                    null
                                }
                                var J = g.children;
                                return g = g.fallback,
                                b ? (qo(l),
                                b = l.mode,
                                J = Gu({
                                    mode: "hidden",
                                    children: J
                                }, b),
                                g = Fo(g, b, p, null),
                                J.return = l,
                                g.return = l,
                                J.sibling = g,
                                l.child = J,
                                g = l.child,
                                g.memoizedState = pr(p),
                                g.childLanes = tf(r, F, p),
                                l.memoizedState = Wa,
                                Hr(null, g)) : (Ql(l),
                                Zl(l, J))
                            }
                            var ve = r.memoizedState;
                            if (ve !== null && (J = ve.dehydrated,
                            J !== null)) {
                                if (C)
                                    l.flags & 256 ? (Ql(l),
                                    l.flags &= -257,
                                    l = Vu(r, l, p)) : l.memoizedState !== null ? (qo(l),
                                    l.child = r.child,
                                    l.flags |= 128,
                                    l = null) : (qo(l),
                                    J = g.fallback,
                                    b = l.mode,
                                    g = Gu({
                                        mode: "visible",
                                        children: g.children
                                    }, b),
                                    J = Fo(J, b, p, null),
                                    J.flags |= 2,
                                    g.return = l,
                                    J.return = l,
                                    g.sibling = J,
                                    l.child = g,
                                    Nc(l, r.child, null, p),
                                    g = l.child,
                                    g.memoizedState = pr(p),
                                    g.childLanes = tf(r, F, p),
                                    l.memoizedState = Wa,
                                    l = Hr(null, g));
                                else if (Ql(l),
                                Kx(J)) {
                                    if (F = J.nextSibling && J.nextSibling.dataset,
                                    F)
                                        var Pe = F.dgst;
                                    F = Pe,
                                    g = Error(s(419)),
                                    g.stack = "",
                                    g.digest = F,
                                    Ph({
                                        value: g,
                                        source: null,
                                        stack: null
                                    }),
                                    l = Vu(r, l, p)
                                } else if (fi || Gl(r, l, p, !1),
                                F = (p & r.childLanes) !== 0,
                                fi || F) {
                                    if (F = zn,
                                    F !== null && (g = Ls(F, p),
                                    g !== 0 && g !== ve.retryLane))
                                        throw ve.retryLane = g,
                                        zl(r, g),
                                        d(F, r, g),
                                        qd;
                                    Zx(J) || qt(),
                                    l = Vu(r, l, p)
                                } else
                                    Zx(J) ? (l.flags |= 192,
                                    l.child = r.child,
                                    l = null) : (r = ve.treeContext,
                                    ni = To(J.nextSibling),
                                    us = l,
                                    gn = !0,
                                    Go = null,
                                    hs = !1,
                                    r !== null && Ih(l, r),
                                    l = Zl(l, g.children),
                                    l.flags |= 4096);
                                return l
                            }
                            return b ? (qo(l),
                            J = g.fallback,
                            b = l.mode,
                            ve = r.child,
                            Pe = ve.sibling,
                            g = co(ve, {
                                mode: "hidden",
                                children: g.children
                            }),
                            g.subtreeFlags = ve.subtreeFlags & 65011712,
                            Pe !== null ? J = co(Pe, J) : (J = Fo(J, b, p, null),
                            J.flags |= 2),
                            J.return = l,
                            g.return = l,
                            g.sibling = J,
                            l.child = g,
                            Hr(null, g),
                            g = l.child,
                            J = r.child.memoizedState,
                            J === null ? J = pr(p) : (b = J.cachePool,
                            b !== null ? (ve = It._currentValue,
                            b = b.parent !== ve ? {
                                parent: ve,
                                pool: ve
                            } : b) : b = Rd(),
                            J = {
                                baseLanes: J.baseLanes | p,
                                cachePool: b
                            }),
                            g.memoizedState = J,
                            g.childLanes = tf(r, F, p),
                            l.memoizedState = Wa,
                            Hr(r.child, g)) : (Ql(l),
                            p = r.child,
                            r = p.sibling,
                            p = co(p, {
                                mode: "visible",
                                children: g.children
                            }),
                            p.return = l,
                            p.sibling = null,
                            r !== null && (F = l.deletions,
                            F === null ? (l.deletions = [r],
                            l.flags |= 16) : F.push(r)),
                            l.child = p,
                            l.memoizedState = null,
                            p)
                        }
                        function Zl(r, l) {
                            return l = Gu({
                                mode: "visible",
                                children: l
                            }, r.mode),
                            l.return = r,
                            r.child = l
                        }
                        function Gu(r, l) {
                            return r = Zs(22, r, null, l),
                            r.lanes = 0,
                            r
                        }
                        function Vu(r, l, p) {
                            return Nc(l, r.child, null, p),
                            r = Zl(l, l.pendingProps.children),
                            r.flags |= 2,
                            l.memoizedState = null,
                            r
                        }
                        function Pc(r, l, p) {
                            r.lanes |= l;
                            var g = r.alternate;
                            g !== null && (g.lanes |= l),
                            Xo(r.return, l, p)
                        }
                        function nf(r, l, p, g, b, C) {
                            var F = r.memoizedState;
                            F === null ? r.memoizedState = {
                                isBackwards: l,
                                rendering: null,
                                renderingStartTime: 0,
                                last: g,
                                tail: p,
                                tailMode: b,
                                treeForkCount: C
                            } : (F.isBackwards = l,
                            F.rendering = null,
                            F.renderingStartTime = 0,
                            F.last = g,
                            F.tail = p,
                            F.tailMode = b,
                            F.treeForkCount = C)
                        }
                        function sf(r, l, p) {
                            var g = l.pendingProps
                              , b = g.revealOrder
                              , C = g.tail;
                            g = g.children;
                            var F = Mi.current
                              , J = (F & 2) !== 0;
                            if (J ? (F = F & 1 | 2,
                            l.flags |= 128) : F &= 1,
                            se(Mi, F),
                            Ei(r, l, g, p),
                            g = gn ? Ru : 0,
                            !J && r !== null && (r.flags & 128) !== 0)
                                e: for (r = l.child; r !== null; ) {
                                    if (r.tag === 13)
                                        r.memoizedState !== null && Pc(r, p, l);
                                    else if (r.tag === 19)
                                        Pc(r, p, l);
                                    else if (r.child !== null) {
                                        r.child.return = r,
                                        r = r.child;
                                        continue
                                    }
                                    if (r === l)
                                        break e;
                                    for (; r.sibling === null; ) {
                                        if (r.return === null || r.return === l)
                                            break e;
                                        r = r.return
                                    }
                                    r.sibling.return = r.return,
                                    r = r.sibling
                                }
                            switch (b) {
                            case "forwards":
                                for (p = l.child,
                                b = null; p !== null; )
                                    r = p.alternate,
                                    r !== null && Bd(r) === null && (b = p),
                                    p = p.sibling;
                                p = b,
                                p === null ? (b = l.child,
                                l.child = null) : (b = p.sibling,
                                p.sibling = null),
                                nf(l, !1, b, p, C, g);
                                break;
                            case "backwards":
                            case "unstable_legacy-backwards":
                                for (p = null,
                                b = l.child,
                                l.child = null; b !== null; ) {
                                    if (r = b.alternate,
                                    r !== null && Bd(r) === null) {
                                        l.child = b;
                                        break
                                    }
                                    r = b.sibling,
                                    b.sibling = p,
                                    p = b,
                                    b = r
                                }
                                nf(l, !0, p, null, C, g);
                                break;
                            case "together":
                                nf(l, !1, null, null, void 0, g);
                                break;
                            default:
                                l.memoizedState = null
                            }
                            return l.child
                        }
                        function Vr(r, l, p) {
                            if (r !== null && (l.dependencies = r.dependencies),
                            Qa |= l.lanes,
                            (p & l.childLanes) === 0)
                                if (r !== null) {
                                    if (Gl(r, l, p, !1),
                                    (p & l.childLanes) === 0)
                                        return null
                                } else
                                    return null;
                            if (r !== null && l.child !== r.child)
                                throw Error(s(153));
                            if (l.child !== null) {
                                for (r = l.child,
                                p = co(r, r.pendingProps),
                                l.child = p,
                                p.return = l; r.sibling !== null; )
                                    r = r.sibling,
                                    p = p.sibling = co(r, r.pendingProps),
                                    p.return = l;
                                p.sibling = null
                            }
                            return l.child
                        }
                        function Kl(r, l) {
                            return (r.lanes & l) !== 0 ? !0 : (r = r.dependencies,
                            !!(r !== null && Uu(r)))
                        }
                        function af(r, l, p) {
                            switch (l.tag) {
                            case 3:
                                qe(l, l.stateNode.containerInfo),
                                ko(l, It, r.memoizedState.cache),
                                Dc();
                                break;
                            case 27:
                            case 5:
                                Ee(l);
                                break;
                            case 4:
                                qe(l, l.stateNode.containerInfo);
                                break;
                            case 10:
                                ko(l, l.type, l.memoizedProps.value);
                                break;
                            case 31:
                                if (l.memoizedState !== null)
                                    return l.flags |= 128,
                                    hv(l),
                                    null;
                                break;
                            case 13:
                                var g = l.memoizedState;
                                if (g !== null)
                                    return g.dehydrated !== null ? (Ql(l),
                                    l.flags |= 128,
                                    null) : (p & l.child.childLanes) !== 0 ? Ya(r, l, p) : (Ql(l),
                                    r = Vr(r, l, p),
                                    r !== null ? r.sibling : null);
                                Ql(l);
                                break;
                            case 19:
                                var b = (r.flags & 128) !== 0;
                                if (g = (p & l.childLanes) !== 0,
                                g || (Gl(r, l, p, !1),
                                g = (p & l.childLanes) !== 0),
                                b) {
                                    if (g)
                                        return sf(r, l, p);
                                    l.flags |= 128
                                }
                                if (b = l.memoizedState,
                                b !== null && (b.rendering = null,
                                b.tail = null,
                                b.lastEffect = null),
                                se(Mi, Mi.current),
                                g)
                                    break;
                                return null;
                            case 22:
                                return l.lanes = 0,
                                Xa(r, l, p, l.pendingProps);
                            case 24:
                                ko(l, It, r.memoizedState.cache)
                            }
                            return Vr(r, l, p)
                        }
                        function jd(r, l, p) {
                            if (r !== null)
                                if (r.memoizedProps !== l.pendingProps)
                                    fi = !0;
                                else {
                                    if (!Kl(r, p) && (l.flags & 128) === 0)
                                        return fi = !1,
                                        af(r, l, p);
                                    fi = (r.flags & 131072) !== 0
                                }
                            else
                                fi = !1,
                                gn && (l.flags & 1048576) !== 0 && Qm(l, Ru, l.index);
                            switch (l.lanes = 0,
                            l.tag) {
                            case 16:
                                e: {
                                    var g = l.pendingProps;
                                    if (r = Oc(l.elementType),
                                    l.type = r,
                                    typeof r == "function")
                                        Ks(r) ? (g = Cs(r, g),
                                        l.tag = 1,
                                        l = ws(null, l, r, g, p)) : (l.tag = 0,
                                        l = Hu(null, l, r, g, p));
                                    else {
                                        if (r != null) {
                                            var b = r.$$typeof;
                                            if (b === O) {
                                                l.tag = 11,
                                                l = Jh(null, l, r, g, p);
                                                break e
                                            } else if (b === z) {
                                                l.tag = 14,
                                                l = $h(null, l, r, g, p);
                                                break e
                                            }
                                        }
                                        throw l = oe(r) || r,
                                        Error(s(306, l, ""))
                                    }
                                }
                                return l;
                            case 0:
                                return Hu(r, l, l.type, l.pendingProps, p);
                            case 1:
                                return g = l.type,
                                b = Cs(g, l.pendingProps),
                                ws(r, l, g, b, p);
                            case 3:
                                e: {
                                    if (qe(l, l.stateNode.containerInfo),
                                    r === null)
                                        throw Error(s(387));
                                    g = l.pendingProps;
                                    var C = l.memoizedState;
                                    b = C.element,
                                    ov(r, l),
                                    Bc(l, g, null, p);
                                    var F = l.memoizedState;
                                    if (g = F.cache,
                                    ko(l, It, g),
                                    g !== C.cache && Dd(l, [It], p, !0),
                                    kh(),
                                    g = F.element,
                                    C.isDehydrated)
                                        if (C = {
                                            element: g,
                                            isDehydrated: !1,
                                            cache: F.cache
                                        },
                                        l.updateQueue.baseState = C,
                                        l.memoizedState = C,
                                        l.flags & 256) {
                                            l = En(r, l, g, p);
                                            break e
                                        } else if (g !== b) {
                                            b = fa(Error(s(424)), l),
                                            Ph(b),
                                            l = En(r, l, g, p);
                                            break e
                                        } else {
                                            switch (r = l.stateNode.containerInfo,
                                            r.nodeType) {
                                            case 9:
                                                r = r.body;
                                                break;
                                            default:
                                                r = r.nodeName === "HTML" ? r.ownerDocument.body : r
                                            }
                                            for (ni = To(r.firstChild),
                                            us = l,
                                            gn = !0,
                                            Go = null,
                                            hs = !0,
                                            p = V0(l, null, g, p),
                                            l.child = p; p; )
                                                p.flags = p.flags & -3 | 4096,
                                                p = p.sibling
                                        }
                                    else {
                                        if (Dc(),
                                        g === b) {
                                            l = Vr(r, l, p);
                                            break e
                                        }
                                        Ei(r, l, g, p)
                                    }
                                    l = l.child
                                }
                                return l;
                            case 26:
                                return Gr(r, l),
                                r === null ? (p = lE(l.type, null, l.pendingProps, null)) ? l.memoizedState = p : gn || (p = l.type,
                                r = l.pendingProps,
                                g = xy(ue.current).createElement(p),
                                g[Qt] = l,
                                g[Xi] = r,
                                ta(g, p, r),
                                pt(g),
                                l.stateNode = g) : l.memoizedState = lE(l.type, r.memoizedProps, l.pendingProps, r.memoizedState),
                                null;
                            case 27:
                                return Ee(l),
                                r === null && gn && (g = l.stateNode = aE(l.type, l.pendingProps, ue.current),
                                us = l,
                                hs = !0,
                                b = ni,
                                Qu(l.type) ? (Jx = b,
                                ni = To(g.firstChild)) : ni = b),
                                Ei(r, l, l.pendingProps.children, p),
                                Gr(r, l),
                                r === null && (l.flags |= 4194304),
                                l.child;
                            case 5:
                                return r === null && gn && ((b = g = ni) && (g = WO(g, l.type, l.pendingProps, hs),
                                g !== null ? (l.stateNode = g,
                                us = l,
                                ni = To(g.firstChild),
                                hs = !1,
                                b = !0) : b = !1),
                                b || pn(l)),
                                Ee(l),
                                b = l.type,
                                C = l.pendingProps,
                                F = r !== null ? r.memoizedProps : null,
                                g = C.children,
                                qx(b, C) ? g = null : F !== null && qx(b, F) && (l.flags |= 32),
                                l.memoizedState !== null && (b = dv(r, l, Dx, null, null, p),
                                Yv._currentValue = b),
                                Gr(r, l),
                                Ei(r, l, g, p),
                                l.child;
                            case 6:
                                return r === null && gn && ((r = p = ni) && (p = YO(p, l.pendingProps, hs),
                                p !== null ? (l.stateNode = p,
                                us = l,
                                ni = null,
                                r = !0) : r = !1),
                                r || pn(l)),
                                null;
                            case 13:
                                return Ya(r, l, p);
                            case 4:
                                return qe(l, l.stateNode.containerInfo),
                                g = l.pendingProps,
                                r === null ? l.child = Nc(l, null, g, p) : Ei(r, l, g, p),
                                l.child;
                            case 11:
                                return Jh(r, l, l.type, l.pendingProps, p);
                            case 7:
                                return Ei(r, l, l.pendingProps, p),
                                l.child;
                            case 8:
                                return Ei(r, l, l.pendingProps.children, p),
                                l.child;
                            case 12:
                                return Ei(r, l, l.pendingProps.children, p),
                                l.child;
                            case 10:
                                return g = l.pendingProps,
                                ko(l, l.type, g.value),
                                Ei(r, l, g.children, p),
                                l.child;
                            case 9:
                                return b = l.type._context,
                                g = l.pendingProps.children,
                                Rc(l),
                                b = fs(b),
                                g = g(b),
                                l.flags |= 1,
                                Ei(r, l, g, p),
                                l.child;
                            case 14:
                                return $h(r, l, l.type, l.pendingProps, p);
                            case 15:
                                return ka(r, l, l.type, l.pendingProps, p);
                            case 19:
                                return sf(r, l, p);
                            case 31:
                                return ef(r, l, p);
                            case 22:
                                return Xa(r, l, p, l.pendingProps);
                            case 24:
                                return Rc(l),
                                g = fs(It),
                                r === null ? (b = po(),
                                b === null && (b = zn,
                                C = ev(),
                                b.pooledCache = C,
                                C.refCount++,
                                C !== null && (b.pooledCacheLanes |= p),
                                b = C),
                                l.memoizedState = {
                                    parent: g,
                                    cache: b
                                },
                                rv(l),
                                ko(l, It, b)) : ((r.lanes & p) !== 0 && (ov(r, l),
                                Bc(l, null, null, p),
                                kh()),
                                b = r.memoizedState,
                                C = l.memoizedState,
                                b.parent !== g ? (b = {
                                    parent: g,
                                    cache: g
                                },
                                l.memoizedState = b,
                                l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = b),
                                ko(l, It, g)) : (g = C.cache,
                                ko(l, It, g),
                                g !== b.cache && Dd(l, [It], p, !0))),
                                Ei(r, l, l.pendingProps.children, p),
                                l.child;
                            case 29:
                                throw l.pendingProps
                            }
                            throw Error(s(156, l.tag))
                        }
                        function ga(r) {
                            r.flags |= 4
                        }
                        function Jl(r, l, p, g, b) {
                            if ((l = (r.mode & 32) !== 0) && (l = !1),
                            l) {
                                if (r.flags |= 16777216,
                                (b & 335544128) === b)
                                    if (r.stateNode.complete)
                                        r.flags |= 8192;
                                    else if (mt())
                                        r.flags |= 8192;
                                    else
                                        throw Ft = Hh,
                                        Fh
                            } else
                                r.flags &= -16777217
                        }
                        function Zo(r, l) {
                            if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0)
                                r.flags &= -16777217;
                            else if (r.flags |= 16777216,
                            !dE(l))
                                if (mt())
                                    r.flags |= 8192;
                                else
                                    throw Ft = Hh,
                                    Fh
                        }
                        function ku(r, l) {
                            l !== null && (r.flags |= 4),
                            r.flags & 16384 && (l = r.tag !== 22 ? Ot() : 536870912,
                            r.lanes |= l,
                            Za |= l)
                        }
                        function rf(r, l) {
                            if (!gn)
                                switch (r.tailMode) {
                                case "hidden":
                                    l = r.tail;
                                    for (var p = null; l !== null; )
                                        l.alternate !== null && (p = l),
                                        l = l.sibling;
                                    p === null ? r.tail = null : p.sibling = null;
                                    break;
                                case "collapsed":
                                    p = r.tail;
                                    for (var g = null; p !== null; )
                                        p.alternate !== null && (g = p),
                                        p = p.sibling;
                                    g === null ? l || r.tail === null ? r.tail = null : r.tail.sibling = null : g.sibling = null
                                }
                        }
                        function Yn(r) {
                            var l = r.alternate !== null && r.alternate.child === r.child
                              , p = 0
                              , g = 0;
                            if (l)
                                for (var b = r.child; b !== null; )
                                    p |= b.lanes | b.childLanes,
                                    g |= b.subtreeFlags & 65011712,
                                    g |= b.flags & 65011712,
                                    b.return = r,
                                    b = b.sibling;
                            else
                                for (b = r.child; b !== null; )
                                    p |= b.lanes | b.childLanes,
                                    g |= b.subtreeFlags,
                                    g |= b.flags,
                                    b.return = r,
                                    b = b.sibling;
                            return r.subtreeFlags |= g,
                            r.childLanes = p,
                            l
                        }
                        function Pv(r, l, p) {
                            var g = l.pendingProps;
                            switch (Hl(l),
                            l.tag) {
                            case 16:
                            case 15:
                            case 0:
                            case 11:
                            case 7:
                            case 8:
                            case 12:
                            case 9:
                            case 14:
                                return Yn(l),
                                null;
                            case 1:
                                return Yn(l),
                                null;
                            case 3:
                                return p = l.stateNode,
                                g = null,
                                r !== null && (g = r.memoizedState.cache),
                                l.memoizedState.cache !== g && (l.flags |= 2048),
                                hr(It),
                                ze(),
                                p.pendingContext && (p.context = p.pendingContext,
                                p.pendingContext = null),
                                (r === null || r.child === null) && (wc(l) ? ga(l) : r === null || r.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024,
                                Zm())),
                                Yn(l),
                                null;
                            case 26:
                                var b = l.type
                                  , C = l.memoizedState;
                                return r === null ? (ga(l),
                                C !== null ? (Yn(l),
                                Zo(l, C)) : (Yn(l),
                                Jl(l, b, null, g, p))) : C ? C !== r.memoizedState ? (ga(l),
                                Yn(l),
                                Zo(l, C)) : (Yn(l),
                                l.flags &= -16777217) : (r = r.memoizedProps,
                                r !== g && ga(l),
                                Yn(l),
                                Jl(l, b, r, g, p)),
                                null;
                            case 27:
                                if (re(l),
                                p = ue.current,
                                b = l.type,
                                r !== null && l.stateNode != null)
                                    r.memoizedProps !== g && ga(l);
                                else {
                                    if (!g) {
                                        if (l.stateNode === null)
                                            throw Error(s(166));
                                        return Yn(l),
                                        null
                                    }
                                    r = K.current,
                                    wc(l) ? wd(l, r) : (r = aE(b, g, p),
                                    l.stateNode = r,
                                    ga(l))
                                }
                                return Yn(l),
                                null;
                            case 5:
                                if (re(l),
                                b = l.type,
                                r !== null && l.stateNode != null)
                                    r.memoizedProps !== g && ga(l);
                                else {
                                    if (!g) {
                                        if (l.stateNode === null)
                                            throw Error(s(166));
                                        return Yn(l),
                                        null
                                    }
                                    if (C = K.current,
                                    wc(l))
                                        wd(l, C);
                                    else {
                                        var F = xy(ue.current);
                                        switch (C) {
                                        case 1:
                                            C = F.createElementNS("http://www.w3.org/2000/svg", b);
                                            break;
                                        case 2:
                                            C = F.createElementNS("http://www.w3.org/1998/Math/MathML", b);
                                            break;
                                        default:
                                            switch (b) {
                                            case "svg":
                                                C = F.createElementNS("http://www.w3.org/2000/svg", b);
                                                break;
                                            case "math":
                                                C = F.createElementNS("http://www.w3.org/1998/Math/MathML", b);
                                                break;
                                            case "script":
                                                C = F.createElement("div"),
                                                C.innerHTML = "<script><\/script>",
                                                C = C.removeChild(C.firstChild);
                                                break;
                                            case "select":
                                                C = typeof g.is == "string" ? F.createElement("select", {
                                                    is: g.is
                                                }) : F.createElement("select"),
                                                g.multiple ? C.multiple = !0 : g.size && (C.size = g.size);
                                                break;
                                            default:
                                                C = typeof g.is == "string" ? F.createElement(b, {
                                                    is: g.is
                                                }) : F.createElement(b)
                                            }
                                        }
                                        C[Qt] = l,
                                        C[Xi] = g;
                                        e: for (F = l.child; F !== null; ) {
                                            if (F.tag === 5 || F.tag === 6)
                                                C.appendChild(F.stateNode);
                                            else if (F.tag !== 4 && F.tag !== 27 && F.child !== null) {
                                                F.child.return = F,
                                                F = F.child;
                                                continue
                                            }
                                            if (F === l)
                                                break e;
                                            for (; F.sibling === null; ) {
                                                if (F.return === null || F.return === l)
                                                    break e;
                                                F = F.return
                                            }
                                            F.sibling.return = F.return,
                                            F = F.sibling
                                        }
                                        l.stateNode = C;
                                        e: switch (ta(C, b, g),
                                        b) {
                                        case "button":
                                        case "input":
                                        case "select":
                                        case "textarea":
                                            g = !!g.autoFocus;
                                            break e;
                                        case "img":
                                            g = !0;
                                            break e;
                                        default:
                                            g = !1
                                        }
                                        g && ga(l)
                                    }
                                }
                                return Yn(l),
                                Jl(l, l.type, r === null ? null : r.memoizedProps, l.pendingProps, p),
                                null;
                            case 6:
                                if (r && l.stateNode != null)
                                    r.memoizedProps !== g && ga(l);
                                else {
                                    if (typeof g != "string" && l.stateNode === null)
                                        throw Error(s(166));
                                    if (r = ue.current,
                                    wc(l)) {
                                        if (r = l.stateNode,
                                        p = l.memoizedProps,
                                        g = null,
                                        b = us,
                                        b !== null)
                                            switch (b.tag) {
                                            case 27:
                                            case 5:
                                                g = b.memoizedProps
                                            }
                                        r[Qt] = l,
                                        r = !!(r.nodeValue === p || g !== null && g.suppressHydrationWarning === !0 || jb(r.nodeValue, p)),
                                        r || pn(l, !0)
                                    } else
                                        r = xy(r).createTextNode(g),
                                        r[Qt] = l,
                                        l.stateNode = r
                                }
                                return Yn(l),
                                null;
                            case 31:
                                if (p = l.memoizedState,
                                r === null || r.memoizedState !== null) {
                                    if (g = wc(l),
                                    p !== null) {
                                        if (r === null) {
                                            if (!g)
                                                throw Error(s(318));
                                            if (r = l.memoizedState,
                                            r = r !== null ? r.dehydrated : null,
                                            !r)
                                                throw Error(s(557));
                                            r[Qt] = l
                                        } else
                                            Dc(),
                                            (l.flags & 128) === 0 && (l.memoizedState = null),
                                            l.flags |= 4;
                                        Yn(l),
                                        r = !1
                                    } else
                                        p = Zm(),
                                        r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = p),
                                        r = !0;
                                    if (!r)
                                        return l.flags & 256 ? (Ha(l),
                                        l) : (Ha(l),
                                        null);
                                    if ((l.flags & 128) !== 0)
                                        throw Error(s(558))
                                }
                                return Yn(l),
                                null;
                            case 13:
                                if (g = l.memoizedState,
                                r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
                                    if (b = wc(l),
                                    g !== null && g.dehydrated !== null) {
                                        if (r === null) {
                                            if (!b)
                                                throw Error(s(318));
                                            if (b = l.memoizedState,
                                            b = b !== null ? b.dehydrated : null,
                                            !b)
                                                throw Error(s(317));
                                            b[Qt] = l
                                        } else
                                            Dc(),
                                            (l.flags & 128) === 0 && (l.memoizedState = null),
                                            l.flags |= 4;
                                        Yn(l),
                                        b = !1
                                    } else
                                        b = Zm(),
                                        r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = b),
                                        b = !0;
                                    if (!b)
                                        return l.flags & 256 ? (Ha(l),
                                        l) : (Ha(l),
                                        null)
                                }
                                return Ha(l),
                                (l.flags & 128) !== 0 ? (l.lanes = p,
                                l) : (p = g !== null,
                                r = r !== null && r.memoizedState !== null,
                                p && (g = l.child,
                                b = null,
                                g.alternate !== null && g.alternate.memoizedState !== null && g.alternate.memoizedState.cachePool !== null && (b = g.alternate.memoizedState.cachePool.pool),
                                C = null,
                                g.memoizedState !== null && g.memoizedState.cachePool !== null && (C = g.memoizedState.cachePool.pool),
                                C !== b && (g.flags |= 2048)),
                                p !== r && p && (l.child.flags |= 8192),
                                ku(l, l.updateQueue),
                                Yn(l),
                                null);
                            case 4:
                                return ze(),
                                r === null && Xb(l.stateNode.containerInfo),
                                Yn(l),
                                null;
                            case 10:
                                return hr(l.type),
                                Yn(l),
                                null;
                            case 19:
                                if (ie(Mi),
                                g = l.memoizedState,
                                g === null)
                                    return Yn(l),
                                    null;
                                if (b = (l.flags & 128) !== 0,
                                C = g.rendering,
                                C === null)
                                    if (b)
                                        rf(g, !1);
                                    else {
                                        if (Fn !== 0 || r !== null && (r.flags & 128) !== 0)
                                            for (r = l.child; r !== null; ) {
                                                if (C = Bd(r),
                                                C !== null) {
                                                    for (l.flags |= 128,
                                                    rf(g, !1),
                                                    r = C.updateQueue,
                                                    l.updateQueue = r,
                                                    ku(l, r),
                                                    l.subtreeFlags = 0,
                                                    r = p,
                                                    p = l.child; p !== null; )
                                                        zs(p, r),
                                                        p = p.sibling;
                                                    return se(Mi, Mi.current & 1 | 2),
                                                    gn && Ho(l, g.treeForkCount),
                                                    l.child
                                                }
                                                r = r.sibling
                                            }
                                        g.tail !== null && pe() > Ka && (l.flags |= 128,
                                        b = !0,
                                        rf(g, !1),
                                        l.lanes = 4194304)
                                    }
                                else {
                                    if (!b)
                                        if (r = Bd(C),
                                        r !== null) {
                                            if (l.flags |= 128,
                                            b = !0,
                                            r = r.updateQueue,
                                            l.updateQueue = r,
                                            ku(l, r),
                                            rf(g, !0),
                                            g.tail === null && g.tailMode === "hidden" && !C.alternate && !gn)
                                                return Yn(l),
                                                null
                                        } else
                                            2 * pe() - g.renderingStartTime > Ka && p !== 536870912 && (l.flags |= 128,
                                            b = !0,
                                            rf(g, !1),
                                            l.lanes = 4194304);
                                    g.isBackwards ? (C.sibling = l.child,
                                    l.child = C) : (r = g.last,
                                    r !== null ? r.sibling = C : l.child = C,
                                    g.last = C)
                                }
                                return g.tail !== null ? (r = g.tail,
                                g.rendering = r,
                                g.tail = r.sibling,
                                g.renderingStartTime = pe(),
                                r.sibling = null,
                                p = Mi.current,
                                se(Mi, b ? p & 1 | 2 : p & 1),
                                gn && Ho(l, g.treeForkCount),
                                r) : (Yn(l),
                                null);
                            case 22:
                            case 23:
                                return Ha(l),
                                Hs(),
                                g = l.memoizedState !== null,
                                r !== null ? r.memoizedState !== null !== g && (l.flags |= 8192) : g && (l.flags |= 8192),
                                g ? (p & 536870912) !== 0 && (l.flags & 128) === 0 && (Yn(l),
                                l.subtreeFlags & 6 && (l.flags |= 8192)) : Yn(l),
                                p = l.updateQueue,
                                p !== null && ku(l, p.retryQueue),
                                p = null,
                                r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (p = r.memoizedState.cachePool.pool),
                                g = null,
                                l.memoizedState !== null && l.memoizedState.cachePool !== null && (g = l.memoizedState.cachePool.pool),
                                g !== p && (l.flags |= 2048),
                                r !== null && ie(Vl),
                                null;
                            case 24:
                                return p = null,
                                r !== null && (p = r.memoizedState.cache),
                                l.memoizedState.cache !== p && (l.flags |= 2048),
                                hr(It),
                                Yn(l),
                                null;
                            case 25:
                                return null;
                            case 30:
                                return null
                            }
                            throw Error(s(156, l.tag))
                        }
                        function Qd(r, l) {
                            switch (Hl(l),
                            l.tag) {
                            case 1:
                                return r = l.flags,
                                r & 65536 ? (l.flags = r & -65537 | 128,
                                l) : null;
                            case 3:
                                return hr(It),
                                ze(),
                                r = l.flags,
                                (r & 65536) !== 0 && (r & 128) === 0 ? (l.flags = r & -65537 | 128,
                                l) : null;
                            case 26:
                            case 27:
                            case 5:
                                return re(l),
                                null;
                            case 31:
                                if (l.memoizedState !== null) {
                                    if (Ha(l),
                                    l.alternate === null)
                                        throw Error(s(340));
                                    Dc()
                                }
                                return r = l.flags,
                                r & 65536 ? (l.flags = r & -65537 | 128,
                                l) : null;
                            case 13:
                                if (Ha(l),
                                r = l.memoizedState,
                                r !== null && r.dehydrated !== null) {
                                    if (l.alternate === null)
                                        throw Error(s(340));
                                    Dc()
                                }
                                return r = l.flags,
                                r & 65536 ? (l.flags = r & -65537 | 128,
                                l) : null;
                            case 19:
                                return ie(Mi),
                                null;
                            case 4:
                                return ze(),
                                null;
                            case 10:
                                return hr(l.type),
                                null;
                            case 22:
                            case 23:
                                return Ha(l),
                                Hs(),
                                r !== null && ie(Vl),
                                r = l.flags,
                                r & 65536 ? (l.flags = r & -65537 | 128,
                                l) : null;
                            case 24:
                                return hr(It),
                                null;
                            case 25:
                                return null;
                            default:
                                return null
                            }
                        }
                        function zc(r, l) {
                            switch (Hl(l),
                            l.tag) {
                            case 3:
                                hr(It),
                                ze();
                                break;
                            case 26:
                            case 27:
                            case 5:
                                re(l);
                                break;
                            case 4:
                                ze();
                                break;
                            case 31:
                                l.memoizedState !== null && Ha(l);
                                break;
                            case 13:
                                Ha(l);
                                break;
                            case 19:
                                ie(Mi);
                                break;
                            case 10:
                                hr(l.type);
                                break;
                            case 22:
                            case 23:
                                Ha(l),
                                Hs(),
                                r !== null && ie(Vl);
                                break;
                            case 24:
                                hr(It)
                            }
                        }
                        function _o(r, l) {
                            try {
                                var p = l.updateQueue
                                  , g = p !== null ? p.lastEffect : null;
                                if (g !== null) {
                                    var b = g.next;
                                    p = b;
                                    do {
                                        if ((p.tag & r) === r) {
                                            g = void 0;
                                            var C = p.create
                                              , F = p.inst;
                                            g = C(),
                                            F.destroy = g
                                        }
                                        p = p.next
                                    } while (p !== b)
                                }
                            } catch (J) {
                                Kn(l, l.return, J)
                            }
                        }
                        function mr(r, l, p) {
                            try {
                                var g = l.updateQueue
                                  , b = g !== null ? g.lastEffect : null;
                                if (b !== null) {
                                    var C = b.next;
                                    g = C;
                                    do {
                                        if ((g.tag & r) === r) {
                                            var F = g.inst
                                              , J = F.destroy;
                                            if (J !== void 0) {
                                                F.destroy = void 0,
                                                b = l;
                                                var ve = p
                                                  , Pe = J;
                                                try {
                                                    Pe()
                                                } catch (Ke) {
                                                    Kn(b, ve, Ke)
                                                }
                                            }
                                        }
                                        g = g.next
                                    } while (g !== C)
                                }
                            } catch (Ke) {
                                Kn(l, l.return, Ke)
                            }
                        }
                        function $l(r) {
                            var l = r.updateQueue;
                            if (l !== null) {
                                var p = r.stateNode;
                                try {
                                    bs(l, p)
                                } catch (g) {
                                    Kn(r, r.return, g)
                                }
                            }
                        }
                        function zv(r, l, p) {
                            p.props = Cs(r.type, r.memoizedProps),
                            p.state = r.memoizedState;
                            try {
                                p.componentWillUnmount()
                            } catch (g) {
                                Kn(r, l, g)
                            }
                        }
                        function So(r, l) {
                            try {
                                var p = r.ref;
                                if (p !== null) {
                                    switch (r.tag) {
                                    case 26:
                                    case 27:
                                    case 5:
                                        var g = r.stateNode;
                                        break;
                                    case 30:
                                        g = r.stateNode;
                                        break;
                                    default:
                                        g = r.stateNode
                                    }
                                    typeof p == "function" ? r.refCleanup = p(g) : p.current = g
                                }
                            } catch (b) {
                                Kn(r, l, b)
                            }
                        }
                        function qa(r, l) {
                            var p = r.ref
                              , g = r.refCleanup;
                            if (p !== null)
                                if (typeof g == "function")
                                    try {
                                        g()
                                    } catch (b) {
                                        Kn(r, l, b)
                                    } finally {
                                        r.refCleanup = null,
                                        r = r.alternate,
                                        r != null && (r.refCleanup = null)
                                    }
                                else if (typeof p == "function")
                                    try {
                                        p(null)
                                    } catch (b) {
                                        Kn(r, l, b)
                                    }
                                else
                                    p.current = null
                        }
                        function ja(r) {
                            var l = r.type
                              , p = r.memoizedProps
                              , g = r.stateNode;
                            try {
                                e: switch (l) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    p.autoFocus && g.focus();
                                    break e;
                                case "img":
                                    p.src ? g.src = p.src : p.srcSet && (g.srcset = p.srcSet)
                                }
                            } catch (b) {
                                Kn(r, r.return, b)
                            }
                        }
                        function vr(r, l, p) {
                            try {
                                var g = r.stateNode;
                                FO(g, r.type, p, l),
                                g[Xi] = l
                            } catch (b) {
                                Kn(r, r.return, b)
                            }
                        }
                        function ji(r) {
                            return r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 && Qu(r.type) || r.tag === 4
                        }
                        function xo(r) {
                            e: for (; ; ) {
                                for (; r.sibling === null; ) {
                                    if (r.return === null || ji(r.return))
                                        return null;
                                    r = r.return
                                }
                                for (r.sibling.return = r.return,
                                r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
                                    if (r.tag === 27 && Qu(r.type) || r.flags & 2 || r.child === null || r.tag === 4)
                                        continue e;
                                    r.child.return = r,
                                    r = r.child
                                }
                                if (!(r.flags & 2))
                                    return r.stateNode
                            }
                        }
                        function $t(r, l, p) {
                            var g = r.tag;
                            if (g === 5 || g === 6)
                                r = r.stateNode,
                                l ? (p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p).insertBefore(r, l) : (l = p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p,
                                l.appendChild(r),
                                p = p._reactRootContainer,
                                p != null || l.onclick !== null || (l.onclick = Ba));
                            else if (g !== 4 && (g === 27 && Qu(r.type) && (p = r.stateNode,
                            l = null),
                            r = r.child,
                            r !== null))
                                for ($t(r, l, p),
                                r = r.sibling; r !== null; )
                                    $t(r, l, p),
                                    r = r.sibling
                        }
                        function Bn(r, l, p) {
                            var g = r.tag;
                            if (g === 5 || g === 6)
                                r = r.stateNode,
                                l ? p.insertBefore(r, l) : p.appendChild(r);
                            else if (g !== 4 && (g === 27 && Qu(r.type) && (p = r.stateNode),
                            r = r.child,
                            r !== null))
                                for (Bn(r, l, p),
                                r = r.sibling; r !== null; )
                                    Bn(r, l, p),
                                    r = r.sibling
                        }
                        function Li(r) {
                            var l = r.stateNode
                              , p = r.memoizedProps;
                            try {
                                for (var g = r.type, b = l.attributes; b.length; )
                                    l.removeAttributeNode(b[0]);
                                ta(l, g, p),
                                l[Qt] = r,
                                l[Xi] = p
                            } catch (C) {
                                Kn(r, r.return, C)
                            }
                        }
                        var gr = !1
                          , di = !1
                          , Ko = !1
                          , of = typeof WeakSet == "function" ? WeakSet : Set
                          , Ci = null;
                        function Xu(r, l) {
                            if (r = r.containerInfo,
                            Wx = wy,
                            r = yd(r),
                            Tu(r)) {
                                if ("selectionStart"in r)
                                    var p = {
                                        start: r.selectionStart,
                                        end: r.selectionEnd
                                    };
                                else
                                    e: {
                                        p = (p = r.ownerDocument) && p.defaultView || window;
                                        var g = p.getSelection && p.getSelection();
                                        if (g && g.rangeCount !== 0) {
                                            p = g.anchorNode;
                                            var b = g.anchorOffset
                                              , C = g.focusNode;
                                            g = g.focusOffset;
                                            try {
                                                p.nodeType,
                                                C.nodeType
                                            } catch {
                                                p = null;
                                                break e
                                            }
                                            var F = 0
                                              , J = -1
                                              , ve = -1
                                              , Pe = 0
                                              , Ke = 0
                                              , st = r
                                              , Ve = null;
                                            t: for (; ; ) {
                                                for (var Ye; st !== p || b !== 0 && st.nodeType !== 3 || (J = F + b),
                                                st !== C || g !== 0 && st.nodeType !== 3 || (ve = F + g),
                                                st.nodeType === 3 && (F += st.nodeValue.length),
                                                (Ye = st.firstChild) !== null; )
                                                    Ve = st,
                                                    st = Ye;
                                                for (; ; ) {
                                                    if (st === r)
                                                        break t;
                                                    if (Ve === p && ++Pe === b && (J = F),
                                                    Ve === C && ++Ke === g && (ve = F),
                                                    (Ye = st.nextSibling) !== null)
                                                        break;
                                                    st = Ve,
                                                    Ve = st.parentNode
                                                }
                                                st = Ye
                                            }
                                            p = J === -1 || ve === -1 ? null : {
                                                start: J,
                                                end: ve
                                            }
                                        } else
                                            p = null
                                    }
                                p = p || {
                                    start: 0,
                                    end: 0
                                }
                            } else
                                p = null;
                            for (Yx = {
                                focusedElem: r,
                                selectionRange: p
                            },
                            wy = !1,
                            Ci = l; Ci !== null; )
                                if (l = Ci,
                                r = l.child,
                                (l.subtreeFlags & 1028) !== 0 && r !== null)
                                    r.return = l,
                                    Ci = r;
                                else
                                    for (; Ci !== null; ) {
                                        switch (l = Ci,
                                        C = l.alternate,
                                        r = l.flags,
                                        l.tag) {
                                        case 0:
                                            if ((r & 4) !== 0 && (r = l.updateQueue,
                                            r = r !== null ? r.events : null,
                                            r !== null))
                                                for (p = 0; p < r.length; p++)
                                                    b = r[p],
                                                    b.ref.impl = b.nextImpl;
                                            break;
                                        case 11:
                                        case 15:
                                            break;
                                        case 1:
                                            if ((r & 1024) !== 0 && C !== null) {
                                                r = void 0,
                                                p = l,
                                                b = C.memoizedProps,
                                                C = C.memoizedState,
                                                g = p.stateNode;
                                                try {
                                                    var wt = Cs(p.type, b);
                                                    r = g.getSnapshotBeforeUpdate(wt, C),
                                                    g.__reactInternalSnapshotBeforeUpdate = r
                                                } catch (Gt) {
                                                    Kn(p, p.return, Gt)
                                                }
                                            }
                                            break;
                                        case 3:
                                            if ((r & 1024) !== 0) {
                                                if (r = l.stateNode.containerInfo,
                                                p = r.nodeType,
                                                p === 9)
                                                    Qx(r);
                                                else if (p === 1)
                                                    switch (r.nodeName) {
                                                    case "HEAD":
                                                    case "HTML":
                                                    case "BODY":
                                                        Qx(r);
                                                        break;
                                                    default:
                                                        r.textContent = ""
                                                    }
                                            }
                                            break;
                                        case 5:
                                        case 26:
                                        case 27:
                                        case 6:
                                        case 4:
                                        case 17:
                                            break;
                                        default:
                                            if ((r & 1024) !== 0)
                                                throw Error(s(163))
                                        }
                                        if (r = l.sibling,
                                        r !== null) {
                                            r.return = l.return,
                                            Ci = r;
                                            break
                                        }
                                        Ci = l.return
                                    }
                        }
                        function py(r, l, p) {
                            var g = p.flags;
                            switch (p.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Jo(r, p),
                                g & 4 && _o(5, p);
                                break;
                            case 1:
                                if (Jo(r, p),
                                g & 4)
                                    if (r = p.stateNode,
                                    l === null)
                                        try {
                                            r.componentDidMount()
                                        } catch (F) {
                                            Kn(p, p.return, F)
                                        }
                                    else {
                                        var b = Cs(p.type, l.memoizedProps);
                                        l = l.memoizedState;
                                        try {
                                            r.componentDidUpdate(b, l, r.__reactInternalSnapshotBeforeUpdate)
                                        } catch (F) {
                                            Kn(p, p.return, F)
                                        }
                                    }
                                g & 64 && $l(p),
                                g & 512 && So(p, p.return);
                                break;
                            case 3:
                                if (Jo(r, p),
                                g & 64 && (r = p.updateQueue,
                                r !== null)) {
                                    if (l = null,
                                    p.child !== null)
                                        switch (p.child.tag) {
                                        case 27:
                                        case 5:
                                            l = p.child.stateNode;
                                            break;
                                        case 1:
                                            l = p.child.stateNode
                                        }
                                    try {
                                        bs(r, l)
                                    } catch (F) {
                                        Kn(p, p.return, F)
                                    }
                                }
                                break;
                            case 27:
                                l === null && g & 4 && Li(p);
                            case 26:
                            case 5:
                                Jo(r, p),
                                l === null && g & 4 && ja(p),
                                g & 512 && So(p, p.return);
                                break;
                            case 12:
                                Jo(r, p);
                                break;
                            case 31:
                                Jo(r, p),
                                g & 4 && Kd(r, p);
                                break;
                            case 13:
                                Jo(r, p),
                                g & 4 && Fv(r, p),
                                g & 64 && (r = p.memoizedState,
                                r !== null && (r = r.dehydrated,
                                r !== null && (p = CO.bind(null, p),
                                qO(r, p))));
                                break;
                            case 22:
                                if (g = p.memoizedState !== null || gr,
                                !g) {
                                    l = l !== null && l.memoizedState !== null || di,
                                    b = gr;
                                    var C = di;
                                    gr = g,
                                    (di = l) && !C ? Pn(r, p, (p.subtreeFlags & 8772) !== 0) : Jo(r, p),
                                    gr = b,
                                    di = C
                                }
                                break;
                            case 30:
                                break;
                            default:
                                Jo(r, p)
                            }
                        }
                        function Zd(r) {
                            var l = r.alternate;
                            l !== null && (r.alternate = null,
                            Zd(l)),
                            r.child = null,
                            r.deletions = null,
                            r.sibling = null,
                            r.tag === 5 && (l = r.stateNode,
                            l !== null && Ge(l)),
                            r.stateNode = null,
                            r.return = null,
                            r.dependencies = null,
                            r.memoizedProps = null,
                            r.memoizedState = null,
                            r.pendingProps = null,
                            r.stateNode = null,
                            r.updateQueue = null
                        }
                        var Cn = null
                          , Qi = !1;
                        function Vs(r, l, p) {
                            for (p = p.child; p !== null; )
                                ec(r, l, p),
                                p = p.sibling
                        }
                        function ec(r, l, p) {
                            if (Ze && typeof Ze.onCommitFiberUnmount == "function")
                                try {
                                    Ze.onCommitFiberUnmount(Je, p)
                                } catch {}
                            switch (p.tag) {
                            case 26:
                                di || qa(p, l),
                                Vs(r, l, p),
                                p.memoizedState ? p.memoizedState.count-- : p.stateNode && (p = p.stateNode,
                                p.parentNode.removeChild(p));
                                break;
                            case 27:
                                di || qa(p, l);
                                var g = Cn
                                  , b = Qi;
                                Qu(p.type) && (Cn = p.stateNode,
                                Qi = !1),
                                Vs(r, l, p),
                                kv(p.stateNode),
                                Cn = g,
                                Qi = b;
                                break;
                            case 5:
                                di || qa(p, l);
                            case 6:
                                if (g = Cn,
                                b = Qi,
                                Cn = null,
                                Vs(r, l, p),
                                Cn = g,
                                Qi = b,
                                Cn !== null)
                                    if (Qi)
                                        try {
                                            (Cn.nodeType === 9 ? Cn.body : Cn.nodeName === "HTML" ? Cn.ownerDocument.body : Cn).removeChild(p.stateNode)
                                        } catch (C) {
                                            Kn(p, l, C)
                                        }
                                    else
                                        try {
                                            Cn.removeChild(p.stateNode)
                                        } catch (C) {
                                            Kn(p, l, C)
                                        }
                                break;
                            case 18:
                                Cn !== null && (Qi ? (r = Cn,
                                eE(r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r, p.stateNode),
                                lp(r)) : eE(Cn, p.stateNode));
                                break;
                            case 4:
                                g = Cn,
                                b = Qi,
                                Cn = p.stateNode.containerInfo,
                                Qi = !0,
                                Vs(r, l, p),
                                Cn = g,
                                Qi = b;
                                break;
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                mr(2, p, l),
                                di || mr(4, p, l),
                                Vs(r, l, p);
                                break;
                            case 1:
                                di || (qa(p, l),
                                g = p.stateNode,
                                typeof g.componentWillUnmount == "function" && zv(p, l, g)),
                                Vs(r, l, p);
                                break;
                            case 21:
                                Vs(r, l, p);
                                break;
                            case 22:
                                di = (g = di) || p.memoizedState !== null,
                                Vs(r, l, p),
                                di = g;
                                break;
                            default:
                                Vs(r, l, p)
                            }
                        }
                        function Kd(r, l) {
                            if (l.memoizedState === null && (r = l.alternate,
                            r !== null && (r = r.memoizedState,
                            r !== null))) {
                                r = r.dehydrated;
                                try {
                                    lp(r)
                                } catch (p) {
                                    Kn(l, l.return, p)
                                }
                            }
                        }
                        function Fv(r, l) {
                            if (l.memoizedState === null && (r = l.alternate,
                            r !== null && (r = r.memoizedState,
                            r !== null && (r = r.dehydrated,
                            r !== null))))
                                try {
                                    lp(r)
                                } catch (p) {
                                    Kn(l, l.return, p)
                                }
                        }
                        function my(r) {
                            switch (r.tag) {
                            case 31:
                            case 13:
                            case 19:
                                var l = r.stateNode;
                                return l === null && (l = r.stateNode = new of),
                                l;
                            case 22:
                                return r = r.stateNode,
                                l = r._retryCache,
                                l === null && (l = r._retryCache = new of),
                                l;
                            default:
                                throw Error(s(435, r.tag))
                            }
                        }
                        function Ii(r, l) {
                            var p = my(r);
                            l.forEach(function(g) {
                                if (!p.has(g)) {
                                    p.add(g);
                                    var b = wO.bind(null, r, g);
                                    g.then(b, b)
                                }
                            })
                        }
                        function ks(r, l) {
                            var p = l.deletions;
                            if (p !== null)
                                for (var g = 0; g < p.length; g++) {
                                    var b = p[g]
                                      , C = r
                                      , F = l
                                      , J = F;
                                    e: for (; J !== null; ) {
                                        switch (J.tag) {
                                        case 27:
                                            if (Qu(J.type)) {
                                                Cn = J.stateNode,
                                                Qi = !1;
                                                break e
                                            }
                                            break;
                                        case 5:
                                            Cn = J.stateNode,
                                            Qi = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            Cn = J.stateNode.containerInfo,
                                            Qi = !0;
                                            break e
                                        }
                                        J = J.return
                                    }
                                    if (Cn === null)
                                        throw Error(s(160));
                                    ec(C, F, b),
                                    Cn = null,
                                    Qi = !1,
                                    C = b.alternate,
                                    C !== null && (C.return = null),
                                    b.return = null
                                }
                            if (l.subtreeFlags & 13886)
                                for (l = l.child; l !== null; )
                                    tc(l, r),
                                    l = l.sibling
                        }
                        var ya = null;
                        function tc(r, l) {
                            var p = r.alternate
                              , g = r.flags;
                            switch (r.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                ks(l, r),
                                wi(r),
                                g & 4 && (mr(3, r, r.return),
                                _o(3, r),
                                mr(5, r, r.return));
                                break;
                            case 1:
                                ks(l, r),
                                wi(r),
                                g & 512 && (di || p === null || qa(p, p.return)),
                                g & 64 && gr && (r = r.updateQueue,
                                r !== null && (g = r.callbacks,
                                g !== null && (p = r.shared.hiddenCallbacks,
                                r.shared.hiddenCallbacks = p === null ? g : p.concat(g))));
                                break;
                            case 26:
                                var b = ya;
                                if (ks(l, r),
                                wi(r),
                                g & 512 && (di || p === null || qa(p, p.return)),
                                g & 4) {
                                    var C = p !== null ? p.memoizedState : null;
                                    if (g = r.memoizedState,
                                    p === null)
                                        if (g === null)
                                            if (r.stateNode === null) {
                                                e: {
                                                    g = r.type,
                                                    p = r.memoizedProps,
                                                    b = b.ownerDocument || b;
                                                    t: switch (g) {
                                                    case "title":
                                                        C = b.getElementsByTagName("title")[0],
                                                        (!C || C[Se] || C[Qt] || C.namespaceURI === "http://www.w3.org/2000/svg" || C.hasAttribute("itemprop")) && (C = b.createElement(g),
                                                        b.head.insertBefore(C, b.querySelector("head > title"))),
                                                        ta(C, g, p),
                                                        C[Qt] = r,
                                                        pt(C),
                                                        g = C;
                                                        break e;
                                                    case "link":
                                                        var F = hE("link", "href", b).get(g + (p.href || ""));
                                                        if (F) {
                                                            for (var J = 0; J < F.length; J++)
                                                                if (C = F[J],
                                                                C.getAttribute("href") === (p.href == null || p.href === "" ? null : p.href) && C.getAttribute("rel") === (p.rel == null ? null : p.rel) && C.getAttribute("title") === (p.title == null ? null : p.title) && C.getAttribute("crossorigin") === (p.crossOrigin == null ? null : p.crossOrigin)) {
                                                                    F.splice(J, 1);
                                                                    break t
                                                                }
                                                        }
                                                        C = b.createElement(g),
                                                        ta(C, g, p),
                                                        b.head.appendChild(C);
                                                        break;
                                                    case "meta":
                                                        if (F = hE("meta", "content", b).get(g + (p.content || ""))) {
                                                            for (J = 0; J < F.length; J++)
                                                                if (C = F[J],
                                                                C.getAttribute("content") === (p.content == null ? null : "" + p.content) && C.getAttribute("name") === (p.name == null ? null : p.name) && C.getAttribute("property") === (p.property == null ? null : p.property) && C.getAttribute("http-equiv") === (p.httpEquiv == null ? null : p.httpEquiv) && C.getAttribute("charset") === (p.charSet == null ? null : p.charSet)) {
                                                                    F.splice(J, 1);
                                                                    break t
                                                                }
                                                        }
                                                        C = b.createElement(g),
                                                        ta(C, g, p),
                                                        b.head.appendChild(C);
                                                        break;
                                                    default:
                                                        throw Error(s(468, g))
                                                    }
                                                    C[Qt] = r,
                                                    pt(C),
                                                    g = C
                                                }
                                                r.stateNode = g
                                            } else
                                                fE(b, r.type, r.stateNode);
                                        else
                                            r.stateNode = uE(b, g, r.memoizedProps);
                                    else
                                        C !== g ? (C === null ? p.stateNode !== null && (p = p.stateNode,
                                        p.parentNode.removeChild(p)) : C.count--,
                                        g === null ? fE(b, r.type, r.stateNode) : uE(b, g, r.memoizedProps)) : g === null && r.stateNode !== null && vr(r, r.memoizedProps, p.memoizedProps)
                                }
                                break;
                            case 27:
                                ks(l, r),
                                wi(r),
                                g & 512 && (di || p === null || qa(p, p.return)),
                                p !== null && g & 4 && vr(r, r.memoizedProps, p.memoizedProps);
                                break;
                            case 5:
                                if (ks(l, r),
                                wi(r),
                                g & 512 && (di || p === null || qa(p, p.return)),
                                r.flags & 32) {
                                    b = r.stateNode;
                                    try {
                                        io(b, "")
                                    } catch (wt) {
                                        Kn(r, r.return, wt)
                                    }
                                }
                                g & 4 && r.stateNode != null && (b = r.memoizedProps,
                                vr(r, b, p !== null ? p.memoizedProps : b)),
                                g & 1024 && (Ko = !0);
                                break;
                            case 6:
                                if (ks(l, r),
                                wi(r),
                                g & 4) {
                                    if (r.stateNode === null)
                                        throw Error(s(162));
                                    g = r.memoizedProps,
                                    p = r.stateNode;
                                    try {
                                        p.nodeValue = g
                                    } catch (wt) {
                                        Kn(r, r.return, wt)
                                    }
                                }
                                break;
                            case 3:
                                if (My = null,
                                b = ya,
                                ya = Ay(l.containerInfo),
                                ks(l, r),
                                ya = b,
                                wi(r),
                                g & 4 && p !== null && p.memoizedState.isDehydrated)
                                    try {
                                        lp(l.containerInfo)
                                    } catch (wt) {
                                        Kn(r, r.return, wt)
                                    }
                                Ko && (Ko = !1,
                                vy(r));
                                break;
                            case 4:
                                g = ya,
                                ya = Ay(r.stateNode.containerInfo),
                                ks(l, r),
                                wi(r),
                                ya = g;
                                break;
                            case 12:
                                ks(l, r),
                                wi(r);
                                break;
                            case 31:
                                ks(l, r),
                                wi(r),
                                g & 4 && (g = r.updateQueue,
                                g !== null && (r.updateQueue = null,
                                Ii(r, g)));
                                break;
                            case 13:
                                ks(l, r),
                                wi(r),
                                r.child.flags & 8192 && r.memoizedState !== null != (p !== null && p.memoizedState !== null) && (tl = pe()),
                                g & 4 && (g = r.updateQueue,
                                g !== null && (r.updateQueue = null,
                                Ii(r, g)));
                                break;
                            case 22:
                                b = r.memoizedState !== null;
                                var ve = p !== null && p.memoizedState !== null
                                  , Pe = gr
                                  , Ke = di;
                                if (gr = Pe || b,
                                di = Ke || ve,
                                ks(l, r),
                                di = Ke,
                                gr = Pe,
                                wi(r),
                                g & 8192)
                                    e: for (l = r.stateNode,
                                    l._visibility = b ? l._visibility & -2 : l._visibility | 1,
                                    b && (p === null || ve || gr || di || Fc(r)),
                                    p = null,
                                    l = r; ; ) {
                                        if (l.tag === 5 || l.tag === 26) {
                                            if (p === null) {
                                                ve = p = l;
                                                try {
                                                    if (C = ve.stateNode,
                                                    b)
                                                        F = C.style,
                                                        typeof F.setProperty == "function" ? F.setProperty("display", "none", "important") : F.display = "none";
                                                    else {
                                                        J = ve.stateNode;
                                                        var st = ve.memoizedProps.style
                                                          , Ve = st != null && st.hasOwnProperty("display") ? st.display : null;
                                                        J.style.display = Ve == null || typeof Ve == "boolean" ? "" : ("" + Ve).trim()
                                                    }
                                                } catch (wt) {
                                                    Kn(ve, ve.return, wt)
                                                }
                                            }
                                        } else if (l.tag === 6) {
                                            if (p === null) {
                                                ve = l;
                                                try {
                                                    ve.stateNode.nodeValue = b ? "" : ve.memoizedProps
                                                } catch (wt) {
                                                    Kn(ve, ve.return, wt)
                                                }
                                            }
                                        } else if (l.tag === 18) {
                                            if (p === null) {
                                                ve = l;
                                                try {
                                                    var Ye = ve.stateNode;
                                                    b ? tE(Ye, !0) : tE(ve.stateNode, !1)
                                                } catch (wt) {
                                                    Kn(ve, ve.return, wt)
                                                }
                                            }
                                        } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === r) && l.child !== null) {
                                            l.child.return = l,
                                            l = l.child;
                                            continue
                                        }
                                        if (l === r)
                                            break e;
                                        for (; l.sibling === null; ) {
                                            if (l.return === null || l.return === r)
                                                break e;
                                            p === l && (p = null),
                                            l = l.return
                                        }
                                        p === l && (p = null),
                                        l.sibling.return = l.return,
                                        l = l.sibling
                                    }
                                g & 4 && (g = r.updateQueue,
                                g !== null && (p = g.retryQueue,
                                p !== null && (g.retryQueue = null,
                                Ii(r, p))));
                                break;
                            case 19:
                                ks(l, r),
                                wi(r),
                                g & 4 && (g = r.updateQueue,
                                g !== null && (r.updateQueue = null,
                                Ii(r, g)));
                                break;
                            case 30:
                                break;
                            case 21:
                                break;
                            default:
                                ks(l, r),
                                wi(r)
                            }
                        }
                        function wi(r) {
                            var l = r.flags;
                            if (l & 2) {
                                try {
                                    for (var p, g = r.return; g !== null; ) {
                                        if (ji(g)) {
                                            p = g;
                                            break
                                        }
                                        g = g.return
                                    }
                                    if (p == null)
                                        throw Error(s(160));
                                    switch (p.tag) {
                                    case 27:
                                        var b = p.stateNode
                                          , C = xo(r);
                                        Bn(r, C, b);
                                        break;
                                    case 5:
                                        var F = p.stateNode;
                                        p.flags & 32 && (io(F, ""),
                                        p.flags &= -33);
                                        var J = xo(r);
                                        Bn(r, J, F);
                                        break;
                                    case 3:
                                    case 4:
                                        var ve = p.stateNode.containerInfo
                                          , Pe = xo(r);
                                        $t(r, Pe, ve);
                                        break;
                                    default:
                                        throw Error(s(161))
                                    }
                                } catch (Ke) {
                                    Kn(r, r.return, Ke)
                                }
                                r.flags &= -3
                            }
                            l & 4096 && (r.flags &= -4097)
                        }
                        function vy(r) {
                            if (r.subtreeFlags & 1024)
                                for (r = r.child; r !== null; ) {
                                    var l = r;
                                    vy(l),
                                    l.tag === 5 && l.flags & 1024 && l.stateNode.reset(),
                                    r = r.sibling
                                }
                        }
                        function Jo(r, l) {
                            if (l.subtreeFlags & 8772)
                                for (l = l.child; l !== null; )
                                    py(r, l.alternate, l),
                                    l = l.sibling
                        }
                        function Fc(r) {
                            for (r = r.child; r !== null; ) {
                                var l = r;
                                switch (l.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    mr(4, l, l.return),
                                    Fc(l);
                                    break;
                                case 1:
                                    qa(l, l.return);
                                    var p = l.stateNode;
                                    typeof p.componentWillUnmount == "function" && zv(l, l.return, p),
                                    Fc(l);
                                    break;
                                case 27:
                                    kv(l.stateNode);
                                case 26:
                                case 5:
                                    qa(l, l.return),
                                    Fc(l);
                                    break;
                                case 22:
                                    l.memoizedState === null && Fc(l);
                                    break;
                                case 30:
                                    Fc(l);
                                    break;
                                default:
                                    Fc(l)
                                }
                                r = r.sibling
                            }
                        }
                        function Pn(r, l, p) {
                            for (p = p && (l.subtreeFlags & 8772) !== 0,
                            l = l.child; l !== null; ) {
                                var g = l.alternate
                                  , b = r
                                  , C = l
                                  , F = C.flags;
                                switch (C.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pn(b, C, p),
                                    _o(4, C);
                                    break;
                                case 1:
                                    if (Pn(b, C, p),
                                    g = C,
                                    b = g.stateNode,
                                    typeof b.componentDidMount == "function")
                                        try {
                                            b.componentDidMount()
                                        } catch (Pe) {
                                            Kn(g, g.return, Pe)
                                        }
                                    if (g = C,
                                    b = g.updateQueue,
                                    b !== null) {
                                        var J = g.stateNode;
                                        try {
                                            var ve = b.shared.hiddenCallbacks;
                                            if (ve !== null)
                                                for (b.shared.hiddenCallbacks = null,
                                                b = 0; b < ve.length; b++)
                                                    mo(ve[b], J)
                                        } catch (Pe) {
                                            Kn(g, g.return, Pe)
                                        }
                                    }
                                    p && F & 64 && $l(C),
                                    So(C, C.return);
                                    break;
                                case 27:
                                    Li(C);
                                case 26:
                                case 5:
                                    Pn(b, C, p),
                                    p && g === null && F & 4 && ja(C),
                                    So(C, C.return);
                                    break;
                                case 12:
                                    Pn(b, C, p);
                                    break;
                                case 31:
                                    Pn(b, C, p),
                                    p && F & 4 && Kd(b, C);
                                    break;
                                case 13:
                                    Pn(b, C, p),
                                    p && F & 4 && Fv(b, C);
                                    break;
                                case 22:
                                    C.memoizedState === null && Pn(b, C, p),
                                    So(C, C.return);
                                    break;
                                case 30:
                                    break;
                                default:
                                    Pn(b, C, p)
                                }
                                l = l.sibling
                            }
                        }
                        function Jd(r, l) {
                            var p = null;
                            r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (p = r.memoizedState.cachePool.pool),
                            r = null,
                            l.memoizedState !== null && l.memoizedState.cachePool !== null && (r = l.memoizedState.cachePool.pool),
                            r !== p && (r != null && r.refCount++,
                            p != null && Ms(p))
                        }
                        function $o(r, l) {
                            r = null,
                            l.alternate !== null && (r = l.alternate.memoizedState.cache),
                            l = l.memoizedState.cache,
                            l !== r && (l.refCount++,
                            r != null && Ms(r))
                        }
                        function is(r, l, p, g) {
                            if (l.subtreeFlags & 10256)
                                for (l = l.child; l !== null; )
                                    _i(r, l, p, g),
                                    l = l.sibling
                        }
                        function _i(r, l, p, g) {
                            var b = l.flags;
                            switch (l.tag) {
                            case 0:
                            case 11:
                            case 15:
                                is(r, l, p, g),
                                b & 2048 && _o(9, l);
                                break;
                            case 1:
                                is(r, l, p, g);
                                break;
                            case 3:
                                is(r, l, p, g),
                                b & 2048 && (r = null,
                                l.alternate !== null && (r = l.alternate.memoizedState.cache),
                                l = l.memoizedState.cache,
                                l !== r && (l.refCount++,
                                r != null && Ms(r)));
                                break;
                            case 12:
                                if (b & 2048) {
                                    is(r, l, p, g),
                                    r = l.stateNode;
                                    try {
                                        var C = l.memoizedProps
                                          , F = C.id
                                          , J = C.onPostCommit;
                                        typeof J == "function" && J(F, l.alternate === null ? "mount" : "update", r.passiveEffectDuration, -0)
                                    } catch (ve) {
                                        Kn(l, l.return, ve)
                                    }
                                } else
                                    is(r, l, p, g);
                                break;
                            case 31:
                                is(r, l, p, g);
                                break;
                            case 13:
                                is(r, l, p, g);
                                break;
                            case 23:
                                break;
                            case 22:
                                C = l.stateNode,
                                F = l.alternate,
                                l.memoizedState !== null ? C._visibility & 2 ? is(r, l, p, g) : Wu(r, l) : C._visibility & 2 ? is(r, l, p, g) : (C._visibility |= 2,
                                nc(r, l, p, g, (l.subtreeFlags & 10256) !== 0 || !1)),
                                b & 2048 && Jd(F, l);
                                break;
                            case 24:
                                is(r, l, p, g),
                                b & 2048 && $o(l.alternate, l);
                                break;
                            default:
                                is(r, l, p, g)
                            }
                        }
                        function nc(r, l, p, g, b) {
                            for (b = b && ((l.subtreeFlags & 10256) !== 0 || !1),
                            l = l.child; l !== null; ) {
                                var C = r
                                  , F = l
                                  , J = p
                                  , ve = g
                                  , Pe = F.flags;
                                switch (F.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    nc(C, F, J, ve, b),
                                    _o(8, F);
                                    break;
                                case 23:
                                    break;
                                case 22:
                                    var Ke = F.stateNode;
                                    F.memoizedState !== null ? Ke._visibility & 2 ? nc(C, F, J, ve, b) : Wu(C, F) : (Ke._visibility |= 2,
                                    nc(C, F, J, ve, b)),
                                    b && Pe & 2048 && Jd(F.alternate, F);
                                    break;
                                case 24:
                                    nc(C, F, J, ve, b),
                                    b && Pe & 2048 && $o(F.alternate, F);
                                    break;
                                default:
                                    nc(C, F, J, ve, b)
                                }
                                l = l.sibling
                            }
                        }
                        function Wu(r, l) {
                            if (l.subtreeFlags & 10256)
                                for (l = l.child; l !== null; ) {
                                    var p = r
                                      , g = l
                                      , b = g.flags;
                                    switch (g.tag) {
                                    case 22:
                                        Wu(p, g),
                                        b & 2048 && Jd(g.alternate, g);
                                        break;
                                    case 24:
                                        Wu(p, g),
                                        b & 2048 && $o(g.alternate, g);
                                        break;
                                    default:
                                        Wu(p, g)
                                    }
                                    l = l.sibling
                                }
                        }
                        var Di = 8192;
                        function Hc(r, l, p) {
                            if (r.subtreeFlags & Di)
                                for (r = r.child; r !== null; )
                                    Pi(r, l, p),
                                    r = r.sibling
                        }
                        function Pi(r, l, p) {
                            switch (r.tag) {
                            case 26:
                                Hc(r, l, p),
                                r.flags & Di && r.memoizedState !== null && aN(p, ya, r.memoizedState, r.memoizedProps);
                                break;
                            case 5:
                                Hc(r, l, p);
                                break;
                            case 3:
                            case 4:
                                var g = ya;
                                ya = Ay(r.stateNode.containerInfo),
                                Hc(r, l, p),
                                ya = g;
                                break;
                            case 22:
                                r.memoizedState === null && (g = r.alternate,
                                g !== null && g.memoizedState !== null ? (g = Di,
                                Di = 16777216,
                                Hc(r, l, p),
                                Di = g) : Hc(r, l, p));
                                break;
                            default:
                                Hc(r, l, p)
                            }
                        }
                        function _a(r) {
                            var l = r.alternate;
                            if (l !== null && (r = l.child,
                            r !== null)) {
                                l.child = null;
                                do
                                    l = r.sibling,
                                    r.sibling = null,
                                    r = l;
                                while (r !== null)
                            }
                        }
                        function ea(r) {
                            var l = r.deletions;
                            if ((r.flags & 16) !== 0) {
                                if (l !== null)
                                    for (var p = 0; p < l.length; p++) {
                                        var g = l[p];
                                        Ci = g,
                                        lf(g, r)
                                    }
                                _a(r)
                            }
                            if (r.subtreeFlags & 10256)
                                for (r = r.child; r !== null; )
                                    Gc(r),
                                    r = r.sibling
                        }
                        function Gc(r) {
                            switch (r.tag) {
                            case 0:
                            case 11:
                            case 15:
                                ea(r),
                                r.flags & 2048 && mr(9, r, r.return);
                                break;
                            case 3:
                                ea(r);
                                break;
                            case 12:
                                ea(r);
                                break;
                            case 22:
                                var l = r.stateNode;
                                r.memoizedState !== null && l._visibility & 2 && (r.return === null || r.return.tag !== 13) ? (l._visibility &= -3,
                                $d(r)) : ea(r);
                                break;
                            default:
                                ea(r)
                            }
                        }
                        function $d(r) {
                            var l = r.deletions;
                            if ((r.flags & 16) !== 0) {
                                if (l !== null)
                                    for (var p = 0; p < l.length; p++) {
                                        var g = l[p];
                                        Ci = g,
                                        lf(g, r)
                                    }
                                _a(r)
                            }
                            for (r = r.child; r !== null; ) {
                                switch (l = r,
                                l.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    mr(8, l, l.return),
                                    $d(l);
                                    break;
                                case 22:
                                    p = l.stateNode,
                                    p._visibility & 2 && (p._visibility &= -3,
                                    $d(l));
                                    break;
                                default:
                                    $d(l)
                                }
                                r = r.sibling
                            }
                        }
                        function lf(r, l) {
                            for (; Ci !== null; ) {
                                var p = Ci;
                                switch (p.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    mr(8, p, l);
                                    break;
                                case 23:
                                case 22:
                                    if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
                                        var g = p.memoizedState.cachePool.pool;
                                        g != null && g.refCount++
                                    }
                                    break;
                                case 24:
                                    Ms(p.memoizedState.cache)
                                }
                                if (g = p.child,
                                g !== null)
                                    g.return = p,
                                    Ci = g;
                                else
                                    e: for (p = r; Ci !== null; ) {
                                        g = Ci;
                                        var b = g.sibling
                                          , C = g.return;
                                        if (Zd(g),
                                        g === p) {
                                            Ci = null;
                                            break e
                                        }
                                        if (b !== null) {
                                            b.return = C,
                                            Ci = b;
                                            break e
                                        }
                                        Ci = C
                                    }
                            }
                        }
                        var ep = {
                            getCacheForType: function(r) {
                                var l = fs(It)
                                  , p = l.data.get(r);
                                return p === void 0 && (p = r(),
                                l.data.set(r, p)),
                                p
                            },
                            cacheSignal: function() {
                                return fs(It).controller.signal
                            }
                        }
                          , tp = typeof WeakMap == "function" ? WeakMap : Map
                          , Sn = 0
                          , zn = null
                          , en = null
                          , mn = 0
                          , Pt = 0
                          , cn = null
                          , jt = !1
                          , rn = !1
                          , Qn = !1
                          , zi = 0
                          , Fn = 0
                          , Qa = 0
                          , el = 0
                          , kr = 0
                          , xn = 0
                          , Za = 0
                          , Xr = null
                          , Xs = null
                          , Sa = !1
                          , tl = 0
                          , Yu = 0
                          , Ka = 1 / 0
                          , qu = null
                          , Ao = null
                          , Si = 0
                          , Wr = null
                          , Ja = null
                          , yr = 0
                          , nl = 0
                          , Vc = null
                          , np = null
                          , kc = 0
                          , Xc = null;
                        function xa() {
                            return (Sn & 2) !== 0 && mn !== 0 ? mn & -mn : W.T !== null ? Fx() : ei()
                        }
                        function h() {
                            if (xn === 0)
                                if ((mn & 536870912) === 0 || gn) {
                                    var r = xt;
                                    xt <<= 1,
                                    (xt & 3932160) === 0 && (xt = 262144),
                                    xn = r
                                } else
                                    xn = 536870912;
                            return r = ns.current,
                            r !== null && (r.flags |= 32),
                            xn
                        }
                        function d(r, l, p) {
                            (r === zn && (Pt === 2 || Pt === 9) || r.cancelPendingCommit !== null) && (Ce(r, 0),
                            P(r, mn, xn, !1)),
                            Un(r, p),
                            ((Sn & 2) === 0 || r !== zn) && (r === zn && ((Sn & 2) === 0 && (el |= p),
                            Fn === 4 && P(r, mn, xn, !1)),
                            Yc(r))
                        }
                        function _(r, l, p) {
                            if ((Sn & 6) !== 0)
                                throw Error(s(327));
                            var g = !p && (l & 127) === 0 && (l & r.expiredLanes) === 0 || _t(r, l)
                              , b = g ? Wc(r, l) : Aa(r, l, !0)
                              , C = g;
                            do {
                                if (b === 0) {
                                    rn && !g && P(r, l, 0, !1);
                                    break
                                } else {
                                    if (p = r.current.alternate,
                                    C && !R(p)) {
                                        b = Aa(r, l, !1),
                                        C = !1;
                                        continue
                                    }
                                    if (b === 2) {
                                        if (C = l,
                                        r.errorRecoveryDisabledLanes & C)
                                            var F = 0;
                                        else
                                            F = r.pendingLanes & -536870913,
                                            F = F !== 0 ? F : F & 536870912 ? 536870912 : 0;
                                        if (F !== 0) {
                                            l = F;
                                            e: {
                                                var J = r;
                                                b = Xr;
                                                var ve = J.current.memoizedState.isDehydrated;
                                                if (ve && (Ce(J, F).flags |= 256),
                                                F = Aa(J, F, !1),
                                                F !== 2) {
                                                    if (Qn && !ve) {
                                                        J.errorRecoveryDisabledLanes |= C,
                                                        el |= C,
                                                        b = 4;
                                                        break e
                                                    }
                                                    C = Xs,
                                                    Xs = b,
                                                    C !== null && (Xs === null ? Xs = C : Xs.push.apply(Xs, C))
                                                }
                                                b = F
                                            }
                                            if (C = !1,
                                            b !== 2)
                                                continue
                                        }
                                    }
                                    if (b === 1) {
                                        Ce(r, 0),
                                        P(r, l, 0, !0);
                                        break
                                    }
                                    e: {
                                        switch (g = r,
                                        C = b,
                                        C) {
                                        case 0:
                                        case 1:
                                            throw Error(s(345));
                                        case 4:
                                            if ((l & 4194048) !== l)
                                                break;
                                        case 6:
                                            P(g, l, xn, !jt);
                                            break e;
                                        case 2:
                                            Xs = null;
                                            break;
                                        case 3:
                                        case 5:
                                            break;
                                        default:
                                            throw Error(s(329))
                                        }
                                        if ((l & 62914560) === l && (b = tl + 300 - pe(),
                                        10 < b)) {
                                            if (P(g, l, xn, !jt),
                                            dt(g, 0, !0) !== 0)
                                                break e;
                                            yr = l,
                                            g.timeoutHandle = Jb(E.bind(null, g, p, Xs, qu, Sa, l, xn, el, Za, jt, C, "Throttled", -0, 0), b);
                                            break e
                                        }
                                        E(g, p, Xs, qu, Sa, l, xn, el, Za, jt, C, null, -0, 0)
                                    }
                                }
                                break
                            } while (!0);
                            Yc(r)
                        }
                        function E(r, l, p, g, b, C, F, J, ve, Pe, Ke, st, Ve, Ye) {
                            if (r.timeoutHandle = -1,
                            st = l.subtreeFlags,
                            st & 8192 || (st & 16785408) === 16785408) {
                                st = {
                                    stylesheets: null,
                                    count: 0,
                                    imgCount: 0,
                                    imgBytes: 0,
                                    suspenseyImages: [],
                                    waitingForImages: !0,
                                    waitingForViewTransition: !1,
                                    unsuspend: Ba
                                },
                                Pi(l, C, st);
                                var wt = (C & 62914560) === C ? tl - pe() : (C & 4194048) === C ? Yu - pe() : 0;
                                if (wt = rN(st, wt),
                                wt !== null) {
                                    yr = C,
                                    r.cancelPendingCommit = wt(kt.bind(null, r, l, C, p, g, b, F, J, ve, Ke, st, null, Ve, Ye)),
                                    P(r, C, F, !Pe);
                                    return
                                }
                            }
                            kt(r, l, C, p, g, b, F, J, ve)
                        }
                        function R(r) {
                            for (var l = r; ; ) {
                                var p = l.tag;
                                if ((p === 0 || p === 11 || p === 15) && l.flags & 16384 && (p = l.updateQueue,
                                p !== null && (p = p.stores,
                                p !== null)))
                                    for (var g = 0; g < p.length; g++) {
                                        var b = p[g]
                                          , C = b.getSnapshot;
                                        b = b.value;
                                        try {
                                            if (!hi(C(), b))
                                                return !1
                                        } catch {
                                            return !1
                                        }
                                    }
                                if (p = l.child,
                                l.subtreeFlags & 16384 && p !== null)
                                    p.return = l,
                                    l = p;
                                else {
                                    if (l === r)
                                        break;
                                    for (; l.sibling === null; ) {
                                        if (l.return === null || l.return === r)
                                            return !0;
                                        l = l.return
                                    }
                                    l.sibling.return = l.return,
                                    l = l.sibling
                                }
                            }
                            return !0
                        }
                        function P(r, l, p, g) {
                            l &= ~kr,
                            l &= ~el,
                            r.suspendedLanes |= l,
                            r.pingedLanes &= ~l,
                            g && (r.warmLanes |= l),
                            g = r.expirationTimes;
                            for (var b = l; 0 < b; ) {
                                var C = 31 - lt(b)
                                  , F = 1 << C;
                                g[C] = -1,
                                b &= ~F
                            }
                            p !== 0 && ki(r, p, l)
                        }
                        function ne() {
                            return (Sn & 6) === 0 ? (Hv(0, !1),
                            !1) : !0
                        }
                        function me() {
                            if (en !== null) {
                                if (Pt === 0)
                                    var r = en.return;
                                else
                                    r = en,
                                    Fs = Vo = null,
                                    vv(r),
                                    Xl = null,
                                    Wl = 0,
                                    r = en;
                                for (; r !== null; )
                                    zc(r.alternate, r),
                                    r = r.return;
                                en = null
                            }
                        }
                        function Ce(r, l) {
                            var p = r.timeoutHandle;
                            p !== -1 && (r.timeoutHandle = -1,
                            VO(p)),
                            p = r.cancelPendingCommit,
                            p !== null && (r.cancelPendingCommit = null,
                            p()),
                            yr = 0,
                            me(),
                            zn = r,
                            en = p = co(r.current, null),
                            mn = l,
                            Pt = 0,
                            cn = null,
                            jt = !1,
                            rn = _t(r, l),
                            Qn = !1,
                            Za = xn = kr = el = Qa = Fn = 0,
                            Xs = Xr = null,
                            Sa = !1,
                            (l & 8) !== 0 && (l |= l & 32);
                            var g = r.entangledLanes;
                            if (g !== 0)
                                for (r = r.entanglements,
                                g &= l; 0 < g; ) {
                                    var b = 31 - lt(g)
                                      , C = 1 << b;
                                    l |= r[b],
                                    g &= ~C
                                }
                            return zi = l,
                            Pl(),
                            p
                        }
                        function et(r, l) {
                            Vt = null,
                            W.H = Qh,
                            l === kl || l === Fr ? (l = Ud(),
                            Pt = 3) : l === Fh ? (l = Ud(),
                            Pt = 4) : Pt = l === qd ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1,
                            cn = l,
                            en === null && (Fn = 1,
                            Yd(r, fa(l, r.current)))
                        }
                        function mt() {
                            var r = ns.current;
                            return r === null ? !0 : (mn & 4194048) === mn ? fr === null : (mn & 62914560) === mn || (mn & 536870912) !== 0 ? r === fr : !1
                        }
                        function Tt() {
                            var r = W.H;
                            return W.H = Qh,
                            r === null ? Qh : r
                        }
                        function bt() {
                            var r = W.A;
                            return W.A = ep,
                            r
                        }
                        function qt() {
                            Fn = 4,
                            jt || (mn & 4194048) !== mn && ns.current !== null || (rn = !0),
                            (Qa & 134217727) === 0 && (el & 134217727) === 0 || zn === null || P(zn, mn, xn, !1)
                        }
                        function Aa(r, l, p) {
                            var g = Sn;
                            Sn |= 2;
                            var b = Tt()
                              , C = bt();
                            (zn !== r || mn !== l) && (qu = null,
                            Ce(r, l)),
                            l = !1;
                            var F = Fn;
                            e: do
                                try {
                                    if (Pt !== 0 && en !== null) {
                                        var J = en
                                          , ve = cn;
                                        switch (Pt) {
                                        case 8:
                                            me(),
                                            F = 6;
                                            break e;
                                        case 3:
                                        case 2:
                                        case 9:
                                        case 6:
                                            ns.current === null && (l = !0);
                                            var Pe = Pt;
                                            if (Pt = 0,
                                            cn = null,
                                            ut(r, J, ve, Pe),
                                            p && rn) {
                                                F = 0;
                                                break e
                                            }
                                            break;
                                        default:
                                            Pe = Pt,
                                            Pt = 0,
                                            cn = null,
                                            ut(r, J, ve, Pe)
                                        }
                                    }
                                    cf(),
                                    F = Fn;
                                    break
                                } catch (Ke) {
                                    et(r, Ke)
                                }
                            while (!0);
                            return l && r.shellSuspendCounter++,
                            Fs = Vo = null,
                            Sn = g,
                            W.H = b,
                            W.A = C,
                            en === null && (zn = null,
                            mn = 0,
                            Pl()),
                            F
                        }
                        function cf() {
                            for (; en !== null; )
                                Me(en)
                        }
                        function Wc(r, l) {
                            var p = Sn;
                            Sn |= 2;
                            var g = Tt()
                              , b = bt();
                            zn !== r || mn !== l ? (qu = null,
                            Ka = pe() + 500,
                            Ce(r, l)) : rn = _t(r, l);
                            e: do
                                try {
                                    if (Pt !== 0 && en !== null) {
                                        l = en;
                                        var C = cn;
                                        t: switch (Pt) {
                                        case 1:
                                            Pt = 0,
                                            cn = null,
                                            ut(r, l, C, 1);
                                            break;
                                        case 2:
                                        case 9:
                                            if (G0(C)) {
                                                Pt = 0,
                                                cn = null,
                                                Xe(l);
                                                break
                                            }
                                            l = function() {
                                                Pt !== 2 && Pt !== 9 || zn !== r || (Pt = 7),
                                                Yc(r)
                                            }
                                            ,
                                            C.then(l, l);
                                            break e;
                                        case 3:
                                            Pt = 7;
                                            break e;
                                        case 4:
                                            Pt = 5;
                                            break e;
                                        case 7:
                                            G0(C) ? (Pt = 0,
                                            cn = null,
                                            Xe(l)) : (Pt = 0,
                                            cn = null,
                                            ut(r, l, C, 7));
                                            break;
                                        case 5:
                                            var F = null;
                                            switch (en.tag) {
                                            case 26:
                                                F = en.memoizedState;
                                            case 5:
                                            case 27:
                                                var J = en;
                                                if (F ? dE(F) : J.stateNode.complete) {
                                                    Pt = 0,
                                                    cn = null;
                                                    var ve = J.sibling;
                                                    if (ve !== null)
                                                        en = ve;
                                                    else {
                                                        var Pe = J.return;
                                                        Pe !== null ? (en = Pe,
                                                        Bt(Pe)) : en = null
                                                    }
                                                    break t
                                                }
                                            }
                                            Pt = 0,
                                            cn = null,
                                            ut(r, l, C, 5);
                                            break;
                                        case 6:
                                            Pt = 0,
                                            cn = null,
                                            ut(r, l, C, 6);
                                            break;
                                        case 8:
                                            me(),
                                            Fn = 6;
                                            break e;
                                        default:
                                            throw Error(s(462))
                                        }
                                    }
                                    Fe();
                                    break
                                } catch (Ke) {
                                    et(r, Ke)
                                }
                            while (!0);
                            return Fs = Vo = null,
                            W.H = g,
                            W.A = b,
                            Sn = p,
                            en !== null ? 0 : (zn = null,
                            mn = 0,
                            Pl(),
                            Fn)
                        }
                        function Fe() {
                            for (; en !== null && !$(); )
                                Me(en)
                        }
                        function Me(r) {
                            var l = jd(r.alternate, r, zi);
                            r.memoizedProps = r.pendingProps,
                            l === null ? Bt(r) : en = l
                        }
                        function Xe(r) {
                            var l = r
                              , p = l.alternate;
                            switch (l.tag) {
                            case 15:
                            case 0:
                                l = Gs(p, l, l.pendingProps, l.type, void 0, mn);
                                break;
                            case 11:
                                l = Gs(p, l, l.pendingProps, l.type.render, l.ref, mn);
                                break;
                            case 5:
                                vv(l);
                            default:
                                zc(p, l),
                                l = en = zs(l, zi),
                                l = jd(p, l, zi)
                            }
                            r.memoizedProps = r.pendingProps,
                            l === null ? Bt(r) : en = l
                        }
                        function ut(r, l, p, g) {
                            Fs = Vo = null,
                            vv(l),
                            Xl = null,
                            Wl = 0;
                            var b = l.return;
                            try {
                                if (Va(r, b, l, p, mn)) {
                                    Fn = 1,
                                    Yd(r, fa(p, r.current)),
                                    en = null;
                                    return
                                }
                            } catch (C) {
                                if (b !== null)
                                    throw en = b,
                                    C;
                                Fn = 1,
                                Yd(r, fa(p, r.current)),
                                en = null;
                                return
                            }
                            l.flags & 32768 ? (gn || g === 1 ? r = !0 : rn || (mn & 536870912) !== 0 ? r = !1 : (jt = r = !0,
                            (g === 2 || g === 9 || g === 3 || g === 6) && (g = ns.current,
                            g !== null && g.tag === 13 && (g.flags |= 16384))),
                            ii(l, r)) : Bt(l)
                        }
                        function Bt(r) {
                            var l = r;
                            do {
                                if ((l.flags & 32768) !== 0) {
                                    ii(l, jt);
                                    return
                                }
                                r = l.return;
                                var p = Pv(l.alternate, l, zi);
                                if (p !== null) {
                                    en = p;
                                    return
                                }
                                if (l = l.sibling,
                                l !== null) {
                                    en = l;
                                    return
                                }
                                en = l = r
                            } while (l !== null);
                            Fn === 0 && (Fn = 5)
                        }
                        function ii(r, l) {
                            do {
                                var p = Qd(r.alternate, r);
                                if (p !== null) {
                                    p.flags &= 32767,
                                    en = p;
                                    return
                                }
                                if (p = r.return,
                                p !== null && (p.flags |= 32768,
                                p.subtreeFlags = 0,
                                p.deletions = null),
                                !l && (r = r.sibling,
                                r !== null)) {
                                    en = r;
                                    return
                                }
                                en = r = p
                            } while (r !== null);
                            Fn = 6,
                            en = null
                        }
                        function kt(r, l, p, g, b, C, F, J, ve) {
                            r.cancelPendingCommit = null;
                            do
                                ip();
                            while (Si !== 0);
                            if ((Sn & 6) !== 0)
                                throw Error(s(327));
                            if (l !== null) {
                                if (l === r.current)
                                    throw Error(s(177));
                                if (C = l.lanes | l.childLanes,
                                C |= Td,
                                On(r, p, C, F, J, ve),
                                r === zn && (en = zn = null,
                                mn = 0),
                                Ja = l,
                                Wr = r,
                                yr = p,
                                nl = C,
                                Vc = b,
                                np = g,
                                (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (r.callbackNode = null,
                                r.callbackPriority = 0,
                                DO(rt, function() {
                                    return Bb(),
                                    null
                                })) : (r.callbackNode = null,
                                r.callbackPriority = 0),
                                g = (l.flags & 13878) !== 0,
                                (l.subtreeFlags & 13878) !== 0 || g) {
                                    g = W.T,
                                    W.T = null,
                                    b = V.p,
                                    V.p = 2,
                                    F = Sn,
                                    Sn |= 4;
                                    try {
                                        Xu(r, l, p)
                                    } finally {
                                        Sn = F,
                                        V.p = b,
                                        W.T = g
                                    }
                                }
                                Si = 1,
                                wn(),
                                ss(),
                                Dn()
                            }
                        }
                        function wn() {
                            if (Si === 1) {
                                Si = 0;
                                var r = Wr
                                  , l = Ja
                                  , p = (l.flags & 13878) !== 0;
                                if ((l.subtreeFlags & 13878) !== 0 || p) {
                                    p = W.T,
                                    W.T = null;
                                    var g = V.p;
                                    V.p = 2;
                                    var b = Sn;
                                    Sn |= 4;
                                    try {
                                        tc(l, r);
                                        var C = Yx
                                          , F = yd(r.containerInfo)
                                          , J = C.focusedElem
                                          , ve = C.selectionRange;
                                        if (F !== J && J && J.ownerDocument && gd(J.ownerDocument.documentElement, J)) {
                                            if (ve !== null && Tu(J)) {
                                                var Pe = ve.start
                                                  , Ke = ve.end;
                                                if (Ke === void 0 && (Ke = Pe),
                                                "selectionStart"in J)
                                                    J.selectionStart = Pe,
                                                    J.selectionEnd = Math.min(Ke, J.value.length);
                                                else {
                                                    var st = J.ownerDocument || document
                                                      , Ve = st && st.defaultView || window;
                                                    if (Ve.getSelection) {
                                                        var Ye = Ve.getSelection()
                                                          , wt = J.textContent.length
                                                          , Gt = Math.min(ve.start, wt)
                                                          , ai = ve.end === void 0 ? Gt : Math.min(ve.end, wt);
                                                        !Ye.extend && Gt > ai && (F = ai,
                                                        ai = Gt,
                                                        Gt = F);
                                                        var be = Wm(J, Gt)
                                                          , _e = Wm(J, ai);
                                                        if (be && _e && (Ye.rangeCount !== 1 || Ye.anchorNode !== be.node || Ye.anchorOffset !== be.offset || Ye.focusNode !== _e.node || Ye.focusOffset !== _e.offset)) {
                                                            var Be = st.createRange();
                                                            Be.setStart(be.node, be.offset),
                                                            Ye.removeAllRanges(),
                                                            Gt > ai ? (Ye.addRange(Be),
                                                            Ye.extend(_e.node, _e.offset)) : (Be.setEnd(_e.node, _e.offset),
                                                            Ye.addRange(Be))
                                                        }
                                                    }
                                                }
                                            }
                                            for (st = [],
                                            Ye = J; Ye = Ye.parentNode; )
                                                Ye.nodeType === 1 && st.push({
                                                    element: Ye,
                                                    left: Ye.scrollLeft,
                                                    top: Ye.scrollTop
                                                });
                                            for (typeof J.focus == "function" && J.focus(),
                                            J = 0; J < st.length; J++) {
                                                var nt = st[J];
                                                nt.element.scrollLeft = nt.left,
                                                nt.element.scrollTop = nt.top
                                            }
                                        }
                                        wy = !!Wx,
                                        Yx = Wx = null
                                    } finally {
                                        Sn = b,
                                        V.p = g,
                                        W.T = p
                                    }
                                }
                                r.current = l,
                                Si = 2
                            }
                        }
                        function ss() {
                            if (Si === 2) {
                                Si = 0;
                                var r = Wr
                                  , l = Ja
                                  , p = (l.flags & 8772) !== 0;
                                if ((l.subtreeFlags & 8772) !== 0 || p) {
                                    p = W.T,
                                    W.T = null;
                                    var g = V.p;
                                    V.p = 2;
                                    var b = Sn;
                                    Sn |= 4;
                                    try {
                                        py(r, l.alternate, l)
                                    } finally {
                                        Sn = b,
                                        V.p = g,
                                        W.T = p
                                    }
                                }
                                Si = 3
                            }
                        }
                        function Dn() {
                            if (Si === 4 || Si === 3) {
                                Si = 0,
                                Y();
                                var r = Wr
                                  , l = Ja
                                  , p = yr
                                  , g = np;
                                (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? Si = 5 : (Si = 0,
                                Ja = Wr = null,
                                il(r, r.pendingLanes));
                                var b = r.pendingLanes;
                                if (b === 0 && (Ao = null),
                                _s(p),
                                l = l.stateNode,
                                Ze && typeof Ze.onCommitFiberRoot == "function")
                                    try {
                                        Ze.onCommitFiberRoot(Je, l, void 0, (l.current.flags & 128) === 128)
                                    } catch {}
                                if (g !== null) {
                                    l = W.T,
                                    b = V.p,
                                    V.p = 2,
                                    W.T = null;
                                    try {
                                        for (var C = r.onRecoverableError, F = 0; F < g.length; F++) {
                                            var J = g[F];
                                            C(J.value, {
                                                componentStack: J.stack
                                            })
                                        }
                                    } finally {
                                        W.T = l,
                                        V.p = b
                                    }
                                }
                                (yr & 3) !== 0 && ip(),
                                Yc(r),
                                b = r.pendingLanes,
                                (p & 261930) !== 0 && (b & 42) !== 0 ? r === Xc ? kc++ : (kc = 0,
                                Xc = r) : kc = 0,
                                Hv(0, !1)
                            }
                        }
                        function il(r, l) {
                            (r.pooledCacheLanes &= l) === 0 && (l = r.pooledCache,
                            l != null && (r.pooledCache = null,
                            Ms(l)))
                        }
                        function ip() {
                            return wn(),
                            ss(),
                            Dn(),
                            Bb()
                        }
                        function Bb() {
                            if (Si !== 5)
                                return !1;
                            var r = Wr
                              , l = nl;
                            nl = 0;
                            var p = _s(yr)
                              , g = W.T
                              , b = V.p;
                            try {
                                V.p = 32 > p ? 32 : p,
                                W.T = null,
                                p = Vc,
                                Vc = null;
                                var C = Wr
                                  , F = yr;
                                if (Si = 0,
                                Ja = Wr = null,
                                yr = 0,
                                (Sn & 6) !== 0)
                                    throw Error(s(331));
                                var J = Sn;
                                if (Sn |= 4,
                                Gc(C.current),
                                _i(C, C.current, F, p),
                                Sn = J,
                                Hv(0, !1),
                                Ze && typeof Ze.onPostCommitFiberRoot == "function")
                                    try {
                                        Ze.onPostCommitFiberRoot(Je, C)
                                    } catch {}
                                return !0
                            } finally {
                                V.p = b,
                                W.T = g,
                                il(r, l)
                            }
                        }
                        function Lb(r, l, p) {
                            l = fa(p, l),
                            l = Iv(r.stateNode, l, 2),
                            r = ql(r, l, 2),
                            r !== null && (Un(r, 2),
                            Yc(r))
                        }
                        function Kn(r, l, p) {
                            if (r.tag === 3)
                                Lb(r, r, p);
                            else
                                for (; l !== null; ) {
                                    if (l.tag === 3) {
                                        Lb(l, r, p);
                                        break
                                    } else if (l.tag === 1) {
                                        var g = l.stateNode;
                                        if (typeof l.type.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && (Ao === null || !Ao.has(g))) {
                                            r = fa(p, r),
                                            p = Fu(2),
                                            g = ql(l, p, 2),
                                            g !== null && (va(p, g, l, r),
                                            Un(g, 2),
                                            Yc(g));
                                            break
                                        }
                                    }
                                    l = l.return
                                }
                        }
                        function Ix(r, l, p) {
                            var g = r.pingCache;
                            if (g === null) {
                                g = r.pingCache = new tp;
                                var b = new Set;
                                g.set(l, b)
                            } else
                                b = g.get(l),
                                b === void 0 && (b = new Set,
                                g.set(l, b));
                            b.has(p) || (Qn = !0,
                            b.add(p),
                            r = EO.bind(null, r, l, p),
                            l.then(r, r))
                        }
                        function EO(r, l, p) {
                            var g = r.pingCache;
                            g !== null && g.delete(l),
                            r.pingedLanes |= r.suspendedLanes & p,
                            r.warmLanes &= ~p,
                            zn === r && (mn & p) === p && (Fn === 4 || Fn === 3 && (mn & 62914560) === mn && 300 > pe() - tl ? (Sn & 2) === 0 && Ce(r, 0) : kr |= p,
                            Za === mn && (Za = 0)),
                            Yc(r)
                        }
                        function Ib(r, l) {
                            l === 0 && (l = Ot()),
                            r = zl(r, l),
                            r !== null && (Un(r, l),
                            Yc(r))
                        }
                        function CO(r) {
                            var l = r.memoizedState
                              , p = 0;
                            l !== null && (p = l.retryLane),
                            Ib(r, p)
                        }
                        function wO(r, l) {
                            var p = 0;
                            switch (r.tag) {
                            case 31:
                            case 13:
                                var g = r.stateNode
                                  , b = r.memoizedState;
                                b !== null && (p = b.retryLane);
                                break;
                            case 19:
                                g = r.stateNode;
                                break;
                            case 22:
                                g = r.stateNode._retryCache;
                                break;
                            default:
                                throw Error(s(314))
                            }
                            g !== null && g.delete(l),
                            Ib(r, p)
                        }
                        function DO(r, l) {
                            return it(r, l)
                        }
                        var gy = null
                          , sp = null
                          , Px = !1
                          , yy = !1
                          , zx = !1
                          , ju = 0;
                        function Yc(r) {
                            r !== sp && r.next === null && (sp === null ? gy = sp = r : sp = sp.next = r),
                            yy = !0,
                            Px || (Px = !0,
                            UO())
                        }
                        function Hv(r, l) {
                            if (!zx && yy) {
                                zx = !0;
                                do
                                    for (var p = !1, g = gy; g !== null; ) {
                                        if (!l)
                                            if (r !== 0) {
                                                var b = g.pendingLanes;
                                                if (b === 0)
                                                    var C = 0;
                                                else {
                                                    var F = g.suspendedLanes
                                                      , J = g.pingedLanes;
                                                    C = (1 << 31 - lt(42 | r) + 1) - 1,
                                                    C &= b & ~(F & ~J),
                                                    C = C & 201326741 ? C & 201326741 | 1 : C ? C | 2 : 0
                                                }
                                                C !== 0 && (p = !0,
                                                Hb(g, C))
                                            } else
                                                C = mn,
                                                C = dt(g, g === zn ? C : 0, g.cancelPendingCommit !== null || g.timeoutHandle !== -1),
                                                (C & 3) === 0 || _t(g, C) || (p = !0,
                                                Hb(g, C));
                                        g = g.next
                                    }
                                while (p);
                                zx = !1
                            }
                        }
                        function RO() {
                            Pb()
                        }
                        function Pb() {
                            yy = Px = !1;
                            var r = 0;
                            ju !== 0 && GO() && (r = ju);
                            for (var l = pe(), p = null, g = gy; g !== null; ) {
                                var b = g.next
                                  , C = zb(g, l);
                                C === 0 ? (g.next = null,
                                p === null ? gy = b : p.next = b,
                                b === null && (sp = p)) : (p = g,
                                (r !== 0 || (C & 3) !== 0) && (yy = !0)),
                                g = b
                            }
                            Si !== 0 && Si !== 5 || Hv(r, !1),
                            ju !== 0 && (ju = 0)
                        }
                        function zb(r, l) {
                            for (var p = r.suspendedLanes, g = r.pingedLanes, b = r.expirationTimes, C = r.pendingLanes & -62914561; 0 < C; ) {
                                var F = 31 - lt(C)
                                  , J = 1 << F
                                  , ve = b[F];
                                ve === -1 ? ((J & p) === 0 || (J & g) !== 0) && (b[F] = Ct(J, l)) : ve <= l && (r.expiredLanes |= J),
                                C &= ~J
                            }
                            if (l = zn,
                            p = mn,
                            p = dt(r, r === l ? p : 0, r.cancelPendingCommit !== null || r.timeoutHandle !== -1),
                            g = r.callbackNode,
                            p === 0 || r === l && (Pt === 2 || Pt === 9) || r.cancelPendingCommit !== null)
                                return g !== null && g !== null && je(g),
                                r.callbackNode = null,
                                r.callbackPriority = 0;
                            if ((p & 3) === 0 || _t(r, p)) {
                                if (l = p & -p,
                                l === r.callbackPriority)
                                    return l;
                                switch (g !== null && je(g),
                                _s(p)) {
                                case 2:
                                case 8:
                                    p = De;
                                    break;
                                case 32:
                                    p = rt;
                                    break;
                                case 268435456:
                                    p = ct;
                                    break;
                                default:
                                    p = rt
                                }
                                return g = Fb.bind(null, r),
                                p = it(p, g),
                                r.callbackPriority = l,
                                r.callbackNode = p,
                                l
                            }
                            return g !== null && g !== null && je(g),
                            r.callbackPriority = 2,
                            r.callbackNode = null,
                            2
                        }
                        function Fb(r, l) {
                            if (Si !== 0 && Si !== 5)
                                return r.callbackNode = null,
                                r.callbackPriority = 0,
                                null;
                            var p = r.callbackNode;
                            if (ip() && r.callbackNode !== p)
                                return null;
                            var g = mn;
                            return g = dt(r, r === zn ? g : 0, r.cancelPendingCommit !== null || r.timeoutHandle !== -1),
                            g === 0 ? null : (_(r, g, l),
                            zb(r, pe()),
                            r.callbackNode != null && r.callbackNode === p ? Fb.bind(null, r) : null)
                        }
                        function Hb(r, l) {
                            if (ip())
                                return null;
                            _(r, l, !0)
                        }
                        function UO() {
                            kO(function() {
                                (Sn & 6) !== 0 ? it(Re, RO) : Pb()
                            })
                        }
                        function Fx() {
                            if (ju === 0) {
                                var r = Wo;
                                r === 0 && (r = tt,
                                tt <<= 1,
                                (tt & 261888) === 0 && (tt = 256)),
                                ju = r
                            }
                            return ju
                        }
                        function Gb(r) {
                            return r == null || typeof r == "symbol" || typeof r == "boolean" ? null : typeof r == "function" ? r : Dr("" + r)
                        }
                        function Vb(r, l) {
                            var p = l.ownerDocument.createElement("input");
                            return p.name = l.name,
                            p.value = l.value,
                            r.id && p.setAttribute("form", r.id),
                            l.parentNode.insertBefore(p, l),
                            r = new FormData(r),
                            p.parentNode.removeChild(p),
                            r
                        }
                        function OO(r, l, p, g, b) {
                            if (l === "submit" && p && p.stateNode === b) {
                                var C = Gb((b[Xi] || null).action)
                                  , F = g.submitter;
                                F && (l = (l = F[Xi] || null) ? Gb(l.formAction) : F.getAttribute("formAction"),
                                l !== null && (C = l,
                                F = null));
                                var J = new Br("action","action",null,g,b);
                                r.push({
                                    event: J,
                                    listeners: [{
                                        instance: null,
                                        listener: function() {
                                            if (g.defaultPrevented) {
                                                if (ju !== 0) {
                                                    var ve = F ? Vb(b, F) : new FormData(b);
                                                    Uv(p, {
                                                        pending: !0,
                                                        data: ve,
                                                        method: b.method,
                                                        action: C
                                                    }, null, ve)
                                                }
                                            } else
                                                typeof C == "function" && (J.preventDefault(),
                                                ve = F ? Vb(b, F) : new FormData(b),
                                                Uv(p, {
                                                    pending: !0,
                                                    data: ve,
                                                    method: b.method,
                                                    action: C
                                                }, C, ve))
                                        },
                                        currentTarget: b
                                    }]
                                })
                            }
                        }
                        for (var Hx = 0; Hx < Ad.length; Hx++) {
                            var Gx = Ad[Hx]
                              , NO = Gx.toLowerCase()
                              , BO = Gx[0].toUpperCase() + Gx.slice(1);
                            Ps(NO, "on" + BO)
                        }
                        Ps(ha, "onAnimationEnd"),
                        Ps(Ym, "onAnimationIteration"),
                        Ps(lo, "onAnimationStart"),
                        Ps("dblclick", "onDoubleClick"),
                        Ps("focusin", "onFocus"),
                        Ps("focusout", "onBlur"),
                        Ps(Cu, "onTransitionRun"),
                        Ps(Ll, "onTransitionStart"),
                        Ps(qm, "onTransitionCancel"),
                        Ps(xd, "onTransitionEnd"),
                        Dt("onMouseEnter", ["mouseout", "mouseover"]),
                        Dt("onMouseLeave", ["mouseout", "mouseover"]),
                        Dt("onPointerEnter", ["pointerout", "pointerover"]),
                        Dt("onPointerLeave", ["pointerout", "pointerover"]),
                        Ut("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
                        Ut("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
                        Ut("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
                        Ut("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
                        Ut("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
                        Ut("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                        var Gv = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
                          , LO = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Gv));
                        function kb(r, l) {
                            l = (l & 4) !== 0;
                            for (var p = 0; p < r.length; p++) {
                                var g = r[p]
                                  , b = g.event;
                                g = g.listeners;
                                e: {
                                    var C = void 0;
                                    if (l)
                                        for (var F = g.length - 1; 0 <= F; F--) {
                                            var J = g[F]
                                              , ve = J.instance
                                              , Pe = J.currentTarget;
                                            if (J = J.listener,
                                            ve !== C && b.isPropagationStopped())
                                                break e;
                                            C = J,
                                            b.currentTarget = Pe;
                                            try {
                                                C(b)
                                            } catch (Ke) {
                                                Il(Ke)
                                            }
                                            b.currentTarget = null,
                                            C = ve
                                        }
                                    else
                                        for (F = 0; F < g.length; F++) {
                                            if (J = g[F],
                                            ve = J.instance,
                                            Pe = J.currentTarget,
                                            J = J.listener,
                                            ve !== C && b.isPropagationStopped())
                                                break e;
                                            C = J,
                                            b.currentTarget = Pe;
                                            try {
                                                C(b)
                                            } catch (Ke) {
                                                Il(Ke)
                                            }
                                            b.currentTarget = null,
                                            C = ve
                                        }
                                }
                            }
                        }
                        function yn(r, l) {
                            var p = l[Cr];
                            p === void 0 && (p = l[Cr] = new Set);
                            var g = r + "__bubble";
                            p.has(g) || (Wb(l, r, 2, !1),
                            p.add(g))
                        }
                        function Vx(r, l, p) {
                            var g = 0;
                            l && (g |= 4),
                            Wb(p, r, g, l)
                        }
                        var _y = "_reactListening" + Math.random().toString(36).slice(2);
                        function Xb(r) {
                            if (!r[_y]) {
                                r[_y] = !0,
                                St.forEach(function(p) {
                                    p !== "selectionchange" && (LO.has(p) || Vx(p, !1, r),
                                    Vx(p, !0, r))
                                });
                                var l = r.nodeType === 9 ? r : r.ownerDocument;
                                l === null || l[_y] || (l[_y] = !0,
                                Vx("selectionchange", !1, l))
                            }
                        }
                        function Wb(r, l, p, g) {
                            switch (yE(l)) {
                            case 2:
                                var b = hN;
                                break;
                            case 8:
                                b = fN;
                                break;
                            default:
                                b = iA
                            }
                            p = b.bind(null, l, p, r),
                            b = void 0,
                            !_c || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (b = !0),
                            g ? b !== void 0 ? r.addEventListener(l, p, {
                                capture: !0,
                                passive: b
                            }) : r.addEventListener(l, p, !0) : b !== void 0 ? r.addEventListener(l, p, {
                                passive: b
                            }) : r.addEventListener(l, p, !1)
                        }
                        function kx(r, l, p, g, b) {
                            var C = g;
                            if ((l & 1) === 0 && (l & 2) === 0 && g !== null)
                                e: for (; ; ) {
                                    if (g === null)
                                        return;
                                    var F = g.tag;
                                    if (F === 3 || F === 4) {
                                        var J = g.stateNode.containerInfo;
                                        if (J === b)
                                            break;
                                        if (F === 4)
                                            for (F = g.return; F !== null; ) {
                                                var ve = F.tag;
                                                if ((ve === 3 || ve === 4) && F.stateNode.containerInfo === b)
                                                    return;
                                                F = F.return
                                            }
                                        for (; J !== null; ) {
                                            if (F = Ue(J),
                                            F === null)
                                                return;
                                            if (ve = F.tag,
                                            ve === 5 || ve === 6 || ve === 26 || ve === 27) {
                                                g = C = F;
                                                continue e
                                            }
                                            J = J.parentNode
                                        }
                                    }
                                    g = g.return
                                }
                            vu(function() {
                                var Pe = C
                                  , Ke = Al(p)
                                  , st = [];
                                e: {
                                    var Ve = zo.get(r);
                                    if (Ve !== void 0) {
                                        var Ye = Br
                                          , wt = r;
                                        switch (r) {
                                        case "keypress":
                                            if (La(p) === 0)
                                                break e;
                                        case "keydown":
                                        case "keyup":
                                            Ye = Lm;
                                            break;
                                        case "focusin":
                                            wt = "focus",
                                            Ye = Is;
                                            break;
                                        case "focusout":
                                            wt = "blur",
                                            Ye = Is;
                                            break;
                                        case "beforeblur":
                                        case "afterblur":
                                            Ye = Is;
                                            break;
                                        case "click":
                                            if (p.button === 2)
                                                break e;
                                        case "auxclick":
                                        case "dblclick":
                                        case "mousedown":
                                        case "mousemove":
                                        case "mouseup":
                                        case "mouseout":
                                        case "mouseover":
                                        case "contextmenu":
                                            Ye = xc;
                                            break;
                                        case "drag":
                                        case "dragend":
                                        case "dragenter":
                                        case "dragexit":
                                        case "dragleave":
                                        case "dragover":
                                        case "dragstart":
                                        case "drop":
                                            Ye = fd;
                                            break;
                                        case "touchcancel":
                                        case "touchend":
                                        case "touchmove":
                                        case "touchstart":
                                            Ye = Io;
                                            break;
                                        case ha:
                                        case Ym:
                                        case lo:
                                            Ye = Lr;
                                            break;
                                        case xd:
                                            Ye = Cx;
                                            break;
                                        case "scroll":
                                        case "scrollend":
                                            Ye = ro;
                                            break;
                                        case "wheel":
                                            Ye = Dl;
                                            break;
                                        case "copy":
                                        case "cut":
                                        case "paste":
                                            Ye = Rm;
                                            break;
                                        case "gotpointercapture":
                                        case "lostpointercapture":
                                        case "pointercancel":
                                        case "pointerdown":
                                        case "pointermove":
                                        case "pointerout":
                                        case "pointerover":
                                        case "pointerup":
                                            Ye = dd;
                                            break;
                                        case "toggle":
                                        case "beforetoggle":
                                            Ye = Pm
                                        }
                                        var Gt = (l & 4) !== 0
                                          , ai = !Gt && (r === "scroll" || r === "scrollend")
                                          , be = Gt ? Ve !== null ? Ve + "Capture" : null : Ve;
                                        Gt = [];
                                        for (var _e = Pe, Be; _e !== null; ) {
                                            var nt = _e;
                                            if (Be = nt.stateNode,
                                            nt = nt.tag,
                                            nt !== 5 && nt !== 26 && nt !== 27 || Be === null || be === null || (nt = es(_e, be),
                                            nt != null && Gt.push(Vv(_e, nt, Be))),
                                            ai)
                                                break;
                                            _e = _e.return
                                        }
                                        0 < Gt.length && (Ve = new Ye(Ve,wt,null,p,Ke),
                                        st.push({
                                            event: Ve,
                                            listeners: Gt
                                        }))
                                    }
                                }
                                if ((l & 7) === 0) {
                                    e: {
                                        if (Ve = r === "mouseover" || r === "pointerover",
                                        Ye = r === "mouseout" || r === "pointerout",
                                        Ve && p !== Rr && (wt = p.relatedTarget || p.fromElement) && (Ue(wt) || wt[lr]))
                                            break e;
                                        if ((Ye || Ve) && (Ve = Ke.window === Ke ? Ke : (Ve = Ke.ownerDocument) ? Ve.defaultView || Ve.parentWindow : window,
                                        Ye ? (wt = p.relatedTarget || p.toElement,
                                        Ye = Pe,
                                        wt = wt ? Ue(wt) : null,
                                        wt !== null && (ai = o(wt),
                                        Gt = wt.tag,
                                        wt !== ai || Gt !== 5 && Gt !== 27 && Gt !== 6) && (wt = null)) : (Ye = null,
                                        wt = Pe),
                                        Ye !== wt)) {
                                            if (Gt = xc,
                                            nt = "onMouseLeave",
                                            be = "onMouseEnter",
                                            _e = "mouse",
                                            (r === "pointerout" || r === "pointerover") && (Gt = dd,
                                            nt = "onPointerLeave",
                                            be = "onPointerEnter",
                                            _e = "pointer"),
                                            ai = Ye == null ? Ve : at(Ye),
                                            Be = wt == null ? Ve : at(wt),
                                            Ve = new Gt(nt,_e + "leave",Ye,p,Ke),
                                            Ve.target = ai,
                                            Ve.relatedTarget = Be,
                                            nt = null,
                                            Ue(Ke) === Pe && (Gt = new Gt(be,_e + "enter",wt,p,Ke),
                                            Gt.target = Be,
                                            Gt.relatedTarget = ai,
                                            nt = Gt),
                                            ai = nt,
                                            Ye && wt)
                                                t: {
                                                    for (Gt = IO,
                                                    be = Ye,
                                                    _e = wt,
                                                    Be = 0,
                                                    nt = be; nt; nt = Gt(nt))
                                                        Be++;
                                                    nt = 0;
                                                    for (var zt = _e; zt; zt = Gt(zt))
                                                        nt++;
                                                    for (; 0 < Be - nt; )
                                                        be = Gt(be),
                                                        Be--;
                                                    for (; 0 < nt - Be; )
                                                        _e = Gt(_e),
                                                        nt--;
                                                    for (; Be--; ) {
                                                        if (be === _e || _e !== null && be === _e.alternate) {
                                                            Gt = be;
                                                            break t
                                                        }
                                                        be = Gt(be),
                                                        _e = Gt(_e)
                                                    }
                                                    Gt = null
                                                }
                                            else
                                                Gt = null;
                                            Ye !== null && Yb(st, Ve, Ye, Gt, !1),
                                            wt !== null && ai !== null && Yb(st, ai, wt, Gt, !0)
                                        }
                                    }
                                    e: {
                                        if (Ve = Pe ? at(Pe) : window,
                                        Ye = Ve.nodeName && Ve.nodeName.toLowerCase(),
                                        Ye === "select" || Ye === "input" && Ve.type === "file")
                                            var Hn = Vm;
                                        else if (Hm(Ve))
                                            if (Rh)
                                                Hn = N0;
                                            else {
                                                Hn = Ol;
                                                var Nt = Uh
                                            }
                                        else
                                            Ye = Ve.nodeName,
                                            !Ye || Ye.toLowerCase() !== "input" || Ve.type !== "checkbox" && Ve.type !== "radio" ? Pe && so(Pe.elementType) && (Hn = Vm) : Hn = O0;
                                        if (Hn && (Hn = Hn(r, Pe))) {
                                            vd(st, Hn, p, Ke);
                                            break e
                                        }
                                        Nt && Nt(r, Ve, Pe),
                                        r === "focusout" && Pe && Ve.type === "number" && Pe.memoizedProps.value != null && Na(Ve, "number", Ve.value)
                                    }
                                    switch (Nt = Pe ? at(Pe) : window,
                                    r) {
                                    case "focusin":
                                        (Hm(Nt) || Nt.contentEditable === "true") && (Mu = Nt,
                                        _d = Pe,
                                        bu = null);
                                        break;
                                    case "focusout":
                                        bu = _d = Mu = null;
                                        break;
                                    case "mousedown":
                                        Pa = !0;
                                        break;
                                    case "contextmenu":
                                    case "mouseup":
                                    case "dragend":
                                        Pa = !1,
                                        Sd(st, p, Ke);
                                        break;
                                    case "selectionchange":
                                        if (B0)
                                            break;
                                    case "keydown":
                                    case "keyup":
                                        Sd(st, p, Ke)
                                    }
                                    var on;
                                    if (Ac)
                                        e: {
                                            switch (r) {
                                            case "compositionstart":
                                                var An = "onCompositionStart";
                                                break e;
                                            case "compositionend":
                                                An = "onCompositionEnd";
                                                break e;
                                            case "compositionupdate":
                                                An = "onCompositionUpdate";
                                                break e
                                            }
                                            An = void 0
                                        }
                                    else
                                        Ul ? pd(r, p) && (An = "onCompositionEnd") : r === "keydown" && p.keyCode === 229 && (An = "onCompositionStart");
                                    An && (Ts && p.locale !== "ko" && (Ul || An !== "onCompositionStart" ? An === "onCompositionEnd" && Ul && (on = ao()) : (cr = Ke,
                                    Sc = "value"in cr ? cr.value : cr.textContent,
                                    Ul = !0)),
                                    Nt = Sy(Pe, An),
                                    0 < Nt.length && (An = new Um(An,r,null,p,Ke),
                                    st.push({
                                        event: An,
                                        listeners: Nt
                                    }),
                                    on ? An.data = on : (on = yu(p),
                                    on !== null && (An.data = on)))),
                                    (on = Tc ? md(r, p) : D0(r, p)) && (An = Sy(Pe, "onBeforeInput"),
                                    0 < An.length && (Nt = new Um("onBeforeInput","beforeinput",null,p,Ke),
                                    st.push({
                                        event: Nt,
                                        listeners: An
                                    }),
                                    Nt.data = on)),
                                    OO(st, r, Pe, p, Ke)
                                }
                                kb(st, l)
                            })
                        }
                        function Vv(r, l, p) {
                            return {
                                instance: r,
                                listener: l,
                                currentTarget: p
                            }
                        }
                        function Sy(r, l) {
                            for (var p = l + "Capture", g = []; r !== null; ) {
                                var b = r
                                  , C = b.stateNode;
                                if (b = b.tag,
                                b !== 5 && b !== 26 && b !== 27 || C === null || (b = es(r, p),
                                b != null && g.unshift(Vv(r, b, C)),
                                b = es(r, l),
                                b != null && g.push(Vv(r, b, C))),
                                r.tag === 3)
                                    return g;
                                r = r.return
                            }
                            return []
                        }
                        function IO(r) {
                            if (r === null)
                                return null;
                            do
                                r = r.return;
                            while (r && r.tag !== 5 && r.tag !== 27);
                            return r || null
                        }
                        function Yb(r, l, p, g, b) {
                            for (var C = l._reactName, F = []; p !== null && p !== g; ) {
                                var J = p
                                  , ve = J.alternate
                                  , Pe = J.stateNode;
                                if (J = J.tag,
                                ve !== null && ve === g)
                                    break;
                                J !== 5 && J !== 26 && J !== 27 || Pe === null || (ve = Pe,
                                b ? (Pe = es(p, C),
                                Pe != null && F.unshift(Vv(p, Pe, ve))) : b || (Pe = es(p, C),
                                Pe != null && F.push(Vv(p, Pe, ve)))),
                                p = p.return
                            }
                            F.length !== 0 && r.push({
                                event: l,
                                listeners: F
                            })
                        }
                        var PO = /\r\n?/g
                          , zO = /\u0000|\uFFFD/g;
                        function qb(r) {
                            return (typeof r == "string" ? r : "" + r).replace(PO, `
`).replace(zO, "")
                        }
                        function jb(r, l) {
                            return l = qb(l),
                            qb(r) === l
                        }
                        function si(r, l, p, g, b, C) {
                            switch (p) {
                            case "children":
                                typeof g == "string" ? l === "body" || l === "textarea" && g === "" || io(r, g) : (typeof g == "number" || typeof g == "bigint") && l !== "body" && io(r, "" + g);
                                break;
                            case "className":
                                Et(r, "class", g);
                                break;
                            case "tabIndex":
                                Et(r, "tabindex", g);
                                break;
                            case "dir":
                            case "role":
                            case "viewBox":
                            case "width":
                            case "height":
                                Et(r, p, g);
                                break;
                            case "style":
                                mu(r, g, C);
                                break;
                            case "data":
                                if (l !== "object") {
                                    Et(r, "data", g);
                                    break
                                }
                            case "src":
                            case "href":
                                if (g === "" && (l !== "a" || p !== "href")) {
                                    r.removeAttribute(p);
                                    break
                                }
                                if (g == null || typeof g == "function" || typeof g == "symbol" || typeof g == "boolean") {
                                    r.removeAttribute(p);
                                    break
                                }
                                g = Dr("" + g),
                                r.setAttribute(p, g);
                                break;
                            case "action":
                            case "formAction":
                                if (typeof g == "function") {
                                    r.setAttribute(p, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                                    break
                                } else
                                    typeof C == "function" && (p === "formAction" ? (l !== "input" && si(r, l, "name", b.name, b, null),
                                    si(r, l, "formEncType", b.formEncType, b, null),
                                    si(r, l, "formMethod", b.formMethod, b, null),
                                    si(r, l, "formTarget", b.formTarget, b, null)) : (si(r, l, "encType", b.encType, b, null),
                                    si(r, l, "method", b.method, b, null),
                                    si(r, l, "target", b.target, b, null)));
                                if (g == null || typeof g == "symbol" || typeof g == "boolean") {
                                    r.removeAttribute(p);
                                    break
                                }
                                g = Dr("" + g),
                                r.setAttribute(p, g);
                                break;
                            case "onClick":
                                g != null && (r.onclick = Ba);
                                break;
                            case "onScroll":
                                g != null && yn("scroll", r);
                                break;
                            case "onScrollEnd":
                                g != null && yn("scrollend", r);
                                break;
                            case "dangerouslySetInnerHTML":
                                if (g != null) {
                                    if (typeof g != "object" || !("__html"in g))
                                        throw Error(s(61));
                                    if (p = g.__html,
                                    p != null) {
                                        if (b.children != null)
                                            throw Error(s(60));
                                        r.innerHTML = p
                                    }
                                }
                                break;
                            case "multiple":
                                r.multiple = g && typeof g != "function" && typeof g != "symbol";
                                break;
                            case "muted":
                                r.muted = g && typeof g != "function" && typeof g != "symbol";
                                break;
                            case "suppressContentEditableWarning":
                            case "suppressHydrationWarning":
                            case "defaultValue":
                            case "defaultChecked":
                            case "innerHTML":
                            case "ref":
                                break;
                            case "autoFocus":
                                break;
                            case "xlinkHref":
                                if (g == null || typeof g == "function" || typeof g == "boolean" || typeof g == "symbol") {
                                    r.removeAttribute("xlink:href");
                                    break
                                }
                                p = Dr("" + g),
                                r.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", p);
                                break;
                            case "contentEditable":
                            case "spellCheck":
                            case "draggable":
                            case "value":
                            case "autoReverse":
                            case "externalResourcesRequired":
                            case "focusable":
                            case "preserveAlpha":
                                g != null && typeof g != "function" && typeof g != "symbol" ? r.setAttribute(p, "" + g) : r.removeAttribute(p);
                                break;
                            case "inert":
                            case "allowFullScreen":
                            case "async":
                            case "autoPlay":
                            case "controls":
                            case "default":
                            case "defer":
                            case "disabled":
                            case "disablePictureInPicture":
                            case "disableRemotePlayback":
                            case "formNoValidate":
                            case "hidden":
                            case "loop":
                            case "noModule":
                            case "noValidate":
                            case "open":
                            case "playsInline":
                            case "readOnly":
                            case "required":
                            case "reversed":
                            case "scoped":
                            case "seamless":
                            case "itemScope":
                                g && typeof g != "function" && typeof g != "symbol" ? r.setAttribute(p, "") : r.removeAttribute(p);
                                break;
                            case "capture":
                            case "download":
                                g === !0 ? r.setAttribute(p, "") : g !== !1 && g != null && typeof g != "function" && typeof g != "symbol" ? r.setAttribute(p, g) : r.removeAttribute(p);
                                break;
                            case "cols":
                            case "rows":
                            case "size":
                            case "span":
                                g != null && typeof g != "function" && typeof g != "symbol" && !isNaN(g) && 1 <= g ? r.setAttribute(p, g) : r.removeAttribute(p);
                                break;
                            case "rowSpan":
                            case "start":
                                g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g) ? r.removeAttribute(p) : r.setAttribute(p, g);
                                break;
                            case "popover":
                                yn("beforetoggle", r),
                                yn("toggle", r),
                                dn(r, "popover", g);
                                break;
                            case "xlinkActuate":
                                vn(r, "http://www.w3.org/1999/xlink", "xlink:actuate", g);
                                break;
                            case "xlinkArcrole":
                                vn(r, "http://www.w3.org/1999/xlink", "xlink:arcrole", g);
                                break;
                            case "xlinkRole":
                                vn(r, "http://www.w3.org/1999/xlink", "xlink:role", g);
                                break;
                            case "xlinkShow":
                                vn(r, "http://www.w3.org/1999/xlink", "xlink:show", g);
                                break;
                            case "xlinkTitle":
                                vn(r, "http://www.w3.org/1999/xlink", "xlink:title", g);
                                break;
                            case "xlinkType":
                                vn(r, "http://www.w3.org/1999/xlink", "xlink:type", g);
                                break;
                            case "xmlBase":
                                vn(r, "http://www.w3.org/XML/1998/namespace", "xml:base", g);
                                break;
                            case "xmlLang":
                                vn(r, "http://www.w3.org/XML/1998/namespace", "xml:lang", g);
                                break;
                            case "xmlSpace":
                                vn(r, "http://www.w3.org/XML/1998/namespace", "xml:space", g);
                                break;
                            case "is":
                                dn(r, "is", g);
                                break;
                            case "innerText":
                            case "textContent":
                                break;
                            default:
                                (!(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (p = Bo.get(p) || p,
                                dn(r, p, g))
                            }
                        }
                        function Xx(r, l, p, g, b, C) {
                            switch (p) {
                            case "style":
                                mu(r, g, C);
                                break;
                            case "dangerouslySetInnerHTML":
                                if (g != null) {
                                    if (typeof g != "object" || !("__html"in g))
                                        throw Error(s(61));
                                    if (p = g.__html,
                                    p != null) {
                                        if (b.children != null)
                                            throw Error(s(60));
                                        r.innerHTML = p
                                    }
                                }
                                break;
                            case "children":
                                typeof g == "string" ? io(r, g) : (typeof g == "number" || typeof g == "bigint") && io(r, "" + g);
                                break;
                            case "onScroll":
                                g != null && yn("scroll", r);
                                break;
                            case "onScrollEnd":
                                g != null && yn("scrollend", r);
                                break;
                            case "onClick":
                                g != null && (r.onclick = Ba);
                                break;
                            case "suppressContentEditableWarning":
                            case "suppressHydrationWarning":
                            case "innerHTML":
                            case "ref":
                                break;
                            case "innerText":
                            case "textContent":
                                break;
                            default:
                                if (!Lt.hasOwnProperty(p))
                                    e: {
                                        if (p[0] === "o" && p[1] === "n" && (b = p.endsWith("Capture"),
                                        l = p.slice(2, b ? p.length - 7 : void 0),
                                        C = r[Xi] || null,
                                        C = C != null ? C[p] : null,
                                        typeof C == "function" && r.removeEventListener(l, C, b),
                                        typeof g == "function")) {
                                            typeof C != "function" && C !== null && (p in r ? r[p] = null : r.hasAttribute(p) && r.removeAttribute(p)),
                                            r.addEventListener(l, g, b);
                                            break e
                                        }
                                        p in r ? r[p] = g : g === !0 ? r.setAttribute(p, "") : dn(r, p, g)
                                    }
                            }
                        }
                        function ta(r, l, p) {
                            switch (l) {
                            case "div":
                            case "span":
                            case "svg":
                            case "path":
                            case "a":
                            case "g":
                            case "p":
                            case "li":
                                break;
                            case "img":
                                yn("error", r),
                                yn("load", r);
                                var g = !1, b = !1, C;
                                for (C in p)
                                    if (p.hasOwnProperty(C)) {
                                        var F = p[C];
                                        if (F != null)
                                            switch (C) {
                                            case "src":
                                                g = !0;
                                                break;
                                            case "srcSet":
                                                b = !0;
                                                break;
                                            case "children":
                                            case "dangerouslySetInnerHTML":
                                                throw Error(s(137, l));
                                            default:
                                                si(r, l, C, F, p, null)
                                            }
                                    }
                                b && si(r, l, "srcSet", p.srcSet, p, null),
                                g && si(r, l, "src", p.src, p, null);
                                return;
                            case "input":
                                yn("invalid", r);
                                var J = C = F = b = null
                                  , ve = null
                                  , Pe = null;
                                for (g in p)
                                    if (p.hasOwnProperty(g)) {
                                        var Ke = p[g];
                                        if (Ke != null)
                                            switch (g) {
                                            case "name":
                                                b = Ke;
                                                break;
                                            case "type":
                                                F = Ke;
                                                break;
                                            case "checked":
                                                ve = Ke;
                                                break;
                                            case "defaultChecked":
                                                Pe = Ke;
                                                break;
                                            case "value":
                                                C = Ke;
                                                break;
                                            case "defaultValue":
                                                J = Ke;
                                                break;
                                            case "children":
                                            case "dangerouslySetInnerHTML":
                                                if (Ke != null)
                                                    throw Error(s(137, l));
                                                break;
                                            default:
                                                si(r, l, g, Ke, p, null)
                                            }
                                    }
                                ls(r, C, J, ve, Pe, F, b, !1);
                                return;
                            case "select":
                                yn("invalid", r),
                                g = F = C = null;
                                for (b in p)
                                    if (p.hasOwnProperty(b) && (J = p[b],
                                    J != null))
                                        switch (b) {
                                        case "value":
                                            C = J;
                                            break;
                                        case "defaultValue":
                                            F = J;
                                            break;
                                        case "multiple":
                                            g = J;
                                        default:
                                            si(r, l, b, J, p, null)
                                        }
                                l = C,
                                p = F,
                                r.multiple = !!g,
                                l != null ? $i(r, !!g, l, !1) : p != null && $i(r, !!g, p, !0);
                                return;
                            case "textarea":
                                yn("invalid", r),
                                C = b = g = null;
                                for (F in p)
                                    if (p.hasOwnProperty(F) && (J = p[F],
                                    J != null))
                                        switch (F) {
                                        case "value":
                                            g = J;
                                            break;
                                        case "defaultValue":
                                            b = J;
                                            break;
                                        case "children":
                                            C = J;
                                            break;
                                        case "dangerouslySetInnerHTML":
                                            if (J != null)
                                                throw Error(s(91));
                                            break;
                                        default:
                                            si(r, l, F, J, p, null)
                                        }
                                no(r, g, b, C);
                                return;
                            case "option":
                                for (ve in p)
                                    if (p.hasOwnProperty(ve) && (g = p[ve],
                                    g != null))
                                        switch (ve) {
                                        case "selected":
                                            r.selected = g && typeof g != "function" && typeof g != "symbol";
                                            break;
                                        default:
                                            si(r, l, ve, g, p, null)
                                        }
                                return;
                            case "dialog":
                                yn("beforetoggle", r),
                                yn("toggle", r),
                                yn("cancel", r),
                                yn("close", r);
                                break;
                            case "iframe":
                            case "object":
                                yn("load", r);
                                break;
                            case "video":
                            case "audio":
                                for (g = 0; g < Gv.length; g++)
                                    yn(Gv[g], r);
                                break;
                            case "image":
                                yn("error", r),
                                yn("load", r);
                                break;
                            case "details":
                                yn("toggle", r);
                                break;
                            case "embed":
                            case "source":
                            case "link":
                                yn("error", r),
                                yn("load", r);
                            case "area":
                            case "base":
                            case "br":
                            case "col":
                            case "hr":
                            case "keygen":
                            case "meta":
                            case "param":
                            case "track":
                            case "wbr":
                            case "menuitem":
                                for (Pe in p)
                                    if (p.hasOwnProperty(Pe) && (g = p[Pe],
                                    g != null))
                                        switch (Pe) {
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            throw Error(s(137, l));
                                        default:
                                            si(r, l, Pe, g, p, null)
                                        }
                                return;
                            default:
                                if (so(l)) {
                                    for (Ke in p)
                                        p.hasOwnProperty(Ke) && (g = p[Ke],
                                        g !== void 0 && Xx(r, l, Ke, g, p, void 0));
                                    return
                                }
                            }
                            for (J in p)
                                p.hasOwnProperty(J) && (g = p[J],
                                g != null && si(r, l, J, g, p, null))
                        }
                        function FO(r, l, p, g) {
                            switch (l) {
                            case "div":
                            case "span":
                            case "svg":
                            case "path":
                            case "a":
                            case "g":
                            case "p":
                            case "li":
                                break;
                            case "input":
                                var b = null
                                  , C = null
                                  , F = null
                                  , J = null
                                  , ve = null
                                  , Pe = null
                                  , Ke = null;
                                for (Ye in p) {
                                    var st = p[Ye];
                                    if (p.hasOwnProperty(Ye) && st != null)
                                        switch (Ye) {
                                        case "checked":
                                            break;
                                        case "value":
                                            break;
                                        case "defaultValue":
                                            ve = st;
                                        default:
                                            g.hasOwnProperty(Ye) || si(r, l, Ye, null, g, st)
                                        }
                                }
                                for (var Ve in g) {
                                    var Ye = g[Ve];
                                    if (st = p[Ve],
                                    g.hasOwnProperty(Ve) && (Ye != null || st != null))
                                        switch (Ve) {
                                        case "type":
                                            C = Ye;
                                            break;
                                        case "name":
                                            b = Ye;
                                            break;
                                        case "checked":
                                            Pe = Ye;
                                            break;
                                        case "defaultChecked":
                                            Ke = Ye;
                                            break;
                                        case "value":
                                            F = Ye;
                                            break;
                                        case "defaultValue":
                                            J = Ye;
                                            break;
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            if (Ye != null)
                                                throw Error(s(137, l));
                                            break;
                                        default:
                                            Ye !== st && si(r, l, Ve, Ye, g, st)
                                        }
                                }
                                qn(r, F, J, ve, Pe, Ke, C, b);
                                return;
                            case "select":
                                Ye = F = J = Ve = null;
                                for (C in p)
                                    if (ve = p[C],
                                    p.hasOwnProperty(C) && ve != null)
                                        switch (C) {
                                        case "value":
                                            break;
                                        case "multiple":
                                            Ye = ve;
                                        default:
                                            g.hasOwnProperty(C) || si(r, l, C, null, g, ve)
                                        }
                                for (b in g)
                                    if (C = g[b],
                                    ve = p[b],
                                    g.hasOwnProperty(b) && (C != null || ve != null))
                                        switch (b) {
                                        case "value":
                                            Ve = C;
                                            break;
                                        case "defaultValue":
                                            J = C;
                                            break;
                                        case "multiple":
                                            F = C;
                                        default:
                                            C !== ve && si(r, l, b, C, g, ve)
                                        }
                                l = J,
                                p = F,
                                g = Ye,
                                Ve != null ? $i(r, !!p, Ve, !1) : !!g != !!p && (l != null ? $i(r, !!p, l, !0) : $i(r, !!p, p ? [] : "", !1));
                                return;
                            case "textarea":
                                Ye = Ve = null;
                                for (J in p)
                                    if (b = p[J],
                                    p.hasOwnProperty(J) && b != null && !g.hasOwnProperty(J))
                                        switch (J) {
                                        case "value":
                                            break;
                                        case "children":
                                            break;
                                        default:
                                            si(r, l, J, null, g, b)
                                        }
                                for (F in g)
                                    if (b = g[F],
                                    C = p[F],
                                    g.hasOwnProperty(F) && (b != null || C != null))
                                        switch (F) {
                                        case "value":
                                            Ve = b;
                                            break;
                                        case "defaultValue":
                                            Ye = b;
                                            break;
                                        case "children":
                                            break;
                                        case "dangerouslySetInnerHTML":
                                            if (b != null)
                                                throw Error(s(91));
                                            break;
                                        default:
                                            b !== C && si(r, l, F, b, g, C)
                                        }
                                yc(r, Ve, Ye);
                                return;
                            case "option":
                                for (var wt in p)
                                    if (Ve = p[wt],
                                    p.hasOwnProperty(wt) && Ve != null && !g.hasOwnProperty(wt))
                                        switch (wt) {
                                        case "selected":
                                            r.selected = !1;
                                            break;
                                        default:
                                            si(r, l, wt, null, g, Ve)
                                        }
                                for (ve in g)
                                    if (Ve = g[ve],
                                    Ye = p[ve],
                                    g.hasOwnProperty(ve) && Ve !== Ye && (Ve != null || Ye != null))
                                        switch (ve) {
                                        case "selected":
                                            r.selected = Ve && typeof Ve != "function" && typeof Ve != "symbol";
                                            break;
                                        default:
                                            si(r, l, ve, Ve, g, Ye)
                                        }
                                return;
                            case "img":
                            case "link":
                            case "area":
                            case "base":
                            case "br":
                            case "col":
                            case "embed":
                            case "hr":
                            case "keygen":
                            case "meta":
                            case "param":
                            case "source":
                            case "track":
                            case "wbr":
                            case "menuitem":
                                for (var Gt in p)
                                    Ve = p[Gt],
                                    p.hasOwnProperty(Gt) && Ve != null && !g.hasOwnProperty(Gt) && si(r, l, Gt, null, g, Ve);
                                for (Pe in g)
                                    if (Ve = g[Pe],
                                    Ye = p[Pe],
                                    g.hasOwnProperty(Pe) && Ve !== Ye && (Ve != null || Ye != null))
                                        switch (Pe) {
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            if (Ve != null)
                                                throw Error(s(137, l));
                                            break;
                                        default:
                                            si(r, l, Pe, Ve, g, Ye)
                                        }
                                return;
                            default:
                                if (so(l)) {
                                    for (var ai in p)
                                        Ve = p[ai],
                                        p.hasOwnProperty(ai) && Ve !== void 0 && !g.hasOwnProperty(ai) && Xx(r, l, ai, void 0, g, Ve);
                                    for (Ke in g)
                                        Ve = g[Ke],
                                        Ye = p[Ke],
                                        !g.hasOwnProperty(Ke) || Ve === Ye || Ve === void 0 && Ye === void 0 || Xx(r, l, Ke, Ve, g, Ye);
                                    return
                                }
                            }
                            for (var be in p)
                                Ve = p[be],
                                p.hasOwnProperty(be) && Ve != null && !g.hasOwnProperty(be) && si(r, l, be, null, g, Ve);
                            for (st in g)
                                Ve = g[st],
                                Ye = p[st],
                                !g.hasOwnProperty(st) || Ve === Ye || Ve == null && Ye == null || si(r, l, st, Ve, g, Ye)
                        }
                        function Qb(r) {
                            switch (r) {
                            case "css":
                            case "script":
                            case "font":
                            case "img":
                            case "image":
                            case "input":
                            case "link":
                                return !0;
                            default:
                                return !1
                            }
                        }
                        function HO() {
                            if (typeof performance.getEntriesByType == "function") {
                                for (var r = 0, l = 0, p = performance.getEntriesByType("resource"), g = 0; g < p.length; g++) {
                                    var b = p[g]
                                      , C = b.transferSize
                                      , F = b.initiatorType
                                      , J = b.duration;
                                    if (C && J && Qb(F)) {
                                        for (F = 0,
                                        J = b.responseEnd,
                                        g += 1; g < p.length; g++) {
                                            var ve = p[g]
                                              , Pe = ve.startTime;
                                            if (Pe > J)
                                                break;
                                            var Ke = ve.transferSize
                                              , st = ve.initiatorType;
                                            Ke && Qb(st) && (ve = ve.responseEnd,
                                            F += Ke * (ve < J ? 1 : (J - Pe) / (ve - Pe)))
                                        }
                                        if (--g,
                                        l += 8 * (C + F) / (b.duration / 1e3),
                                        r++,
                                        10 < r)
                                            break
                                    }
                                }
                                if (0 < r)
                                    return l / r / 1e6
                            }
                            return navigator.connection && (r = navigator.connection.downlink,
                            typeof r == "number") ? r : 5
                        }
                        var Wx = null
                          , Yx = null;
                        function xy(r) {
                            return r.nodeType === 9 ? r : r.ownerDocument
                        }
                        function Zb(r) {
                            switch (r) {
                            case "http://www.w3.org/2000/svg":
                                return 1;
                            case "http://www.w3.org/1998/Math/MathML":
                                return 2;
                            default:
                                return 0
                            }
                        }
                        function Kb(r, l) {
                            if (r === 0)
                                switch (l) {
                                case "svg":
                                    return 1;
                                case "math":
                                    return 2;
                                default:
                                    return 0
                                }
                            return r === 1 && l === "foreignObject" ? 0 : r
                        }
                        function qx(r, l) {
                            return r === "textarea" || r === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null
                        }
                        var jx = null;
                        function GO() {
                            var r = window.event;
                            return r && r.type === "popstate" ? r === jx ? !1 : (jx = r,
                            !0) : (jx = null,
                            !1)
                        }
                        var Jb = typeof setTimeout == "function" ? setTimeout : void 0
                          , VO = typeof clearTimeout == "function" ? clearTimeout : void 0
                          , $b = typeof Promise == "function" ? Promise : void 0
                          , kO = typeof queueMicrotask == "function" ? queueMicrotask : typeof $b < "u" ? function(r) {
                            return $b.resolve(null).then(r).catch(XO)
                        }
                        : Jb;
                        function XO(r) {
                            setTimeout(function() {
                                throw r
                            })
                        }
                        function Qu(r) {
                            return r === "head"
                        }
                        function eE(r, l) {
                            var p = l
                              , g = 0;
                            do {
                                var b = p.nextSibling;
                                if (r.removeChild(p),
                                b && b.nodeType === 8)
                                    if (p = b.data,
                                    p === "/$" || p === "/&") {
                                        if (g === 0) {
                                            r.removeChild(b),
                                            lp(l);
                                            return
                                        }
                                        g--
                                    } else if (p === "$" || p === "$?" || p === "$~" || p === "$!" || p === "&")
                                        g++;
                                    else if (p === "html")
                                        kv(r.ownerDocument.documentElement);
                                    else if (p === "head") {
                                        p = r.ownerDocument.head,
                                        kv(p);
                                        for (var C = p.firstChild; C; ) {
                                            var F = C.nextSibling
                                              , J = C.nodeName;
                                            C[Se] || J === "SCRIPT" || J === "STYLE" || J === "LINK" && C.rel.toLowerCase() === "stylesheet" || p.removeChild(C),
                                            C = F
                                        }
                                    } else
                                        p === "body" && kv(r.ownerDocument.body);
                                p = b
                            } while (p);
                            lp(l)
                        }
                        function tE(r, l) {
                            var p = r;
                            r = 0;
                            do {
                                var g = p.nextSibling;
                                if (p.nodeType === 1 ? l ? (p._stashedDisplay = p.style.display,
                                p.style.display = "none") : (p.style.display = p._stashedDisplay || "",
                                p.getAttribute("style") === "" && p.removeAttribute("style")) : p.nodeType === 3 && (l ? (p._stashedText = p.nodeValue,
                                p.nodeValue = "") : p.nodeValue = p._stashedText || ""),
                                g && g.nodeType === 8)
                                    if (p = g.data,
                                    p === "/$") {
                                        if (r === 0)
                                            break;
                                        r--
                                    } else
                                        p !== "$" && p !== "$?" && p !== "$~" && p !== "$!" || r++;
                                p = g
                            } while (p)
                        }
                        function Qx(r) {
                            var l = r.firstChild;
                            for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
                                var p = l;
                                switch (l = l.nextSibling,
                                p.nodeName) {
                                case "HTML":
                                case "HEAD":
                                case "BODY":
                                    Qx(p),
                                    Ge(p);
                                    continue;
                                case "SCRIPT":
                                case "STYLE":
                                    continue;
                                case "LINK":
                                    if (p.rel.toLowerCase() === "stylesheet")
                                        continue
                                }
                                r.removeChild(p)
                            }
                        }
                        function WO(r, l, p, g) {
                            for (; r.nodeType === 1; ) {
                                var b = p;
                                if (r.nodeName.toLowerCase() !== l.toLowerCase()) {
                                    if (!g && (r.nodeName !== "INPUT" || r.type !== "hidden"))
                                        break
                                } else if (g) {
                                    if (!r[Se])
                                        switch (l) {
                                        case "meta":
                                            if (!r.hasAttribute("itemprop"))
                                                break;
                                            return r;
                                        case "link":
                                            if (C = r.getAttribute("rel"),
                                            C === "stylesheet" && r.hasAttribute("data-precedence"))
                                                break;
                                            if (C !== b.rel || r.getAttribute("href") !== (b.href == null || b.href === "" ? null : b.href) || r.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin) || r.getAttribute("title") !== (b.title == null ? null : b.title))
                                                break;
                                            return r;
                                        case "style":
                                            if (r.hasAttribute("data-precedence"))
                                                break;
                                            return r;
                                        case "script":
                                            if (C = r.getAttribute("src"),
                                            (C !== (b.src == null ? null : b.src) || r.getAttribute("type") !== (b.type == null ? null : b.type) || r.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin)) && C && r.hasAttribute("async") && !r.hasAttribute("itemprop"))
                                                break;
                                            return r;
                                        default:
                                            return r
                                        }
                                } else if (l === "input" && r.type === "hidden") {
                                    var C = b.name == null ? null : "" + b.name;
                                    if (b.type === "hidden" && r.getAttribute("name") === C)
                                        return r
                                } else
                                    return r;
                                if (r = To(r.nextSibling),
                                r === null)
                                    break
                            }
                            return null
                        }
                        function YO(r, l, p) {
                            if (l === "")
                                return null;
                            for (; r.nodeType !== 3; )
                                if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !p || (r = To(r.nextSibling),
                                r === null))
                                    return null;
                            return r
                        }
                        function nE(r, l) {
                            for (; r.nodeType !== 8; )
                                if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !l || (r = To(r.nextSibling),
                                r === null))
                                    return null;
                            return r
                        }
                        function Zx(r) {
                            return r.data === "$?" || r.data === "$~"
                        }
                        function Kx(r) {
                            return r.data === "$!" || r.data === "$?" && r.ownerDocument.readyState !== "loading"
                        }
                        function qO(r, l) {
                            var p = r.ownerDocument;
                            if (r.data === "$~")
                                r._reactRetry = l;
                            else if (r.data !== "$?" || p.readyState !== "loading")
                                l();
                            else {
                                var g = function() {
                                    l(),
                                    p.removeEventListener("DOMContentLoaded", g)
                                };
                                p.addEventListener("DOMContentLoaded", g),
                                r._reactRetry = g
                            }
                        }
                        function To(r) {
                            for (; r != null; r = r.nextSibling) {
                                var l = r.nodeType;
                                if (l === 1 || l === 3)
                                    break;
                                if (l === 8) {
                                    if (l = r.data,
                                    l === "$" || l === "$!" || l === "$?" || l === "$~" || l === "&" || l === "F!" || l === "F")
                                        break;
                                    if (l === "/$" || l === "/&")
                                        return null
                                }
                            }
                            return r
                        }
                        var Jx = null;
                        function iE(r) {
                            r = r.nextSibling;
                            for (var l = 0; r; ) {
                                if (r.nodeType === 8) {
                                    var p = r.data;
                                    if (p === "/$" || p === "/&") {
                                        if (l === 0)
                                            return To(r.nextSibling);
                                        l--
                                    } else
                                        p !== "$" && p !== "$!" && p !== "$?" && p !== "$~" && p !== "&" || l++
                                }
                                r = r.nextSibling
                            }
                            return null
                        }
                        function sE(r) {
                            r = r.previousSibling;
                            for (var l = 0; r; ) {
                                if (r.nodeType === 8) {
                                    var p = r.data;
                                    if (p === "$" || p === "$!" || p === "$?" || p === "$~" || p === "&") {
                                        if (l === 0)
                                            return r;
                                        l--
                                    } else
                                        p !== "/$" && p !== "/&" || l++
                                }
                                r = r.previousSibling
                            }
                            return null
                        }
                        function aE(r, l, p) {
                            switch (l = xy(p),
                            r) {
                            case "html":
                                if (r = l.documentElement,
                                !r)
                                    throw Error(s(452));
                                return r;
                            case "head":
                                if (r = l.head,
                                !r)
                                    throw Error(s(453));
                                return r;
                            case "body":
                                if (r = l.body,
                                !r)
                                    throw Error(s(454));
                                return r;
                            default:
                                throw Error(s(451))
                            }
                        }
                        function kv(r) {
                            for (var l = r.attributes; l.length; )
                                r.removeAttributeNode(l[0]);
                            Ge(r)
                        }
                        var Mo = new Map
                          , rE = new Set;
                        function Ay(r) {
                            return typeof r.getRootNode == "function" ? r.getRootNode() : r.nodeType === 9 ? r : r.ownerDocument
                        }
                        var qc = V.d;
                        V.d = {
                            f: jO,
                            r: QO,
                            D: ZO,
                            C: KO,
                            L: JO,
                            m: $O,
                            X: tN,
                            S: eN,
                            M: nN
                        };
                        function jO() {
                            var r = qc.f()
                              , l = ne();
                            return r || l
                        }
                        function QO(r) {
                            var l = ce(r);
                            l !== null && l.tag === 5 && l.type === "form" ? Ov(l) : qc.r(r)
                        }
                        var ap = typeof document > "u" ? null : document;
                        function oE(r, l, p) {
                            var g = ap;
                            if (g && typeof l == "string" && l) {
                                var b = Nn(l);
                                b = 'link[rel="' + r + '"][href="' + b + '"]',
                                typeof p == "string" && (b += '[crossorigin="' + p + '"]'),
                                rE.has(b) || (rE.add(b),
                                r = {
                                    rel: r,
                                    crossOrigin: p,
                                    href: l
                                },
                                g.querySelector(b) === null && (l = g.createElement("link"),
                                ta(l, "link", r),
                                pt(l),
                                g.head.appendChild(l)))
                            }
                        }
                        function ZO(r) {
                            qc.D(r),
                            oE("dns-prefetch", r, null)
                        }
                        function KO(r, l) {
                            qc.C(r, l),
                            oE("preconnect", r, l)
                        }
                        function JO(r, l, p) {
                            qc.L(r, l, p);
                            var g = ap;
                            if (g && r && l) {
                                var b = 'link[rel="preload"][as="' + Nn(l) + '"]';
                                l === "image" && p && p.imageSrcSet ? (b += '[imagesrcset="' + Nn(p.imageSrcSet) + '"]',
                                typeof p.imageSizes == "string" && (b += '[imagesizes="' + Nn(p.imageSizes) + '"]')) : b += '[href="' + Nn(r) + '"]';
                                var C = b;
                                switch (l) {
                                case "style":
                                    C = rp(r);
                                    break;
                                case "script":
                                    C = op(r)
                                }
                                Mo.has(C) || (r = y({
                                    rel: "preload",
                                    href: l === "image" && p && p.imageSrcSet ? void 0 : r,
                                    as: l
                                }, p),
                                Mo.set(C, r),
                                g.querySelector(b) !== null || l === "style" && g.querySelector(Xv(C)) || l === "script" && g.querySelector(Wv(C)) || (l = g.createElement("link"),
                                ta(l, "link", r),
                                pt(l),
                                g.head.appendChild(l)))
                            }
                        }
                        function $O(r, l) {
                            qc.m(r, l);
                            var p = ap;
                            if (p && r) {
                                var g = l && typeof l.as == "string" ? l.as : "script"
                                  , b = 'link[rel="modulepreload"][as="' + Nn(g) + '"][href="' + Nn(r) + '"]'
                                  , C = b;
                                switch (g) {
                                case "audioworklet":
                                case "paintworklet":
                                case "serviceworker":
                                case "sharedworker":
                                case "worker":
                                case "script":
                                    C = op(r)
                                }
                                if (!Mo.has(C) && (r = y({
                                    rel: "modulepreload",
                                    href: r
                                }, l),
                                Mo.set(C, r),
                                p.querySelector(b) === null)) {
                                    switch (g) {
                                    case "audioworklet":
                                    case "paintworklet":
                                    case "serviceworker":
                                    case "sharedworker":
                                    case "worker":
                                    case "script":
                                        if (p.querySelector(Wv(C)))
                                            return
                                    }
                                    g = p.createElement("link"),
                                    ta(g, "link", r),
                                    pt(g),
                                    p.head.appendChild(g)
                                }
                            }
                        }
                        function eN(r, l, p) {
                            qc.S(r, l, p);
                            var g = ap;
                            if (g && r) {
                                var b = yt(g).hoistableStyles
                                  , C = rp(r);
                                l = l || "default";
                                var F = b.get(C);
                                if (!F) {
                                    var J = {
                                        loading: 0,
                                        preload: null
                                    };
                                    if (F = g.querySelector(Xv(C)))
                                        J.loading = 5;
                                    else {
                                        r = y({
                                            rel: "stylesheet",
                                            href: r,
                                            "data-precedence": l
                                        }, p),
                                        (p = Mo.get(C)) && $x(r, p);
                                        var ve = F = g.createElement("link");
                                        pt(ve),
                                        ta(ve, "link", r),
                                        ve._p = new Promise(function(Pe, Ke) {
                                            ve.onload = Pe,
                                            ve.onerror = Ke
                                        }
                                        ),
                                        ve.addEventListener("load", function() {
                                            J.loading |= 1
                                        }),
                                        ve.addEventListener("error", function() {
                                            J.loading |= 2
                                        }),
                                        J.loading |= 4,
                                        Ty(F, l, g)
                                    }
                                    F = {
                                        type: "stylesheet",
                                        instance: F,
                                        count: 1,
                                        state: J
                                    },
                                    b.set(C, F)
                                }
                            }
                        }
                        function tN(r, l) {
                            qc.X(r, l);
                            var p = ap;
                            if (p && r) {
                                var g = yt(p).hoistableScripts
                                  , b = op(r)
                                  , C = g.get(b);
                                C || (C = p.querySelector(Wv(b)),
                                C || (r = y({
                                    src: r,
                                    async: !0
                                }, l),
                                (l = Mo.get(b)) && eA(r, l),
                                C = p.createElement("script"),
                                pt(C),
                                ta(C, "link", r),
                                p.head.appendChild(C)),
                                C = {
                                    type: "script",
                                    instance: C,
                                    count: 1,
                                    state: null
                                },
                                g.set(b, C))
                            }
                        }
                        function nN(r, l) {
                            qc.M(r, l);
                            var p = ap;
                            if (p && r) {
                                var g = yt(p).hoistableScripts
                                  , b = op(r)
                                  , C = g.get(b);
                                C || (C = p.querySelector(Wv(b)),
                                C || (r = y({
                                    src: r,
                                    async: !0,
                                    type: "module"
                                }, l),
                                (l = Mo.get(b)) && eA(r, l),
                                C = p.createElement("script"),
                                pt(C),
                                ta(C, "link", r),
                                p.head.appendChild(C)),
                                C = {
                                    type: "script",
                                    instance: C,
                                    count: 1,
                                    state: null
                                },
                                g.set(b, C))
                            }
                        }
                        function lE(r, l, p, g) {
                            var b = (b = ue.current) ? Ay(b) : null;
                            if (!b)
                                throw Error(s(446));
                            switch (r) {
                            case "meta":
                            case "title":
                                return null;
                            case "style":
                                return typeof p.precedence == "string" && typeof p.href == "string" ? (l = rp(p.href),
                                p = yt(b).hoistableStyles,
                                g = p.get(l),
                                g || (g = {
                                    type: "style",
                                    instance: null,
                                    count: 0,
                                    state: null
                                },
                                p.set(l, g)),
                                g) : {
                                    type: "void",
                                    instance: null,
                                    count: 0,
                                    state: null
                                };
                            case "link":
                                if (p.rel === "stylesheet" && typeof p.href == "string" && typeof p.precedence == "string") {
                                    r = rp(p.href);
                                    var C = yt(b).hoistableStyles
                                      , F = C.get(r);
                                    if (F || (b = b.ownerDocument || b,
                                    F = {
                                        type: "stylesheet",
                                        instance: null,
                                        count: 0,
                                        state: {
                                            loading: 0,
                                            preload: null
                                        }
                                    },
                                    C.set(r, F),
                                    (C = b.querySelector(Xv(r))) && !C._p && (F.instance = C,
                                    F.state.loading = 5),
                                    Mo.has(r) || (p = {
                                        rel: "preload",
                                        as: "style",
                                        href: p.href,
                                        crossOrigin: p.crossOrigin,
                                        integrity: p.integrity,
                                        media: p.media,
                                        hrefLang: p.hrefLang,
                                        referrerPolicy: p.referrerPolicy
                                    },
                                    Mo.set(r, p),
                                    C || iN(b, r, p, F.state))),
                                    l && g === null)
                                        throw Error(s(528, ""));
                                    return F
                                }
                                if (l && g !== null)
                                    throw Error(s(529, ""));
                                return null;
                            case "script":
                                return l = p.async,
                                p = p.src,
                                typeof p == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = op(p),
                                p = yt(b).hoistableScripts,
                                g = p.get(l),
                                g || (g = {
                                    type: "script",
                                    instance: null,
                                    count: 0,
                                    state: null
                                },
                                p.set(l, g)),
                                g) : {
                                    type: "void",
                                    instance: null,
                                    count: 0,
                                    state: null
                                };
                            default:
                                throw Error(s(444, r))
                            }
                        }
                        function rp(r) {
                            return 'href="' + Nn(r) + '"'
                        }
                        function Xv(r) {
                            return 'link[rel="stylesheet"][' + r + "]"
                        }
                        function cE(r) {
                            return y({}, r, {
                                "data-precedence": r.precedence,
                                precedence: null
                            })
                        }
                        function iN(r, l, p, g) {
                            r.querySelector('link[rel="preload"][as="style"][' + l + "]") ? g.loading = 1 : (l = r.createElement("link"),
                            g.preload = l,
                            l.addEventListener("load", function() {
                                return g.loading |= 1
                            }),
                            l.addEventListener("error", function() {
                                return g.loading |= 2
                            }),
                            ta(l, "link", p),
                            pt(l),
                            r.head.appendChild(l))
                        }
                        function op(r) {
                            return '[src="' + Nn(r) + '"]'
                        }
                        function Wv(r) {
                            return "script[async]" + r
                        }
                        function uE(r, l, p) {
                            if (l.count++,
                            l.instance === null)
                                switch (l.type) {
                                case "style":
                                    var g = r.querySelector('style[data-href~="' + Nn(p.href) + '"]');
                                    if (g)
                                        return l.instance = g,
                                        pt(g),
                                        g;
                                    var b = y({}, p, {
                                        "data-href": p.href,
                                        "data-precedence": p.precedence,
                                        href: null,
                                        precedence: null
                                    });
                                    return g = (r.ownerDocument || r).createElement("style"),
                                    pt(g),
                                    ta(g, "style", b),
                                    Ty(g, p.precedence, r),
                                    l.instance = g;
                                case "stylesheet":
                                    b = rp(p.href);
                                    var C = r.querySelector(Xv(b));
                                    if (C)
                                        return l.state.loading |= 4,
                                        l.instance = C,
                                        pt(C),
                                        C;
                                    g = cE(p),
                                    (b = Mo.get(b)) && $x(g, b),
                                    C = (r.ownerDocument || r).createElement("link"),
                                    pt(C);
                                    var F = C;
                                    return F._p = new Promise(function(J, ve) {
                                        F.onload = J,
                                        F.onerror = ve
                                    }
                                    ),
                                    ta(C, "link", g),
                                    l.state.loading |= 4,
                                    Ty(C, p.precedence, r),
                                    l.instance = C;
                                case "script":
                                    return C = op(p.src),
                                    (b = r.querySelector(Wv(C))) ? (l.instance = b,
                                    pt(b),
                                    b) : (g = p,
                                    (b = Mo.get(C)) && (g = y({}, p),
                                    eA(g, b)),
                                    r = r.ownerDocument || r,
                                    b = r.createElement("script"),
                                    pt(b),
                                    ta(b, "link", g),
                                    r.head.appendChild(b),
                                    l.instance = b);
                                case "void":
                                    return null;
                                default:
                                    throw Error(s(443, l.type))
                                }
                            else
                                l.type === "stylesheet" && (l.state.loading & 4) === 0 && (g = l.instance,
                                l.state.loading |= 4,
                                Ty(g, p.precedence, r));
                            return l.instance
                        }
                        function Ty(r, l, p) {
                            for (var g = p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), b = g.length ? g[g.length - 1] : null, C = b, F = 0; F < g.length; F++) {
                                var J = g[F];
                                if (J.dataset.precedence === l)
                                    C = J;
                                else if (C !== b)
                                    break
                            }
                            C ? C.parentNode.insertBefore(r, C.nextSibling) : (l = p.nodeType === 9 ? p.head : p,
                            l.insertBefore(r, l.firstChild))
                        }
                        function $x(r, l) {
                            r.crossOrigin ??= l.crossOrigin,
                            r.referrerPolicy ??= l.referrerPolicy,
                            r.title ??= l.title
                        }
                        function eA(r, l) {
                            r.crossOrigin ??= l.crossOrigin,
                            r.referrerPolicy ??= l.referrerPolicy,
                            r.integrity ??= l.integrity
                        }
                        var My = null;
                        function hE(r, l, p) {
                            if (My === null) {
                                var g = new Map
                                  , b = My = new Map;
                                b.set(p, g)
                            } else
                                b = My,
                                g = b.get(p),
                                g || (g = new Map,
                                b.set(p, g));
                            if (g.has(r))
                                return g;
                            for (g.set(r, null),
                            p = p.getElementsByTagName(r),
                            b = 0; b < p.length; b++) {
                                var C = p[b];
                                if (!(C[Se] || C[Qt] || r === "link" && C.getAttribute("rel") === "stylesheet") && C.namespaceURI !== "http://www.w3.org/2000/svg") {
                                    var F = C.getAttribute(l) || "";
                                    F = r + F;
                                    var J = g.get(F);
                                    J ? J.push(C) : g.set(F, [C])
                                }
                            }
                            return g
                        }
                        function fE(r, l, p) {
                            r = r.ownerDocument || r,
                            r.head.insertBefore(p, l === "title" ? r.querySelector("head > title") : null)
                        }
                        function sN(r, l, p) {
                            if (p === 1 || l.itemProp != null)
                                return !1;
                            switch (r) {
                            case "meta":
                            case "title":
                                return !0;
                            case "style":
                                if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "")
                                    break;
                                return !0;
                            case "link":
                                if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError)
                                    break;
                                switch (l.rel) {
                                case "stylesheet":
                                    return r = l.disabled,
                                    typeof l.precedence == "string" && r == null;
                                default:
                                    return !0
                                }
                            case "script":
                                if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string")
                                    return !0
                            }
                            return !1
                        }
                        function dE(r) {
                            return !(r.type === "stylesheet" && (r.state.loading & 3) === 0)
                        }
                        function aN(r, l, p, g) {
                            if (p.type === "stylesheet" && (typeof g.media != "string" || matchMedia(g.media).matches !== !1) && (p.state.loading & 4) === 0) {
                                if (p.instance === null) {
                                    var b = rp(g.href)
                                      , C = l.querySelector(Xv(b));
                                    if (C) {
                                        l = C._p,
                                        l !== null && typeof l == "object" && typeof l.then == "function" && (r.count++,
                                        r = by.bind(r),
                                        l.then(r, r)),
                                        p.state.loading |= 4,
                                        p.instance = C,
                                        pt(C);
                                        return
                                    }
                                    C = l.ownerDocument || l,
                                    g = cE(g),
                                    (b = Mo.get(b)) && $x(g, b),
                                    C = C.createElement("link"),
                                    pt(C);
                                    var F = C;
                                    F._p = new Promise(function(J, ve) {
                                        F.onload = J,
                                        F.onerror = ve
                                    }
                                    ),
                                    ta(C, "link", g),
                                    p.instance = C
                                }
                                r.stylesheets === null && (r.stylesheets = new Map),
                                r.stylesheets.set(p, l),
                                (l = p.state.preload) && (p.state.loading & 3) === 0 && (r.count++,
                                p = by.bind(r),
                                l.addEventListener("load", p),
                                l.addEventListener("error", p))
                            }
                        }
                        var tA = 0;
                        function rN(r, l) {
                            return r.stylesheets && r.count === 0 && Cy(r, r.stylesheets),
                            0 < r.count || 0 < r.imgCount ? function(p) {
                                var g = setTimeout(function() {
                                    if (r.stylesheets && Cy(r, r.stylesheets),
                                    r.unsuspend) {
                                        var C = r.unsuspend;
                                        r.unsuspend = null,
                                        C()
                                    }
                                }, 6e4 + l);
                                0 < r.imgBytes && tA === 0 && (tA = 62500 * HO());
                                var b = setTimeout(function() {
                                    if (r.waitingForImages = !1,
                                    r.count === 0 && (r.stylesheets && Cy(r, r.stylesheets),
                                    r.unsuspend)) {
                                        var C = r.unsuspend;
                                        r.unsuspend = null,
                                        C()
                                    }
                                }, (r.imgBytes > tA ? 50 : 800) + l);
                                return r.unsuspend = p,
                                function() {
                                    r.unsuspend = null,
                                    clearTimeout(g),
                                    clearTimeout(b)
                                }
                            }
                            : null
                        }
                        function by() {
                            if (this.count--,
                            this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
                                if (this.stylesheets)
                                    Cy(this, this.stylesheets);
                                else if (this.unsuspend) {
                                    var r = this.unsuspend;
                                    this.unsuspend = null,
                                    r()
                                }
                            }
                        }
                        var Ey = null;
                        function Cy(r, l) {
                            r.stylesheets = null,
                            r.unsuspend !== null && (r.count++,
                            Ey = new Map,
                            l.forEach(oN, r),
                            Ey = null,
                            by.call(r))
                        }
                        function oN(r, l) {
                            if (!(l.state.loading & 4)) {
                                var p = Ey.get(r);
                                if (p)
                                    var g = p.get(null);
                                else {
                                    p = new Map,
                                    Ey.set(r, p);
                                    for (var b = r.querySelectorAll("link[data-precedence],style[data-precedence]"), C = 0; C < b.length; C++) {
                                        var F = b[C];
                                        (F.nodeName === "LINK" || F.getAttribute("media") !== "not all") && (p.set(F.dataset.precedence, F),
                                        g = F)
                                    }
                                    g && p.set(null, g)
                                }
                                b = l.instance,
                                F = b.getAttribute("data-precedence"),
                                C = p.get(F) || g,
                                C === g && p.set(null, b),
                                p.set(F, b),
                                this.count++,
                                g = by.bind(this),
                                b.addEventListener("load", g),
                                b.addEventListener("error", g),
                                C ? C.parentNode.insertBefore(b, C.nextSibling) : (r = r.nodeType === 9 ? r.head : r,
                                r.insertBefore(b, r.firstChild)),
                                l.state.loading |= 4
                            }
                        }
                        var Yv = {
                            $$typeof: U,
                            Provider: null,
                            Consumer: null,
                            _currentValue: Z,
                            _currentValue2: Z,
                            _threadCount: 0
                        };
                        function lN(r, l, p, g, b, C, F, J, ve) {
                            this.tag = 1,
                            this.containerInfo = r,
                            this.pingCache = this.current = this.pendingChildren = null,
                            this.timeoutHandle = -1,
                            this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                            this.callbackPriority = 0,
                            this.expirationTimes = Mn(-1),
                            this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                            this.entanglements = Mn(0),
                            this.hiddenUpdates = Mn(null),
                            this.identifierPrefix = g,
                            this.onUncaughtError = b,
                            this.onCaughtError = C,
                            this.onRecoverableError = F,
                            this.pooledCache = null,
                            this.pooledCacheLanes = 0,
                            this.formState = ve,
                            this.incompleteTransitions = new Map
                        }
                        function cN(r, l, p, g, b, C, F, J, ve, Pe, Ke, st) {
                            return r = new lN(r,l,p,F,ve,Pe,Ke,st,J),
                            l = 1,
                            C === !0 && (l |= 24),
                            C = Zs(3, null, null, l),
                            r.current = C,
                            C.stateNode = r,
                            l = ev(),
                            l.refCount++,
                            r.pooledCache = l,
                            l.refCount++,
                            C.memoizedState = {
                                element: g,
                                isDehydrated: p,
                                cache: l
                            },
                            rv(C),
                            r
                        }
                        function uN(r) {
                            return r ? (r = Fl,
                            r) : Fl
                        }
                        function pE(r, l, p, g, b, C) {
                            b = uN(b),
                            g.context === null ? g.context = b : g.pendingContext = b,
                            g = Yo(l),
                            g.payload = {
                                element: p
                            },
                            C = C === void 0 ? null : C,
                            C !== null && (g.callback = C),
                            p = ql(r, g, l),
                            p !== null && (d(p, r, l),
                            jl(p, r, l))
                        }
                        function mE(r, l) {
                            if (r = r.memoizedState,
                            r !== null && r.dehydrated !== null) {
                                var p = r.retryLane;
                                r.retryLane = p !== 0 && p < l ? p : l
                            }
                        }
                        function nA(r, l) {
                            mE(r, l),
                            (r = r.alternate) && mE(r, l)
                        }
                        function vE(r) {
                            if (r.tag === 13 || r.tag === 31) {
                                var l = zl(r, 67108864);
                                l !== null && d(l, r, 67108864),
                                nA(r, 67108864)
                            }
                        }
                        function gE(r) {
                            if (r.tag === 13 || r.tag === 31) {
                                var l = xa();
                                l = Ai(l);
                                var p = zl(r, l);
                                p !== null && d(p, r, l),
                                nA(r, l)
                            }
                        }
                        var wy = !0;
                        function hN(r, l, p, g) {
                            var b = W.T;
                            W.T = null;
                            var C = V.p;
                            try {
                                V.p = 2,
                                iA(r, l, p, g)
                            } finally {
                                V.p = C,
                                W.T = b
                            }
                        }
                        function fN(r, l, p, g) {
                            var b = W.T;
                            W.T = null;
                            var C = V.p;
                            try {
                                V.p = 8,
                                iA(r, l, p, g)
                            } finally {
                                V.p = C,
                                W.T = b
                            }
                        }
                        function iA(r, l, p, g) {
                            if (wy) {
                                var b = sA(g);
                                if (b === null)
                                    kx(r, l, g, Dy, p),
                                    _E(r, g);
                                else if (pN(b, r, l, p, g))
                                    g.stopPropagation();
                                else if (_E(r, g),
                                l & 4 && -1 < dN.indexOf(r)) {
                                    for (; b !== null; ) {
                                        var C = ce(b);
                                        if (C !== null)
                                            switch (C.tag) {
                                            case 3:
                                                if (C = C.stateNode,
                                                C.current.memoizedState.isDehydrated) {
                                                    var F = Ne(C.pendingLanes);
                                                    if (F !== 0) {
                                                        var J = C;
                                                        for (J.pendingLanes |= 2,
                                                        J.entangledLanes |= 2; F; ) {
                                                            var ve = 1 << 31 - lt(F);
                                                            J.entanglements[1] |= ve,
                                                            F &= ~ve
                                                        }
                                                        Yc(C),
                                                        (Sn & 6) === 0 && (Ka = pe() + 500,
                                                        Hv(0, !1))
                                                    }
                                                }
                                                break;
                                            case 31:
                                            case 13:
                                                J = zl(C, 2),
                                                J !== null && d(J, C, 2),
                                                ne(),
                                                nA(C, 2)
                                            }
                                        if (C = sA(g),
                                        C === null && kx(r, l, g, Dy, p),
                                        C === b)
                                            break;
                                        b = C
                                    }
                                    b !== null && g.stopPropagation()
                                } else
                                    kx(r, l, g, null, p)
                            }
                        }
                        function sA(r) {
                            return r = Al(r),
                            aA(r)
                        }
                        var Dy = null;
                        function aA(r) {
                            if (Dy = null,
                            r = Ue(r),
                            r !== null) {
                                var l = o(r);
                                if (l === null)
                                    r = null;
                                else {
                                    var p = l.tag;
                                    if (p === 13) {
                                        if (r = c(l),
                                        r !== null)
                                            return r;
                                        r = null
                                    } else if (p === 31) {
                                        if (r = u(l),
                                        r !== null)
                                            return r;
                                        r = null
                                    } else if (p === 3) {
                                        if (l.stateNode.current.memoizedState.isDehydrated)
                                            return l.tag === 3 ? l.stateNode.containerInfo : null;
                                        r = null
                                    } else
                                        l !== r && (r = null)
                                }
                            }
                            return Dy = r,
                            null
                        }
                        function yE(r) {
                            switch (r) {
                            case "beforetoggle":
                            case "cancel":
                            case "click":
                            case "close":
                            case "contextmenu":
                            case "copy":
                            case "cut":
                            case "auxclick":
                            case "dblclick":
                            case "dragend":
                            case "dragstart":
                            case "drop":
                            case "focusin":
                            case "focusout":
                            case "input":
                            case "invalid":
                            case "keydown":
                            case "keypress":
                            case "keyup":
                            case "mousedown":
                            case "mouseup":
                            case "paste":
                            case "pause":
                            case "play":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointerup":
                            case "ratechange":
                            case "reset":
                            case "resize":
                            case "seeked":
                            case "submit":
                            case "toggle":
                            case "touchcancel":
                            case "touchend":
                            case "touchstart":
                            case "volumechange":
                            case "change":
                            case "selectionchange":
                            case "textInput":
                            case "compositionstart":
                            case "compositionend":
                            case "compositionupdate":
                            case "beforeblur":
                            case "afterblur":
                            case "beforeinput":
                            case "blur":
                            case "fullscreenchange":
                            case "focus":
                            case "hashchange":
                            case "popstate":
                            case "select":
                            case "selectstart":
                                return 2;
                            case "drag":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "mousemove":
                            case "mouseout":
                            case "mouseover":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "scroll":
                            case "touchmove":
                            case "wheel":
                            case "mouseenter":
                            case "mouseleave":
                            case "pointerenter":
                            case "pointerleave":
                                return 8;
                            case "message":
                                switch (He()) {
                                case Re:
                                    return 2;
                                case De:
                                    return 8;
                                case rt:
                                case $e:
                                    return 32;
                                case ct:
                                    return 268435456;
                                default:
                                    return 32
                                }
                            default:
                                return 32
                            }
                        }
                        var rA = !1
                          , Zu = null
                          , Ku = null
                          , Ju = null
                          , qv = new Map
                          , jv = new Map
                          , $u = []
                          , dN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
                        function _E(r, l) {
                            switch (r) {
                            case "focusin":
                            case "focusout":
                                Zu = null;
                                break;
                            case "dragenter":
                            case "dragleave":
                                Ku = null;
                                break;
                            case "mouseover":
                            case "mouseout":
                                Ju = null;
                                break;
                            case "pointerover":
                            case "pointerout":
                                qv.delete(l.pointerId);
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                                jv.delete(l.pointerId)
                            }
                        }
                        function Qv(r, l, p, g, b, C) {
                            return r === null || r.nativeEvent !== C ? (r = {
                                blockedOn: l,
                                domEventName: p,
                                eventSystemFlags: g,
                                nativeEvent: C,
                                targetContainers: [b]
                            },
                            l !== null && (l = ce(l),
                            l !== null && vE(l)),
                            r) : (r.eventSystemFlags |= g,
                            l = r.targetContainers,
                            b !== null && l.indexOf(b) === -1 && l.push(b),
                            r)
                        }
                        function pN(r, l, p, g, b) {
                            switch (l) {
                            case "focusin":
                                return Zu = Qv(Zu, r, l, p, g, b),
                                !0;
                            case "dragenter":
                                return Ku = Qv(Ku, r, l, p, g, b),
                                !0;
                            case "mouseover":
                                return Ju = Qv(Ju, r, l, p, g, b),
                                !0;
                            case "pointerover":
                                var C = b.pointerId;
                                return qv.set(C, Qv(qv.get(C) || null, r, l, p, g, b)),
                                !0;
                            case "gotpointercapture":
                                return C = b.pointerId,
                                jv.set(C, Qv(jv.get(C) || null, r, l, p, g, b)),
                                !0
                            }
                            return !1
                        }
                        function SE(r) {
                            var l = Ue(r.target);
                            if (l !== null) {
                                var p = o(l);
                                if (p !== null) {
                                    if (l = p.tag,
                                    l === 13) {
                                        if (l = c(p),
                                        l !== null) {
                                            r.blockedOn = l,
                                            ti(r.priority, function() {
                                                gE(p)
                                            });
                                            return
                                        }
                                    } else if (l === 31) {
                                        if (l = u(p),
                                        l !== null) {
                                            r.blockedOn = l,
                                            ti(r.priority, function() {
                                                gE(p)
                                            });
                                            return
                                        }
                                    } else if (l === 3 && p.stateNode.current.memoizedState.isDehydrated) {
                                        r.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
                                        return
                                    }
                                }
                            }
                            r.blockedOn = null
                        }
                        function Ry(r) {
                            if (r.blockedOn !== null)
                                return !1;
                            for (var l = r.targetContainers; 0 < l.length; ) {
                                var p = sA(r.nativeEvent);
                                if (p === null) {
                                    p = r.nativeEvent;
                                    var g = new p.constructor(p.type,p);
                                    Rr = g,
                                    p.target.dispatchEvent(g),
                                    Rr = null
                                } else
                                    return l = ce(p),
                                    l !== null && vE(l),
                                    r.blockedOn = p,
                                    !1;
                                l.shift()
                            }
                            return !0
                        }
                        function xE(r, l, p) {
                            Ry(r) && p.delete(l)
                        }
                        function mN() {
                            rA = !1,
                            Zu !== null && Ry(Zu) && (Zu = null),
                            Ku !== null && Ry(Ku) && (Ku = null),
                            Ju !== null && Ry(Ju) && (Ju = null),
                            qv.forEach(xE),
                            jv.forEach(xE)
                        }
                        function Uy(r, l) {
                            r.blockedOn === l && (r.blockedOn = null,
                            rA || (rA = !0,
                            t.unstable_scheduleCallback(t.unstable_NormalPriority, mN)))
                        }
                        var Oy = null;
                        function AE(r) {
                            Oy !== r && (Oy = r,
                            t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
                                Oy === r && (Oy = null);
                                for (var l = 0; l < r.length; l += 3) {
                                    var p = r[l]
                                      , g = r[l + 1]
                                      , b = r[l + 2];
                                    if (typeof g != "function") {
                                        if (aA(g || p) === null)
                                            continue;
                                        break
                                    }
                                    var C = ce(p);
                                    C !== null && (r.splice(l, 3),
                                    l -= 3,
                                    Uv(C, {
                                        pending: !0,
                                        data: b,
                                        method: p.method,
                                        action: g
                                    }, g, b))
                                }
                            }))
                        }
                        function lp(r) {
                            function l(ve) {
                                return Uy(ve, r)
                            }
                            Zu !== null && Uy(Zu, r),
                            Ku !== null && Uy(Ku, r),
                            Ju !== null && Uy(Ju, r),
                            qv.forEach(l),
                            jv.forEach(l);
                            for (var p = 0; p < $u.length; p++) {
                                var g = $u[p];
                                g.blockedOn === r && (g.blockedOn = null)
                            }
                            for (; 0 < $u.length && (p = $u[0],
                            p.blockedOn === null); )
                                SE(p),
                                p.blockedOn === null && $u.shift();
                            if (p = (r.ownerDocument || r).$$reactFormReplay,
                            p != null)
                                for (g = 0; g < p.length; g += 3) {
                                    var b = p[g]
                                      , C = p[g + 1]
                                      , F = b[Xi] || null;
                                    if (typeof C == "function")
                                        F || AE(p);
                                    else if (F) {
                                        var J = null;
                                        if (C && C.hasAttribute("formAction")) {
                                            if (b = C,
                                            F = C[Xi] || null)
                                                J = F.formAction;
                                            else if (aA(b) !== null)
                                                continue
                                        } else
                                            J = F.action;
                                        typeof J == "function" ? p[g + 1] = J : (p.splice(g, 3),
                                        g -= 3),
                                        AE(p)
                                    }
                                }
                        }
                        function vN() {
                            function r(C) {
                                C.canIntercept && C.info === "react-transition" && C.intercept({
                                    handler: function() {
                                        return new Promise(function(F) {
                                            return b = F
                                        }
                                        )
                                    },
                                    focusReset: "manual",
                                    scroll: "manual"
                                })
                            }
                            function l() {
                                b !== null && (b(),
                                b = null),
                                g || setTimeout(p, 20)
                            }
                            function p() {
                                if (!g && !navigation.transition) {
                                    var C = navigation.currentEntry;
                                    C && C.url != null && navigation.navigate(C.url, {
                                        state: C.getState(),
                                        info: "react-transition",
                                        history: "replace"
                                    })
                                }
                            }
                            if (typeof navigation == "object") {
                                var g = !1
                                  , b = null;
                                return navigation.addEventListener("navigate", r),
                                navigation.addEventListener("navigatesuccess", l),
                                navigation.addEventListener("navigateerror", l),
                                setTimeout(p, 100),
                                function() {
                                    g = !0,
                                    navigation.removeEventListener("navigate", r),
                                    navigation.removeEventListener("navigatesuccess", l),
                                    navigation.removeEventListener("navigateerror", l),
                                    b !== null && (b(),
                                    b = null)
                                }
                            }
                        }
                        function oA(r) {
                            this._internalRoot = r
                        }
                        lA.prototype.render = oA.prototype.render = function(r) {
                            var l = this._internalRoot;
                            if (l === null)
                                throw Error(s(409));
                            var p = l.current
                              , g = xa();
                            pE(p, g, r, l, null, null)
                        }
                        ,
                        lA.prototype.unmount = oA.prototype.unmount = function() {
                            var r = this._internalRoot;
                            if (r !== null) {
                                this._internalRoot = null;
                                var l = r.containerInfo;
                                pE(r.current, 2, null, r, null, null),
                                ne(),
                                l[lr] = null
                            }
                        }
                        ;
                        function lA(r) {
                            this._internalRoot = r
                        }
                        lA.prototype.unstable_scheduleHydration = function(r) {
                            if (r) {
                                var l = ei();
                                r = {
                                    blockedOn: null,
                                    target: r,
                                    priority: l
                                };
                                for (var p = 0; p < $u.length && l !== 0 && l < $u[p].priority; p++)
                                    ;
                                $u.splice(p, 0, r),
                                p === 0 && SE(r)
                            }
                        }
                        ;
                        var TE = n.version;
                        if (TE !== "19.2.0")
                            throw Error(s(527, TE, "19.2.0"));
                        V.findDOMNode = function(r) {
                            var l = r._reactInternals;
                            if (l === void 0)
                                throw typeof r.render == "function" ? Error(s(188)) : (r = Object.keys(r).join(","),
                                Error(s(268, r)));
                            return r = m(l),
                            r = r !== null ? v(r) : null,
                            r = r === null ? null : r.stateNode,
                            r
                        }
                        ;
                        var gN = {
                            bundleType: 0,
                            version: "19.2.0",
                            rendererPackageName: "react-dom",
                            currentDispatcherRef: W,
                            reconcilerVersion: "19.2.0"
                        };
                        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
                            var Ny = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                            if (!Ny.isDisabled && Ny.supportsFiber)
                                try {
                                    Je = Ny.inject(gN),
                                    Ze = Ny
                                } catch {}
                        }
                        e.createRoot = function(r, l) {
                            if (!a(r))
                                throw Error(s(299));
                            var p = !1
                              , g = ""
                              , b = fy
                              , C = Lx
                              , F = Lv;
                            return l != null && (l.unstable_strictMode === !0 && (p = !0),
                            l.identifierPrefix !== void 0 && (g = l.identifierPrefix),
                            l.onUncaughtError !== void 0 && (b = l.onUncaughtError),
                            l.onCaughtError !== void 0 && (C = l.onCaughtError),
                            l.onRecoverableError !== void 0 && (F = l.onRecoverableError)),
                            l = cN(r, 1, !1, null, null, p, g, null, b, C, F, vN),
                            r[lr] = l.current,
                            Xb(r),
                            new oA(l)
                        }
                    }
                    )
                })
                  , BN = un({
                    "node_modules/react-dom/client.js": ( (e, t) => {
                        function n() {
                            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                                try {
                                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                                } catch (i) {
                                    console.error(i)
                                }
                        }
                        n(),
                        t.exports = NN()
                    }
                    )
                })
                  , LN = un({
                    "node_modules/react-reconciler/cjs/react-reconciler-constants.production.js": (e => {
                        e.ConcurrentRoot = 1,
                        e.ContinuousEventPriority = 8,
                        e.DefaultEventPriority = 32,
                        e.DiscreteEventPriority = 2
                    }
                    )
                })
                  , DE = un({
                    "node_modules/react-reconciler/constants.js": ( (e, t) => {
                        t.exports = LN()
                    }
                    )
                })
                  , By = _r(DE())
                  , IN = _r(BN())
                  , We = _r(cp(), 1)
                  , Ly = _r(wE());
                const jc = "180"
                  , PN = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                }
                  , zN = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                }
                  , RE = 0
                  , hA = 1
                  , UE = 2
                  , FN = 3
                  , OE = 0
                  , Iy = 1
                  , Zv = 2
                  , sl = 3
                  , ic = 0
                  , Ds = 1
                  , $a = 2
                  , pi = 0
                  , uf = 1
                  , fA = 2
                  , dA = 3
                  , pA = 4
                  , NE = 5
                  , th = 100
                  , BE = 101
                  , LE = 102
                  , IE = 103
                  , PE = 104
                  , zE = 200
                  , FE = 201
                  , HE = 202
                  , GE = 203
                  , Py = 204
                  , zy = 205
                  , VE = 206
                  , kE = 207
                  , XE = 208
                  , WE = 209
                  , YE = 210
                  , qE = 211
                  , jE = 212
                  , QE = 213
                  , ZE = 214
                  , Kv = 0
                  , Jv = 1
                  , up = 2
                  , nh = 3
                  , hf = 4
                  , $v = 5
                  , eg = 6
                  , hp = 7
                  , tg = 0
                  , KE = 1
                  , JE = 2
                  , al = 0
                  , $E = 1
                  , eC = 2
                  , tC = 3
                  , mA = 4
                  , nC = 5
                  , iC = 6
                  , sC = 7
                  , vA = "attached"
                  , aC = "detached"
                  , Fy = 300
                  , Qc = 301
                  , ih = 302
                  , fp = 303
                  , ng = 304
                  , dp = 306
                  , sh = 1e3
                  , bo = 1001
                  , ig = 1002
                  , ri = 1003
                  , gA = 1004
                  , HN = 1004
                  , pp = 1005
                  , GN = 1005
                  , mi = 1006
                  , sg = 1007
                  , VN = 1007
                  , sc = 1008
                  , kN = 1008
                  , gi = 1009
                  , yA = 1010
                  , _A = 1011
                  , mp = 1012
                  , Hy = 1013
                  , ac = 1014
                  , na = 1015
                  , ff = 1016
                  , Gy = 1017
                  , Vy = 1018
                  , df = 1020
                  , SA = 35902
                  , xA = 35899
                  , AA = 1021
                  , TA = 1022
                  , ps = 1023
                  , vp = 1026
                  , pf = 1027
                  , gp = 1028
                  , ag = 1029
                  , ky = 1030
                  , Xy = 1031
                  , XN = 1032
                  , Wy = 1033
                  , rg = 33776
                  , og = 33777
                  , lg = 33778
                  , cg = 33779
                  , Yy = 35840
                  , qy = 35841
                  , jy = 35842
                  , Qy = 35843
                  , Zy = 36196
                  , Ky = 37492
                  , Jy = 37496
                  , $y = 37808
                  , e_ = 37809
                  , t_ = 37810
                  , n_ = 37811
                  , i_ = 37812
                  , s_ = 37813
                  , a_ = 37814
                  , r_ = 37815
                  , o_ = 37816
                  , l_ = 37817
                  , c_ = 37818
                  , u_ = 37819
                  , h_ = 37820
                  , f_ = 37821
                  , d_ = 36492
                  , p_ = 36494
                  , m_ = 36495
                  , v_ = 36283
                  , g_ = 36284
                  , y_ = 36285
                  , __ = 36286
                  , rC = 2200
                  , oC = 2201
                  , lC = 2202
                  , ug = 2300
                  , S_ = 2301
                  , x_ = 2302
                  , mf = 2400
                  , vf = 2401
                  , hg = 2402
                  , A_ = 2500
                  , MA = 2501
                  , WN = 0
                  , YN = 1
                  , qN = 2
                  , as = 3200
                  , Eo = 3201
                  , jN = 3202
                  , QN = 3203
                  , ah = 0
                  , cC = 1
                  , rl = ""
                  , Zt = "srgb"
                  , rc = "srgb-linear"
                  , fg = "linear"
                  , Jn = "srgb"
                  , ZN = 0
                  , gf = 7680
                  , KN = 7681
                  , JN = 7682
                  , $N = 7683
                  , eB = 34055
                  , tB = 34056
                  , nB = 5386
                  , iB = 512
                  , sB = 513
                  , aB = 514
                  , rB = 515
                  , oB = 516
                  , lB = 517
                  , cB = 518
                  , bA = 519
                  , uC = 512
                  , hC = 513
                  , fC = 514
                  , EA = 515
                  , dC = 516
                  , pC = 517
                  , mC = 518
                  , vC = 519
                  , dg = 35044
                  , uB = 35048
                  , hB = 35040
                  , fB = 35045
                  , dB = 35049
                  , pB = 35041
                  , mB = 35046
                  , vB = 35050
                  , gB = 35042
                  , yB = "100"
                  , CA = "300 es"
                  , Yr = 2e3
                  , yp = 2001
                  , _B = {
                    COMPUTE: "compute",
                    RENDER: "render"
                }
                  , SB = {
                    PERSPECTIVE: "perspective",
                    LINEAR: "linear",
                    FLAT: "flat"
                }
                  , xB = {
                    NORMAL: "normal",
                    CENTROID: "centroid",
                    SAMPLE: "sample",
                    FIRST: "first",
                    EITHER: "either"
                };
                var qr = class {
                    addEventListener(e, t) {
                        this._listeners === void 0 && (this._listeners = {});
                        const n = this._listeners;
                        n[e] === void 0 && (n[e] = []),
                        n[e].indexOf(t) === -1 && n[e].push(t)
                    }
                    hasEventListener(e, t) {
                        const n = this._listeners;
                        return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
                    }
                    removeEventListener(e, t) {
                        const n = this._listeners;
                        if (n === void 0)
                            return;
                        const i = n[e];
                        if (i !== void 0) {
                            const s = i.indexOf(t);
                            s !== -1 && i.splice(s, 1)
                        }
                    }
                    dispatchEvent(e) {
                        const t = this._listeners;
                        if (t === void 0)
                            return;
                        const n = t[e.type];
                        if (n !== void 0) {
                            e.target = this;
                            const i = n.slice(0);
                            for (let s = 0, a = i.length; s < a; s++)
                                i[s].call(this, e);
                            e.target = null
                        }
                    }
                }
                ;
                const Ta = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                let gC = 1234567;
                const yf = Math.PI / 180
                  , _p = 180 / Math.PI;
                function jr() {
                    const e = Math.random() * 4294967295 | 0
                      , t = Math.random() * 4294967295 | 0
                      , n = Math.random() * 4294967295 | 0
                      , i = Math.random() * 4294967295 | 0;
                    return (Ta[e & 255] + Ta[e >> 8 & 255] + Ta[e >> 16 & 255] + Ta[e >> 24 & 255] + "-" + Ta[t & 255] + Ta[t >> 8 & 255] + "-" + Ta[t >> 16 & 15 | 64] + Ta[t >> 24 & 255] + "-" + Ta[n & 63 | 128] + Ta[n >> 8 & 255] + "-" + Ta[n >> 16 & 255] + Ta[n >> 24 & 255] + Ta[i & 255] + Ta[i >> 8 & 255] + Ta[i >> 16 & 255] + Ta[i >> 24 & 255]).toLowerCase()
                }
                function Yt(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                }
                function wA(e, t) {
                    return (e % t + t) % t
                }
                function AB(e, t, n, i, s) {
                    return i + (e - t) * (s - i) / (n - t)
                }
                function TB(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                }
                function pg(e, t, n) {
                    return (1 - n) * e + n * t
                }
                function MB(e, t, n, i) {
                    return pg(e, t, 1 - Math.exp(-n * i))
                }
                function bB(e, t=1) {
                    return t - Math.abs(wA(e, t * 2) - t)
                }
                function EB(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t),
                    e * e * (3 - 2 * e))
                }
                function CB(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t),
                    e * e * e * (e * (e * 6 - 15) + 10))
                }
                function wB(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                }
                function DB(e, t) {
                    return e + Math.random() * (t - e)
                }
                function RB(e) {
                    return e * (.5 - Math.random())
                }
                function UB(e) {
                    e !== void 0 && (gC = e);
                    let t = gC += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, t | 1),
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61),
                    ((t ^ t >>> 14) >>> 0) / 4294967296
                }
                function OB(e) {
                    return e * yf
                }
                function NB(e) {
                    return e * _p
                }
                function BB(e) {
                    return (e & e - 1) === 0 && e !== 0
                }
                function LB(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                }
                function IB(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                }
                function PB(e, t, n, i, s) {
                    const a = Math.cos
                      , o = Math.sin
                      , c = a(n / 2)
                      , u = o(n / 2)
                      , f = a((t + i) / 2)
                      , m = o((t + i) / 2)
                      , v = a((t - i) / 2)
                      , y = o((t - i) / 2)
                      , S = a((i - t) / 2)
                      , A = o((i - t) / 2);
                    switch (s) {
                    case "XYX":
                        e.set(c * m, u * v, u * y, c * f);
                        break;
                    case "YZY":
                        e.set(u * y, c * m, u * v, c * f);
                        break;
                    case "ZXZ":
                        e.set(u * v, u * y, c * m, c * f);
                        break;
                    case "XZX":
                        e.set(c * m, u * A, u * S, c * f);
                        break;
                    case "YXY":
                        e.set(u * S, c * m, u * A, c * f);
                        break;
                    case "ZYZ":
                        e.set(u * A, u * S, c * m, c * f);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s)
                    }
                }
                function er(e, t) {
                    switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return e / 4294967295;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int32Array:
                        return Math.max(e / 2147483647, -1);
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                function tn(e, t) {
                    switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return Math.round(e * 4294967295);
                    case Uint16Array:
                        return Math.round(e * 65535);
                    case Uint8Array:
                        return Math.round(e * 255);
                    case Int32Array:
                        return Math.round(e * 2147483647);
                    case Int16Array:
                        return Math.round(e * 32767);
                    case Int8Array:
                        return Math.round(e * 127);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                const zB = {
                    DEG2RAD: yf,
                    RAD2DEG: _p,
                    generateUUID: jr,
                    clamp: Yt,
                    euclideanModulo: wA,
                    mapLinear: AB,
                    inverseLerp: TB,
                    lerp: pg,
                    damp: MB,
                    pingpong: bB,
                    smoothstep: EB,
                    smootherstep: CB,
                    randInt: wB,
                    randFloat: DB,
                    randFloatSpread: RB,
                    seededRandom: UB,
                    degToRad: OB,
                    radToDeg: NB,
                    isPowerOfTwo: BB,
                    ceilPowerOfTwo: LB,
                    floorPowerOfTwo: IB,
                    setQuaternionFromProperEuler: PB,
                    normalize: tn,
                    denormalize: er
                };
                var Oe = class rU {
                    constructor(t=0, n=0) {
                        rU.prototype.isVector2 = !0,
                        this.x = t,
                        this.y = n
                    }
                    get width() {
                        return this.x
                    }
                    set width(t) {
                        this.x = t
                    }
                    get height() {
                        return this.y
                    }
                    set height(t) {
                        this.y = t
                    }
                    set(t, n) {
                        return this.x = t,
                        this.y = n,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    applyMatrix3(t) {
                        const n = this.x
                          , i = this.y
                          , s = t.elements;
                        return this.x = s[0] * n + s[3] * i + s[6],
                        this.y = s[1] * n + s[4] * i + s[7],
                        this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this
                    }
                    clamp(t, n) {
                        return this.x = Yt(this.x, t.x, n.x),
                        this.y = Yt(this.y, t.y, n.y),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = Yt(this.x, t, n),
                        this.y = Yt(this.y, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Yt(i, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    angleTo(t) {
                        const n = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const i = this.dot(t) / n;
                        return Math.acos(Yt(i, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const n = this.x - t.x
                          , i = this.y - t.y;
                        return n * n + i * i
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this
                    }
                    lerpVectors(t, n, i) {
                        return this.x = t.x + (n.x - t.x) * i,
                        this.y = t.y + (n.y - t.y) * i,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this
                    }
                    rotateAround(t, n) {
                        const i = Math.cos(n)
                          , s = Math.sin(n)
                          , a = this.x - t.x
                          , o = this.y - t.y;
                        return this.x = a * i - o * s + t.x,
                        this.y = a * s + o * i + t.y,
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y
                    }
                }
                  , ia = class {
                    constructor(e=0, t=0, n=0, i=1) {
                        this.isQuaternion = !0,
                        this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = i
                    }
                    static slerpFlat(e, t, n, i, s, a, o) {
                        let c = n[i + 0]
                          , u = n[i + 1]
                          , f = n[i + 2]
                          , m = n[i + 3];
                        const v = s[a + 0]
                          , y = s[a + 1]
                          , S = s[a + 2]
                          , A = s[a + 3];
                        if (o === 0) {
                            e[t + 0] = c,
                            e[t + 1] = u,
                            e[t + 2] = f,
                            e[t + 3] = m;
                            return
                        }
                        if (o === 1) {
                            e[t + 0] = v,
                            e[t + 1] = y,
                            e[t + 2] = S,
                            e[t + 3] = A;
                            return
                        }
                        if (m !== A || c !== v || u !== y || f !== S) {
                            let M = 1 - o;
                            const x = c * v + u * y + f * S + m * A
                              , T = x >= 0 ? 1 : -1
                              , D = 1 - x * x;
                            if (D > Number.EPSILON) {
                                const U = Math.sqrt(D)
                                  , O = Math.atan2(U, x * T);
                                M = Math.sin(M * O) / U,
                                o = Math.sin(o * O) / U
                            }
                            const w = o * T;
                            if (c = c * M + v * w,
                            u = u * M + y * w,
                            f = f * M + S * w,
                            m = m * M + A * w,
                            M === 1 - o) {
                                const U = 1 / Math.sqrt(c * c + u * u + f * f + m * m);
                                c *= U,
                                u *= U,
                                f *= U,
                                m *= U
                            }
                        }
                        e[t] = c,
                        e[t + 1] = u,
                        e[t + 2] = f,
                        e[t + 3] = m
                    }
                    static multiplyQuaternionsFlat(e, t, n, i, s, a) {
                        const o = n[i]
                          , c = n[i + 1]
                          , u = n[i + 2]
                          , f = n[i + 3]
                          , m = s[a]
                          , v = s[a + 1]
                          , y = s[a + 2]
                          , S = s[a + 3];
                        return e[t] = o * S + f * m + c * y - u * v,
                        e[t + 1] = c * S + f * v + u * m - o * y,
                        e[t + 2] = u * S + f * y + o * v - c * m,
                        e[t + 3] = f * S - o * m - c * v - u * y,
                        e
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x = e,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y = e,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(e) {
                        this._z = e,
                        this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(e) {
                        this._w = e,
                        this._onChangeCallback()
                    }
                    set(e, t, n, i) {
                        return this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = i,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._w)
                    }
                    copy(e) {
                        return this._x = e.x,
                        this._y = e.y,
                        this._z = e.z,
                        this._w = e.w,
                        this._onChangeCallback(),
                        this
                    }
                    setFromEuler(e, t=!0) {
                        const n = e._x
                          , i = e._y
                          , s = e._z
                          , a = e._order
                          , o = Math.cos
                          , c = Math.sin
                          , u = o(n / 2)
                          , f = o(i / 2)
                          , m = o(s / 2)
                          , v = c(n / 2)
                          , y = c(i / 2)
                          , S = c(s / 2);
                        switch (a) {
                        case "XYZ":
                            this._x = v * f * m + u * y * S,
                            this._y = u * y * m - v * f * S,
                            this._z = u * f * S + v * y * m,
                            this._w = u * f * m - v * y * S;
                            break;
                        case "YXZ":
                            this._x = v * f * m + u * y * S,
                            this._y = u * y * m - v * f * S,
                            this._z = u * f * S - v * y * m,
                            this._w = u * f * m + v * y * S;
                            break;
                        case "ZXY":
                            this._x = v * f * m - u * y * S,
                            this._y = u * y * m + v * f * S,
                            this._z = u * f * S + v * y * m,
                            this._w = u * f * m - v * y * S;
                            break;
                        case "ZYX":
                            this._x = v * f * m - u * y * S,
                            this._y = u * y * m + v * f * S,
                            this._z = u * f * S - v * y * m,
                            this._w = u * f * m + v * y * S;
                            break;
                        case "YZX":
                            this._x = v * f * m + u * y * S,
                            this._y = u * y * m + v * f * S,
                            this._z = u * f * S - v * y * m,
                            this._w = u * f * m - v * y * S;
                            break;
                        case "XZY":
                            this._x = v * f * m - u * y * S,
                            this._y = u * y * m - v * f * S,
                            this._z = u * f * S + v * y * m,
                            this._w = u * f * m + v * y * S;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                        }
                        return t === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromAxisAngle(e, t) {
                        const n = t / 2
                          , i = Math.sin(n);
                        return this._x = e.x * i,
                        this._y = e.y * i,
                        this._z = e.z * i,
                        this._w = Math.cos(n),
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(e) {
                        const t = e.elements
                          , n = t[0]
                          , i = t[4]
                          , s = t[8]
                          , a = t[1]
                          , o = t[5]
                          , c = t[9]
                          , u = t[2]
                          , f = t[6]
                          , m = t[10]
                          , v = n + o + m;
                        if (v > 0) {
                            const y = .5 / Math.sqrt(v + 1);
                            this._w = .25 / y,
                            this._x = (f - c) * y,
                            this._y = (s - u) * y,
                            this._z = (a - i) * y
                        } else if (n > o && n > m) {
                            const y = 2 * Math.sqrt(1 + n - o - m);
                            this._w = (f - c) / y,
                            this._x = .25 * y,
                            this._y = (i + a) / y,
                            this._z = (s + u) / y
                        } else if (o > m) {
                            const y = 2 * Math.sqrt(1 + o - n - m);
                            this._w = (s - u) / y,
                            this._x = (i + a) / y,
                            this._y = .25 * y,
                            this._z = (c + f) / y
                        } else {
                            const y = 2 * Math.sqrt(1 + m - n - o);
                            this._w = (a - i) / y,
                            this._x = (s + u) / y,
                            this._y = (c + f) / y,
                            this._z = .25 * y
                        }
                        return this._onChangeCallback(),
                        this
                    }
                    setFromUnitVectors(e, t) {
                        let n = e.dot(t) + 1;
                        return n < 1e-8 ? (n = 0,
                        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                        this._y = e.x,
                        this._z = 0,
                        this._w = n) : (this._x = 0,
                        this._y = -e.z,
                        this._z = e.y,
                        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                        this._y = e.z * t.x - e.x * t.z,
                        this._z = e.x * t.y - e.y * t.x,
                        this._w = n),
                        this.normalize()
                    }
                    angleTo(e) {
                        return 2 * Math.acos(Math.abs(Yt(this.dot(e), -1, 1)))
                    }
                    rotateTowards(e, t) {
                        const n = this.angleTo(e);
                        if (n === 0)
                            return this;
                        const i = Math.min(1, t / n);
                        return this.slerp(e, i),
                        this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this._onChangeCallback(),
                        this
                    }
                    dot(e) {
                        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let e = this.length();
                        return e === 0 ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (e = 1 / e,
                        this._x = this._x * e,
                        this._y = this._y * e,
                        this._z = this._z * e,
                        this._w = this._w * e),
                        this._onChangeCallback(),
                        this
                    }
                    multiply(e) {
                        return this.multiplyQuaternions(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyQuaternions(e, this)
                    }
                    multiplyQuaternions(e, t) {
                        const n = e._x
                          , i = e._y
                          , s = e._z
                          , a = e._w
                          , o = t._x
                          , c = t._y
                          , u = t._z
                          , f = t._w;
                        return this._x = n * f + a * o + i * u - s * c,
                        this._y = i * f + a * c + s * o - n * u,
                        this._z = s * f + a * u + n * c - i * o,
                        this._w = a * f - n * o - i * c - s * u,
                        this._onChangeCallback(),
                        this
                    }
                    slerp(e, t) {
                        if (t === 0)
                            return this;
                        if (t === 1)
                            return this.copy(e);
                        const n = this._x
                          , i = this._y
                          , s = this._z
                          , a = this._w;
                        let o = a * e._w + n * e._x + i * e._y + s * e._z;
                        if (o < 0 ? (this._w = -e._w,
                        this._x = -e._x,
                        this._y = -e._y,
                        this._z = -e._z,
                        o = -o) : this.copy(e),
                        o >= 1)
                            return this._w = a,
                            this._x = n,
                            this._y = i,
                            this._z = s,
                            this;
                        const c = 1 - o * o;
                        if (c <= Number.EPSILON) {
                            const y = 1 - t;
                            return this._w = y * a + t * this._w,
                            this._x = y * n + t * this._x,
                            this._y = y * i + t * this._y,
                            this._z = y * s + t * this._z,
                            this.normalize(),
                            this
                        }
                        const u = Math.sqrt(c)
                          , f = Math.atan2(u, o)
                          , m = Math.sin((1 - t) * f) / u
                          , v = Math.sin(t * f) / u;
                        return this._w = a * m + this._w * v,
                        this._x = n * m + this._x * v,
                        this._y = i * m + this._y * v,
                        this._z = s * m + this._z * v,
                        this._onChangeCallback(),
                        this
                    }
                    slerpQuaternions(e, t, n) {
                        return this.copy(e).slerp(t, n)
                    }
                    random() {
                        const e = 2 * Math.PI * Math.random()
                          , t = 2 * Math.PI * Math.random()
                          , n = Math.random()
                          , i = Math.sqrt(1 - n)
                          , s = Math.sqrt(n);
                        return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
                    }
                    equals(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                    }
                    fromArray(e, t=0) {
                        return this._x = e[t],
                        this._y = e[t + 1],
                        this._z = e[t + 2],
                        this._w = e[t + 3],
                        this._onChangeCallback(),
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this._x,
                        e[t + 1] = this._y,
                        e[t + 2] = this._z,
                        e[t + 3] = this._w,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this._x = e.getX(t),
                        this._y = e.getY(t),
                        this._z = e.getZ(t),
                        this._w = e.getW(t),
                        this._onChangeCallback(),
                        this
                    }
                    toJSON() {
                        return this.toArray()
                    }
                    _onChange(e) {
                        return this._onChangeCallback = e,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._w
                    }
                }
                  , ae = class oU {
                    constructor(t=0, n=0, i=0) {
                        oU.prototype.isVector3 = !0,
                        this.x = t,
                        this.y = n,
                        this.z = i
                    }
                    set(t, n, i) {
                        return i === void 0 && (i = this.z),
                        this.x = t,
                        this.y = n,
                        this.z = i,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setZ(t) {
                        return this.z = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this.z = t.z + n.z,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this.z += t.z * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this.z = t.z - n.z,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this
                    }
                    multiplyVectors(t, n) {
                        return this.x = t.x * n.x,
                        this.y = t.y * n.y,
                        this.z = t.z * n.z,
                        this
                    }
                    applyEuler(t) {
                        return this.applyQuaternion(yC.setFromEuler(t))
                    }
                    applyAxisAngle(t, n) {
                        return this.applyQuaternion(yC.setFromAxisAngle(t, n))
                    }
                    applyMatrix3(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , a = t.elements;
                        return this.x = a[0] * n + a[3] * i + a[6] * s,
                        this.y = a[1] * n + a[4] * i + a[7] * s,
                        this.z = a[2] * n + a[5] * i + a[8] * s,
                        this
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                    applyMatrix4(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , a = t.elements
                          , o = 1 / (a[3] * n + a[7] * i + a[11] * s + a[15]);
                        return this.x = (a[0] * n + a[4] * i + a[8] * s + a[12]) * o,
                        this.y = (a[1] * n + a[5] * i + a[9] * s + a[13]) * o,
                        this.z = (a[2] * n + a[6] * i + a[10] * s + a[14]) * o,
                        this
                    }
                    applyQuaternion(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , a = t.x
                          , o = t.y
                          , c = t.z
                          , u = t.w
                          , f = 2 * (o * s - c * i)
                          , m = 2 * (c * n - a * s)
                          , v = 2 * (a * i - o * n);
                        return this.x = n + u * f + o * v - c * m,
                        this.y = i + u * m + c * f - a * v,
                        this.z = s + u * v + a * m - o * f,
                        this
                    }
                    project(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                    unproject(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                    transformDirection(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , a = t.elements;
                        return this.x = a[0] * n + a[4] * i + a[8] * s,
                        this.y = a[1] * n + a[5] * i + a[9] * s,
                        this.z = a[2] * n + a[6] * i + a[10] * s,
                        this.normalize()
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this
                    }
                    clamp(t, n) {
                        return this.x = Yt(this.x, t.x, n.x),
                        this.y = Yt(this.y, t.y, n.y),
                        this.z = Yt(this.z, t.z, n.z),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = Yt(this.x, t, n),
                        this.y = Yt(this.y, t, n),
                        this.z = Yt(this.z, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Yt(i, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this.z += (t.z - this.z) * n,
                        this
                    }
                    lerpVectors(t, n, i) {
                        return this.x = t.x + (n.x - t.x) * i,
                        this.y = t.y + (n.y - t.y) * i,
                        this.z = t.z + (n.z - t.z) * i,
                        this
                    }
                    cross(t) {
                        return this.crossVectors(this, t)
                    }
                    crossVectors(t, n) {
                        const i = t.x
                          , s = t.y
                          , a = t.z
                          , o = n.x
                          , c = n.y
                          , u = n.z;
                        return this.x = s * u - a * c,
                        this.y = a * o - i * u,
                        this.z = i * c - s * o,
                        this
                    }
                    projectOnVector(t) {
                        const n = t.lengthSq();
                        if (n === 0)
                            return this.set(0, 0, 0);
                        const i = t.dot(this) / n;
                        return this.copy(t).multiplyScalar(i)
                    }
                    projectOnPlane(t) {
                        return DA.copy(this).projectOnVector(t),
                        this.sub(DA)
                    }
                    reflect(t) {
                        return this.sub(DA.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                    angleTo(t) {
                        const n = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const i = this.dot(t) / n;
                        return Math.acos(Yt(i, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const n = this.x - t.x
                          , i = this.y - t.y
                          , s = this.z - t.z;
                        return n * n + i * i + s * s
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                    setFromSphericalCoords(t, n, i) {
                        const s = Math.sin(n) * t;
                        return this.x = s * Math.sin(i),
                        this.y = Math.cos(n) * t,
                        this.z = s * Math.cos(i),
                        this
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                    setFromCylindricalCoords(t, n, i) {
                        return this.x = t * Math.sin(n),
                        this.y = i,
                        this.z = t * Math.cos(n),
                        this
                    }
                    setFromMatrixPosition(t) {
                        const n = t.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this
                    }
                    setFromMatrixScale(t) {
                        const n = this.setFromMatrixColumn(t, 0).length()
                          , i = this.setFromMatrixColumn(t, 1).length()
                          , s = this.setFromMatrixColumn(t, 2).length();
                        return this.x = n,
                        this.y = i,
                        this.z = s,
                        this
                    }
                    setFromMatrixColumn(t, n) {
                        return this.fromArray(t.elements, n * 4)
                    }
                    setFromMatrix3Column(t, n) {
                        return this.fromArray(t.elements, n * 3)
                    }
                    setFromEuler(t) {
                        return this.x = t._x,
                        this.y = t._y,
                        this.z = t._z,
                        this
                    }
                    setFromColor(t) {
                        return this.x = t.r,
                        this.y = t.g,
                        this.z = t.b,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this.z = t[n + 2],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t[n + 2] = this.z,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this.z = t.getZ(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this
                    }
                    randomDirection() {
                        const t = Math.random() * Math.PI * 2
                          , n = Math.random() * 2 - 1
                          , i = Math.sqrt(1 - n * n);
                        return this.x = i * Math.cos(t),
                        this.y = n,
                        this.z = i * Math.sin(t),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z
                    }
                }
                ;
                const DA = new ae
                  , yC = new ia;
                var nn = class lU {
                    constructor(t, n, i, s, a, o, c, u, f) {
                        lU.prototype.isMatrix3 = !0,
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        t !== void 0 && this.set(t, n, i, s, a, o, c, u, f)
                    }
                    set(t, n, i, s, a, o, c, u, f) {
                        const m = this.elements;
                        return m[0] = t,
                        m[1] = s,
                        m[2] = c,
                        m[3] = n,
                        m[4] = a,
                        m[5] = u,
                        m[6] = i,
                        m[7] = o,
                        m[8] = f,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                    }
                    copy(t) {
                        const n = this.elements
                          , i = t.elements;
                        return n[0] = i[0],
                        n[1] = i[1],
                        n[2] = i[2],
                        n[3] = i[3],
                        n[4] = i[4],
                        n[5] = i[5],
                        n[6] = i[6],
                        n[7] = i[7],
                        n[8] = i[8],
                        this
                    }
                    extractBasis(t, n, i) {
                        return t.setFromMatrix3Column(this, 0),
                        n.setFromMatrix3Column(this, 1),
                        i.setFromMatrix3Column(this, 2),
                        this
                    }
                    setFromMatrix4(t) {
                        const n = t.elements;
                        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]),
                        this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, n) {
                        const i = t.elements
                          , s = n.elements
                          , a = this.elements
                          , o = i[0]
                          , c = i[3]
                          , u = i[6]
                          , f = i[1]
                          , m = i[4]
                          , v = i[7]
                          , y = i[2]
                          , S = i[5]
                          , A = i[8]
                          , M = s[0]
                          , x = s[3]
                          , T = s[6]
                          , D = s[1]
                          , w = s[4]
                          , U = s[7]
                          , O = s[2]
                          , L = s[5]
                          , N = s[8];
                        return a[0] = o * M + c * D + u * O,
                        a[3] = o * x + c * w + u * L,
                        a[6] = o * T + c * U + u * N,
                        a[1] = f * M + m * D + v * O,
                        a[4] = f * x + m * w + v * L,
                        a[7] = f * T + m * U + v * N,
                        a[2] = y * M + S * D + A * O,
                        a[5] = y * x + S * w + A * L,
                        a[8] = y * T + S * U + A * N,
                        this
                    }
                    multiplyScalar(t) {
                        const n = this.elements;
                        return n[0] *= t,
                        n[3] *= t,
                        n[6] *= t,
                        n[1] *= t,
                        n[4] *= t,
                        n[7] *= t,
                        n[2] *= t,
                        n[5] *= t,
                        n[8] *= t,
                        this
                    }
                    determinant() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[1]
                          , s = t[2]
                          , a = t[3]
                          , o = t[4]
                          , c = t[5]
                          , u = t[6]
                          , f = t[7]
                          , m = t[8];
                        return n * o * m - n * c * f - i * a * m + i * c * u + s * a * f - s * o * u
                    }
                    invert() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[1]
                          , s = t[2]
                          , a = t[3]
                          , o = t[4]
                          , c = t[5]
                          , u = t[6]
                          , f = t[7]
                          , m = t[8]
                          , v = m * o - c * f
                          , y = c * u - m * a
                          , S = f * a - o * u
                          , A = n * v + i * y + s * S;
                        if (A === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const M = 1 / A;
                        return t[0] = v * M,
                        t[1] = (s * f - m * i) * M,
                        t[2] = (c * i - s * o) * M,
                        t[3] = y * M,
                        t[4] = (m * n - s * u) * M,
                        t[5] = (s * a - c * n) * M,
                        t[6] = S * M,
                        t[7] = (i * u - f * n) * M,
                        t[8] = (o * n - i * a) * M,
                        this
                    }
                    transpose() {
                        let t;
                        const n = this.elements;
                        return t = n[1],
                        n[1] = n[3],
                        n[3] = t,
                        t = n[2],
                        n[2] = n[6],
                        n[6] = t,
                        t = n[5],
                        n[5] = n[7],
                        n[7] = t,
                        this
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose()
                    }
                    transposeIntoArray(t) {
                        const n = this.elements;
                        return t[0] = n[0],
                        t[1] = n[3],
                        t[2] = n[6],
                        t[3] = n[1],
                        t[4] = n[4],
                        t[5] = n[7],
                        t[6] = n[2],
                        t[7] = n[5],
                        t[8] = n[8],
                        this
                    }
                    setUvTransform(t, n, i, s, a, o, c) {
                        const u = Math.cos(a)
                          , f = Math.sin(a);
                        return this.set(i * u, i * f, -i * (u * o + f * c) + o + t, -s * f, s * u, -s * (-f * o + u * c) + c + n, 0, 0, 1),
                        this
                    }
                    scale(t, n) {
                        return this.premultiply(RA.makeScale(t, n)),
                        this
                    }
                    rotate(t) {
                        return this.premultiply(RA.makeRotation(-t)),
                        this
                    }
                    translate(t, n) {
                        return this.premultiply(RA.makeTranslation(t, n)),
                        this
                    }
                    makeTranslation(t, n) {
                        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, n, 0, 0, 1),
                        this
                    }
                    makeRotation(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(n, -i, 0, i, n, 0, 0, 0, 1),
                        this
                    }
                    makeScale(t, n) {
                        return this.set(t, 0, 0, 0, n, 0, 0, 0, 1),
                        this
                    }
                    equals(t) {
                        const n = this.elements
                          , i = t.elements;
                        for (let s = 0; s < 9; s++)
                            if (n[s] !== i[s])
                                return !1;
                        return !0
                    }
                    fromArray(t, n=0) {
                        for (let i = 0; i < 9; i++)
                            this.elements[i] = t[i + n];
                        return this
                    }
                    toArray(t=[], n=0) {
                        const i = this.elements;
                        return t[n] = i[0],
                        t[n + 1] = i[1],
                        t[n + 2] = i[2],
                        t[n + 3] = i[3],
                        t[n + 4] = i[4],
                        t[n + 5] = i[5],
                        t[n + 6] = i[6],
                        t[n + 7] = i[7],
                        t[n + 8] = i[8],
                        t
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements)
                    }
                }
                ;
                const RA = new nn;
                function _C(e) {
                    for (let t = e.length - 1; t >= 0; --t)
                        if (e[t] >= 65535)
                            return !0;
                    return !1
                }
                const FB = {
                    Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                };
                function Sp(e, t) {
                    return new FB[e](t)
                }
                function mg(e) {
                    return document.createElementNS("http://www.w3.org/1999/xhtml", e)
                }
                function SC() {
                    const e = mg("canvas");
                    return e.style.display = "block",
                    e
                }
                const xC = {};
                function vg(e) {
                    e in xC || (xC[e] = !0,
                    console.warn(e))
                }
                function HB(e, t, n) {
                    return new Promise(function(i, s) {
                        function a() {
                            switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                            case e.WAIT_FAILED:
                                s();
                                break;
                            case e.TIMEOUT_EXPIRED:
                                setTimeout(a, n);
                                break;
                            default:
                                i()
                            }
                        }
                        setTimeout(a, n)
                    }
                    )
                }
                const AC = new nn().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
                  , TC = new nn().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
                function GB() {
                    const e = {
                        enabled: !0,
                        workingColorSpace: rc,
                        spaces: {},
                        convert: function(s, a, o) {
                            return this.enabled === !1 || a === o || !a || !o || (this.spaces[a].transfer === Jn && (s.r = Zc(s.r),
                            s.g = Zc(s.g),
                            s.b = Zc(s.b)),
                            this.spaces[a].primaries !== this.spaces[o].primaries && (s.applyMatrix3(this.spaces[a].toXYZ),
                            s.applyMatrix3(this.spaces[o].fromXYZ)),
                            this.spaces[o].transfer === Jn && (s.r = xp(s.r),
                            s.g = xp(s.g),
                            s.b = xp(s.b))),
                            s
                        },
                        workingToColorSpace: function(s, a) {
                            return this.convert(s, this.workingColorSpace, a)
                        },
                        colorSpaceToWorking: function(s, a) {
                            return this.convert(s, a, this.workingColorSpace)
                        },
                        getPrimaries: function(s) {
                            return this.spaces[s].primaries
                        },
                        getTransfer: function(s) {
                            return s === rl ? fg : this.spaces[s].transfer
                        },
                        getToneMappingMode: function(s) {
                            return this.spaces[s].outputColorSpaceConfig.toneMappingMode || "standard"
                        },
                        getLuminanceCoefficients: function(s, a=this.workingColorSpace) {
                            return s.fromArray(this.spaces[a].luminanceCoefficients)
                        },
                        define: function(s) {
                            Object.assign(this.spaces, s)
                        },
                        _getMatrix: function(s, a, o) {
                            return s.copy(this.spaces[a].toXYZ).multiply(this.spaces[o].fromXYZ)
                        },
                        _getDrawingBufferColorSpace: function(s) {
                            return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace
                        },
                        _getUnpackColorSpace: function(s=this.workingColorSpace) {
                            return this.spaces[s].workingColorSpaceConfig.unpackColorSpace
                        },
                        fromWorkingColorSpace: function(s, a) {
                            return vg("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
                            e.workingToColorSpace(s, a)
                        },
                        toWorkingColorSpace: function(s, a) {
                            return vg("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
                            e.colorSpaceToWorking(s, a)
                        }
                    }
                      , t = [.64, .33, .3, .6, .15, .06]
                      , n = [.2126, .7152, .0722]
                      , i = [.3127, .329];
                    return e.define({
                        [rc]: {
                            primaries: t,
                            whitePoint: i,
                            transfer: fg,
                            toXYZ: AC,
                            fromXYZ: TC,
                            luminanceCoefficients: n,
                            workingColorSpaceConfig: {
                                unpackColorSpace: Zt
                            },
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: Zt
                            }
                        },
                        [Zt]: {
                            primaries: t,
                            whitePoint: i,
                            transfer: Jn,
                            toXYZ: AC,
                            fromXYZ: TC,
                            luminanceCoefficients: n,
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: Zt
                            }
                        }
                    }),
                    e
                }
                const Rn = GB();
                function Zc(e) {
                    return e < .04045 ? e * .0773993808 : Math.pow(e * .9478672986 + .0521327014, 2.4)
                }
                function xp(e) {
                    return e < .0031308 ? e * 12.92 : 1.055 * Math.pow(e, .41666) - .055
                }
                let Ap;
                var MC = class {
                    static getDataURL(e, t="image/png") {
                        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                            return e.src;
                        let n;
                        if (e instanceof HTMLCanvasElement)
                            n = e;
                        else {
                            Ap === void 0 && (Ap = mg("canvas")),
                            Ap.width = e.width,
                            Ap.height = e.height;
                            const i = Ap.getContext("2d");
                            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
                            n = Ap
                        }
                        return n.toDataURL(t)
                    }
                    static sRGBToLinear(e) {
                        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                            const t = mg("canvas");
                            t.width = e.width,
                            t.height = e.height;
                            const n = t.getContext("2d");
                            n.drawImage(e, 0, 0, e.width, e.height);
                            const i = n.getImageData(0, 0, e.width, e.height)
                              , s = i.data;
                            for (let a = 0; a < s.length; a++)
                                s[a] = Zc(s[a] / 255) * 255;
                            return n.putImageData(i, 0, 0),
                            t
                        } else if (e.data) {
                            const t = e.data.slice(0);
                            for (let n = 0; n < t.length; n++)
                                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Zc(t[n] / 255) * 255) : t[n] = Zc(t[n]);
                            return {
                                data: t,
                                width: e.width,
                                height: e.height
                            }
                        } else
                            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                            e
                    }
                }
                ;
                let VB = 0;
                var rh = class {
                    constructor(e=null) {
                        this.isSource = !0,
                        Object.defineProperty(this, "id", {
                            value: VB++
                        }),
                        this.uuid = jr(),
                        this.data = e,
                        this.dataReady = !0,
                        this.version = 0
                    }
                    getSize(e) {
                        const t = this.data;
                        return typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
                        e
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    toJSON(e) {
                        const t = e === void 0 || typeof e == "string";
                        if (!t && e.images[this.uuid] !== void 0)
                            return e.images[this.uuid];
                        const n = {
                            uuid: this.uuid,
                            url: ""
                        }
                          , i = this.data;
                        if (i !== null) {
                            let s;
                            if (Array.isArray(i)) {
                                s = [];
                                for (let a = 0, o = i.length; a < o; a++)
                                    i[a].isDataTexture ? s.push(UA(i[a].image)) : s.push(UA(i[a]))
                            } else
                                s = UA(i);
                            n.url = s
                        }
                        return t || (e.images[this.uuid] = n),
                        n
                    }
                }
                ;
                function UA(e) {
                    return typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap ? MC.getDataURL(e) : e.data ? {
                        data: Array.from(e.data),
                        width: e.width,
                        height: e.height,
                        type: e.data.constructor.name
                    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
                    {})
                }
                let kB = 0;
                const OA = new ae;
                var Fi = class Ax extends qr {
                    constructor(t=Ax.DEFAULT_IMAGE, n=Ax.DEFAULT_MAPPING, i=bo, s=bo, a=mi, o=sc, c=ps, u=gi, f=Ax.DEFAULT_ANISOTROPY, m=rl) {
                        super(),
                        this.isTexture = !0,
                        Object.defineProperty(this, "id", {
                            value: kB++
                        }),
                        this.uuid = jr(),
                        this.name = "",
                        this.source = new rh(t),
                        this.mipmaps = [],
                        this.mapping = n,
                        this.channel = 0,
                        this.wrapS = i,
                        this.wrapT = s,
                        this.magFilter = a,
                        this.minFilter = o,
                        this.anisotropy = f,
                        this.format = c,
                        this.internalFormat = null,
                        this.type = u,
                        this.offset = new Oe(0,0),
                        this.repeat = new Oe(1,1),
                        this.center = new Oe(0,0),
                        this.rotation = 0,
                        this.matrixAutoUpdate = !0,
                        this.matrix = new nn,
                        this.generateMipmaps = !0,
                        this.premultiplyAlpha = !1,
                        this.flipY = !0,
                        this.unpackAlignment = 4,
                        this.colorSpace = m,
                        this.userData = {},
                        this.updateRanges = [],
                        this.version = 0,
                        this.onUpdate = null,
                        this.renderTarget = null,
                        this.isRenderTargetTexture = !1,
                        this.isArrayTexture = !!(t && t.depth && t.depth > 1),
                        this.pmremVersion = 0
                    }
                    get width() {
                        return this.source.getSize(OA).x
                    }
                    get height() {
                        return this.source.getSize(OA).y
                    }
                    get depth() {
                        return this.source.getSize(OA).z
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(t=null) {
                        this.source.data = t
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    addUpdateRange(t, n) {
                        this.updateRanges.push({
                            start: t,
                            count: n
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.name = t.name,
                        this.source = t.source,
                        this.mipmaps = t.mipmaps.slice(0),
                        this.mapping = t.mapping,
                        this.channel = t.channel,
                        this.wrapS = t.wrapS,
                        this.wrapT = t.wrapT,
                        this.magFilter = t.magFilter,
                        this.minFilter = t.minFilter,
                        this.anisotropy = t.anisotropy,
                        this.format = t.format,
                        this.internalFormat = t.internalFormat,
                        this.type = t.type,
                        this.offset.copy(t.offset),
                        this.repeat.copy(t.repeat),
                        this.center.copy(t.center),
                        this.rotation = t.rotation,
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrix.copy(t.matrix),
                        this.generateMipmaps = t.generateMipmaps,
                        this.premultiplyAlpha = t.premultiplyAlpha,
                        this.flipY = t.flipY,
                        this.unpackAlignment = t.unpackAlignment,
                        this.colorSpace = t.colorSpace,
                        this.renderTarget = t.renderTarget,
                        this.isRenderTargetTexture = t.isRenderTargetTexture,
                        this.isArrayTexture = t.isArrayTexture,
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        this.needsUpdate = !0,
                        this
                    }
                    setValues(t) {
                        for (const n in t) {
                            const i = t[n];
                            if (i === void 0) {
                                console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);
                                continue
                            }
                            const s = this[n];
                            if (s === void 0) {
                                console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);
                                continue
                            }
                            s && i && s.isVector2 && i.isVector2 || s && i && s.isVector3 && i.isVector3 || s && i && s.isMatrix3 && i.isMatrix3 ? s.copy(i) : this[n] = i
                        }
                    }
                    toJSON(t) {
                        const n = t === void 0 || typeof t == "string";
                        if (!n && t.textures[this.uuid] !== void 0)
                            return t.textures[this.uuid];
                        const i = {
                            metadata: {
                                version: 4.7,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(t).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                        n || (t.textures[this.uuid] = i),
                        i
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(t) {
                        if (this.mapping !== Fy)
                            return t;
                        if (t.applyMatrix3(this.matrix),
                        t.x < 0 || t.x > 1)
                            switch (this.wrapS) {
                            case sh:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case bo:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case ig:
                                Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                                break
                            }
                        if (t.y < 0 || t.y > 1)
                            switch (this.wrapT) {
                            case sh:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case bo:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case ig:
                                Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                                break
                            }
                        return this.flipY && (t.y = 1 - t.y),
                        t
                    }
                    set needsUpdate(t) {
                        t === !0 && (this.version++,
                        this.source.needsUpdate = !0)
                    }
                    set needsPMREMUpdate(t) {
                        t === !0 && this.pmremVersion++
                    }
                }
                ;
                Fi.DEFAULT_IMAGE = null,
                Fi.DEFAULT_MAPPING = Fy,
                Fi.DEFAULT_ANISOTROPY = 1;
                var hn = class cU {
                    constructor(t=0, n=0, i=0, s=1) {
                        cU.prototype.isVector4 = !0,
                        this.x = t,
                        this.y = n,
                        this.z = i,
                        this.w = s
                    }
                    get width() {
                        return this.z
                    }
                    set width(t) {
                        this.z = t
                    }
                    get height() {
                        return this.w
                    }
                    set height(t) {
                        this.w = t
                    }
                    set(t, n, i, s) {
                        return this.x = t,
                        this.y = n,
                        this.z = i,
                        this.w = s,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this.w = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setZ(t) {
                        return this.z = t,
                        this
                    }
                    setW(t) {
                        return this.w = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        case 3:
                            this.w = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z,this.w)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this.w = t.w !== void 0 ? t.w : 1,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this.w += t.w,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this.w += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this.z = t.z + n.z,
                        this.w = t.w + n.w,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this.z += t.z * n,
                        this.w += t.w * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this.w -= t.w,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this.w -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this.z = t.z - n.z,
                        this.w = t.w - n.w,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this.w *= t.w,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this.w *= t,
                        this
                    }
                    applyMatrix4(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , a = this.w
                          , o = t.elements;
                        return this.x = o[0] * n + o[4] * i + o[8] * s + o[12] * a,
                        this.y = o[1] * n + o[5] * i + o[9] * s + o[13] * a,
                        this.z = o[2] * n + o[6] * i + o[10] * s + o[14] * a,
                        this.w = o[3] * n + o[7] * i + o[11] * s + o[15] * a,
                        this
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this.w /= t.w,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const n = Math.sqrt(1 - t.w * t.w);
                        return n < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = t.x / n,
                        this.y = t.y / n,
                        this.z = t.z / n),
                        this
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let n, i, s, a;
                        const u = t.elements
                          , f = u[0]
                          , m = u[4]
                          , v = u[8]
                          , y = u[1]
                          , S = u[5]
                          , A = u[9]
                          , M = u[2]
                          , x = u[6]
                          , T = u[10];
                        if (Math.abs(m - y) < .01 && Math.abs(v - M) < .01 && Math.abs(A - x) < .01) {
                            if (Math.abs(m + y) < .1 && Math.abs(v + M) < .1 && Math.abs(A + x) < .1 && Math.abs(f + S + T - 3) < .1)
                                return this.set(1, 0, 0, 0),
                                this;
                            n = Math.PI;
                            const w = (f + 1) / 2
                              , U = (S + 1) / 2
                              , O = (T + 1) / 2
                              , L = (m + y) / 4
                              , N = (v + M) / 4
                              , z = (A + x) / 4;
                            return w > U && w > O ? w < .01 ? (i = 0,
                            s = .707106781,
                            a = .707106781) : (i = Math.sqrt(w),
                            s = L / i,
                            a = N / i) : U > O ? U < .01 ? (i = .707106781,
                            s = 0,
                            a = .707106781) : (s = Math.sqrt(U),
                            i = L / s,
                            a = z / s) : O < .01 ? (i = .707106781,
                            s = .707106781,
                            a = 0) : (a = Math.sqrt(O),
                            i = N / a,
                            s = z / a),
                            this.set(i, s, a, n),
                            this
                        }
                        let D = Math.sqrt((x - A) * (x - A) + (v - M) * (v - M) + (y - m) * (y - m));
                        return Math.abs(D) < .001 && (D = 1),
                        this.x = (x - A) / D,
                        this.y = (v - M) / D,
                        this.z = (y - m) / D,
                        this.w = Math.acos((f + S + T - 1) / 2),
                        this
                    }
                    setFromMatrixPosition(t) {
                        const n = t.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this.w = n[15],
                        this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this.w = Math.min(this.w, t.w),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this.w = Math.max(this.w, t.w),
                        this
                    }
                    clamp(t, n) {
                        return this.x = Yt(this.x, t.x, n.x),
                        this.y = Yt(this.y, t.y, n.y),
                        this.z = Yt(this.z, t.z, n.z),
                        this.w = Yt(this.w, t.w, n.w),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = Yt(this.x, t, n),
                        this.y = Yt(this.y, t, n),
                        this.z = Yt(this.z, t, n),
                        this.w = Yt(this.w, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Yt(i, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this.w = Math.trunc(this.w),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this.z += (t.z - this.z) * n,
                        this.w += (t.w - this.w) * n,
                        this
                    }
                    lerpVectors(t, n, i) {
                        return this.x = t.x + (n.x - t.x) * i,
                        this.y = t.y + (n.y - t.y) * i,
                        this.z = t.z + (n.z - t.z) * i,
                        this.w = t.w + (n.w - t.w) * i,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this.z = t[n + 2],
                        this.w = t[n + 3],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t[n + 2] = this.z,
                        t[n + 3] = this.w,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this.z = t.getZ(n),
                        this.w = t.getW(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this.w = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z,
                        yield this.w
                    }
                }
                  , NA = class extends qr {
                    constructor(e=1, t=1, n={}) {
                        super(),
                        n = Object.assign({
                            generateMipmaps: !1,
                            internalFormat: null,
                            minFilter: mi,
                            depthBuffer: !0,
                            stencilBuffer: !1,
                            resolveDepthBuffer: !0,
                            resolveStencilBuffer: !0,
                            depthTexture: null,
                            samples: 0,
                            count: 1,
                            depth: 1,
                            multiview: !1
                        }, n),
                        this.isRenderTarget = !0,
                        this.width = e,
                        this.height = t,
                        this.depth = n.depth,
                        this.scissor = new hn(0,0,e,t),
                        this.scissorTest = !1,
                        this.viewport = new hn(0,0,e,t);
                        const i = {
                            width: e,
                            height: t,
                            depth: n.depth
                        }
                          , s = new Fi(i);
                        this.textures = [];
                        const a = n.count;
                        for (let o = 0; o < a; o++)
                            this.textures[o] = s.clone(),
                            this.textures[o].isRenderTargetTexture = !0,
                            this.textures[o].renderTarget = this;
                        this._setTextureOptions(n),
                        this.depthBuffer = n.depthBuffer,
                        this.stencilBuffer = n.stencilBuffer,
                        this.resolveDepthBuffer = n.resolveDepthBuffer,
                        this.resolveStencilBuffer = n.resolveStencilBuffer,
                        this._depthTexture = null,
                        this.depthTexture = n.depthTexture,
                        this.samples = n.samples,
                        this.multiview = n.multiview
                    }
                    _setTextureOptions(e={}) {
                        const t = {
                            minFilter: mi,
                            generateMipmaps: !1,
                            flipY: !1,
                            internalFormat: null
                        };
                        e.mapping !== void 0 && (t.mapping = e.mapping),
                        e.wrapS !== void 0 && (t.wrapS = e.wrapS),
                        e.wrapT !== void 0 && (t.wrapT = e.wrapT),
                        e.wrapR !== void 0 && (t.wrapR = e.wrapR),
                        e.magFilter !== void 0 && (t.magFilter = e.magFilter),
                        e.minFilter !== void 0 && (t.minFilter = e.minFilter),
                        e.format !== void 0 && (t.format = e.format),
                        e.type !== void 0 && (t.type = e.type),
                        e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
                        e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
                        e.flipY !== void 0 && (t.flipY = e.flipY),
                        e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
                        e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
                        for (let n = 0; n < this.textures.length; n++)
                            this.textures[n].setValues(t)
                    }
                    get texture() {
                        return this.textures[0]
                    }
                    set texture(e) {
                        this.textures[0] = e
                    }
                    set depthTexture(e) {
                        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
                        e !== null && (e.renderTarget = this),
                        this._depthTexture = e
                    }
                    get depthTexture() {
                        return this._depthTexture
                    }
                    setSize(e, t, n=1) {
                        if (this.width !== e || this.height !== t || this.depth !== n) {
                            this.width = e,
                            this.height = t,
                            this.depth = n;
                            for (let i = 0, s = this.textures.length; i < s; i++)
                                this.textures[i].image.width = e,
                                this.textures[i].image.height = t,
                                this.textures[i].image.depth = n,
                                this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
                            this.dispose()
                        }
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.width = e.width,
                        this.height = e.height,
                        this.depth = e.depth,
                        this.scissor.copy(e.scissor),
                        this.scissorTest = e.scissorTest,
                        this.viewport.copy(e.viewport),
                        this.textures.length = 0;
                        for (let t = 0, n = e.textures.length; t < n; t++) {
                            this.textures[t] = e.textures[t].clone(),
                            this.textures[t].isRenderTargetTexture = !0,
                            this.textures[t].renderTarget = this;
                            const i = Object.assign({}, e.textures[t].image);
                            this.textures[t].source = new rh(i)
                        }
                        return this.depthBuffer = e.depthBuffer,
                        this.stencilBuffer = e.stencilBuffer,
                        this.resolveDepthBuffer = e.resolveDepthBuffer,
                        this.resolveStencilBuffer = e.resolveStencilBuffer,
                        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                        this.samples = e.samples,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                  , Vn = class extends NA {
                    constructor(e=1, t=1, n={}) {
                        super(e, t, n),
                        this.isWebGLRenderTarget = !0
                    }
                }
                  , T_ = class extends Fi {
                    constructor(e=null, t=1, n=1, i=1) {
                        super(null),
                        this.isDataArrayTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n,
                            depth: i
                        },
                        this.magFilter = ri,
                        this.minFilter = ri,
                        this.wrapR = bo,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(e) {
                        this.layerUpdates.add(e)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , XB = class extends Vn {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isWebGLArrayRenderTarget = !0,
                        this.depth = n,
                        this.texture = new T_(null,e,t,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , M_ = class extends Fi {
                    constructor(e=null, t=1, n=1, i=1) {
                        super(null),
                        this.isData3DTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n,
                            depth: i
                        },
                        this.magFilter = ri,
                        this.minFilter = ri,
                        this.wrapR = bo,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                  , WB = class extends Vn {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isWebGL3DRenderTarget = !0,
                        this.depth = n,
                        this.texture = new M_(null,e,t,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , Ws = class {
                    constructor(e=new ae(1 / 0,1 / 0,1 / 0), t=new ae(-1 / 0,-1 / 0,-1 / 0)) {
                        this.isBox3 = !0,
                        this.min = e,
                        this.max = t
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromArray(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t += 3)
                            this.expandByPoint(ol.fromArray(e, t));
                        return this
                    }
                    setFromBufferAttribute(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.count; t < n; t++)
                            this.expandByPoint(ol.fromBufferAttribute(e, t));
                        return this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = ol.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    setFromObject(e, t=!1) {
                        return this.makeEmpty(),
                        this.expandByObject(e, t)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0,
                        this.max.x = this.max.y = this.max.z = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(e) {
                        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    expandByObject(e, t=!1) {
                        e.updateWorldMatrix(!1, !1);
                        const n = e.geometry;
                        if (n !== void 0) {
                            const s = n.getAttribute("position");
                            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                                for (let a = 0, o = s.count; a < o; a++)
                                    e.isMesh === !0 ? e.getVertexPosition(a, ol) : ol.fromBufferAttribute(s, a),
                                    ol.applyMatrix4(e.matrixWorld),
                                    this.expandByPoint(ol);
                            else
                                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                                b_.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                                b_.copy(n.boundingBox)),
                                b_.applyMatrix4(e.matrixWorld),
                                this.union(b_)
                        }
                        const i = e.children;
                        for (let s = 0, a = i.length; s < a; s++)
                            this.expandByObject(i[s], t);
                        return this
                    }
                    containsPoint(e) {
                        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                    }
                    getParameter(e, t) {
                        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(e) {
                        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                    }
                    intersectsSphere(e) {
                        return this.clampPoint(e.center, ol),
                        ol.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                    intersectsPlane(e) {
                        let t, n;
                        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                        n = e.normal.x * this.min.x),
                        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                        n += e.normal.y * this.min.y),
                        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                        n += e.normal.z * this.min.z),
                        t <= -e.constant && n >= -e.constant
                    }
                    intersectsTriangle(e) {
                        if (this.isEmpty())
                            return !1;
                        this.getCenter(gg),
                        E_.subVectors(this.max, gg),
                        Tp.subVectors(e.a, gg),
                        Mp.subVectors(e.b, gg),
                        bp.subVectors(e.c, gg),
                        oh.subVectors(Mp, Tp),
                        lh.subVectors(bp, Mp),
                        _f.subVectors(Tp, bp);
                        let t = [0, -oh.z, oh.y, 0, -lh.z, lh.y, 0, -_f.z, _f.y, oh.z, 0, -oh.x, lh.z, 0, -lh.x, _f.z, 0, -_f.x, -oh.y, oh.x, 0, -lh.y, lh.x, 0, -_f.y, _f.x, 0];
                        return !BA(t, Tp, Mp, bp, E_) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        !BA(t, Tp, Mp, bp, E_)) ? !1 : (C_.crossVectors(oh, lh),
                        t = [C_.x, C_.y, C_.z],
                        BA(t, Tp, Mp, bp, E_))
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return this.clampPoint(e, ol).distanceTo(e)
                    }
                    getBoundingSphere(e) {
                        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                        e.radius = this.getSize(ol).length() * .5),
                        e
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    applyMatrix4(e) {
                        return this.isEmpty() ? this : (Kc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                        Kc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                        Kc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                        Kc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                        Kc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                        Kc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                        Kc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                        Kc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                        this.setFromPoints(Kc),
                        this)
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                    toJSON() {
                        return {
                            min: this.min.toArray(),
                            max: this.max.toArray()
                        }
                    }
                    fromJSON(e) {
                        return this.min.fromArray(e.min),
                        this.max.fromArray(e.max),
                        this
                    }
                }
                ;
                const Kc = [new ae, new ae, new ae, new ae, new ae, new ae, new ae, new ae]
                  , ol = new ae
                  , b_ = new Ws
                  , Tp = new ae
                  , Mp = new ae
                  , bp = new ae
                  , oh = new ae
                  , lh = new ae
                  , _f = new ae
                  , gg = new ae
                  , E_ = new ae
                  , C_ = new ae
                  , Sf = new ae;
                function BA(e, t, n, i, s) {
                    for (let a = 0, o = e.length - 3; a <= o; a += 3) {
                        Sf.fromArray(e, a);
                        const c = s.x * Math.abs(Sf.x) + s.y * Math.abs(Sf.y) + s.z * Math.abs(Sf.z)
                          , u = t.dot(Sf)
                          , f = n.dot(Sf)
                          , m = i.dot(Sf);
                        if (Math.max(-Math.max(u, f, m), Math.min(u, f, m)) > c)
                            return !1
                    }
                    return !0
                }
                const YB = new Ws
                  , yg = new ae
                  , LA = new ae;
                var Ys = class {
                    constructor(e=new ae, t=-1) {
                        this.isSphere = !0,
                        this.center = e,
                        this.radius = t
                    }
                    set(e, t) {
                        return this.center.copy(e),
                        this.radius = t,
                        this
                    }
                    setFromPoints(e, t) {
                        const n = this.center;
                        t !== void 0 ? n.copy(t) : YB.setFromPoints(e).getCenter(n);
                        let i = 0;
                        for (let s = 0, a = e.length; s < a; s++)
                            i = Math.max(i, n.distanceToSquared(e[s]));
                        return this.radius = Math.sqrt(i),
                        this
                    }
                    copy(e) {
                        return this.center.copy(e.center),
                        this.radius = e.radius,
                        this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0),
                        this.radius = -1,
                        this
                    }
                    containsPoint(e) {
                        return e.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(e) {
                        return e.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(e) {
                        const t = this.radius + e.radius;
                        return e.center.distanceToSquared(this.center) <= t * t
                    }
                    intersectsBox(e) {
                        return e.intersectsSphere(this)
                    }
                    intersectsPlane(e) {
                        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(e, t) {
                        const n = this.center.distanceToSquared(e);
                        return t.copy(e),
                        n > this.radius * this.radius && (t.sub(this.center).normalize(),
                        t.multiplyScalar(this.radius).add(this.center)),
                        t
                    }
                    getBoundingBox(e) {
                        return this.isEmpty() ? (e.makeEmpty(),
                        e) : (e.set(this.center, this.center),
                        e.expandByScalar(this.radius),
                        e)
                    }
                    applyMatrix4(e) {
                        return this.center.applyMatrix4(e),
                        this.radius = this.radius * e.getMaxScaleOnAxis(),
                        this
                    }
                    translate(e) {
                        return this.center.add(e),
                        this
                    }
                    expandByPoint(e) {
                        if (this.isEmpty())
                            return this.center.copy(e),
                            this.radius = 0,
                            this;
                        yg.subVectors(e, this.center);
                        const t = yg.lengthSq();
                        if (t > this.radius * this.radius) {
                            const n = Math.sqrt(t)
                              , i = (n - this.radius) * .5;
                            this.center.addScaledVector(yg, i / n),
                            this.radius += i
                        }
                        return this
                    }
                    union(e) {
                        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (LA.subVectors(e.center, this.center).setLength(e.radius),
                        this.expandByPoint(yg.copy(e.center).add(LA)),
                        this.expandByPoint(yg.copy(e.center).sub(LA))),
                        this)
                    }
                    equals(e) {
                        return e.center.equals(this.center) && e.radius === this.radius
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        return {
                            radius: this.radius,
                            center: this.center.toArray()
                        }
                    }
                    fromJSON(e) {
                        return this.radius = e.radius,
                        this.center.fromArray(e.center),
                        this
                    }
                }
                ;
                const Jc = new ae
                  , IA = new ae
                  , w_ = new ae
                  , ch = new ae
                  , PA = new ae
                  , D_ = new ae
                  , zA = new ae;
                var Ep = class {
                    constructor(e=new ae, t=new ae(0,0,-1)) {
                        this.origin = e,
                        this.direction = t
                    }
                    set(e, t) {
                        return this.origin.copy(e),
                        this.direction.copy(t),
                        this
                    }
                    copy(e) {
                        return this.origin.copy(e.origin),
                        this.direction.copy(e.direction),
                        this
                    }
                    at(e, t) {
                        return t.copy(this.origin).addScaledVector(this.direction, e)
                    }
                    lookAt(e) {
                        return this.direction.copy(e).sub(this.origin).normalize(),
                        this
                    }
                    recast(e) {
                        return this.origin.copy(this.at(e, Jc)),
                        this
                    }
                    closestPointToPoint(e, t) {
                        t.subVectors(e, this.origin);
                        const n = t.dot(this.direction);
                        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                    }
                    distanceToPoint(e) {
                        return Math.sqrt(this.distanceSqToPoint(e))
                    }
                    distanceSqToPoint(e) {
                        const t = Jc.subVectors(e, this.origin).dot(this.direction);
                        return t < 0 ? this.origin.distanceToSquared(e) : (Jc.copy(this.origin).addScaledVector(this.direction, t),
                        Jc.distanceToSquared(e))
                    }
                    distanceSqToSegment(e, t, n, i) {
                        IA.copy(e).add(t).multiplyScalar(.5),
                        w_.copy(t).sub(e).normalize(),
                        ch.copy(this.origin).sub(IA);
                        const s = e.distanceTo(t) * .5
                          , a = -this.direction.dot(w_)
                          , o = ch.dot(this.direction)
                          , c = -ch.dot(w_)
                          , u = ch.lengthSq()
                          , f = Math.abs(1 - a * a);
                        let m, v, y, S;
                        if (f > 0)
                            if (m = a * c - o,
                            v = a * o - c,
                            S = s * f,
                            m >= 0)
                                if (v >= -S)
                                    if (v <= S) {
                                        const A = 1 / f;
                                        m *= A,
                                        v *= A,
                                        y = m * (m + a * v + 2 * o) + v * (a * m + v + 2 * c) + u
                                    } else
                                        v = s,
                                        m = Math.max(0, -(a * v + o)),
                                        y = -m * m + v * (v + 2 * c) + u;
                                else
                                    v = -s,
                                    m = Math.max(0, -(a * v + o)),
                                    y = -m * m + v * (v + 2 * c) + u;
                            else
                                v <= -S ? (m = Math.max(0, -(-a * s + o)),
                                v = m > 0 ? -s : Math.min(Math.max(-s, -c), s),
                                y = -m * m + v * (v + 2 * c) + u) : v <= S ? (m = 0,
                                v = Math.min(Math.max(-s, -c), s),
                                y = v * (v + 2 * c) + u) : (m = Math.max(0, -(a * s + o)),
                                v = m > 0 ? s : Math.min(Math.max(-s, -c), s),
                                y = -m * m + v * (v + 2 * c) + u);
                        else
                            v = a > 0 ? -s : s,
                            m = Math.max(0, -(a * v + o)),
                            y = -m * m + v * (v + 2 * c) + u;
                        return n && n.copy(this.origin).addScaledVector(this.direction, m),
                        i && i.copy(IA).addScaledVector(w_, v),
                        y
                    }
                    intersectSphere(e, t) {
                        Jc.subVectors(e.center, this.origin);
                        const n = Jc.dot(this.direction)
                          , i = Jc.dot(Jc) - n * n
                          , s = e.radius * e.radius;
                        if (i > s)
                            return null;
                        const a = Math.sqrt(s - i)
                          , o = n - a
                          , c = n + a;
                        return c < 0 ? null : o < 0 ? this.at(c, t) : this.at(o, t)
                    }
                    intersectsSphere(e) {
                        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
                    }
                    distanceToPlane(e) {
                        const t = e.normal.dot(this.direction);
                        if (t === 0)
                            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                        const n = -(this.origin.dot(e.normal) + e.constant) / t;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(e, t) {
                        const n = this.distanceToPlane(e);
                        return n === null ? null : this.at(n, t)
                    }
                    intersectsPlane(e) {
                        const t = e.distanceToPoint(this.origin);
                        return t === 0 || e.normal.dot(this.direction) * t < 0
                    }
                    intersectBox(e, t) {
                        let n, i, s, a, o, c;
                        const u = 1 / this.direction.x
                          , f = 1 / this.direction.y
                          , m = 1 / this.direction.z
                          , v = this.origin;
                        return u >= 0 ? (n = (e.min.x - v.x) * u,
                        i = (e.max.x - v.x) * u) : (n = (e.max.x - v.x) * u,
                        i = (e.min.x - v.x) * u),
                        f >= 0 ? (s = (e.min.y - v.y) * f,
                        a = (e.max.y - v.y) * f) : (s = (e.max.y - v.y) * f,
                        a = (e.min.y - v.y) * f),
                        n > a || s > i || ((s > n || isNaN(n)) && (n = s),
                        (a < i || isNaN(i)) && (i = a),
                        m >= 0 ? (o = (e.min.z - v.z) * m,
                        c = (e.max.z - v.z) * m) : (o = (e.max.z - v.z) * m,
                        c = (e.min.z - v.z) * m),
                        n > c || o > i) || ((o > n || n !== n) && (n = o),
                        (c < i || i !== i) && (i = c),
                        i < 0) ? null : this.at(n >= 0 ? n : i, t)
                    }
                    intersectsBox(e) {
                        return this.intersectBox(e, Jc) !== null
                    }
                    intersectTriangle(e, t, n, i, s) {
                        PA.subVectors(t, e),
                        D_.subVectors(n, e),
                        zA.crossVectors(PA, D_);
                        let a = this.direction.dot(zA), o;
                        if (a > 0) {
                            if (i)
                                return null;
                            o = 1
                        } else if (a < 0)
                            o = -1,
                            a = -a;
                        else
                            return null;
                        ch.subVectors(this.origin, e);
                        const c = o * this.direction.dot(D_.crossVectors(ch, D_));
                        if (c < 0)
                            return null;
                        const u = o * this.direction.dot(PA.cross(ch));
                        if (u < 0 || c + u > a)
                            return null;
                        const f = -o * ch.dot(zA);
                        return f < 0 ? null : this.at(f / a, s)
                    }
                    applyMatrix4(e) {
                        return this.origin.applyMatrix4(e),
                        this.direction.transformDirection(e),
                        this
                    }
                    equals(e) {
                        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , Xt = class Rb {
                    constructor(t, n, i, s, a, o, c, u, f, m, v, y, S, A, M, x) {
                        Rb.prototype.isMatrix4 = !0,
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                        t !== void 0 && this.set(t, n, i, s, a, o, c, u, f, m, v, y, S, A, M, x)
                    }
                    set(t, n, i, s, a, o, c, u, f, m, v, y, S, A, M, x) {
                        const T = this.elements;
                        return T[0] = t,
                        T[4] = n,
                        T[8] = i,
                        T[12] = s,
                        T[1] = a,
                        T[5] = o,
                        T[9] = c,
                        T[13] = u,
                        T[2] = f,
                        T[6] = m,
                        T[10] = v,
                        T[14] = y,
                        T[3] = S,
                        T[7] = A,
                        T[11] = M,
                        T[15] = x,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    clone() {
                        return new Rb().fromArray(this.elements)
                    }
                    copy(t) {
                        const n = this.elements
                          , i = t.elements;
                        return n[0] = i[0],
                        n[1] = i[1],
                        n[2] = i[2],
                        n[3] = i[3],
                        n[4] = i[4],
                        n[5] = i[5],
                        n[6] = i[6],
                        n[7] = i[7],
                        n[8] = i[8],
                        n[9] = i[9],
                        n[10] = i[10],
                        n[11] = i[11],
                        n[12] = i[12],
                        n[13] = i[13],
                        n[14] = i[14],
                        n[15] = i[15],
                        this
                    }
                    copyPosition(t) {
                        const n = this.elements
                          , i = t.elements;
                        return n[12] = i[12],
                        n[13] = i[13],
                        n[14] = i[14],
                        this
                    }
                    setFromMatrix3(t) {
                        const n = t.elements;
                        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1),
                        this
                    }
                    extractBasis(t, n, i) {
                        return t.setFromMatrixColumn(this, 0),
                        n.setFromMatrixColumn(this, 1),
                        i.setFromMatrixColumn(this, 2),
                        this
                    }
                    makeBasis(t, n, i) {
                        return this.set(t.x, n.x, i.x, 0, t.y, n.y, i.y, 0, t.z, n.z, i.z, 0, 0, 0, 0, 1),
                        this
                    }
                    extractRotation(t) {
                        const n = this.elements
                          , i = t.elements
                          , s = 1 / Cp.setFromMatrixColumn(t, 0).length()
                          , a = 1 / Cp.setFromMatrixColumn(t, 1).length()
                          , o = 1 / Cp.setFromMatrixColumn(t, 2).length();
                        return n[0] = i[0] * s,
                        n[1] = i[1] * s,
                        n[2] = i[2] * s,
                        n[3] = 0,
                        n[4] = i[4] * a,
                        n[5] = i[5] * a,
                        n[6] = i[6] * a,
                        n[7] = 0,
                        n[8] = i[8] * o,
                        n[9] = i[9] * o,
                        n[10] = i[10] * o,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromEuler(t) {
                        const n = this.elements
                          , i = t.x
                          , s = t.y
                          , a = t.z
                          , o = Math.cos(i)
                          , c = Math.sin(i)
                          , u = Math.cos(s)
                          , f = Math.sin(s)
                          , m = Math.cos(a)
                          , v = Math.sin(a);
                        if (t.order === "XYZ") {
                            const y = o * m
                              , S = o * v
                              , A = c * m
                              , M = c * v;
                            n[0] = u * m,
                            n[4] = -u * v,
                            n[8] = f,
                            n[1] = S + A * f,
                            n[5] = y - M * f,
                            n[9] = -c * u,
                            n[2] = M - y * f,
                            n[6] = A + S * f,
                            n[10] = o * u
                        } else if (t.order === "YXZ") {
                            const y = u * m
                              , S = u * v
                              , A = f * m
                              , M = f * v;
                            n[0] = y + M * c,
                            n[4] = A * c - S,
                            n[8] = o * f,
                            n[1] = o * v,
                            n[5] = o * m,
                            n[9] = -c,
                            n[2] = S * c - A,
                            n[6] = M + y * c,
                            n[10] = o * u
                        } else if (t.order === "ZXY") {
                            const y = u * m
                              , S = u * v
                              , A = f * m
                              , M = f * v;
                            n[0] = y - M * c,
                            n[4] = -o * v,
                            n[8] = A + S * c,
                            n[1] = S + A * c,
                            n[5] = o * m,
                            n[9] = M - y * c,
                            n[2] = -o * f,
                            n[6] = c,
                            n[10] = o * u
                        } else if (t.order === "ZYX") {
                            const y = o * m
                              , S = o * v
                              , A = c * m
                              , M = c * v;
                            n[0] = u * m,
                            n[4] = A * f - S,
                            n[8] = y * f + M,
                            n[1] = u * v,
                            n[5] = M * f + y,
                            n[9] = S * f - A,
                            n[2] = -f,
                            n[6] = c * u,
                            n[10] = o * u
                        } else if (t.order === "YZX") {
                            const y = o * u
                              , S = o * f
                              , A = c * u
                              , M = c * f;
                            n[0] = u * m,
                            n[4] = M - y * v,
                            n[8] = A * v + S,
                            n[1] = v,
                            n[5] = o * m,
                            n[9] = -c * m,
                            n[2] = -f * m,
                            n[6] = S * v + A,
                            n[10] = y - M * v
                        } else if (t.order === "XZY") {
                            const y = o * u
                              , S = o * f
                              , A = c * u
                              , M = c * f;
                            n[0] = u * m,
                            n[4] = -v,
                            n[8] = f * m,
                            n[1] = y * v + M,
                            n[5] = o * m,
                            n[9] = S * v - A,
                            n[2] = A * v - S,
                            n[6] = c * m,
                            n[10] = M * v + y
                        }
                        return n[3] = 0,
                        n[7] = 0,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(qB, t, jB)
                    }
                    lookAt(t, n, i) {
                        const s = this.elements;
                        return Qr.subVectors(t, n),
                        Qr.lengthSq() === 0 && (Qr.z = 1),
                        Qr.normalize(),
                        uh.crossVectors(i, Qr),
                        uh.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Qr.x += 1e-4 : Qr.z += 1e-4,
                        Qr.normalize(),
                        uh.crossVectors(i, Qr)),
                        uh.normalize(),
                        R_.crossVectors(Qr, uh),
                        s[0] = uh.x,
                        s[4] = R_.x,
                        s[8] = Qr.x,
                        s[1] = uh.y,
                        s[5] = R_.y,
                        s[9] = Qr.y,
                        s[2] = uh.z,
                        s[6] = R_.z,
                        s[10] = Qr.z,
                        this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, n) {
                        const i = t.elements
                          , s = n.elements
                          , a = this.elements
                          , o = i[0]
                          , c = i[4]
                          , u = i[8]
                          , f = i[12]
                          , m = i[1]
                          , v = i[5]
                          , y = i[9]
                          , S = i[13]
                          , A = i[2]
                          , M = i[6]
                          , x = i[10]
                          , T = i[14]
                          , D = i[3]
                          , w = i[7]
                          , U = i[11]
                          , O = i[15]
                          , L = s[0]
                          , N = s[4]
                          , z = s[8]
                          , I = s[12]
                          , B = s[1]
                          , G = s[5]
                          , X = s[9]
                          , q = s[13]
                          , Q = s[2]
                          , oe = s[6]
                          , k = s[10]
                          , W = s[14]
                          , V = s[3]
                          , Z = s[7]
                          , j = s[11]
                          , ee = s[15];
                        return a[0] = o * L + c * B + u * Q + f * V,
                        a[4] = o * N + c * G + u * oe + f * Z,
                        a[8] = o * z + c * X + u * k + f * j,
                        a[12] = o * I + c * q + u * W + f * ee,
                        a[1] = m * L + v * B + y * Q + S * V,
                        a[5] = m * N + v * G + y * oe + S * Z,
                        a[9] = m * z + v * X + y * k + S * j,
                        a[13] = m * I + v * q + y * W + S * ee,
                        a[2] = A * L + M * B + x * Q + T * V,
                        a[6] = A * N + M * G + x * oe + T * Z,
                        a[10] = A * z + M * X + x * k + T * j,
                        a[14] = A * I + M * q + x * W + T * ee,
                        a[3] = D * L + w * B + U * Q + O * V,
                        a[7] = D * N + w * G + U * oe + O * Z,
                        a[11] = D * z + w * X + U * k + O * j,
                        a[15] = D * I + w * q + U * W + O * ee,
                        this
                    }
                    multiplyScalar(t) {
                        const n = this.elements;
                        return n[0] *= t,
                        n[4] *= t,
                        n[8] *= t,
                        n[12] *= t,
                        n[1] *= t,
                        n[5] *= t,
                        n[9] *= t,
                        n[13] *= t,
                        n[2] *= t,
                        n[6] *= t,
                        n[10] *= t,
                        n[14] *= t,
                        n[3] *= t,
                        n[7] *= t,
                        n[11] *= t,
                        n[15] *= t,
                        this
                    }
                    determinant() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[4]
                          , s = t[8]
                          , a = t[12]
                          , o = t[1]
                          , c = t[5]
                          , u = t[9]
                          , f = t[13]
                          , m = t[2]
                          , v = t[6]
                          , y = t[10]
                          , S = t[14]
                          , A = t[3]
                          , M = t[7]
                          , x = t[11]
                          , T = t[15];
                        return A * (+a * u * v - s * f * v - a * c * y + i * f * y + s * c * S - i * u * S) + M * (+n * u * S - n * f * y + a * o * y - s * o * S + s * f * m - a * u * m) + x * (+n * f * v - n * c * S - a * o * v + i * o * S + a * c * m - i * f * m) + T * (-s * c * m - n * u * v + n * c * y + s * o * v - i * o * y + i * u * m)
                    }
                    transpose() {
                        const t = this.elements;
                        let n;
                        return n = t[1],
                        t[1] = t[4],
                        t[4] = n,
                        n = t[2],
                        t[2] = t[8],
                        t[8] = n,
                        n = t[6],
                        t[6] = t[9],
                        t[9] = n,
                        n = t[3],
                        t[3] = t[12],
                        t[12] = n,
                        n = t[7],
                        t[7] = t[13],
                        t[13] = n,
                        n = t[11],
                        t[11] = t[14],
                        t[14] = n,
                        this
                    }
                    setPosition(t, n, i) {
                        const s = this.elements;
                        return t.isVector3 ? (s[12] = t.x,
                        s[13] = t.y,
                        s[14] = t.z) : (s[12] = t,
                        s[13] = n,
                        s[14] = i),
                        this
                    }
                    invert() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[1]
                          , s = t[2]
                          , a = t[3]
                          , o = t[4]
                          , c = t[5]
                          , u = t[6]
                          , f = t[7]
                          , m = t[8]
                          , v = t[9]
                          , y = t[10]
                          , S = t[11]
                          , A = t[12]
                          , M = t[13]
                          , x = t[14]
                          , T = t[15]
                          , D = v * x * f - M * y * f + M * u * S - c * x * S - v * u * T + c * y * T
                          , w = A * y * f - m * x * f - A * u * S + o * x * S + m * u * T - o * y * T
                          , U = m * M * f - A * v * f + A * c * S - o * M * S - m * c * T + o * v * T
                          , O = A * v * u - m * M * u - A * c * y + o * M * y + m * c * x - o * v * x
                          , L = n * D + i * w + s * U + a * O;
                        if (L === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const N = 1 / L;
                        return t[0] = D * N,
                        t[1] = (M * y * a - v * x * a - M * s * S + i * x * S + v * s * T - i * y * T) * N,
                        t[2] = (c * x * a - M * u * a + M * s * f - i * x * f - c * s * T + i * u * T) * N,
                        t[3] = (v * u * a - c * y * a - v * s * f + i * y * f + c * s * S - i * u * S) * N,
                        t[4] = w * N,
                        t[5] = (m * x * a - A * y * a + A * s * S - n * x * S - m * s * T + n * y * T) * N,
                        t[6] = (A * u * a - o * x * a - A * s * f + n * x * f + o * s * T - n * u * T) * N,
                        t[7] = (o * y * a - m * u * a + m * s * f - n * y * f - o * s * S + n * u * S) * N,
                        t[8] = U * N,
                        t[9] = (A * v * a - m * M * a - A * i * S + n * M * S + m * i * T - n * v * T) * N,
                        t[10] = (o * M * a - A * c * a + A * i * f - n * M * f - o * i * T + n * c * T) * N,
                        t[11] = (m * c * a - o * v * a - m * i * f + n * v * f + o * i * S - n * c * S) * N,
                        t[12] = O * N,
                        t[13] = (m * M * s - A * v * s + A * i * y - n * M * y - m * i * x + n * v * x) * N,
                        t[14] = (A * c * s - o * M * s - A * i * u + n * M * u + o * i * x - n * c * x) * N,
                        t[15] = (o * v * s - m * c * s + m * i * u - n * v * u - o * i * y + n * c * y) * N,
                        this
                    }
                    scale(t) {
                        const n = this.elements
                          , i = t.x
                          , s = t.y
                          , a = t.z;
                        return n[0] *= i,
                        n[4] *= s,
                        n[8] *= a,
                        n[1] *= i,
                        n[5] *= s,
                        n[9] *= a,
                        n[2] *= i,
                        n[6] *= s,
                        n[10] *= a,
                        n[3] *= i,
                        n[7] *= s,
                        n[11] *= a,
                        this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements
                          , n = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                          , i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                          , s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(n, i, s))
                    }
                    makeTranslation(t, n, i) {
                        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1),
                        this
                    }
                    makeRotationX(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationY(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationZ(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationAxis(t, n) {
                        const i = Math.cos(n)
                          , s = Math.sin(n)
                          , a = 1 - i
                          , o = t.x
                          , c = t.y
                          , u = t.z
                          , f = a * o
                          , m = a * c;
                        return this.set(f * o + i, f * c - s * u, f * u + s * c, 0, f * c + s * u, m * c + i, m * u - s * o, 0, f * u - s * c, m * u + s * o, a * u * u + i, 0, 0, 0, 0, 1),
                        this
                    }
                    makeScale(t, n, i) {
                        return this.set(t, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
                        this
                    }
                    makeShear(t, n, i, s, a, o) {
                        return this.set(1, i, a, 0, t, 1, o, 0, n, s, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    compose(t, n, i) {
                        const s = this.elements
                          , a = n._x
                          , o = n._y
                          , c = n._z
                          , u = n._w
                          , f = a + a
                          , m = o + o
                          , v = c + c
                          , y = a * f
                          , S = a * m
                          , A = a * v
                          , M = o * m
                          , x = o * v
                          , T = c * v
                          , D = u * f
                          , w = u * m
                          , U = u * v
                          , O = i.x
                          , L = i.y
                          , N = i.z;
                        return s[0] = (1 - (M + T)) * O,
                        s[1] = (S + U) * O,
                        s[2] = (A - w) * O,
                        s[3] = 0,
                        s[4] = (S - U) * L,
                        s[5] = (1 - (y + T)) * L,
                        s[6] = (x + D) * L,
                        s[7] = 0,
                        s[8] = (A + w) * N,
                        s[9] = (x - D) * N,
                        s[10] = (1 - (y + M)) * N,
                        s[11] = 0,
                        s[12] = t.x,
                        s[13] = t.y,
                        s[14] = t.z,
                        s[15] = 1,
                        this
                    }
                    decompose(t, n, i) {
                        const s = this.elements;
                        let a = Cp.set(s[0], s[1], s[2]).length();
                        const o = Cp.set(s[4], s[5], s[6]).length()
                          , c = Cp.set(s[8], s[9], s[10]).length();
                        this.determinant() < 0 && (a = -a),
                        t.x = s[12],
                        t.y = s[13],
                        t.z = s[14],
                        ll.copy(this);
                        const u = 1 / a
                          , f = 1 / o
                          , m = 1 / c;
                        return ll.elements[0] *= u,
                        ll.elements[1] *= u,
                        ll.elements[2] *= u,
                        ll.elements[4] *= f,
                        ll.elements[5] *= f,
                        ll.elements[6] *= f,
                        ll.elements[8] *= m,
                        ll.elements[9] *= m,
                        ll.elements[10] *= m,
                        n.setFromRotationMatrix(ll),
                        i.x = a,
                        i.y = o,
                        i.z = c,
                        this
                    }
                    makePerspective(t, n, i, s, a, o, c=Yr, u=!1) {
                        const f = this.elements
                          , m = 2 * a / (n - t)
                          , v = 2 * a / (i - s)
                          , y = (n + t) / (n - t)
                          , S = (i + s) / (i - s);
                        let A, M;
                        if (u)
                            A = a / (o - a),
                            M = o * a / (o - a);
                        else if (c === Yr)
                            A = -(o + a) / (o - a),
                            M = -2 * o * a / (o - a);
                        else if (c === yp)
                            A = -o / (o - a),
                            M = -o * a / (o - a);
                        else
                            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + c);
                        return f[0] = m,
                        f[4] = 0,
                        f[8] = y,
                        f[12] = 0,
                        f[1] = 0,
                        f[5] = v,
                        f[9] = S,
                        f[13] = 0,
                        f[2] = 0,
                        f[6] = 0,
                        f[10] = A,
                        f[14] = M,
                        f[3] = 0,
                        f[7] = 0,
                        f[11] = -1,
                        f[15] = 0,
                        this
                    }
                    makeOrthographic(t, n, i, s, a, o, c=Yr, u=!1) {
                        const f = this.elements
                          , m = 2 / (n - t)
                          , v = 2 / (i - s)
                          , y = -(n + t) / (n - t)
                          , S = -(i + s) / (i - s);
                        let A, M;
                        if (u)
                            A = 1 / (o - a),
                            M = o / (o - a);
                        else if (c === Yr)
                            A = -2 / (o - a),
                            M = -(o + a) / (o - a);
                        else if (c === yp)
                            A = -1 / (o - a),
                            M = -a / (o - a);
                        else
                            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + c);
                        return f[0] = m,
                        f[4] = 0,
                        f[8] = 0,
                        f[12] = y,
                        f[1] = 0,
                        f[5] = v,
                        f[9] = 0,
                        f[13] = S,
                        f[2] = 0,
                        f[6] = 0,
                        f[10] = A,
                        f[14] = M,
                        f[3] = 0,
                        f[7] = 0,
                        f[11] = 0,
                        f[15] = 1,
                        this
                    }
                    equals(t) {
                        const n = this.elements
                          , i = t.elements;
                        for (let s = 0; s < 16; s++)
                            if (n[s] !== i[s])
                                return !1;
                        return !0
                    }
                    fromArray(t, n=0) {
                        for (let i = 0; i < 16; i++)
                            this.elements[i] = t[i + n];
                        return this
                    }
                    toArray(t=[], n=0) {
                        const i = this.elements;
                        return t[n] = i[0],
                        t[n + 1] = i[1],
                        t[n + 2] = i[2],
                        t[n + 3] = i[3],
                        t[n + 4] = i[4],
                        t[n + 5] = i[5],
                        t[n + 6] = i[6],
                        t[n + 7] = i[7],
                        t[n + 8] = i[8],
                        t[n + 9] = i[9],
                        t[n + 10] = i[10],
                        t[n + 11] = i[11],
                        t[n + 12] = i[12],
                        t[n + 13] = i[13],
                        t[n + 14] = i[14],
                        t[n + 15] = i[15],
                        t
                    }
                }
                ;
                const Cp = new ae
                  , ll = new Xt
                  , qB = new ae(0,0,0)
                  , jB = new ae(1,1,1)
                  , uh = new ae
                  , R_ = new ae
                  , Qr = new ae
                  , bC = new Xt
                  , EC = new ia;
                var Co = class uU {
                    constructor(t=0, n=0, i=0, s=uU.DEFAULT_ORDER) {
                        this.isEuler = !0,
                        this._x = t,
                        this._y = n,
                        this._z = i,
                        this._order = s
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t,
                        this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(t) {
                        this._order = t,
                        this._onChangeCallback()
                    }
                    set(t, n, i, s=this._order) {
                        return this._x = t,
                        this._y = n,
                        this._z = i,
                        this._order = s,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._order)
                    }
                    copy(t) {
                        return this._x = t._x,
                        this._y = t._y,
                        this._z = t._z,
                        this._order = t._order,
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(t, n=this._order, i=!0) {
                        const s = t.elements
                          , a = s[0]
                          , o = s[4]
                          , c = s[8]
                          , u = s[1]
                          , f = s[5]
                          , m = s[9]
                          , v = s[2]
                          , y = s[6]
                          , S = s[10];
                        switch (n) {
                        case "XYZ":
                            this._y = Math.asin(Yt(c, -1, 1)),
                            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-m, S),
                            this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(y, f),
                            this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-Yt(m, -1, 1)),
                            Math.abs(m) < .9999999 ? (this._y = Math.atan2(c, S),
                            this._z = Math.atan2(u, f)) : (this._y = Math.atan2(-v, a),
                            this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(Yt(y, -1, 1)),
                            Math.abs(y) < .9999999 ? (this._y = Math.atan2(-v, S),
                            this._z = Math.atan2(-o, f)) : (this._y = 0,
                            this._z = Math.atan2(u, a));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-Yt(v, -1, 1)),
                            Math.abs(v) < .9999999 ? (this._x = Math.atan2(y, S),
                            this._z = Math.atan2(u, a)) : (this._x = 0,
                            this._z = Math.atan2(-o, f));
                            break;
                        case "YZX":
                            this._z = Math.asin(Yt(u, -1, 1)),
                            Math.abs(u) < .9999999 ? (this._x = Math.atan2(-m, f),
                            this._y = Math.atan2(-v, a)) : (this._x = 0,
                            this._y = Math.atan2(c, S));
                            break;
                        case "XZY":
                            this._z = Math.asin(-Yt(o, -1, 1)),
                            Math.abs(o) < .9999999 ? (this._x = Math.atan2(y, f),
                            this._y = Math.atan2(c, a)) : (this._x = Math.atan2(-m, S),
                            this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
                        }
                        return this._order = n,
                        i === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromQuaternion(t, n, i) {
                        return bC.makeRotationFromQuaternion(t),
                        this.setFromRotationMatrix(bC, n, i)
                    }
                    setFromVector3(t, n=this._order) {
                        return this.set(t.x, t.y, t.z, n)
                    }
                    reorder(t) {
                        return EC.setFromEuler(this),
                        this.setFromQuaternion(EC, t)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                    fromArray(t) {
                        return this._x = t[0],
                        this._y = t[1],
                        this._z = t[2],
                        t[3] !== void 0 && (this._order = t[3]),
                        this._onChangeCallback(),
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this._x,
                        t[n + 1] = this._y,
                        t[n + 2] = this._z,
                        t[n + 3] = this._order,
                        t
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._order
                    }
                }
                ;
                Co.DEFAULT_ORDER = "XYZ";
                var wp = class {
                    constructor() {
                        this.mask = 1
                    }
                    set(e) {
                        this.mask = (1 << e | 0) >>> 0
                    }
                    enable(e) {
                        this.mask |= 1 << e | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(e) {
                        this.mask ^= 1 << e | 0
                    }
                    disable(e) {
                        this.mask &= ~(1 << e | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(e) {
                        return (this.mask & e.mask) !== 0
                    }
                    isEnabled(e) {
                        return (this.mask & (1 << e | 0)) !== 0
                    }
                }
                ;
                let QB = 0;
                const CC = new ae
                  , Dp = new ia
                  , $c = new Xt
                  , U_ = new ae
                  , _g = new ae
                  , ZB = new ae
                  , KB = new ia
                  , wC = new ae(1,0,0)
                  , DC = new ae(0,1,0)
                  , RC = new ae(0,0,1)
                  , UC = {
                    type: "added"
                }
                  , JB = {
                    type: "removed"
                }
                  , Rp = {
                    type: "childadded",
                    child: null
                }
                  , FA = {
                    type: "childremoved",
                    child: null
                };
                var $n = class Tx extends qr {
                    constructor() {
                        super(),
                        this.isObject3D = !0,
                        Object.defineProperty(this, "id", {
                            value: QB++
                        }),
                        this.uuid = jr(),
                        this.name = "",
                        this.type = "Object3D",
                        this.parent = null,
                        this.children = [],
                        this.up = Tx.DEFAULT_UP.clone();
                        const t = new ae
                          , n = new Co
                          , i = new ia
                          , s = new ae(1,1,1);
                        function a() {
                            i.setFromEuler(n, !1)
                        }
                        function o() {
                            n.setFromQuaternion(i, void 0, !1)
                        }
                        n._onChange(a),
                        i._onChange(o),
                        Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: t
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: i
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: s
                            },
                            modelViewMatrix: {
                                value: new Xt
                            },
                            normalMatrix: {
                                value: new nn
                            }
                        }),
                        this.matrix = new Xt,
                        this.matrixWorld = new Xt,
                        this.matrixAutoUpdate = Tx.DEFAULT_MATRIX_AUTO_UPDATE,
                        this.matrixWorldAutoUpdate = Tx.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                        this.matrixWorldNeedsUpdate = !1,
                        this.layers = new wp,
                        this.visible = !0,
                        this.castShadow = !1,
                        this.receiveShadow = !1,
                        this.frustumCulled = !0,
                        this.renderOrder = 0,
                        this.animations = [],
                        this.customDepthMaterial = void 0,
                        this.customDistanceMaterial = void 0,
                        this.userData = {}
                    }
                    onBeforeShadow() {}
                    onAfterShadow() {}
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(t),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t),
                        this
                    }
                    setRotationFromAxisAngle(t, n) {
                        this.quaternion.setFromAxisAngle(t, n)
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0)
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t)
                    }
                    rotateOnAxis(t, n) {
                        return Dp.setFromAxisAngle(t, n),
                        this.quaternion.multiply(Dp),
                        this
                    }
                    rotateOnWorldAxis(t, n) {
                        return Dp.setFromAxisAngle(t, n),
                        this.quaternion.premultiply(Dp),
                        this
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(wC, t)
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(DC, t)
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(RC, t)
                    }
                    translateOnAxis(t, n) {
                        return CC.copy(t).applyQuaternion(this.quaternion),
                        this.position.add(CC.multiplyScalar(n)),
                        this
                    }
                    translateX(t) {
                        return this.translateOnAxis(wC, t)
                    }
                    translateY(t) {
                        return this.translateOnAxis(DC, t)
                    }
                    translateZ(t) {
                        return this.translateOnAxis(RC, t)
                    }
                    localToWorld(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.applyMatrix4($c.copy(this.matrixWorld).invert())
                    }
                    lookAt(t, n, i) {
                        t.isVector3 ? U_.copy(t) : U_.set(t, n, i);
                        const s = this.parent;
                        this.updateWorldMatrix(!0, !1),
                        _g.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? $c.lookAt(_g, U_, this.up) : $c.lookAt(U_, _g, this.up),
                        this.quaternion.setFromRotationMatrix($c),
                        s && ($c.extractRotation(s.matrixWorld),
                        Dp.setFromRotationMatrix($c),
                        this.quaternion.premultiply(Dp.invert()))
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let n = 0; n < arguments.length; n++)
                                this.add(arguments[n]);
                            return this
                        }
                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                        this) : (t && t.isObject3D ? (t.removeFromParent(),
                        t.parent = this,
                        this.children.push(t),
                        t.dispatchEvent(UC),
                        Rp.child = t,
                        this.dispatchEvent(Rp),
                        Rp.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                        this)
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let i = 0; i < arguments.length; i++)
                                this.remove(arguments[i]);
                            return this
                        }
                        const n = this.children.indexOf(t);
                        return n !== -1 && (t.parent = null,
                        this.children.splice(n, 1),
                        t.dispatchEvent(JB),
                        FA.child = t,
                        this.dispatchEvent(FA),
                        FA.child = null),
                        this
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return t !== null && t.remove(this),
                        this
                    }
                    clear() {
                        return this.remove(...this.children)
                    }
                    attach(t) {
                        return this.updateWorldMatrix(!0, !1),
                        $c.copy(this.matrixWorld).invert(),
                        t.parent !== null && (t.parent.updateWorldMatrix(!0, !1),
                        $c.multiply(t.parent.matrixWorld)),
                        t.applyMatrix4($c),
                        t.removeFromParent(),
                        t.parent = this,
                        this.children.push(t),
                        t.updateWorldMatrix(!1, !0),
                        t.dispatchEvent(UC),
                        Rp.child = t,
                        this.dispatchEvent(Rp),
                        Rp.child = null,
                        this
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t)
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t)
                    }
                    getObjectByProperty(t, n) {
                        if (this[t] === n)
                            return this;
                        for (let i = 0, s = this.children.length; i < s; i++) {
                            const a = this.children[i].getObjectByProperty(t, n);
                            if (a !== void 0)
                                return a
                        }
                    }
                    getObjectsByProperty(t, n, i=[]) {
                        this[t] === n && i.push(this);
                        const s = this.children;
                        for (let a = 0, o = s.length; a < o; a++)
                            s[a].getObjectsByProperty(t, n, i);
                        return i
                    }
                    getWorldPosition(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(t) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(_g, t, ZB),
                        t
                    }
                    getWorldScale(t) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(_g, KB, t),
                        t
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const n = this.matrixWorld.elements;
                        return t.set(n[8], n[9], n[10]).normalize()
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const n = this.children;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].traverse(t)
                    }
                    traverseVisible(t) {
                        if (this.visible === !1)
                            return;
                        t(this);
                        const n = this.children;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const n = this.parent;
                        n !== null && (t(n),
                        n.traverseAncestors(t))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        this.matrixWorldNeedsUpdate = !1,
                        t = !0);
                        const n = this.children;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].updateMatrixWorld(t)
                    }
                    updateWorldMatrix(t, n) {
                        const i = this.parent;
                        if (t === !0 && i !== null && i.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        n === !0) {
                            const s = this.children;
                            for (let a = 0, o = s.length; a < o; a++)
                                s[a].updateWorldMatrix(!1, !0)
                        }
                    }
                    toJSON(t) {
                        const n = t === void 0 || typeof t == "string"
                          , i = {};
                        n && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                            nodes: {}
                        },
                        i.metadata = {
                            version: 4.7,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const s = {};
                        s.uuid = this.uuid,
                        s.type = this.type,
                        this.name !== "" && (s.name = this.name),
                        this.castShadow === !0 && (s.castShadow = !0),
                        this.receiveShadow === !0 && (s.receiveShadow = !0),
                        this.visible === !1 && (s.visible = !1),
                        this.frustumCulled === !1 && (s.frustumCulled = !1),
                        this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
                        Object.keys(this.userData).length > 0 && (s.userData = this.userData),
                        s.layers = this.layers.mask,
                        s.matrix = this.matrix.toArray(),
                        s.up = this.up.toArray(),
                        this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
                        this.isInstancedMesh && (s.type = "InstancedMesh",
                        s.count = this.count,
                        s.instanceMatrix = this.instanceMatrix.toJSON(),
                        this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())),
                        this.isBatchedMesh && (s.type = "BatchedMesh",
                        s.perObjectFrustumCulled = this.perObjectFrustumCulled,
                        s.sortObjects = this.sortObjects,
                        s.drawRanges = this._drawRanges,
                        s.reservedRanges = this._reservedRanges,
                        s.geometryInfo = this._geometryInfo.map(c => ({
                            ...c,
                            boundingBox: c.boundingBox ? c.boundingBox.toJSON() : void 0,
                            boundingSphere: c.boundingSphere ? c.boundingSphere.toJSON() : void 0
                        })),
                        s.instanceInfo = this._instanceInfo.map(c => ({
                            ...c
                        })),
                        s.availableInstanceIds = this._availableInstanceIds.slice(),
                        s.availableGeometryIds = this._availableGeometryIds.slice(),
                        s.nextIndexStart = this._nextIndexStart,
                        s.nextVertexStart = this._nextVertexStart,
                        s.geometryCount = this._geometryCount,
                        s.maxInstanceCount = this._maxInstanceCount,
                        s.maxVertexCount = this._maxVertexCount,
                        s.maxIndexCount = this._maxIndexCount,
                        s.geometryInitialized = this._geometryInitialized,
                        s.matricesTexture = this._matricesTexture.toJSON(t),
                        s.indirectTexture = this._indirectTexture.toJSON(t),
                        this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(t)),
                        this.boundingSphere !== null && (s.boundingSphere = this.boundingSphere.toJSON()),
                        this.boundingBox !== null && (s.boundingBox = this.boundingBox.toJSON()));
                        function a(c, u) {
                            return c[u.uuid] === void 0 && (c[u.uuid] = u.toJSON(t)),
                            u.uuid
                        }
                        if (this.isScene)
                            this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(t).uuid)),
                            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            s.geometry = a(t.geometries, this.geometry);
                            const c = this.geometry.parameters;
                            if (c !== void 0 && c.shapes !== void 0) {
                                const u = c.shapes;
                                if (Array.isArray(u))
                                    for (let f = 0, m = u.length; f < m; f++) {
                                        const v = u[f];
                                        a(t.shapes, v)
                                    }
                                else
                                    a(t.shapes, u)
                            }
                        }
                        if (this.isSkinnedMesh && (s.bindMode = this.bindMode,
                        s.bindMatrix = this.bindMatrix.toArray(),
                        this.skeleton !== void 0 && (a(t.skeletons, this.skeleton),
                        s.skeleton = this.skeleton.uuid)),
                        this.material !== void 0)
                            if (Array.isArray(this.material)) {
                                const c = [];
                                for (let u = 0, f = this.material.length; u < f; u++)
                                    c.push(a(t.materials, this.material[u]));
                                s.material = c
                            } else
                                s.material = a(t.materials, this.material);
                        if (this.children.length > 0) {
                            s.children = [];
                            for (let c = 0; c < this.children.length; c++)
                                s.children.push(this.children[c].toJSON(t).object)
                        }
                        if (this.animations.length > 0) {
                            s.animations = [];
                            for (let c = 0; c < this.animations.length; c++) {
                                const u = this.animations[c];
                                s.animations.push(a(t.animations, u))
                            }
                        }
                        if (n) {
                            const c = o(t.geometries)
                              , u = o(t.materials)
                              , f = o(t.textures)
                              , m = o(t.images)
                              , v = o(t.shapes)
                              , y = o(t.skeletons)
                              , S = o(t.animations)
                              , A = o(t.nodes);
                            c.length > 0 && (i.geometries = c),
                            u.length > 0 && (i.materials = u),
                            f.length > 0 && (i.textures = f),
                            m.length > 0 && (i.images = m),
                            v.length > 0 && (i.shapes = v),
                            y.length > 0 && (i.skeletons = y),
                            S.length > 0 && (i.animations = S),
                            A.length > 0 && (i.nodes = A)
                        }
                        return i.object = s,
                        i;
                        function o(c) {
                            const u = [];
                            for (const f in c) {
                                const m = c[f];
                                delete m.metadata,
                                u.push(m)
                            }
                            return u
                        }
                    }
                    clone(t) {
                        return new this.constructor().copy(this, t)
                    }
                    copy(t, n=!0) {
                        if (this.name = t.name,
                        this.up.copy(t.up),
                        this.position.copy(t.position),
                        this.rotation.order = t.rotation.order,
                        this.quaternion.copy(t.quaternion),
                        this.scale.copy(t.scale),
                        this.matrix.copy(t.matrix),
                        this.matrixWorld.copy(t.matrixWorld),
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate,
                        this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                        this.layers.mask = t.layers.mask,
                        this.visible = t.visible,
                        this.castShadow = t.castShadow,
                        this.receiveShadow = t.receiveShadow,
                        this.frustumCulled = t.frustumCulled,
                        this.renderOrder = t.renderOrder,
                        this.animations = t.animations.slice(),
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        n === !0)
                            for (let i = 0; i < t.children.length; i++) {
                                const s = t.children[i];
                                this.add(s.clone())
                            }
                        return this
                    }
                }
                ;
                $n.DEFAULT_UP = new ae(0,1,0),
                $n.DEFAULT_MATRIX_AUTO_UPDATE = !0,
                $n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                const cl = new ae
                  , eu = new ae
                  , HA = new ae
                  , tu = new ae
                  , Up = new ae
                  , Op = new ae
                  , OC = new ae
                  , GA = new ae
                  , VA = new ae
                  , kA = new ae
                  , XA = new hn
                  , WA = new hn
                  , YA = new hn;
                var hh = class wm {
                    constructor(t=new ae, n=new ae, i=new ae) {
                        this.a = t,
                        this.b = n,
                        this.c = i
                    }
                    static getNormal(t, n, i, s) {
                        s.subVectors(i, n),
                        cl.subVectors(t, n),
                        s.cross(cl);
                        const a = s.lengthSq();
                        return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0)
                    }
                    static getBarycoord(t, n, i, s, a) {
                        cl.subVectors(s, n),
                        eu.subVectors(i, n),
                        HA.subVectors(t, n);
                        const o = cl.dot(cl)
                          , c = cl.dot(eu)
                          , u = cl.dot(HA)
                          , f = eu.dot(eu)
                          , m = eu.dot(HA)
                          , v = o * f - c * c;
                        if (v === 0)
                            return a.set(0, 0, 0),
                            null;
                        const y = 1 / v
                          , S = (f * u - c * m) * y
                          , A = (o * m - c * u) * y;
                        return a.set(1 - S - A, A, S)
                    }
                    static containsPoint(t, n, i, s) {
                        return this.getBarycoord(t, n, i, s, tu) === null ? !1 : tu.x >= 0 && tu.y >= 0 && tu.x + tu.y <= 1
                    }
                    static getInterpolation(t, n, i, s, a, o, c, u) {
                        return this.getBarycoord(t, n, i, s, tu) === null ? (u.x = 0,
                        u.y = 0,
                        "z"in u && (u.z = 0),
                        "w"in u && (u.w = 0),
                        null) : (u.setScalar(0),
                        u.addScaledVector(a, tu.x),
                        u.addScaledVector(o, tu.y),
                        u.addScaledVector(c, tu.z),
                        u)
                    }
                    static getInterpolatedAttribute(t, n, i, s, a, o) {
                        return XA.setScalar(0),
                        WA.setScalar(0),
                        YA.setScalar(0),
                        XA.fromBufferAttribute(t, n),
                        WA.fromBufferAttribute(t, i),
                        YA.fromBufferAttribute(t, s),
                        o.setScalar(0),
                        o.addScaledVector(XA, a.x),
                        o.addScaledVector(WA, a.y),
                        o.addScaledVector(YA, a.z),
                        o
                    }
                    static isFrontFacing(t, n, i, s) {
                        return cl.subVectors(i, n),
                        eu.subVectors(t, n),
                        cl.cross(eu).dot(s) < 0
                    }
                    set(t, n, i) {
                        return this.a.copy(t),
                        this.b.copy(n),
                        this.c.copy(i),
                        this
                    }
                    setFromPointsAndIndices(t, n, i, s) {
                        return this.a.copy(t[n]),
                        this.b.copy(t[i]),
                        this.c.copy(t[s]),
                        this
                    }
                    setFromAttributeAndIndices(t, n, i, s) {
                        return this.a.fromBufferAttribute(t, n),
                        this.b.fromBufferAttribute(t, i),
                        this.c.fromBufferAttribute(t, s),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.a.copy(t.a),
                        this.b.copy(t.b),
                        this.c.copy(t.c),
                        this
                    }
                    getArea() {
                        return cl.subVectors(this.c, this.b),
                        eu.subVectors(this.a, this.b),
                        cl.cross(eu).length() * .5
                    }
                    getMidpoint(t) {
                        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(t) {
                        return wm.getNormal(this.a, this.b, this.c, t)
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(t, n) {
                        return wm.getBarycoord(t, this.a, this.b, this.c, n)
                    }
                    getInterpolation(t, n, i, s, a) {
                        return wm.getInterpolation(t, this.a, this.b, this.c, n, i, s, a)
                    }
                    containsPoint(t) {
                        return wm.containsPoint(t, this.a, this.b, this.c)
                    }
                    isFrontFacing(t) {
                        return wm.isFrontFacing(this.a, this.b, this.c, t)
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this)
                    }
                    closestPointToPoint(t, n) {
                        const i = this.a
                          , s = this.b
                          , a = this.c;
                        let o, c;
                        Up.subVectors(s, i),
                        Op.subVectors(a, i),
                        GA.subVectors(t, i);
                        const u = Up.dot(GA)
                          , f = Op.dot(GA);
                        if (u <= 0 && f <= 0)
                            return n.copy(i);
                        VA.subVectors(t, s);
                        const m = Up.dot(VA)
                          , v = Op.dot(VA);
                        if (m >= 0 && v <= m)
                            return n.copy(s);
                        const y = u * v - m * f;
                        if (y <= 0 && u >= 0 && m <= 0)
                            return o = u / (u - m),
                            n.copy(i).addScaledVector(Up, o);
                        kA.subVectors(t, a);
                        const S = Up.dot(kA)
                          , A = Op.dot(kA);
                        if (A >= 0 && S <= A)
                            return n.copy(a);
                        const M = S * f - u * A;
                        if (M <= 0 && f >= 0 && A <= 0)
                            return c = f / (f - A),
                            n.copy(i).addScaledVector(Op, c);
                        const x = m * A - S * v;
                        if (x <= 0 && v - m >= 0 && S - A >= 0)
                            return OC.subVectors(a, s),
                            c = (v - m) / (v - m + (S - A)),
                            n.copy(s).addScaledVector(OC, c);
                        const T = 1 / (x + M + y);
                        return o = M * T,
                        c = y * T,
                        n.copy(i).addScaledVector(Up, o).addScaledVector(Op, c)
                    }
                    equals(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }
                ;
                const NC = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                }
                  , fh = {
                    h: 0,
                    s: 0,
                    l: 0
                }
                  , O_ = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                function qA(e, t, n) {
                    return n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e
                }
                var ft = class {
                    constructor(e, t, n) {
                        return this.isColor = !0,
                        this.r = 1,
                        this.g = 1,
                        this.b = 1,
                        this.set(e, t, n)
                    }
                    set(e, t, n) {
                        if (t === void 0 && n === void 0) {
                            const i = e;
                            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
                        } else
                            this.setRGB(e, t, n);
                        return this
                    }
                    setScalar(e) {
                        return this.r = e,
                        this.g = e,
                        this.b = e,
                        this
                    }
                    setHex(e, t=Zt) {
                        return e = Math.floor(e),
                        this.r = (e >> 16 & 255) / 255,
                        this.g = (e >> 8 & 255) / 255,
                        this.b = (e & 255) / 255,
                        Rn.colorSpaceToWorking(this, t),
                        this
                    }
                    setRGB(e, t, n, i=Rn.workingColorSpace) {
                        return this.r = e,
                        this.g = t,
                        this.b = n,
                        Rn.colorSpaceToWorking(this, i),
                        this
                    }
                    setHSL(e, t, n, i=Rn.workingColorSpace) {
                        if (e = wA(e, 1),
                        t = Yt(t, 0, 1),
                        n = Yt(n, 0, 1),
                        t === 0)
                            this.r = this.g = this.b = n;
                        else {
                            const s = n <= .5 ? n * (1 + t) : n + t - n * t
                              , a = 2 * n - s;
                            this.r = qA(a, s, e + 1 / 3),
                            this.g = qA(a, s, e),
                            this.b = qA(a, s, e - 1 / 3)
                        }
                        return Rn.colorSpaceToWorking(this, i),
                        this
                    }
                    setStyle(e, t=Zt) {
                        function n(s) {
                            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                        }
                        let i;
                        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                            let s;
                            const a = i[1]
                              , o = i[2];
                            switch (a) {
                            case "rgb":
                            case "rgba":
                                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                                    return n(s[4]),
                                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                                    return n(s[4]),
                                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                                break;
                            case "hsl":
                            case "hsla":
                                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                                    return n(s[4]),
                                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                                break;
                            default:
                                console.warn("THREE.Color: Unknown color model " + e)
                            }
                        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                            const s = i[1]
                              , a = s.length;
                            if (a === 3)
                                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
                            if (a === 6)
                                return this.setHex(parseInt(s, 16), t);
                            console.warn("THREE.Color: Invalid hex color " + e)
                        } else if (e && e.length > 0)
                            return this.setColorName(e, t);
                        return this
                    }
                    setColorName(e, t=Zt) {
                        const n = NC[e.toLowerCase()];
                        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                        this
                    }
                    clone() {
                        return new this.constructor(this.r,this.g,this.b)
                    }
                    copy(e) {
                        return this.r = e.r,
                        this.g = e.g,
                        this.b = e.b,
                        this
                    }
                    copySRGBToLinear(e) {
                        return this.r = Zc(e.r),
                        this.g = Zc(e.g),
                        this.b = Zc(e.b),
                        this
                    }
                    copyLinearToSRGB(e) {
                        return this.r = xp(e.r),
                        this.g = xp(e.g),
                        this.b = xp(e.b),
                        this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this),
                        this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this),
                        this
                    }
                    getHex(e=Zt) {
                        return Rn.workingToColorSpace(Ma.copy(this), e),
                        Math.round(Yt(Ma.r * 255, 0, 255)) * 65536 + Math.round(Yt(Ma.g * 255, 0, 255)) * 256 + Math.round(Yt(Ma.b * 255, 0, 255))
                    }
                    getHexString(e=Zt) {
                        return ("000000" + this.getHex(e).toString(16)).slice(-6)
                    }
                    getHSL(e, t=Rn.workingColorSpace) {
                        Rn.workingToColorSpace(Ma.copy(this), t);
                        const n = Ma.r
                          , i = Ma.g
                          , s = Ma.b
                          , a = Math.max(n, i, s)
                          , o = Math.min(n, i, s);
                        let c, u;
                        const f = (o + a) / 2;
                        if (o === a)
                            c = 0,
                            u = 0;
                        else {
                            const m = a - o;
                            switch (u = f <= .5 ? m / (a + o) : m / (2 - a - o),
                            a) {
                            case n:
                                c = (i - s) / m + (i < s ? 6 : 0);
                                break;
                            case i:
                                c = (s - n) / m + 2;
                                break;
                            case s:
                                c = (n - i) / m + 4;
                                break
                            }
                            c /= 6
                        }
                        return e.h = c,
                        e.s = u,
                        e.l = f,
                        e
                    }
                    getRGB(e, t=Rn.workingColorSpace) {
                        return Rn.workingToColorSpace(Ma.copy(this), t),
                        e.r = Ma.r,
                        e.g = Ma.g,
                        e.b = Ma.b,
                        e
                    }
                    getStyle(e=Zt) {
                        Rn.workingToColorSpace(Ma.copy(this), e);
                        const t = Ma.r
                          , n = Ma.g
                          , i = Ma.b;
                        return e !== Zt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
                    }
                    offsetHSL(e, t, n) {
                        return this.getHSL(fh),
                        this.setHSL(fh.h + e, fh.s + t, fh.l + n)
                    }
                    add(e) {
                        return this.r += e.r,
                        this.g += e.g,
                        this.b += e.b,
                        this
                    }
                    addColors(e, t) {
                        return this.r = e.r + t.r,
                        this.g = e.g + t.g,
                        this.b = e.b + t.b,
                        this
                    }
                    addScalar(e) {
                        return this.r += e,
                        this.g += e,
                        this.b += e,
                        this
                    }
                    sub(e) {
                        return this.r = Math.max(0, this.r - e.r),
                        this.g = Math.max(0, this.g - e.g),
                        this.b = Math.max(0, this.b - e.b),
                        this
                    }
                    multiply(e) {
                        return this.r *= e.r,
                        this.g *= e.g,
                        this.b *= e.b,
                        this
                    }
                    multiplyScalar(e) {
                        return this.r *= e,
                        this.g *= e,
                        this.b *= e,
                        this
                    }
                    lerp(e, t) {
                        return this.r += (e.r - this.r) * t,
                        this.g += (e.g - this.g) * t,
                        this.b += (e.b - this.b) * t,
                        this
                    }
                    lerpColors(e, t, n) {
                        return this.r = e.r + (t.r - e.r) * n,
                        this.g = e.g + (t.g - e.g) * n,
                        this.b = e.b + (t.b - e.b) * n,
                        this
                    }
                    lerpHSL(e, t) {
                        this.getHSL(fh),
                        e.getHSL(O_);
                        const n = pg(fh.h, O_.h, t)
                          , i = pg(fh.s, O_.s, t)
                          , s = pg(fh.l, O_.l, t);
                        return this.setHSL(n, i, s),
                        this
                    }
                    setFromVector3(e) {
                        return this.r = e.x,
                        this.g = e.y,
                        this.b = e.z,
                        this
                    }
                    applyMatrix3(e) {
                        const t = this.r
                          , n = this.g
                          , i = this.b
                          , s = e.elements;
                        return this.r = s[0] * t + s[3] * n + s[6] * i,
                        this.g = s[1] * t + s[4] * n + s[7] * i,
                        this.b = s[2] * t + s[5] * n + s[8] * i,
                        this
                    }
                    equals(e) {
                        return e.r === this.r && e.g === this.g && e.b === this.b
                    }
                    fromArray(e, t=0) {
                        return this.r = e[t],
                        this.g = e[t + 1],
                        this.b = e[t + 2],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.r,
                        e[t + 1] = this.g,
                        e[t + 2] = this.b,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this.r = e.getX(t),
                        this.g = e.getY(t),
                        this.b = e.getZ(t),
                        this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                    *[Symbol.iterator]() {
                        yield this.r,
                        yield this.g,
                        yield this.b
                    }
                }
                ;
                const Ma = new ft;
                ft.NAMES = NC;
                let $B = 0;
                var qs = class extends qr {
                    constructor() {
                        super(),
                        this.isMaterial = !0,
                        Object.defineProperty(this, "id", {
                            value: $B++
                        }),
                        this.uuid = jr(),
                        this.name = "",
                        this.type = "Material",
                        this.blending = uf,
                        this.side = ic,
                        this.vertexColors = !1,
                        this.opacity = 1,
                        this.transparent = !1,
                        this.alphaHash = !1,
                        this.blendSrc = Py,
                        this.blendDst = zy,
                        this.blendEquation = th,
                        this.blendSrcAlpha = null,
                        this.blendDstAlpha = null,
                        this.blendEquationAlpha = null,
                        this.blendColor = new ft(0,0,0),
                        this.blendAlpha = 0,
                        this.depthFunc = nh,
                        this.depthTest = !0,
                        this.depthWrite = !0,
                        this.stencilWriteMask = 255,
                        this.stencilFunc = bA,
                        this.stencilRef = 0,
                        this.stencilFuncMask = 255,
                        this.stencilFail = gf,
                        this.stencilZFail = gf,
                        this.stencilZPass = gf,
                        this.stencilWrite = !1,
                        this.clippingPlanes = null,
                        this.clipIntersection = !1,
                        this.clipShadows = !1,
                        this.shadowSide = null,
                        this.colorWrite = !0,
                        this.precision = null,
                        this.polygonOffset = !1,
                        this.polygonOffsetFactor = 0,
                        this.polygonOffsetUnits = 0,
                        this.dithering = !1,
                        this.alphaToCoverage = !1,
                        this.premultipliedAlpha = !1,
                        this.forceSinglePass = !1,
                        this.allowOverride = !0,
                        this.visible = !0,
                        this.toneMapped = !0,
                        this.userData = {},
                        this.version = 0,
                        this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(e) {
                        this._alphaTest > 0 != e > 0 && this.version++,
                        this._alphaTest = e
                    }
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(e) {
                        if (e !== void 0)
                            for (const t in e) {
                                const n = e[t];
                                if (n === void 0) {
                                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                                    continue
                                }
                                const i = this[t];
                                if (i === void 0) {
                                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                                    continue
                                }
                                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                            }
                    }
                    toJSON(e) {
                        const t = e === void 0 || typeof e == "string";
                        t && (e = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.7,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        n.uuid = this.uuid,
                        n.type = this.type,
                        this.name !== "" && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        this.roughness !== void 0 && (n.roughness = this.roughness),
                        this.metalness !== void 0 && (n.metalness = this.metalness),
                        this.sheen !== void 0 && (n.sheen = this.sheen),
                        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
                        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                        this.shininess !== void 0 && (n.shininess = this.shininess),
                        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
                        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                        this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
                        this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
                        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
                        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
                        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
                        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
                        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
                        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                        n.lightMapIntensity = this.lightMapIntensity),
                        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                        n.aoMapIntensity = this.aoMapIntensity),
                        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                        n.bumpScale = this.bumpScale),
                        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                        n.normalMapType = this.normalMapType,
                        n.normalScale = this.normalScale.toArray()),
                        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                        n.displacementScale = this.displacementScale,
                        n.displacementBias = this.displacementBias),
                        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                        this.combine !== void 0 && (n.combine = this.combine)),
                        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
                        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
                        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
                        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
                        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                        this.transmission !== void 0 && (n.transmission = this.transmission),
                        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                        this.thickness !== void 0 && (n.thickness = this.thickness),
                        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
                        this.size !== void 0 && (n.size = this.size),
                        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
                        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== uf && (n.blending = this.blending),
                        this.side !== ic && (n.side = this.side),
                        this.vertexColors === !0 && (n.vertexColors = !0),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        this.transparent === !0 && (n.transparent = !0),
                        this.blendSrc !== Py && (n.blendSrc = this.blendSrc),
                        this.blendDst !== zy && (n.blendDst = this.blendDst),
                        this.blendEquation !== th && (n.blendEquation = this.blendEquation),
                        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
                        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
                        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
                        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
                        this.depthFunc !== nh && (n.depthFunc = this.depthFunc),
                        this.depthTest === !1 && (n.depthTest = this.depthTest),
                        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
                        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
                        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
                        this.stencilFunc !== bA && (n.stencilFunc = this.stencilFunc),
                        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
                        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
                        this.stencilFail !== gf && (n.stencilFail = this.stencilFail),
                        this.stencilZFail !== gf && (n.stencilZFail = this.stencilZFail),
                        this.stencilZPass !== gf && (n.stencilZPass = this.stencilZPass),
                        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
                        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
                        this.polygonOffset === !0 && (n.polygonOffset = !0),
                        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
                        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
                        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
                        this.scale !== void 0 && (n.scale = this.scale),
                        this.dithering === !0 && (n.dithering = !0),
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        this.alphaHash === !0 && (n.alphaHash = !0),
                        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
                        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
                        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
                        this.wireframe === !0 && (n.wireframe = !0),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
                        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
                        this.flatShading === !0 && (n.flatShading = !0),
                        this.visible === !1 && (n.visible = !1),
                        this.toneMapped === !1 && (n.toneMapped = !1),
                        this.fog === !1 && (n.fog = !1),
                        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
                        function i(s) {
                            const a = [];
                            for (const o in s) {
                                const c = s[o];
                                delete c.metadata,
                                a.push(c)
                            }
                            return a
                        }
                        if (t) {
                            const s = i(e.textures)
                              , a = i(e.images);
                            s.length > 0 && (n.textures = s),
                            a.length > 0 && (n.images = a)
                        }
                        return n
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.name = e.name,
                        this.blending = e.blending,
                        this.side = e.side,
                        this.vertexColors = e.vertexColors,
                        this.opacity = e.opacity,
                        this.transparent = e.transparent,
                        this.blendSrc = e.blendSrc,
                        this.blendDst = e.blendDst,
                        this.blendEquation = e.blendEquation,
                        this.blendSrcAlpha = e.blendSrcAlpha,
                        this.blendDstAlpha = e.blendDstAlpha,
                        this.blendEquationAlpha = e.blendEquationAlpha,
                        this.blendColor.copy(e.blendColor),
                        this.blendAlpha = e.blendAlpha,
                        this.depthFunc = e.depthFunc,
                        this.depthTest = e.depthTest,
                        this.depthWrite = e.depthWrite,
                        this.stencilWriteMask = e.stencilWriteMask,
                        this.stencilFunc = e.stencilFunc,
                        this.stencilRef = e.stencilRef,
                        this.stencilFuncMask = e.stencilFuncMask,
                        this.stencilFail = e.stencilFail,
                        this.stencilZFail = e.stencilZFail,
                        this.stencilZPass = e.stencilZPass,
                        this.stencilWrite = e.stencilWrite;
                        const t = e.clippingPlanes;
                        let n = null;
                        if (t !== null) {
                            const i = t.length;
                            n = new Array(i);
                            for (let s = 0; s !== i; ++s)
                                n[s] = t[s].clone()
                        }
                        return this.clippingPlanes = n,
                        this.clipIntersection = e.clipIntersection,
                        this.clipShadows = e.clipShadows,
                        this.shadowSide = e.shadowSide,
                        this.colorWrite = e.colorWrite,
                        this.precision = e.precision,
                        this.polygonOffset = e.polygonOffset,
                        this.polygonOffsetFactor = e.polygonOffsetFactor,
                        this.polygonOffsetUnits = e.polygonOffsetUnits,
                        this.dithering = e.dithering,
                        this.alphaTest = e.alphaTest,
                        this.alphaHash = e.alphaHash,
                        this.alphaToCoverage = e.alphaToCoverage,
                        this.premultipliedAlpha = e.premultipliedAlpha,
                        this.forceSinglePass = e.forceSinglePass,
                        this.visible = e.visible,
                        this.toneMapped = e.toneMapped,
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                }
                  , nu = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshBasicMaterial = !0,
                        this.type = "MeshBasicMaterial",
                        this.color = new ft(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new Co,
                        this.combine = tg,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const iu = eL();
                function eL() {
                    const e = new ArrayBuffer(4)
                      , t = new Float32Array(e)
                      , n = new Uint32Array(e)
                      , i = new Uint32Array(512)
                      , s = new Uint32Array(512);
                    for (let u = 0; u < 256; ++u) {
                        const f = u - 127;
                        f < -27 ? (i[u] = 0,
                        i[u | 256] = 32768,
                        s[u] = 24,
                        s[u | 256] = 24) : f < -14 ? (i[u] = 1024 >> -f - 14,
                        i[u | 256] = 1024 >> -f - 14 | 32768,
                        s[u] = -f - 1,
                        s[u | 256] = -f - 1) : f <= 15 ? (i[u] = f + 15 << 10,
                        i[u | 256] = f + 15 << 10 | 32768,
                        s[u] = 13,
                        s[u | 256] = 13) : f < 128 ? (i[u] = 31744,
                        i[u | 256] = 64512,
                        s[u] = 24,
                        s[u | 256] = 24) : (i[u] = 31744,
                        i[u | 256] = 64512,
                        s[u] = 13,
                        s[u | 256] = 13)
                    }
                    const a = new Uint32Array(2048)
                      , o = new Uint32Array(64)
                      , c = new Uint32Array(64);
                    for (let u = 1; u < 1024; ++u) {
                        let f = u << 13
                          , m = 0;
                        for (; (f & 8388608) === 0; )
                            f <<= 1,
                            m -= 8388608;
                        f &= -8388609,
                        m += 947912704,
                        a[u] = f | m
                    }
                    for (let u = 1024; u < 2048; ++u)
                        a[u] = 939524096 + (u - 1024 << 13);
                    for (let u = 1; u < 31; ++u)
                        o[u] = u << 23;
                    o[31] = 1199570944,
                    o[32] = 2147483648;
                    for (let u = 33; u < 63; ++u)
                        o[u] = 2147483648 + (u - 32 << 23);
                    o[63] = 3347054592;
                    for (let u = 1; u < 64; ++u)
                        u !== 32 && (c[u] = 1024);
                    return {
                        floatView: t,
                        uint32View: n,
                        baseTable: i,
                        shiftTable: s,
                        mantissaTable: a,
                        exponentTable: o,
                        offsetTable: c
                    }
                }
                function Sr(e) {
                    Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
                    e = Yt(e, -65504, 65504),
                    iu.floatView[0] = e;
                    const t = iu.uint32View[0]
                      , n = t >> 23 & 511;
                    return iu.baseTable[n] + ((t & 8388607) >> iu.shiftTable[n])
                }
                function Sg(e) {
                    const t = e >> 10;
                    return iu.uint32View[0] = iu.mantissaTable[iu.offsetTable[t] + (e & 1023)] + iu.exponentTable[t],
                    iu.floatView[0]
                }
                var tL = class {
                    static toHalfFloat(e) {
                        return Sr(e)
                    }
                    static fromHalfFloat(e) {
                        return Sg(e)
                    }
                }
                ;
                const ms = new ae
                  , N_ = new Oe;
                let nL = 0;
                var Ln = class {
                    constructor(e, t, n=!1) {
                        if (Array.isArray(e))
                            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0,
                        Object.defineProperty(this, "id", {
                            value: nL++
                        }),
                        this.name = "",
                        this.array = e,
                        this.itemSize = t,
                        this.count = e !== void 0 ? e.length / t : 0,
                        this.normalized = n,
                        this.usage = dg,
                        this.updateRanges = [],
                        this.gpuType = na,
                        this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    addUpdateRange(e, t) {
                        this.updateRanges.push({
                            start: e,
                            count: t
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(e) {
                        return this.name = e.name,
                        this.array = new e.array.constructor(e.array),
                        this.itemSize = e.itemSize,
                        this.count = e.count,
                        this.normalized = e.normalized,
                        this.usage = e.usage,
                        this.gpuType = e.gpuType,
                        this
                    }
                    copyAt(e, t, n) {
                        e *= this.itemSize,
                        n *= t.itemSize;
                        for (let i = 0, s = this.itemSize; i < s; i++)
                            this.array[e + i] = t.array[n + i];
                        return this
                    }
                    copyArray(e) {
                        return this.array.set(e),
                        this
                    }
                    applyMatrix3(e) {
                        if (this.itemSize === 2)
                            for (let t = 0, n = this.count; t < n; t++)
                                N_.fromBufferAttribute(this, t),
                                N_.applyMatrix3(e),
                                this.setXY(t, N_.x, N_.y);
                        else if (this.itemSize === 3)
                            for (let t = 0, n = this.count; t < n; t++)
                                ms.fromBufferAttribute(this, t),
                                ms.applyMatrix3(e),
                                this.setXYZ(t, ms.x, ms.y, ms.z);
                        return this
                    }
                    applyMatrix4(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            ms.fromBufferAttribute(this, t),
                            ms.applyMatrix4(e),
                            this.setXYZ(t, ms.x, ms.y, ms.z);
                        return this
                    }
                    applyNormalMatrix(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            ms.fromBufferAttribute(this, t),
                            ms.applyNormalMatrix(e),
                            this.setXYZ(t, ms.x, ms.y, ms.z);
                        return this
                    }
                    transformDirection(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            ms.fromBufferAttribute(this, t),
                            ms.transformDirection(e),
                            this.setXYZ(t, ms.x, ms.y, ms.z);
                        return this
                    }
                    set(e, t=0) {
                        return this.array.set(e, t),
                        this
                    }
                    getComponent(e, t) {
                        let n = this.array[e * this.itemSize + t];
                        return this.normalized && (n = er(n, this.array)),
                        n
                    }
                    setComponent(e, t, n) {
                        return this.normalized && (n = tn(n, this.array)),
                        this.array[e * this.itemSize + t] = n,
                        this
                    }
                    getX(e) {
                        let t = this.array[e * this.itemSize];
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setX(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize] = t,
                        this
                    }
                    getY(e) {
                        let t = this.array[e * this.itemSize + 1];
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setY(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize + 1] = t,
                        this
                    }
                    getZ(e) {
                        let t = this.array[e * this.itemSize + 2];
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setZ(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize + 2] = t,
                        this
                    }
                    getW(e) {
                        let t = this.array[e * this.itemSize + 3];
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setW(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize + 3] = t,
                        this
                    }
                    setXY(e, t, n) {
                        return e *= this.itemSize,
                        this.normalized && (t = tn(t, this.array),
                        n = tn(n, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this
                    }
                    setXYZ(e, t, n, i) {
                        return e *= this.itemSize,
                        this.normalized && (t = tn(t, this.array),
                        n = tn(n, this.array),
                        i = tn(i, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = i,
                        this
                    }
                    setXYZW(e, t, n, i, s) {
                        return e *= this.itemSize,
                        this.normalized && (t = tn(t, this.array),
                        n = tn(n, this.array),
                        i = tn(i, this.array),
                        s = tn(s, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = i,
                        this.array[e + 3] = s,
                        this
                    }
                    onUpload(e) {
                        return this.onUploadCallback = e,
                        this
                    }
                    clone() {
                        return new this.constructor(this.array,this.itemSize).copy(this)
                    }
                    toJSON() {
                        const e = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        return this.name !== "" && (e.name = this.name),
                        this.usage !== dg && (e.usage = this.usage),
                        e
                    }
                }
                  , iL = class extends Ln {
                    constructor(e, t, n) {
                        super(new Int8Array(e), t, n)
                    }
                }
                  , sL = class extends Ln {
                    constructor(e, t, n) {
                        super(new Uint8Array(e), t, n)
                    }
                }
                  , aL = class extends Ln {
                    constructor(e, t, n) {
                        super(new Uint8ClampedArray(e), t, n)
                    }
                }
                  , rL = class extends Ln {
                    constructor(e, t, n) {
                        super(new Int16Array(e), t, n)
                    }
                }
                  , jA = class extends Ln {
                    constructor(e, t, n) {
                        super(new Uint16Array(e), t, n)
                    }
                }
                  , oL = class extends Ln {
                    constructor(e, t, n) {
                        super(new Int32Array(e), t, n)
                    }
                }
                  , QA = class extends Ln {
                    constructor(e, t, n) {
                        super(new Uint32Array(e), t, n)
                    }
                }
                  , lL = class extends Ln {
                    constructor(e, t, n) {
                        super(new Uint16Array(e), t, n),
                        this.isFloat16BufferAttribute = !0
                    }
                    getX(e) {
                        let t = Sg(this.array[e * this.itemSize]);
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setX(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize] = Sr(t),
                        this
                    }
                    getY(e) {
                        let t = Sg(this.array[e * this.itemSize + 1]);
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setY(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize + 1] = Sr(t),
                        this
                    }
                    getZ(e) {
                        let t = Sg(this.array[e * this.itemSize + 2]);
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setZ(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize + 2] = Sr(t),
                        this
                    }
                    getW(e) {
                        let t = Sg(this.array[e * this.itemSize + 3]);
                        return this.normalized && (t = er(t, this.array)),
                        t
                    }
                    setW(e, t) {
                        return this.normalized && (t = tn(t, this.array)),
                        this.array[e * this.itemSize + 3] = Sr(t),
                        this
                    }
                    setXY(e, t, n) {
                        return e *= this.itemSize,
                        this.normalized && (t = tn(t, this.array),
                        n = tn(n, this.array)),
                        this.array[e + 0] = Sr(t),
                        this.array[e + 1] = Sr(n),
                        this
                    }
                    setXYZ(e, t, n, i) {
                        return e *= this.itemSize,
                        this.normalized && (t = tn(t, this.array),
                        n = tn(n, this.array),
                        i = tn(i, this.array)),
                        this.array[e + 0] = Sr(t),
                        this.array[e + 1] = Sr(n),
                        this.array[e + 2] = Sr(i),
                        this
                    }
                    setXYZW(e, t, n, i, s) {
                        return e *= this.itemSize,
                        this.normalized && (t = tn(t, this.array),
                        n = tn(n, this.array),
                        i = tn(i, this.array),
                        s = tn(s, this.array)),
                        this.array[e + 0] = Sr(t),
                        this.array[e + 1] = Sr(n),
                        this.array[e + 2] = Sr(i),
                        this.array[e + 3] = Sr(s),
                        this
                    }
                }
                  , Rt = class extends Ln {
                    constructor(e, t, n) {
                        super(new Float32Array(e), t, n)
                    }
                }
                ;
                let cL = 0;
                const wo = new Xt
                  , ZA = new $n
                  , Np = new ae
                  , Zr = new Ws
                  , xg = new Ws
                  , js = new ae;
                var sn = class hU extends qr {
                    constructor() {
                        super(),
                        this.isBufferGeometry = !0,
                        Object.defineProperty(this, "id", {
                            value: cL++
                        }),
                        this.uuid = jr(),
                        this.name = "",
                        this.type = "BufferGeometry",
                        this.index = null,
                        this.indirect = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.morphTargetsRelative = !1,
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        },
                        this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(t) {
                        return Array.isArray(t) ? this.index = new (_C(t) ? QA : jA)(t,1) : this.index = t,
                        this
                    }
                    setIndirect(t) {
                        return this.indirect = t,
                        this
                    }
                    getIndirect() {
                        return this.indirect
                    }
                    getAttribute(t) {
                        return this.attributes[t]
                    }
                    setAttribute(t, n) {
                        return this.attributes[t] = n,
                        this
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t],
                        this
                    }
                    hasAttribute(t) {
                        return this.attributes[t] !== void 0
                    }
                    addGroup(t, n, i=0) {
                        this.groups.push({
                            start: t,
                            count: n,
                            materialIndex: i
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(t, n) {
                        this.drawRange.start = t,
                        this.drawRange.count = n
                    }
                    applyMatrix4(t) {
                        const n = this.attributes.position;
                        n !== void 0 && (n.applyMatrix4(t),
                        n.needsUpdate = !0);
                        const i = this.attributes.normal;
                        if (i !== void 0) {
                            const a = new nn().getNormalMatrix(t);
                            i.applyNormalMatrix(a),
                            i.needsUpdate = !0
                        }
                        const s = this.attributes.tangent;
                        return s !== void 0 && (s.transformDirection(t),
                        s.needsUpdate = !0),
                        this.boundingBox !== null && this.computeBoundingBox(),
                        this.boundingSphere !== null && this.computeBoundingSphere(),
                        this
                    }
                    applyQuaternion(t) {
                        return wo.makeRotationFromQuaternion(t),
                        this.applyMatrix4(wo),
                        this
                    }
                    rotateX(t) {
                        return wo.makeRotationX(t),
                        this.applyMatrix4(wo),
                        this
                    }
                    rotateY(t) {
                        return wo.makeRotationY(t),
                        this.applyMatrix4(wo),
                        this
                    }
                    rotateZ(t) {
                        return wo.makeRotationZ(t),
                        this.applyMatrix4(wo),
                        this
                    }
                    translate(t, n, i) {
                        return wo.makeTranslation(t, n, i),
                        this.applyMatrix4(wo),
                        this
                    }
                    scale(t, n, i) {
                        return wo.makeScale(t, n, i),
                        this.applyMatrix4(wo),
                        this
                    }
                    lookAt(t) {
                        return ZA.lookAt(t),
                        ZA.updateMatrix(),
                        this.applyMatrix4(ZA.matrix),
                        this
                    }
                    center() {
                        return this.computeBoundingBox(),
                        this.boundingBox.getCenter(Np).negate(),
                        this.translate(Np.x, Np.y, Np.z),
                        this
                    }
                    setFromPoints(t) {
                        const n = this.getAttribute("position");
                        if (n === void 0) {
                            const i = [];
                            for (let s = 0, a = t.length; s < a; s++) {
                                const o = t[s];
                                i.push(o.x, o.y, o.z || 0)
                            }
                            this.setAttribute("position", new Rt(i,3))
                        } else {
                            const i = Math.min(t.length, n.count);
                            for (let s = 0; s < i; s++) {
                                const a = t[s];
                                n.setXYZ(s, a.x, a.y, a.z || 0)
                            }
                            t.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                            n.needsUpdate = !0
                        }
                        return this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new Ws);
                        const t = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) {
                            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                            this.boundingBox.set(new ae(-1 / 0,-1 / 0,-1 / 0), new ae(1 / 0,1 / 0,1 / 0));
                            return
                        }
                        if (t !== void 0) {
                            if (this.boundingBox.setFromBufferAttribute(t),
                            n)
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const a = n[i];
                                    Zr.setFromBufferAttribute(a),
                                    this.morphTargetsRelative ? (js.addVectors(this.boundingBox.min, Zr.min),
                                    this.boundingBox.expandByPoint(js),
                                    js.addVectors(this.boundingBox.max, Zr.max),
                                    this.boundingBox.expandByPoint(js)) : (this.boundingBox.expandByPoint(Zr.min),
                                    this.boundingBox.expandByPoint(Zr.max))
                                }
                        } else
                            this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new Ys);
                        const t = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) {
                            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                            this.boundingSphere.set(new ae, 1 / 0);
                            return
                        }
                        if (t) {
                            const i = this.boundingSphere.center;
                            if (Zr.setFromBufferAttribute(t),
                            n)
                                for (let a = 0, o = n.length; a < o; a++) {
                                    const c = n[a];
                                    xg.setFromBufferAttribute(c),
                                    this.morphTargetsRelative ? (js.addVectors(Zr.min, xg.min),
                                    Zr.expandByPoint(js),
                                    js.addVectors(Zr.max, xg.max),
                                    Zr.expandByPoint(js)) : (Zr.expandByPoint(xg.min),
                                    Zr.expandByPoint(xg.max))
                                }
                            Zr.getCenter(i);
                            let s = 0;
                            for (let a = 0, o = t.count; a < o; a++)
                                js.fromBufferAttribute(t, a),
                                s = Math.max(s, i.distanceToSquared(js));
                            if (n)
                                for (let a = 0, o = n.length; a < o; a++) {
                                    const c = n[a]
                                      , u = this.morphTargetsRelative;
                                    for (let f = 0, m = c.count; f < m; f++)
                                        js.fromBufferAttribute(c, f),
                                        u && (Np.fromBufferAttribute(t, f),
                                        js.add(Np)),
                                        s = Math.max(s, i.distanceToSquared(js))
                                }
                            this.boundingSphere.radius = Math.sqrt(s),
                            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const t = this.index
                          , n = this.attributes;
                        if (t === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
                            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            return
                        }
                        const i = n.position
                          , s = n.normal
                          , a = n.uv;
                        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ln(new Float32Array(4 * i.count),4));
                        const o = this.getAttribute("tangent")
                          , c = []
                          , u = [];
                        for (let z = 0; z < i.count; z++)
                            c[z] = new ae,
                            u[z] = new ae;
                        const f = new ae
                          , m = new ae
                          , v = new ae
                          , y = new Oe
                          , S = new Oe
                          , A = new Oe
                          , M = new ae
                          , x = new ae;
                        function T(z, I, B) {
                            f.fromBufferAttribute(i, z),
                            m.fromBufferAttribute(i, I),
                            v.fromBufferAttribute(i, B),
                            y.fromBufferAttribute(a, z),
                            S.fromBufferAttribute(a, I),
                            A.fromBufferAttribute(a, B),
                            m.sub(f),
                            v.sub(f),
                            S.sub(y),
                            A.sub(y);
                            const G = 1 / (S.x * A.y - A.x * S.y);
                            isFinite(G) && (M.copy(m).multiplyScalar(A.y).addScaledVector(v, -S.y).multiplyScalar(G),
                            x.copy(v).multiplyScalar(S.x).addScaledVector(m, -A.x).multiplyScalar(G),
                            c[z].add(M),
                            c[I].add(M),
                            c[B].add(M),
                            u[z].add(x),
                            u[I].add(x),
                            u[B].add(x))
                        }
                        let D = this.groups;
                        D.length === 0 && (D = [{
                            start: 0,
                            count: t.count
                        }]);
                        for (let z = 0, I = D.length; z < I; ++z) {
                            const B = D[z]
                              , G = B.start
                              , X = B.count;
                            for (let q = G, Q = G + X; q < Q; q += 3)
                                T(t.getX(q + 0), t.getX(q + 1), t.getX(q + 2))
                        }
                        const w = new ae
                          , U = new ae
                          , O = new ae
                          , L = new ae;
                        function N(z) {
                            O.fromBufferAttribute(s, z),
                            L.copy(O);
                            const I = c[z];
                            w.copy(I),
                            w.sub(O.multiplyScalar(O.dot(I))).normalize(),
                            U.crossVectors(L, I);
                            const B = U.dot(u[z]) < 0 ? -1 : 1;
                            o.setXYZW(z, w.x, w.y, w.z, B)
                        }
                        for (let z = 0, I = D.length; z < I; ++z) {
                            const B = D[z]
                              , G = B.start
                              , X = B.count;
                            for (let q = G, Q = G + X; q < Q; q += 3)
                                N(t.getX(q + 0)),
                                N(t.getX(q + 1)),
                                N(t.getX(q + 2))
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index
                          , n = this.getAttribute("position");
                        if (n !== void 0) {
                            let i = this.getAttribute("normal");
                            if (i === void 0)
                                i = new Ln(new Float32Array(n.count * 3),3),
                                this.setAttribute("normal", i);
                            else
                                for (let y = 0, S = i.count; y < S; y++)
                                    i.setXYZ(y, 0, 0, 0);
                            const s = new ae
                              , a = new ae
                              , o = new ae
                              , c = new ae
                              , u = new ae
                              , f = new ae
                              , m = new ae
                              , v = new ae;
                            if (t)
                                for (let y = 0, S = t.count; y < S; y += 3) {
                                    const A = t.getX(y + 0)
                                      , M = t.getX(y + 1)
                                      , x = t.getX(y + 2);
                                    s.fromBufferAttribute(n, A),
                                    a.fromBufferAttribute(n, M),
                                    o.fromBufferAttribute(n, x),
                                    m.subVectors(o, a),
                                    v.subVectors(s, a),
                                    m.cross(v),
                                    c.fromBufferAttribute(i, A),
                                    u.fromBufferAttribute(i, M),
                                    f.fromBufferAttribute(i, x),
                                    c.add(m),
                                    u.add(m),
                                    f.add(m),
                                    i.setXYZ(A, c.x, c.y, c.z),
                                    i.setXYZ(M, u.x, u.y, u.z),
                                    i.setXYZ(x, f.x, f.y, f.z)
                                }
                            else
                                for (let y = 0, S = n.count; y < S; y += 3)
                                    s.fromBufferAttribute(n, y + 0),
                                    a.fromBufferAttribute(n, y + 1),
                                    o.fromBufferAttribute(n, y + 2),
                                    m.subVectors(o, a),
                                    v.subVectors(s, a),
                                    m.cross(v),
                                    i.setXYZ(y + 0, m.x, m.y, m.z),
                                    i.setXYZ(y + 1, m.x, m.y, m.z),
                                    i.setXYZ(y + 2, m.x, m.y, m.z);
                            this.normalizeNormals(),
                            i.needsUpdate = !0
                        }
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let n = 0, i = t.count; n < i; n++)
                            js.fromBufferAttribute(t, n),
                            js.normalize(),
                            t.setXYZ(n, js.x, js.y, js.z)
                    }
                    toNonIndexed() {
                        function t(c, u) {
                            const f = c.array
                              , m = c.itemSize
                              , v = c.normalized
                              , y = new f.constructor(u.length * m);
                            let S = 0
                              , A = 0;
                            for (let M = 0, x = u.length; M < x; M++) {
                                c.isInterleavedBufferAttribute ? S = u[M] * c.data.stride + c.offset : S = u[M] * m;
                                for (let T = 0; T < m; T++)
                                    y[A++] = f[S++]
                            }
                            return new Ln(y,m,v)
                        }
                        if (this.index === null)
                            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                            this;
                        const n = new hU
                          , i = this.index.array
                          , s = this.attributes;
                        for (const c in s) {
                            const u = s[c]
                              , f = t(u, i);
                            n.setAttribute(c, f)
                        }
                        const a = this.morphAttributes;
                        for (const c in a) {
                            const u = []
                              , f = a[c];
                            for (let m = 0, v = f.length; m < v; m++) {
                                const y = f[m]
                                  , S = t(y, i);
                                u.push(S)
                            }
                            n.morphAttributes[c] = u
                        }
                        n.morphTargetsRelative = this.morphTargetsRelative;
                        const o = this.groups;
                        for (let c = 0, u = o.length; c < u; c++) {
                            const f = o[c];
                            n.addGroup(f.start, f.count, f.materialIndex)
                        }
                        return n
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid,
                        t.type = this.type,
                        this.name !== "" && (t.name = this.name),
                        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                        this.parameters !== void 0) {
                            const u = this.parameters;
                            for (const f in u)
                                u[f] !== void 0 && (t[f] = u[f]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        const n = this.index;
                        n !== null && (t.data.index = {
                            type: n.array.constructor.name,
                            array: Array.prototype.slice.call(n.array)
                        });
                        const i = this.attributes;
                        for (const u in i) {
                            const f = i[u];
                            t.data.attributes[u] = f.toJSON(t.data)
                        }
                        const s = {};
                        let a = !1;
                        for (const u in this.morphAttributes) {
                            const f = this.morphAttributes[u]
                              , m = [];
                            for (let v = 0, y = f.length; v < y; v++) {
                                const S = f[v];
                                m.push(S.toJSON(t.data))
                            }
                            m.length > 0 && (s[u] = m,
                            a = !0)
                        }
                        a && (t.data.morphAttributes = s,
                        t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const o = this.groups;
                        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                        const c = this.boundingSphere;
                        return c !== null && (t.data.boundingSphere = c.toJSON()),
                        t
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        this.index = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        const n = {};
                        this.name = t.name;
                        const i = t.index;
                        i !== null && this.setIndex(i.clone());
                        const s = t.attributes;
                        for (const f in s) {
                            const m = s[f];
                            this.setAttribute(f, m.clone(n))
                        }
                        const a = t.morphAttributes;
                        for (const f in a) {
                            const m = []
                              , v = a[f];
                            for (let y = 0, S = v.length; y < S; y++)
                                m.push(v[y].clone(n));
                            this.morphAttributes[f] = m
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const o = t.groups;
                        for (let f = 0, m = o.length; f < m; f++) {
                            const v = o[f];
                            this.addGroup(v.start, v.count, v.materialIndex)
                        }
                        const c = t.boundingBox;
                        c !== null && (this.boundingBox = c.clone());
                        const u = t.boundingSphere;
                        return u !== null && (this.boundingSphere = u.clone()),
                        this.drawRange.start = t.drawRange.start,
                        this.drawRange.count = t.drawRange.count,
                        this.userData = t.userData,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                ;
                const BC = new Xt
                  , xf = new Ep
                  , B_ = new Ys
                  , LC = new ae
                  , L_ = new ae
                  , I_ = new ae
                  , P_ = new ae
                  , KA = new ae
                  , z_ = new ae
                  , IC = new ae
                  , F_ = new ae;
                var oi = class extends $n {
                    constructor(e=new sn, t=new nu) {
                        super(),
                        this.isMesh = !0,
                        this.type = "Mesh",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.count = 1,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const a = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[a] = i
                                }
                            }
                        }
                    }
                    getVertexPosition(e, t) {
                        const n = this.geometry
                          , i = n.attributes.position
                          , s = n.morphAttributes.position
                          , a = n.morphTargetsRelative;
                        t.fromBufferAttribute(i, e);
                        const o = this.morphTargetInfluences;
                        if (s && o) {
                            z_.set(0, 0, 0);
                            for (let c = 0, u = s.length; c < u; c++) {
                                const f = o[c]
                                  , m = s[c];
                                f !== 0 && (KA.fromBufferAttribute(m, e),
                                a ? z_.addScaledVector(KA, f) : z_.addScaledVector(KA.sub(t), f))
                            }
                            t.add(z_)
                        }
                        return t
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , i = this.material
                          , s = this.matrixWorld;
                        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
                        B_.copy(n.boundingSphere),
                        B_.applyMatrix4(s),
                        xf.copy(e.ray).recast(e.near),
                        !(B_.containsPoint(xf.origin) === !1 && (xf.intersectSphere(B_, LC) === null || xf.origin.distanceToSquared(LC) > (e.far - e.near) ** 2)) && (BC.copy(s).invert(),
                        xf.copy(e.ray).applyMatrix4(BC),
                        !(n.boundingBox !== null && xf.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, xf)))
                    }
                    _computeIntersections(e, t, n) {
                        let i;
                        const s = this.geometry
                          , a = this.material
                          , o = s.index
                          , c = s.attributes.position
                          , u = s.attributes.uv
                          , f = s.attributes.uv1
                          , m = s.attributes.normal
                          , v = s.groups
                          , y = s.drawRange;
                        if (o !== null)
                            if (Array.isArray(a))
                                for (let S = 0, A = v.length; S < A; S++) {
                                    const M = v[S]
                                      , x = a[M.materialIndex]
                                      , T = Math.max(M.start, y.start)
                                      , D = Math.min(o.count, Math.min(M.start + M.count, y.start + y.count));
                                    for (let w = T, U = D; w < U; w += 3) {
                                        const O = o.getX(w)
                                          , L = o.getX(w + 1)
                                          , N = o.getX(w + 2);
                                        i = H_(this, x, e, n, u, f, m, O, L, N),
                                        i && (i.faceIndex = Math.floor(w / 3),
                                        i.face.materialIndex = M.materialIndex,
                                        t.push(i))
                                    }
                                }
                            else {
                                const S = Math.max(0, y.start)
                                  , A = Math.min(o.count, y.start + y.count);
                                for (let M = S, x = A; M < x; M += 3) {
                                    const T = o.getX(M)
                                      , D = o.getX(M + 1)
                                      , w = o.getX(M + 2);
                                    i = H_(this, a, e, n, u, f, m, T, D, w),
                                    i && (i.faceIndex = Math.floor(M / 3),
                                    t.push(i))
                                }
                            }
                        else if (c !== void 0)
                            if (Array.isArray(a))
                                for (let S = 0, A = v.length; S < A; S++) {
                                    const M = v[S]
                                      , x = a[M.materialIndex]
                                      , T = Math.max(M.start, y.start)
                                      , D = Math.min(c.count, Math.min(M.start + M.count, y.start + y.count));
                                    for (let w = T, U = D; w < U; w += 3) {
                                        const O = w
                                          , L = w + 1
                                          , N = w + 2;
                                        i = H_(this, x, e, n, u, f, m, O, L, N),
                                        i && (i.faceIndex = Math.floor(w / 3),
                                        i.face.materialIndex = M.materialIndex,
                                        t.push(i))
                                    }
                                }
                            else {
                                const S = Math.max(0, y.start)
                                  , A = Math.min(c.count, y.start + y.count);
                                for (let M = S, x = A; M < x; M += 3) {
                                    const T = M
                                      , D = M + 1
                                      , w = M + 2;
                                    i = H_(this, a, e, n, u, f, m, T, D, w),
                                    i && (i.faceIndex = Math.floor(M / 3),
                                    t.push(i))
                                }
                            }
                    }
                }
                ;
                function uL(e, t, n, i, s, a, o, c) {
                    let u;
                    if (t.side === Ds ? u = i.intersectTriangle(o, a, s, !0, c) : u = i.intersectTriangle(s, a, o, t.side === ic, c),
                    u === null)
                        return null;
                    F_.copy(c),
                    F_.applyMatrix4(e.matrixWorld);
                    const f = n.ray.origin.distanceTo(F_);
                    return f < n.near || f > n.far ? null : {
                        distance: f,
                        point: F_.clone(),
                        object: e
                    }
                }
                function H_(e, t, n, i, s, a, o, c, u, f) {
                    e.getVertexPosition(c, L_),
                    e.getVertexPosition(u, I_),
                    e.getVertexPosition(f, P_);
                    const m = uL(e, t, n, i, L_, I_, P_, IC);
                    if (m) {
                        const v = new ae;
                        hh.getBarycoord(IC, L_, I_, P_, v),
                        s && (m.uv = hh.getInterpolatedAttribute(s, c, u, f, v, new Oe)),
                        a && (m.uv1 = hh.getInterpolatedAttribute(a, c, u, f, v, new Oe)),
                        o && (m.normal = hh.getInterpolatedAttribute(o, c, u, f, v, new ae),
                        m.normal.dot(i.direction) > 0 && m.normal.multiplyScalar(-1));
                        const y = {
                            a: c,
                            b: u,
                            c: f,
                            normal: new ae,
                            materialIndex: 0
                        };
                        hh.getNormal(L_, I_, P_, y.normal),
                        m.face = y,
                        m.barycoord = v
                    }
                    return m
                }
                var dh = class fU extends sn {
                    constructor(t=1, n=1, i=1, s=1, a=1, o=1) {
                        super(),
                        this.type = "BoxGeometry",
                        this.parameters = {
                            width: t,
                            height: n,
                            depth: i,
                            widthSegments: s,
                            heightSegments: a,
                            depthSegments: o
                        };
                        const c = this;
                        s = Math.floor(s),
                        a = Math.floor(a),
                        o = Math.floor(o);
                        const u = []
                          , f = []
                          , m = []
                          , v = [];
                        let y = 0
                          , S = 0;
                        A("z", "y", "x", -1, -1, i, n, t, o, a, 0),
                        A("z", "y", "x", 1, -1, i, n, -t, o, a, 1),
                        A("x", "z", "y", 1, 1, t, i, n, s, o, 2),
                        A("x", "z", "y", 1, -1, t, i, -n, s, o, 3),
                        A("x", "y", "z", 1, -1, t, n, i, s, a, 4),
                        A("x", "y", "z", -1, -1, t, n, -i, s, a, 5),
                        this.setIndex(u),
                        this.setAttribute("position", new Rt(f,3)),
                        this.setAttribute("normal", new Rt(m,3)),
                        this.setAttribute("uv", new Rt(v,2));
                        function A(M, x, T, D, w, U, O, L, N, z, I) {
                            const B = U / N
                              , G = O / z
                              , X = U / 2
                              , q = O / 2
                              , Q = L / 2
                              , oe = N + 1
                              , k = z + 1;
                            let W = 0
                              , V = 0;
                            const Z = new ae;
                            for (let j = 0; j < k; j++) {
                                const ee = j * G - q;
                                for (let H = 0; H < oe; H++)
                                    Z[M] = (H * B - X) * D,
                                    Z[x] = ee * w,
                                    Z[T] = Q,
                                    f.push(Z.x, Z.y, Z.z),
                                    Z[M] = 0,
                                    Z[x] = 0,
                                    Z[T] = L > 0 ? 1 : -1,
                                    m.push(Z.x, Z.y, Z.z),
                                    v.push(H / N),
                                    v.push(1 - j / z),
                                    W += 1
                            }
                            for (let j = 0; j < z; j++)
                                for (let ee = 0; ee < N; ee++) {
                                    const H = y + ee + oe * j
                                      , ie = y + ee + oe * (j + 1)
                                      , se = y + (ee + 1) + oe * (j + 1)
                                      , K = y + (ee + 1) + oe * j;
                                    u.push(H, ie, K),
                                    u.push(ie, se, K),
                                    V += 6
                                }
                            c.addGroup(S, V, I),
                            S += V,
                            y += W
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new fU(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
                    }
                }
                ;
                function Bp(e) {
                    const t = {};
                    for (const n in e) {
                        t[n] = {};
                        for (const i in e[n]) {
                            const s = e[n][i];
                            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                            t[n][i] = null) : t[n][i] = s.clone() : Array.isArray(s) ? t[n][i] = s.slice() : t[n][i] = s
                        }
                    }
                    return t
                }
                function tr(e) {
                    const t = {};
                    for (let n = 0; n < e.length; n++) {
                        const i = Bp(e[n]);
                        for (const s in i)
                            t[s] = i[s]
                    }
                    return t
                }
                function hL(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }
                function PC(e) {
                    const t = e.getRenderTarget();
                    return t === null ? e.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : Rn.workingColorSpace
                }
                const JA = {
                    clone: Bp,
                    merge: tr
                };
                var fL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
                  , dL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
                  , kn = class extends qs {
                    constructor(e) {
                        super(),
                        this.isShaderMaterial = !0,
                        this.type = "ShaderMaterial",
                        this.defines = {},
                        this.uniforms = {},
                        this.uniformsGroups = [],
                        this.vertexShader = fL,
                        this.fragmentShader = dL,
                        this.linewidth = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.fog = !1,
                        this.lights = !1,
                        this.clipping = !1,
                        this.forceSinglePass = !0,
                        this.extensions = {
                            clipCullDistance: !1,
                            multiDraw: !1
                        },
                        this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv1: [0, 0]
                        },
                        this.index0AttributeName = void 0,
                        this.uniformsNeedUpdate = !1,
                        this.glslVersion = null,
                        e !== void 0 && this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.fragmentShader = e.fragmentShader,
                        this.vertexShader = e.vertexShader,
                        this.uniforms = Bp(e.uniforms),
                        this.uniformsGroups = hL(e.uniformsGroups),
                        this.defines = Object.assign({}, e.defines),
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.fog = e.fog,
                        this.lights = e.lights,
                        this.clipping = e.clipping,
                        this.extensions = Object.assign({}, e.extensions),
                        this.glslVersion = e.glslVersion,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        t.glslVersion = this.glslVersion,
                        t.uniforms = {};
                        for (const i in this.uniforms) {
                            const s = this.uniforms[i].value;
                            s && s.isTexture ? t.uniforms[i] = {
                                type: "t",
                                value: s.toJSON(e).uuid
                            } : s && s.isColor ? t.uniforms[i] = {
                                type: "c",
                                value: s.getHex()
                            } : s && s.isVector2 ? t.uniforms[i] = {
                                type: "v2",
                                value: s.toArray()
                            } : s && s.isVector3 ? t.uniforms[i] = {
                                type: "v3",
                                value: s.toArray()
                            } : s && s.isVector4 ? t.uniforms[i] = {
                                type: "v4",
                                value: s.toArray()
                            } : s && s.isMatrix3 ? t.uniforms[i] = {
                                type: "m3",
                                value: s.toArray()
                            } : s && s.isMatrix4 ? t.uniforms[i] = {
                                type: "m4",
                                value: s.toArray()
                            } : t.uniforms[i] = {
                                value: s
                            }
                        }
                        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                        t.vertexShader = this.vertexShader,
                        t.fragmentShader = this.fragmentShader,
                        t.lights = this.lights,
                        t.clipping = this.clipping;
                        const n = {};
                        for (const i in this.extensions)
                            this.extensions[i] === !0 && (n[i] = !0);
                        return Object.keys(n).length > 0 && (t.extensions = n),
                        t
                    }
                }
                  , Ag = class extends $n {
                    constructor() {
                        super(),
                        this.isCamera = !0,
                        this.type = "Camera",
                        this.matrixWorldInverse = new Xt,
                        this.projectionMatrix = new Xt,
                        this.projectionMatrixInverse = new Xt,
                        this.coordinateSystem = Yr,
                        this._reversedDepth = !1
                    }
                    get reversedDepth() {
                        return this._reversedDepth
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.matrixWorldInverse.copy(e.matrixWorldInverse),
                        this.projectionMatrix.copy(e.projectionMatrix),
                        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                        this.coordinateSystem = e.coordinateSystem,
                        this
                    }
                    getWorldDirection(e) {
                        return super.getWorldDirection(e).negate()
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(e, t) {
                        super.updateWorldMatrix(e, t),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const ph = new ae
                  , zC = new Oe
                  , FC = new Oe;
                var Hi = class extends Ag {
                    constructor(e=50, t=1, n=.1, i=2e3) {
                        super(),
                        this.isPerspectiveCamera = !0,
                        this.type = "PerspectiveCamera",
                        this.fov = e,
                        this.zoom = 1,
                        this.near = n,
                        this.far = i,
                        this.focus = 10,
                        this.aspect = t,
                        this.view = null,
                        this.filmGauge = 35,
                        this.filmOffset = 0,
                        this.updateProjectionMatrix()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.fov = e.fov,
                        this.zoom = e.zoom,
                        this.near = e.near,
                        this.far = e.far,
                        this.focus = e.focus,
                        this.aspect = e.aspect,
                        this.view = e.view === null ? null : Object.assign({}, e.view),
                        this.filmGauge = e.filmGauge,
                        this.filmOffset = e.filmOffset,
                        this
                    }
                    setFocalLength(e) {
                        const t = .5 * this.getFilmHeight() / e;
                        this.fov = _p * 2 * Math.atan(t),
                        this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const e = Math.tan(yf * .5 * this.fov);
                        return .5 * this.getFilmHeight() / e
                    }
                    getEffectiveFOV() {
                        return _p * 2 * Math.atan(Math.tan(yf * .5 * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    getViewBounds(e, t, n) {
                        ph.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                        t.set(ph.x, ph.y).multiplyScalar(-e / ph.z),
                        ph.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                        n.set(ph.x, ph.y).multiplyScalar(-e / ph.z)
                    }
                    getViewSize(e, t) {
                        return this.getViewBounds(e, zC, FC),
                        t.subVectors(FC, zC)
                    }
                    setViewOffset(e, t, n, i, s, a) {
                        this.aspect = e / t,
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = s,
                        this.view.height = a,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const e = this.near;
                        let t = e * Math.tan(yf * .5 * this.fov) / this.zoom
                          , n = 2 * t
                          , i = this.aspect * n
                          , s = -.5 * i;
                        const a = this.view;
                        if (this.view !== null && this.view.enabled) {
                            const c = a.fullWidth
                              , u = a.fullHeight;
                            s += a.offsetX * i / c,
                            t -= a.offsetY * n / u,
                            i *= a.width / c,
                            n *= a.height / u
                        }
                        const o = this.filmOffset;
                        o !== 0 && (s += e * o / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.fov = this.fov,
                        t.object.zoom = this.zoom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        t.object.focus = this.focus,
                        t.object.aspect = this.aspect,
                        this.view !== null && (t.object.view = Object.assign({}, this.view)),
                        t.object.filmGauge = this.filmGauge,
                        t.object.filmOffset = this.filmOffset,
                        t
                    }
                }
                ;
                const Lp = -90
                  , Ip = 1;
                var HC = class extends $n {
                    constructor(e, t, n) {
                        super(),
                        this.type = "CubeCamera",
                        this.renderTarget = n,
                        this.coordinateSystem = null,
                        this.activeMipmapLevel = 0;
                        const i = new Hi(Lp,Ip,e,t);
                        i.layers = this.layers,
                        this.add(i);
                        const s = new Hi(Lp,Ip,e,t);
                        s.layers = this.layers,
                        this.add(s);
                        const a = new Hi(Lp,Ip,e,t);
                        a.layers = this.layers,
                        this.add(a);
                        const o = new Hi(Lp,Ip,e,t);
                        o.layers = this.layers,
                        this.add(o);
                        const c = new Hi(Lp,Ip,e,t);
                        c.layers = this.layers,
                        this.add(c);
                        const u = new Hi(Lp,Ip,e,t);
                        u.layers = this.layers,
                        this.add(u)
                    }
                    updateCoordinateSystem() {
                        const e = this.coordinateSystem
                          , t = this.children.concat()
                          , [n,i,s,a,o,c] = t;
                        for (const u of t)
                            this.remove(u);
                        if (e === Yr)
                            n.up.set(0, 1, 0),
                            n.lookAt(1, 0, 0),
                            i.up.set(0, 1, 0),
                            i.lookAt(-1, 0, 0),
                            s.up.set(0, 0, -1),
                            s.lookAt(0, 1, 0),
                            a.up.set(0, 0, 1),
                            a.lookAt(0, -1, 0),
                            o.up.set(0, 1, 0),
                            o.lookAt(0, 0, 1),
                            c.up.set(0, 1, 0),
                            c.lookAt(0, 0, -1);
                        else if (e === yp)
                            n.up.set(0, -1, 0),
                            n.lookAt(-1, 0, 0),
                            i.up.set(0, -1, 0),
                            i.lookAt(1, 0, 0),
                            s.up.set(0, 0, 1),
                            s.lookAt(0, 1, 0),
                            a.up.set(0, 0, -1),
                            a.lookAt(0, -1, 0),
                            o.up.set(0, -1, 0),
                            o.lookAt(0, 0, 1),
                            c.up.set(0, -1, 0),
                            c.lookAt(0, 0, -1);
                        else
                            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                        for (const u of t)
                            this.add(u),
                            u.updateMatrixWorld()
                    }
                    update(e, t) {
                        this.parent === null && this.updateMatrixWorld();
                        const {renderTarget: n, activeMipmapLevel: i} = this;
                        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                        this.updateCoordinateSystem());
                        const [s,a,o,c,u,f] = this.children
                          , m = e.getRenderTarget()
                          , v = e.getActiveCubeFace()
                          , y = e.getActiveMipmapLevel()
                          , S = e.xr.enabled;
                        e.xr.enabled = !1;
                        const A = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1,
                        e.setRenderTarget(n, 0, i),
                        e.render(t, s),
                        e.setRenderTarget(n, 1, i),
                        e.render(t, a),
                        e.setRenderTarget(n, 2, i),
                        e.render(t, o),
                        e.setRenderTarget(n, 3, i),
                        e.render(t, c),
                        e.setRenderTarget(n, 4, i),
                        e.render(t, u),
                        n.texture.generateMipmaps = A,
                        e.setRenderTarget(n, 5, i),
                        e.render(t, f),
                        e.setRenderTarget(m, v, y),
                        e.xr.enabled = S,
                        n.texture.needsPMREMUpdate = !0
                    }
                }
                  , Tg = class extends Fi {
                    constructor(e=[], t=Qc, n, i, s, a, o, c, u, f) {
                        super(e, t, n, i, s, a, o, c, u, f),
                        this.isCubeTexture = !0,
                        this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(e) {
                        this.image = e
                    }
                }
                  , GC = class extends Vn {
                    constructor(e=1, t={}) {
                        super(e, e, t),
                        this.isWebGLCubeRenderTarget = !0;
                        const n = {
                            width: e,
                            height: e,
                            depth: 1
                        };
                        this.texture = new Tg([n, n, n, n, n, n]),
                        this._setTextureOptions(t),
                        this.texture.isRenderTargetTexture = !0
                    }
                    fromEquirectangularTexture(e, t) {
                        this.texture.type = t.type,
                        this.texture.colorSpace = t.colorSpace,
                        this.texture.generateMipmaps = t.generateMipmaps,
                        this.texture.minFilter = t.minFilter,
                        this.texture.magFilter = t.magFilter;
                        const n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        }
                          , i = new dh(5,5,5)
                          , s = new kn({
                            name: "CubemapFromEquirect",
                            uniforms: Bp(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: Ds,
                            blending: pi
                        });
                        s.uniforms.tEquirect.value = t;
                        const a = new oi(i,s)
                          , o = t.minFilter;
                        return t.minFilter === sc && (t.minFilter = mi),
                        new HC(1,10,this).update(e, a),
                        t.minFilter = o,
                        a.geometry.dispose(),
                        a.material.dispose(),
                        this
                    }
                    clear(e, t=!0, n=!0, i=!0) {
                        const s = e.getRenderTarget();
                        for (let a = 0; a < 6; a++)
                            e.setRenderTarget(this, a),
                            e.clear(t, n, i);
                        e.setRenderTarget(s)
                    }
                }
                  , su = class extends $n {
                    constructor() {
                        super(),
                        this.isGroup = !0,
                        this.type = "Group"
                    }
                }
                ;
                const pL = {
                    type: "move"
                };
                var G_ = class {
                    constructor() {
                        this._targetRay = null,
                        this._grip = null,
                        this._hand = null
                    }
                    getHandSpace() {
                        return this._hand === null && (this._hand = new su,
                        this._hand.matrixAutoUpdate = !1,
                        this._hand.visible = !1,
                        this._hand.joints = {},
                        this._hand.inputState = {
                            pinching: !1
                        }),
                        this._hand
                    }
                    getTargetRaySpace() {
                        return this._targetRay === null && (this._targetRay = new su,
                        this._targetRay.matrixAutoUpdate = !1,
                        this._targetRay.visible = !1,
                        this._targetRay.hasLinearVelocity = !1,
                        this._targetRay.linearVelocity = new ae,
                        this._targetRay.hasAngularVelocity = !1,
                        this._targetRay.angularVelocity = new ae),
                        this._targetRay
                    }
                    getGripSpace() {
                        return this._grip === null && (this._grip = new su,
                        this._grip.matrixAutoUpdate = !1,
                        this._grip.visible = !1,
                        this._grip.hasLinearVelocity = !1,
                        this._grip.linearVelocity = new ae,
                        this._grip.hasAngularVelocity = !1,
                        this._grip.angularVelocity = new ae),
                        this._grip
                    }
                    dispatchEvent(e) {
                        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
                        this._grip !== null && this._grip.dispatchEvent(e),
                        this._hand !== null && this._hand.dispatchEvent(e),
                        this
                    }
                    connect(e) {
                        if (e && e.hand) {
                            const t = this._hand;
                            if (t)
                                for (const n of e.hand.values())
                                    this._getHandJoint(t, n)
                        }
                        return this.dispatchEvent({
                            type: "connected",
                            data: e
                        }),
                        this
                    }
                    disconnect(e) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }),
                        this._targetRay !== null && (this._targetRay.visible = !1),
                        this._grip !== null && (this._grip.visible = !1),
                        this._hand !== null && (this._hand.visible = !1),
                        this
                    }
                    update(e, t, n) {
                        let i = null
                          , s = null
                          , a = null;
                        const o = this._targetRay
                          , c = this._grip
                          , u = this._hand;
                        if (e && t.session.visibilityState !== "visible-blurred") {
                            if (u && e.hand) {
                                a = !0;
                                for (const A of e.hand.values()) {
                                    const M = t.getJointPose(A, n)
                                      , x = this._getHandJoint(u, A);
                                    M !== null && (x.matrix.fromArray(M.transform.matrix),
                                    x.matrix.decompose(x.position, x.rotation, x.scale),
                                    x.matrixWorldNeedsUpdate = !0,
                                    x.jointRadius = M.radius),
                                    x.visible = M !== null
                                }
                                const f = u.joints["index-finger-tip"]
                                  , m = u.joints["thumb-tip"]
                                  , v = f.position.distanceTo(m.position)
                                  , y = .02
                                  , S = .005;
                                u.inputState.pinching && v > y + S ? (u.inputState.pinching = !1,
                                this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: e.handedness,
                                    target: this
                                })) : !u.inputState.pinching && v <= y - S && (u.inputState.pinching = !0,
                                this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: e.handedness,
                                    target: this
                                }))
                            } else
                                c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n),
                                s !== null && (c.matrix.fromArray(s.transform.matrix),
                                c.matrix.decompose(c.position, c.rotation, c.scale),
                                c.matrixWorldNeedsUpdate = !0,
                                s.linearVelocity ? (c.hasLinearVelocity = !0,
                                c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1,
                                s.angularVelocity ? (c.hasAngularVelocity = !0,
                                c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
                            o !== null && (i = t.getPose(e.targetRaySpace, n),
                            i === null && s !== null && (i = s),
                            i !== null && (o.matrix.fromArray(i.transform.matrix),
                            o.matrix.decompose(o.position, o.rotation, o.scale),
                            o.matrixWorldNeedsUpdate = !0,
                            i.linearVelocity ? (o.hasLinearVelocity = !0,
                            o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                            i.angularVelocity ? (o.hasAngularVelocity = !0,
                            o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1,
                            this.dispatchEvent(pL)))
                        }
                        return o !== null && (o.visible = i !== null),
                        c !== null && (c.visible = s !== null),
                        u !== null && (u.visible = a !== null),
                        this
                    }
                    _getHandJoint(e, t) {
                        if (e.joints[t.jointName] === void 0) {
                            const n = new su;
                            n.matrixAutoUpdate = !1,
                            n.visible = !1,
                            e.joints[t.jointName] = n,
                            e.add(n)
                        }
                        return e.joints[t.jointName]
                    }
                }
                  , VC = class dU {
                    constructor(t, n=25e-5) {
                        this.isFogExp2 = !0,
                        this.name = "",
                        this.color = new ft(t),
                        this.density = n
                    }
                    clone() {
                        return new dU(this.color,this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            name: this.name,
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                  , kC = class pU {
                    constructor(t, n=1, i=1e3) {
                        this.isFog = !0,
                        this.name = "",
                        this.color = new ft(t),
                        this.near = n,
                        this.far = i
                    }
                    clone() {
                        return new pU(this.color,this.near,this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            name: this.name,
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                  , Pp = class extends $n {
                    constructor() {
                        super(),
                        this.isScene = !0,
                        this.type = "Scene",
                        this.background = null,
                        this.environment = null,
                        this.fog = null,
                        this.backgroundBlurriness = 0,
                        this.backgroundIntensity = 1,
                        this.backgroundRotation = new Co,
                        this.environmentIntensity = 1,
                        this.environmentRotation = new Co,
                        this.overrideMaterial = null,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.background !== null && (this.background = e.background.clone()),
                        e.environment !== null && (this.environment = e.environment.clone()),
                        e.fog !== null && (this.fog = e.fog.clone()),
                        this.backgroundBlurriness = e.backgroundBlurriness,
                        this.backgroundIntensity = e.backgroundIntensity,
                        this.backgroundRotation.copy(e.backgroundRotation),
                        this.environmentIntensity = e.environmentIntensity,
                        this.environmentRotation.copy(e.environmentRotation),
                        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
                        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
                        t.object.backgroundRotation = this.backgroundRotation.toArray(),
                        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
                        t.object.environmentRotation = this.environmentRotation.toArray(),
                        t
                    }
                }
                  , V_ = class {
                    constructor(e, t) {
                        this.isInterleavedBuffer = !0,
                        this.array = e,
                        this.stride = t,
                        this.count = e !== void 0 ? e.length / t : 0,
                        this.usage = dg,
                        this.updateRanges = [],
                        this.version = 0,
                        this.uuid = jr()
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    addUpdateRange(e, t) {
                        this.updateRanges.push({
                            start: e,
                            count: t
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(e) {
                        return this.array = new e.array.constructor(e.array),
                        this.count = e.count,
                        this.stride = e.stride,
                        this.usage = e.usage,
                        this
                    }
                    copyAt(e, t, n) {
                        e *= this.stride,
                        n *= t.stride;
                        for (let i = 0, s = this.stride; i < s; i++)
                            this.array[e + i] = t.array[n + i];
                        return this
                    }
                    set(e, t=0) {
                        return this.array.set(e, t),
                        this
                    }
                    clone(e) {
                        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = jr()),
                        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                          , n = new this.constructor(t,this.stride);
                        return n.setUsage(this.usage),
                        n
                    }
                    onUpload(e) {
                        return this.onUploadCallback = e,
                        this
                    }
                    toJSON(e) {
                        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = jr()),
                        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                ;
                const nr = new ae;
                var Mg = class mU {
                    constructor(t, n, i, s=!1) {
                        this.isInterleavedBufferAttribute = !0,
                        this.name = "",
                        this.data = t,
                        this.itemSize = n,
                        this.offset = i,
                        this.normalized = s
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(t) {
                        this.data.needsUpdate = t
                    }
                    applyMatrix4(t) {
                        for (let n = 0, i = this.data.count; n < i; n++)
                            nr.fromBufferAttribute(this, n),
                            nr.applyMatrix4(t),
                            this.setXYZ(n, nr.x, nr.y, nr.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let n = 0, i = this.count; n < i; n++)
                            nr.fromBufferAttribute(this, n),
                            nr.applyNormalMatrix(t),
                            this.setXYZ(n, nr.x, nr.y, nr.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let n = 0, i = this.count; n < i; n++)
                            nr.fromBufferAttribute(this, n),
                            nr.transformDirection(t),
                            this.setXYZ(n, nr.x, nr.y, nr.z);
                        return this
                    }
                    getComponent(t, n) {
                        let i = this.array[t * this.data.stride + this.offset + n];
                        return this.normalized && (i = er(i, this.array)),
                        i
                    }
                    setComponent(t, n, i) {
                        return this.normalized && (i = tn(i, this.array)),
                        this.data.array[t * this.data.stride + this.offset + n] = i,
                        this
                    }
                    setX(t, n) {
                        return this.normalized && (n = tn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset] = n,
                        this
                    }
                    setY(t, n) {
                        return this.normalized && (n = tn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 1] = n,
                        this
                    }
                    setZ(t, n) {
                        return this.normalized && (n = tn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 2] = n,
                        this
                    }
                    setW(t, n) {
                        return this.normalized && (n = tn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 3] = n,
                        this
                    }
                    getX(t) {
                        let n = this.data.array[t * this.data.stride + this.offset];
                        return this.normalized && (n = er(n, this.array)),
                        n
                    }
                    getY(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 1];
                        return this.normalized && (n = er(n, this.array)),
                        n
                    }
                    getZ(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 2];
                        return this.normalized && (n = er(n, this.array)),
                        n
                    }
                    getW(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 3];
                        return this.normalized && (n = er(n, this.array)),
                        n
                    }
                    setXY(t, n, i) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = tn(n, this.array),
                        i = tn(i, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = i,
                        this
                    }
                    setXYZ(t, n, i, s) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = tn(n, this.array),
                        i = tn(i, this.array),
                        s = tn(s, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = i,
                        this.data.array[t + 2] = s,
                        this
                    }
                    setXYZW(t, n, i, s, a) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = tn(n, this.array),
                        i = tn(i, this.array),
                        s = tn(s, this.array),
                        a = tn(a, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = i,
                        this.data.array[t + 2] = s,
                        this.data.array[t + 3] = a,
                        this
                    }
                    clone(t) {
                        if (t === void 0) {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let i = 0; i < this.count; i++) {
                                const s = i * this.data.stride + this.offset;
                                for (let a = 0; a < this.itemSize; a++)
                                    n.push(this.data.array[s + a])
                            }
                            return new Ln(new this.array.constructor(n),this.itemSize,this.normalized)
                        } else
                            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
                            t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                            new mU(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                    }
                    toJSON(t) {
                        if (t === void 0) {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let i = 0; i < this.count; i++) {
                                const s = i * this.data.stride + this.offset;
                                for (let a = 0; a < this.itemSize; a++)
                                    n.push(this.data.array[s + a])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: n,
                                normalized: this.normalized
                            }
                        } else
                            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
                            t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                            {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                    }
                }
                  , $A = class extends qs {
                    constructor(e) {
                        super(),
                        this.isSpriteMaterial = !0,
                        this.type = "SpriteMaterial",
                        this.color = new ft(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.rotation = 0,
                        this.sizeAttenuation = !0,
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.rotation = e.rotation,
                        this.sizeAttenuation = e.sizeAttenuation,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                let zp;
                const bg = new ae
                  , Fp = new ae
                  , Hp = new ae
                  , Gp = new Oe
                  , Eg = new Oe
                  , XC = new Xt
                  , k_ = new ae
                  , Cg = new ae
                  , X_ = new ae
                  , WC = new Oe
                  , eT = new Oe
                  , YC = new Oe;
                var qC = class extends $n {
                    constructor(e=new $A) {
                        if (super(),
                        this.isSprite = !0,
                        this.type = "Sprite",
                        zp === void 0) {
                            zp = new sn;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                              , n = new V_(t,5);
                            zp.setIndex([0, 1, 2, 0, 2, 3]),
                            zp.setAttribute("position", new Mg(n,3,0,!1)),
                            zp.setAttribute("uv", new Mg(n,2,3,!1))
                        }
                        this.geometry = zp,
                        this.material = e,
                        this.center = new Oe(.5,.5),
                        this.count = 1
                    }
                    raycast(e, t) {
                        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                        Fp.setFromMatrixScale(this.matrixWorld),
                        XC.copy(e.camera.matrixWorld),
                        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                        Hp.setFromMatrixPosition(this.modelViewMatrix),
                        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Fp.multiplyScalar(-Hp.z);
                        const n = this.material.rotation;
                        let i, s;
                        n !== 0 && (s = Math.cos(n),
                        i = Math.sin(n));
                        const a = this.center;
                        W_(k_.set(-.5, -.5, 0), Hp, a, Fp, i, s),
                        W_(Cg.set(.5, -.5, 0), Hp, a, Fp, i, s),
                        W_(X_.set(.5, .5, 0), Hp, a, Fp, i, s),
                        WC.set(0, 0),
                        eT.set(1, 0),
                        YC.set(1, 1);
                        let o = e.ray.intersectTriangle(k_, Cg, X_, !1, bg);
                        if (o === null && (W_(Cg.set(-.5, .5, 0), Hp, a, Fp, i, s),
                        eT.set(0, 1),
                        o = e.ray.intersectTriangle(k_, X_, Cg, !1, bg),
                        o === null))
                            return;
                        const c = e.ray.origin.distanceTo(bg);
                        c < e.near || c > e.far || t.push({
                            distance: c,
                            point: bg.clone(),
                            uv: hh.getInterpolation(bg, k_, Cg, X_, WC, eT, YC, new Oe),
                            face: null,
                            object: this
                        })
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.center !== void 0 && this.center.copy(e.center),
                        this.material = e.material,
                        this
                    }
                }
                ;
                function W_(e, t, n, i, s, a) {
                    Gp.subVectors(e, n).addScalar(.5).multiply(i),
                    s !== void 0 ? (Eg.x = a * Gp.x - s * Gp.y,
                    Eg.y = s * Gp.x + a * Gp.y) : Eg.copy(Gp),
                    e.copy(t),
                    e.x += Eg.x,
                    e.y += Eg.y,
                    e.applyMatrix4(XC)
                }
                const Y_ = new ae
                  , jC = new ae;
                var QC = class extends $n {
                    constructor() {
                        super(),
                        this.isLOD = !0,
                        this._currentLevel = 0,
                        this.type = "LOD",
                        Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            }
                        }),
                        this.autoUpdate = !0
                    }
                    copy(e) {
                        super.copy(e, !1);
                        const t = e.levels;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const s = t[n];
                            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
                        }
                        return this.autoUpdate = e.autoUpdate,
                        this
                    }
                    addLevel(e, t=0, n=0) {
                        t = Math.abs(t);
                        const i = this.levels;
                        let s;
                        for (s = 0; s < i.length && !(t < i[s].distance); s++)
                            ;
                        return i.splice(s, 0, {
                            distance: t,
                            hysteresis: n,
                            object: e
                        }),
                        this.add(e),
                        this
                    }
                    removeLevel(e) {
                        const t = this.levels;
                        for (let n = 0; n < t.length; n++)
                            if (t[n].distance === e) {
                                const i = t.splice(n, 1);
                                return this.remove(i[0].object),
                                !0
                            }
                        return !1
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(e) {
                        const t = this.levels;
                        if (t.length > 0) {
                            let n, i;
                            for (n = 1,
                            i = t.length; n < i; n++) {
                                let s = t[n].distance;
                                if (t[n].object.visible && (s -= s * t[n].hysteresis),
                                e < s)
                                    break
                            }
                            return t[n - 1].object
                        }
                        return null
                    }
                    raycast(e, t) {
                        if (this.levels.length > 0) {
                            Y_.setFromMatrixPosition(this.matrixWorld);
                            const n = e.ray.origin.distanceTo(Y_);
                            this.getObjectForDistance(n).raycast(e, t)
                        }
                    }
                    update(e) {
                        const t = this.levels;
                        if (t.length > 1) {
                            Y_.setFromMatrixPosition(e.matrixWorld),
                            jC.setFromMatrixPosition(this.matrixWorld);
                            const n = Y_.distanceTo(jC) / e.zoom;
                            t[0].object.visible = !0;
                            let i, s;
                            for (i = 1,
                            s = t.length; i < s; i++) {
                                let a = t[i].distance;
                                if (t[i].object.visible && (a -= a * t[i].hysteresis),
                                n >= a)
                                    t[i - 1].object.visible = !1,
                                    t[i].object.visible = !0;
                                else
                                    break
                            }
                            for (this._currentLevel = i - 1; i < s; i++)
                                t[i].object.visible = !1
                        }
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
                        t.object.levels = [];
                        const n = this.levels;
                        for (let i = 0, s = n.length; i < s; i++) {
                            const a = n[i];
                            t.object.levels.push({
                                object: a.object.uuid,
                                distance: a.distance,
                                hysteresis: a.hysteresis
                            })
                        }
                        return t
                    }
                }
                ;
                const ZC = new ae
                  , KC = new hn
                  , JC = new hn
                  , mL = new ae
                  , $C = new Xt
                  , q_ = new ae
                  , tT = new Ys
                  , ew = new Xt
                  , nT = new Ep;
                var tw = class extends oi {
                    constructor(e, t) {
                        super(e, t),
                        this.isSkinnedMesh = !0,
                        this.type = "SkinnedMesh",
                        this.bindMode = vA,
                        this.bindMatrix = new Xt,
                        this.bindMatrixInverse = new Xt,
                        this.boundingBox = null,
                        this.boundingSphere = null
                    }
                    computeBoundingBox() {
                        const e = this.geometry;
                        this.boundingBox === null && (this.boundingBox = new Ws),
                        this.boundingBox.makeEmpty();
                        const t = e.getAttribute("position");
                        for (let n = 0; n < t.count; n++)
                            this.getVertexPosition(n, q_),
                            this.boundingBox.expandByPoint(q_)
                    }
                    computeBoundingSphere() {
                        const e = this.geometry;
                        this.boundingSphere === null && (this.boundingSphere = new Ys),
                        this.boundingSphere.makeEmpty();
                        const t = e.getAttribute("position");
                        for (let n = 0; n < t.count; n++)
                            this.getVertexPosition(n, q_),
                            this.boundingSphere.expandByPoint(q_)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.bindMode = e.bindMode,
                        this.bindMatrix.copy(e.bindMatrix),
                        this.bindMatrixInverse.copy(e.bindMatrixInverse),
                        this.skeleton = e.skeleton,
                        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
                        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
                        this
                    }
                    raycast(e, t) {
                        const n = this.material
                          , i = this.matrixWorld;
                        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        tT.copy(this.boundingSphere),
                        tT.applyMatrix4(i),
                        e.ray.intersectsSphere(tT) !== !1 && (ew.copy(i).invert(),
                        nT.copy(e.ray).applyMatrix4(ew),
                        !(this.boundingBox !== null && nT.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, nT)))
                    }
                    getVertexPosition(e, t) {
                        return super.getVertexPosition(e, t),
                        this.applyBoneTransform(e, t),
                        t
                    }
                    bind(e, t) {
                        this.skeleton = e,
                        t === void 0 && (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        t = this.matrixWorld),
                        this.bindMatrix.copy(t),
                        this.bindMatrixInverse.copy(t).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const e = new hn
                          , t = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = t.count; n < i; n++) {
                            e.fromBufferAttribute(t, n);
                            const s = 1 / e.manhattanLength();
                            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
                            t.setXYZW(n, e.x, e.y, e.z, e.w)
                        }
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                        this.bindMode === vA ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === aC ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    applyBoneTransform(e, t) {
                        const n = this.skeleton
                          , i = this.geometry;
                        KC.fromBufferAttribute(i.attributes.skinIndex, e),
                        JC.fromBufferAttribute(i.attributes.skinWeight, e),
                        ZC.copy(t).applyMatrix4(this.bindMatrix),
                        t.set(0, 0, 0);
                        for (let s = 0; s < 4; s++) {
                            const a = JC.getComponent(s);
                            if (a !== 0) {
                                const o = KC.getComponent(s);
                                $C.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]),
                                t.addScaledVector(mL.copy(ZC).applyMatrix4($C), a)
                            }
                        }
                        return t.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                  , iT = class extends $n {
                    constructor() {
                        super(),
                        this.isBone = !0,
                        this.type = "Bone"
                    }
                }
                  , ul = class extends Fi {
                    constructor(e=null, t=1, n=1, i, s, a, o, c, u=ri, f=ri, m, v) {
                        super(null, a, o, c, u, f, i, s, m, v),
                        this.isDataTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n
                        },
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                ;
                const nw = new Xt
                  , vL = new Xt;
                var iw = class vU {
                    constructor(t=[], n=[]) {
                        this.uuid = jr(),
                        this.bones = t.slice(0),
                        this.boneInverses = n,
                        this.boneMatrices = null,
                        this.boneTexture = null,
                        this.init()
                    }
                    init() {
                        const t = this.bones
                          , n = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(t.length * 16),
                        n.length === 0)
                            this.calculateInverses();
                        else if (t.length !== n.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                            this.boneInverses = [];
                            for (let i = 0, s = this.bones.length; i < s; i++)
                                this.boneInverses.push(new Xt)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const i = new Xt;
                            this.bones[t] && i.copy(this.bones[t].matrixWorld).invert(),
                            this.boneInverses.push(i)
                        }
                    }
                    pose() {
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const i = this.bones[t];
                            i && i.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const i = this.bones[t];
                            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
                            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
                            i.matrix.decompose(i.position, i.quaternion, i.scale))
                        }
                    }
                    update() {
                        const t = this.bones
                          , n = this.boneInverses
                          , i = this.boneMatrices
                          , s = this.boneTexture;
                        for (let a = 0, o = t.length; a < o; a++) {
                            const c = t[a] ? t[a].matrixWorld : vL;
                            nw.multiplyMatrices(c, n[a]),
                            nw.toArray(i, a * 16)
                        }
                        s !== null && (s.needsUpdate = !0)
                    }
                    clone() {
                        return new vU(this.bones,this.boneInverses)
                    }
                    computeBoneTexture() {
                        let t = Math.sqrt(this.bones.length * 4);
                        t = Math.ceil(t / 4) * 4,
                        t = Math.max(t, 4);
                        const n = new Float32Array(t * t * 4);
                        n.set(this.boneMatrices);
                        const i = new ul(n,t,t,ps,na);
                        return i.needsUpdate = !0,
                        this.boneMatrices = n,
                        this.boneTexture = i,
                        this
                    }
                    getBoneByName(t) {
                        for (let n = 0, i = this.bones.length; n < i; n++) {
                            const s = this.bones[n];
                            if (s.name === t)
                                return s
                        }
                    }
                    dispose() {
                        this.boneTexture !== null && (this.boneTexture.dispose(),
                        this.boneTexture = null)
                    }
                    fromJSON(t, n) {
                        this.uuid = t.uuid;
                        for (let i = 0, s = t.bones.length; i < s; i++) {
                            const a = t.bones[i];
                            let o = n[a];
                            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", a),
                            o = new iT),
                            this.bones.push(o),
                            this.boneInverses.push(new Xt().fromArray(t.boneInverses[i]))
                        }
                        return this.init(),
                        this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        t.uuid = this.uuid;
                        const n = this.bones
                          , i = this.boneInverses;
                        for (let s = 0, a = n.length; s < a; s++) {
                            const o = n[s];
                            t.bones.push(o.uuid);
                            const c = i[s];
                            t.boneInverses.push(c.toArray())
                        }
                        return t
                    }
                }
                  , Af = class extends Ln {
                    constructor(e, t, n, i=1) {
                        super(e, t, n),
                        this.isInstancedBufferAttribute = !0,
                        this.meshPerAttribute = i
                    }
                    copy(e) {
                        return super.copy(e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.meshPerAttribute = this.meshPerAttribute,
                        e.isInstancedBufferAttribute = !0,
                        e
                    }
                }
                ;
                const Vp = new Xt
                  , sw = new Xt
                  , j_ = []
                  , aw = new Ws
                  , gL = new Xt
                  , wg = new oi
                  , Dg = new Ys;
                var rw = class extends oi {
                    constructor(e, t, n) {
                        super(e, t),
                        this.isInstancedMesh = !0,
                        this.instanceMatrix = new Af(new Float32Array(n * 16),16),
                        this.instanceColor = null,
                        this.morphTexture = null,
                        this.count = n,
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        for (let i = 0; i < n; i++)
                            this.setMatrixAt(i, gL)
                    }
                    computeBoundingBox() {
                        const e = this.geometry
                          , t = this.count;
                        this.boundingBox === null && (this.boundingBox = new Ws),
                        e.boundingBox === null && e.computeBoundingBox(),
                        this.boundingBox.makeEmpty();
                        for (let n = 0; n < t; n++)
                            this.getMatrixAt(n, Vp),
                            aw.copy(e.boundingBox).applyMatrix4(Vp),
                            this.boundingBox.union(aw)
                    }
                    computeBoundingSphere() {
                        const e = this.geometry
                          , t = this.count;
                        this.boundingSphere === null && (this.boundingSphere = new Ys),
                        e.boundingSphere === null && e.computeBoundingSphere(),
                        this.boundingSphere.makeEmpty();
                        for (let n = 0; n < t; n++)
                            this.getMatrixAt(n, Vp),
                            Dg.copy(e.boundingSphere).applyMatrix4(Vp),
                            this.boundingSphere.union(Dg)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.instanceMatrix.copy(e.instanceMatrix),
                        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
                        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
                        this.count = e.count,
                        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
                        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
                        this
                    }
                    getColorAt(e, t) {
                        t.fromArray(this.instanceColor.array, e * 3)
                    }
                    getMatrixAt(e, t) {
                        t.fromArray(this.instanceMatrix.array, e * 16)
                    }
                    getMorphAt(e, t) {
                        const n = t.morphTargetInfluences
                          , i = this.morphTexture.source.data.data
                          , s = n.length + 1
                          , a = e * s + 1;
                        for (let o = 0; o < n.length; o++)
                            n[o] = i[a + o]
                    }
                    raycast(e, t) {
                        const n = this.matrixWorld
                          , i = this.count;
                        if (wg.geometry = this.geometry,
                        wg.material = this.material,
                        wg.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        Dg.copy(this.boundingSphere),
                        Dg.applyMatrix4(n),
                        e.ray.intersectsSphere(Dg) !== !1))
                            for (let s = 0; s < i; s++) {
                                this.getMatrixAt(s, Vp),
                                sw.multiplyMatrices(n, Vp),
                                wg.matrixWorld = sw,
                                wg.raycast(e, j_);
                                for (let a = 0, o = j_.length; a < o; a++) {
                                    const c = j_[a];
                                    c.instanceId = s,
                                    c.object = this,
                                    t.push(c)
                                }
                                j_.length = 0
                            }
                    }
                    setColorAt(e, t) {
                        this.instanceColor === null && (this.instanceColor = new Af(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
                        t.toArray(this.instanceColor.array, e * 3)
                    }
                    setMatrixAt(e, t) {
                        t.toArray(this.instanceMatrix.array, e * 16)
                    }
                    setMorphAt(e, t) {
                        const n = t.morphTargetInfluences
                          , i = n.length + 1;
                        this.morphTexture === null && (this.morphTexture = new ul(new Float32Array(i * this.count),i,this.count,gp,na));
                        const s = this.morphTexture.source.data.data;
                        let a = 0;
                        for (let u = 0; u < n.length; u++)
                            a += n[u];
                        const o = this.geometry.morphTargetsRelative ? 1 : 1 - a
                          , c = i * e;
                        s[c] = o,
                        s.set(n, c + 1)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        }),
                        this.morphTexture !== null && (this.morphTexture.dispose(),
                        this.morphTexture = null)
                    }
                }
                ;
                const sT = new ae
                  , yL = new ae
                  , _L = new nn;
                var au = class {
                    constructor(e=new ae(1,0,0), t=0) {
                        this.isPlane = !0,
                        this.normal = e,
                        this.constant = t
                    }
                    set(e, t) {
                        return this.normal.copy(e),
                        this.constant = t,
                        this
                    }
                    setComponents(e, t, n, i) {
                        return this.normal.set(e, t, n),
                        this.constant = i,
                        this
                    }
                    setFromNormalAndCoplanarPoint(e, t) {
                        return this.normal.copy(e),
                        this.constant = -t.dot(this.normal),
                        this
                    }
                    setFromCoplanarPoints(e, t, n) {
                        const i = sT.subVectors(n, t).cross(yL.subVectors(e, t)).normalize();
                        return this.setFromNormalAndCoplanarPoint(i, e),
                        this
                    }
                    copy(e) {
                        return this.normal.copy(e.normal),
                        this.constant = e.constant,
                        this
                    }
                    normalize() {
                        const e = 1 / this.normal.length();
                        return this.normal.multiplyScalar(e),
                        this.constant *= e,
                        this
                    }
                    negate() {
                        return this.constant *= -1,
                        this.normal.negate(),
                        this
                    }
                    distanceToPoint(e) {
                        return this.normal.dot(e) + this.constant
                    }
                    distanceToSphere(e) {
                        return this.distanceToPoint(e.center) - e.radius
                    }
                    projectPoint(e, t) {
                        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                    }
                    intersectLine(e, t) {
                        const n = e.delta(sT)
                          , i = this.normal.dot(n);
                        if (i === 0)
                            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
                        const s = -(e.start.dot(this.normal) + this.constant) / i;
                        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
                    }
                    intersectsLine(e) {
                        const t = this.distanceToPoint(e.start)
                          , n = this.distanceToPoint(e.end);
                        return t < 0 && n > 0 || n < 0 && t > 0
                    }
                    intersectsBox(e) {
                        return e.intersectsPlane(this)
                    }
                    intersectsSphere(e) {
                        return e.intersectsPlane(this)
                    }
                    coplanarPoint(e) {
                        return e.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(e, t) {
                        const n = t || _L.getNormalMatrix(e)
                          , i = this.coplanarPoint(sT).applyMatrix4(e)
                          , s = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(s),
                        this
                    }
                    translate(e) {
                        return this.constant -= e.dot(this.normal),
                        this
                    }
                    equals(e) {
                        return e.normal.equals(this.normal) && e.constant === this.constant
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const Tf = new Ys
                  , SL = new Oe(.5,.5)
                  , Q_ = new ae;
                var kp = class {
                    constructor(e=new au, t=new au, n=new au, i=new au, s=new au, a=new au) {
                        this.planes = [e, t, n, i, s, a]
                    }
                    set(e, t, n, i, s, a) {
                        const o = this.planes;
                        return o[0].copy(e),
                        o[1].copy(t),
                        o[2].copy(n),
                        o[3].copy(i),
                        o[4].copy(s),
                        o[5].copy(a),
                        this
                    }
                    copy(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            t[n].copy(e.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(e, t=Yr, n=!1) {
                        const i = this.planes
                          , s = e.elements
                          , a = s[0]
                          , o = s[1]
                          , c = s[2]
                          , u = s[3]
                          , f = s[4]
                          , m = s[5]
                          , v = s[6]
                          , y = s[7]
                          , S = s[8]
                          , A = s[9]
                          , M = s[10]
                          , x = s[11]
                          , T = s[12]
                          , D = s[13]
                          , w = s[14]
                          , U = s[15];
                        if (i[0].setComponents(u - a, y - f, x - S, U - T).normalize(),
                        i[1].setComponents(u + a, y + f, x + S, U + T).normalize(),
                        i[2].setComponents(u + o, y + m, x + A, U + D).normalize(),
                        i[3].setComponents(u - o, y - m, x - A, U - D).normalize(),
                        n)
                            i[4].setComponents(c, v, M, w).normalize(),
                            i[5].setComponents(u - c, y - v, x - M, U - w).normalize();
                        else if (i[4].setComponents(u - c, y - v, x - M, U - w).normalize(),
                        t === Yr)
                            i[5].setComponents(u + c, y + v, x + M, U + w).normalize();
                        else if (t === yp)
                            i[5].setComponents(c, v, M, w).normalize();
                        else
                            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                        return this
                    }
                    intersectsObject(e) {
                        if (e.boundingSphere !== void 0)
                            e.boundingSphere === null && e.computeBoundingSphere(),
                            Tf.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                        else {
                            const t = e.geometry;
                            t.boundingSphere === null && t.computeBoundingSphere(),
                            Tf.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                        }
                        return this.intersectsSphere(Tf)
                    }
                    intersectsSprite(e) {
                        return Tf.center.set(0, 0, 0),
                        Tf.radius = .7071067811865476 + SL.distanceTo(e.center),
                        Tf.applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(Tf)
                    }
                    intersectsSphere(e) {
                        const t = this.planes
                          , n = e.center
                          , i = -e.radius;
                        for (let s = 0; s < 6; s++)
                            if (t[s].distanceToPoint(n) < i)
                                return !1;
                        return !0
                    }
                    intersectsBox(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const i = t[n];
                            if (Q_.x = i.normal.x > 0 ? e.max.x : e.min.x,
                            Q_.y = i.normal.y > 0 ? e.max.y : e.min.y,
                            Q_.z = i.normal.z > 0 ? e.max.z : e.min.z,
                            i.distanceToPoint(Q_) < 0)
                                return !1
                        }
                        return !0
                    }
                    containsPoint(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (t[n].distanceToPoint(e) < 0)
                                return !1;
                        return !0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const oc = new Xt
                  , lc = new kp;
                var ow = class gU {
                    constructor() {
                        this.coordinateSystem = Yr
                    }
                    intersectsObject(t, n) {
                        if (!n.isArrayCamera || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (oc.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            lc.setFromProjectionMatrix(oc, s.coordinateSystem, s.reversedDepth),
                            lc.intersectsObject(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsSprite(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (oc.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            lc.setFromProjectionMatrix(oc, s.coordinateSystem, s.reversedDepth),
                            lc.intersectsSprite(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsSphere(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (oc.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            lc.setFromProjectionMatrix(oc, s.coordinateSystem, s.reversedDepth),
                            lc.intersectsSphere(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsBox(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (oc.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            lc.setFromProjectionMatrix(oc, s.coordinateSystem, s.reversedDepth),
                            lc.intersectsBox(t))
                                return !0
                        }
                        return !1
                    }
                    containsPoint(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (oc.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            lc.setFromProjectionMatrix(oc, s.coordinateSystem, s.reversedDepth),
                            lc.containsPoint(t))
                                return !0
                        }
                        return !1
                    }
                    clone() {
                        return new gU
                    }
                }
                ;
                function aT(e, t) {
                    return e - t
                }
                function xL(e, t) {
                    return e.z - t.z
                }
                function AL(e, t) {
                    return t.z - e.z
                }
                var TL = class {
                    constructor() {
                        this.index = 0,
                        this.pool = [],
                        this.list = []
                    }
                    push(e, t, n, i) {
                        const s = this.pool
                          , a = this.list;
                        this.index >= s.length && s.push({
                            start: -1,
                            count: -1,
                            z: -1,
                            index: -1
                        });
                        const o = s[this.index];
                        a.push(o),
                        this.index++,
                        o.start = e,
                        o.count = t,
                        o.z = n,
                        o.index = i
                    }
                    reset() {
                        this.list.length = 0,
                        this.index = 0
                    }
                }
                ;
                const xr = new Xt
                  , ML = new ft(1,1,1)
                  , lw = new kp
                  , bL = new ow
                  , Z_ = new Ws
                  , Mf = new Ys
                  , Rg = new ae
                  , cw = new ae
                  , EL = new ae
                  , rT = new TL
                  , ba = new oi
                  , K_ = [];
                function CL(e, t, n=0) {
                    const i = t.itemSize;
                    if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                        const s = e.count;
                        for (let a = 0; a < s; a++)
                            for (let o = 0; o < i; o++)
                                t.setComponent(a + n, o, e.getComponent(a, o))
                    } else
                        t.array.set(e.array, n * i);
                    t.needsUpdate = !0
                }
                function bf(e, t) {
                    if (e.constructor !== t.constructor) {
                        const n = Math.min(e.length, t.length);
                        for (let i = 0; i < n; i++)
                            t[i] = e[i]
                    } else {
                        const n = Math.min(e.length, t.length);
                        t.set(new e.constructor(e.buffer,0,n))
                    }
                }
                var uw = class extends oi {
                    constructor(e, t, n=t * 2, i) {
                        super(new sn, i),
                        this.isBatchedMesh = !0,
                        this.perObjectFrustumCulled = !0,
                        this.sortObjects = !0,
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.customSort = null,
                        this._instanceInfo = [],
                        this._geometryInfo = [],
                        this._availableInstanceIds = [],
                        this._availableGeometryIds = [],
                        this._nextIndexStart = 0,
                        this._nextVertexStart = 0,
                        this._geometryCount = 0,
                        this._visibilityChanged = !0,
                        this._geometryInitialized = !1,
                        this._maxInstanceCount = e,
                        this._maxVertexCount = t,
                        this._maxIndexCount = n,
                        this._multiDrawCounts = new Int32Array(e),
                        this._multiDrawStarts = new Int32Array(e),
                        this._multiDrawCount = 0,
                        this._multiDrawInstances = null,
                        this._matricesTexture = null,
                        this._indirectTexture = null,
                        this._colorsTexture = null,
                        this._initMatricesTexture(),
                        this._initIndirectTexture()
                    }
                    get maxInstanceCount() {
                        return this._maxInstanceCount
                    }
                    get instanceCount() {
                        return this._instanceInfo.length - this._availableInstanceIds.length
                    }
                    get unusedVertexCount() {
                        return this._maxVertexCount - this._nextVertexStart
                    }
                    get unusedIndexCount() {
                        return this._maxIndexCount - this._nextIndexStart
                    }
                    _initMatricesTexture() {
                        let e = Math.sqrt(this._maxInstanceCount * 4);
                        e = Math.ceil(e / 4) * 4,
                        e = Math.max(e, 4);
                        const t = new Float32Array(e * e * 4);
                        this._matricesTexture = new ul(t,e,e,ps,na)
                    }
                    _initIndirectTexture() {
                        let e = Math.sqrt(this._maxInstanceCount);
                        e = Math.ceil(e);
                        const t = new Uint32Array(e * e);
                        this._indirectTexture = new ul(t,e,e,ag,ac)
                    }
                    _initColorsTexture() {
                        let e = Math.sqrt(this._maxInstanceCount);
                        e = Math.ceil(e);
                        const t = new Float32Array(e * e * 4).fill(1)
                          , n = new ul(t,e,e,ps,na);
                        n.colorSpace = Rn.workingColorSpace,
                        this._colorsTexture = n
                    }
                    _initializeGeometry(e) {
                        const t = this.geometry
                          , n = this._maxVertexCount
                          , i = this._maxIndexCount;
                        if (this._geometryInitialized === !1) {
                            for (const s in e.attributes) {
                                const {array: a, itemSize: o, normalized: c} = e.getAttribute(s)
                                  , u = new a.constructor(n * o)
                                  , f = new Ln(u,o,c);
                                t.setAttribute(s, f)
                            }
                            if (e.getIndex() !== null) {
                                const s = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                                t.setIndex(new Ln(s,1))
                            }
                            this._geometryInitialized = !0
                        }
                    }
                    _validateGeometry(e) {
                        const t = this.geometry;
                        if (!!e.getIndex() != !!t.getIndex())
                            throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
                        for (const n in t.attributes) {
                            if (!e.hasAttribute(n))
                                throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                            const i = e.getAttribute(n)
                              , s = t.getAttribute(n);
                            if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
                                throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                        }
                    }
                    validateInstanceId(e) {
                        const t = this._instanceInfo;
                        if (e < 0 || e >= t.length || t[e].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
                    }
                    validateGeometryId(e) {
                        const t = this._geometryInfo;
                        if (e < 0 || e >= t.length || t[e].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
                    }
                    setCustomSort(e) {
                        return this.customSort = e,
                        this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new Ws);
                        const e = this.boundingBox
                          , t = this._instanceInfo;
                        e.makeEmpty();
                        for (let n = 0, i = t.length; n < i; n++) {
                            if (t[n].active === !1)
                                continue;
                            const s = t[n].geometryIndex;
                            this.getMatrixAt(n, xr),
                            this.getBoundingBoxAt(s, Z_).applyMatrix4(xr),
                            e.union(Z_)
                        }
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new Ys);
                        const e = this.boundingSphere
                          , t = this._instanceInfo;
                        e.makeEmpty();
                        for (let n = 0, i = t.length; n < i; n++) {
                            if (t[n].active === !1)
                                continue;
                            const s = t[n].geometryIndex;
                            this.getMatrixAt(n, xr),
                            this.getBoundingSphereAt(s, Mf).applyMatrix4(xr),
                            e.union(Mf)
                        }
                    }
                    addInstance(e) {
                        if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
                            throw new Error("THREE.BatchedMesh: Maximum item count reached.");
                        const t = {
                            visible: !0,
                            active: !0,
                            geometryIndex: e
                        };
                        let n = null;
                        this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(aT),
                        n = this._availableInstanceIds.shift(),
                        this._instanceInfo[n] = t) : (n = this._instanceInfo.length,
                        this._instanceInfo.push(t));
                        const i = this._matricesTexture;
                        xr.identity().toArray(i.image.data, n * 16),
                        i.needsUpdate = !0;
                        const s = this._colorsTexture;
                        return s && (ML.toArray(s.image.data, n * 4),
                        s.needsUpdate = !0),
                        this._visibilityChanged = !0,
                        n
                    }
                    addGeometry(e, t=-1, n=-1) {
                        this._initializeGeometry(e),
                        this._validateGeometry(e);
                        const i = {
                            vertexStart: -1,
                            vertexCount: -1,
                            reservedVertexCount: -1,
                            indexStart: -1,
                            indexCount: -1,
                            reservedIndexCount: -1,
                            start: -1,
                            count: -1,
                            boundingBox: null,
                            boundingSphere: null,
                            active: !0
                        }
                          , s = this._geometryInfo;
                        i.vertexStart = this._nextVertexStart,
                        i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
                        const a = e.getIndex();
                        if (a !== null && (i.indexStart = this._nextIndexStart,
                        i.reservedIndexCount = n === -1 ? a.count : n),
                        i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                        let o;
                        return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(aT),
                        o = this._availableGeometryIds.shift(),
                        s[o] = i) : (o = this._geometryCount,
                        this._geometryCount++,
                        s.push(i)),
                        this.setGeometryAt(o, e),
                        this._nextIndexStart = i.indexStart + i.reservedIndexCount,
                        this._nextVertexStart = i.vertexStart + i.reservedVertexCount,
                        o
                    }
                    setGeometryAt(e, t) {
                        if (e >= this._geometryCount)
                            throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
                        this._validateGeometry(t);
                        const n = this.geometry
                          , i = n.getIndex() !== null
                          , s = n.getIndex()
                          , a = t.getIndex()
                          , o = this._geometryInfo[e];
                        if (i && a.count > o.reservedIndexCount || t.attributes.position.count > o.reservedVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
                        const c = o.vertexStart
                          , u = o.reservedVertexCount;
                        o.vertexCount = t.getAttribute("position").count;
                        for (const f in n.attributes) {
                            const m = t.getAttribute(f)
                              , v = n.getAttribute(f);
                            CL(m, v, c);
                            const y = m.itemSize;
                            for (let S = m.count, A = u; S < A; S++) {
                                const M = c + S;
                                for (let x = 0; x < y; x++)
                                    v.setComponent(M, x, 0)
                            }
                            v.needsUpdate = !0,
                            v.addUpdateRange(c * y, u * y)
                        }
                        if (i) {
                            const f = o.indexStart
                              , m = o.reservedIndexCount;
                            o.indexCount = t.getIndex().count;
                            for (let v = 0; v < a.count; v++)
                                s.setX(f + v, c + a.getX(v));
                            for (let v = a.count, y = m; v < y; v++)
                                s.setX(f + v, c);
                            s.needsUpdate = !0,
                            s.addUpdateRange(f, o.reservedIndexCount)
                        }
                        return o.start = i ? o.indexStart : o.vertexStart,
                        o.count = i ? o.indexCount : o.vertexCount,
                        o.boundingBox = null,
                        t.boundingBox !== null && (o.boundingBox = t.boundingBox.clone()),
                        o.boundingSphere = null,
                        t.boundingSphere !== null && (o.boundingSphere = t.boundingSphere.clone()),
                        this._visibilityChanged = !0,
                        e
                    }
                    deleteGeometry(e) {
                        const t = this._geometryInfo;
                        if (e >= t.length || t[e].active === !1)
                            return this;
                        const n = this._instanceInfo;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
                        return t[e].active = !1,
                        this._availableGeometryIds.push(e),
                        this._visibilityChanged = !0,
                        this
                    }
                    deleteInstance(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].active = !1,
                        this._availableInstanceIds.push(e),
                        this._visibilityChanged = !0,
                        this
                    }
                    optimize() {
                        let e = 0
                          , t = 0;
                        const n = this._geometryInfo
                          , i = n.map( (a, o) => o).sort( (a, o) => n[a].vertexStart - n[o].vertexStart)
                          , s = this.geometry;
                        for (let a = 0, o = n.length; a < o; a++) {
                            const c = i[a]
                              , u = n[c];
                            if (u.active !== !1) {
                                if (s.index !== null) {
                                    if (u.indexStart !== t) {
                                        const {indexStart: f, vertexStart: m, reservedIndexCount: v} = u
                                          , y = s.index
                                          , S = y.array
                                          , A = e - m;
                                        for (let M = f; M < f + v; M++)
                                            S[M] = S[M] + A;
                                        y.array.copyWithin(t, f, f + v),
                                        y.addUpdateRange(t, v),
                                        u.indexStart = t
                                    }
                                    t += u.reservedIndexCount
                                }
                                if (u.vertexStart !== e) {
                                    const {vertexStart: f, reservedVertexCount: m} = u
                                      , v = s.attributes;
                                    for (const y in v) {
                                        const S = v[y]
                                          , {array: A, itemSize: M} = S;
                                        A.copyWithin(e * M, f * M, (f + m) * M),
                                        S.addUpdateRange(e * M, m * M)
                                    }
                                    u.vertexStart = e
                                }
                                e += u.reservedVertexCount,
                                u.start = s.index ? u.indexStart : u.vertexStart,
                                this._nextIndexStart = s.index ? u.indexStart + u.reservedIndexCount : 0,
                                this._nextVertexStart = u.vertexStart + u.reservedVertexCount
                            }
                        }
                        return this
                    }
                    getBoundingBoxAt(e, t) {
                        if (e >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , i = this._geometryInfo[e];
                        if (i.boundingBox === null) {
                            const s = new Ws
                              , a = n.index
                              , o = n.attributes.position;
                            for (let c = i.start, u = i.start + i.count; c < u; c++) {
                                let f = c;
                                a && (f = a.getX(f)),
                                s.expandByPoint(Rg.fromBufferAttribute(o, f))
                            }
                            i.boundingBox = s
                        }
                        return t.copy(i.boundingBox),
                        t
                    }
                    getBoundingSphereAt(e, t) {
                        if (e >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , i = this._geometryInfo[e];
                        if (i.boundingSphere === null) {
                            const s = new Ys;
                            this.getBoundingBoxAt(e, Z_),
                            Z_.getCenter(s.center);
                            const a = n.index
                              , o = n.attributes.position;
                            let c = 0;
                            for (let u = i.start, f = i.start + i.count; u < f; u++) {
                                let m = u;
                                a && (m = a.getX(m)),
                                Rg.fromBufferAttribute(o, m),
                                c = Math.max(c, s.center.distanceToSquared(Rg))
                            }
                            s.radius = Math.sqrt(c),
                            i.boundingSphere = s
                        }
                        return t.copy(i.boundingSphere),
                        t
                    }
                    setMatrixAt(e, t) {
                        this.validateInstanceId(e);
                        const n = this._matricesTexture
                          , i = this._matricesTexture.image.data;
                        return t.toArray(i, e * 16),
                        n.needsUpdate = !0,
                        this
                    }
                    getMatrixAt(e, t) {
                        return this.validateInstanceId(e),
                        t.fromArray(this._matricesTexture.image.data, e * 16)
                    }
                    setColorAt(e, t) {
                        return this.validateInstanceId(e),
                        this._colorsTexture === null && this._initColorsTexture(),
                        t.toArray(this._colorsTexture.image.data, e * 4),
                        this._colorsTexture.needsUpdate = !0,
                        this
                    }
                    getColorAt(e, t) {
                        return this.validateInstanceId(e),
                        t.fromArray(this._colorsTexture.image.data, e * 4)
                    }
                    setVisibleAt(e, t) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t,
                        this._visibilityChanged = !0,
                        this)
                    }
                    getVisibleAt(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].visible
                    }
                    setGeometryIdAt(e, t) {
                        return this.validateInstanceId(e),
                        this.validateGeometryId(t),
                        this._instanceInfo[e].geometryIndex = t,
                        this
                    }
                    getGeometryIdAt(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].geometryIndex
                    }
                    getGeometryRangeAt(e, t={}) {
                        this.validateGeometryId(e);
                        const n = this._geometryInfo[e];
                        return t.vertexStart = n.vertexStart,
                        t.vertexCount = n.vertexCount,
                        t.reservedVertexCount = n.reservedVertexCount,
                        t.indexStart = n.indexStart,
                        t.indexCount = n.indexCount,
                        t.reservedIndexCount = n.reservedIndexCount,
                        t.start = n.start,
                        t.count = n.count,
                        t
                    }
                    setInstanceCount(e) {
                        const t = this._availableInstanceIds
                          , n = this._instanceInfo;
                        for (t.sort(aT); t[t.length - 1] === n.length - 1; )
                            n.pop(),
                            t.pop();
                        if (e < n.length)
                            throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
                        const i = new Int32Array(e)
                          , s = new Int32Array(e);
                        bf(this._multiDrawCounts, i),
                        bf(this._multiDrawStarts, s),
                        this._multiDrawCounts = i,
                        this._multiDrawStarts = s,
                        this._maxInstanceCount = e;
                        const a = this._indirectTexture
                          , o = this._matricesTexture
                          , c = this._colorsTexture;
                        a.dispose(),
                        this._initIndirectTexture(),
                        bf(a.image.data, this._indirectTexture.image.data),
                        o.dispose(),
                        this._initMatricesTexture(),
                        bf(o.image.data, this._matricesTexture.image.data),
                        c && (c.dispose(),
                        this._initColorsTexture(),
                        bf(c.image.data, this._colorsTexture.image.data))
                    }
                    setGeometrySize(e, t) {
                        const n = [...this._geometryInfo].filter(a => a.active);
                        if (Math.max(...n.map(a => a.vertexStart + a.reservedVertexCount)) > e)
                            throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
                        if (this.geometry.index && Math.max(...n.map(a => a.indexStart + a.reservedIndexCount)) > t)
                            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
                        const i = this.geometry;
                        i.dispose(),
                        this._maxVertexCount = e,
                        this._maxIndexCount = t,
                        this._geometryInitialized && (this._geometryInitialized = !1,
                        this.geometry = new sn,
                        this._initializeGeometry(i));
                        const s = this.geometry;
                        i.index && bf(i.index.array, s.index.array);
                        for (const a in i.attributes)
                            bf(i.attributes[a].array, s.attributes[a].array)
                    }
                    raycast(e, t) {
                        const n = this._instanceInfo
                          , i = this._geometryInfo
                          , s = this.matrixWorld
                          , a = this.geometry;
                        ba.material = this.material,
                        ba.geometry.index = a.index,
                        ba.geometry.attributes = a.attributes,
                        ba.geometry.boundingBox === null && (ba.geometry.boundingBox = new Ws),
                        ba.geometry.boundingSphere === null && (ba.geometry.boundingSphere = new Ys);
                        for (let o = 0, c = n.length; o < c; o++) {
                            if (!n[o].visible || !n[o].active)
                                continue;
                            const u = n[o].geometryIndex
                              , f = i[u];
                            ba.geometry.setDrawRange(f.start, f.count),
                            this.getMatrixAt(o, ba.matrixWorld).premultiply(s),
                            this.getBoundingBoxAt(u, ba.geometry.boundingBox),
                            this.getBoundingSphereAt(u, ba.geometry.boundingSphere),
                            ba.raycast(e, K_);
                            for (let m = 0, v = K_.length; m < v; m++) {
                                const y = K_[m];
                                y.object = this,
                                y.batchId = o,
                                t.push(y)
                            }
                            K_.length = 0
                        }
                        ba.material = null,
                        ba.geometry.index = null,
                        ba.geometry.attributes = {},
                        ba.geometry.setDrawRange(0, 1 / 0)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.geometry = e.geometry.clone(),
                        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
                        this.sortObjects = e.sortObjects,
                        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
                        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
                        this._geometryInfo = e._geometryInfo.map(t => ({
                            ...t,
                            boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
                            boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
                        })),
                        this._instanceInfo = e._instanceInfo.map(t => ({
                            ...t
                        })),
                        this._availableInstanceIds = e._availableInstanceIds.slice(),
                        this._availableGeometryIds = e._availableGeometryIds.slice(),
                        this._nextIndexStart = e._nextIndexStart,
                        this._nextVertexStart = e._nextVertexStart,
                        this._geometryCount = e._geometryCount,
                        this._maxInstanceCount = e._maxInstanceCount,
                        this._maxVertexCount = e._maxVertexCount,
                        this._maxIndexCount = e._maxIndexCount,
                        this._geometryInitialized = e._geometryInitialized,
                        this._multiDrawCounts = e._multiDrawCounts.slice(),
                        this._multiDrawStarts = e._multiDrawStarts.slice(),
                        this._indirectTexture = e._indirectTexture.clone(),
                        this._indirectTexture.image.data = this._indirectTexture.image.data.slice(),
                        this._matricesTexture = e._matricesTexture.clone(),
                        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
                        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
                        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this._matricesTexture.dispose(),
                        this._matricesTexture = null,
                        this._indirectTexture.dispose(),
                        this._indirectTexture = null,
                        this._colorsTexture !== null && (this._colorsTexture.dispose(),
                        this._colorsTexture = null)
                    }
                    onBeforeRender(e, t, n, i, s) {
                        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                            return;
                        const a = i.getIndex()
                          , o = a === null ? 1 : a.array.BYTES_PER_ELEMENT
                          , c = this._instanceInfo
                          , u = this._multiDrawStarts
                          , f = this._multiDrawCounts
                          , m = this._geometryInfo
                          , v = this.perObjectFrustumCulled
                          , y = this._indirectTexture
                          , S = y.image.data
                          , A = n.isArrayCamera ? bL : lw;
                        v && !n.isArrayCamera && (xr.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
                        lw.setFromProjectionMatrix(xr, n.coordinateSystem, n.reversedDepth));
                        let M = 0;
                        if (this.sortObjects) {
                            xr.copy(this.matrixWorld).invert(),
                            Rg.setFromMatrixPosition(n.matrixWorld).applyMatrix4(xr),
                            cw.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(xr);
                            for (let D = 0, w = c.length; D < w; D++)
                                if (c[D].visible && c[D].active) {
                                    const U = c[D].geometryIndex;
                                    this.getMatrixAt(D, xr),
                                    this.getBoundingSphereAt(U, Mf).applyMatrix4(xr);
                                    let O = !1;
                                    if (v && (O = !A.intersectsSphere(Mf, n)),
                                    !O) {
                                        const L = m[U]
                                          , N = EL.subVectors(Mf.center, Rg).dot(cw);
                                        rT.push(L.start, L.count, N, D)
                                    }
                                }
                            const x = rT.list
                              , T = this.customSort;
                            T === null ? x.sort(s.transparent ? AL : xL) : T.call(this, x, n);
                            for (let D = 0, w = x.length; D < w; D++) {
                                const U = x[D];
                                u[M] = U.start * o,
                                f[M] = U.count,
                                S[M] = U.index,
                                M++
                            }
                            rT.reset()
                        } else
                            for (let x = 0, T = c.length; x < T; x++)
                                if (c[x].visible && c[x].active) {
                                    const D = c[x].geometryIndex;
                                    let w = !1;
                                    if (v && (this.getMatrixAt(x, xr),
                                    this.getBoundingSphereAt(D, Mf).applyMatrix4(xr),
                                    w = !A.intersectsSphere(Mf, n)),
                                    !w) {
                                        const U = m[D];
                                        u[M] = U.start * o,
                                        f[M] = U.count,
                                        S[M] = x,
                                        M++
                                    }
                                }
                        y.needsUpdate = !0,
                        this._multiDrawCount = M,
                        this._visibilityChanged = !1
                    }
                    onBeforeShadow(e, t, n, i, s, a) {
                        this.onBeforeRender(e, null, i, s, a)
                    }
                }
                  , ir = class extends qs {
                    constructor(e) {
                        super(),
                        this.isLineBasicMaterial = !0,
                        this.type = "LineBasicMaterial",
                        this.color = new ft(16777215),
                        this.map = null,
                        this.linewidth = 1,
                        this.linecap = "round",
                        this.linejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.linewidth = e.linewidth,
                        this.linecap = e.linecap,
                        this.linejoin = e.linejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const J_ = new ae
                  , $_ = new ae
                  , hw = new Xt
                  , Ug = new Ep
                  , eS = new Ys
                  , oT = new ae
                  , fw = new ae;
                var mh = class extends $n {
                    constructor(e=new sn, t=new ir) {
                        super(),
                        this.isLine = !0,
                        this.type = "Line",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.index === null) {
                            const t = e.attributes.position
                              , n = [0];
                            for (let i = 1, s = t.count; i < s; i++)
                                J_.fromBufferAttribute(t, i - 1),
                                $_.fromBufferAttribute(t, i),
                                n[i] = n[i - 1],
                                n[i] += J_.distanceTo($_);
                            e.setAttribute("lineDistance", new Rt(n,1))
                        } else
                            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , i = this.matrixWorld
                          , s = e.params.Line.threshold
                          , a = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        eS.copy(n.boundingSphere),
                        eS.applyMatrix4(i),
                        eS.radius += s,
                        e.ray.intersectsSphere(eS) === !1)
                            return;
                        hw.copy(i).invert(),
                        Ug.copy(e.ray).applyMatrix4(hw);
                        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , c = o * o
                          , u = this.isLineSegments ? 2 : 1
                          , f = n.index
                          , m = n.attributes.position;
                        if (f !== null) {
                            const v = Math.max(0, a.start)
                              , y = Math.min(f.count, a.start + a.count);
                            for (let S = v, A = y - 1; S < A; S += u) {
                                const M = f.getX(S)
                                  , x = f.getX(S + 1)
                                  , T = tS(this, e, Ug, c, M, x, S);
                                T && t.push(T)
                            }
                            if (this.isLineLoop) {
                                const S = f.getX(y - 1)
                                  , A = f.getX(v)
                                  , M = tS(this, e, Ug, c, S, A, y - 1);
                                M && t.push(M)
                            }
                        } else {
                            const v = Math.max(0, a.start)
                              , y = Math.min(m.count, a.start + a.count);
                            for (let S = v, A = y - 1; S < A; S += u) {
                                const M = tS(this, e, Ug, c, S, S + 1, S);
                                M && t.push(M)
                            }
                            if (this.isLineLoop) {
                                const S = tS(this, e, Ug, c, y - 1, v, y - 1);
                                S && t.push(S)
                            }
                        }
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const a = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[a] = i
                                }
                            }
                        }
                    }
                }
                ;
                function tS(e, t, n, i, s, a, o) {
                    const c = e.geometry.attributes.position;
                    if (J_.fromBufferAttribute(c, s),
                    $_.fromBufferAttribute(c, a),
                    n.distanceSqToSegment(J_, $_, oT, fw) > i)
                        return;
                    oT.applyMatrix4(e.matrixWorld);
                    const u = t.ray.origin.distanceTo(oT);
                    if (!(u < t.near || u > t.far))
                        return {
                            distance: u,
                            point: fw.clone().applyMatrix4(e.matrixWorld),
                            index: o,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: e
                        }
                }
                const dw = new ae
                  , pw = new ae;
                var cc = class extends mh {
                    constructor(e, t) {
                        super(e, t),
                        this.isLineSegments = !0,
                        this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.index === null) {
                            const t = e.attributes.position
                              , n = [];
                            for (let i = 0, s = t.count; i < s; i += 2)
                                dw.fromBufferAttribute(t, i),
                                pw.fromBufferAttribute(t, i + 1),
                                n[i] = i === 0 ? 0 : n[i - 1],
                                n[i + 1] = n[i] + dw.distanceTo(pw);
                            e.setAttribute("lineDistance", new Rt(n,1))
                        } else
                            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                }
                  , mw = class extends mh {
                    constructor(e, t) {
                        super(e, t),
                        this.isLineLoop = !0,
                        this.type = "LineLoop"
                    }
                }
                  , lT = class extends qs {
                    constructor(e) {
                        super(),
                        this.isPointsMaterial = !0,
                        this.type = "PointsMaterial",
                        this.color = new ft(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.size = 1,
                        this.sizeAttenuation = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.size = e.size,
                        this.sizeAttenuation = e.sizeAttenuation,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const vw = new Xt
                  , cT = new Ep
                  , nS = new Ys
                  , iS = new ae;
                var gw = class extends $n {
                    constructor(e=new sn, t=new lT) {
                        super(),
                        this.isPoints = !0,
                        this.type = "Points",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , i = this.matrixWorld
                          , s = e.params.Points.threshold
                          , a = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        nS.copy(n.boundingSphere),
                        nS.applyMatrix4(i),
                        nS.radius += s,
                        e.ray.intersectsSphere(nS) === !1)
                            return;
                        vw.copy(i).invert(),
                        cT.copy(e.ray).applyMatrix4(vw);
                        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , c = o * o
                          , u = n.index
                          , f = n.attributes.position;
                        if (u !== null) {
                            const m = Math.max(0, a.start)
                              , v = Math.min(u.count, a.start + a.count);
                            for (let y = m, S = v; y < S; y++) {
                                const A = u.getX(y);
                                iS.fromBufferAttribute(f, A),
                                yw(iS, A, c, i, e, t, this)
                            }
                        } else {
                            const m = Math.max(0, a.start)
                              , v = Math.min(f.count, a.start + a.count);
                            for (let y = m, S = v; y < S; y++)
                                iS.fromBufferAttribute(f, y),
                                yw(iS, y, c, i, e, t, this)
                        }
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const a = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[a] = i
                                }
                            }
                        }
                    }
                }
                ;
                function yw(e, t, n, i, s, a, o) {
                    const c = cT.distanceSqToPoint(e);
                    if (c < n) {
                        const u = new ae;
                        cT.closestPointToPoint(e, u),
                        u.applyMatrix4(i);
                        const f = s.ray.origin.distanceTo(u);
                        if (f < s.near || f > s.far)
                            return;
                        a.push({
                            distance: f,
                            distanceToRay: Math.sqrt(c),
                            point: u,
                            index: t,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: o
                        })
                    }
                }
                var _w = class extends Fi {
                    constructor(e, t, n, i, s=mi, a=mi, o, c, u) {
                        super(e, t, n, i, s, a, o, c, u),
                        this.isVideoTexture = !0,
                        this.generateMipmaps = !1,
                        this._requestVideoFrameCallbackId = 0;
                        const f = this;
                        function m() {
                            f.needsUpdate = !0,
                            f._requestVideoFrameCallbackId = e.requestVideoFrameCallback(m)
                        }
                        "requestVideoFrameCallback"in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(m))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const e = this.image;
                        !("requestVideoFrameCallback"in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                    dispose() {
                        this._requestVideoFrameCallbackId !== 0 && this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),
                        super.dispose()
                    }
                }
                  , wL = class extends _w {
                    constructor(e, t, n, i, s, a, o, c) {
                        super({}, e, t, n, i, s, a, o, c),
                        this.isVideoFrameTexture = !0
                    }
                    update() {}
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    setFrame(e) {
                        this.image = e,
                        this.needsUpdate = !0
                    }
                }
                  , DL = class extends Fi {
                    constructor(e, t) {
                        super({
                            width: e,
                            height: t
                        }),
                        this.isFramebufferTexture = !0,
                        this.magFilter = ri,
                        this.minFilter = ri,
                        this.generateMipmaps = !1,
                        this.needsUpdate = !0
                    }
                }
                  , sS = class extends Fi {
                    constructor(e, t, n, i, s, a, o, c, u, f, m, v) {
                        super(null, a, o, c, u, f, i, s, m, v),
                        this.isCompressedTexture = !0,
                        this.image = {
                            width: t,
                            height: n
                        },
                        this.mipmaps = e,
                        this.flipY = !1,
                        this.generateMipmaps = !1
                    }
                }
                  , RL = class extends sS {
                    constructor(e, t, n, i, s, a) {
                        super(e, t, n, s, a),
                        this.isCompressedArrayTexture = !0,
                        this.image.depth = i,
                        this.wrapR = bo,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(e) {
                        this.layerUpdates.add(e)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , UL = class extends sS {
                    constructor(e, t, n) {
                        super(void 0, e[0].width, e[0].height, t, n, Qc),
                        this.isCompressedCubeTexture = !0,
                        this.isCubeTexture = !0,
                        this.image = e
                    }
                }
                  , Sw = class extends Fi {
                    constructor(e, t, n, i, s, a, o, c, u) {
                        super(e, t, n, i, s, a, o, c, u),
                        this.isCanvasTexture = !0,
                        this.needsUpdate = !0
                    }
                }
                  , Og = class extends Fi {
                    constructor(e, t, n=ac, i, s, a, o=ri, c=ri, u, f=vp, m=1) {
                        if (f !== vp && f !== pf)
                            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        super({
                            width: e,
                            height: t,
                            depth: m
                        }, i, s, a, o, c, f, n, u),
                        this.isDepthTexture = !0,
                        this.flipY = !1,
                        this.generateMipmaps = !1,
                        this.compareFunction = null
                    }
                    copy(e) {
                        return super.copy(e),
                        this.source = new rh(Object.assign({}, e.image)),
                        this.compareFunction = e.compareFunction,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
                        t
                    }
                }
                  , uT = class extends Fi {
                    constructor(e=null) {
                        super(),
                        this.sourceTexture = e,
                        this.isExternalTexture = !0
                    }
                    copy(e) {
                        return super.copy(e),
                        this.sourceTexture = e.sourceTexture,
                        this
                    }
                }
                  , xw = class yU extends sn {
                    constructor(t=1, n=1, i=4, s=8, a=1) {
                        super(),
                        this.type = "CapsuleGeometry",
                        this.parameters = {
                            radius: t,
                            height: n,
                            capSegments: i,
                            radialSegments: s,
                            heightSegments: a
                        },
                        n = Math.max(0, n),
                        i = Math.max(1, Math.floor(i)),
                        s = Math.max(3, Math.floor(s)),
                        a = Math.max(1, Math.floor(a));
                        const o = []
                          , c = []
                          , u = []
                          , f = []
                          , m = n / 2
                          , v = Math.PI / 2 * t
                          , y = n
                          , S = 2 * v + y
                          , A = i * 2 + a
                          , M = s + 1
                          , x = new ae
                          , T = new ae;
                        for (let D = 0; D <= A; D++) {
                            let w = 0
                              , U = 0
                              , O = 0
                              , L = 0;
                            if (D <= i) {
                                const I = D / i
                                  , B = I * Math.PI / 2;
                                U = -m - t * Math.cos(B),
                                O = t * Math.sin(B),
                                L = -t * Math.cos(B),
                                w = I * v
                            } else if (D <= i + a) {
                                const I = (D - i) / a;
                                U = -m + I * n,
                                O = t,
                                L = 0,
                                w = v + I * y
                            } else {
                                const I = (D - i - a) / i
                                  , B = I * Math.PI / 2;
                                U = m + t * Math.sin(B),
                                O = t * Math.cos(B),
                                L = t * Math.sin(B),
                                w = v + y + I * v
                            }
                            const N = Math.max(0, Math.min(1, w / S));
                            let z = 0;
                            D === 0 ? z = .5 / s : D === A && (z = -.5 / s);
                            for (let I = 0; I <= s; I++) {
                                const B = I / s
                                  , G = B * Math.PI * 2
                                  , X = Math.sin(G)
                                  , q = Math.cos(G);
                                T.x = -O * q,
                                T.y = U,
                                T.z = O * X,
                                c.push(T.x, T.y, T.z),
                                x.set(-O * q, L, O * X),
                                x.normalize(),
                                u.push(x.x, x.y, x.z),
                                f.push(B + z, N)
                            }
                            if (D > 0) {
                                const I = (D - 1) * M;
                                for (let B = 0; B < s; B++) {
                                    const G = I + B
                                      , X = I + B + 1
                                      , q = D * M + B
                                      , Q = D * M + B + 1;
                                    o.push(G, X, q),
                                    o.push(X, Q, q)
                                }
                            }
                        }
                        this.setIndex(o),
                        this.setAttribute("position", new Rt(c,3)),
                        this.setAttribute("normal", new Rt(u,3)),
                        this.setAttribute("uv", new Rt(f,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new yU(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)
                    }
                }
                  , Aw = class _U extends sn {
                    constructor(t=1, n=32, i=0, s=Math.PI * 2) {
                        super(),
                        this.type = "CircleGeometry",
                        this.parameters = {
                            radius: t,
                            segments: n,
                            thetaStart: i,
                            thetaLength: s
                        },
                        n = Math.max(3, n);
                        const a = []
                          , o = []
                          , c = []
                          , u = []
                          , f = new ae
                          , m = new Oe;
                        o.push(0, 0, 0),
                        c.push(0, 0, 1),
                        u.push(.5, .5);
                        for (let v = 0, y = 3; v <= n; v++,
                        y += 3) {
                            const S = i + v / n * s;
                            f.x = t * Math.cos(S),
                            f.y = t * Math.sin(S),
                            o.push(f.x, f.y, f.z),
                            c.push(0, 0, 1),
                            m.x = (o[y] / t + 1) / 2,
                            m.y = (o[y + 1] / t + 1) / 2,
                            u.push(m.x, m.y)
                        }
                        for (let v = 1; v <= n; v++)
                            a.push(v, v + 1, 0);
                        this.setIndex(a),
                        this.setAttribute("position", new Rt(o,3)),
                        this.setAttribute("normal", new Rt(c,3)),
                        this.setAttribute("uv", new Rt(u,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new _U(t.radius,t.segments,t.thetaStart,t.thetaLength)
                    }
                }
                  , hT = class SU extends sn {
                    constructor(t=1, n=1, i=1, s=32, a=1, o=!1, c=0, u=Math.PI * 2) {
                        super(),
                        this.type = "CylinderGeometry",
                        this.parameters = {
                            radiusTop: t,
                            radiusBottom: n,
                            height: i,
                            radialSegments: s,
                            heightSegments: a,
                            openEnded: o,
                            thetaStart: c,
                            thetaLength: u
                        };
                        const f = this;
                        s = Math.floor(s),
                        a = Math.floor(a);
                        const m = []
                          , v = []
                          , y = []
                          , S = [];
                        let A = 0;
                        const M = []
                          , x = i / 2;
                        let T = 0;
                        D(),
                        o === !1 && (t > 0 && w(!0),
                        n > 0 && w(!1)),
                        this.setIndex(m),
                        this.setAttribute("position", new Rt(v,3)),
                        this.setAttribute("normal", new Rt(y,3)),
                        this.setAttribute("uv", new Rt(S,2));
                        function D() {
                            const U = new ae
                              , O = new ae;
                            let L = 0;
                            const N = (n - t) / i;
                            for (let z = 0; z <= a; z++) {
                                const I = []
                                  , B = z / a
                                  , G = B * (n - t) + t;
                                for (let X = 0; X <= s; X++) {
                                    const q = X / s
                                      , Q = q * u + c
                                      , oe = Math.sin(Q)
                                      , k = Math.cos(Q);
                                    O.x = G * oe,
                                    O.y = -B * i + x,
                                    O.z = G * k,
                                    v.push(O.x, O.y, O.z),
                                    U.set(oe, N, k).normalize(),
                                    y.push(U.x, U.y, U.z),
                                    S.push(q, 1 - B),
                                    I.push(A++)
                                }
                                M.push(I)
                            }
                            for (let z = 0; z < s; z++)
                                for (let I = 0; I < a; I++) {
                                    const B = M[I][z]
                                      , G = M[I + 1][z]
                                      , X = M[I + 1][z + 1]
                                      , q = M[I][z + 1];
                                    (t > 0 || I !== 0) && (m.push(B, G, q),
                                    L += 3),
                                    (n > 0 || I !== a - 1) && (m.push(G, X, q),
                                    L += 3)
                                }
                            f.addGroup(T, L, 0),
                            T += L
                        }
                        function w(U) {
                            const O = A
                              , L = new Oe
                              , N = new ae;
                            let z = 0;
                            const I = U === !0 ? t : n
                              , B = U === !0 ? 1 : -1;
                            for (let X = 1; X <= s; X++)
                                v.push(0, x * B, 0),
                                y.push(0, B, 0),
                                S.push(.5, .5),
                                A++;
                            const G = A;
                            for (let X = 0; X <= s; X++) {
                                const q = X / s * u + c
                                  , Q = Math.cos(q)
                                  , oe = Math.sin(q);
                                N.x = I * oe,
                                N.y = x * B,
                                N.z = I * Q,
                                v.push(N.x, N.y, N.z),
                                y.push(0, B, 0),
                                L.x = Q * .5 + .5,
                                L.y = oe * .5 * B + .5,
                                S.push(L.x, L.y),
                                A++
                            }
                            for (let X = 0; X < s; X++) {
                                const q = O + X
                                  , Q = G + X;
                                U === !0 ? m.push(Q, Q + 1, q) : m.push(Q + 1, Q, q),
                                z += 3
                            }
                            f.addGroup(T, z, U === !0 ? 1 : 2),
                            T += z
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new SU(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)
                    }
                }
                  , fT = class xU extends hT {
                    constructor(t=1, n=1, i=32, s=1, a=!1, o=0, c=Math.PI * 2) {
                        super(0, t, n, i, s, a, o, c),
                        this.type = "ConeGeometry",
                        this.parameters = {
                            radius: t,
                            height: n,
                            radialSegments: i,
                            heightSegments: s,
                            openEnded: a,
                            thetaStart: o,
                            thetaLength: c
                        }
                    }
                    static fromJSON(t) {
                        return new xU(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)
                    }
                }
                  , Xp = class AU extends sn {
                    constructor(t=[], n=[], i=1, s=0) {
                        super(),
                        this.type = "PolyhedronGeometry",
                        this.parameters = {
                            vertices: t,
                            indices: n,
                            radius: i,
                            detail: s
                        };
                        const a = []
                          , o = [];
                        c(s),
                        f(i),
                        m(),
                        this.setAttribute("position", new Rt(a,3)),
                        this.setAttribute("normal", new Rt(a.slice(),3)),
                        this.setAttribute("uv", new Rt(o,2)),
                        s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
                        function c(D) {
                            const w = new ae
                              , U = new ae
                              , O = new ae;
                            for (let L = 0; L < n.length; L += 3)
                                S(n[L + 0], w),
                                S(n[L + 1], U),
                                S(n[L + 2], O),
                                u(w, U, O, D)
                        }
                        function u(D, w, U, O) {
                            const L = O + 1
                              , N = [];
                            for (let z = 0; z <= L; z++) {
                                N[z] = [];
                                const I = D.clone().lerp(U, z / L)
                                  , B = w.clone().lerp(U, z / L)
                                  , G = L - z;
                                for (let X = 0; X <= G; X++)
                                    X === 0 && z === L ? N[z][X] = I : N[z][X] = I.clone().lerp(B, X / G)
                            }
                            for (let z = 0; z < L; z++)
                                for (let I = 0; I < 2 * (L - z) - 1; I++) {
                                    const B = Math.floor(I / 2);
                                    I % 2 === 0 ? (y(N[z][B + 1]),
                                    y(N[z + 1][B]),
                                    y(N[z][B])) : (y(N[z][B + 1]),
                                    y(N[z + 1][B + 1]),
                                    y(N[z + 1][B]))
                                }
                        }
                        function f(D) {
                            const w = new ae;
                            for (let U = 0; U < a.length; U += 3)
                                w.x = a[U + 0],
                                w.y = a[U + 1],
                                w.z = a[U + 2],
                                w.normalize().multiplyScalar(D),
                                a[U + 0] = w.x,
                                a[U + 1] = w.y,
                                a[U + 2] = w.z
                        }
                        function m() {
                            const D = new ae;
                            for (let w = 0; w < a.length; w += 3) {
                                D.x = a[w + 0],
                                D.y = a[w + 1],
                                D.z = a[w + 2];
                                const U = x(D) / 2 / Math.PI + .5
                                  , O = T(D) / Math.PI + .5;
                                o.push(U, 1 - O)
                            }
                            A(),
                            v()
                        }
                        function v() {
                            for (let D = 0; D < o.length; D += 6) {
                                const w = o[D + 0]
                                  , U = o[D + 2]
                                  , O = o[D + 4];
                                Math.max(w, U, O) > .9 && Math.min(w, U, O) < .1 && (w < .2 && (o[D + 0] += 1),
                                U < .2 && (o[D + 2] += 1),
                                O < .2 && (o[D + 4] += 1))
                            }
                        }
                        function y(D) {
                            a.push(D.x, D.y, D.z)
                        }
                        function S(D, w) {
                            const U = D * 3;
                            w.x = t[U + 0],
                            w.y = t[U + 1],
                            w.z = t[U + 2]
                        }
                        function A() {
                            const D = new ae
                              , w = new ae
                              , U = new ae
                              , O = new ae
                              , L = new Oe
                              , N = new Oe
                              , z = new Oe;
                            for (let I = 0, B = 0; I < a.length; I += 9,
                            B += 6) {
                                D.set(a[I + 0], a[I + 1], a[I + 2]),
                                w.set(a[I + 3], a[I + 4], a[I + 5]),
                                U.set(a[I + 6], a[I + 7], a[I + 8]),
                                L.set(o[B + 0], o[B + 1]),
                                N.set(o[B + 2], o[B + 3]),
                                z.set(o[B + 4], o[B + 5]),
                                O.copy(D).add(w).add(U).divideScalar(3);
                                const G = x(O);
                                M(L, B + 0, D, G),
                                M(N, B + 2, w, G),
                                M(z, B + 4, U, G)
                            }
                        }
                        function M(D, w, U, O) {
                            O < 0 && D.x === 1 && (o[w] = D.x - 1),
                            U.x === 0 && U.z === 0 && (o[w] = O / 2 / Math.PI + .5)
                        }
                        function x(D) {
                            return Math.atan2(D.z, -D.x)
                        }
                        function T(D) {
                            return Math.atan2(-D.y, Math.sqrt(D.x * D.x + D.z * D.z))
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new AU(t.vertices,t.indices,t.radius,t.details)
                    }
                }
                  , Tw = class TU extends Xp {
                    constructor(t=1, n=0) {
                        const i = (1 + Math.sqrt(5)) / 2
                          , s = 1 / i
                          , a = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, 0, -i, 0, -s, i, 0, -s, -i, 0, s, i, 0, s];
                        super(a, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, n),
                        this.type = "DodecahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new TU(t.radius,t.detail)
                    }
                }
                ;
                const aS = new ae
                  , rS = new ae
                  , dT = new ae
                  , oS = new hh;
                var Mw = class extends sn {
                    constructor(e=null, t=1) {
                        if (super(),
                        this.type = "EdgesGeometry",
                        this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        },
                        e !== null) {
                            const n = Math.pow(10, 4)
                              , i = Math.cos(yf * t)
                              , s = e.getIndex()
                              , a = e.getAttribute("position")
                              , o = s ? s.count : a.count
                              , c = [0, 0, 0]
                              , u = ["a", "b", "c"]
                              , f = new Array(3)
                              , m = {}
                              , v = [];
                            for (let y = 0; y < o; y += 3) {
                                s ? (c[0] = s.getX(y),
                                c[1] = s.getX(y + 1),
                                c[2] = s.getX(y + 2)) : (c[0] = y,
                                c[1] = y + 1,
                                c[2] = y + 2);
                                const {a: S, b: A, c: M} = oS;
                                if (S.fromBufferAttribute(a, c[0]),
                                A.fromBufferAttribute(a, c[1]),
                                M.fromBufferAttribute(a, c[2]),
                                oS.getNormal(dT),
                                f[0] = `${Math.round(S.x * n)},${Math.round(S.y * n)},${Math.round(S.z * n)}`,
                                f[1] = `${Math.round(A.x * n)},${Math.round(A.y * n)},${Math.round(A.z * n)}`,
                                f[2] = `${Math.round(M.x * n)},${Math.round(M.y * n)},${Math.round(M.z * n)}`,
                                !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
                                    for (let x = 0; x < 3; x++) {
                                        const T = (x + 1) % 3
                                          , D = f[x]
                                          , w = f[T]
                                          , U = oS[u[x]]
                                          , O = oS[u[T]]
                                          , L = `${D}_${w}`
                                          , N = `${w}_${D}`;
                                        N in m && m[N] ? (dT.dot(m[N].normal) <= i && (v.push(U.x, U.y, U.z),
                                        v.push(O.x, O.y, O.z)),
                                        m[N] = null) : L in m || (m[L] = {
                                            index0: c[x],
                                            index1: c[T],
                                            normal: dT.clone()
                                        })
                                    }
                            }
                            for (const y in m)
                                if (m[y]) {
                                    const {index0: S, index1: A} = m[y];
                                    aS.fromBufferAttribute(a, S),
                                    rS.fromBufferAttribute(a, A),
                                    v.push(aS.x, aS.y, aS.z),
                                    v.push(rS.x, rS.y, rS.z)
                                }
                            this.setAttribute("position", new Rt(v,3))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                }
                  , hl = class {
                    constructor() {
                        this.type = "Curve",
                        this.arcLengthDivisions = 200,
                        this.needsUpdate = !1,
                        this.cacheArcLengths = null
                    }
                    getPoint() {
                        console.warn("THREE.Curve: .getPoint() not implemented.")
                    }
                    getPointAt(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getPoint(n, t)
                    }
                    getPoints(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return t
                    }
                    getSpacedPoints(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPointAt(n / e));
                        return t
                    }
                    getLength() {
                        const e = this.getLengths();
                        return e[e.length - 1]
                    }
                    getLengths(e=this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const t = [];
                        let n, i = this.getPoint(0), s = 0;
                        t.push(0);
                        for (let a = 1; a <= e; a++)
                            n = this.getPoint(a / e),
                            s += n.distanceTo(i),
                            t.push(s),
                            i = n;
                        return this.cacheArcLengths = t,
                        t
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.getLengths()
                    }
                    getUtoTmapping(e, t=null) {
                        const n = this.getLengths();
                        let i = 0;
                        const s = n.length;
                        let a;
                        t ? a = t : a = e * n[s - 1];
                        let o = 0, c = s - 1, u;
                        for (; o <= c; )
                            if (i = Math.floor(o + (c - o) / 2),
                            u = n[i] - a,
                            u < 0)
                                o = i + 1;
                            else if (u > 0)
                                c = i - 1;
                            else {
                                c = i;
                                break
                            }
                        if (i = c,
                        n[i] === a)
                            return i / (s - 1);
                        const f = n[i]
                          , m = n[i + 1] - f
                          , v = (a - f) / m;
                        return (i + v) / (s - 1)
                    }
                    getTangent(e, t) {
                        let i = e - 1e-4
                          , s = e + 1e-4;
                        i < 0 && (i = 0),
                        s > 1 && (s = 1);
                        const a = this.getPoint(i)
                          , o = this.getPoint(s)
                          , c = t || (a.isVector2 ? new Oe : new ae);
                        return c.copy(o).sub(a).normalize(),
                        c
                    }
                    getTangentAt(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getTangent(n, t)
                    }
                    computeFrenetFrames(e, t=!1) {
                        const n = new ae
                          , i = []
                          , s = []
                          , a = []
                          , o = new ae
                          , c = new Xt;
                        for (let y = 0; y <= e; y++) {
                            const S = y / e;
                            i[y] = this.getTangentAt(S, new ae)
                        }
                        s[0] = new ae,
                        a[0] = new ae;
                        let u = Number.MAX_VALUE;
                        const f = Math.abs(i[0].x)
                          , m = Math.abs(i[0].y)
                          , v = Math.abs(i[0].z);
                        f <= u && (u = f,
                        n.set(1, 0, 0)),
                        m <= u && (u = m,
                        n.set(0, 1, 0)),
                        v <= u && n.set(0, 0, 1),
                        o.crossVectors(i[0], n).normalize(),
                        s[0].crossVectors(i[0], o),
                        a[0].crossVectors(i[0], s[0]);
                        for (let y = 1; y <= e; y++) {
                            if (s[y] = s[y - 1].clone(),
                            a[y] = a[y - 1].clone(),
                            o.crossVectors(i[y - 1], i[y]),
                            o.length() > Number.EPSILON) {
                                o.normalize();
                                const S = Math.acos(Yt(i[y - 1].dot(i[y]), -1, 1));
                                s[y].applyMatrix4(c.makeRotationAxis(o, S))
                            }
                            a[y].crossVectors(i[y], s[y])
                        }
                        if (t === !0) {
                            let y = Math.acos(Yt(s[0].dot(s[e]), -1, 1));
                            y /= e,
                            i[0].dot(o.crossVectors(s[0], s[e])) > 0 && (y = -y);
                            for (let S = 1; S <= e; S++)
                                s[S].applyMatrix4(c.makeRotationAxis(i[S], y * S)),
                                a[S].crossVectors(i[S], s[S])
                        }
                        return {
                            tangents: i,
                            normals: s,
                            binormals: a
                        }
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.7,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return e.arcLengthDivisions = this.arcLengthDivisions,
                        e.type = this.type,
                        e
                    }
                    fromJSON(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                }
                  , lS = class extends hl {
                    constructor(e=0, t=0, n=1, i=1, s=0, a=Math.PI * 2, o=!1, c=0) {
                        super(),
                        this.isEllipseCurve = !0,
                        this.type = "EllipseCurve",
                        this.aX = e,
                        this.aY = t,
                        this.xRadius = n,
                        this.yRadius = i,
                        this.aStartAngle = s,
                        this.aEndAngle = a,
                        this.aClockwise = o,
                        this.aRotation = c
                    }
                    getPoint(e, t=new Oe) {
                        const n = t
                          , i = Math.PI * 2;
                        let s = this.aEndAngle - this.aStartAngle;
                        const a = Math.abs(s) < Number.EPSILON;
                        for (; s < 0; )
                            s += i;
                        for (; s > i; )
                            s -= i;
                        s < Number.EPSILON && (a ? s = 0 : s = i),
                        this.aClockwise === !0 && !a && (s === i ? s = -i : s = s - i);
                        const o = this.aStartAngle + e * s;
                        let c = this.aX + this.xRadius * Math.cos(o)
                          , u = this.aY + this.yRadius * Math.sin(o);
                        if (this.aRotation !== 0) {
                            const f = Math.cos(this.aRotation)
                              , m = Math.sin(this.aRotation)
                              , v = c - this.aX
                              , y = u - this.aY;
                            c = v * f - y * m + this.aX,
                            u = v * m + y * f + this.aY
                        }
                        return n.set(c, u)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.aX = e.aX,
                        this.aY = e.aY,
                        this.xRadius = e.xRadius,
                        this.yRadius = e.yRadius,
                        this.aStartAngle = e.aStartAngle,
                        this.aEndAngle = e.aEndAngle,
                        this.aClockwise = e.aClockwise,
                        this.aRotation = e.aRotation,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.aX = this.aX,
                        e.aY = this.aY,
                        e.xRadius = this.xRadius,
                        e.yRadius = this.yRadius,
                        e.aStartAngle = this.aStartAngle,
                        e.aEndAngle = this.aEndAngle,
                        e.aClockwise = this.aClockwise,
                        e.aRotation = this.aRotation,
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.aX = e.aX,
                        this.aY = e.aY,
                        this.xRadius = e.xRadius,
                        this.yRadius = e.yRadius,
                        this.aStartAngle = e.aStartAngle,
                        this.aEndAngle = e.aEndAngle,
                        this.aClockwise = e.aClockwise,
                        this.aRotation = e.aRotation,
                        this
                    }
                }
                  , bw = class extends lS {
                    constructor(e, t, n, i, s, a) {
                        super(e, t, n, n, i, s, a),
                        this.isArcCurve = !0,
                        this.type = "ArcCurve"
                    }
                }
                ;
                function pT() {
                    let e = 0
                      , t = 0
                      , n = 0
                      , i = 0;
                    function s(a, o, c, u) {
                        e = a,
                        t = c,
                        n = -3 * a + 3 * o - 2 * c - u,
                        i = 2 * a - 2 * o + c + u
                    }
                    return {
                        initCatmullRom: function(a, o, c, u, f) {
                            s(o, c, f * (c - a), f * (u - o))
                        },
                        initNonuniformCatmullRom: function(a, o, c, u, f, m, v) {
                            let y = (o - a) / f - (c - a) / (f + m) + (c - o) / m
                              , S = (c - o) / m - (u - o) / (m + v) + (u - c) / v;
                            y *= m,
                            S *= m,
                            s(o, c, y, S)
                        },
                        calc: function(a) {
                            const o = a * a
                              , c = o * a;
                            return e + t * a + n * o + i * c
                        }
                    }
                }
                const cS = new ae
                  , mT = new pT
                  , vT = new pT
                  , gT = new pT;
                var Ew = class extends hl {
                    constructor(e=[], t=!1, n="centripetal", i=.5) {
                        super(),
                        this.isCatmullRomCurve3 = !0,
                        this.type = "CatmullRomCurve3",
                        this.points = e,
                        this.closed = t,
                        this.curveType = n,
                        this.tension = i
                    }
                    getPoint(e, t=new ae) {
                        const n = t
                          , i = this.points
                          , s = i.length
                          , a = (s - (this.closed ? 0 : 1)) * e;
                        let o = Math.floor(a)
                          , c = a - o;
                        this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : c === 0 && o === s - 1 && (o = s - 2,
                        c = 1);
                        let u, f;
                        this.closed || o > 0 ? u = i[(o - 1) % s] : (cS.subVectors(i[0], i[1]).add(i[0]),
                        u = cS);
                        const m = i[o % s]
                          , v = i[(o + 1) % s];
                        if (this.closed || o + 2 < s ? f = i[(o + 2) % s] : (cS.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]),
                        f = cS),
                        this.curveType === "centripetal" || this.curveType === "chordal") {
                            const y = this.curveType === "chordal" ? .5 : .25;
                            let S = Math.pow(u.distanceToSquared(m), y)
                              , A = Math.pow(m.distanceToSquared(v), y)
                              , M = Math.pow(v.distanceToSquared(f), y);
                            A < 1e-4 && (A = 1),
                            S < 1e-4 && (S = A),
                            M < 1e-4 && (M = A),
                            mT.initNonuniformCatmullRom(u.x, m.x, v.x, f.x, S, A, M),
                            vT.initNonuniformCatmullRom(u.y, m.y, v.y, f.y, S, A, M),
                            gT.initNonuniformCatmullRom(u.z, m.z, v.z, f.z, S, A, M)
                        } else
                            this.curveType === "catmullrom" && (mT.initCatmullRom(u.x, m.x, v.x, f.x, this.tension),
                            vT.initCatmullRom(u.y, m.y, v.y, f.y, this.tension),
                            gT.initCatmullRom(u.z, m.z, v.z, f.z, this.tension));
                        return n.set(mT.calc(c), vT.calc(c), gT.calc(c)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(i.clone())
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const i = this.points[t];
                            e.points.push(i.toArray())
                        }
                        return e.closed = this.closed,
                        e.curveType = this.curveType,
                        e.tension = this.tension,
                        e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(new ae().fromArray(i))
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                }
                ;
                function Cw(e, t, n, i, s) {
                    const a = (i - t) * .5
                      , o = (s - n) * .5
                      , c = e * e
                      , u = e * c;
                    return (2 * n - 2 * i + a + o) * u + (-3 * n + 3 * i - 2 * a - o) * c + a * e + n
                }
                function OL(e, t) {
                    const n = 1 - e;
                    return n * n * t
                }
                function NL(e, t) {
                    return 2 * (1 - e) * e * t
                }
                function BL(e, t) {
                    return e * e * t
                }
                function Ng(e, t, n, i) {
                    return OL(e, t) + NL(e, n) + BL(e, i)
                }
                function LL(e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }
                function IL(e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }
                function PL(e, t) {
                    return 3 * (1 - e) * e * e * t
                }
                function zL(e, t) {
                    return e * e * e * t
                }
                function Bg(e, t, n, i, s) {
                    return LL(e, t) + IL(e, n) + PL(e, i) + zL(e, s)
                }
                var yT = class extends hl {
                    constructor(e=new Oe, t=new Oe, n=new Oe, i=new Oe) {
                        super(),
                        this.isCubicBezierCurve = !0,
                        this.type = "CubicBezierCurve",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(e, t=new Oe) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , a = this.v2
                          , o = this.v3;
                        return n.set(Bg(e, i.x, s.x, a.x, o.x), Bg(e, i.y, s.y, a.y, o.y)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                  , ww = class extends hl {
                    constructor(e=new ae, t=new ae, n=new ae, i=new ae) {
                        super(),
                        this.isCubicBezierCurve3 = !0,
                        this.type = "CubicBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(e, t=new ae) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , a = this.v2
                          , o = this.v3;
                        return n.set(Bg(e, i.x, s.x, a.x, o.x), Bg(e, i.y, s.y, a.y, o.y), Bg(e, i.z, s.z, a.z, o.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                  , _T = class extends hl {
                    constructor(e=new Oe, t=new Oe) {
                        super(),
                        this.isLineCurve = !0,
                        this.type = "LineCurve",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new Oe) {
                        const n = t;
                        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new Oe) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , Dw = class extends hl {
                    constructor(e=new ae, t=new ae) {
                        super(),
                        this.isLineCurve3 = !0,
                        this.type = "LineCurve3",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new ae) {
                        const n = t;
                        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new ae) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , ST = class extends hl {
                    constructor(e=new Oe, t=new Oe, n=new Oe) {
                        super(),
                        this.isQuadraticBezierCurve = !0,
                        this.type = "QuadraticBezierCurve",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n
                    }
                    getPoint(e, t=new Oe) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , a = this.v2;
                        return n.set(Ng(e, i.x, s.x, a.x), Ng(e, i.y, s.y, a.y)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , xT = class extends hl {
                    constructor(e=new ae, t=new ae, n=new ae) {
                        super(),
                        this.isQuadraticBezierCurve3 = !0,
                        this.type = "QuadraticBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n
                    }
                    getPoint(e, t=new ae) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , a = this.v2;
                        return n.set(Ng(e, i.x, s.x, a.x), Ng(e, i.y, s.y, a.y), Ng(e, i.z, s.z, a.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , AT = class extends hl {
                    constructor(e=[]) {
                        super(),
                        this.isSplineCurve = !0,
                        this.type = "SplineCurve",
                        this.points = e
                    }
                    getPoint(e, t=new Oe) {
                        const n = t
                          , i = this.points
                          , s = (i.length - 1) * e
                          , a = Math.floor(s)
                          , o = s - a
                          , c = i[a === 0 ? a : a - 1]
                          , u = i[a]
                          , f = i[a > i.length - 2 ? i.length - 1 : a + 1]
                          , m = i[a > i.length - 3 ? i.length - 1 : a + 2];
                        return n.set(Cw(o, c.x, u.x, f.x, m.x), Cw(o, c.y, u.y, f.y, m.y)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(i.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const i = this.points[t];
                            e.points.push(i.toArray())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(new Oe().fromArray(i))
                        }
                        return this
                    }
                }
                  , uS = Object.freeze({
                    __proto__: null,
                    ArcCurve: bw,
                    CatmullRomCurve3: Ew,
                    CubicBezierCurve: yT,
                    CubicBezierCurve3: ww,
                    EllipseCurve: lS,
                    LineCurve: _T,
                    LineCurve3: Dw,
                    QuadraticBezierCurve: ST,
                    QuadraticBezierCurve3: xT,
                    SplineCurve: AT
                })
                  , Rw = class extends hl {
                    constructor() {
                        super(),
                        this.type = "CurvePath",
                        this.curves = [],
                        this.autoClose = !1
                    }
                    add(e) {
                        this.curves.push(e)
                    }
                    closePath() {
                        const e = this.curves[0].getPoint(0)
                          , t = this.curves[this.curves.length - 1].getPoint(1);
                        if (!e.equals(t)) {
                            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                            this.curves.push(new uS[n](t,e))
                        }
                        return this
                    }
                    getPoint(e, t) {
                        const n = e * this.getLength()
                          , i = this.getCurveLengths();
                        let s = 0;
                        for (; s < i.length; ) {
                            if (i[s] >= n) {
                                const a = i[s] - n
                                  , o = this.curves[s]
                                  , c = o.getLength()
                                  , u = c === 0 ? 0 : 1 - a / c;
                                return o.getPointAt(u, t)
                            }
                            s++
                        }
                        return null
                    }
                    getLength() {
                        const e = this.getCurveLengths();
                        return e[e.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.cacheLengths = null,
                        this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                            return this.cacheLengths;
                        const e = [];
                        let t = 0;
                        for (let n = 0, i = this.curves.length; n < i; n++)
                            t += this.curves[n].getLength(),
                            e.push(t);
                        return this.cacheLengths = e,
                        e
                    }
                    getSpacedPoints(e=40) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return this.autoClose && t.push(t[0]),
                        t
                    }
                    getPoints(e=12) {
                        const t = [];
                        let n;
                        for (let i = 0, s = this.curves; i < s.length; i++) {
                            const a = s[i]
                              , o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e
                              , c = a.getPoints(o);
                            for (let u = 0; u < c.length; u++) {
                                const f = c[u];
                                n && n.equals(f) || (t.push(f),
                                n = f)
                            }
                        }
                        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                        t
                    }
                    copy(e) {
                        super.copy(e),
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const i = e.curves[t];
                            this.curves.push(i.clone())
                        }
                        return this.autoClose = e.autoClose,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.autoClose = this.autoClose,
                        e.curves = [];
                        for (let t = 0, n = this.curves.length; t < n; t++) {
                            const i = this.curves[t];
                            e.curves.push(i.toJSON())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.autoClose = e.autoClose,
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const i = e.curves[t];
                            this.curves.push(new uS[i.type]().fromJSON(i))
                        }
                        return this
                    }
                }
                  , hS = class extends Rw {
                    constructor(e) {
                        super(),
                        this.type = "Path",
                        this.currentPoint = new Oe,
                        e && this.setFromPoints(e)
                    }
                    setFromPoints(e) {
                        this.moveTo(e[0].x, e[0].y);
                        for (let t = 1, n = e.length; t < n; t++)
                            this.lineTo(e[t].x, e[t].y);
                        return this
                    }
                    moveTo(e, t) {
                        return this.currentPoint.set(e, t),
                        this
                    }
                    lineTo(e, t) {
                        const n = new _T(this.currentPoint.clone(),new Oe(e,t));
                        return this.curves.push(n),
                        this.currentPoint.set(e, t),
                        this
                    }
                    quadraticCurveTo(e, t, n, i) {
                        const s = new ST(this.currentPoint.clone(),new Oe(e,t),new Oe(n,i));
                        return this.curves.push(s),
                        this.currentPoint.set(n, i),
                        this
                    }
                    bezierCurveTo(e, t, n, i, s, a) {
                        const o = new yT(this.currentPoint.clone(),new Oe(e,t),new Oe(n,i),new Oe(s,a));
                        return this.curves.push(o),
                        this.currentPoint.set(s, a),
                        this
                    }
                    splineThru(e) {
                        const t = [this.currentPoint.clone()].concat(e)
                          , n = new AT(t);
                        return this.curves.push(n),
                        this.currentPoint.copy(e[e.length - 1]),
                        this
                    }
                    arc(e, t, n, i, s, a) {
                        const o = this.currentPoint.x
                          , c = this.currentPoint.y;
                        return this.absarc(e + o, t + c, n, i, s, a),
                        this
                    }
                    absarc(e, t, n, i, s, a) {
                        return this.absellipse(e, t, n, n, i, s, a),
                        this
                    }
                    ellipse(e, t, n, i, s, a, o, c) {
                        const u = this.currentPoint.x
                          , f = this.currentPoint.y;
                        return this.absellipse(e + u, t + f, n, i, s, a, o, c),
                        this
                    }
                    absellipse(e, t, n, i, s, a, o, c) {
                        const u = new lS(e,t,n,i,s,a,o,c);
                        if (this.curves.length > 0) {
                            const m = u.getPoint(0);
                            m.equals(this.currentPoint) || this.lineTo(m.x, m.y)
                        }
                        this.curves.push(u);
                        const f = u.getPoint(1);
                        return this.currentPoint.copy(f),
                        this
                    }
                    copy(e) {
                        return super.copy(e),
                        this.currentPoint.copy(e.currentPoint),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.currentPoint = this.currentPoint.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.currentPoint.fromArray(e.currentPoint),
                        this
                    }
                }
                  , Ef = class extends hS {
                    constructor(e) {
                        super(e),
                        this.uuid = jr(),
                        this.type = "Shape",
                        this.holes = []
                    }
                    getPointsHoles(e) {
                        const t = [];
                        for (let n = 0, i = this.holes.length; n < i; n++)
                            t[n] = this.holes[n].getPoints(e);
                        return t
                    }
                    extractPoints(e) {
                        return {
                            shape: this.getPoints(e),
                            holes: this.getPointsHoles(e)
                        }
                    }
                    copy(e) {
                        super.copy(e),
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const i = e.holes[t];
                            this.holes.push(i.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.uuid = this.uuid,
                        e.holes = [];
                        for (let t = 0, n = this.holes.length; t < n; t++) {
                            const i = this.holes[t];
                            e.holes.push(i.toJSON())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.uuid = e.uuid,
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const i = e.holes[t];
                            this.holes.push(new hS().fromJSON(i))
                        }
                        return this
                    }
                }
                ;
                function FL(e, t, n=2) {
                    const i = t && t.length
                      , s = i ? t[0] * n : e.length;
                    let a = Uw(e, 0, s, n, !0);
                    const o = [];
                    if (!a || a.next === a.prev)
                        return o;
                    let c, u, f;
                    if (i && (a = XL(e, t, a, n)),
                    e.length > 80 * n) {
                        c = 1 / 0,
                        u = 1 / 0;
                        let m = -1 / 0
                          , v = -1 / 0;
                        for (let y = n; y < s; y += n) {
                            const S = e[y]
                              , A = e[y + 1];
                            S < c && (c = S),
                            A < u && (u = A),
                            S > m && (m = S),
                            A > v && (v = A)
                        }
                        f = Math.max(m - c, v - u),
                        f = f !== 0 ? 32767 / f : 0
                    }
                    return Lg(a, o, n, c, u, f, 0),
                    o
                }
                function Uw(e, t, n, i, s) {
                    let a;
                    if (s === tI(e, t, n, i) > 0)
                        for (let o = t; o < n; o += i)
                            a = Lw(o / i | 0, e[o], e[o + 1], a);
                    else
                        for (let o = n - i; o >= t; o -= i)
                            a = Lw(o / i | 0, e[o], e[o + 1], a);
                    return a && Wp(a, a.next) && (zg(a),
                    a = a.next),
                    a
                }
                function Cf(e, t) {
                    if (!e)
                        return e;
                    t || (t = e);
                    let n = e, i;
                    do
                        if (i = !1,
                        !n.steiner && (Wp(n, n.next) || Gi(n.prev, n, n.next) === 0)) {
                            if (zg(n),
                            n = t = n.prev,
                            n === n.next)
                                break;
                            i = !0
                        } else
                            n = n.next;
                    while (i || n !== t);
                    return t
                }
                function Lg(e, t, n, i, s, a, o) {
                    if (!e)
                        return;
                    !o && a && QL(e, i, s, a);
                    let c = e;
                    for (; e.prev !== e.next; ) {
                        const u = e.prev
                          , f = e.next;
                        if (a ? GL(e, i, s, a) : HL(e)) {
                            t.push(u.i, e.i, f.i),
                            zg(e),
                            e = f.next,
                            c = f.next;
                            continue
                        }
                        if (e = f,
                        e === c) {
                            o ? o === 1 ? (e = VL(Cf(e), t),
                            Lg(e, t, n, i, s, a, 2)) : o === 2 && kL(e, t, n, i, s, a) : Lg(Cf(e), t, n, i, s, a, 1);
                            break
                        }
                    }
                }
                function HL(e) {
                    const t = e.prev
                      , n = e
                      , i = e.next;
                    if (Gi(t, n, i) >= 0)
                        return !1;
                    const s = t.x
                      , a = n.x
                      , o = i.x
                      , c = t.y
                      , u = n.y
                      , f = i.y
                      , m = Math.min(s, a, o)
                      , v = Math.min(c, u, f)
                      , y = Math.max(s, a, o)
                      , S = Math.max(c, u, f);
                    let A = i.next;
                    for (; A !== t; ) {
                        if (A.x >= m && A.x <= y && A.y >= v && A.y <= S && Ig(s, c, a, u, o, f, A.x, A.y) && Gi(A.prev, A, A.next) >= 0)
                            return !1;
                        A = A.next
                    }
                    return !0
                }
                function GL(e, t, n, i) {
                    const s = e.prev
                      , a = e
                      , o = e.next;
                    if (Gi(s, a, o) >= 0)
                        return !1;
                    const c = s.x
                      , u = a.x
                      , f = o.x
                      , m = s.y
                      , v = a.y
                      , y = o.y
                      , S = Math.min(c, u, f)
                      , A = Math.min(m, v, y)
                      , M = Math.max(c, u, f)
                      , x = Math.max(m, v, y)
                      , T = TT(S, A, t, n, i)
                      , D = TT(M, x, t, n, i);
                    let w = e.prevZ
                      , U = e.nextZ;
                    for (; w && w.z >= T && U && U.z <= D; ) {
                        if (w.x >= S && w.x <= M && w.y >= A && w.y <= x && w !== s && w !== o && Ig(c, m, u, v, f, y, w.x, w.y) && Gi(w.prev, w, w.next) >= 0 || (w = w.prevZ,
                        U.x >= S && U.x <= M && U.y >= A && U.y <= x && U !== s && U !== o && Ig(c, m, u, v, f, y, U.x, U.y) && Gi(U.prev, U, U.next) >= 0))
                            return !1;
                        U = U.nextZ
                    }
                    for (; w && w.z >= T; ) {
                        if (w.x >= S && w.x <= M && w.y >= A && w.y <= x && w !== s && w !== o && Ig(c, m, u, v, f, y, w.x, w.y) && Gi(w.prev, w, w.next) >= 0)
                            return !1;
                        w = w.prevZ
                    }
                    for (; U && U.z <= D; ) {
                        if (U.x >= S && U.x <= M && U.y >= A && U.y <= x && U !== s && U !== o && Ig(c, m, u, v, f, y, U.x, U.y) && Gi(U.prev, U, U.next) >= 0)
                            return !1;
                        U = U.nextZ
                    }
                    return !0
                }
                function VL(e, t) {
                    let n = e;
                    do {
                        const i = n.prev
                          , s = n.next.next;
                        !Wp(i, s) && Nw(i, n, n.next, s) && Pg(i, s) && Pg(s, i) && (t.push(i.i, n.i, s.i),
                        zg(n),
                        zg(n.next),
                        n = e = s),
                        n = n.next
                    } while (n !== e);
                    return Cf(n)
                }
                function kL(e, t, n, i, s, a) {
                    let o = e;
                    do {
                        let c = o.next.next;
                        for (; c !== o.prev; ) {
                            if (o.i !== c.i && JL(o, c)) {
                                let u = Bw(o, c);
                                o = Cf(o, o.next),
                                u = Cf(u, u.next),
                                Lg(o, t, n, i, s, a, 0),
                                Lg(u, t, n, i, s, a, 0);
                                return
                            }
                            c = c.next
                        }
                        o = o.next
                    } while (o !== e)
                }
                function XL(e, t, n, i) {
                    const s = [];
                    for (let a = 0, o = t.length; a < o; a++) {
                        const c = t[a] * i
                          , u = a < o - 1 ? t[a + 1] * i : e.length
                          , f = Uw(e, c, u, i, !1);
                        f === f.next && (f.steiner = !0),
                        s.push(KL(f))
                    }
                    s.sort(WL);
                    for (let a = 0; a < s.length; a++)
                        n = YL(s[a], n);
                    return n
                }
                function WL(e, t) {
                    let n = e.x - t.x;
                    if (n === 0 && (n = e.y - t.y,
                    n === 0)) {
                        const i = (e.next.y - e.y) / (e.next.x - e.x)
                          , s = (t.next.y - t.y) / (t.next.x - t.x);
                        n = i - s
                    }
                    return n
                }
                function YL(e, t) {
                    const n = qL(e, t);
                    if (!n)
                        return t;
                    const i = Bw(n, e);
                    return Cf(i, i.next),
                    Cf(n, n.next)
                }
                function qL(e, t) {
                    let n = t;
                    const i = e.x
                      , s = e.y;
                    let a = -1 / 0, o;
                    if (Wp(e, n))
                        return n;
                    do {
                        if (Wp(e, n.next))
                            return n.next;
                        if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                            const v = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (v <= i && v > a && (a = v,
                            o = n.x < n.next.x ? n : n.next,
                            v === i))
                                return o
                        }
                        n = n.next
                    } while (n !== t);
                    if (!o)
                        return null;
                    const c = o
                      , u = o.x
                      , f = o.y;
                    let m = 1 / 0;
                    n = o;
                    do {
                        if (i >= n.x && n.x >= u && i !== n.x && Ow(s < f ? i : a, s, u, f, s < f ? a : i, s, n.x, n.y)) {
                            const v = Math.abs(s - n.y) / (i - n.x);
                            Pg(n, e) && (v < m || v === m && (n.x > o.x || n.x === o.x && jL(o, n))) && (o = n,
                            m = v)
                        }
                        n = n.next
                    } while (n !== c);
                    return o
                }
                function jL(e, t) {
                    return Gi(e.prev, e, t.prev) < 0 && Gi(t.next, e, e.next) < 0
                }
                function QL(e, t, n, i) {
                    let s = e;
                    do
                        s.z === 0 && (s.z = TT(s.x, s.y, t, n, i)),
                        s.prevZ = s.prev,
                        s.nextZ = s.next,
                        s = s.next;
                    while (s !== e);
                    s.prevZ.nextZ = null,
                    s.prevZ = null,
                    ZL(s)
                }
                function ZL(e) {
                    let t, n = 1;
                    do {
                        let i = e, s;
                        e = null;
                        let a = null;
                        for (t = 0; i; ) {
                            t++;
                            let o = i
                              , c = 0;
                            for (let f = 0; f < n && (c++,
                            o = o.nextZ,
                            !!o); f++)
                                ;
                            let u = n;
                            for (; c > 0 || u > 0 && o; )
                                c !== 0 && (u === 0 || !o || i.z <= o.z) ? (s = i,
                                i = i.nextZ,
                                c--) : (s = o,
                                o = o.nextZ,
                                u--),
                                a ? a.nextZ = s : e = s,
                                s.prevZ = a,
                                a = s;
                            i = o
                        }
                        a.nextZ = null,
                        n *= 2
                    } while (t > 1);
                    return e
                }
                function TT(e, t, n, i, s) {
                    return e = (e - n) * s | 0,
                    t = (t - i) * s | 0,
                    e = (e | e << 8) & 16711935,
                    e = (e | e << 4) & 252645135,
                    e = (e | e << 2) & 858993459,
                    e = (e | e << 1) & 1431655765,
                    t = (t | t << 8) & 16711935,
                    t = (t | t << 4) & 252645135,
                    t = (t | t << 2) & 858993459,
                    t = (t | t << 1) & 1431655765,
                    e | t << 1
                }
                function KL(e) {
                    let t = e
                      , n = e;
                    do
                        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                        t = t.next;
                    while (t !== e);
                    return n
                }
                function Ow(e, t, n, i, s, a, o, c) {
                    return (s - o) * (t - c) >= (e - o) * (a - c) && (e - o) * (i - c) >= (n - o) * (t - c) && (n - o) * (a - c) >= (s - o) * (i - c)
                }
                function Ig(e, t, n, i, s, a, o, c) {
                    return !(e === o && t === c) && Ow(e, t, n, i, s, a, o, c)
                }
                function JL(e, t) {
                    return e.next.i !== t.i && e.prev.i !== t.i && !$L(e, t) && (Pg(e, t) && Pg(t, e) && eI(e, t) && (Gi(e.prev, e, t.prev) || Gi(e, t.prev, t)) || Wp(e, t) && Gi(e.prev, e, e.next) > 0 && Gi(t.prev, t, t.next) > 0)
                }
                function Gi(e, t, n) {
                    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
                }
                function Wp(e, t) {
                    return e.x === t.x && e.y === t.y
                }
                function Nw(e, t, n, i) {
                    const s = dS(Gi(e, t, n))
                      , a = dS(Gi(e, t, i))
                      , o = dS(Gi(n, i, e))
                      , c = dS(Gi(n, i, t));
                    return !!(s !== a && o !== c || s === 0 && fS(e, n, t) || a === 0 && fS(e, i, t) || o === 0 && fS(n, e, i) || c === 0 && fS(n, t, i))
                }
                function fS(e, t, n) {
                    return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
                }
                function dS(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0
                }
                function $L(e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Nw(n, n.next, e, t))
                            return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }
                function Pg(e, t) {
                    return Gi(e.prev, e, e.next) < 0 ? Gi(e, t, e.next) >= 0 && Gi(e, e.prev, t) >= 0 : Gi(e, t, e.prev) < 0 || Gi(e, e.next, t) < 0
                }
                function eI(e, t) {
                    let n = e
                      , i = !1;
                    const s = (e.x + t.x) / 2
                      , a = (e.y + t.y) / 2;
                    do
                        n.y > a != n.next.y > a && n.next.y !== n.y && s < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                        n = n.next;
                    while (n !== e);
                    return i
                }
                function Bw(e, t) {
                    const n = MT(e.i, e.x, e.y)
                      , i = MT(t.i, t.x, t.y)
                      , s = e.next
                      , a = t.prev;
                    return e.next = t,
                    t.prev = e,
                    n.next = s,
                    s.prev = n,
                    i.next = n,
                    n.prev = i,
                    a.next = i,
                    i.prev = a,
                    i
                }
                function Lw(e, t, n, i) {
                    const s = MT(e, t, n);
                    return i ? (s.next = i.next,
                    s.prev = i,
                    i.next.prev = s,
                    i.next = s) : (s.prev = s,
                    s.next = s),
                    s
                }
                function zg(e) {
                    e.next.prev = e.prev,
                    e.prev.next = e.next,
                    e.prevZ && (e.prevZ.nextZ = e.nextZ),
                    e.nextZ && (e.nextZ.prevZ = e.prevZ)
                }
                function MT(e, t, n) {
                    return {
                        i: e,
                        x: t,
                        y: n,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                function tI(e, t, n, i) {
                    let s = 0;
                    for (let a = t, o = n - i; a < n; a += i)
                        s += (e[o] - e[a]) * (e[a + 1] + e[o + 1]),
                        o = a;
                    return s
                }
                var nI = class {
                    static triangulate(e, t, n=2) {
                        return FL(e, t, n)
                    }
                }
                  , ru = class MU {
                    static area(t) {
                        const n = t.length;
                        let i = 0;
                        for (let s = n - 1, a = 0; a < n; s = a++)
                            i += t[s].x * t[a].y - t[a].x * t[s].y;
                        return i * .5
                    }
                    static isClockWise(t) {
                        return MU.area(t) < 0
                    }
                    static triangulateShape(t, n) {
                        const i = []
                          , s = []
                          , a = [];
                        Iw(t),
                        Pw(i, t);
                        let o = t.length;
                        n.forEach(Iw);
                        for (let u = 0; u < n.length; u++)
                            s.push(o),
                            o += n[u].length,
                            Pw(i, n[u]);
                        const c = nI.triangulate(i, s);
                        for (let u = 0; u < c.length; u += 3)
                            a.push(c.slice(u, u + 3));
                        return a
                    }
                }
                ;
                function Iw(e) {
                    const t = e.length;
                    t > 2 && e[t - 1].equals(e[0]) && e.pop()
                }
                function Pw(e, t) {
                    for (let n = 0; n < t.length; n++)
                        e.push(t[n].x),
                        e.push(t[n].y)
                }
                var zw = class bU extends sn {
                    constructor(t=new Ef([new Oe(.5,.5), new Oe(-.5,.5), new Oe(-.5,-.5), new Oe(.5,-.5)]), n={}) {
                        super(),
                        this.type = "ExtrudeGeometry",
                        this.parameters = {
                            shapes: t,
                            options: n
                        },
                        t = Array.isArray(t) ? t : [t];
                        const i = this
                          , s = []
                          , a = [];
                        for (let c = 0, u = t.length; c < u; c++) {
                            const f = t[c];
                            o(f)
                        }
                        this.setAttribute("position", new Rt(s,3)),
                        this.setAttribute("uv", new Rt(a,2)),
                        this.computeVertexNormals();
                        function o(c) {
                            const u = []
                              , f = n.curveSegments !== void 0 ? n.curveSegments : 12
                              , m = n.steps !== void 0 ? n.steps : 1
                              , v = n.depth !== void 0 ? n.depth : 1;
                            let y = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0
                              , S = n.bevelThickness !== void 0 ? n.bevelThickness : .2
                              , A = n.bevelSize !== void 0 ? n.bevelSize : S - .1
                              , M = n.bevelOffset !== void 0 ? n.bevelOffset : 0
                              , x = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
                            const T = n.extrudePath
                              , D = n.UVGenerator !== void 0 ? n.UVGenerator : iI;
                            let w, U = !1, O, L, N, z;
                            T && (w = T.getSpacedPoints(m),
                            U = !0,
                            y = !1,
                            O = T.computeFrenetFrames(m, !1),
                            L = new ae,
                            N = new ae,
                            z = new ae),
                            y || (x = 0,
                            S = 0,
                            A = 0,
                            M = 0);
                            const I = c.extractPoints(f);
                            let B = I.shape;
                            const G = I.holes;
                            if (!ru.isClockWise(B)) {
                                B = B.reverse();
                                for (let Le = 0, he = G.length; Le < he; Le++) {
                                    const ye = G[Le];
                                    ru.isClockWise(ye) && (G[Le] = ye.reverse())
                                }
                            }
                            function X(Le) {
                                const ye = 10000000000000001e-36;
                                let xe = Le[0];
                                for (let ge = 1; ge <= Le.length; ge++) {
                                    const Te = ge % Le.length
                                      , Ae = Le[Te]
                                      , we = Ae.x - xe.x
                                      , it = Ae.y - xe.y
                                      , je = we * we + it * it
                                      , $ = Math.max(Math.abs(Ae.x), Math.abs(Ae.y), Math.abs(xe.x), Math.abs(xe.y))
                                      , Y = ye * $ * $;
                                    if (je <= Y) {
                                        Le.splice(Te, 1),
                                        ge--;
                                        continue
                                    }
                                    xe = Ae
                                }
                            }
                            X(B),
                            G.forEach(X);
                            const q = G.length
                              , Q = B;
                            for (let Le = 0; Le < q; Le++) {
                                const he = G[Le];
                                B = B.concat(he)
                            }
                            function oe(Le, he, ye) {
                                return he || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                                Le.clone().addScaledVector(he, ye)
                            }
                            const k = B.length;
                            function W(Le, he, ye) {
                                let xe, ge, Te;
                                const Ae = Le.x - he.x
                                  , we = Le.y - he.y
                                  , it = ye.x - Le.x
                                  , je = ye.y - Le.y
                                  , $ = Ae * Ae + we * we
                                  , Y = Ae * je - we * it;
                                if (Math.abs(Y) > Number.EPSILON) {
                                    const pe = Math.sqrt($)
                                      , He = Math.sqrt(it * it + je * je)
                                      , Re = he.x - we / pe
                                      , De = he.y + Ae / pe
                                      , rt = ye.x - je / He
                                      , $e = ye.y + it / He
                                      , ct = ((rt - Re) * je - ($e - De) * it) / (Ae * je - we * it);
                                    xe = Re + Ae * ct - Le.x,
                                    ge = De + we * ct - Le.y;
                                    const gt = xe * xe + ge * ge;
                                    if (gt <= 2)
                                        return new Oe(xe,ge);
                                    Te = Math.sqrt(gt / 2)
                                } else {
                                    let pe = !1;
                                    Ae > Number.EPSILON ? it > Number.EPSILON && (pe = !0) : Ae < -Number.EPSILON ? it < -Number.EPSILON && (pe = !0) : Math.sign(we) === Math.sign(je) && (pe = !0),
                                    pe ? (xe = -we,
                                    ge = Ae,
                                    Te = Math.sqrt($)) : (xe = Ae,
                                    ge = we,
                                    Te = Math.sqrt($ / 2))
                                }
                                return new Oe(xe / Te,ge / Te)
                            }
                            const V = [];
                            for (let Le = 0, he = Q.length, ye = he - 1, xe = Le + 1; Le < he; Le++,
                            ye++,
                            xe++)
                                ye === he && (ye = 0),
                                xe === he && (xe = 0),
                                V[Le] = W(Q[Le], Q[ye], Q[xe]);
                            const Z = [];
                            let j, ee = V.concat();
                            for (let Le = 0, he = q; Le < he; Le++) {
                                const ye = G[Le];
                                j = [];
                                for (let xe = 0, ge = ye.length, Te = ge - 1, Ae = xe + 1; xe < ge; xe++,
                                Te++,
                                Ae++)
                                    Te === ge && (Te = 0),
                                    Ae === ge && (Ae = 0),
                                    j[xe] = W(ye[xe], ye[Te], ye[Ae]);
                                Z.push(j),
                                ee = ee.concat(j)
                            }
                            let H;
                            if (x === 0)
                                H = ru.triangulateShape(Q, G);
                            else {
                                const Le = []
                                  , he = [];
                                for (let ye = 0; ye < x; ye++) {
                                    const xe = ye / x
                                      , ge = S * Math.cos(xe * Math.PI / 2)
                                      , Te = A * Math.sin(xe * Math.PI / 2) + M;
                                    for (let Ae = 0, we = Q.length; Ae < we; Ae++) {
                                        const it = oe(Q[Ae], V[Ae], Te);
                                        de(it.x, it.y, -ge),
                                        xe === 0 && Le.push(it)
                                    }
                                    for (let Ae = 0, we = q; Ae < we; Ae++) {
                                        const it = G[Ae];
                                        j = Z[Ae];
                                        const je = [];
                                        for (let $ = 0, Y = it.length; $ < Y; $++) {
                                            const pe = oe(it[$], j[$], Te);
                                            de(pe.x, pe.y, -ge),
                                            xe === 0 && je.push(pe)
                                        }
                                        xe === 0 && he.push(je)
                                    }
                                }
                                H = ru.triangulateShape(Le, he)
                            }
                            const ie = H.length
                              , se = A + M;
                            for (let Le = 0; Le < k; Le++) {
                                const he = y ? oe(B[Le], ee[Le], se) : B[Le];
                                U ? (N.copy(O.normals[0]).multiplyScalar(he.x),
                                L.copy(O.binormals[0]).multiplyScalar(he.y),
                                z.copy(w[0]).add(N).add(L),
                                de(z.x, z.y, z.z)) : de(he.x, he.y, 0)
                            }
                            for (let Le = 1; Le <= m; Le++)
                                for (let he = 0; he < k; he++) {
                                    const ye = y ? oe(B[he], ee[he], se) : B[he];
                                    U ? (N.copy(O.normals[Le]).multiplyScalar(ye.x),
                                    L.copy(O.binormals[Le]).multiplyScalar(ye.y),
                                    z.copy(w[Le]).add(N).add(L),
                                    de(z.x, z.y, z.z)) : de(ye.x, ye.y, v / m * Le)
                                }
                            for (let Le = x - 1; Le >= 0; Le--) {
                                const he = Le / x
                                  , ye = S * Math.cos(he * Math.PI / 2)
                                  , xe = A * Math.sin(he * Math.PI / 2) + M;
                                for (let ge = 0, Te = Q.length; ge < Te; ge++) {
                                    const Ae = oe(Q[ge], V[ge], xe);
                                    de(Ae.x, Ae.y, v + ye)
                                }
                                for (let ge = 0, Te = G.length; ge < Te; ge++) {
                                    const Ae = G[ge];
                                    j = Z[ge];
                                    for (let we = 0, it = Ae.length; we < it; we++) {
                                        const je = oe(Ae[we], j[we], xe);
                                        U ? de(je.x, je.y + w[m - 1].y, w[m - 1].x + ye) : de(je.x, je.y, v + ye)
                                    }
                                }
                            }
                            K(),
                            le();
                            function K() {
                                const Le = s.length / 3;
                                if (y) {
                                    let he = 0
                                      , ye = k * he;
                                    for (let xe = 0; xe < ie; xe++) {
                                        const ge = H[xe];
                                        qe(ge[2] + ye, ge[1] + ye, ge[0] + ye)
                                    }
                                    he = m + x * 2,
                                    ye = k * he;
                                    for (let xe = 0; xe < ie; xe++) {
                                        const ge = H[xe];
                                        qe(ge[0] + ye, ge[1] + ye, ge[2] + ye)
                                    }
                                } else {
                                    for (let he = 0; he < ie; he++) {
                                        const ye = H[he];
                                        qe(ye[2], ye[1], ye[0])
                                    }
                                    for (let he = 0; he < ie; he++) {
                                        const ye = H[he];
                                        qe(ye[0] + k * m, ye[1] + k * m, ye[2] + k * m)
                                    }
                                }
                                i.addGroup(Le, s.length / 3 - Le, 0)
                            }
                            function le() {
                                const Le = s.length / 3;
                                let he = 0;
                                ue(Q, he),
                                he += Q.length;
                                for (let ye = 0, xe = G.length; ye < xe; ye++) {
                                    const ge = G[ye];
                                    ue(ge, he),
                                    he += ge.length
                                }
                                i.addGroup(Le, s.length / 3 - Le, 1)
                            }
                            function ue(Le, he) {
                                let ye = Le.length;
                                for (; --ye >= 0; ) {
                                    const xe = ye;
                                    let ge = ye - 1;
                                    ge < 0 && (ge = Le.length - 1);
                                    for (let Te = 0, Ae = m + x * 2; Te < Ae; Te++) {
                                        const we = k * Te
                                          , it = k * (Te + 1)
                                          , je = he + xe + we
                                          , $ = he + ge + we
                                          , Y = he + ge + it
                                          , pe = he + xe + it;
                                        ze(je, $, Y, pe)
                                    }
                                }
                            }
                            function de(Le, he, ye) {
                                u.push(Le),
                                u.push(he),
                                u.push(ye)
                            }
                            function qe(Le, he, ye) {
                                Ee(Le),
                                Ee(he),
                                Ee(ye);
                                const xe = s.length / 3
                                  , ge = D.generateTopUV(i, s, xe - 3, xe - 2, xe - 1);
                                re(ge[0]),
                                re(ge[1]),
                                re(ge[2])
                            }
                            function ze(Le, he, ye, xe) {
                                Ee(Le),
                                Ee(he),
                                Ee(xe),
                                Ee(he),
                                Ee(ye),
                                Ee(xe);
                                const ge = s.length / 3
                                  , Te = D.generateSideWallUV(i, s, ge - 6, ge - 3, ge - 2, ge - 1);
                                re(Te[0]),
                                re(Te[1]),
                                re(Te[3]),
                                re(Te[1]),
                                re(Te[2]),
                                re(Te[3])
                            }
                            function Ee(Le) {
                                s.push(u[Le * 3 + 0]),
                                s.push(u[Le * 3 + 1]),
                                s.push(u[Le * 3 + 2])
                            }
                            function re(Le) {
                                a.push(Le.x),
                                a.push(Le.y)
                            }
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON()
                          , n = this.parameters.shapes
                          , i = this.parameters.options;
                        return sI(n, i, t)
                    }
                    static fromJSON(t, n) {
                        const i = [];
                        for (let a = 0, o = t.shapes.length; a < o; a++) {
                            const c = n[t.shapes[a]];
                            i.push(c)
                        }
                        const s = t.options.extrudePath;
                        return s !== void 0 && (t.options.extrudePath = new uS[s.type]().fromJSON(s)),
                        new bU(i,t.options)
                    }
                }
                ;
                const iI = {
                    generateTopUV: function(e, t, n, i, s) {
                        const a = t[n * 3]
                          , o = t[n * 3 + 1]
                          , c = t[i * 3]
                          , u = t[i * 3 + 1]
                          , f = t[s * 3]
                          , m = t[s * 3 + 1];
                        return [new Oe(a,o), new Oe(c,u), new Oe(f,m)]
                    },
                    generateSideWallUV: function(e, t, n, i, s, a) {
                        const o = t[n * 3]
                          , c = t[n * 3 + 1]
                          , u = t[n * 3 + 2]
                          , f = t[i * 3]
                          , m = t[i * 3 + 1]
                          , v = t[i * 3 + 2]
                          , y = t[s * 3]
                          , S = t[s * 3 + 1]
                          , A = t[s * 3 + 2]
                          , M = t[a * 3]
                          , x = t[a * 3 + 1]
                          , T = t[a * 3 + 2];
                        return Math.abs(c - m) < Math.abs(o - f) ? [new Oe(o,1 - u), new Oe(f,1 - v), new Oe(y,1 - A), new Oe(M,1 - T)] : [new Oe(c,1 - u), new Oe(m,1 - v), new Oe(S,1 - A), new Oe(x,1 - T)]
                    }
                };
                function sI(e, t, n) {
                    if (n.shapes = [],
                    Array.isArray(e))
                        for (let i = 0, s = e.length; i < s; i++) {
                            const a = e[i];
                            n.shapes.push(a.uuid)
                        }
                    else
                        n.shapes.push(e.uuid);
                    return n.options = Object.assign({}, t),
                    t.extrudePath !== void 0 && (n.options.extrudePath = t.extrudePath.toJSON()),
                    n
                }
                var Fw = class EU extends Xp {
                    constructor(t=1, n=0) {
                        const i = (1 + Math.sqrt(5)) / 2
                          , s = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
                        super(s, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, n),
                        this.type = "IcosahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new EU(t.radius,t.detail)
                    }
                }
                  , Hw = class CU extends sn {
                    constructor(t=[new Oe(0,-.5), new Oe(.5,0), new Oe(0,.5)], n=12, i=0, s=Math.PI * 2) {
                        super(),
                        this.type = "LatheGeometry",
                        this.parameters = {
                            points: t,
                            segments: n,
                            phiStart: i,
                            phiLength: s
                        },
                        n = Math.floor(n),
                        s = Yt(s, 0, Math.PI * 2);
                        const a = []
                          , o = []
                          , c = []
                          , u = []
                          , f = []
                          , m = 1 / n
                          , v = new ae
                          , y = new Oe
                          , S = new ae
                          , A = new ae
                          , M = new ae;
                        let x = 0
                          , T = 0;
                        for (let D = 0; D <= t.length - 1; D++)
                            switch (D) {
                            case 0:
                                x = t[D + 1].x - t[D].x,
                                T = t[D + 1].y - t[D].y,
                                S.x = T * 1,
                                S.y = -x,
                                S.z = T * 0,
                                M.copy(S),
                                S.normalize(),
                                u.push(S.x, S.y, S.z);
                                break;
                            case t.length - 1:
                                u.push(M.x, M.y, M.z);
                                break;
                            default:
                                x = t[D + 1].x - t[D].x,
                                T = t[D + 1].y - t[D].y,
                                S.x = T * 1,
                                S.y = -x,
                                S.z = T * 0,
                                A.copy(S),
                                S.x += M.x,
                                S.y += M.y,
                                S.z += M.z,
                                S.normalize(),
                                u.push(S.x, S.y, S.z),
                                M.copy(A)
                            }
                        for (let D = 0; D <= n; D++) {
                            const w = i + D * m * s
                              , U = Math.sin(w)
                              , O = Math.cos(w);
                            for (let L = 0; L <= t.length - 1; L++) {
                                v.x = t[L].x * U,
                                v.y = t[L].y,
                                v.z = t[L].x * O,
                                o.push(v.x, v.y, v.z),
                                y.x = D / n,
                                y.y = L / (t.length - 1),
                                c.push(y.x, y.y);
                                const N = u[3 * L + 0] * U
                                  , z = u[3 * L + 1]
                                  , I = u[3 * L + 0] * O;
                                f.push(N, z, I)
                            }
                        }
                        for (let D = 0; D < n; D++)
                            for (let w = 0; w < t.length - 1; w++) {
                                const U = w + D * t.length
                                  , O = U
                                  , L = U + t.length
                                  , N = U + t.length + 1
                                  , z = U + 1;
                                a.push(O, L, z),
                                a.push(N, z, L)
                            }
                        this.setIndex(a),
                        this.setAttribute("position", new Rt(o,3)),
                        this.setAttribute("uv", new Rt(c,2)),
                        this.setAttribute("normal", new Rt(f,3))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new CU(t.points,t.segments,t.phiStart,t.phiLength)
                    }
                }
                  , bT = class wU extends Xp {
                    constructor(t=1, n=0) {
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, n),
                        this.type = "OctahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new wU(t.radius,t.detail)
                    }
                }
                  , wf = class DU extends sn {
                    constructor(t=1, n=1, i=1, s=1) {
                        super(),
                        this.type = "PlaneGeometry",
                        this.parameters = {
                            width: t,
                            height: n,
                            widthSegments: i,
                            heightSegments: s
                        };
                        const a = t / 2
                          , o = n / 2
                          , c = Math.floor(i)
                          , u = Math.floor(s)
                          , f = c + 1
                          , m = u + 1
                          , v = t / c
                          , y = n / u
                          , S = []
                          , A = []
                          , M = []
                          , x = [];
                        for (let T = 0; T < m; T++) {
                            const D = T * y - o;
                            for (let w = 0; w < f; w++) {
                                const U = w * v - a;
                                A.push(U, -D, 0),
                                M.push(0, 0, 1),
                                x.push(w / c),
                                x.push(1 - T / u)
                            }
                        }
                        for (let T = 0; T < u; T++)
                            for (let D = 0; D < c; D++) {
                                const w = D + f * T
                                  , U = D + f * (T + 1)
                                  , O = D + 1 + f * (T + 1)
                                  , L = D + 1 + f * T;
                                S.push(w, U, L),
                                S.push(U, O, L)
                            }
                        this.setIndex(S),
                        this.setAttribute("position", new Rt(A,3)),
                        this.setAttribute("normal", new Rt(M,3)),
                        this.setAttribute("uv", new Rt(x,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new DU(t.width,t.height,t.widthSegments,t.heightSegments)
                    }
                }
                  , Gw = class RU extends sn {
                    constructor(t=.5, n=1, i=32, s=1, a=0, o=Math.PI * 2) {
                        super(),
                        this.type = "RingGeometry",
                        this.parameters = {
                            innerRadius: t,
                            outerRadius: n,
                            thetaSegments: i,
                            phiSegments: s,
                            thetaStart: a,
                            thetaLength: o
                        },
                        i = Math.max(3, i),
                        s = Math.max(1, s);
                        const c = []
                          , u = []
                          , f = []
                          , m = [];
                        let v = t;
                        const y = (n - t) / s
                          , S = new ae
                          , A = new Oe;
                        for (let M = 0; M <= s; M++) {
                            for (let x = 0; x <= i; x++) {
                                const T = a + x / i * o;
                                S.x = v * Math.cos(T),
                                S.y = v * Math.sin(T),
                                u.push(S.x, S.y, S.z),
                                f.push(0, 0, 1),
                                A.x = (S.x / n + 1) / 2,
                                A.y = (S.y / n + 1) / 2,
                                m.push(A.x, A.y)
                            }
                            v += y
                        }
                        for (let M = 0; M < s; M++) {
                            const x = M * (i + 1);
                            for (let T = 0; T < i; T++) {
                                const D = T + x
                                  , w = D
                                  , U = D + i + 1
                                  , O = D + i + 2
                                  , L = D + 1;
                                c.push(w, U, L),
                                c.push(U, O, L)
                            }
                        }
                        this.setIndex(c),
                        this.setAttribute("position", new Rt(u,3)),
                        this.setAttribute("normal", new Rt(f,3)),
                        this.setAttribute("uv", new Rt(m,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new RU(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)
                    }
                }
                  , Vw = class UU extends sn {
                    constructor(t=new Ef([new Oe(0,.5), new Oe(-.5,-.5), new Oe(.5,-.5)]), n=12) {
                        super(),
                        this.type = "ShapeGeometry",
                        this.parameters = {
                            shapes: t,
                            curveSegments: n
                        };
                        const i = []
                          , s = []
                          , a = []
                          , o = [];
                        let c = 0
                          , u = 0;
                        if (Array.isArray(t) === !1)
                            f(t);
                        else
                            for (let m = 0; m < t.length; m++)
                                f(t[m]),
                                this.addGroup(c, u, m),
                                c += u,
                                u = 0;
                        this.setIndex(i),
                        this.setAttribute("position", new Rt(s,3)),
                        this.setAttribute("normal", new Rt(a,3)),
                        this.setAttribute("uv", new Rt(o,2));
                        function f(m) {
                            const v = s.length / 3
                              , y = m.extractPoints(n);
                            let S = y.shape;
                            const A = y.holes;
                            ru.isClockWise(S) === !1 && (S = S.reverse());
                            for (let x = 0, T = A.length; x < T; x++) {
                                const D = A[x];
                                ru.isClockWise(D) === !0 && (A[x] = D.reverse())
                            }
                            const M = ru.triangulateShape(S, A);
                            for (let x = 0, T = A.length; x < T; x++) {
                                const D = A[x];
                                S = S.concat(D)
                            }
                            for (let x = 0, T = S.length; x < T; x++) {
                                const D = S[x];
                                s.push(D.x, D.y, 0),
                                a.push(0, 0, 1),
                                o.push(D.x, D.y)
                            }
                            for (let x = 0, T = M.length; x < T; x++) {
                                const D = M[x]
                                  , w = D[0] + v
                                  , U = D[1] + v
                                  , O = D[2] + v;
                                i.push(w, U, O),
                                u += 3
                            }
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON()
                          , n = this.parameters.shapes;
                        return aI(n, t)
                    }
                    static fromJSON(t, n) {
                        const i = [];
                        for (let s = 0, a = t.shapes.length; s < a; s++) {
                            const o = n[t.shapes[s]];
                            i.push(o)
                        }
                        return new UU(i,t.curveSegments)
                    }
                }
                ;
                function aI(e, t) {
                    if (t.shapes = [],
                    Array.isArray(e))
                        for (let n = 0, i = e.length; n < i; n++) {
                            const s = e[n];
                            t.shapes.push(s.uuid)
                        }
                    else
                        t.shapes.push(e.uuid);
                    return t
                }
                var ET = class OU extends sn {
                    constructor(t=1, n=32, i=16, s=0, a=Math.PI * 2, o=0, c=Math.PI) {
                        super(),
                        this.type = "SphereGeometry",
                        this.parameters = {
                            radius: t,
                            widthSegments: n,
                            heightSegments: i,
                            phiStart: s,
                            phiLength: a,
                            thetaStart: o,
                            thetaLength: c
                        },
                        n = Math.max(3, Math.floor(n)),
                        i = Math.max(2, Math.floor(i));
                        const u = Math.min(o + c, Math.PI);
                        let f = 0;
                        const m = []
                          , v = new ae
                          , y = new ae
                          , S = []
                          , A = []
                          , M = []
                          , x = [];
                        for (let T = 0; T <= i; T++) {
                            const D = []
                              , w = T / i;
                            let U = 0;
                            T === 0 && o === 0 ? U = .5 / n : T === i && u === Math.PI && (U = -.5 / n);
                            for (let O = 0; O <= n; O++) {
                                const L = O / n;
                                v.x = -t * Math.cos(s + L * a) * Math.sin(o + w * c),
                                v.y = t * Math.cos(o + w * c),
                                v.z = t * Math.sin(s + L * a) * Math.sin(o + w * c),
                                A.push(v.x, v.y, v.z),
                                y.copy(v).normalize(),
                                M.push(y.x, y.y, y.z),
                                x.push(L + U, 1 - w),
                                D.push(f++)
                            }
                            m.push(D)
                        }
                        for (let T = 0; T < i; T++)
                            for (let D = 0; D < n; D++) {
                                const w = m[T][D + 1]
                                  , U = m[T][D]
                                  , O = m[T + 1][D]
                                  , L = m[T + 1][D + 1];
                                (T !== 0 || o > 0) && S.push(w, U, L),
                                (T !== i - 1 || u < Math.PI) && S.push(U, O, L)
                            }
                        this.setIndex(S),
                        this.setAttribute("position", new Rt(A,3)),
                        this.setAttribute("normal", new Rt(M,3)),
                        this.setAttribute("uv", new Rt(x,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new OU(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)
                    }
                }
                  , kw = class NU extends Xp {
                    constructor(t=1, n=0) {
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, n),
                        this.type = "TetrahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new NU(t.radius,t.detail)
                    }
                }
                  , Xw = class BU extends sn {
                    constructor(t=1, n=.4, i=12, s=48, a=Math.PI * 2) {
                        super(),
                        this.type = "TorusGeometry",
                        this.parameters = {
                            radius: t,
                            tube: n,
                            radialSegments: i,
                            tubularSegments: s,
                            arc: a
                        },
                        i = Math.floor(i),
                        s = Math.floor(s);
                        const o = []
                          , c = []
                          , u = []
                          , f = []
                          , m = new ae
                          , v = new ae
                          , y = new ae;
                        for (let S = 0; S <= i; S++)
                            for (let A = 0; A <= s; A++) {
                                const M = A / s * a
                                  , x = S / i * Math.PI * 2;
                                v.x = (t + n * Math.cos(x)) * Math.cos(M),
                                v.y = (t + n * Math.cos(x)) * Math.sin(M),
                                v.z = n * Math.sin(x),
                                c.push(v.x, v.y, v.z),
                                m.x = t * Math.cos(M),
                                m.y = t * Math.sin(M),
                                y.subVectors(v, m).normalize(),
                                u.push(y.x, y.y, y.z),
                                f.push(A / s),
                                f.push(S / i)
                            }
                        for (let S = 1; S <= i; S++)
                            for (let A = 1; A <= s; A++) {
                                const M = (s + 1) * S + A - 1
                                  , x = (s + 1) * (S - 1) + A - 1
                                  , T = (s + 1) * (S - 1) + A
                                  , D = (s + 1) * S + A;
                                o.push(M, x, D),
                                o.push(x, T, D)
                            }
                        this.setIndex(o),
                        this.setAttribute("position", new Rt(c,3)),
                        this.setAttribute("normal", new Rt(u,3)),
                        this.setAttribute("uv", new Rt(f,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new BU(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)
                    }
                }
                  , Ww = class LU extends sn {
                    constructor(t=1, n=.4, i=64, s=8, a=2, o=3) {
                        super(),
                        this.type = "TorusKnotGeometry",
                        this.parameters = {
                            radius: t,
                            tube: n,
                            tubularSegments: i,
                            radialSegments: s,
                            p: a,
                            q: o
                        },
                        i = Math.floor(i),
                        s = Math.floor(s);
                        const c = []
                          , u = []
                          , f = []
                          , m = []
                          , v = new ae
                          , y = new ae
                          , S = new ae
                          , A = new ae
                          , M = new ae
                          , x = new ae
                          , T = new ae;
                        for (let w = 0; w <= i; ++w) {
                            const U = w / i * a * Math.PI * 2;
                            D(U, a, o, t, S),
                            D(U + .01, a, o, t, A),
                            x.subVectors(A, S),
                            T.addVectors(A, S),
                            M.crossVectors(x, T),
                            T.crossVectors(M, x),
                            M.normalize(),
                            T.normalize();
                            for (let O = 0; O <= s; ++O) {
                                const L = O / s * Math.PI * 2
                                  , N = -n * Math.cos(L)
                                  , z = n * Math.sin(L);
                                v.x = S.x + (N * T.x + z * M.x),
                                v.y = S.y + (N * T.y + z * M.y),
                                v.z = S.z + (N * T.z + z * M.z),
                                u.push(v.x, v.y, v.z),
                                y.subVectors(v, S).normalize(),
                                f.push(y.x, y.y, y.z),
                                m.push(w / i),
                                m.push(O / s)
                            }
                        }
                        for (let w = 1; w <= i; w++)
                            for (let U = 1; U <= s; U++) {
                                const O = (s + 1) * (w - 1) + (U - 1)
                                  , L = (s + 1) * w + (U - 1)
                                  , N = (s + 1) * w + U
                                  , z = (s + 1) * (w - 1) + U;
                                c.push(O, L, z),
                                c.push(L, N, z)
                            }
                        this.setIndex(c),
                        this.setAttribute("position", new Rt(u,3)),
                        this.setAttribute("normal", new Rt(f,3)),
                        this.setAttribute("uv", new Rt(m,2));
                        function D(w, U, O, L, N) {
                            const z = Math.cos(w)
                              , I = Math.sin(w)
                              , B = O / U * w
                              , G = Math.cos(B);
                            N.x = L * (2 + G) * .5 * z,
                            N.y = L * (2 + G) * I * .5,
                            N.z = L * Math.sin(B) * .5
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new LU(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)
                    }
                }
                  , Yw = class IU extends sn {
                    constructor(t=new xT(new ae(-1,-1,0),new ae(-1,1,0),new ae(1,1,0)), n=64, i=1, s=8, a=!1) {
                        super(),
                        this.type = "TubeGeometry",
                        this.parameters = {
                            path: t,
                            tubularSegments: n,
                            radius: i,
                            radialSegments: s,
                            closed: a
                        };
                        const o = t.computeFrenetFrames(n, a);
                        this.tangents = o.tangents,
                        this.normals = o.normals,
                        this.binormals = o.binormals;
                        const c = new ae
                          , u = new ae
                          , f = new Oe;
                        let m = new ae;
                        const v = []
                          , y = []
                          , S = []
                          , A = [];
                        M(),
                        this.setIndex(A),
                        this.setAttribute("position", new Rt(v,3)),
                        this.setAttribute("normal", new Rt(y,3)),
                        this.setAttribute("uv", new Rt(S,2));
                        function M() {
                            for (let w = 0; w < n; w++)
                                x(w);
                            x(a === !1 ? n : 0),
                            D(),
                            T()
                        }
                        function x(w) {
                            m = t.getPointAt(w / n, m);
                            const U = o.normals[w]
                              , O = o.binormals[w];
                            for (let L = 0; L <= s; L++) {
                                const N = L / s * Math.PI * 2
                                  , z = Math.sin(N)
                                  , I = -Math.cos(N);
                                u.x = I * U.x + z * O.x,
                                u.y = I * U.y + z * O.y,
                                u.z = I * U.z + z * O.z,
                                u.normalize(),
                                y.push(u.x, u.y, u.z),
                                c.x = m.x + i * u.x,
                                c.y = m.y + i * u.y,
                                c.z = m.z + i * u.z,
                                v.push(c.x, c.y, c.z)
                            }
                        }
                        function T() {
                            for (let w = 1; w <= n; w++)
                                for (let U = 1; U <= s; U++) {
                                    const O = (s + 1) * (w - 1) + (U - 1)
                                      , L = (s + 1) * w + (U - 1)
                                      , N = (s + 1) * w + U
                                      , z = (s + 1) * (w - 1) + U;
                                    A.push(O, L, z),
                                    A.push(L, N, z)
                                }
                        }
                        function D() {
                            for (let w = 0; w <= n; w++)
                                for (let U = 0; U <= s; U++)
                                    f.x = w / n,
                                    f.y = U / s,
                                    S.push(f.x, f.y)
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.path = this.parameters.path.toJSON(),
                        t
                    }
                    static fromJSON(t) {
                        return new IU(new uS[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)
                    }
                }
                  , qw = class extends sn {
                    constructor(e=null) {
                        if (super(),
                        this.type = "WireframeGeometry",
                        this.parameters = {
                            geometry: e
                        },
                        e !== null) {
                            const t = []
                              , n = new Set
                              , i = new ae
                              , s = new ae;
                            if (e.index !== null) {
                                const a = e.attributes.position
                                  , o = e.index;
                                let c = e.groups;
                                c.length === 0 && (c = [{
                                    start: 0,
                                    count: o.count,
                                    materialIndex: 0
                                }]);
                                for (let u = 0, f = c.length; u < f; ++u) {
                                    const m = c[u]
                                      , v = m.start
                                      , y = m.count;
                                    for (let S = v, A = v + y; S < A; S += 3)
                                        for (let M = 0; M < 3; M++) {
                                            const x = o.getX(S + M)
                                              , T = o.getX(S + (M + 1) % 3);
                                            i.fromBufferAttribute(a, x),
                                            s.fromBufferAttribute(a, T),
                                            jw(i, s, n) === !0 && (t.push(i.x, i.y, i.z),
                                            t.push(s.x, s.y, s.z))
                                        }
                                }
                            } else {
                                const a = e.attributes.position;
                                for (let o = 0, c = a.count / 3; o < c; o++)
                                    for (let u = 0; u < 3; u++) {
                                        const f = 3 * o + u
                                          , m = 3 * o + (u + 1) % 3;
                                        i.fromBufferAttribute(a, f),
                                        s.fromBufferAttribute(a, m),
                                        jw(i, s, n) === !0 && (t.push(i.x, i.y, i.z),
                                        t.push(s.x, s.y, s.z))
                                    }
                            }
                            this.setAttribute("position", new Rt(t,3))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                }
                ;
                function jw(e, t, n) {
                    const i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`
                      , s = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                    return n.has(i) === !0 || n.has(s) === !0 ? !1 : (n.add(i),
                    n.add(s),
                    !0)
                }
                var Qw = Object.freeze({
                    __proto__: null,
                    BoxGeometry: dh,
                    CapsuleGeometry: xw,
                    CircleGeometry: Aw,
                    ConeGeometry: fT,
                    CylinderGeometry: hT,
                    DodecahedronGeometry: Tw,
                    EdgesGeometry: Mw,
                    ExtrudeGeometry: zw,
                    IcosahedronGeometry: Fw,
                    LatheGeometry: Hw,
                    OctahedronGeometry: bT,
                    PlaneGeometry: wf,
                    PolyhedronGeometry: Xp,
                    RingGeometry: Gw,
                    ShapeGeometry: Vw,
                    SphereGeometry: ET,
                    TetrahedronGeometry: kw,
                    TorusGeometry: Xw,
                    TorusKnotGeometry: Ww,
                    TubeGeometry: Yw,
                    WireframeGeometry: qw
                })
                  , Zw = class extends qs {
                    constructor(e) {
                        super(),
                        this.isShadowMaterial = !0,
                        this.type = "ShadowMaterial",
                        this.color = new ft(0),
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.fog = e.fog,
                        this
                    }
                }
                  , Kw = class extends kn {
                    constructor(e) {
                        super(e),
                        this.isRawShaderMaterial = !0,
                        this.type = "RawShaderMaterial"
                    }
                }
                  , Yp = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshStandardMaterial = !0,
                        this.type = "MeshStandardMaterial",
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color = new ft(16777215),
                        this.roughness = 1,
                        this.metalness = 0,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ft(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = ah,
                        this.normalScale = new Oe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.roughnessMap = null,
                        this.metalnessMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new Co,
                        this.envMapIntensity = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color.copy(e.color),
                        this.roughness = e.roughness,
                        this.metalness = e.metalness,
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.roughnessMap = e.roughnessMap,
                        this.metalnessMap = e.metalnessMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.envMapIntensity = e.envMapIntensity,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , Jw = class extends Yp {
                    constructor(e) {
                        super(),
                        this.isMeshPhysicalMaterial = !0,
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.type = "MeshPhysicalMaterial",
                        this.anisotropyRotation = 0,
                        this.anisotropyMap = null,
                        this.clearcoatMap = null,
                        this.clearcoatRoughness = 0,
                        this.clearcoatRoughnessMap = null,
                        this.clearcoatNormalScale = new Oe(1,1),
                        this.clearcoatNormalMap = null,
                        this.ior = 1.5,
                        Object.defineProperty(this, "reflectivity", {
                            get: function() {
                                return Yt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function(t) {
                                this.ior = (1 + .4 * t) / (1 - .4 * t)
                            }
                        }),
                        this.iridescenceMap = null,
                        this.iridescenceIOR = 1.3,
                        this.iridescenceThicknessRange = [100, 400],
                        this.iridescenceThicknessMap = null,
                        this.sheenColor = new ft(0),
                        this.sheenColorMap = null,
                        this.sheenRoughness = 1,
                        this.sheenRoughnessMap = null,
                        this.transmissionMap = null,
                        this.thickness = 0,
                        this.thicknessMap = null,
                        this.attenuationDistance = 1 / 0,
                        this.attenuationColor = new ft(1,1,1),
                        this.specularIntensity = 1,
                        this.specularIntensityMap = null,
                        this.specularColor = new ft(1,1,1),
                        this.specularColorMap = null,
                        this._anisotropy = 0,
                        this._clearcoat = 0,
                        this._dispersion = 0,
                        this._iridescence = 0,
                        this._sheen = 0,
                        this._transmission = 0,
                        this.setValues(e)
                    }
                    get anisotropy() {
                        return this._anisotropy
                    }
                    set anisotropy(e) {
                        this._anisotropy > 0 != e > 0 && this.version++,
                        this._anisotropy = e
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(e) {
                        this._clearcoat > 0 != e > 0 && this.version++,
                        this._clearcoat = e
                    }
                    get iridescence() {
                        return this._iridescence
                    }
                    set iridescence(e) {
                        this._iridescence > 0 != e > 0 && this.version++,
                        this._iridescence = e
                    }
                    get dispersion() {
                        return this._dispersion
                    }
                    set dispersion(e) {
                        this._dispersion > 0 != e > 0 && this.version++,
                        this._dispersion = e
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(e) {
                        this._sheen > 0 != e > 0 && this.version++,
                        this._sheen = e
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(e) {
                        this._transmission > 0 != e > 0 && this.version++,
                        this._transmission = e
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.anisotropy = e.anisotropy,
                        this.anisotropyRotation = e.anisotropyRotation,
                        this.anisotropyMap = e.anisotropyMap,
                        this.clearcoat = e.clearcoat,
                        this.clearcoatMap = e.clearcoatMap,
                        this.clearcoatRoughness = e.clearcoatRoughness,
                        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                        this.clearcoatNormalMap = e.clearcoatNormalMap,
                        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                        this.dispersion = e.dispersion,
                        this.ior = e.ior,
                        this.iridescence = e.iridescence,
                        this.iridescenceMap = e.iridescenceMap,
                        this.iridescenceIOR = e.iridescenceIOR,
                        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                        this.sheen = e.sheen,
                        this.sheenColor.copy(e.sheenColor),
                        this.sheenColorMap = e.sheenColorMap,
                        this.sheenRoughness = e.sheenRoughness,
                        this.sheenRoughnessMap = e.sheenRoughnessMap,
                        this.transmission = e.transmission,
                        this.transmissionMap = e.transmissionMap,
                        this.thickness = e.thickness,
                        this.thicknessMap = e.thicknessMap,
                        this.attenuationDistance = e.attenuationDistance,
                        this.attenuationColor.copy(e.attenuationColor),
                        this.specularIntensity = e.specularIntensity,
                        this.specularIntensityMap = e.specularIntensityMap,
                        this.specularColor.copy(e.specularColor),
                        this.specularColorMap = e.specularColorMap,
                        this
                    }
                }
                  , $w = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshPhongMaterial = !0,
                        this.type = "MeshPhongMaterial",
                        this.color = new ft(16777215),
                        this.specular = new ft(1118481),
                        this.shininess = 30,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ft(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = ah,
                        this.normalScale = new Oe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new Co,
                        this.combine = tg,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.specular.copy(e.specular),
                        this.shininess = e.shininess,
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , e2 = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshToonMaterial = !0,
                        this.defines = {
                            TOON: ""
                        },
                        this.type = "MeshToonMaterial",
                        this.color = new ft(16777215),
                        this.map = null,
                        this.gradientMap = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ft(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = ah,
                        this.normalScale = new Oe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.gradientMap = e.gradientMap,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.alphaMap = e.alphaMap,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                  , CT = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshNormalMaterial = !0,
                        this.type = "MeshNormalMaterial",
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = ah,
                        this.normalScale = new Oe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.flatShading = !1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.flatShading = e.flatShading,
                        this
                    }
                }
                  , t2 = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshLambertMaterial = !0,
                        this.type = "MeshLambertMaterial",
                        this.color = new ft(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ft(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = ah,
                        this.normalScale = new Oe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new Co,
                        this.combine = tg,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , Fg = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshDepthMaterial = !0,
                        this.type = "MeshDepthMaterial",
                        this.depthPacking = as,
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.depthPacking = e.depthPacking,
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this
                    }
                }
                  , pS = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshDistanceMaterial = !0,
                        this.type = "MeshDistanceMaterial",
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this
                    }
                }
                  , n2 = class extends qs {
                    constructor(e) {
                        super(),
                        this.isMeshMatcapMaterial = !0,
                        this.defines = {
                            MATCAP: ""
                        },
                        this.type = "MeshMatcapMaterial",
                        this.color = new ft(16777215),
                        this.matcap = null,
                        this.map = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = ah,
                        this.normalScale = new Oe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            MATCAP: ""
                        },
                        this.color.copy(e.color),
                        this.matcap = e.matcap,
                        this.map = e.map,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.alphaMap = e.alphaMap,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , i2 = class extends ir {
                    constructor(e) {
                        super(),
                        this.isLineDashedMaterial = !0,
                        this.type = "LineDashedMaterial",
                        this.scale = 1,
                        this.dashSize = 3,
                        this.gapSize = 1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.scale = e.scale,
                        this.dashSize = e.dashSize,
                        this.gapSize = e.gapSize,
                        this
                    }
                }
                ;
                function Df(e, t) {
                    return !e || e.constructor === t ? e : typeof t.BYTES_PER_ELEMENT == "number" ? new t(e) : Array.prototype.slice.call(e)
                }
                function s2(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                }
                function a2(e) {
                    function t(s, a) {
                        return e[s] - e[a]
                    }
                    const n = e.length
                      , i = new Array(n);
                    for (let s = 0; s !== n; ++s)
                        i[s] = s;
                    return i.sort(t),
                    i
                }
                function wT(e, t, n) {
                    const i = e.length
                      , s = new e.constructor(i);
                    for (let a = 0, o = 0; o !== i; ++a) {
                        const c = n[a] * t;
                        for (let u = 0; u !== t; ++u)
                            s[o++] = e[c + u]
                    }
                    return s
                }
                function DT(e, t, n, i) {
                    let s = 1
                      , a = e[0];
                    for (; a !== void 0 && a[i] === void 0; )
                        a = e[s++];
                    if (a === void 0)
                        return;
                    let o = a[i];
                    if (o !== void 0)
                        if (Array.isArray(o))
                            do
                                o = a[i],
                                o !== void 0 && (t.push(a.time),
                                n.push(...o)),
                                a = e[s++];
                            while (a !== void 0);
                        else if (o.toArray !== void 0)
                            do
                                o = a[i],
                                o !== void 0 && (t.push(a.time),
                                o.toArray(n, n.length)),
                                a = e[s++];
                            while (a !== void 0);
                        else
                            do
                                o = a[i],
                                o !== void 0 && (t.push(a.time),
                                n.push(o)),
                                a = e[s++];
                            while (a !== void 0)
                }
                function rI(e, t, n, i, s=30) {
                    const a = e.clone();
                    a.name = t;
                    const o = [];
                    for (let u = 0; u < a.tracks.length; ++u) {
                        const f = a.tracks[u]
                          , m = f.getValueSize()
                          , v = []
                          , y = [];
                        for (let S = 0; S < f.times.length; ++S) {
                            const A = f.times[S] * s;
                            if (!(A < n || A >= i)) {
                                v.push(f.times[S]);
                                for (let M = 0; M < m; ++M)
                                    y.push(f.values[S * m + M])
                            }
                        }
                        v.length !== 0 && (f.times = Df(v, f.times.constructor),
                        f.values = Df(y, f.values.constructor),
                        o.push(f))
                    }
                    a.tracks = o;
                    let c = 1 / 0;
                    for (let u = 0; u < a.tracks.length; ++u)
                        c > a.tracks[u].times[0] && (c = a.tracks[u].times[0]);
                    for (let u = 0; u < a.tracks.length; ++u)
                        a.tracks[u].shift(-1 * c);
                    return a.resetDuration(),
                    a
                }
                function oI(e, t=0, n=e, i=30) {
                    i <= 0 && (i = 30);
                    const s = n.tracks.length
                      , a = t / i;
                    for (let o = 0; o < s; ++o) {
                        const c = n.tracks[o]
                          , u = c.ValueTypeName;
                        if (u === "bool" || u === "string")
                            continue;
                        const f = e.tracks.find(function(T) {
                            return T.name === c.name && T.ValueTypeName === u
                        });
                        if (f === void 0)
                            continue;
                        let m = 0;
                        const v = c.getValueSize();
                        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = v / 3);
                        let y = 0;
                        const S = f.getValueSize();
                        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (y = S / 3);
                        const A = c.times.length - 1;
                        let M;
                        if (a <= c.times[0]) {
                            const T = m
                              , D = v - m;
                            M = c.values.slice(T, D)
                        } else if (a >= c.times[A]) {
                            const T = A * v + m
                              , D = T + v - m;
                            M = c.values.slice(T, D)
                        } else {
                            const T = c.createInterpolant()
                              , D = m
                              , w = v - m;
                            T.evaluate(a),
                            M = T.resultBuffer.slice(D, w)
                        }
                        u === "quaternion" && new ia().fromArray(M).normalize().conjugate().toArray(M);
                        const x = f.times.length;
                        for (let T = 0; T < x; ++T) {
                            const D = T * S + y;
                            if (u === "quaternion")
                                ia.multiplyQuaternionsFlat(f.values, D, M, 0, f.values, D);
                            else {
                                const w = S - y * 2;
                                for (let U = 0; U < w; ++U)
                                    f.values[D + U] -= M[U]
                            }
                        }
                    }
                    return e.blendMode = MA,
                    e
                }
                var lI = class {
                    static convertArray(e, t) {
                        return Df(e, t)
                    }
                    static isTypedArray(e) {
                        return s2(e)
                    }
                    static getKeyframeOrder(e) {
                        return a2(e)
                    }
                    static sortedArray(e, t, n) {
                        return wT(e, t, n)
                    }
                    static flattenJSON(e, t, n, i) {
                        DT(e, t, n, i)
                    }
                    static subclip(e, t, n, i, s=30) {
                        return rI(e, t, n, i, s)
                    }
                    static makeClipAdditive(e, t=0, n=e, i=30) {
                        return oI(e, t, n, i)
                    }
                }
                  , Hg = class {
                    constructor(e, t, n, i) {
                        this.parameterPositions = e,
                        this._cachedIndex = 0,
                        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
                        this.sampleValues = t,
                        this.valueSize = n,
                        this.settings = null,
                        this.DefaultSettings_ = {}
                    }
                    evaluate(e) {
                        const t = this.parameterPositions;
                        let n = this._cachedIndex
                          , i = t[n]
                          , s = t[n - 1];
                        e: {
                            t: {
                                let a;
                                n: {
                                    i: if (!(e < i)) {
                                        for (let o = n + 2; ; ) {
                                            if (i === void 0) {
                                                if (e < s)
                                                    break i;
                                                return n = t.length,
                                                this._cachedIndex = n,
                                                this.copySampleValue_(n - 1)
                                            }
                                            if (n === o)
                                                break;
                                            if (s = i,
                                            i = t[++n],
                                            e < i)
                                                break t
                                        }
                                        a = t.length;
                                        break n
                                    }
                                    if (!(e >= s)) {
                                        const o = t[1];
                                        e < o && (n = 2,
                                        s = o);
                                        for (let c = n - 2; ; ) {
                                            if (s === void 0)
                                                return this._cachedIndex = 0,
                                                this.copySampleValue_(0);
                                            if (n === c)
                                                break;
                                            if (i = s,
                                            s = t[--n - 1],
                                            e >= s)
                                                break t
                                        }
                                        a = n,
                                        n = 0;
                                        break n
                                    }
                                    break e
                                }
                                for (; n < a; ) {
                                    const o = n + a >>> 1;
                                    e < t[o] ? a = o : n = o + 1
                                }
                                if (i = t[n],
                                s = t[n - 1],
                                s === void 0)
                                    return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                if (i === void 0)
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.copySampleValue_(n - 1)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, s, i)
                        }
                        return this.interpolate_(n, s, e, i)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(e) {
                        const t = this.resultBuffer
                          , n = this.sampleValues
                          , i = this.valueSize
                          , s = e * i;
                        for (let a = 0; a !== i; ++a)
                            t[a] = n[s + a];
                        return t
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                  , r2 = class extends Hg {
                    constructor(e, t, n, i) {
                        super(e, t, n, i),
                        this._weightPrev = -0,
                        this._offsetPrev = -0,
                        this._weightNext = -0,
                        this._offsetNext = -0,
                        this.DefaultSettings_ = {
                            endingStart: mf,
                            endingEnd: mf
                        }
                    }
                    intervalChanged_(e, t, n) {
                        const i = this.parameterPositions;
                        let s = e - 2
                          , a = e + 1
                          , o = i[s]
                          , c = i[a];
                        if (o === void 0)
                            switch (this.getSettings_().endingStart) {
                            case vf:
                                s = e,
                                o = 2 * t - n;
                                break;
                            case hg:
                                s = i.length - 2,
                                o = t + i[s] - i[s + 1];
                                break;
                            default:
                                s = e,
                                o = n
                            }
                        if (c === void 0)
                            switch (this.getSettings_().endingEnd) {
                            case vf:
                                a = e,
                                c = 2 * n - t;
                                break;
                            case hg:
                                a = 1,
                                c = n + i[1] - i[0];
                                break;
                            default:
                                a = e - 1,
                                c = t
                            }
                        const u = (n - t) * .5
                          , f = this.valueSize;
                        this._weightPrev = u / (t - o),
                        this._weightNext = u / (c - n),
                        this._offsetPrev = s * f,
                        this._offsetNext = a * f
                    }
                    interpolate_(e, t, n, i) {
                        const s = this.resultBuffer
                          , a = this.sampleValues
                          , o = this.valueSize
                          , c = e * o
                          , u = c - o
                          , f = this._offsetPrev
                          , m = this._offsetNext
                          , v = this._weightPrev
                          , y = this._weightNext
                          , S = (n - t) / (i - t)
                          , A = S * S
                          , M = A * S
                          , x = -v * M + 2 * v * A - v * S
                          , T = (1 + v) * M + (-1.5 - 2 * v) * A + (-.5 + v) * S + 1
                          , D = (-1 - y) * M + (1.5 + y) * A + .5 * S
                          , w = y * M - y * A;
                        for (let U = 0; U !== o; ++U)
                            s[U] = x * a[f + U] + T * a[u + U] + D * a[c + U] + w * a[m + U];
                        return s
                    }
                }
                  , RT = class extends Hg {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    interpolate_(e, t, n, i) {
                        const s = this.resultBuffer
                          , a = this.sampleValues
                          , o = this.valueSize
                          , c = e * o
                          , u = c - o
                          , f = (n - t) / (i - t)
                          , m = 1 - f;
                        for (let v = 0; v !== o; ++v)
                            s[v] = a[u + v] * m + a[c + v] * f;
                        return s
                    }
                }
                  , o2 = class extends Hg {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    interpolate_(e) {
                        return this.copySampleValue_(e - 1)
                    }
                }
                  , Do = class {
                    constructor(e, t, n, i) {
                        if (e === void 0)
                            throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (t === void 0 || t.length === 0)
                            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                        this.name = e,
                        this.times = Df(t, this.TimeBufferType),
                        this.values = Df(n, this.ValueBufferType),
                        this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(e) {
                        const t = e.constructor;
                        let n;
                        if (t.toJSON !== this.toJSON)
                            n = t.toJSON(e);
                        else {
                            n = {
                                name: e.name,
                                times: Df(e.times, Array),
                                values: Df(e.values, Array)
                            };
                            const i = e.getInterpolation();
                            i !== e.DefaultInterpolation && (n.interpolation = i)
                        }
                        return n.type = e.ValueTypeName,
                        n
                    }
                    InterpolantFactoryMethodDiscrete(e) {
                        return new o2(this.times,this.values,this.getValueSize(),e)
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new RT(this.times,this.values,this.getValueSize(),e)
                    }
                    InterpolantFactoryMethodSmooth(e) {
                        return new r2(this.times,this.values,this.getValueSize(),e)
                    }
                    setInterpolation(e) {
                        let t;
                        switch (e) {
                        case ug:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case S_:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case x_:
                            t = this.InterpolantFactoryMethodSmooth;
                            break
                        }
                        if (t === void 0) {
                            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (this.createInterpolant === void 0)
                                if (e !== this.DefaultInterpolation)
                                    this.setInterpolation(this.DefaultInterpolation);
                                else
                                    throw new Error(n);
                            return console.warn("THREE.KeyframeTrack:", n),
                            this
                        }
                        return this.createInterpolant = t,
                        this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return ug;
                        case this.InterpolantFactoryMethodLinear:
                            return S_;
                        case this.InterpolantFactoryMethodSmooth:
                            return x_
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(e) {
                        if (e !== 0) {
                            const t = this.times;
                            for (let n = 0, i = t.length; n !== i; ++n)
                                t[n] += e
                        }
                        return this
                    }
                    scale(e) {
                        if (e !== 1) {
                            const t = this.times;
                            for (let n = 0, i = t.length; n !== i; ++n)
                                t[n] *= e
                        }
                        return this
                    }
                    trim(e, t) {
                        const n = this.times
                          , i = n.length;
                        let s = 0
                          , a = i - 1;
                        for (; s !== i && n[s] < e; )
                            ++s;
                        for (; a !== -1 && n[a] > t; )
                            --a;
                        if (++a,
                        s !== 0 || a !== i) {
                            s >= a && (a = Math.max(a, 1),
                            s = a - 1);
                            const o = this.getValueSize();
                            this.times = n.slice(s, a),
                            this.values = this.values.slice(s * o, a * o)
                        }
                        return this
                    }
                    validate() {
                        let e = !0;
                        const t = this.getValueSize();
                        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                        e = !1);
                        const n = this.times
                          , i = this.values
                          , s = n.length;
                        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                        e = !1);
                        let a = null;
                        for (let o = 0; o !== s; o++) {
                            const c = n[o];
                            if (typeof c == "number" && isNaN(c)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c),
                                e = !1;
                                break
                            }
                            if (a !== null && a > c) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a),
                                e = !1;
                                break
                            }
                            a = c
                        }
                        if (i !== void 0 && s2(i))
                            for (let o = 0, c = i.length; o !== c; ++o) {
                                const u = i[o];
                                if (isNaN(u)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, u),
                                    e = !1;
                                    break
                                }
                            }
                        return e
                    }
                    optimize() {
                        const e = this.times.slice()
                          , t = this.values.slice()
                          , n = this.getValueSize()
                          , i = this.getInterpolation() === x_
                          , s = e.length - 1;
                        let a = 1;
                        for (let o = 1; o < s; ++o) {
                            let c = !1;
                            const u = e[o]
                              , f = e[o + 1];
                            if (u !== f && (o !== 1 || u !== e[0]))
                                if (i)
                                    c = !0;
                                else {
                                    const m = o * n
                                      , v = m - n
                                      , y = m + n;
                                    for (let S = 0; S !== n; ++S) {
                                        const A = t[m + S];
                                        if (A !== t[v + S] || A !== t[y + S]) {
                                            c = !0;
                                            break
                                        }
                                    }
                                }
                            if (c) {
                                if (o !== a) {
                                    e[a] = e[o];
                                    const m = o * n
                                      , v = a * n;
                                    for (let y = 0; y !== n; ++y)
                                        t[v + y] = t[m + y]
                                }
                                ++a
                            }
                        }
                        if (s > 0) {
                            e[a] = e[s];
                            for (let o = s * n, c = a * n, u = 0; u !== n; ++u)
                                t[c + u] = t[o + u];
                            ++a
                        }
                        return a !== e.length ? (this.times = e.slice(0, a),
                        this.values = t.slice(0, a * n)) : (this.times = e,
                        this.values = t),
                        this
                    }
                    clone() {
                        const e = this.times.slice()
                          , t = this.values.slice()
                          , n = this.constructor
                          , i = new n(this.name,e,t);
                        return i.createInterpolant = this.createInterpolant,
                        i
                    }
                }
                ;
                Do.prototype.ValueTypeName = "",
                Do.prototype.TimeBufferType = Float32Array,
                Do.prototype.ValueBufferType = Float32Array,
                Do.prototype.DefaultInterpolation = S_;
                var Rf = class extends Do {
                    constructor(e, t, n) {
                        super(e, t, n)
                    }
                }
                ;
                Rf.prototype.ValueTypeName = "bool",
                Rf.prototype.ValueBufferType = Array,
                Rf.prototype.DefaultInterpolation = ug,
                Rf.prototype.InterpolantFactoryMethodLinear = void 0,
                Rf.prototype.InterpolantFactoryMethodSmooth = void 0;
                var UT = class extends Do {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                }
                ;
                UT.prototype.ValueTypeName = "color";
                var Gg = class extends Do {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                }
                ;
                Gg.prototype.ValueTypeName = "number";
                var l2 = class extends Hg {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    interpolate_(e, t, n, i) {
                        const s = this.resultBuffer
                          , a = this.sampleValues
                          , o = this.valueSize
                          , c = (n - t) / (i - t);
                        let u = e * o;
                        for (let f = u + o; u !== f; u += 4)
                            ia.slerpFlat(s, 0, a, u - o, a, u, c);
                        return s
                    }
                }
                  , Vg = class extends Do {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new l2(this.times,this.values,this.getValueSize(),e)
                    }
                }
                ;
                Vg.prototype.ValueTypeName = "quaternion",
                Vg.prototype.InterpolantFactoryMethodSmooth = void 0;
                var Uf = class extends Do {
                    constructor(e, t, n) {
                        super(e, t, n)
                    }
                }
                ;
                Uf.prototype.ValueTypeName = "string",
                Uf.prototype.ValueBufferType = Array,
                Uf.prototype.DefaultInterpolation = ug,
                Uf.prototype.InterpolantFactoryMethodLinear = void 0,
                Uf.prototype.InterpolantFactoryMethodSmooth = void 0;
                var kg = class extends Do {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                }
                ;
                kg.prototype.ValueTypeName = "vector";
                var Xg = class {
                    constructor(e="", t=-1, n=[], i=A_) {
                        this.name = e,
                        this.tracks = n,
                        this.duration = t,
                        this.blendMode = i,
                        this.uuid = jr(),
                        this.userData = {},
                        this.duration < 0 && this.resetDuration()
                    }
                    static parse(e) {
                        const t = []
                          , n = e.tracks
                          , i = 1 / (e.fps || 1);
                        for (let a = 0, o = n.length; a !== o; ++a)
                            t.push(uI(n[a]).scale(i));
                        const s = new this(e.name,e.duration,t,e.blendMode);
                        return s.uuid = e.uuid,
                        s.userData = JSON.parse(e.userData || "{}"),
                        s
                    }
                    static toJSON(e) {
                        const t = []
                          , n = e.tracks
                          , i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode,
                            userData: JSON.stringify(e.userData)
                        };
                        for (let s = 0, a = n.length; s !== a; ++s)
                            t.push(Do.toJSON(n[s]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(e, t, n, i) {
                        const s = t.length
                          , a = [];
                        for (let o = 0; o < s; o++) {
                            let c = []
                              , u = [];
                            c.push((o + s - 1) % s, o, (o + 1) % s),
                            u.push(0, 1, 0);
                            const f = a2(c);
                            c = wT(c, 1, f),
                            u = wT(u, 1, f),
                            !i && c[0] === 0 && (c.push(s),
                            u.push(u[0])),
                            a.push(new Gg(".morphTargetInfluences[" + t[o].name + "]",c,u).scale(1 / n))
                        }
                        return new this(e,-1,a)
                    }
                    static findByName(e, t) {
                        let n = e;
                        if (!Array.isArray(e)) {
                            const i = e;
                            n = i.geometry && i.geometry.animations || i.animations
                        }
                        for (let i = 0; i < n.length; i++)
                            if (n[i].name === t)
                                return n[i];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(e, t, n) {
                        const i = {}
                          , s = /^([\w-]*?)([\d]+)$/;
                        for (let o = 0, c = e.length; o < c; o++) {
                            const u = e[o]
                              , f = u.name.match(s);
                            if (f && f.length > 1) {
                                const m = f[1];
                                let v = i[m];
                                v || (i[m] = v = []),
                                v.push(u)
                            }
                        }
                        const a = [];
                        for (const o in i)
                            a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
                        return a
                    }
                    static parseAnimation(e, t) {
                        if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
                        !e)
                            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                            null;
                        const n = function(f, m, v, y, S) {
                            if (v.length !== 0) {
                                const A = []
                                  , M = [];
                                DT(v, A, M, y),
                                A.length !== 0 && S.push(new f(m,A,M))
                            }
                        }
                          , i = []
                          , s = e.name || "default"
                          , a = e.fps || 30
                          , o = e.blendMode;
                        let c = e.length || -1;
                        const u = e.hierarchy || [];
                        for (let f = 0; f < u.length; f++) {
                            const m = u[f].keys;
                            if (!(!m || m.length === 0))
                                if (m[0].morphTargets) {
                                    const v = {};
                                    let y;
                                    for (y = 0; y < m.length; y++)
                                        if (m[y].morphTargets)
                                            for (let S = 0; S < m[y].morphTargets.length; S++)
                                                v[m[y].morphTargets[S]] = -1;
                                    for (const S in v) {
                                        const A = []
                                          , M = [];
                                        for (let x = 0; x !== m[y].morphTargets.length; ++x) {
                                            const T = m[y];
                                            A.push(T.time),
                                            M.push(T.morphTarget === S ? 1 : 0)
                                        }
                                        i.push(new Gg(".morphTargetInfluence[" + S + "]",A,M))
                                    }
                                    c = v.length * a
                                } else {
                                    const v = ".bones[" + t[f].name + "]";
                                    n(kg, v + ".position", m, "pos", i),
                                    n(Vg, v + ".quaternion", m, "rot", i),
                                    n(kg, v + ".scale", m, "scl", i)
                                }
                        }
                        return i.length === 0 ? null : new this(s,c,i,o)
                    }
                    resetDuration() {
                        const e = this.tracks;
                        let t = 0;
                        for (let n = 0, i = e.length; n !== i; ++n) {
                            const s = this.tracks[n];
                            t = Math.max(t, s.times[s.times.length - 1])
                        }
                        return this.duration = t,
                        this
                    }
                    trim() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let e = !0;
                        for (let t = 0; t < this.tracks.length; t++)
                            e = e && this.tracks[t].validate();
                        return e
                    }
                    optimize() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].optimize();
                        return this
                    }
                    clone() {
                        const e = [];
                        for (let n = 0; n < this.tracks.length; n++)
                            e.push(this.tracks[n].clone());
                        const t = new this.constructor(this.name,this.duration,e,this.blendMode);
                        return t.userData = JSON.parse(JSON.stringify(this.userData)),
                        t
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }
                ;
                function cI(e) {
                    switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Gg;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return kg;
                    case "color":
                        return UT;
                    case "quaternion":
                        return Vg;
                    case "bool":
                    case "boolean":
                        return Rf;
                    case "string":
                        return Uf
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }
                function uI(e) {
                    if (e.type === void 0)
                        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const t = cI(e.type);
                    if (e.times === void 0) {
                        const n = []
                          , i = [];
                        DT(e.keys, n, i, "value"),
                        e.times = n,
                        e.values = i
                    }
                    return t.parse !== void 0 ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
                }
                const uc = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        this.enabled !== !1 && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (this.enabled !== !1)
                            return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                var mS = class {
                    constructor(e, t, n) {
                        const i = this;
                        let s = !1, a = 0, o = 0, c;
                        const u = [];
                        this.onStart = void 0,
                        this.onLoad = e,
                        this.onProgress = t,
                        this.onError = n,
                        this.abortController = new AbortController,
                        this.itemStart = function(f) {
                            o++,
                            s === !1 && i.onStart !== void 0 && i.onStart(f, a, o),
                            s = !0
                        }
                        ,
                        this.itemEnd = function(f) {
                            a++,
                            i.onProgress !== void 0 && i.onProgress(f, a, o),
                            a === o && (s = !1,
                            i.onLoad !== void 0 && i.onLoad())
                        }
                        ,
                        this.itemError = function(f) {
                            i.onError !== void 0 && i.onError(f)
                        }
                        ,
                        this.resolveURL = function(f) {
                            return c ? c(f) : f
                        }
                        ,
                        this.setURLModifier = function(f) {
                            return c = f,
                            this
                        }
                        ,
                        this.addHandler = function(f, m) {
                            return u.push(f, m),
                            this
                        }
                        ,
                        this.removeHandler = function(f) {
                            const m = u.indexOf(f);
                            return m !== -1 && u.splice(m, 2),
                            this
                        }
                        ,
                        this.getHandler = function(f) {
                            for (let m = 0, v = u.length; m < v; m += 2) {
                                const y = u[m]
                                  , S = u[m + 1];
                                if (y.global && (y.lastIndex = 0),
                                y.test(f))
                                    return S
                            }
                            return null
                        }
                        ,
                        this.abort = function() {
                            return this.abortController.abort(),
                            this.abortController = new AbortController,
                            this
                        }
                    }
                }
                ;
                const c2 = new mS;
                var Ar = class {
                    constructor(e) {
                        this.manager = e !== void 0 ? e : c2,
                        this.crossOrigin = "anonymous",
                        this.withCredentials = !1,
                        this.path = "",
                        this.resourcePath = "",
                        this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(e, t) {
                        const n = this;
                        return new Promise(function(i, s) {
                            n.load(e, i, t, s)
                        }
                        )
                    }
                    parse() {}
                    setCrossOrigin(e) {
                        return this.crossOrigin = e,
                        this
                    }
                    setWithCredentials(e) {
                        return this.withCredentials = e,
                        this
                    }
                    setPath(e) {
                        return this.path = e,
                        this
                    }
                    setResourcePath(e) {
                        return this.resourcePath = e,
                        this
                    }
                    setRequestHeader(e) {
                        return this.requestHeader = e,
                        this
                    }
                    abort() {
                        return this
                    }
                }
                ;
                Ar.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                const ou = {};
                var hI = class extends Error {
                    constructor(e, t) {
                        super(e),
                        this.response = t
                    }
                }
                  , lu = class extends Ar {
                    constructor(e) {
                        super(e),
                        this.mimeType = "",
                        this.responseType = "",
                        this._abortController = new AbortController
                    }
                    load(e, t, n, i) {
                        e === void 0 && (e = ""),
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const s = uc.get(`file:${e}`);
                        if (s !== void 0)
                            return this.manager.itemStart(e),
                            setTimeout( () => {
                                t && t(s),
                                this.manager.itemEnd(e)
                            }
                            , 0),
                            s;
                        if (ou[e] !== void 0) {
                            ou[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: i
                            });
                            return
                        }
                        ou[e] = [],
                        ou[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        });
                        const a = new Request(e,{
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin",
                            signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
                        })
                          , o = this.mimeType
                          , c = this.responseType;
                        fetch(a).then(u => {
                            if (u.status === 200 || u.status === 0) {
                                if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                                typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0)
                                    return u;
                                const f = ou[e]
                                  , m = u.body.getReader()
                                  , v = u.headers.get("X-File-Size") || u.headers.get("Content-Length")
                                  , y = v ? parseInt(v) : 0
                                  , S = y !== 0;
                                let A = 0;
                                const M = new ReadableStream({
                                    start(x) {
                                        T();
                                        function T() {
                                            m.read().then( ({done: D, value: w}) => {
                                                if (D)
                                                    x.close();
                                                else {
                                                    A += w.byteLength;
                                                    const U = new ProgressEvent("progress",{
                                                        lengthComputable: S,
                                                        loaded: A,
                                                        total: y
                                                    });
                                                    for (let O = 0, L = f.length; O < L; O++) {
                                                        const N = f[O];
                                                        N.onProgress && N.onProgress(U)
                                                    }
                                                    x.enqueue(w),
                                                    T()
                                                }
                                            }
                                            , D => {
                                                x.error(D)
                                            }
                                            )
                                        }
                                    }
                                });
                                return new Response(M)
                            } else
                                throw new hI(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)
                        }
                        ).then(u => {
                            switch (c) {
                            case "arraybuffer":
                                return u.arrayBuffer();
                            case "blob":
                                return u.blob();
                            case "document":
                                return u.text().then(f => new DOMParser().parseFromString(f, o));
                            case "json":
                                return u.json();
                            default:
                                if (o === "")
                                    return u.text();
                                {
                                    const f = /charset="?([^;"\s]*)"?/i.exec(o)
                                      , m = f && f[1] ? f[1].toLowerCase() : void 0
                                      , v = new TextDecoder(m);
                                    return u.arrayBuffer().then(y => v.decode(y))
                                }
                            }
                        }
                        ).then(u => {
                            uc.add(`file:${e}`, u);
                            const f = ou[e];
                            delete ou[e];
                            for (let m = 0, v = f.length; m < v; m++) {
                                const y = f[m];
                                y.onLoad && y.onLoad(u)
                            }
                        }
                        ).catch(u => {
                            const f = ou[e];
                            if (f === void 0)
                                throw this.manager.itemError(e),
                                u;
                            delete ou[e];
                            for (let m = 0, v = f.length; m < v; m++) {
                                const y = f[m];
                                y.onError && y.onError(u)
                            }
                            this.manager.itemError(e)
                        }
                        ).finally( () => {
                            this.manager.itemEnd(e)
                        }
                        ),
                        this.manager.itemStart(e)
                    }
                    setResponseType(e) {
                        return this.responseType = e,
                        this
                    }
                    setMimeType(e) {
                        return this.mimeType = e,
                        this
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                  , fI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , a = new lu(this.manager);
                        a.setPath(this.path),
                        a.setRequestHeader(this.requestHeader),
                        a.setWithCredentials(this.withCredentials),
                        a.load(e, function(o) {
                            try {
                                t(s.parse(JSON.parse(o)))
                            } catch (c) {
                                i ? i(c) : console.error(c),
                                s.manager.itemError(e)
                            }
                        }, n, i)
                    }
                    parse(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const i = Xg.parse(e[n]);
                            t.push(i)
                        }
                        return t
                    }
                }
                  , dI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , a = []
                          , o = new sS
                          , c = new lu(this.manager);
                        c.setPath(this.path),
                        c.setResponseType("arraybuffer"),
                        c.setRequestHeader(this.requestHeader),
                        c.setWithCredentials(s.withCredentials);
                        let u = 0;
                        function f(m) {
                            c.load(e[m], function(v) {
                                const y = s.parse(v, !0);
                                a[m] = {
                                    width: y.width,
                                    height: y.height,
                                    format: y.format,
                                    mipmaps: y.mipmaps
                                },
                                u += 1,
                                u === 6 && (y.mipmapCount === 1 && (o.minFilter = mi),
                                o.image = a,
                                o.format = y.format,
                                o.needsUpdate = !0,
                                t && t(o))
                            }, n, i)
                        }
                        if (Array.isArray(e))
                            for (let m = 0, v = e.length; m < v; ++m)
                                f(m);
                        else
                            c.load(e, function(m) {
                                const v = s.parse(m, !0);
                                if (v.isCubemap) {
                                    const y = v.mipmaps.length / v.mipmapCount;
                                    for (let S = 0; S < y; S++) {
                                        a[S] = {
                                            mipmaps: []
                                        };
                                        for (let A = 0; A < v.mipmapCount; A++)
                                            a[S].mipmaps.push(v.mipmaps[S * v.mipmapCount + A]),
                                            a[S].format = v.format,
                                            a[S].width = v.width,
                                            a[S].height = v.height
                                    }
                                    o.image = a
                                } else
                                    o.image.width = v.width,
                                    o.image.height = v.height,
                                    o.mipmaps = v.mipmaps;
                                v.mipmapCount === 1 && (o.minFilter = mi),
                                o.format = v.format,
                                o.needsUpdate = !0,
                                t && t(o)
                            }, n, i);
                        return o
                    }
                }
                ;
                const qp = new WeakMap;
                var Wg = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const s = this
                          , a = uc.get(`image:${e}`);
                        if (a !== void 0) {
                            if (a.complete === !0)
                                s.manager.itemStart(e),
                                setTimeout(function() {
                                    t && t(a),
                                    s.manager.itemEnd(e)
                                }, 0);
                            else {
                                let m = qp.get(a);
                                m === void 0 && (m = [],
                                qp.set(a, m)),
                                m.push({
                                    onLoad: t,
                                    onError: i
                                })
                            }
                            return a
                        }
                        const o = mg("img");
                        function c() {
                            f(),
                            t && t(this);
                            const m = qp.get(this) || [];
                            for (let v = 0; v < m.length; v++) {
                                const y = m[v];
                                y.onLoad && y.onLoad(this)
                            }
                            qp.delete(this),
                            s.manager.itemEnd(e)
                        }
                        function u(m) {
                            f(),
                            i && i(m),
                            uc.remove(`image:${e}`);
                            const v = qp.get(this) || [];
                            for (let y = 0; y < v.length; y++) {
                                const S = v[y];
                                S.onError && S.onError(m)
                            }
                            qp.delete(this),
                            s.manager.itemError(e),
                            s.manager.itemEnd(e)
                        }
                        function f() {
                            o.removeEventListener("load", c, !1),
                            o.removeEventListener("error", u, !1)
                        }
                        return o.addEventListener("load", c, !1),
                        o.addEventListener("error", u, !1),
                        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin),
                        uc.add(`image:${e}`, o),
                        s.manager.itemStart(e),
                        o.src = e,
                        o
                    }
                }
                  , pI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = new Tg;
                        s.colorSpace = Zt;
                        const a = new Wg(this.manager);
                        a.setCrossOrigin(this.crossOrigin),
                        a.setPath(this.path);
                        let o = 0;
                        function c(u) {
                            a.load(e[u], function(f) {
                                s.images[u] = f,
                                o++,
                                o === 6 && (s.needsUpdate = !0,
                                t && t(s))
                            }, void 0, i)
                        }
                        for (let u = 0; u < e.length; ++u)
                            c(u);
                        return s
                    }
                }
                  , mI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , a = new ul
                          , o = new lu(this.manager);
                        return o.setResponseType("arraybuffer"),
                        o.setRequestHeader(this.requestHeader),
                        o.setPath(this.path),
                        o.setWithCredentials(s.withCredentials),
                        o.load(e, function(c) {
                            let u;
                            try {
                                u = s.parse(c)
                            } catch (f) {
                                if (i !== void 0)
                                    i(f);
                                else {
                                    console.error(f);
                                    return
                                }
                            }
                            u.image !== void 0 ? a.image = u.image : u.data !== void 0 && (a.image.width = u.width,
                            a.image.height = u.height,
                            a.image.data = u.data),
                            a.wrapS = u.wrapS !== void 0 ? u.wrapS : bo,
                            a.wrapT = u.wrapT !== void 0 ? u.wrapT : bo,
                            a.magFilter = u.magFilter !== void 0 ? u.magFilter : mi,
                            a.minFilter = u.minFilter !== void 0 ? u.minFilter : mi,
                            a.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1,
                            u.colorSpace !== void 0 && (a.colorSpace = u.colorSpace),
                            u.flipY !== void 0 && (a.flipY = u.flipY),
                            u.format !== void 0 && (a.format = u.format),
                            u.type !== void 0 && (a.type = u.type),
                            u.mipmaps !== void 0 && (a.mipmaps = u.mipmaps,
                            a.minFilter = sc),
                            u.mipmapCount === 1 && (a.minFilter = mi),
                            u.generateMipmaps !== void 0 && (a.generateMipmaps = u.generateMipmaps),
                            a.needsUpdate = !0,
                            t && t(a, u)
                        }, n, i),
                        a
                    }
                }
                  , vI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = new Fi
                          , a = new Wg(this.manager);
                        return a.setCrossOrigin(this.crossOrigin),
                        a.setPath(this.path),
                        a.load(e, function(o) {
                            s.image = o,
                            s.needsUpdate = !0,
                            t !== void 0 && t(s)
                        }, n, i),
                        s
                    }
                }
                  , vh = class extends $n {
                    constructor(e, t=1) {
                        super(),
                        this.isLight = !0,
                        this.type = "Light",
                        this.color = new ft(e),
                        this.intensity = t
                    }
                    dispose() {}
                    copy(e, t) {
                        return super.copy(e, t),
                        this.color.copy(e.color),
                        this.intensity = e.intensity,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.color = this.color.getHex(),
                        t.object.intensity = this.intensity,
                        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
                        this.distance !== void 0 && (t.object.distance = this.distance),
                        this.angle !== void 0 && (t.object.angle = this.angle),
                        this.decay !== void 0 && (t.object.decay = this.decay),
                        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
                        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
                        this.target !== void 0 && (t.object.target = this.target.uuid),
                        t
                    }
                }
                  , u2 = class extends vh {
                    constructor(e, t, n) {
                        super(e, n),
                        this.isHemisphereLight = !0,
                        this.type = "HemisphereLight",
                        this.position.copy($n.DEFAULT_UP),
                        this.updateMatrix(),
                        this.groundColor = new ft(t)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.groundColor.copy(e.groundColor),
                        this
                    }
                }
                ;
                const OT = new Xt
                  , h2 = new ae
                  , f2 = new ae;
                var NT = class {
                    constructor(e) {
                        this.camera = e,
                        this.intensity = 1,
                        this.bias = 0,
                        this.normalBias = 0,
                        this.radius = 1,
                        this.blurSamples = 8,
                        this.mapSize = new Oe(512,512),
                        this.mapType = gi,
                        this.map = null,
                        this.mapPass = null,
                        this.matrix = new Xt,
                        this.autoUpdate = !0,
                        this.needsUpdate = !1,
                        this._frustum = new kp,
                        this._frameExtents = new Oe(1,1),
                        this._viewportCount = 1,
                        this._viewports = [new hn(0,0,1,1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(e) {
                        const t = this.camera
                          , n = this.matrix;
                        h2.setFromMatrixPosition(e.matrixWorld),
                        t.position.copy(h2),
                        f2.setFromMatrixPosition(e.target.matrixWorld),
                        t.lookAt(f2),
                        t.updateMatrixWorld(),
                        OT.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(OT, t.coordinateSystem, t.reversedDepth),
                        t.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        n.multiply(OT)
                    }
                    getViewport(e) {
                        return this._viewports[e]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(),
                        this.mapPass && this.mapPass.dispose()
                    }
                    copy(e) {
                        return this.camera = e.camera.clone(),
                        this.intensity = e.intensity,
                        this.bias = e.bias,
                        this.radius = e.radius,
                        this.autoUpdate = e.autoUpdate,
                        this.needsUpdate = e.needsUpdate,
                        this.normalBias = e.normalBias,
                        this.blurSamples = e.blurSamples,
                        this.mapSize.copy(e.mapSize),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        const e = {};
                        return this.intensity !== 1 && (e.intensity = this.intensity),
                        this.bias !== 0 && (e.bias = this.bias),
                        this.normalBias !== 0 && (e.normalBias = this.normalBias),
                        this.radius !== 1 && (e.radius = this.radius),
                        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
                        e.camera = this.camera.toJSON(!1).object,
                        delete e.camera.matrix,
                        e
                    }
                }
                  , gI = class extends NT {
                    constructor() {
                        super(new Hi(50,1,.5,500)),
                        this.isSpotLightShadow = !0,
                        this.focus = 1,
                        this.aspect = 1
                    }
                    updateMatrices(e) {
                        const t = this.camera
                          , n = _p * 2 * e.angle * this.focus
                          , i = this.mapSize.width / this.mapSize.height * this.aspect
                          , s = e.distance || t.far;
                        (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n,
                        t.aspect = i,
                        t.far = s,
                        t.updateProjectionMatrix()),
                        super.updateMatrices(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.focus = e.focus,
                        this
                    }
                }
                  , d2 = class extends vh {
                    constructor(e, t, n=0, i=Math.PI / 3, s=0, a=2) {
                        super(e, t),
                        this.isSpotLight = !0,
                        this.type = "SpotLight",
                        this.position.copy($n.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new $n,
                        this.distance = n,
                        this.angle = i,
                        this.penumbra = s,
                        this.decay = a,
                        this.map = null,
                        this.shadow = new gI
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.distance = e.distance,
                        this.angle = e.angle,
                        this.penumbra = e.penumbra,
                        this.decay = e.decay,
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }
                ;
                const p2 = new Xt
                  , Yg = new ae
                  , BT = new ae;
                var yI = class extends NT {
                    constructor() {
                        super(new Hi(90,1,.5,500)),
                        this.isPointLightShadow = !0,
                        this._frameExtents = new Oe(4,2),
                        this._viewportCount = 6,
                        this._viewports = [new hn(2,1,1,1), new hn(0,1,1,1), new hn(3,1,1,1), new hn(1,1,1,1), new hn(3,0,1,1), new hn(1,0,1,1)],
                        this._cubeDirections = [new ae(1,0,0), new ae(-1,0,0), new ae(0,0,1), new ae(0,0,-1), new ae(0,1,0), new ae(0,-1,0)],
                        this._cubeUps = [new ae(0,1,0), new ae(0,1,0), new ae(0,1,0), new ae(0,1,0), new ae(0,0,1), new ae(0,0,-1)]
                    }
                    updateMatrices(e, t=0) {
                        const n = this.camera
                          , i = this.matrix
                          , s = e.distance || n.far;
                        s !== n.far && (n.far = s,
                        n.updateProjectionMatrix()),
                        Yg.setFromMatrixPosition(e.matrixWorld),
                        n.position.copy(Yg),
                        BT.copy(n.position),
                        BT.add(this._cubeDirections[t]),
                        n.up.copy(this._cubeUps[t]),
                        n.lookAt(BT),
                        n.updateMatrixWorld(),
                        i.makeTranslation(-Yg.x, -Yg.y, -Yg.z),
                        p2.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(p2, n.coordinateSystem, n.reversedDepth)
                    }
                }
                  , m2 = class extends vh {
                    constructor(e, t, n=0, i=2) {
                        super(e, t),
                        this.isPointLight = !0,
                        this.type = "PointLight",
                        this.distance = n,
                        this.decay = i,
                        this.shadow = new yI
                    }
                    get power() {
                        return this.intensity * 4 * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.distance = e.distance,
                        this.decay = e.decay,
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }
                  , qg = class extends Ag {
                    constructor(e=-1, t=1, n=1, i=-1, s=.1, a=2e3) {
                        super(),
                        this.isOrthographicCamera = !0,
                        this.type = "OrthographicCamera",
                        this.zoom = 1,
                        this.view = null,
                        this.left = e,
                        this.right = t,
                        this.top = n,
                        this.bottom = i,
                        this.near = s,
                        this.far = a,
                        this.updateProjectionMatrix()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.left = e.left,
                        this.right = e.right,
                        this.top = e.top,
                        this.bottom = e.bottom,
                        this.near = e.near,
                        this.far = e.far,
                        this.zoom = e.zoom,
                        this.view = e.view === null ? null : Object.assign({}, e.view),
                        this
                    }
                    setViewOffset(e, t, n, i, s, a) {
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = s,
                        this.view.height = a,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const e = (this.right - this.left) / (2 * this.zoom)
                          , t = (this.top - this.bottom) / (2 * this.zoom)
                          , n = (this.right + this.left) / 2
                          , i = (this.top + this.bottom) / 2;
                        let s = n - e
                          , a = n + e
                          , o = i + t
                          , c = i - t;
                        if (this.view !== null && this.view.enabled) {
                            const u = (this.right - this.left) / this.view.fullWidth / this.zoom
                              , f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            s += u * this.view.offsetX,
                            a = s + u * this.view.width,
                            o -= f * this.view.offsetY,
                            c = o - f * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(s, a, o, c, this.near, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.zoom = this.zoom,
                        t.object.left = this.left,
                        t.object.right = this.right,
                        t.object.top = this.top,
                        t.object.bottom = this.bottom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        this.view !== null && (t.object.view = Object.assign({}, this.view)),
                        t
                    }
                }
                  , _I = class extends NT {
                    constructor() {
                        super(new qg(-5,5,5,-5,.5,500)),
                        this.isDirectionalLightShadow = !0
                    }
                }
                  , v2 = class extends vh {
                    constructor(e, t) {
                        super(e, t),
                        this.isDirectionalLight = !0,
                        this.type = "DirectionalLight",
                        this.position.copy($n.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new $n,
                        this.shadow = new _I
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(e) {
                        return super.copy(e),
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }
                  , g2 = class extends vh {
                    constructor(e, t) {
                        super(e, t),
                        this.isAmbientLight = !0,
                        this.type = "AmbientLight"
                    }
                }
                  , y2 = class extends vh {
                    constructor(e, t, n=10, i=10) {
                        super(e, t),
                        this.isRectAreaLight = !0,
                        this.type = "RectAreaLight",
                        this.width = n,
                        this.height = i
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / (this.width * this.height * Math.PI)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.width = e.width,
                        this.height = e.height,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.width = this.width,
                        t.object.height = this.height,
                        t
                    }
                }
                  , _2 = class {
                    constructor() {
                        this.isSphericalHarmonics3 = !0,
                        this.coefficients = [];
                        for (let e = 0; e < 9; e++)
                            this.coefficients.push(new ae)
                    }
                    set(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].copy(e[t]);
                        return this
                    }
                    zero() {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].set(0, 0, 0);
                        return this
                    }
                    getAt(e, t) {
                        const n = e.x
                          , i = e.y
                          , s = e.z
                          , a = this.coefficients;
                        return t.copy(a[0]).multiplyScalar(.282095),
                        t.addScaledVector(a[1], .488603 * i),
                        t.addScaledVector(a[2], .488603 * s),
                        t.addScaledVector(a[3], .488603 * n),
                        t.addScaledVector(a[4], 1.092548 * (n * i)),
                        t.addScaledVector(a[5], 1.092548 * (i * s)),
                        t.addScaledVector(a[6], .315392 * (3 * s * s - 1)),
                        t.addScaledVector(a[7], 1.092548 * (n * s)),
                        t.addScaledVector(a[8], .546274 * (n * n - i * i)),
                        t
                    }
                    getIrradianceAt(e, t) {
                        const n = e.x
                          , i = e.y
                          , s = e.z
                          , a = this.coefficients;
                        return t.copy(a[0]).multiplyScalar(.886227),
                        t.addScaledVector(a[1], 2 * .511664 * i),
                        t.addScaledVector(a[2], 2 * .511664 * s),
                        t.addScaledVector(a[3], 2 * .511664 * n),
                        t.addScaledVector(a[4], 2 * .429043 * n * i),
                        t.addScaledVector(a[5], 2 * .429043 * i * s),
                        t.addScaledVector(a[6], .743125 * s * s - .247708),
                        t.addScaledVector(a[7], 2 * .429043 * n * s),
                        t.addScaledVector(a[8], .429043 * (n * n - i * i)),
                        t
                    }
                    add(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].add(e.coefficients[t]);
                        return this
                    }
                    addScaledSH(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].addScaledVector(e.coefficients[n], t);
                        return this
                    }
                    scale(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].multiplyScalar(e);
                        return this
                    }
                    lerp(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].lerp(e.coefficients[n], t);
                        return this
                    }
                    equals(e) {
                        for (let t = 0; t < 9; t++)
                            if (!this.coefficients[t].equals(e.coefficients[t]))
                                return !1;
                        return !0
                    }
                    copy(e) {
                        return this.set(e.coefficients)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    fromArray(e, t=0) {
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++)
                            n[i].fromArray(e, t + i * 3);
                        return this
                    }
                    toArray(e=[], t=0) {
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++)
                            n[i].toArray(e, t + i * 3);
                        return e
                    }
                    static getBasisAt(e, t) {
                        const n = e.x
                          , i = e.y
                          , s = e.z;
                        t[0] = .282095,
                        t[1] = .488603 * i,
                        t[2] = .488603 * s,
                        t[3] = .488603 * n,
                        t[4] = 1.092548 * n * i,
                        t[5] = 1.092548 * i * s,
                        t[6] = .315392 * (3 * s * s - 1),
                        t[7] = 1.092548 * n * s,
                        t[8] = .546274 * (n * n - i * i)
                    }
                }
                  , S2 = class extends vh {
                    constructor(e=new _2, t=1) {
                        super(void 0, t),
                        this.isLightProbe = !0,
                        this.sh = e
                    }
                    copy(e) {
                        return super.copy(e),
                        this.sh.copy(e.sh),
                        this
                    }
                    fromJSON(e) {
                        return this.intensity = e.intensity,
                        this.sh.fromArray(e.sh),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.sh = this.sh.toArray(),
                        t
                    }
                }
                  , x2 = class PU extends Ar {
                    constructor(t) {
                        super(t),
                        this.textures = {}
                    }
                    load(t, n, i, s) {
                        const a = this
                          , o = new lu(a.manager);
                        o.setPath(a.path),
                        o.setRequestHeader(a.requestHeader),
                        o.setWithCredentials(a.withCredentials),
                        o.load(t, function(c) {
                            try {
                                n(a.parse(JSON.parse(c)))
                            } catch (u) {
                                s ? s(u) : console.error(u),
                                a.manager.itemError(t)
                            }
                        }, i, s)
                    }
                    parse(t) {
                        const n = this.textures;
                        function i(a) {
                            return n[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a),
                            n[a]
                        }
                        const s = this.createMaterialFromType(t.type);
                        if (t.uuid !== void 0 && (s.uuid = t.uuid),
                        t.name !== void 0 && (s.name = t.name),
                        t.color !== void 0 && s.color !== void 0 && s.color.setHex(t.color),
                        t.roughness !== void 0 && (s.roughness = t.roughness),
                        t.metalness !== void 0 && (s.metalness = t.metalness),
                        t.sheen !== void 0 && (s.sheen = t.sheen),
                        t.sheenColor !== void 0 && (s.sheenColor = new ft().setHex(t.sheenColor)),
                        t.sheenRoughness !== void 0 && (s.sheenRoughness = t.sheenRoughness),
                        t.emissive !== void 0 && s.emissive !== void 0 && s.emissive.setHex(t.emissive),
                        t.specular !== void 0 && s.specular !== void 0 && s.specular.setHex(t.specular),
                        t.specularIntensity !== void 0 && (s.specularIntensity = t.specularIntensity),
                        t.specularColor !== void 0 && s.specularColor !== void 0 && s.specularColor.setHex(t.specularColor),
                        t.shininess !== void 0 && (s.shininess = t.shininess),
                        t.clearcoat !== void 0 && (s.clearcoat = t.clearcoat),
                        t.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = t.clearcoatRoughness),
                        t.dispersion !== void 0 && (s.dispersion = t.dispersion),
                        t.iridescence !== void 0 && (s.iridescence = t.iridescence),
                        t.iridescenceIOR !== void 0 && (s.iridescenceIOR = t.iridescenceIOR),
                        t.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = t.iridescenceThicknessRange),
                        t.transmission !== void 0 && (s.transmission = t.transmission),
                        t.thickness !== void 0 && (s.thickness = t.thickness),
                        t.attenuationDistance !== void 0 && (s.attenuationDistance = t.attenuationDistance),
                        t.attenuationColor !== void 0 && s.attenuationColor !== void 0 && s.attenuationColor.setHex(t.attenuationColor),
                        t.anisotropy !== void 0 && (s.anisotropy = t.anisotropy),
                        t.anisotropyRotation !== void 0 && (s.anisotropyRotation = t.anisotropyRotation),
                        t.fog !== void 0 && (s.fog = t.fog),
                        t.flatShading !== void 0 && (s.flatShading = t.flatShading),
                        t.blending !== void 0 && (s.blending = t.blending),
                        t.combine !== void 0 && (s.combine = t.combine),
                        t.side !== void 0 && (s.side = t.side),
                        t.shadowSide !== void 0 && (s.shadowSide = t.shadowSide),
                        t.opacity !== void 0 && (s.opacity = t.opacity),
                        t.transparent !== void 0 && (s.transparent = t.transparent),
                        t.alphaTest !== void 0 && (s.alphaTest = t.alphaTest),
                        t.alphaHash !== void 0 && (s.alphaHash = t.alphaHash),
                        t.depthFunc !== void 0 && (s.depthFunc = t.depthFunc),
                        t.depthTest !== void 0 && (s.depthTest = t.depthTest),
                        t.depthWrite !== void 0 && (s.depthWrite = t.depthWrite),
                        t.colorWrite !== void 0 && (s.colorWrite = t.colorWrite),
                        t.blendSrc !== void 0 && (s.blendSrc = t.blendSrc),
                        t.blendDst !== void 0 && (s.blendDst = t.blendDst),
                        t.blendEquation !== void 0 && (s.blendEquation = t.blendEquation),
                        t.blendSrcAlpha !== void 0 && (s.blendSrcAlpha = t.blendSrcAlpha),
                        t.blendDstAlpha !== void 0 && (s.blendDstAlpha = t.blendDstAlpha),
                        t.blendEquationAlpha !== void 0 && (s.blendEquationAlpha = t.blendEquationAlpha),
                        t.blendColor !== void 0 && s.blendColor !== void 0 && s.blendColor.setHex(t.blendColor),
                        t.blendAlpha !== void 0 && (s.blendAlpha = t.blendAlpha),
                        t.stencilWriteMask !== void 0 && (s.stencilWriteMask = t.stencilWriteMask),
                        t.stencilFunc !== void 0 && (s.stencilFunc = t.stencilFunc),
                        t.stencilRef !== void 0 && (s.stencilRef = t.stencilRef),
                        t.stencilFuncMask !== void 0 && (s.stencilFuncMask = t.stencilFuncMask),
                        t.stencilFail !== void 0 && (s.stencilFail = t.stencilFail),
                        t.stencilZFail !== void 0 && (s.stencilZFail = t.stencilZFail),
                        t.stencilZPass !== void 0 && (s.stencilZPass = t.stencilZPass),
                        t.stencilWrite !== void 0 && (s.stencilWrite = t.stencilWrite),
                        t.wireframe !== void 0 && (s.wireframe = t.wireframe),
                        t.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = t.wireframeLinewidth),
                        t.wireframeLinecap !== void 0 && (s.wireframeLinecap = t.wireframeLinecap),
                        t.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = t.wireframeLinejoin),
                        t.rotation !== void 0 && (s.rotation = t.rotation),
                        t.linewidth !== void 0 && (s.linewidth = t.linewidth),
                        t.dashSize !== void 0 && (s.dashSize = t.dashSize),
                        t.gapSize !== void 0 && (s.gapSize = t.gapSize),
                        t.scale !== void 0 && (s.scale = t.scale),
                        t.polygonOffset !== void 0 && (s.polygonOffset = t.polygonOffset),
                        t.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = t.polygonOffsetFactor),
                        t.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = t.polygonOffsetUnits),
                        t.dithering !== void 0 && (s.dithering = t.dithering),
                        t.alphaToCoverage !== void 0 && (s.alphaToCoverage = t.alphaToCoverage),
                        t.premultipliedAlpha !== void 0 && (s.premultipliedAlpha = t.premultipliedAlpha),
                        t.forceSinglePass !== void 0 && (s.forceSinglePass = t.forceSinglePass),
                        t.visible !== void 0 && (s.visible = t.visible),
                        t.toneMapped !== void 0 && (s.toneMapped = t.toneMapped),
                        t.userData !== void 0 && (s.userData = t.userData),
                        t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? s.vertexColors = t.vertexColors > 0 : s.vertexColors = t.vertexColors),
                        t.uniforms !== void 0)
                            for (const a in t.uniforms) {
                                const o = t.uniforms[a];
                                switch (s.uniforms[a] = {},
                                o.type) {
                                case "t":
                                    s.uniforms[a].value = i(o.value);
                                    break;
                                case "c":
                                    s.uniforms[a].value = new ft().setHex(o.value);
                                    break;
                                case "v2":
                                    s.uniforms[a].value = new Oe().fromArray(o.value);
                                    break;
                                case "v3":
                                    s.uniforms[a].value = new ae().fromArray(o.value);
                                    break;
                                case "v4":
                                    s.uniforms[a].value = new hn().fromArray(o.value);
                                    break;
                                case "m3":
                                    s.uniforms[a].value = new nn().fromArray(o.value);
                                    break;
                                case "m4":
                                    s.uniforms[a].value = new Xt().fromArray(o.value);
                                    break;
                                default:
                                    s.uniforms[a].value = o.value
                                }
                            }
                        if (t.defines !== void 0 && (s.defines = t.defines),
                        t.vertexShader !== void 0 && (s.vertexShader = t.vertexShader),
                        t.fragmentShader !== void 0 && (s.fragmentShader = t.fragmentShader),
                        t.glslVersion !== void 0 && (s.glslVersion = t.glslVersion),
                        t.extensions !== void 0)
                            for (const a in t.extensions)
                                s.extensions[a] = t.extensions[a];
                        if (t.lights !== void 0 && (s.lights = t.lights),
                        t.clipping !== void 0 && (s.clipping = t.clipping),
                        t.size !== void 0 && (s.size = t.size),
                        t.sizeAttenuation !== void 0 && (s.sizeAttenuation = t.sizeAttenuation),
                        t.map !== void 0 && (s.map = i(t.map)),
                        t.matcap !== void 0 && (s.matcap = i(t.matcap)),
                        t.alphaMap !== void 0 && (s.alphaMap = i(t.alphaMap)),
                        t.bumpMap !== void 0 && (s.bumpMap = i(t.bumpMap)),
                        t.bumpScale !== void 0 && (s.bumpScale = t.bumpScale),
                        t.normalMap !== void 0 && (s.normalMap = i(t.normalMap)),
                        t.normalMapType !== void 0 && (s.normalMapType = t.normalMapType),
                        t.normalScale !== void 0) {
                            let a = t.normalScale;
                            Array.isArray(a) === !1 && (a = [a, a]),
                            s.normalScale = new Oe().fromArray(a)
                        }
                        return t.displacementMap !== void 0 && (s.displacementMap = i(t.displacementMap)),
                        t.displacementScale !== void 0 && (s.displacementScale = t.displacementScale),
                        t.displacementBias !== void 0 && (s.displacementBias = t.displacementBias),
                        t.roughnessMap !== void 0 && (s.roughnessMap = i(t.roughnessMap)),
                        t.metalnessMap !== void 0 && (s.metalnessMap = i(t.metalnessMap)),
                        t.emissiveMap !== void 0 && (s.emissiveMap = i(t.emissiveMap)),
                        t.emissiveIntensity !== void 0 && (s.emissiveIntensity = t.emissiveIntensity),
                        t.specularMap !== void 0 && (s.specularMap = i(t.specularMap)),
                        t.specularIntensityMap !== void 0 && (s.specularIntensityMap = i(t.specularIntensityMap)),
                        t.specularColorMap !== void 0 && (s.specularColorMap = i(t.specularColorMap)),
                        t.envMap !== void 0 && (s.envMap = i(t.envMap)),
                        t.envMapRotation !== void 0 && s.envMapRotation.fromArray(t.envMapRotation),
                        t.envMapIntensity !== void 0 && (s.envMapIntensity = t.envMapIntensity),
                        t.reflectivity !== void 0 && (s.reflectivity = t.reflectivity),
                        t.refractionRatio !== void 0 && (s.refractionRatio = t.refractionRatio),
                        t.lightMap !== void 0 && (s.lightMap = i(t.lightMap)),
                        t.lightMapIntensity !== void 0 && (s.lightMapIntensity = t.lightMapIntensity),
                        t.aoMap !== void 0 && (s.aoMap = i(t.aoMap)),
                        t.aoMapIntensity !== void 0 && (s.aoMapIntensity = t.aoMapIntensity),
                        t.gradientMap !== void 0 && (s.gradientMap = i(t.gradientMap)),
                        t.clearcoatMap !== void 0 && (s.clearcoatMap = i(t.clearcoatMap)),
                        t.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)),
                        t.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = i(t.clearcoatNormalMap)),
                        t.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new Oe().fromArray(t.clearcoatNormalScale)),
                        t.iridescenceMap !== void 0 && (s.iridescenceMap = i(t.iridescenceMap)),
                        t.iridescenceThicknessMap !== void 0 && (s.iridescenceThicknessMap = i(t.iridescenceThicknessMap)),
                        t.transmissionMap !== void 0 && (s.transmissionMap = i(t.transmissionMap)),
                        t.thicknessMap !== void 0 && (s.thicknessMap = i(t.thicknessMap)),
                        t.anisotropyMap !== void 0 && (s.anisotropyMap = i(t.anisotropyMap)),
                        t.sheenColorMap !== void 0 && (s.sheenColorMap = i(t.sheenColorMap)),
                        t.sheenRoughnessMap !== void 0 && (s.sheenRoughnessMap = i(t.sheenRoughnessMap)),
                        s
                    }
                    setTextures(t) {
                        return this.textures = t,
                        this
                    }
                    createMaterialFromType(t) {
                        return PU.createMaterialFromType(t)
                    }
                    static createMaterialFromType(t) {
                        return new {
                            ShadowMaterial: Zw,
                            SpriteMaterial: $A,
                            RawShaderMaterial: Kw,
                            ShaderMaterial: kn,
                            PointsMaterial: lT,
                            MeshPhysicalMaterial: Jw,
                            MeshStandardMaterial: Yp,
                            MeshPhongMaterial: $w,
                            MeshToonMaterial: e2,
                            MeshNormalMaterial: CT,
                            MeshLambertMaterial: t2,
                            MeshDepthMaterial: Fg,
                            MeshDistanceMaterial: pS,
                            MeshBasicMaterial: nu,
                            MeshMatcapMaterial: n2,
                            LineDashedMaterial: i2,
                            LineBasicMaterial: ir,
                            Material: qs
                        }[t]
                    }
                }
                  , LT = class {
                    static extractUrlBase(e) {
                        const t = e.lastIndexOf("/");
                        return t === -1 ? "./" : e.slice(0, t + 1)
                    }
                    static resolveURL(e, t) {
                        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                    }
                }
                  , IT = class extends sn {
                    constructor() {
                        super(),
                        this.isInstancedBufferGeometry = !0,
                        this.type = "InstancedBufferGeometry",
                        this.instanceCount = 1 / 0
                    }
                    copy(e) {
                        return super.copy(e),
                        this.instanceCount = e.instanceCount,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.instanceCount = this.instanceCount,
                        e.isInstancedBufferGeometry = !0,
                        e
                    }
                }
                  , A2 = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , a = new lu(s.manager);
                        a.setPath(s.path),
                        a.setRequestHeader(s.requestHeader),
                        a.setWithCredentials(s.withCredentials),
                        a.load(e, function(o) {
                            try {
                                t(s.parse(JSON.parse(o)))
                            } catch (c) {
                                i ? i(c) : console.error(c),
                                s.manager.itemError(e)
                            }
                        }, n, i)
                    }
                    parse(e) {
                        const t = {}
                          , n = {};
                        function i(v, y) {
                            if (t[y] !== void 0)
                                return t[y];
                            const S = v.interleavedBuffers[y]
                              , A = s(v, S.buffer)
                              , M = Sp(S.type, A)
                              , x = new V_(M,S.stride);
                            return x.uuid = S.uuid,
                            t[y] = x,
                            x
                        }
                        function s(v, y) {
                            if (n[y] !== void 0)
                                return n[y];
                            const S = v.arrayBuffers[y]
                              , A = new Uint32Array(S).buffer;
                            return n[y] = A,
                            A
                        }
                        const a = e.isInstancedBufferGeometry ? new IT : new sn
                          , o = e.data.index;
                        if (o !== void 0) {
                            const v = Sp(o.type, o.array);
                            a.setIndex(new Ln(v,1))
                        }
                        const c = e.data.attributes;
                        for (const v in c) {
                            const y = c[v];
                            let S;
                            if (y.isInterleavedBufferAttribute) {
                                const A = i(e.data, y.data);
                                S = new Mg(A,y.itemSize,y.offset,y.normalized)
                            } else {
                                const A = Sp(y.type, y.array);
                                S = new (y.isInstancedBufferAttribute ? Af : Ln)(A,y.itemSize,y.normalized)
                            }
                            y.name !== void 0 && (S.name = y.name),
                            y.usage !== void 0 && S.setUsage(y.usage),
                            a.setAttribute(v, S)
                        }
                        const u = e.data.morphAttributes;
                        if (u)
                            for (const v in u) {
                                const y = u[v]
                                  , S = [];
                                for (let A = 0, M = y.length; A < M; A++) {
                                    const x = y[A];
                                    let T;
                                    if (x.isInterleavedBufferAttribute) {
                                        const D = i(e.data, x.data);
                                        T = new Mg(D,x.itemSize,x.offset,x.normalized)
                                    } else {
                                        const D = Sp(x.type, x.array);
                                        T = new Ln(D,x.itemSize,x.normalized)
                                    }
                                    x.name !== void 0 && (T.name = x.name),
                                    S.push(T)
                                }
                                a.morphAttributes[v] = S
                            }
                        e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
                        const f = e.data.groups || e.data.drawcalls || e.data.offsets;
                        if (f !== void 0)
                            for (let v = 0, y = f.length; v !== y; ++v) {
                                const S = f[v];
                                a.addGroup(S.start, S.count, S.materialIndex)
                            }
                        const m = e.data.boundingSphere;
                        return m !== void 0 && (a.boundingSphere = new Ys().fromJSON(m)),
                        e.name && (a.name = e.name),
                        e.userData && (a.userData = e.userData),
                        a
                    }
                }
                  , SI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , a = this.path === "" ? LT.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || a;
                        const o = new lu(this.manager);
                        o.setPath(this.path),
                        o.setRequestHeader(this.requestHeader),
                        o.setWithCredentials(this.withCredentials),
                        o.load(e, function(c) {
                            let u = null;
                            try {
                                u = JSON.parse(c)
                            } catch (m) {
                                i !== void 0 && i(m),
                                console.error("THREE:ObjectLoader: Can't parse " + e + ".", m.message);
                                return
                            }
                            const f = u.metadata;
                            if (f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry") {
                                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
                                console.error("THREE.ObjectLoader: Can't load " + e);
                                return
                            }
                            s.parse(u, t)
                        }, n, i)
                    }
                    async loadAsync(e, t) {
                        const n = this
                          , i = this.path === "" ? LT.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || i;
                        const s = new lu(this.manager);
                        s.setPath(this.path),
                        s.setRequestHeader(this.requestHeader),
                        s.setWithCredentials(this.withCredentials);
                        const a = await s.loadAsync(e, t)
                          , o = JSON.parse(a)
                          , c = o.metadata;
                        if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
                            throw new Error("THREE.ObjectLoader: Can't load " + e);
                        return await n.parseAsync(o)
                    }
                    parse(e, t) {
                        const n = this.parseAnimations(e.animations)
                          , i = this.parseShapes(e.shapes)
                          , s = this.parseGeometries(e.geometries, i)
                          , a = this.parseImages(e.images, function() {
                            t !== void 0 && t(u)
                        })
                          , o = this.parseTextures(e.textures, a)
                          , c = this.parseMaterials(e.materials, o)
                          , u = this.parseObject(e.object, s, c, o, n)
                          , f = this.parseSkeletons(e.skeletons, u);
                        if (this.bindSkeletons(u, f),
                        this.bindLightTargets(u),
                        t !== void 0) {
                            let m = !1;
                            for (const v in a)
                                if (a[v].data instanceof HTMLImageElement) {
                                    m = !0;
                                    break
                                }
                            m === !1 && t(u)
                        }
                        return u
                    }
                    async parseAsync(e) {
                        const t = this.parseAnimations(e.animations)
                          , n = this.parseShapes(e.shapes)
                          , i = this.parseGeometries(e.geometries, n)
                          , s = await this.parseImagesAsync(e.images)
                          , a = this.parseTextures(e.textures, s)
                          , o = this.parseMaterials(e.materials, a)
                          , c = this.parseObject(e.object, i, o, a, t)
                          , u = this.parseSkeletons(e.skeletons, c);
                        return this.bindSkeletons(c, u),
                        this.bindLightTargets(c),
                        c
                    }
                    parseShapes(e) {
                        const t = {};
                        if (e !== void 0)
                            for (let n = 0, i = e.length; n < i; n++) {
                                const s = new Ef().fromJSON(e[n]);
                                t[s.uuid] = s
                            }
                        return t
                    }
                    parseSkeletons(e, t) {
                        const n = {}
                          , i = {};
                        if (t.traverse(function(s) {
                            s.isBone && (i[s.uuid] = s)
                        }),
                        e !== void 0)
                            for (let s = 0, a = e.length; s < a; s++) {
                                const o = new iw().fromJSON(e[s], i);
                                n[o.uuid] = o
                            }
                        return n
                    }
                    parseGeometries(e, t) {
                        const n = {};
                        if (e !== void 0) {
                            const i = new A2;
                            for (let s = 0, a = e.length; s < a; s++) {
                                let o;
                                const c = e[s];
                                switch (c.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    o = i.parse(c);
                                    break;
                                default:
                                    c.type in Qw ? o = Qw[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)
                                }
                                o.uuid = c.uuid,
                                c.name !== void 0 && (o.name = c.name),
                                c.userData !== void 0 && (o.userData = c.userData),
                                n[c.uuid] = o
                            }
                        }
                        return n
                    }
                    parseMaterials(e, t) {
                        const n = {}
                          , i = {};
                        if (e !== void 0) {
                            const s = new x2;
                            s.setTextures(t);
                            for (let a = 0, o = e.length; a < o; a++) {
                                const c = e[a];
                                n[c.uuid] === void 0 && (n[c.uuid] = s.parse(c)),
                                i[c.uuid] = n[c.uuid]
                            }
                        }
                        return i
                    }
                    parseAnimations(e) {
                        const t = {};
                        if (e !== void 0)
                            for (let n = 0; n < e.length; n++) {
                                const i = e[n]
                                  , s = Xg.parse(i);
                                t[s.uuid] = s
                            }
                        return t
                    }
                    parseImages(e, t) {
                        const n = this
                          , i = {};
                        let s;
                        function a(c) {
                            return n.manager.itemStart(c),
                            s.load(c, function() {
                                n.manager.itemEnd(c)
                            }, void 0, function() {
                                n.manager.itemError(c),
                                n.manager.itemEnd(c)
                            })
                        }
                        function o(c) {
                            if (typeof c == "string") {
                                const u = c
                                  , f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
                                return a(f)
                            } else
                                return c.data ? {
                                    data: Sp(c.type, c.data),
                                    width: c.width,
                                    height: c.height
                                } : null
                        }
                        if (e !== void 0 && e.length > 0) {
                            const c = new mS(t);
                            s = new Wg(c),
                            s.setCrossOrigin(this.crossOrigin);
                            for (let u = 0, f = e.length; u < f; u++) {
                                const m = e[u]
                                  , v = m.url;
                                if (Array.isArray(v)) {
                                    const y = [];
                                    for (let S = 0, A = v.length; S < A; S++) {
                                        const M = v[S]
                                          , x = o(M);
                                        x !== null && (x instanceof HTMLImageElement ? y.push(x) : y.push(new ul(x.data,x.width,x.height)))
                                    }
                                    i[m.uuid] = new rh(y)
                                } else {
                                    const y = o(m.url);
                                    i[m.uuid] = new rh(y)
                                }
                            }
                        }
                        return i
                    }
                    async parseImagesAsync(e) {
                        const t = this
                          , n = {};
                        let i;
                        async function s(a) {
                            if (typeof a == "string") {
                                const o = a
                                  , c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
                                return await i.loadAsync(c)
                            } else
                                return a.data ? {
                                    data: Sp(a.type, a.data),
                                    width: a.width,
                                    height: a.height
                                } : null
                        }
                        if (e !== void 0 && e.length > 0) {
                            i = new Wg(this.manager),
                            i.setCrossOrigin(this.crossOrigin);
                            for (let a = 0, o = e.length; a < o; a++) {
                                const c = e[a]
                                  , u = c.url;
                                if (Array.isArray(u)) {
                                    const f = [];
                                    for (let m = 0, v = u.length; m < v; m++) {
                                        const y = u[m]
                                          , S = await s(y);
                                        S !== null && (S instanceof HTMLImageElement ? f.push(S) : f.push(new ul(S.data,S.width,S.height)))
                                    }
                                    n[c.uuid] = new rh(f)
                                } else {
                                    const f = await s(c.url);
                                    n[c.uuid] = new rh(f)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(e, t) {
                        function n(s, a) {
                            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
                            a[s])
                        }
                        const i = {};
                        if (e !== void 0)
                            for (let s = 0, a = e.length; s < a; s++) {
                                const o = e[s];
                                o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
                                t[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                                const c = t[o.image]
                                  , u = c.data;
                                let f;
                                Array.isArray(u) ? (f = new Tg,
                                u.length === 6 && (f.needsUpdate = !0)) : (u && u.data ? f = new ul : f = new Fi,
                                u && (f.needsUpdate = !0)),
                                f.source = c,
                                f.uuid = o.uuid,
                                o.name !== void 0 && (f.name = o.name),
                                o.mapping !== void 0 && (f.mapping = n(o.mapping, xI)),
                                o.channel !== void 0 && (f.channel = o.channel),
                                o.offset !== void 0 && f.offset.fromArray(o.offset),
                                o.repeat !== void 0 && f.repeat.fromArray(o.repeat),
                                o.center !== void 0 && f.center.fromArray(o.center),
                                o.rotation !== void 0 && (f.rotation = o.rotation),
                                o.wrap !== void 0 && (f.wrapS = n(o.wrap[0], T2),
                                f.wrapT = n(o.wrap[1], T2)),
                                o.format !== void 0 && (f.format = o.format),
                                o.internalFormat !== void 0 && (f.internalFormat = o.internalFormat),
                                o.type !== void 0 && (f.type = o.type),
                                o.colorSpace !== void 0 && (f.colorSpace = o.colorSpace),
                                o.minFilter !== void 0 && (f.minFilter = n(o.minFilter, M2)),
                                o.magFilter !== void 0 && (f.magFilter = n(o.magFilter, M2)),
                                o.anisotropy !== void 0 && (f.anisotropy = o.anisotropy),
                                o.flipY !== void 0 && (f.flipY = o.flipY),
                                o.generateMipmaps !== void 0 && (f.generateMipmaps = o.generateMipmaps),
                                o.premultiplyAlpha !== void 0 && (f.premultiplyAlpha = o.premultiplyAlpha),
                                o.unpackAlignment !== void 0 && (f.unpackAlignment = o.unpackAlignment),
                                o.compareFunction !== void 0 && (f.compareFunction = o.compareFunction),
                                o.userData !== void 0 && (f.userData = o.userData),
                                i[o.uuid] = f
                            }
                        return i
                    }
                    parseObject(e, t, n, i, s) {
                        let a;
                        function o(v) {
                            return t[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", v),
                            t[v]
                        }
                        function c(v) {
                            if (v !== void 0) {
                                if (Array.isArray(v)) {
                                    const y = [];
                                    for (let S = 0, A = v.length; S < A; S++) {
                                        const M = v[S];
                                        n[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M),
                                        y.push(n[M])
                                    }
                                    return y
                                }
                                return n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v),
                                n[v]
                            }
                        }
                        function u(v) {
                            return i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", v),
                            i[v]
                        }
                        let f, m;
                        switch (e.type) {
                        case "Scene":
                            a = new Pp,
                            e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new ft(e.background) : a.background = u(e.background)),
                            e.environment !== void 0 && (a.environment = u(e.environment)),
                            e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new kC(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new VC(e.fog.color,e.fog.density)),
                            e.fog.name !== "" && (a.fog.name = e.fog.name)),
                            e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness),
                            e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity),
                            e.backgroundRotation !== void 0 && a.backgroundRotation.fromArray(e.backgroundRotation),
                            e.environmentIntensity !== void 0 && (a.environmentIntensity = e.environmentIntensity),
                            e.environmentRotation !== void 0 && a.environmentRotation.fromArray(e.environmentRotation);
                            break;
                        case "PerspectiveCamera":
                            a = new Hi(e.fov,e.aspect,e.near,e.far),
                            e.focus !== void 0 && (a.focus = e.focus),
                            e.zoom !== void 0 && (a.zoom = e.zoom),
                            e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
                            e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
                            e.view !== void 0 && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new qg(e.left,e.right,e.top,e.bottom,e.near,e.far),
                            e.zoom !== void 0 && (a.zoom = e.zoom),
                            e.view !== void 0 && (a.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            a = new g2(e.color,e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new v2(e.color,e.intensity),
                            a.target = e.target || "";
                            break;
                        case "PointLight":
                            a = new m2(e.color,e.intensity,e.distance,e.decay);
                            break;
                        case "RectAreaLight":
                            a = new y2(e.color,e.intensity,e.width,e.height);
                            break;
                        case "SpotLight":
                            a = new d2(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
                            a.target = e.target || "";
                            break;
                        case "HemisphereLight":
                            a = new u2(e.color,e.groundColor,e.intensity);
                            break;
                        case "LightProbe":
                            a = new S2().fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            f = o(e.geometry),
                            m = c(e.material),
                            a = new tw(f,m),
                            e.bindMode !== void 0 && (a.bindMode = e.bindMode),
                            e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
                            e.skeleton !== void 0 && (a.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            f = o(e.geometry),
                            m = c(e.material),
                            a = new oi(f,m);
                            break;
                        case "InstancedMesh":
                            f = o(e.geometry),
                            m = c(e.material);
                            const v = e.count
                              , y = e.instanceMatrix
                              , S = e.instanceColor;
                            a = new rw(f,m,v),
                            a.instanceMatrix = new Af(new Float32Array(y.array),16),
                            S !== void 0 && (a.instanceColor = new Af(new Float32Array(S.array),S.itemSize));
                            break;
                        case "BatchedMesh":
                            f = o(e.geometry),
                            m = c(e.material),
                            a = new uw(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,m),
                            a.geometry = f,
                            a.perObjectFrustumCulled = e.perObjectFrustumCulled,
                            a.sortObjects = e.sortObjects,
                            a._drawRanges = e.drawRanges,
                            a._reservedRanges = e.reservedRanges,
                            a._geometryInfo = e.geometryInfo.map(A => {
                                let M = null
                                  , x = null;
                                return A.boundingBox !== void 0 && (M = new Ws().fromJSON(A.boundingBox)),
                                A.boundingSphere !== void 0 && (x = new Ys().fromJSON(A.boundingSphere)),
                                {
                                    ...A,
                                    boundingBox: M,
                                    boundingSphere: x
                                }
                            }
                            ),
                            a._instanceInfo = e.instanceInfo,
                            a._availableInstanceIds = e._availableInstanceIds,
                            a._availableGeometryIds = e._availableGeometryIds,
                            a._nextIndexStart = e.nextIndexStart,
                            a._nextVertexStart = e.nextVertexStart,
                            a._geometryCount = e.geometryCount,
                            a._maxInstanceCount = e.maxInstanceCount,
                            a._maxVertexCount = e.maxVertexCount,
                            a._maxIndexCount = e.maxIndexCount,
                            a._geometryInitialized = e.geometryInitialized,
                            a._matricesTexture = u(e.matricesTexture.uuid),
                            a._indirectTexture = u(e.indirectTexture.uuid),
                            e.colorsTexture !== void 0 && (a._colorsTexture = u(e.colorsTexture.uuid)),
                            e.boundingSphere !== void 0 && (a.boundingSphere = new Ys().fromJSON(e.boundingSphere)),
                            e.boundingBox !== void 0 && (a.boundingBox = new Ws().fromJSON(e.boundingBox));
                            break;
                        case "LOD":
                            a = new QC;
                            break;
                        case "Line":
                            a = new mh(o(e.geometry),c(e.material));
                            break;
                        case "LineLoop":
                            a = new mw(o(e.geometry),c(e.material));
                            break;
                        case "LineSegments":
                            a = new cc(o(e.geometry),c(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new gw(o(e.geometry),c(e.material));
                            break;
                        case "Sprite":
                            a = new qC(c(e.material));
                            break;
                        case "Group":
                            a = new su;
                            break;
                        case "Bone":
                            a = new iT;
                            break;
                        default:
                            a = new $n
                        }
                        if (a.uuid = e.uuid,
                        e.name !== void 0 && (a.name = e.name),
                        e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix),
                        e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate),
                        a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position),
                        e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
                        e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
                        e.scale !== void 0 && a.scale.fromArray(e.scale)),
                        e.up !== void 0 && a.up.fromArray(e.up),
                        e.castShadow !== void 0 && (a.castShadow = e.castShadow),
                        e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
                        e.shadow && (e.shadow.intensity !== void 0 && (a.shadow.intensity = e.shadow.intensity),
                        e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
                        e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias),
                        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
                        e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize),
                        e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))),
                        e.visible !== void 0 && (a.visible = e.visible),
                        e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
                        e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
                        e.userData !== void 0 && (a.userData = e.userData),
                        e.layers !== void 0 && (a.layers.mask = e.layers),
                        e.children !== void 0) {
                            const v = e.children;
                            for (let y = 0; y < v.length; y++)
                                a.add(this.parseObject(v[y], t, n, i, s))
                        }
                        if (e.animations !== void 0) {
                            const v = e.animations;
                            for (let y = 0; y < v.length; y++) {
                                const S = v[y];
                                a.animations.push(s[S])
                            }
                        }
                        if (e.type === "LOD") {
                            e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
                            const v = e.levels;
                            for (let y = 0; y < v.length; y++) {
                                const S = v[y]
                                  , A = a.getObjectByProperty("uuid", S.object);
                                A !== void 0 && a.addLevel(A, S.distance, S.hysteresis)
                            }
                        }
                        return a
                    }
                    bindSkeletons(e, t) {
                        Object.keys(t).length !== 0 && e.traverse(function(n) {
                            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                                const i = t[n.skeleton];
                                i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix)
                            }
                        })
                    }
                    bindLightTargets(e) {
                        e.traverse(function(t) {
                            if (t.isDirectionalLight || t.isSpotLight) {
                                const n = t.target
                                  , i = e.getObjectByProperty("uuid", n);
                                i !== void 0 ? t.target = i : t.target = new $n
                            }
                        })
                    }
                }
                ;
                const xI = {
                    UVMapping: Fy,
                    CubeReflectionMapping: Qc,
                    CubeRefractionMapping: ih,
                    EquirectangularReflectionMapping: fp,
                    EquirectangularRefractionMapping: ng,
                    CubeUVReflectionMapping: dp
                }
                  , T2 = {
                    RepeatWrapping: sh,
                    ClampToEdgeWrapping: bo,
                    MirroredRepeatWrapping: ig
                }
                  , M2 = {
                    NearestFilter: ri,
                    NearestMipmapNearestFilter: gA,
                    NearestMipmapLinearFilter: pp,
                    LinearFilter: mi,
                    LinearMipmapNearestFilter: sg,
                    LinearMipmapLinearFilter: sc
                }
                  , PT = new WeakMap;
                var AI = class extends Ar {
                    constructor(e) {
                        super(e),
                        this.isImageBitmapLoader = !0,
                        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                        this.options = {
                            premultiplyAlpha: "none"
                        },
                        this._abortController = new AbortController
                    }
                    setOptions(e) {
                        return this.options = e,
                        this
                    }
                    load(e, t, n, i) {
                        e === void 0 && (e = ""),
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const s = this
                          , a = uc.get(`image-bitmap:${e}`);
                        if (a !== void 0) {
                            if (s.manager.itemStart(e),
                            a.then) {
                                a.then(u => {
                                    if (PT.has(a) === !0)
                                        i && i(PT.get(a)),
                                        s.manager.itemError(e),
                                        s.manager.itemEnd(e);
                                    else
                                        return t && t(u),
                                        s.manager.itemEnd(e),
                                        u
                                }
                                );
                                return
                            }
                            return setTimeout(function() {
                                t && t(a),
                                s.manager.itemEnd(e)
                            }, 0),
                            a
                        }
                        const o = {};
                        o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                        o.headers = this.requestHeader,
                        o.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
                        const c = fetch(e, o).then(function(u) {
                            return u.blob()
                        }).then(function(u) {
                            return createImageBitmap(u, Object.assign(s.options, {
                                colorSpaceConversion: "none"
                            }))
                        }).then(function(u) {
                            return uc.add(`image-bitmap:${e}`, u),
                            t && t(u),
                            s.manager.itemEnd(e),
                            u
                        }).catch(function(u) {
                            i && i(u),
                            PT.set(c, u),
                            uc.remove(`image-bitmap:${e}`),
                            s.manager.itemError(e),
                            s.manager.itemEnd(e)
                        });
                        uc.add(`image-bitmap:${e}`, c),
                        s.manager.itemStart(e)
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                ;
                let vS;
                var zT = class {
                    static getContext() {
                        return vS === void 0 && (vS = new (window.AudioContext || window.webkitAudioContext)),
                        vS
                    }
                    static setContext(e) {
                        vS = e
                    }
                }
                  , TI = class extends Ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , a = new lu(this.manager);
                        a.setResponseType("arraybuffer"),
                        a.setPath(this.path),
                        a.setRequestHeader(this.requestHeader),
                        a.setWithCredentials(this.withCredentials),
                        a.load(e, function(c) {
                            try {
                                const u = c.slice(0);
                                zT.getContext().decodeAudioData(u, function(f) {
                                    t(f)
                                }).catch(o)
                            } catch (u) {
                                o(u)
                            }
                        }, n, i);
                        function o(c) {
                            i ? i(c) : console.error(c),
                            s.manager.itemError(e)
                        }
                    }
                }
                ;
                const b2 = new Xt
                  , E2 = new Xt
                  , Of = new Xt;
                var MI = class {
                    constructor() {
                        this.type = "StereoCamera",
                        this.aspect = 1,
                        this.eyeSep = .064,
                        this.cameraL = new Hi,
                        this.cameraL.layers.enable(1),
                        this.cameraL.matrixAutoUpdate = !1,
                        this.cameraR = new Hi,
                        this.cameraR.layers.enable(2),
                        this.cameraR.matrixAutoUpdate = !1,
                        this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(e) {
                        const t = this._cache;
                        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                            t.focus = e.focus,
                            t.fov = e.fov,
                            t.aspect = e.aspect * this.aspect,
                            t.near = e.near,
                            t.far = e.far,
                            t.zoom = e.zoom,
                            t.eyeSep = this.eyeSep,
                            Of.copy(e.projectionMatrix);
                            const n = t.eyeSep / 2
                              , i = n * t.near / t.focus
                              , s = t.near * Math.tan(yf * t.fov * .5) / t.zoom;
                            let a, o;
                            E2.elements[12] = -n,
                            b2.elements[12] = n,
                            a = -s * t.aspect + i,
                            o = s * t.aspect + i,
                            Of.elements[0] = 2 * t.near / (o - a),
                            Of.elements[8] = (o + a) / (o - a),
                            this.cameraL.projectionMatrix.copy(Of),
                            a = -s * t.aspect - i,
                            o = s * t.aspect - i,
                            Of.elements[0] = 2 * t.near / (o - a),
                            Of.elements[8] = (o + a) / (o - a),
                            this.cameraR.projectionMatrix.copy(Of)
                        }
                        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(E2),
                        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(b2)
                    }
                }
                  , C2 = class extends Hi {
                    constructor(e=[]) {
                        super(),
                        this.isArrayCamera = !0,
                        this.isMultiViewCamera = !1,
                        this.cameras = e
                    }
                }
                  , FT = class {
                    constructor(e=!0) {
                        this.autoStart = e,
                        this.startTime = 0,
                        this.oldTime = 0,
                        this.elapsedTime = 0,
                        this.running = !1
                    }
                    start() {
                        this.startTime = performance.now(),
                        this.oldTime = this.startTime,
                        this.elapsedTime = 0,
                        this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(),
                        this.running = !1,
                        this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(),
                        this.elapsedTime
                    }
                    getDelta() {
                        let e = 0;
                        if (this.autoStart && !this.running)
                            return this.start(),
                            0;
                        if (this.running) {
                            const t = performance.now();
                            e = (t - this.oldTime) / 1e3,
                            this.oldTime = t,
                            this.elapsedTime += e
                        }
                        return e
                    }
                }
                ;
                const Nf = new ae
                  , HT = new ia
                  , bI = new ae
                  , Bf = new ae
                  , Lf = new ae;
                var EI = class extends $n {
                    constructor() {
                        super(),
                        this.type = "AudioListener",
                        this.context = zT.getContext(),
                        this.gain = this.context.createGain(),
                        this.gain.connect(this.context.destination),
                        this.filter = null,
                        this.timeDelta = 0,
                        this._clock = new FT
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return this.filter !== null && (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination),
                        this.gain.connect(this.context.destination),
                        this.filter = null),
                        this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(e) {
                        return this.filter !== null ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                        this.filter = e,
                        this.gain.connect(this.filter),
                        this.filter.connect(this.context.destination),
                        this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e);
                        const t = this.context.listener;
                        if (this.timeDelta = this._clock.getDelta(),
                        this.matrixWorld.decompose(Nf, HT, bI),
                        Bf.set(0, 0, -1).applyQuaternion(HT),
                        Lf.set(0, 1, 0).applyQuaternion(HT),
                        t.positionX) {
                            const n = this.context.currentTime + this.timeDelta;
                            t.positionX.linearRampToValueAtTime(Nf.x, n),
                            t.positionY.linearRampToValueAtTime(Nf.y, n),
                            t.positionZ.linearRampToValueAtTime(Nf.z, n),
                            t.forwardX.linearRampToValueAtTime(Bf.x, n),
                            t.forwardY.linearRampToValueAtTime(Bf.y, n),
                            t.forwardZ.linearRampToValueAtTime(Bf.z, n),
                            t.upX.linearRampToValueAtTime(Lf.x, n),
                            t.upY.linearRampToValueAtTime(Lf.y, n),
                            t.upZ.linearRampToValueAtTime(Lf.z, n)
                        } else
                            t.setPosition(Nf.x, Nf.y, Nf.z),
                            t.setOrientation(Bf.x, Bf.y, Bf.z, Lf.x, Lf.y, Lf.z)
                    }
                }
                  , w2 = class extends $n {
                    constructor(e) {
                        super(),
                        this.type = "Audio",
                        this.listener = e,
                        this.context = e.context,
                        this.gain = this.context.createGain(),
                        this.gain.connect(e.getInput()),
                        this.autoplay = !1,
                        this.buffer = null,
                        this.detune = 0,
                        this.loop = !1,
                        this.loopStart = 0,
                        this.loopEnd = 0,
                        this.offset = 0,
                        this.duration = void 0,
                        this.playbackRate = 1,
                        this.isPlaying = !1,
                        this.hasPlaybackControl = !0,
                        this.source = null,
                        this.sourceType = "empty",
                        this._startedAt = 0,
                        this._progress = 0,
                        this._connected = !1,
                        this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "audioNode",
                        this.source = e,
                        this.connect(),
                        this
                    }
                    setMediaElementSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaNode",
                        this.source = this.context.createMediaElementSource(e),
                        this.connect(),
                        this
                    }
                    setMediaStreamSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaStreamNode",
                        this.source = this.context.createMediaStreamSource(e),
                        this.connect(),
                        this
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this.sourceType = "buffer",
                        this.autoplay && this.play(),
                        this
                    }
                    play(e=0) {
                        if (this.isPlaying === !0) {
                            console.warn("THREE.Audio: Audio is already playing.");
                            return
                        }
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        this._startedAt = this.context.currentTime + e;
                        const t = this.context.createBufferSource();
                        return t.buffer = this.buffer,
                        t.loop = this.loop,
                        t.loopStart = this.loopStart,
                        t.loopEnd = this.loopEnd,
                        t.onended = this.onEnded.bind(this),
                        t.start(this._startedAt, this._progress + this.offset, this.duration),
                        this.isPlaying = !0,
                        this.source = t,
                        this.setDetune(this.detune),
                        this.setPlaybackRate(this.playbackRate),
                        this.connect()
                    }
                    pause() {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                        this.source.stop(),
                        this.source.onended = null,
                        this.isPlaying = !1),
                        this
                    }
                    stop(e=0) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this._progress = 0,
                        this.source !== null && (this.source.stop(this.context.currentTime + e),
                        this.source.onended = null),
                        this.isPlaying = !1,
                        this
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let e = 1, t = this.filters.length; e < t; e++)
                                this.filters[e - 1].connect(this.filters[e]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else
                            this.source.connect(this.getOutput());
                        return this._connected = !0,
                        this
                    }
                    disconnect() {
                        if (this._connected !== !1) {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (let e = 1, t = this.filters.length; e < t; e++)
                                    this.filters[e - 1].disconnect(this.filters[e]);
                                this.filters[this.filters.length - 1].disconnect(this.getOutput())
                            } else
                                this.source.disconnect(this.getOutput());
                            return this._connected = !1,
                            this
                        }
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(e) {
                        return e || (e = []),
                        this._connected === !0 ? (this.disconnect(),
                        this.filters = e.slice(),
                        this.connect()) : this.filters = e.slice(),
                        this
                    }
                    setDetune(e) {
                        return this.detune = e,
                        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                        this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(e) {
                        return this.setFilters(e ? [e] : [])
                    }
                    setPlaybackRate(e) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this.playbackRate = e,
                        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                        this
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1,
                        this._progress = 0
                    }
                    getLoop() {
                        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                        !1) : this.loop
                    }
                    setLoop(e) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this.loop = e,
                        this.isPlaying === !0 && (this.source.loop = this.loop),
                        this
                    }
                    setLoopStart(e) {
                        return this.loopStart = e,
                        this
                    }
                    setLoopEnd(e) {
                        return this.loopEnd = e,
                        this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
                        this) : (this.autoplay = e.autoplay,
                        this.buffer = e.buffer,
                        this.detune = e.detune,
                        this.loop = e.loop,
                        this.loopStart = e.loopStart,
                        this.loopEnd = e.loopEnd,
                        this.offset = e.offset,
                        this.duration = e.duration,
                        this.playbackRate = e.playbackRate,
                        this.hasPlaybackControl = e.hasPlaybackControl,
                        this.sourceType = e.sourceType,
                        this.filters = e.filters.slice(),
                        this)
                    }
                    clone(e) {
                        return new this.constructor(this.listener).copy(this, e)
                    }
                }
                ;
                const If = new ae
                  , D2 = new ia
                  , CI = new ae
                  , Pf = new ae;
                var wI = class extends w2 {
                    constructor(e) {
                        super(e),
                        this.panner = this.context.createPanner(),
                        this.panner.panningModel = "HRTF",
                        this.panner.connect(this.gain)
                    }
                    connect() {
                        return super.connect(),
                        this.panner.connect(this.gain),
                        this
                    }
                    disconnect() {
                        return super.disconnect(),
                        this.panner.disconnect(this.gain),
                        this
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(e) {
                        return this.panner.refDistance = e,
                        this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(e) {
                        return this.panner.rolloffFactor = e,
                        this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(e) {
                        return this.panner.distanceModel = e,
                        this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(e) {
                        return this.panner.maxDistance = e,
                        this
                    }
                    setDirectionalCone(e, t, n) {
                        return this.panner.coneInnerAngle = e,
                        this.panner.coneOuterAngle = t,
                        this.panner.coneOuterGain = n,
                        this
                    }
                    updateMatrixWorld(e) {
                        if (super.updateMatrixWorld(e),
                        this.hasPlaybackControl === !0 && this.isPlaying === !1)
                            return;
                        this.matrixWorld.decompose(If, D2, CI),
                        Pf.set(0, 0, 1).applyQuaternion(D2);
                        const t = this.panner;
                        if (t.positionX) {
                            const n = this.context.currentTime + this.listener.timeDelta;
                            t.positionX.linearRampToValueAtTime(If.x, n),
                            t.positionY.linearRampToValueAtTime(If.y, n),
                            t.positionZ.linearRampToValueAtTime(If.z, n),
                            t.orientationX.linearRampToValueAtTime(Pf.x, n),
                            t.orientationY.linearRampToValueAtTime(Pf.y, n),
                            t.orientationZ.linearRampToValueAtTime(Pf.z, n)
                        } else
                            t.setPosition(If.x, If.y, If.z),
                            t.setOrientation(Pf.x, Pf.y, Pf.z)
                    }
                }
                  , DI = class {
                    constructor(e, t=2048) {
                        this.analyser = e.context.createAnalyser(),
                        this.analyser.fftSize = t,
                        this.data = new Uint8Array(this.analyser.frequencyBinCount),
                        e.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data),
                        this.data
                    }
                    getAverageFrequency() {
                        let e = 0;
                        const t = this.getFrequencyData();
                        for (let n = 0; n < t.length; n++)
                            e += t[n];
                        return e / t.length
                    }
                }
                  , R2 = class {
                    constructor(e, t, n) {
                        this.binding = e,
                        this.valueSize = n;
                        let i, s, a;
                        switch (t) {
                        case "quaternion":
                            i = this._slerp,
                            s = this._slerpAdditive,
                            a = this._setAdditiveIdentityQuaternion,
                            this.buffer = new Float64Array(n * 6),
                            this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            i = this._select,
                            s = this._select,
                            a = this._setAdditiveIdentityOther,
                            this.buffer = new Array(n * 5);
                            break;
                        default:
                            i = this._lerp,
                            s = this._lerpAdditive,
                            a = this._setAdditiveIdentityNumeric,
                            this.buffer = new Float64Array(n * 5)
                        }
                        this._mixBufferRegion = i,
                        this._mixBufferRegionAdditive = s,
                        this._setIdentity = a,
                        this._origIndex = 3,
                        this._addIndex = 4,
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        this.useCount = 0,
                        this.referenceCount = 0
                    }
                    accumulate(e, t) {
                        const n = this.buffer
                          , i = this.valueSize
                          , s = e * i + i;
                        let a = this.cumulativeWeight;
                        if (a === 0) {
                            for (let o = 0; o !== i; ++o)
                                n[s + o] = n[o];
                            a = t
                        } else {
                            a += t;
                            const o = t / a;
                            this._mixBufferRegion(n, s, 0, o, i)
                        }
                        this.cumulativeWeight = a
                    }
                    accumulateAdditive(e) {
                        const t = this.buffer
                          , n = this.valueSize
                          , i = n * this._addIndex;
                        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                        this._mixBufferRegionAdditive(t, i, 0, e, n),
                        this.cumulativeWeightAdditive += e
                    }
                    apply(e) {
                        const t = this.valueSize
                          , n = this.buffer
                          , i = e * t + t
                          , s = this.cumulativeWeight
                          , a = this.cumulativeWeightAdditive
                          , o = this.binding;
                        if (this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        s < 1) {
                            const c = t * this._origIndex;
                            this._mixBufferRegion(n, i, c, 1 - s, t)
                        }
                        a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                        for (let c = t, u = t + t; c !== u; ++c)
                            if (n[c] !== n[c + t]) {
                                o.setValue(n, i);
                                break
                            }
                    }
                    saveOriginalState() {
                        const e = this.binding
                          , t = this.buffer
                          , n = this.valueSize
                          , i = n * this._origIndex;
                        e.getValue(t, i);
                        for (let s = n, a = i; s !== a; ++s)
                            t[s] = t[i + s % n];
                        this._setIdentity(),
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const e = this.valueSize * 3;
                        this.binding.setValue(this.buffer, e)
                    }
                    _setAdditiveIdentityNumeric() {
                        const e = this._addIndex * this.valueSize
                          , t = e + this.valueSize;
                        for (let n = e; n < t; n++)
                            this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(),
                        this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const e = this._origIndex * this.valueSize
                          , t = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++)
                            this.buffer[t + n] = this.buffer[e + n]
                    }
                    _select(e, t, n, i, s) {
                        if (i >= .5)
                            for (let a = 0; a !== s; ++a)
                                e[t + a] = e[n + a]
                    }
                    _slerp(e, t, n, i) {
                        ia.slerpFlat(e, t, e, t, e, n, i)
                    }
                    _slerpAdditive(e, t, n, i, s) {
                        const a = this._workIndex * s;
                        ia.multiplyQuaternionsFlat(e, a, e, t, e, n),
                        ia.slerpFlat(e, t, e, t, e, a, i)
                    }
                    _lerp(e, t, n, i, s) {
                        const a = 1 - i;
                        for (let o = 0; o !== s; ++o) {
                            const c = t + o;
                            e[c] = e[c] * a + e[n + o] * i
                        }
                    }
                    _lerpAdditive(e, t, n, i, s) {
                        for (let a = 0; a !== s; ++a) {
                            const o = t + a;
                            e[o] = e[o] + e[n + a] * i
                        }
                    }
                }
                ;
                const GT = "\\[\\]\\.:\\/"
                  , RI = new RegExp("[" + GT + "]","g")
                  , VT = "[^" + GT + "]"
                  , UI = "[^" + GT.replace("\\.", "") + "]"
                  , OI = /((?:WC+[\/:])*)/.source.replace("WC", VT)
                  , NI = /(WCOD+)?/.source.replace("WCOD", UI)
                  , BI = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", VT)
                  , LI = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", VT)
                  , II = new RegExp("^" + OI + NI + BI + LI + "$")
                  , PI = ["material", "materials", "bones", "map"];
                var zI = class {
                    constructor(e, t, n) {
                        const i = n || vi.parseTrackName(t);
                        this._targetGroup = e,
                        this._bindings = e.subscribe_(t, i)
                    }
                    getValue(e, t) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_
                          , i = this._bindings[n];
                        i !== void 0 && i.getValue(e, t)
                    }
                    setValue(e, t) {
                        const n = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
                            n[i].setValue(e, t)
                    }
                    bind() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].bind()
                    }
                    unbind() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].unbind()
                    }
                }
                  , vi = class Dm {
                    constructor(t, n, i) {
                        this.path = n,
                        this.parsedPath = i || Dm.parseTrackName(n),
                        this.node = Dm.findNode(t, this.parsedPath.nodeName),
                        this.rootNode = t,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                    static create(t, n, i) {
                        return t && t.isAnimationObjectGroup ? new Dm.Composite(t,n,i) : new Dm(t,n,i)
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(RI, "")
                    }
                    static parseTrackName(t) {
                        const n = II.exec(t);
                        if (n === null)
                            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const i = {
                            nodeName: n[2],
                            objectName: n[3],
                            objectIndex: n[4],
                            propertyName: n[5],
                            propertyIndex: n[6]
                        }
                          , s = i.nodeName && i.nodeName.lastIndexOf(".");
                        if (s !== void 0 && s !== -1) {
                            const a = i.nodeName.substring(s + 1);
                            PI.indexOf(a) !== -1 && (i.nodeName = i.nodeName.substring(0, s),
                            i.objectName = a)
                        }
                        if (i.propertyName === null || i.propertyName.length === 0)
                            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return i
                    }
                    static findNode(t, n) {
                        if (n === void 0 || n === "" || n === "." || n === -1 || n === t.name || n === t.uuid)
                            return t;
                        if (t.skeleton) {
                            const i = t.skeleton.getBoneByName(n);
                            if (i !== void 0)
                                return i
                        }
                        if (t.children) {
                            const i = function(a) {
                                for (let o = 0; o < a.length; o++) {
                                    const c = a[o];
                                    if (c.name === n || c.uuid === n)
                                        return c;
                                    const u = i(c.children);
                                    if (u)
                                        return u
                                }
                                return null
                            }
                              , s = i(t.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, n) {
                        t[n] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, a = i.length; s !== a; ++s)
                            t[n++] = i[s]
                    }
                    _getValue_arrayElement(t, n) {
                        t[n] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(t, n) {
                        this.resolvedProperty.toArray(t, n)
                    }
                    _setValue_direct(t, n) {
                        this.targetObject[this.propertyName] = t[n]
                    }
                    _setValue_direct_setNeedsUpdate(t, n) {
                        this.targetObject[this.propertyName] = t[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, n) {
                        this.targetObject[this.propertyName] = t[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, a = i.length; s !== a; ++s)
                            i[s] = t[n++]
                    }
                    _setValue_array_setNeedsUpdate(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, a = i.length; s !== a; ++s)
                            i[s] = t[n++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, a = i.length; s !== a; ++s)
                            i[s] = t[n++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n]
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(t, n) {
                        this.resolvedProperty.fromArray(t, n)
                    }
                    _setValue_fromArray_setNeedsUpdate(t, n) {
                        this.resolvedProperty.fromArray(t, n),
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, n) {
                        this.resolvedProperty.fromArray(t, n),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(t, n) {
                        this.bind(),
                        this.getValue(t, n)
                    }
                    _setValue_unbound(t, n) {
                        this.bind(),
                        this.setValue(t, n)
                    }
                    bind() {
                        let t = this.node;
                        const n = this.parsedPath
                          , i = n.objectName
                          , s = n.propertyName;
                        let a = n.propertyIndex;
                        if (t || (t = Dm.findNode(this.rootNode, n.nodeName),
                        this.node = t),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !t) {
                            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                            return
                        }
                        if (i) {
                            let f = n.objectIndex;
                            switch (i) {
                            case "materials":
                                if (!t.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.materials) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) {
                                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                t = t.skeleton.bones;
                                for (let m = 0; m < t.length; m++)
                                    if (t[m].name === f) {
                                        f = m;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map"in t) {
                                    t = t.map;
                                    break
                                }
                                if (!t.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.map) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                t = t.material.map;
                                break;
                            default:
                                if (t[i] === void 0) {
                                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                t = t[i]
                            }
                            if (f !== void 0) {
                                if (t[f] === void 0) {
                                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    return
                                }
                                t = t[f]
                            }
                        }
                        const o = t[s];
                        if (o === void 0) {
                            const f = n.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + s + " but it wasn't found.", t);
                            return
                        }
                        let c = this.Versioning.None;
                        this.targetObject = t,
                        t.isMaterial === !0 ? c = this.Versioning.NeedsUpdate : t.isObject3D === !0 && (c = this.Versioning.MatrixWorldNeedsUpdate);
                        let u = this.BindingType.Direct;
                        if (a !== void 0) {
                            if (s === "morphTargetInfluences") {
                                if (!t.geometry) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    return
                                }
                                if (!t.geometry.morphAttributes) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                t.morphTargetDictionary[a] !== void 0 && (a = t.morphTargetDictionary[a])
                            }
                            u = this.BindingType.ArrayElement,
                            this.resolvedProperty = o,
                            this.propertyIndex = a
                        } else
                            o.fromArray !== void 0 && o.toArray !== void 0 ? (u = this.BindingType.HasFromToArray,
                            this.resolvedProperty = o) : Array.isArray(o) ? (u = this.BindingType.EntireArray,
                            this.resolvedProperty = o) : this.propertyName = s;
                        this.getValue = this.GetterByBindingType[u],
                        this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                    }
                    unbind() {
                        this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                }
                ;
                vi.Composite = zI,
                vi.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                vi.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                vi.prototype.GetterByBindingType = [vi.prototype._getValue_direct, vi.prototype._getValue_array, vi.prototype._getValue_arrayElement, vi.prototype._getValue_toArray],
                vi.prototype.SetterByBindingTypeAndVersioning = [[vi.prototype._setValue_direct, vi.prototype._setValue_direct_setNeedsUpdate, vi.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [vi.prototype._setValue_array, vi.prototype._setValue_array_setNeedsUpdate, vi.prototype._setValue_array_setMatrixWorldNeedsUpdate], [vi.prototype._setValue_arrayElement, vi.prototype._setValue_arrayElement_setNeedsUpdate, vi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [vi.prototype._setValue_fromArray, vi.prototype._setValue_fromArray_setNeedsUpdate, vi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
                var FI = class {
                    constructor() {
                        this.isAnimationObjectGroup = !0,
                        this.uuid = jr(),
                        this._objects = Array.prototype.slice.call(arguments),
                        this.nCachedObjects_ = 0;
                        const e = {};
                        this._indicesByUUID = e;
                        for (let n = 0, i = arguments.length; n !== i; ++n)
                            e[arguments[n].uuid] = n;
                        this._paths = [],
                        this._parsedPaths = [],
                        this._bindings = [],
                        this._bindingsIndicesByPath = {};
                        const t = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return t._objects.length
                                },
                                get inUse() {
                                    return this.total - t.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return t._bindings.length
                            }
                        }
                    }
                    add() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._paths
                          , i = this._parsedPaths
                          , s = this._bindings
                          , a = s.length;
                        let o, c = e.length, u = this.nCachedObjects_;
                        for (let f = 0, m = arguments.length; f !== m; ++f) {
                            const v = arguments[f]
                              , y = v.uuid;
                            let S = t[y];
                            if (S === void 0) {
                                S = c++,
                                t[y] = S,
                                e.push(v);
                                for (let A = 0, M = a; A !== M; ++A)
                                    s[A].push(new vi(v,n[A],i[A]))
                            } else if (S < u) {
                                o = e[S];
                                const A = --u
                                  , M = e[A];
                                t[M.uuid] = S,
                                e[S] = M,
                                t[y] = A,
                                e[A] = v;
                                for (let x = 0, T = a; x !== T; ++x) {
                                    const D = s[x]
                                      , w = D[A];
                                    let U = D[S];
                                    D[S] = w,
                                    U === void 0 && (U = new vi(v,n[x],i[x])),
                                    D[A] = U
                                }
                            } else
                                e[S] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = u
                    }
                    remove() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , i = n.length;
                        let s = this.nCachedObjects_;
                        for (let a = 0, o = arguments.length; a !== o; ++a) {
                            const c = arguments[a]
                              , u = c.uuid
                              , f = t[u];
                            if (f !== void 0 && f >= s) {
                                const m = s++
                                  , v = e[m];
                                t[v.uuid] = f,
                                e[f] = v,
                                t[u] = m,
                                e[m] = c;
                                for (let y = 0, S = i; y !== S; ++y) {
                                    const A = n[y]
                                      , M = A[m]
                                      , x = A[f];
                                    A[f] = M,
                                    A[m] = x
                                }
                            }
                        }
                        this.nCachedObjects_ = s
                    }
                    uncache() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , i = n.length;
                        let s = this.nCachedObjects_
                          , a = e.length;
                        for (let o = 0, c = arguments.length; o !== c; ++o) {
                            const u = arguments[o]
                              , f = u.uuid
                              , m = t[f];
                            if (m !== void 0)
                                if (delete t[f],
                                m < s) {
                                    const v = --s
                                      , y = e[v]
                                      , S = --a
                                      , A = e[S];
                                    t[y.uuid] = m,
                                    e[m] = y,
                                    t[A.uuid] = v,
                                    e[v] = A,
                                    e.pop();
                                    for (let M = 0, x = i; M !== x; ++M) {
                                        const T = n[M]
                                          , D = T[v]
                                          , w = T[S];
                                        T[m] = D,
                                        T[v] = w,
                                        T.pop()
                                    }
                                } else {
                                    const v = --a
                                      , y = e[v];
                                    v > 0 && (t[y.uuid] = m),
                                    e[m] = y,
                                    e.pop();
                                    for (let S = 0, A = i; S !== A; ++S) {
                                        const M = n[S];
                                        M[m] = M[v],
                                        M.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = s
                    }
                    subscribe_(e, t) {
                        const n = this._bindingsIndicesByPath;
                        let i = n[e];
                        const s = this._bindings;
                        if (i !== void 0)
                            return s[i];
                        const a = this._paths
                          , o = this._parsedPaths
                          , c = this._objects
                          , u = c.length
                          , f = this.nCachedObjects_
                          , m = new Array(u);
                        i = s.length,
                        n[e] = i,
                        a.push(e),
                        o.push(t),
                        s.push(m);
                        for (let v = f, y = c.length; v !== y; ++v) {
                            const S = c[v];
                            m[v] = new vi(S,e,t)
                        }
                        return m
                    }
                    unsubscribe_(e) {
                        const t = this._bindingsIndicesByPath
                          , n = t[e];
                        if (n !== void 0) {
                            const i = this._paths
                              , s = this._parsedPaths
                              , a = this._bindings
                              , o = a.length - 1
                              , c = a[o]
                              , u = e[o];
                            t[u] = n,
                            a[n] = c,
                            a.pop(),
                            s[n] = s[o],
                            s.pop(),
                            i[n] = i[o],
                            i.pop()
                        }
                    }
                }
                  , U2 = class {
                    constructor(e, t, n=null, i=t.blendMode) {
                        this._mixer = e,
                        this._clip = t,
                        this._localRoot = n,
                        this.blendMode = i;
                        const s = t.tracks
                          , a = s.length
                          , o = new Array(a)
                          , c = {
                            endingStart: mf,
                            endingEnd: mf
                        };
                        for (let u = 0; u !== a; ++u) {
                            const f = s[u].createInterpolant(null);
                            o[u] = f,
                            f.settings = c
                        }
                        this._interpolantSettings = c,
                        this._interpolants = o,
                        this._propertyBindings = new Array(a),
                        this._cacheIndex = null,
                        this._byClipCacheIndex = null,
                        this._timeScaleInterpolant = null,
                        this._weightInterpolant = null,
                        this.loop = oC,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.time = 0,
                        this.timeScale = 1,
                        this._effectiveTimeScale = 1,
                        this.weight = 1,
                        this._effectiveWeight = 1,
                        this.repetitions = 1 / 0,
                        this.paused = !1,
                        this.enabled = !0,
                        this.clampWhenFinished = !1,
                        this.zeroSlopeAtStart = !0,
                        this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this),
                        this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this),
                        this.reset()
                    }
                    reset() {
                        return this.paused = !1,
                        this.enabled = !0,
                        this.time = 0,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(e) {
                        return this._startTime = e,
                        this
                    }
                    setLoop(e, t) {
                        return this.loop = e,
                        this.repetitions = t,
                        this
                    }
                    setEffectiveWeight(e) {
                        return this.weight = e,
                        this._effectiveWeight = this.enabled ? e : 0,
                        this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(e) {
                        return this._scheduleFading(e, 0, 1)
                    }
                    fadeOut(e) {
                        return this._scheduleFading(e, 1, 0)
                    }
                    crossFadeFrom(e, t, n=!1) {
                        if (e.fadeOut(t),
                        this.fadeIn(t),
                        n === !0) {
                            const i = this._clip.duration
                              , s = e._clip.duration
                              , a = s / i
                              , o = i / s;
                            e.warp(1, a, t),
                            this.warp(o, 1, t)
                        }
                        return this
                    }
                    crossFadeTo(e, t, n=!1) {
                        return e.crossFadeFrom(this, t, n)
                    }
                    stopFading() {
                        const e = this._weightInterpolant;
                        return e !== null && (this._weightInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    setEffectiveTimeScale(e) {
                        return this.timeScale = e,
                        this._effectiveTimeScale = this.paused ? 0 : e,
                        this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(e) {
                        return this.timeScale = this._clip.duration / e,
                        this.stopWarping()
                    }
                    syncWith(e) {
                        return this.time = e.time,
                        this.timeScale = e.timeScale,
                        this.stopWarping()
                    }
                    halt(e) {
                        return this.warp(this._effectiveTimeScale, 0, e)
                    }
                    warp(e, t, n) {
                        const i = this._mixer
                          , s = i.time
                          , a = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        o === null && (o = i._lendControlInterpolant(),
                        this._timeScaleInterpolant = o);
                        const c = o.parameterPositions
                          , u = o.sampleValues;
                        return c[0] = s,
                        c[1] = s + n,
                        u[0] = e / a,
                        u[1] = t / a,
                        this
                    }
                    stopWarping() {
                        const e = this._timeScaleInterpolant;
                        return e !== null && (this._timeScaleInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(e, t, n, i) {
                        if (!this.enabled) {
                            this._updateWeight(e);
                            return
                        }
                        const s = this._startTime;
                        if (s !== null) {
                            const c = (e - s) * n;
                            c < 0 || n === 0 ? t = 0 : (this._startTime = null,
                            t = n * c)
                        }
                        t *= this._updateTimeScale(e);
                        const a = this._updateTime(t)
                          , o = this._updateWeight(e);
                        if (o > 0) {
                            const c = this._interpolants
                              , u = this._propertyBindings;
                            switch (this.blendMode) {
                            case MA:
                                for (let f = 0, m = c.length; f !== m; ++f)
                                    c[f].evaluate(a),
                                    u[f].accumulateAdditive(o);
                                break;
                            case A_:
                            default:
                                for (let f = 0, m = c.length; f !== m; ++f)
                                    c[f].evaluate(a),
                                    u[f].accumulate(i, o)
                            }
                        }
                    }
                    _updateWeight(e) {
                        let t = 0;
                        if (this.enabled) {
                            t = this.weight;
                            const n = this._weightInterpolant;
                            if (n !== null) {
                                const i = n.evaluate(e)[0];
                                t *= i,
                                e > n.parameterPositions[1] && (this.stopFading(),
                                i === 0 && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = t,
                        t
                    }
                    _updateTimeScale(e) {
                        let t = 0;
                        if (!this.paused) {
                            t = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            if (n !== null) {
                                const i = n.evaluate(e)[0];
                                t *= i,
                                e > n.parameterPositions[1] && (this.stopWarping(),
                                t === 0 ? this.paused = !0 : this.timeScale = t)
                            }
                        }
                        return this._effectiveTimeScale = t,
                        t
                    }
                    _updateTime(e) {
                        const t = this._clip.duration
                          , n = this.loop;
                        let i = this.time + e
                          , s = this._loopCount;
                        const a = n === lC;
                        if (e === 0)
                            return s === -1 ? i : a && (s & 1) === 1 ? t - i : i;
                        if (n === rC) {
                            s === -1 && (this._loopCount = 0,
                            this._setEndings(!0, !0, !1));
                            e: {
                                if (i >= t)
                                    i = t;
                                else if (i < 0)
                                    i = 0;
                                else {
                                    this.time = i;
                                    break e
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: e < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (s === -1 && (e >= 0 ? (s = 0,
                            this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)),
                            i >= t || i < 0) {
                                const o = Math.floor(i / t);
                                i -= t * o,
                                s += Math.abs(o);
                                const c = this.repetitions - s;
                                if (c <= 0)
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    i = e > 0 ? t : 0,
                                    this.time = i,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    });
                                else {
                                    if (c === 1) {
                                        const u = e < 0;
                                        this._setEndings(u, !u, a)
                                    } else
                                        this._setEndings(!1, !1, a);
                                    this._loopCount = s,
                                    this.time = i,
                                    this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: o
                                    })
                                }
                            } else
                                this.time = i;
                            if (a && (s & 1) === 1)
                                return t - i
                        }
                        return i
                    }
                    _setEndings(e, t, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = vf,
                        i.endingEnd = vf) : (e ? i.endingStart = this.zeroSlopeAtStart ? vf : mf : i.endingStart = hg,
                        t ? i.endingEnd = this.zeroSlopeAtEnd ? vf : mf : i.endingEnd = hg)
                    }
                    _scheduleFading(e, t, n) {
                        const i = this._mixer
                          , s = i.time;
                        let a = this._weightInterpolant;
                        a === null && (a = i._lendControlInterpolant(),
                        this._weightInterpolant = a);
                        const o = a.parameterPositions
                          , c = a.sampleValues;
                        return o[0] = s,
                        c[0] = t,
                        o[1] = s + e,
                        c[1] = n,
                        this
                    }
                }
                ;
                const HI = new Float32Array(1);
                var GI = class extends qr {
                    constructor(e) {
                        super(),
                        this._root = e,
                        this._initMemoryManager(),
                        this._accuIndex = 0,
                        this.time = 0,
                        this.timeScale = 1
                    }
                    _bindAction(e, t) {
                        const n = e._localRoot || this._root
                          , i = e._clip.tracks
                          , s = i.length
                          , a = e._propertyBindings
                          , o = e._interpolants
                          , c = n.uuid
                          , u = this._bindingsByRootAndName;
                        let f = u[c];
                        f === void 0 && (f = {},
                        u[c] = f);
                        for (let m = 0; m !== s; ++m) {
                            const v = i[m]
                              , y = v.name;
                            let S = f[y];
                            if (S !== void 0)
                                ++S.referenceCount,
                                a[m] = S;
                            else {
                                if (S = a[m],
                                S !== void 0) {
                                    S._cacheIndex === null && (++S.referenceCount,
                                    this._addInactiveBinding(S, c, y));
                                    continue
                                }
                                const A = t && t._propertyBindings[m].binding.parsedPath;
                                S = new R2(vi.create(n, y, A),v.ValueTypeName,v.getValueSize()),
                                ++S.referenceCount,
                                this._addInactiveBinding(S, c, y),
                                a[m] = S
                            }
                            o[m].resultBuffer = S.buffer
                        }
                    }
                    _activateAction(e) {
                        if (!this._isActiveAction(e)) {
                            if (e._cacheIndex === null) {
                                const n = (e._localRoot || this._root).uuid
                                  , i = e._clip.uuid
                                  , s = this._actionsByClip[i];
                                this._bindAction(e, s && s.knownActions[0]),
                                this._addInactiveAction(e, i, n)
                            }
                            const t = e._propertyBindings;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const s = t[n];
                                s.useCount++ === 0 && (this._lendBinding(s),
                                s.saveOriginalState())
                            }
                            this._lendAction(e)
                        }
                    }
                    _deactivateAction(e) {
                        if (this._isActiveAction(e)) {
                            const t = e._propertyBindings;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const s = t[n];
                                --s.useCount === 0 && (s.restoreOriginalState(),
                                this._takeBackBinding(s))
                            }
                            this._takeBackAction(e)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [],
                        this._nActiveActions = 0,
                        this._actionsByClip = {},
                        this._bindings = [],
                        this._nActiveBindings = 0,
                        this._bindingsByRootAndName = {},
                        this._controlInterpolants = [],
                        this._nActiveControlInterpolants = 0;
                        const e = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return e._actions.length
                                },
                                get inUse() {
                                    return e._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return e._bindings.length
                                },
                                get inUse() {
                                    return e._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return e._controlInterpolants.length
                                },
                                get inUse() {
                                    return e._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(e) {
                        const t = e._cacheIndex;
                        return t !== null && t < this._nActiveActions
                    }
                    _addInactiveAction(e, t, n) {
                        const i = this._actions
                          , s = this._actionsByClip;
                        let a = s[t];
                        if (a === void 0)
                            a = {
                                knownActions: [e],
                                actionByRoot: {}
                            },
                            e._byClipCacheIndex = 0,
                            s[t] = a;
                        else {
                            const o = a.knownActions;
                            e._byClipCacheIndex = o.length,
                            o.push(e)
                        }
                        e._cacheIndex = i.length,
                        i.push(e),
                        a.actionByRoot[n] = e
                    }
                    _removeInactiveAction(e) {
                        const t = this._actions
                          , n = t[t.length - 1]
                          , i = e._cacheIndex;
                        n._cacheIndex = i,
                        t[i] = n,
                        t.pop(),
                        e._cacheIndex = null;
                        const s = e._clip.uuid
                          , a = this._actionsByClip
                          , o = a[s]
                          , c = o.knownActions
                          , u = c[c.length - 1]
                          , f = e._byClipCacheIndex;
                        u._byClipCacheIndex = f,
                        c[f] = u,
                        c.pop(),
                        e._byClipCacheIndex = null;
                        const m = o.actionByRoot
                          , v = (e._localRoot || this._root).uuid;
                        delete m[v],
                        c.length === 0 && delete a[s],
                        this._removeInactiveBindingsForAction(e)
                    }
                    _removeInactiveBindingsForAction(e) {
                        const t = e._propertyBindings;
                        for (let n = 0, i = t.length; n !== i; ++n) {
                            const s = t[n];
                            --s.referenceCount === 0 && this._removeInactiveBinding(s)
                        }
                    }
                    _lendAction(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , i = this._nActiveActions++
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _takeBackAction(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , i = --this._nActiveActions
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _addInactiveBinding(e, t, n) {
                        const i = this._bindingsByRootAndName
                          , s = this._bindings;
                        let a = i[t];
                        a === void 0 && (a = {},
                        i[t] = a),
                        a[n] = e,
                        e._cacheIndex = s.length,
                        s.push(e)
                    }
                    _removeInactiveBinding(e) {
                        const t = this._bindings
                          , n = e.binding
                          , i = n.rootNode.uuid
                          , s = n.path
                          , a = this._bindingsByRootAndName
                          , o = a[i]
                          , c = t[t.length - 1]
                          , u = e._cacheIndex;
                        c._cacheIndex = u,
                        t[u] = c,
                        t.pop(),
                        delete o[s],
                        Object.keys(o).length === 0 && delete a[i]
                    }
                    _lendBinding(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , i = this._nActiveBindings++
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _takeBackBinding(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , i = --this._nActiveBindings
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _lendControlInterpolant() {
                        const e = this._controlInterpolants
                          , t = this._nActiveControlInterpolants++;
                        let n = e[t];
                        return n === void 0 && (n = new RT(new Float32Array(2),new Float32Array(2),1,HI),
                        n.__cacheIndex = t,
                        e[t] = n),
                        n
                    }
                    _takeBackControlInterpolant(e) {
                        const t = this._controlInterpolants
                          , n = e.__cacheIndex
                          , i = --this._nActiveControlInterpolants
                          , s = t[i];
                        e.__cacheIndex = i,
                        t[i] = e,
                        s.__cacheIndex = n,
                        t[n] = s
                    }
                    clipAction(e, t, n) {
                        const i = t || this._root
                          , s = i.uuid;
                        let a = typeof e == "string" ? Xg.findByName(i, e) : e;
                        const o = a !== null ? a.uuid : e
                          , c = this._actionsByClip[o];
                        let u = null;
                        if (n === void 0 && (a !== null ? n = a.blendMode : n = A_),
                        c !== void 0) {
                            const m = c.actionByRoot[s];
                            if (m !== void 0 && m.blendMode === n)
                                return m;
                            u = c.knownActions[0],
                            a === null && (a = u._clip)
                        }
                        if (a === null)
                            return null;
                        const f = new U2(this,a,t,n);
                        return this._bindAction(f, u),
                        this._addInactiveAction(f, o, s),
                        f
                    }
                    existingAction(e, t) {
                        const n = t || this._root
                          , i = n.uuid
                          , s = typeof e == "string" ? Xg.findByName(n, e) : e
                          , a = s ? s.uuid : e
                          , o = this._actionsByClip[a];
                        return o !== void 0 && o.actionByRoot[i] || null
                    }
                    stopAllAction() {
                        const e = this._actions
                          , t = this._nActiveActions;
                        for (let n = t - 1; n >= 0; --n)
                            e[n].stop();
                        return this
                    }
                    update(e) {
                        e *= this.timeScale;
                        const t = this._actions
                          , n = this._nActiveActions
                          , i = this.time += e
                          , s = Math.sign(e)
                          , a = this._accuIndex ^= 1;
                        for (let u = 0; u !== n; ++u)
                            t[u]._update(i, e, s, a);
                        const o = this._bindings
                          , c = this._nActiveBindings;
                        for (let u = 0; u !== c; ++u)
                            o[u].apply(a);
                        return this
                    }
                    setTime(e) {
                        this.time = 0;
                        for (let t = 0; t < this._actions.length; t++)
                            this._actions[t].time = 0;
                        return this.update(e)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(e) {
                        const t = this._actions
                          , n = e.uuid
                          , i = this._actionsByClip
                          , s = i[n];
                        if (s !== void 0) {
                            const a = s.knownActions;
                            for (let o = 0, c = a.length; o !== c; ++o) {
                                const u = a[o];
                                this._deactivateAction(u);
                                const f = u._cacheIndex
                                  , m = t[t.length - 1];
                                u._cacheIndex = null,
                                u._byClipCacheIndex = null,
                                m._cacheIndex = f,
                                t[f] = m,
                                t.pop(),
                                this._removeInactiveBindingsForAction(u)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(e) {
                        const t = e.uuid
                          , n = this._actionsByClip;
                        for (const a in n) {
                            const o = n[a].actionByRoot
                              , c = o[t];
                            c !== void 0 && (this._deactivateAction(c),
                            this._removeInactiveAction(c))
                        }
                        const i = this._bindingsByRootAndName
                          , s = i[t];
                        if (s !== void 0)
                            for (const a in s) {
                                const o = s[a];
                                o.restoreOriginalState(),
                                this._removeInactiveBinding(o)
                            }
                    }
                    uncacheAction(e, t) {
                        const n = this.existingAction(e, t);
                        n !== null && (this._deactivateAction(n),
                        this._removeInactiveAction(n))
                    }
                }
                  , VI = class extends NA {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isRenderTarget3D = !0,
                        this.depth = n,
                        this.texture = new M_(null,e,t,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , ke = class zU {
                    constructor(t) {
                        this.value = t
                    }
                    clone() {
                        return new zU(this.value.clone === void 0 ? this.value : this.value.clone())
                    }
                }
                ;
                let kI = 0;
                var XI = class extends qr {
                    constructor() {
                        super(),
                        this.isUniformsGroup = !0,
                        Object.defineProperty(this, "id", {
                            value: kI++
                        }),
                        this.name = "",
                        this.usage = dg,
                        this.uniforms = []
                    }
                    add(e) {
                        return this.uniforms.push(e),
                        this
                    }
                    remove(e) {
                        const t = this.uniforms.indexOf(e);
                        return t !== -1 && this.uniforms.splice(t, 1),
                        this
                    }
                    setName(e) {
                        return this.name = e,
                        this
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    copy(e) {
                        this.name = e.name,
                        this.usage = e.usage;
                        const t = e.uniforms;
                        this.uniforms.length = 0;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const s = Array.isArray(t[n]) ? t[n] : [t[n]];
                            for (let a = 0; a < s.length; a++)
                                this.uniforms.push(s[a].clone())
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , WI = class extends V_ {
                    constructor(e, t, n=1) {
                        super(e, t),
                        this.isInstancedInterleavedBuffer = !0,
                        this.meshPerAttribute = n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    }
                    clone(e) {
                        const t = super.clone(e);
                        return t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.isInstancedInterleavedBuffer = !0,
                        t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                }
                  , YI = class {
                    constructor(e, t, n, i, s, a=!1) {
                        this.isGLBufferAttribute = !0,
                        this.name = "",
                        this.buffer = e,
                        this.type = t,
                        this.itemSize = n,
                        this.elementSize = i,
                        this.count = s,
                        this.normalized = a,
                        this.version = 0
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this
                    }
                    setType(e, t) {
                        return this.type = e,
                        this.elementSize = t,
                        this
                    }
                    setItemSize(e) {
                        return this.itemSize = e,
                        this
                    }
                    setCount(e) {
                        return this.count = e,
                        this
                    }
                }
                ;
                const O2 = new Xt;
                var kT = class {
                    constructor(e, t, n=0, i=1 / 0) {
                        this.ray = new Ep(e,t),
                        this.near = n,
                        this.far = i,
                        this.camera = null,
                        this.layers = new wp,
                        this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(e, t) {
                        this.ray.set(e, t)
                    }
                    setFromCamera(e, t) {
                        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                    }
                    setFromXRController(e) {
                        return O2.identity().extractRotation(e.matrixWorld),
                        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction.set(0, 0, -1).applyMatrix4(O2),
                        this
                    }
                    intersectObject(e, t=!0, n=[]) {
                        return XT(e, this, n, t),
                        n.sort(N2),
                        n
                    }
                    intersectObjects(e, t=!0, n=[]) {
                        for (let i = 0, s = e.length; i < s; i++)
                            XT(e[i], this, n, t);
                        return n.sort(N2),
                        n
                    }
                }
                ;
                function N2(e, t) {
                    return e.distance - t.distance
                }
                function XT(e, t, n, i) {
                    let s = !0;
                    if (e.layers.test(t.layers) && e.raycast(t, n) === !1 && (s = !1),
                    s === !0 && i === !0) {
                        const a = e.children;
                        for (let o = 0, c = a.length; o < c; o++)
                            XT(a[o], t, n, !0)
                    }
                }
                var qI = class {
                    constructor() {
                        this._previousTime = 0,
                        this._currentTime = 0,
                        this._startTime = performance.now(),
                        this._delta = 0,
                        this._elapsed = 0,
                        this._timescale = 1,
                        this._document = null,
                        this._pageVisibilityHandler = null
                    }
                    connect(e) {
                        this._document = e,
                        e.hidden !== void 0 && (this._pageVisibilityHandler = jI.bind(this),
                        e.addEventListener("visibilitychange", this._pageVisibilityHandler, !1))
                    }
                    disconnect() {
                        this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler),
                        this._pageVisibilityHandler = null),
                        this._document = null
                    }
                    getDelta() {
                        return this._delta / 1e3
                    }
                    getElapsed() {
                        return this._elapsed / 1e3
                    }
                    getTimescale() {
                        return this._timescale
                    }
                    setTimescale(e) {
                        return this._timescale = e,
                        this
                    }
                    reset() {
                        return this._currentTime = performance.now() - this._startTime,
                        this
                    }
                    dispose() {
                        this.disconnect()
                    }
                    update(e) {
                        return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime,
                        this._currentTime = (e !== void 0 ? e : performance.now()) - this._startTime,
                        this._delta = (this._currentTime - this._previousTime) * this._timescale,
                        this._elapsed += this._delta),
                        this
                    }
                }
                ;
                function jI() {
                    this._document.hidden === !1 && this.reset()
                }
                var B2 = class {
                    constructor(e=1, t=0, n=0) {
                        this.radius = e,
                        this.phi = t,
                        this.theta = n
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.phi = t,
                        this.theta = n,
                        this
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.phi = e.phi,
                        this.theta = e.theta,
                        this
                    }
                    makeSafe() {
                        return this.phi = Yt(this.phi, 1e-6, Math.PI - 1e-6),
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + t * t + n * n),
                        this.radius === 0 ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(e, n),
                        this.phi = Math.acos(Yt(t / this.radius, -1, 1))),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , QI = class {
                    constructor(e=1, t=0, n=0) {
                        this.radius = e,
                        this.theta = t,
                        this.y = n
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.theta = t,
                        this.y = n,
                        this
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.theta = e.theta,
                        this.y = e.y,
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + n * n),
                        this.theta = Math.atan2(e, n),
                        this.y = t,
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , ZI = class FU {
                    constructor(t, n, i, s) {
                        FU.prototype.isMatrix2 = !0,
                        this.elements = [1, 0, 0, 1],
                        t !== void 0 && this.set(t, n, i, s)
                    }
                    identity() {
                        return this.set(1, 0, 0, 1),
                        this
                    }
                    fromArray(t, n=0) {
                        for (let i = 0; i < 4; i++)
                            this.elements[i] = t[i + n];
                        return this
                    }
                    set(t, n, i, s) {
                        const a = this.elements;
                        return a[0] = t,
                        a[2] = n,
                        a[1] = i,
                        a[3] = s,
                        this
                    }
                }
                ;
                const L2 = new Oe;
                var KI = class {
                    constructor(e=new Oe(1 / 0,1 / 0), t=new Oe(-1 / 0,-1 / 0)) {
                        this.isBox2 = !0,
                        this.min = e,
                        this.max = t
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = L2.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0,
                        this.max.x = this.max.y = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(e) {
                        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    containsPoint(e) {
                        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                    }
                    getParameter(e, t) {
                        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(e) {
                        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return this.clampPoint(e, L2).distanceTo(e)
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                }
                ;
                const I2 = new ae
                  , gS = new ae
                  , jp = new ae
                  , Qp = new ae
                  , WT = new ae
                  , JI = new ae
                  , $I = new ae;
                var eP = class {
                    constructor(e=new ae, t=new ae) {
                        this.start = e,
                        this.end = t
                    }
                    set(e, t) {
                        return this.start.copy(e),
                        this.end.copy(t),
                        this
                    }
                    copy(e) {
                        return this.start.copy(e.start),
                        this.end.copy(e.end),
                        this
                    }
                    getCenter(e) {
                        return e.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(e) {
                        return e.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(e, t) {
                        return this.delta(t).multiplyScalar(e).add(this.start)
                    }
                    closestPointToPointParameter(e, t) {
                        I2.subVectors(e, this.start),
                        gS.subVectors(this.end, this.start);
                        const n = gS.dot(gS);
                        let i = gS.dot(I2) / n;
                        return t && (i = Yt(i, 0, 1)),
                        i
                    }
                    closestPointToPoint(e, t, n) {
                        const i = this.closestPointToPointParameter(e, t);
                        return this.delta(n).multiplyScalar(i).add(this.start)
                    }
                    distanceSqToLine3(e, t=JI, n=$I) {
                        const i = 10000000000000001e-32;
                        let s, a;
                        const o = this.start
                          , c = e.start
                          , u = this.end
                          , f = e.end;
                        jp.subVectors(u, o),
                        Qp.subVectors(f, c),
                        WT.subVectors(o, c);
                        const m = jp.dot(jp)
                          , v = Qp.dot(Qp)
                          , y = Qp.dot(WT);
                        if (m <= i && v <= i)
                            return t.copy(o),
                            n.copy(c),
                            t.sub(n),
                            t.dot(t);
                        if (m <= i)
                            s = 0,
                            a = y / v,
                            a = Yt(a, 0, 1);
                        else {
                            const S = jp.dot(WT);
                            if (v <= i)
                                a = 0,
                                s = Yt(-S / m, 0, 1);
                            else {
                                const A = jp.dot(Qp)
                                  , M = m * v - A * A;
                                M !== 0 ? s = Yt((A * y - S * v) / M, 0, 1) : s = 0,
                                a = (A * s + y) / v,
                                a < 0 ? (a = 0,
                                s = Yt(-S / m, 0, 1)) : a > 1 && (a = 1,
                                s = Yt((A - S) / m, 0, 1))
                            }
                        }
                        return t.copy(o).add(jp.multiplyScalar(s)),
                        n.copy(c).add(Qp.multiplyScalar(a)),
                        t.sub(n),
                        t.dot(t)
                    }
                    applyMatrix4(e) {
                        return this.start.applyMatrix4(e),
                        this.end.applyMatrix4(e),
                        this
                    }
                    equals(e) {
                        return e.start.equals(this.start) && e.end.equals(this.end)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const P2 = new ae;
                var tP = class extends $n {
                    constructor(e, t) {
                        super(),
                        this.light = e,
                        this.matrixAutoUpdate = !1,
                        this.color = t,
                        this.type = "SpotLightHelper";
                        const n = new sn
                          , i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let a = 0, o = 1, c = 32; a < c; a++,
                        o++) {
                            const u = a / c * Math.PI * 2
                              , f = o / c * Math.PI * 2;
                            i.push(Math.cos(u), Math.sin(u), 1, Math.cos(f), Math.sin(f), 1)
                        }
                        n.setAttribute("position", new Rt(i,3));
                        const s = new ir({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new cc(n,s),
                        this.add(this.cone),
                        this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        this.parent ? (this.parent.updateWorldMatrix(!0),
                        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
                        this.matrixWorld.copy(this.light.matrixWorld);
                        const e = this.light.distance ? this.light.distance : 1e3
                          , t = e * Math.tan(this.light.angle);
                        this.cone.scale.set(t, t, e),
                        P2.setFromMatrixPosition(this.light.target.matrixWorld),
                        this.cone.lookAt(P2),
                        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                ;
                const gh = new ae
                  , yS = new Xt
                  , YT = new Xt;
                var nP = class extends cc {
                    constructor(e) {
                        const t = z2(e)
                          , n = new sn
                          , i = []
                          , s = [];
                        for (let u = 0; u < t.length; u++) {
                            const f = t[u];
                            f.parent && f.parent.isBone && (i.push(0, 0, 0),
                            i.push(0, 0, 0),
                            s.push(0, 0, 0),
                            s.push(0, 0, 0))
                        }
                        n.setAttribute("position", new Rt(i,3)),
                        n.setAttribute("color", new Rt(s,3));
                        const a = new ir({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        });
                        super(n, a),
                        this.isSkeletonHelper = !0,
                        this.type = "SkeletonHelper",
                        this.root = e,
                        this.bones = t,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1;
                        const o = new ft(255)
                          , c = new ft(65280);
                        this.setColors(o, c)
                    }
                    updateMatrixWorld(e) {
                        const t = this.bones
                          , n = this.geometry
                          , i = n.getAttribute("position");
                        YT.copy(this.root.matrixWorld).invert();
                        for (let s = 0, a = 0; s < t.length; s++) {
                            const o = t[s];
                            o.parent && o.parent.isBone && (yS.multiplyMatrices(YT, o.matrixWorld),
                            gh.setFromMatrixPosition(yS),
                            i.setXYZ(a, gh.x, gh.y, gh.z),
                            yS.multiplyMatrices(YT, o.parent.matrixWorld),
                            gh.setFromMatrixPosition(yS),
                            i.setXYZ(a + 1, gh.x, gh.y, gh.z),
                            a += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0,
                        super.updateMatrixWorld(e)
                    }
                    setColors(e, t) {
                        const n = this.geometry.getAttribute("color");
                        for (let i = 0; i < n.count; i += 2)
                            n.setXYZ(i, e.r, e.g, e.b),
                            n.setXYZ(i + 1, t.r, t.g, t.b);
                        return n.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function z2(e) {
                    const t = [];
                    e.isBone === !0 && t.push(e);
                    for (let n = 0; n < e.children.length; n++)
                        t.push(...z2(e.children[n]));
                    return t
                }
                var iP = class extends oi {
                    constructor(e, t, n) {
                        const i = new ET(t,4,2)
                          , s = new nu({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                        super(i, s),
                        this.light = e,
                        this.color = n,
                        this.type = "PointLightHelper",
                        this.matrix = this.light.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                ;
                const sP = new ae
                  , F2 = new ft
                  , H2 = new ft;
                var aP = class extends $n {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "HemisphereLightHelper";
                        const i = new bT(t);
                        i.rotateY(Math.PI * .5),
                        this.material = new nu({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }),
                        this.color === void 0 && (this.material.vertexColors = !0);
                        const s = i.getAttribute("position")
                          , a = new Float32Array(s.count * 3);
                        i.setAttribute("color", new Ln(a,3)),
                        this.add(new oi(i,this.material)),
                        this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                    update() {
                        const e = this.children[0];
                        if (this.color !== void 0)
                            this.material.color.set(this.color);
                        else {
                            const t = e.geometry.getAttribute("color");
                            F2.copy(this.light.color),
                            H2.copy(this.light.groundColor);
                            for (let n = 0, i = t.count; n < i; n++) {
                                const s = n < i / 2 ? F2 : H2;
                                t.setXYZ(n, s.r, s.g, s.b)
                            }
                            t.needsUpdate = !0
                        }
                        this.light.updateWorldMatrix(!0, !1),
                        e.lookAt(sP.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                  , rP = class extends cc {
                    constructor(e=10, t=10, n=4473924, i=8947848) {
                        n = new ft(n),
                        i = new ft(i);
                        const s = t / 2
                          , a = e / t
                          , o = e / 2
                          , c = []
                          , u = [];
                        for (let v = 0, y = 0, S = -o; v <= t; v++,
                        S += a) {
                            c.push(-o, 0, S, o, 0, S),
                            c.push(S, 0, -o, S, 0, o);
                            const A = v === s ? n : i;
                            A.toArray(u, y),
                            y += 3,
                            A.toArray(u, y),
                            y += 3,
                            A.toArray(u, y),
                            y += 3,
                            A.toArray(u, y),
                            y += 3
                        }
                        const f = new sn;
                        f.setAttribute("position", new Rt(c,3)),
                        f.setAttribute("color", new Rt(u,3));
                        const m = new ir({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(f, m),
                        this.type = "GridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , oP = class extends cc {
                    constructor(e=10, t=16, n=8, i=64, s=4473924, a=8947848) {
                        s = new ft(s),
                        a = new ft(a);
                        const o = []
                          , c = [];
                        if (t > 1)
                            for (let m = 0; m < t; m++) {
                                const v = m / t * (Math.PI * 2)
                                  , y = Math.sin(v) * e
                                  , S = Math.cos(v) * e;
                                o.push(0, 0, 0),
                                o.push(y, 0, S);
                                const A = m & 1 ? s : a;
                                c.push(A.r, A.g, A.b),
                                c.push(A.r, A.g, A.b)
                            }
                        for (let m = 0; m < n; m++) {
                            const v = m & 1 ? s : a
                              , y = e - e / n * m;
                            for (let S = 0; S < i; S++) {
                                let A = S / i * (Math.PI * 2)
                                  , M = Math.sin(A) * y
                                  , x = Math.cos(A) * y;
                                o.push(M, 0, x),
                                c.push(v.r, v.g, v.b),
                                A = (S + 1) / i * (Math.PI * 2),
                                M = Math.sin(A) * y,
                                x = Math.cos(A) * y,
                                o.push(M, 0, x),
                                c.push(v.r, v.g, v.b)
                            }
                        }
                        const u = new sn;
                        u.setAttribute("position", new Rt(o,3)),
                        u.setAttribute("color", new Rt(c,3));
                        const f = new ir({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(u, f),
                        this.type = "PolarGridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                const G2 = new ae
                  , _S = new ae
                  , V2 = new ae;
                var lP = class extends $n {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "DirectionalLightHelper",
                        t === void 0 && (t = 1);
                        let i = new sn;
                        i.setAttribute("position", new Rt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
                        const s = new ir({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new mh(i,s),
                        this.add(this.lightPlane),
                        i = new sn,
                        i.setAttribute("position", new Rt([0, 0, 0, 0, 0, 1],3)),
                        this.targetLine = new mh(i,s),
                        this.add(this.targetLine),
                        this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(),
                        this.lightPlane.material.dispose(),
                        this.targetLine.geometry.dispose(),
                        this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        G2.setFromMatrixPosition(this.light.matrixWorld),
                        _S.setFromMatrixPosition(this.light.target.matrixWorld),
                        V2.subVectors(_S, G2),
                        this.lightPlane.lookAt(_S),
                        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                        this.targetLine.lookAt(_S),
                        this.targetLine.scale.z = V2.length()
                    }
                }
                ;
                const SS = new ae
                  , Zi = new Ag;
                var cP = class extends cc {
                    constructor(e) {
                        const t = new sn
                          , n = new ir({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        })
                          , i = []
                          , s = []
                          , a = {};
                        o("n1", "n2"),
                        o("n2", "n4"),
                        o("n4", "n3"),
                        o("n3", "n1"),
                        o("f1", "f2"),
                        o("f2", "f4"),
                        o("f4", "f3"),
                        o("f3", "f1"),
                        o("n1", "f1"),
                        o("n2", "f2"),
                        o("n3", "f3"),
                        o("n4", "f4"),
                        o("p", "n1"),
                        o("p", "n2"),
                        o("p", "n3"),
                        o("p", "n4"),
                        o("u1", "u2"),
                        o("u2", "u3"),
                        o("u3", "u1"),
                        o("c", "t"),
                        o("p", "c"),
                        o("cn1", "cn2"),
                        o("cn3", "cn4"),
                        o("cf1", "cf2"),
                        o("cf3", "cf4");
                        function o(S, A) {
                            c(S),
                            c(A)
                        }
                        function c(S) {
                            i.push(0, 0, 0),
                            s.push(0, 0, 0),
                            a[S] === void 0 && (a[S] = []),
                            a[S].push(i.length / 3 - 1)
                        }
                        t.setAttribute("position", new Rt(i,3)),
                        t.setAttribute("color", new Rt(s,3)),
                        super(t, n),
                        this.type = "CameraHelper",
                        this.camera = e,
                        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.pointMap = a,
                        this.update();
                        const u = new ft(16755200)
                          , f = new ft(16711680)
                          , m = new ft(43775)
                          , v = new ft(16777215)
                          , y = new ft(3355443);
                        this.setColors(u, f, m, v, y)
                    }
                    setColors(e, t, n, i, s) {
                        const a = this.geometry.getAttribute("color");
                        return a.setXYZ(0, e.r, e.g, e.b),
                        a.setXYZ(1, e.r, e.g, e.b),
                        a.setXYZ(2, e.r, e.g, e.b),
                        a.setXYZ(3, e.r, e.g, e.b),
                        a.setXYZ(4, e.r, e.g, e.b),
                        a.setXYZ(5, e.r, e.g, e.b),
                        a.setXYZ(6, e.r, e.g, e.b),
                        a.setXYZ(7, e.r, e.g, e.b),
                        a.setXYZ(8, e.r, e.g, e.b),
                        a.setXYZ(9, e.r, e.g, e.b),
                        a.setXYZ(10, e.r, e.g, e.b),
                        a.setXYZ(11, e.r, e.g, e.b),
                        a.setXYZ(12, e.r, e.g, e.b),
                        a.setXYZ(13, e.r, e.g, e.b),
                        a.setXYZ(14, e.r, e.g, e.b),
                        a.setXYZ(15, e.r, e.g, e.b),
                        a.setXYZ(16, e.r, e.g, e.b),
                        a.setXYZ(17, e.r, e.g, e.b),
                        a.setXYZ(18, e.r, e.g, e.b),
                        a.setXYZ(19, e.r, e.g, e.b),
                        a.setXYZ(20, e.r, e.g, e.b),
                        a.setXYZ(21, e.r, e.g, e.b),
                        a.setXYZ(22, e.r, e.g, e.b),
                        a.setXYZ(23, e.r, e.g, e.b),
                        a.setXYZ(24, t.r, t.g, t.b),
                        a.setXYZ(25, t.r, t.g, t.b),
                        a.setXYZ(26, t.r, t.g, t.b),
                        a.setXYZ(27, t.r, t.g, t.b),
                        a.setXYZ(28, t.r, t.g, t.b),
                        a.setXYZ(29, t.r, t.g, t.b),
                        a.setXYZ(30, t.r, t.g, t.b),
                        a.setXYZ(31, t.r, t.g, t.b),
                        a.setXYZ(32, n.r, n.g, n.b),
                        a.setXYZ(33, n.r, n.g, n.b),
                        a.setXYZ(34, n.r, n.g, n.b),
                        a.setXYZ(35, n.r, n.g, n.b),
                        a.setXYZ(36, n.r, n.g, n.b),
                        a.setXYZ(37, n.r, n.g, n.b),
                        a.setXYZ(38, i.r, i.g, i.b),
                        a.setXYZ(39, i.r, i.g, i.b),
                        a.setXYZ(40, s.r, s.g, s.b),
                        a.setXYZ(41, s.r, s.g, s.b),
                        a.setXYZ(42, s.r, s.g, s.b),
                        a.setXYZ(43, s.r, s.g, s.b),
                        a.setXYZ(44, s.r, s.g, s.b),
                        a.setXYZ(45, s.r, s.g, s.b),
                        a.setXYZ(46, s.r, s.g, s.b),
                        a.setXYZ(47, s.r, s.g, s.b),
                        a.setXYZ(48, s.r, s.g, s.b),
                        a.setXYZ(49, s.r, s.g, s.b),
                        a.needsUpdate = !0,
                        this
                    }
                    update() {
                        const e = this.geometry
                          , t = this.pointMap
                          , n = 1
                          , i = 1;
                        let s, a;
                        if (Zi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                        this.camera.reversedDepth === !0)
                            s = 1,
                            a = 0;
                        else if (this.camera.coordinateSystem === Yr)
                            s = -1,
                            a = 1;
                        else if (this.camera.coordinateSystem === yp)
                            s = 0,
                            a = 1;
                        else
                            throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem);
                        rs("c", t, e, Zi, 0, 0, s),
                        rs("t", t, e, Zi, 0, 0, a),
                        rs("n1", t, e, Zi, -n, -i, s),
                        rs("n2", t, e, Zi, n, -i, s),
                        rs("n3", t, e, Zi, -n, i, s),
                        rs("n4", t, e, Zi, n, i, s),
                        rs("f1", t, e, Zi, -n, -i, a),
                        rs("f2", t, e, Zi, n, -i, a),
                        rs("f3", t, e, Zi, -n, i, a),
                        rs("f4", t, e, Zi, n, i, a),
                        rs("u1", t, e, Zi, n * .7, i * 1.1, s),
                        rs("u2", t, e, Zi, -n * .7, i * 1.1, s),
                        rs("u3", t, e, Zi, 0, i * 2, s),
                        rs("cf1", t, e, Zi, -n, 0, a),
                        rs("cf2", t, e, Zi, n, 0, a),
                        rs("cf3", t, e, Zi, 0, -i, a),
                        rs("cf4", t, e, Zi, 0, i, a),
                        rs("cn1", t, e, Zi, -n, 0, s),
                        rs("cn2", t, e, Zi, n, 0, s),
                        rs("cn3", t, e, Zi, 0, -i, s),
                        rs("cn4", t, e, Zi, 0, i, s),
                        e.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function rs(e, t, n, i, s, a, o) {
                    SS.set(s, a, o).unproject(i);
                    const c = t[e];
                    if (c !== void 0) {
                        const u = n.getAttribute("position");
                        for (let f = 0, m = c.length; f < m; f++)
                            u.setXYZ(c[f], SS.x, SS.y, SS.z)
                    }
                }
                const xS = new Ws;
                var uP = class extends cc {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , i = new Float32Array(24)
                          , s = new sn;
                        s.setIndex(new Ln(n,1)),
                        s.setAttribute("position", new Ln(i,3)),
                        super(s, new ir({
                            color: t,
                            toneMapped: !1
                        })),
                        this.object = e,
                        this.type = "BoxHelper",
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    update() {
                        if (this.object !== void 0 && xS.setFromObject(this.object),
                        xS.isEmpty())
                            return;
                        const e = xS.min
                          , t = xS.max
                          , n = this.geometry.attributes.position
                          , i = n.array;
                        i[0] = t.x,
                        i[1] = t.y,
                        i[2] = t.z,
                        i[3] = e.x,
                        i[4] = t.y,
                        i[5] = t.z,
                        i[6] = e.x,
                        i[7] = e.y,
                        i[8] = t.z,
                        i[9] = t.x,
                        i[10] = e.y,
                        i[11] = t.z,
                        i[12] = t.x,
                        i[13] = t.y,
                        i[14] = e.z,
                        i[15] = e.x,
                        i[16] = t.y,
                        i[17] = e.z,
                        i[18] = e.x,
                        i[19] = e.y,
                        i[20] = e.z,
                        i[21] = t.x,
                        i[22] = e.y,
                        i[23] = e.z,
                        n.needsUpdate = !0,
                        this.geometry.computeBoundingSphere()
                    }
                    setFromObject(e) {
                        return this.object = e,
                        this.update(),
                        this
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.object = e.object,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , hP = class extends cc {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
                          , s = new sn;
                        s.setIndex(new Ln(n,1)),
                        s.setAttribute("position", new Rt(i,3)),
                        super(s, new ir({
                            color: t,
                            toneMapped: !1
                        })),
                        this.box = e,
                        this.type = "Box3Helper",
                        this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(e) {
                        const t = this.box;
                        t.isEmpty() || (t.getCenter(this.position),
                        t.getSize(this.scale),
                        this.scale.multiplyScalar(.5),
                        super.updateMatrixWorld(e))
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , fP = class extends mh {
                    constructor(e, t=1, n=16776960) {
                        const i = n
                          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
                          , a = new sn;
                        a.setAttribute("position", new Rt(s,3)),
                        a.computeBoundingSphere(),
                        super(a, new ir({
                            color: i,
                            toneMapped: !1
                        })),
                        this.type = "PlaneHelper",
                        this.plane = e,
                        this.size = t;
                        const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
                          , c = new sn;
                        c.setAttribute("position", new Rt(o,3)),
                        c.computeBoundingSphere(),
                        this.add(new oi(c,new nu({
                            color: i,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(e) {
                        this.position.set(0, 0, 0),
                        this.scale.set(.5 * this.size, .5 * this.size, 1),
                        this.lookAt(this.plane.normal),
                        this.translateZ(-this.plane.constant),
                        super.updateMatrixWorld(e)
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose(),
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                }
                ;
                const k2 = new ae;
                let AS, qT;
                var dP = class extends $n {
                    constructor(e=new ae(0,0,1), t=new ae(0,0,0), n=1, i=16776960, s=n * .2, a=s * .2) {
                        super(),
                        this.type = "ArrowHelper",
                        AS === void 0 && (AS = new sn,
                        AS.setAttribute("position", new Rt([0, 0, 0, 0, 1, 0],3)),
                        qT = new fT(.5,1,5,1),
                        qT.translate(0, -.5, 0)),
                        this.position.copy(t),
                        this.line = new mh(AS,new ir({
                            color: i,
                            toneMapped: !1
                        })),
                        this.line.matrixAutoUpdate = !1,
                        this.add(this.line),
                        this.cone = new oi(qT,new nu({
                            color: i,
                            toneMapped: !1
                        })),
                        this.cone.matrixAutoUpdate = !1,
                        this.add(this.cone),
                        this.setDirection(e),
                        this.setLength(n, s, a)
                    }
                    setDirection(e) {
                        if (e.y > .99999)
                            this.quaternion.set(0, 0, 0, 1);
                        else if (e.y < -.99999)
                            this.quaternion.set(1, 0, 0, 0);
                        else {
                            k2.set(e.z, 0, -e.x).normalize();
                            const t = Math.acos(e.y);
                            this.quaternion.setFromAxisAngle(k2, t)
                        }
                    }
                    setLength(e, t=e * .2, n=t * .2) {
                        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                        this.line.updateMatrix(),
                        this.cone.scale.set(n, t, n),
                        this.cone.position.y = e,
                        this.cone.updateMatrix()
                    }
                    setColor(e) {
                        this.line.material.color.set(e),
                        this.cone.material.color.set(e)
                    }
                    copy(e) {
                        return super.copy(e, !1),
                        this.line.copy(e.line),
                        this.cone.copy(e.cone),
                        this
                    }
                    dispose() {
                        this.line.geometry.dispose(),
                        this.line.material.dispose(),
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                }
                  , pP = class extends cc {
                    constructor(e=1) {
                        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
                          , n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
                          , i = new sn;
                        i.setAttribute("position", new Rt(t,3)),
                        i.setAttribute("color", new Rt(n,3));
                        const s = new ir({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(i, s),
                        this.type = "AxesHelper"
                    }
                    setColors(e, t, n) {
                        const i = new ft
                          , s = this.geometry.attributes.color.array;
                        return i.set(e),
                        i.toArray(s, 0),
                        i.toArray(s, 3),
                        i.set(t),
                        i.toArray(s, 6),
                        i.toArray(s, 9),
                        i.set(n),
                        i.toArray(s, 12),
                        i.toArray(s, 15),
                        this.geometry.attributes.color.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , mP = class {
                    constructor() {
                        this.type = "ShapePath",
                        this.color = new ft,
                        this.subPaths = [],
                        this.currentPath = null
                    }
                    moveTo(e, t) {
                        return this.currentPath = new hS,
                        this.subPaths.push(this.currentPath),
                        this.currentPath.moveTo(e, t),
                        this
                    }
                    lineTo(e, t) {
                        return this.currentPath.lineTo(e, t),
                        this
                    }
                    quadraticCurveTo(e, t, n, i) {
                        return this.currentPath.quadraticCurveTo(e, t, n, i),
                        this
                    }
                    bezierCurveTo(e, t, n, i, s, a) {
                        return this.currentPath.bezierCurveTo(e, t, n, i, s, a),
                        this
                    }
                    splineThru(e) {
                        return this.currentPath.splineThru(e),
                        this
                    }
                    toShapes(e) {
                        function t(x) {
                            const T = [];
                            for (let D = 0, w = x.length; D < w; D++) {
                                const U = x[D]
                                  , O = new Ef;
                                O.curves = U.curves,
                                T.push(O)
                            }
                            return T
                        }
                        function n(x, T) {
                            const D = T.length;
                            let w = !1;
                            for (let U = D - 1, O = 0; O < D; U = O++) {
                                let L = T[U]
                                  , N = T[O]
                                  , z = N.x - L.x
                                  , I = N.y - L.y;
                                if (Math.abs(I) > Number.EPSILON) {
                                    if (I < 0 && (L = T[O],
                                    z = -z,
                                    N = T[U],
                                    I = -I),
                                    x.y < L.y || x.y > N.y)
                                        continue;
                                    if (x.y === L.y) {
                                        if (x.x === L.x)
                                            return !0
                                    } else {
                                        const B = I * (x.x - L.x) - z * (x.y - L.y);
                                        if (B === 0)
                                            return !0;
                                        if (B < 0)
                                            continue;
                                        w = !w
                                    }
                                } else {
                                    if (x.y !== L.y)
                                        continue;
                                    if (N.x <= x.x && x.x <= L.x || L.x <= x.x && x.x <= N.x)
                                        return !0
                                }
                            }
                            return w
                        }
                        const i = ru.isClockWise
                          , s = this.subPaths;
                        if (s.length === 0)
                            return [];
                        let a, o, c;
                        const u = [];
                        if (s.length === 1)
                            return o = s[0],
                            c = new Ef,
                            c.curves = o.curves,
                            u.push(c),
                            u;
                        let f = !i(s[0].getPoints());
                        f = e ? !f : f;
                        const m = []
                          , v = [];
                        let y = [], S = 0, A;
                        v[S] = void 0,
                        y[S] = [];
                        for (let x = 0, T = s.length; x < T; x++)
                            o = s[x],
                            A = o.getPoints(),
                            a = i(A),
                            a = e ? !a : a,
                            a ? (!f && v[S] && S++,
                            v[S] = {
                                s: new Ef,
                                p: A
                            },
                            v[S].s.curves = o.curves,
                            f && S++,
                            y[S] = []) : y[S].push({
                                h: o,
                                p: A[0]
                            });
                        if (!v[0])
                            return t(s);
                        if (v.length > 1) {
                            let x = !1
                              , T = 0;
                            for (let D = 0, w = v.length; D < w; D++)
                                m[D] = [];
                            for (let D = 0, w = v.length; D < w; D++) {
                                const U = y[D];
                                for (let O = 0; O < U.length; O++) {
                                    const L = U[O];
                                    let N = !0;
                                    for (let z = 0; z < v.length; z++)
                                        n(L.p, v[z].p) && (D !== z && T++,
                                        N ? (N = !1,
                                        m[z].push(L)) : x = !0);
                                    N && m[D].push(L)
                                }
                            }
                            T > 0 && x === !1 && (y = m)
                        }
                        let M;
                        for (let x = 0, T = v.length; x < T; x++) {
                            c = v[x].s,
                            u.push(c),
                            M = y[x];
                            for (let D = 0, w = M.length; D < w; D++)
                                c.holes.push(M[D].h)
                        }
                        return u
                    }
                }
                  , vP = class extends qr {
                    constructor(e, t=null) {
                        super(),
                        this.object = e,
                        this.domElement = t,
                        this.enabled = !0,
                        this.state = -1,
                        this.keys = {},
                        this.mouseButtons = {
                            LEFT: null,
                            MIDDLE: null,
                            RIGHT: null
                        },
                        this.touches = {
                            ONE: null,
                            TWO: null
                        }
                    }
                    connect(e) {
                        if (e === void 0) {
                            console.warn("THREE.Controls: connect() now requires an element.");
                            return
                        }
                        this.domElement !== null && this.disconnect(),
                        this.domElement = e
                    }
                    disconnect() {}
                    dispose() {}
                    update() {}
                }
                ;
                function gP(e, t) {
                    const n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = 1,
                    e.repeat.y = n / t,
                    e.offset.x = 0,
                    e.offset.y = (1 - e.repeat.y) / 2) : (e.repeat.x = t / n,
                    e.repeat.y = 1,
                    e.offset.x = (1 - e.repeat.x) / 2,
                    e.offset.y = 0),
                    e
                }
                function yP(e, t) {
                    const n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = t / n,
                    e.repeat.y = 1,
                    e.offset.x = (1 - e.repeat.x) / 2,
                    e.offset.y = 0) : (e.repeat.x = 1,
                    e.repeat.y = n / t,
                    e.offset.x = 0,
                    e.offset.y = (1 - e.repeat.y) / 2),
                    e
                }
                function _P(e) {
                    return e.repeat.x = 1,
                    e.repeat.y = 1,
                    e.offset.x = 0,
                    e.offset.y = 0,
                    e
                }
                function jT(e, t, n, i) {
                    const s = SP(i);
                    switch (n) {
                    case AA:
                        return e * t;
                    case gp:
                        return e * t / s.components * s.byteLength;
                    case ag:
                        return e * t / s.components * s.byteLength;
                    case ky:
                        return e * t * 2 / s.components * s.byteLength;
                    case Xy:
                        return e * t * 2 / s.components * s.byteLength;
                    case TA:
                        return e * t * 3 / s.components * s.byteLength;
                    case ps:
                        return e * t * 4 / s.components * s.byteLength;
                    case Wy:
                        return e * t * 4 / s.components * s.byteLength;
                    case rg:
                    case og:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case lg:
                    case cg:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case qy:
                    case Qy:
                        return Math.max(e, 16) * Math.max(t, 8) / 4;
                    case Yy:
                    case jy:
                        return Math.max(e, 8) * Math.max(t, 8) / 2;
                    case Zy:
                    case Ky:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case Jy:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case $y:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case e_:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                    case t_:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                    case n_:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                    case i_:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                    case s_:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                    case a_:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                    case r_:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                    case o_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                    case l_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                    case c_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                    case u_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                    case h_:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                    case f_:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                    case d_:
                    case p_:
                    case m_:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                    case v_:
                    case g_:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                    case y_:
                    case __:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                    }
                    throw new Error(`Unable to determine texture byte length for ${n} format.`)
                }
                function SP(e) {
                    switch (e) {
                    case gi:
                    case yA:
                        return {
                            byteLength: 1,
                            components: 1
                        };
                    case mp:
                    case _A:
                    case ff:
                        return {
                            byteLength: 2,
                            components: 1
                        };
                    case Gy:
                    case Vy:
                        return {
                            byteLength: 2,
                            components: 4
                        };
                    case ac:
                    case Hy:
                    case na:
                        return {
                            byteLength: 4,
                            components: 1
                        };
                    case SA:
                    case xA:
                        return {
                            byteLength: 4,
                            components: 3
                        }
                    }
                    throw new Error(`Unknown texture type ${e}.`)
                }
                var xP = class {
                    static contain(e, t) {
                        return gP(e, t)
                    }
                    static cover(e, t) {
                        return yP(e, t)
                    }
                    static fill(e) {
                        return _P(e)
                    }
                    static getByteLength(e, t, n, i) {
                        return jT(e, t, n, i)
                    }
                }
                ;
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                    detail: {
                        revision: jc
                    }
                })),
                typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = jc);
                var AP = TN({
                    ACESFilmicToneMapping: () => mA,
                    AddEquation: () => th,
                    AddOperation: () => JE,
                    AdditiveAnimationBlendMode: () => MA,
                    AdditiveBlending: () => fA,
                    AgXToneMapping: () => iC,
                    AlphaFormat: () => AA,
                    AlwaysCompare: () => vC,
                    AlwaysDepth: () => Jv,
                    AlwaysStencilFunc: () => bA,
                    AmbientLight: () => g2,
                    AnimationAction: () => U2,
                    AnimationClip: () => Xg,
                    AnimationLoader: () => fI,
                    AnimationMixer: () => GI,
                    AnimationObjectGroup: () => FI,
                    AnimationUtils: () => lI,
                    ArcCurve: () => bw,
                    ArrayCamera: () => C2,
                    ArrowHelper: () => dP,
                    AttachedBindMode: () => vA,
                    Audio: () => w2,
                    AudioAnalyser: () => DI,
                    AudioContext: () => zT,
                    AudioListener: () => EI,
                    AudioLoader: () => TI,
                    AxesHelper: () => pP,
                    BackSide: () => Ds,
                    BasicDepthPacking: () => as,
                    BasicShadowMap: () => OE,
                    BatchedMesh: () => uw,
                    Bone: () => iT,
                    BooleanKeyframeTrack: () => Rf,
                    Box2: () => KI,
                    Box3: () => Ws,
                    Box3Helper: () => hP,
                    BoxGeometry: () => dh,
                    BoxHelper: () => uP,
                    BufferAttribute: () => Ln,
                    BufferGeometry: () => sn,
                    BufferGeometryLoader: () => A2,
                    ByteType: () => yA,
                    Cache: () => uc,
                    Camera: () => Ag,
                    CameraHelper: () => cP,
                    CanvasTexture: () => Sw,
                    CapsuleGeometry: () => xw,
                    CatmullRomCurve3: () => Ew,
                    CineonToneMapping: () => tC,
                    CircleGeometry: () => Aw,
                    ClampToEdgeWrapping: () => bo,
                    Clock: () => FT,
                    Color: () => ft,
                    ColorKeyframeTrack: () => UT,
                    ColorManagement: () => Rn,
                    CompressedArrayTexture: () => RL,
                    CompressedCubeTexture: () => UL,
                    CompressedTexture: () => sS,
                    CompressedTextureLoader: () => dI,
                    ConeGeometry: () => fT,
                    ConstantAlphaFactor: () => QE,
                    ConstantColorFactor: () => qE,
                    Controls: () => vP,
                    CubeCamera: () => HC,
                    CubeReflectionMapping: () => Qc,
                    CubeRefractionMapping: () => ih,
                    CubeTexture: () => Tg,
                    CubeTextureLoader: () => pI,
                    CubeUVReflectionMapping: () => dp,
                    CubicBezierCurve: () => yT,
                    CubicBezierCurve3: () => ww,
                    CubicInterpolant: () => r2,
                    CullFaceBack: () => hA,
                    CullFaceFront: () => UE,
                    CullFaceFrontBack: () => FN,
                    CullFaceNone: () => RE,
                    Curve: () => hl,
                    CurvePath: () => Rw,
                    CustomBlending: () => NE,
                    CustomToneMapping: () => nC,
                    CylinderGeometry: () => hT,
                    Cylindrical: () => QI,
                    Data3DTexture: () => M_,
                    DataArrayTexture: () => T_,
                    DataTexture: () => ul,
                    DataTextureLoader: () => mI,
                    DataUtils: () => tL,
                    DecrementStencilOp: () => $N,
                    DecrementWrapStencilOp: () => tB,
                    DefaultLoadingManager: () => c2,
                    DepthFormat: () => vp,
                    DepthStencilFormat: () => pf,
                    DepthTexture: () => Og,
                    DetachedBindMode: () => aC,
                    DirectionalLight: () => v2,
                    DirectionalLightHelper: () => lP,
                    DiscreteInterpolant: () => o2,
                    DodecahedronGeometry: () => Tw,
                    DoubleSide: () => $a,
                    DstAlphaFactor: () => VE,
                    DstColorFactor: () => XE,
                    DynamicCopyUsage: () => vB,
                    DynamicDrawUsage: () => uB,
                    DynamicReadUsage: () => dB,
                    EdgesGeometry: () => Mw,
                    EllipseCurve: () => lS,
                    EqualCompare: () => fC,
                    EqualDepth: () => hf,
                    EqualStencilFunc: () => aB,
                    EquirectangularReflectionMapping: () => fp,
                    EquirectangularRefractionMapping: () => ng,
                    Euler: () => Co,
                    EventDispatcher: () => qr,
                    ExternalTexture: () => uT,
                    ExtrudeGeometry: () => zw,
                    FileLoader: () => lu,
                    Float16BufferAttribute: () => lL,
                    Float32BufferAttribute: () => Rt,
                    FloatType: () => na,
                    Fog: () => kC,
                    FogExp2: () => VC,
                    FramebufferTexture: () => DL,
                    FrontSide: () => ic,
                    Frustum: () => kp,
                    FrustumArray: () => ow,
                    GLBufferAttribute: () => YI,
                    GLSL1: () => yB,
                    GLSL3: () => CA,
                    GreaterCompare: () => dC,
                    GreaterDepth: () => eg,
                    GreaterEqualCompare: () => mC,
                    GreaterEqualDepth: () => $v,
                    GreaterEqualStencilFunc: () => cB,
                    GreaterStencilFunc: () => oB,
                    GridHelper: () => rP,
                    Group: () => su,
                    HalfFloatType: () => ff,
                    HemisphereLight: () => u2,
                    HemisphereLightHelper: () => aP,
                    IcosahedronGeometry: () => Fw,
                    ImageBitmapLoader: () => AI,
                    ImageLoader: () => Wg,
                    ImageUtils: () => MC,
                    IncrementStencilOp: () => JN,
                    IncrementWrapStencilOp: () => eB,
                    InstancedBufferAttribute: () => Af,
                    InstancedBufferGeometry: () => IT,
                    InstancedInterleavedBuffer: () => WI,
                    InstancedMesh: () => rw,
                    Int16BufferAttribute: () => rL,
                    Int32BufferAttribute: () => oL,
                    Int8BufferAttribute: () => iL,
                    IntType: () => Hy,
                    InterleavedBuffer: () => V_,
                    InterleavedBufferAttribute: () => Mg,
                    Interpolant: () => Hg,
                    InterpolateDiscrete: () => ug,
                    InterpolateLinear: () => S_,
                    InterpolateSmooth: () => x_,
                    InterpolationSamplingMode: () => xB,
                    InterpolationSamplingType: () => SB,
                    InvertStencilOp: () => nB,
                    KeepStencilOp: () => gf,
                    KeyframeTrack: () => Do,
                    LOD: () => QC,
                    LatheGeometry: () => Hw,
                    Layers: () => wp,
                    LessCompare: () => hC,
                    LessDepth: () => up,
                    LessEqualCompare: () => EA,
                    LessEqualDepth: () => nh,
                    LessEqualStencilFunc: () => rB,
                    LessStencilFunc: () => sB,
                    Light: () => vh,
                    LightProbe: () => S2,
                    Line: () => mh,
                    Line3: () => eP,
                    LineBasicMaterial: () => ir,
                    LineCurve: () => _T,
                    LineCurve3: () => Dw,
                    LineDashedMaterial: () => i2,
                    LineLoop: () => mw,
                    LineSegments: () => cc,
                    LinearFilter: () => mi,
                    LinearInterpolant: () => RT,
                    LinearMipMapLinearFilter: () => kN,
                    LinearMipMapNearestFilter: () => VN,
                    LinearMipmapLinearFilter: () => sc,
                    LinearMipmapNearestFilter: () => sg,
                    LinearSRGBColorSpace: () => rc,
                    LinearToneMapping: () => $E,
                    LinearTransfer: () => fg,
                    Loader: () => Ar,
                    LoaderUtils: () => LT,
                    LoadingManager: () => mS,
                    LoopOnce: () => rC,
                    LoopPingPong: () => lC,
                    LoopRepeat: () => oC,
                    MOUSE: () => PN,
                    Material: () => qs,
                    MaterialLoader: () => x2,
                    MathUtils: () => zB,
                    Matrix2: () => ZI,
                    Matrix3: () => nn,
                    Matrix4: () => Xt,
                    MaxEquation: () => PE,
                    Mesh: () => oi,
                    MeshBasicMaterial: () => nu,
                    MeshDepthMaterial: () => Fg,
                    MeshDistanceMaterial: () => pS,
                    MeshLambertMaterial: () => t2,
                    MeshMatcapMaterial: () => n2,
                    MeshNormalMaterial: () => CT,
                    MeshPhongMaterial: () => $w,
                    MeshPhysicalMaterial: () => Jw,
                    MeshStandardMaterial: () => Yp,
                    MeshToonMaterial: () => e2,
                    MinEquation: () => IE,
                    MirroredRepeatWrapping: () => ig,
                    MixOperation: () => KE,
                    MultiplyBlending: () => pA,
                    MultiplyOperation: () => tg,
                    NearestFilter: () => ri,
                    NearestMipMapLinearFilter: () => GN,
                    NearestMipMapNearestFilter: () => HN,
                    NearestMipmapLinearFilter: () => pp,
                    NearestMipmapNearestFilter: () => gA,
                    NeutralToneMapping: () => sC,
                    NeverCompare: () => uC,
                    NeverDepth: () => Kv,
                    NeverStencilFunc: () => iB,
                    NoBlending: () => pi,
                    NoColorSpace: () => rl,
                    NoToneMapping: () => al,
                    NormalAnimationBlendMode: () => A_,
                    NormalBlending: () => uf,
                    NotEqualCompare: () => pC,
                    NotEqualDepth: () => hp,
                    NotEqualStencilFunc: () => lB,
                    NumberKeyframeTrack: () => Gg,
                    Object3D: () => $n,
                    ObjectLoader: () => SI,
                    ObjectSpaceNormalMap: () => cC,
                    OctahedronGeometry: () => bT,
                    OneFactor: () => FE,
                    OneMinusConstantAlphaFactor: () => ZE,
                    OneMinusConstantColorFactor: () => jE,
                    OneMinusDstAlphaFactor: () => kE,
                    OneMinusDstColorFactor: () => WE,
                    OneMinusSrcAlphaFactor: () => zy,
                    OneMinusSrcColorFactor: () => GE,
                    OrthographicCamera: () => qg,
                    PCFShadowMap: () => Iy,
                    PCFSoftShadowMap: () => Zv,
                    PMREMGenerator: () => eM,
                    Path: () => hS,
                    PerspectiveCamera: () => Hi,
                    Plane: () => au,
                    PlaneGeometry: () => wf,
                    PlaneHelper: () => fP,
                    PointLight: () => m2,
                    PointLightHelper: () => iP,
                    Points: () => gw,
                    PointsMaterial: () => lT,
                    PolarGridHelper: () => oP,
                    PolyhedronGeometry: () => Xp,
                    PositionalAudio: () => wI,
                    PropertyBinding: () => vi,
                    PropertyMixer: () => R2,
                    QuadraticBezierCurve: () => ST,
                    QuadraticBezierCurve3: () => xT,
                    Quaternion: () => ia,
                    QuaternionKeyframeTrack: () => Vg,
                    QuaternionLinearInterpolant: () => l2,
                    RED_GREEN_RGTC2_Format: () => y_,
                    RED_RGTC1_Format: () => v_,
                    REVISION: () => jc,
                    RGBADepthPacking: () => Eo,
                    RGBAFormat: () => ps,
                    RGBAIntegerFormat: () => Wy,
                    RGBA_ASTC_10x10_Format: () => u_,
                    RGBA_ASTC_10x5_Format: () => o_,
                    RGBA_ASTC_10x6_Format: () => l_,
                    RGBA_ASTC_10x8_Format: () => c_,
                    RGBA_ASTC_12x10_Format: () => h_,
                    RGBA_ASTC_12x12_Format: () => f_,
                    RGBA_ASTC_4x4_Format: () => $y,
                    RGBA_ASTC_5x4_Format: () => e_,
                    RGBA_ASTC_5x5_Format: () => t_,
                    RGBA_ASTC_6x5_Format: () => n_,
                    RGBA_ASTC_6x6_Format: () => i_,
                    RGBA_ASTC_8x5_Format: () => s_,
                    RGBA_ASTC_8x6_Format: () => a_,
                    RGBA_ASTC_8x8_Format: () => r_,
                    RGBA_BPTC_Format: () => d_,
                    RGBA_ETC2_EAC_Format: () => Jy,
                    RGBA_PVRTC_2BPPV1_Format: () => Qy,
                    RGBA_PVRTC_4BPPV1_Format: () => jy,
                    RGBA_S3TC_DXT1_Format: () => og,
                    RGBA_S3TC_DXT3_Format: () => lg,
                    RGBA_S3TC_DXT5_Format: () => cg,
                    RGBDepthPacking: () => jN,
                    RGBFormat: () => TA,
                    RGBIntegerFormat: () => XN,
                    RGB_BPTC_SIGNED_Format: () => p_,
                    RGB_BPTC_UNSIGNED_Format: () => m_,
                    RGB_ETC1_Format: () => Zy,
                    RGB_ETC2_Format: () => Ky,
                    RGB_PVRTC_2BPPV1_Format: () => qy,
                    RGB_PVRTC_4BPPV1_Format: () => Yy,
                    RGB_S3TC_DXT1_Format: () => rg,
                    RGDepthPacking: () => QN,
                    RGFormat: () => ky,
                    RGIntegerFormat: () => Xy,
                    RawShaderMaterial: () => Kw,
                    Ray: () => Ep,
                    Raycaster: () => kT,
                    RectAreaLight: () => y2,
                    RedFormat: () => gp,
                    RedIntegerFormat: () => ag,
                    ReinhardToneMapping: () => eC,
                    RenderTarget: () => NA,
                    RenderTarget3D: () => VI,
                    RepeatWrapping: () => sh,
                    ReplaceStencilOp: () => KN,
                    ReverseSubtractEquation: () => LE,
                    RingGeometry: () => Gw,
                    SIGNED_RED_GREEN_RGTC2_Format: () => __,
                    SIGNED_RED_RGTC1_Format: () => g_,
                    SRGBColorSpace: () => Zt,
                    SRGBTransfer: () => Jn,
                    Scene: () => Pp,
                    ShaderChunk: () => an,
                    ShaderLib: () => fl,
                    ShaderMaterial: () => kn,
                    ShadowMaterial: () => Zw,
                    Shape: () => Ef,
                    ShapeGeometry: () => Vw,
                    ShapePath: () => mP,
                    ShapeUtils: () => ru,
                    ShortType: () => _A,
                    Skeleton: () => iw,
                    SkeletonHelper: () => nP,
                    SkinnedMesh: () => tw,
                    Source: () => rh,
                    Sphere: () => Ys,
                    SphereGeometry: () => ET,
                    Spherical: () => B2,
                    SphericalHarmonics3: () => _2,
                    SplineCurve: () => AT,
                    SpotLight: () => d2,
                    SpotLightHelper: () => tP,
                    Sprite: () => qC,
                    SpriteMaterial: () => $A,
                    SrcAlphaFactor: () => Py,
                    SrcAlphaSaturateFactor: () => YE,
                    SrcColorFactor: () => HE,
                    StaticCopyUsage: () => mB,
                    StaticDrawUsage: () => dg,
                    StaticReadUsage: () => fB,
                    StereoCamera: () => MI,
                    StreamCopyUsage: () => gB,
                    StreamDrawUsage: () => hB,
                    StreamReadUsage: () => pB,
                    StringKeyframeTrack: () => Uf,
                    SubtractEquation: () => BE,
                    SubtractiveBlending: () => dA,
                    TOUCH: () => zN,
                    TangentSpaceNormalMap: () => ah,
                    TetrahedronGeometry: () => kw,
                    Texture: () => Fi,
                    TextureLoader: () => vI,
                    TextureUtils: () => xP,
                    Timer: () => qI,
                    TimestampQuery: () => _B,
                    TorusGeometry: () => Xw,
                    TorusKnotGeometry: () => Ww,
                    Triangle: () => hh,
                    TriangleFanDrawMode: () => qN,
                    TriangleStripDrawMode: () => YN,
                    TrianglesDrawMode: () => WN,
                    TubeGeometry: () => Yw,
                    UVMapping: () => Fy,
                    Uint16BufferAttribute: () => jA,
                    Uint32BufferAttribute: () => QA,
                    Uint8BufferAttribute: () => sL,
                    Uint8ClampedBufferAttribute: () => aL,
                    Uniform: () => ke,
                    UniformsGroup: () => XI,
                    UniformsLib: () => Mt,
                    UniformsUtils: () => JA,
                    UnsignedByteType: () => gi,
                    UnsignedInt101111Type: () => xA,
                    UnsignedInt248Type: () => df,
                    UnsignedInt5999Type: () => SA,
                    UnsignedIntType: () => ac,
                    UnsignedShort4444Type: () => Gy,
                    UnsignedShort5551Type: () => Vy,
                    UnsignedShortType: () => mp,
                    VSMShadowMap: () => sl,
                    Vector2: () => Oe,
                    Vector3: () => ae,
                    Vector4: () => hn,
                    VectorKeyframeTrack: () => kg,
                    VideoFrameTexture: () => wL,
                    VideoTexture: () => _w,
                    WebGL3DRenderTarget: () => WB,
                    WebGLArrayRenderTarget: () => XB,
                    WebGLCoordinateSystem: () => Yr,
                    WebGLCubeRenderTarget: () => GC,
                    WebGLRenderTarget: () => Vn,
                    WebGLRenderer: () => _1,
                    WebGLUtils: () => y1,
                    WebGPUCoordinateSystem: () => yp,
                    WebXRController: () => G_,
                    WireframeGeometry: () => qw,
                    WrapAroundEnding: () => hg,
                    ZeroCurvatureEnding: () => mf,
                    ZeroFactor: () => zE,
                    ZeroSlopeEnding: () => vf,
                    ZeroStencilOp: () => ZN,
                    createCanvasElement: () => SC
                });
                function X2() {
                    let e = null
                      , t = !1
                      , n = null
                      , i = null;
                    function s(a, o) {
                        n(a, o),
                        i = e.requestAnimationFrame(s)
                    }
                    return {
                        start: function() {
                            t !== !0 && n !== null && (i = e.requestAnimationFrame(s),
                            t = !0)
                        },
                        stop: function() {
                            e.cancelAnimationFrame(i),
                            t = !1
                        },
                        setAnimationLoop: function(a) {
                            n = a
                        },
                        setContext: function(a) {
                            e = a
                        }
                    }
                }
                function TP(e) {
                    const t = new WeakMap;
                    function n(c, u) {
                        const f = c.array
                          , m = c.usage
                          , v = f.byteLength
                          , y = e.createBuffer();
                        e.bindBuffer(u, y),
                        e.bufferData(u, f, m),
                        c.onUploadCallback();
                        let S;
                        if (f instanceof Float32Array)
                            S = e.FLOAT;
                        else if (typeof Float16Array < "u" && f instanceof Float16Array)
                            S = e.HALF_FLOAT;
                        else if (f instanceof Uint16Array)
                            c.isFloat16BufferAttribute ? S = e.HALF_FLOAT : S = e.UNSIGNED_SHORT;
                        else if (f instanceof Int16Array)
                            S = e.SHORT;
                        else if (f instanceof Uint32Array)
                            S = e.UNSIGNED_INT;
                        else if (f instanceof Int32Array)
                            S = e.INT;
                        else if (f instanceof Int8Array)
                            S = e.BYTE;
                        else if (f instanceof Uint8Array)
                            S = e.UNSIGNED_BYTE;
                        else if (f instanceof Uint8ClampedArray)
                            S = e.UNSIGNED_BYTE;
                        else
                            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
                        return {
                            buffer: y,
                            type: S,
                            bytesPerElement: f.BYTES_PER_ELEMENT,
                            version: c.version,
                            size: v
                        }
                    }
                    function i(c, u, f) {
                        const m = u.array
                          , v = u.updateRanges;
                        if (e.bindBuffer(f, c),
                        v.length === 0)
                            e.bufferSubData(f, 0, m);
                        else {
                            v.sort( (S, A) => S.start - A.start);
                            let y = 0;
                            for (let S = 1; S < v.length; S++) {
                                const A = v[y]
                                  , M = v[S];
                                M.start <= A.start + A.count + 1 ? A.count = Math.max(A.count, M.start + M.count - A.start) : (++y,
                                v[y] = M)
                            }
                            v.length = y + 1;
                            for (let S = 0, A = v.length; S < A; S++) {
                                const M = v[S];
                                e.bufferSubData(f, M.start * m.BYTES_PER_ELEMENT, m, M.start, M.count)
                            }
                            u.clearUpdateRanges()
                        }
                        u.onUploadCallback()
                    }
                    function s(c) {
                        return c.isInterleavedBufferAttribute && (c = c.data),
                        t.get(c)
                    }
                    function a(c) {
                        c.isInterleavedBufferAttribute && (c = c.data);
                        const u = t.get(c);
                        u && (e.deleteBuffer(u.buffer),
                        t.delete(c))
                    }
                    function o(c, u) {
                        if (c.isInterleavedBufferAttribute && (c = c.data),
                        c.isGLBufferAttribute) {
                            const m = t.get(c);
                            (!m || m.version < c.version) && t.set(c, {
                                buffer: c.buffer,
                                type: c.type,
                                bytesPerElement: c.elementSize,
                                version: c.version
                            });
                            return
                        }
                        const f = t.get(c);
                        if (f === void 0)
                            t.set(c, n(c, u));
                        else if (f.version < c.version) {
                            if (f.size !== c.array.byteLength)
                                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            i(f.buffer, c, u),
                            f.version = c.version
                        }
                    }
                    return {
                        get: s,
                        remove: a,
                        update: o
                    }
                }
                const an = {
                    alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
                    alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
                    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
                    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    alphatest_fragment: `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
                    alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
                    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
                    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
                    batching_pars_vertex: `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
                    batching_vertex: `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
                    begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
                    beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
                    bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
                    iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
                    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
                    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
                    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
                    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
                    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
                    color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
                    color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
                    color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
                    color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
                    common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
                    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
                    defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
                    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
                    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
                    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
                    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
                    envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
                    envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
                    envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
                    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
                    envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
                    envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
                    fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
                    fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
                    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
                    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
                    gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
                    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
                    lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
                    lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
                    lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
                    lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
                    lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
                    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
                    lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
                    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
                    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
                    lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
                    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
                    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
                    logdepthbuf_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
                    logdepthbuf_pars_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_pars_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
                    map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
                    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
                    map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
                    map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
                    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
                    morphinstance_vertex: `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
                    morphcolor_vertex: `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
                    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
                    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
                    normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
                    normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
                    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
                    clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
                    clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
                    clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
                    iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
                    opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
                    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
                    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
                    project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
                    dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
                    dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
                    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
                    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
                    shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
                    shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
                    shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
                    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
                    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
                    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
                    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
                    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
                    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
                    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
                    tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
                    tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
                    transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
                    transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
                    uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
                    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
                    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                    background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
                    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
                    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                    meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
                    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                    meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
                    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
                }
                  , Mt = {
                    common: {
                        diffuse: {
                            value: new ft(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new nn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new nn
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new nn
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new nn
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new nn
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new nn
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new nn
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new nn
                        },
                        normalScale: {
                            value: new Oe(1,1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new nn
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new nn
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new nn
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new nn
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new ft(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new ft(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new nn
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new nn
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new ft(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Oe(.5,.5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new nn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new nn
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                }
                  , fl = {
                    basic: {
                        uniforms: tr([Mt.common, Mt.specularmap, Mt.envmap, Mt.aomap, Mt.lightmap, Mt.fog]),
                        vertexShader: an.meshbasic_vert,
                        fragmentShader: an.meshbasic_frag
                    },
                    lambert: {
                        uniforms: tr([Mt.common, Mt.specularmap, Mt.envmap, Mt.aomap, Mt.lightmap, Mt.emissivemap, Mt.bumpmap, Mt.normalmap, Mt.displacementmap, Mt.fog, Mt.lights, {
                            emissive: {
                                value: new ft(0)
                            }
                        }]),
                        vertexShader: an.meshlambert_vert,
                        fragmentShader: an.meshlambert_frag
                    },
                    phong: {
                        uniforms: tr([Mt.common, Mt.specularmap, Mt.envmap, Mt.aomap, Mt.lightmap, Mt.emissivemap, Mt.bumpmap, Mt.normalmap, Mt.displacementmap, Mt.fog, Mt.lights, {
                            emissive: {
                                value: new ft(0)
                            },
                            specular: {
                                value: new ft(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: an.meshphong_vert,
                        fragmentShader: an.meshphong_frag
                    },
                    standard: {
                        uniforms: tr([Mt.common, Mt.envmap, Mt.aomap, Mt.lightmap, Mt.emissivemap, Mt.bumpmap, Mt.normalmap, Mt.displacementmap, Mt.roughnessmap, Mt.metalnessmap, Mt.fog, Mt.lights, {
                            emissive: {
                                value: new ft(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: an.meshphysical_vert,
                        fragmentShader: an.meshphysical_frag
                    },
                    toon: {
                        uniforms: tr([Mt.common, Mt.aomap, Mt.lightmap, Mt.emissivemap, Mt.bumpmap, Mt.normalmap, Mt.displacementmap, Mt.gradientmap, Mt.fog, Mt.lights, {
                            emissive: {
                                value: new ft(0)
                            }
                        }]),
                        vertexShader: an.meshtoon_vert,
                        fragmentShader: an.meshtoon_frag
                    },
                    matcap: {
                        uniforms: tr([Mt.common, Mt.bumpmap, Mt.normalmap, Mt.displacementmap, Mt.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: an.meshmatcap_vert,
                        fragmentShader: an.meshmatcap_frag
                    },
                    points: {
                        uniforms: tr([Mt.points, Mt.fog]),
                        vertexShader: an.points_vert,
                        fragmentShader: an.points_frag
                    },
                    dashed: {
                        uniforms: tr([Mt.common, Mt.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: an.linedashed_vert,
                        fragmentShader: an.linedashed_frag
                    },
                    depth: {
                        uniforms: tr([Mt.common, Mt.displacementmap]),
                        vertexShader: an.depth_vert,
                        fragmentShader: an.depth_frag
                    },
                    normal: {
                        uniforms: tr([Mt.common, Mt.bumpmap, Mt.normalmap, Mt.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: an.meshnormal_vert,
                        fragmentShader: an.meshnormal_frag
                    },
                    sprite: {
                        uniforms: tr([Mt.sprite, Mt.fog]),
                        vertexShader: an.sprite_vert,
                        fragmentShader: an.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new nn
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: an.background_vert,
                        fragmentShader: an.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new nn
                            }
                        },
                        vertexShader: an.backgroundCube_vert,
                        fragmentShader: an.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: an.cube_vert,
                        fragmentShader: an.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: an.equirect_vert,
                        fragmentShader: an.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: tr([Mt.common, Mt.displacementmap, {
                            referencePosition: {
                                value: new ae
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: an.distanceRGBA_vert,
                        fragmentShader: an.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: tr([Mt.lights, Mt.fog, {
                            color: {
                                value: new ft(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: an.shadow_vert,
                        fragmentShader: an.shadow_frag
                    }
                };
                fl.physical = {
                    uniforms: tr([fl.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatMapTransform: {
                            value: new nn
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        clearcoatNormalMapTransform: {
                            value: new nn
                        },
                        clearcoatNormalScale: {
                            value: new Oe(1,1)
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatRoughnessMapTransform: {
                            value: new nn
                        },
                        dispersion: {
                            value: 0
                        },
                        iridescence: {
                            value: 0
                        },
                        iridescenceMap: {
                            value: null
                        },
                        iridescenceMapTransform: {
                            value: new nn
                        },
                        iridescenceIOR: {
                            value: 1.3
                        },
                        iridescenceThicknessMinimum: {
                            value: 100
                        },
                        iridescenceThicknessMaximum: {
                            value: 400
                        },
                        iridescenceThicknessMap: {
                            value: null
                        },
                        iridescenceThicknessMapTransform: {
                            value: new nn
                        },
                        sheen: {
                            value: 0
                        },
                        sheenColor: {
                            value: new ft(0)
                        },
                        sheenColorMap: {
                            value: null
                        },
                        sheenColorMapTransform: {
                            value: new nn
                        },
                        sheenRoughness: {
                            value: 1
                        },
                        sheenRoughnessMap: {
                            value: null
                        },
                        sheenRoughnessMapTransform: {
                            value: new nn
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionMapTransform: {
                            value: new nn
                        },
                        transmissionSamplerSize: {
                            value: new Oe
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        thicknessMapTransform: {
                            value: new nn
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new ft(0)
                        },
                        specularColor: {
                            value: new ft(1,1,1)
                        },
                        specularColorMap: {
                            value: null
                        },
                        specularColorMapTransform: {
                            value: new nn
                        },
                        specularIntensity: {
                            value: 1
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularIntensityMapTransform: {
                            value: new nn
                        },
                        anisotropyVector: {
                            value: new Oe
                        },
                        anisotropyMap: {
                            value: null
                        },
                        anisotropyMapTransform: {
                            value: new nn
                        }
                    }]),
                    vertexShader: an.meshphysical_vert,
                    fragmentShader: an.meshphysical_frag
                };
                const TS = {
                    r: 0,
                    b: 0,
                    g: 0
                }
                  , zf = new Co
                  , MP = new Xt;
                function bP(e, t, n, i, s, a, o) {
                    const c = new ft(0);
                    let u = a === !0 ? 0 : 1, f, m, v = null, y = 0, S = null;
                    function A(w) {
                        let U = w.isScene === !0 ? w.background : null;
                        return U && U.isTexture && (U = (w.backgroundBlurriness > 0 ? n : t).get(U)),
                        U
                    }
                    function M(w) {
                        let U = !1;
                        const O = A(w);
                        O === null ? T(c, u) : O && O.isColor && (T(O, 1),
                        U = !0);
                        const L = e.xr.getEnvironmentBlendMode();
                        L === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : L === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
                        (e.autoClear || U) && (i.buffers.depth.setTest(!0),
                        i.buffers.depth.setMask(!0),
                        i.buffers.color.setMask(!0),
                        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                    }
                    function x(w, U) {
                        const O = A(U);
                        O && (O.isCubeTexture || O.mapping === dp) ? (m === void 0 && (m = new oi(new dh(1,1,1),new kn({
                            name: "BackgroundCubeMaterial",
                            uniforms: Bp(fl.backgroundCube.uniforms),
                            vertexShader: fl.backgroundCube.vertexShader,
                            fragmentShader: fl.backgroundCube.fragmentShader,
                            side: Ds,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        m.geometry.deleteAttribute("normal"),
                        m.geometry.deleteAttribute("uv"),
                        m.onBeforeRender = function(L, N, z) {
                            this.matrixWorld.copyPosition(z.matrixWorld)
                        }
                        ,
                        Object.defineProperty(m.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        s.update(m)),
                        zf.copy(U.backgroundRotation),
                        zf.x *= -1,
                        zf.y *= -1,
                        zf.z *= -1,
                        O.isCubeTexture && O.isRenderTargetTexture === !1 && (zf.y *= -1,
                        zf.z *= -1),
                        m.material.uniforms.envMap.value = O,
                        m.material.uniforms.flipEnvMap.value = O.isCubeTexture && O.isRenderTargetTexture === !1 ? -1 : 1,
                        m.material.uniforms.backgroundBlurriness.value = U.backgroundBlurriness,
                        m.material.uniforms.backgroundIntensity.value = U.backgroundIntensity,
                        m.material.uniforms.backgroundRotation.value.setFromMatrix4(MP.makeRotationFromEuler(zf)),
                        m.material.toneMapped = Rn.getTransfer(O.colorSpace) !== Jn,
                        (v !== O || y !== O.version || S !== e.toneMapping) && (m.material.needsUpdate = !0,
                        v = O,
                        y = O.version,
                        S = e.toneMapping),
                        m.layers.enableAll(),
                        w.unshift(m, m.geometry, m.material, 0, 0, null)) : O && O.isTexture && (f === void 0 && (f = new oi(new wf(2,2),new kn({
                            name: "BackgroundMaterial",
                            uniforms: Bp(fl.background.uniforms),
                            vertexShader: fl.background.vertexShader,
                            fragmentShader: fl.background.fragmentShader,
                            side: ic,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        f.geometry.deleteAttribute("normal"),
                        Object.defineProperty(f.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        s.update(f)),
                        f.material.uniforms.t2D.value = O,
                        f.material.uniforms.backgroundIntensity.value = U.backgroundIntensity,
                        f.material.toneMapped = Rn.getTransfer(O.colorSpace) !== Jn,
                        O.matrixAutoUpdate === !0 && O.updateMatrix(),
                        f.material.uniforms.uvTransform.value.copy(O.matrix),
                        (v !== O || y !== O.version || S !== e.toneMapping) && (f.material.needsUpdate = !0,
                        v = O,
                        y = O.version,
                        S = e.toneMapping),
                        f.layers.enableAll(),
                        w.unshift(f, f.geometry, f.material, 0, 0, null))
                    }
                    function T(w, U) {
                        w.getRGB(TS, PC(e)),
                        i.buffers.color.setClear(TS.r, TS.g, TS.b, U, o)
                    }
                    function D() {
                        m !== void 0 && (m.geometry.dispose(),
                        m.material.dispose(),
                        m = void 0),
                        f !== void 0 && (f.geometry.dispose(),
                        f.material.dispose(),
                        f = void 0)
                    }
                    return {
                        getClearColor: function() {
                            return c
                        },
                        setClearColor: function(w, U=1) {
                            c.set(w),
                            u = U,
                            T(c, u)
                        },
                        getClearAlpha: function() {
                            return u
                        },
                        setClearAlpha: function(w) {
                            u = w,
                            T(c, u)
                        },
                        render: M,
                        addToRenderList: x,
                        dispose: D
                    }
                }
                function EP(e, t) {
                    const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                      , i = {}
                      , s = y(null);
                    let a = s
                      , o = !1;
                    function c(B, G, X, q, Q) {
                        let oe = !1;
                        const k = v(q, X, G);
                        a !== k && (a = k,
                        f(a.object)),
                        oe = S(B, q, X, Q),
                        oe && A(B, q, X, Q),
                        Q !== null && t.update(Q, e.ELEMENT_ARRAY_BUFFER),
                        (oe || o) && (o = !1,
                        U(B, G, X, q),
                        Q !== null && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(Q).buffer))
                    }
                    function u() {
                        return e.createVertexArray()
                    }
                    function f(B) {
                        return e.bindVertexArray(B)
                    }
                    function m(B) {
                        return e.deleteVertexArray(B)
                    }
                    function v(B, G, X) {
                        const q = X.wireframe === !0;
                        let Q = i[B.id];
                        Q === void 0 && (Q = {},
                        i[B.id] = Q);
                        let oe = Q[G.id];
                        oe === void 0 && (oe = {},
                        Q[G.id] = oe);
                        let k = oe[q];
                        return k === void 0 && (k = y(u()),
                        oe[q] = k),
                        k
                    }
                    function y(B) {
                        const G = []
                          , X = []
                          , q = [];
                        for (let Q = 0; Q < n; Q++)
                            G[Q] = 0,
                            X[Q] = 0,
                            q[Q] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: G,
                            enabledAttributes: X,
                            attributeDivisors: q,
                            object: B,
                            attributes: {},
                            index: null
                        }
                    }
                    function S(B, G, X, q) {
                        const Q = a.attributes
                          , oe = G.attributes;
                        let k = 0;
                        const W = X.getAttributes();
                        for (const V in W)
                            if (W[V].location >= 0) {
                                const Z = Q[V];
                                let j = oe[V];
                                if (j === void 0 && (V === "instanceMatrix" && B.instanceMatrix && (j = B.instanceMatrix),
                                V === "instanceColor" && B.instanceColor && (j = B.instanceColor)),
                                Z === void 0 || Z.attribute !== j || j && Z.data !== j.data)
                                    return !0;
                                k++
                            }
                        return a.attributesNum !== k || a.index !== q
                    }
                    function A(B, G, X, q) {
                        const Q = {}
                          , oe = G.attributes;
                        let k = 0;
                        const W = X.getAttributes();
                        for (const V in W)
                            if (W[V].location >= 0) {
                                let Z = oe[V];
                                Z === void 0 && (V === "instanceMatrix" && B.instanceMatrix && (Z = B.instanceMatrix),
                                V === "instanceColor" && B.instanceColor && (Z = B.instanceColor));
                                const j = {};
                                j.attribute = Z,
                                Z && Z.data && (j.data = Z.data),
                                Q[V] = j,
                                k++
                            }
                        a.attributes = Q,
                        a.attributesNum = k,
                        a.index = q
                    }
                    function M() {
                        const B = a.newAttributes;
                        for (let G = 0, X = B.length; G < X; G++)
                            B[G] = 0
                    }
                    function x(B) {
                        T(B, 0)
                    }
                    function T(B, G) {
                        const X = a.newAttributes
                          , q = a.enabledAttributes
                          , Q = a.attributeDivisors;
                        X[B] = 1,
                        q[B] === 0 && (e.enableVertexAttribArray(B),
                        q[B] = 1),
                        Q[B] !== G && (e.vertexAttribDivisor(B, G),
                        Q[B] = G)
                    }
                    function D() {
                        const B = a.newAttributes
                          , G = a.enabledAttributes;
                        for (let X = 0, q = G.length; X < q; X++)
                            G[X] !== B[X] && (e.disableVertexAttribArray(X),
                            G[X] = 0)
                    }
                    function w(B, G, X, q, Q, oe, k) {
                        k === !0 ? e.vertexAttribIPointer(B, G, X, Q, oe) : e.vertexAttribPointer(B, G, X, q, Q, oe)
                    }
                    function U(B, G, X, q) {
                        M();
                        const Q = q.attributes
                          , oe = X.getAttributes()
                          , k = G.defaultAttributeValues;
                        for (const W in oe) {
                            const V = oe[W];
                            if (V.location >= 0) {
                                let Z = Q[W];
                                if (Z === void 0 && (W === "instanceMatrix" && B.instanceMatrix && (Z = B.instanceMatrix),
                                W === "instanceColor" && B.instanceColor && (Z = B.instanceColor)),
                                Z !== void 0) {
                                    const j = Z.normalized
                                      , ee = Z.itemSize
                                      , H = t.get(Z);
                                    if (H === void 0)
                                        continue;
                                    const ie = H.buffer
                                      , se = H.type
                                      , K = H.bytesPerElement
                                      , le = se === e.INT || se === e.UNSIGNED_INT || Z.gpuType === Hy;
                                    if (Z.isInterleavedBufferAttribute) {
                                        const ue = Z.data
                                          , de = ue.stride
                                          , qe = Z.offset;
                                        if (ue.isInstancedInterleavedBuffer) {
                                            for (let ze = 0; ze < V.locationSize; ze++)
                                                T(V.location + ze, ue.meshPerAttribute);
                                            B.isInstancedMesh !== !0 && q._maxInstanceCount === void 0 && (q._maxInstanceCount = ue.meshPerAttribute * ue.count)
                                        } else
                                            for (let ze = 0; ze < V.locationSize; ze++)
                                                x(V.location + ze);
                                        e.bindBuffer(e.ARRAY_BUFFER, ie);
                                        for (let ze = 0; ze < V.locationSize; ze++)
                                            w(V.location + ze, ee / V.locationSize, se, j, de * K, (qe + ee / V.locationSize * ze) * K, le)
                                    } else {
                                        if (Z.isInstancedBufferAttribute) {
                                            for (let ue = 0; ue < V.locationSize; ue++)
                                                T(V.location + ue, Z.meshPerAttribute);
                                            B.isInstancedMesh !== !0 && q._maxInstanceCount === void 0 && (q._maxInstanceCount = Z.meshPerAttribute * Z.count)
                                        } else
                                            for (let ue = 0; ue < V.locationSize; ue++)
                                                x(V.location + ue);
                                        e.bindBuffer(e.ARRAY_BUFFER, ie);
                                        for (let ue = 0; ue < V.locationSize; ue++)
                                            w(V.location + ue, ee / V.locationSize, se, j, ee * K, ee / V.locationSize * ue * K, le)
                                    }
                                } else if (k !== void 0) {
                                    const j = k[W];
                                    if (j !== void 0)
                                        switch (j.length) {
                                        case 2:
                                            e.vertexAttrib2fv(V.location, j);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(V.location, j);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(V.location, j);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(V.location, j)
                                        }
                                }
                            }
                        }
                        D()
                    }
                    function O() {
                        z();
                        for (const B in i) {
                            const G = i[B];
                            for (const X in G) {
                                const q = G[X];
                                for (const Q in q)
                                    m(q[Q].object),
                                    delete q[Q];
                                delete G[X]
                            }
                            delete i[B]
                        }
                    }
                    function L(B) {
                        if (i[B.id] === void 0)
                            return;
                        const G = i[B.id];
                        for (const X in G) {
                            const q = G[X];
                            for (const Q in q)
                                m(q[Q].object),
                                delete q[Q];
                            delete G[X]
                        }
                        delete i[B.id]
                    }
                    function N(B) {
                        for (const G in i) {
                            const X = i[G];
                            if (X[B.id] === void 0)
                                continue;
                            const q = X[B.id];
                            for (const Q in q)
                                m(q[Q].object),
                                delete q[Q];
                            delete X[B.id]
                        }
                    }
                    function z() {
                        I(),
                        o = !0,
                        a !== s && (a = s,
                        f(a.object))
                    }
                    function I() {
                        s.geometry = null,
                        s.program = null,
                        s.wireframe = !1
                    }
                    return {
                        setup: c,
                        reset: z,
                        resetDefaultState: I,
                        dispose: O,
                        releaseStatesOfGeometry: L,
                        releaseStatesOfProgram: N,
                        initAttributes: M,
                        enableAttribute: x,
                        disableUnusedAttributes: D
                    }
                }
                function CP(e, t, n) {
                    let i;
                    function s(f) {
                        i = f
                    }
                    function a(f, m) {
                        e.drawArrays(i, f, m),
                        n.update(m, i, 1)
                    }
                    function o(f, m, v) {
                        v !== 0 && (e.drawArraysInstanced(i, f, m, v),
                        n.update(m, i, v))
                    }
                    function c(f, m, v) {
                        if (v === 0)
                            return;
                        t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, f, 0, m, 0, v);
                        let y = 0;
                        for (let S = 0; S < v; S++)
                            y += m[S];
                        n.update(y, i, 1)
                    }
                    function u(f, m, v, y) {
                        if (v === 0)
                            return;
                        const S = t.get("WEBGL_multi_draw");
                        if (S === null)
                            for (let A = 0; A < f.length; A++)
                                o(f[A], m[A], y[A]);
                        else {
                            S.multiDrawArraysInstancedWEBGL(i, f, 0, m, 0, y, 0, v);
                            let A = 0;
                            for (let M = 0; M < v; M++)
                                A += m[M] * y[M];
                            n.update(A, i, 1)
                        }
                    }
                    this.setMode = s,
                    this.render = a,
                    this.renderInstances = o,
                    this.renderMultiDraw = c,
                    this.renderMultiDrawInstances = u
                }
                function wP(e, t, n, i) {
                    let s;
                    function a() {
                        if (s !== void 0)
                            return s;
                        if (t.has("EXT_texture_filter_anisotropic") === !0) {
                            const N = t.get("EXT_texture_filter_anisotropic");
                            s = e.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else
                            s = 0;
                        return s
                    }
                    function o(N) {
                        return !(N !== ps && i.convert(N) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT))
                    }
                    function c(N) {
                        const z = N === ff && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                        return !(N !== gi && i.convert(N) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && N !== na && !z)
                    }
                    function u(N) {
                        if (N === "highp") {
                            if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                                return "highp";
                            N = "mediump"
                        }
                        return N === "mediump" && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                    }
                    let f = n.precision !== void 0 ? n.precision : "highp";
                    const m = u(f);
                    m !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", m, "instead."),
                    f = m);
                    const v = n.logarithmicDepthBuffer === !0
                      , y = n.reversedDepthBuffer === !0 && t.has("EXT_clip_control")
                      , S = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
                      , A = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                      , M = e.getParameter(e.MAX_TEXTURE_SIZE)
                      , x = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
                      , T = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                      , D = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
                      , w = e.getParameter(e.MAX_VARYING_VECTORS)
                      , U = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
                      , O = A > 0
                      , L = e.getParameter(e.MAX_SAMPLES);
                    return {
                        isWebGL2: !0,
                        getMaxAnisotropy: a,
                        getMaxPrecision: u,
                        textureFormatReadable: o,
                        textureTypeReadable: c,
                        precision: f,
                        logarithmicDepthBuffer: v,
                        reversedDepthBuffer: y,
                        maxTextures: S,
                        maxVertexTextures: A,
                        maxTextureSize: M,
                        maxCubemapSize: x,
                        maxAttributes: T,
                        maxVertexUniforms: D,
                        maxVaryings: w,
                        maxFragmentUniforms: U,
                        vertexTextures: O,
                        maxSamples: L
                    }
                }
                function DP(e) {
                    const t = this;
                    let n = null
                      , i = 0
                      , s = !1
                      , a = !1;
                    const o = new au
                      , c = new nn
                      , u = {
                        value: null,
                        needsUpdate: !1
                    };
                    this.uniform = u,
                    this.numPlanes = 0,
                    this.numIntersection = 0,
                    this.init = function(v, y) {
                        const S = v.length !== 0 || y || i !== 0 || s;
                        return s = y,
                        i = v.length,
                        S
                    }
                    ,
                    this.beginShadows = function() {
                        a = !0,
                        m(null)
                    }
                    ,
                    this.endShadows = function() {
                        a = !1
                    }
                    ,
                    this.setGlobalState = function(v, y) {
                        n = m(v, y, 0)
                    }
                    ,
                    this.setState = function(v, y, S) {
                        const A = v.clippingPlanes
                          , M = v.clipIntersection
                          , x = v.clipShadows
                          , T = e.get(v);
                        if (!s || A === null || A.length === 0 || a && !x)
                            a ? m(null) : f();
                        else {
                            const D = a ? 0 : i
                              , w = D * 4;
                            let U = T.clippingState || null;
                            u.value = U,
                            U = m(A, y, w, S);
                            for (let O = 0; O !== w; ++O)
                                U[O] = n[O];
                            T.clippingState = U,
                            this.numIntersection = M ? this.numPlanes : 0,
                            this.numPlanes += D
                        }
                    }
                    ;
                    function f() {
                        u.value !== n && (u.value = n,
                        u.needsUpdate = i > 0),
                        t.numPlanes = i,
                        t.numIntersection = 0
                    }
                    function m(v, y, S, A) {
                        const M = v !== null ? v.length : 0;
                        let x = null;
                        if (M !== 0) {
                            if (x = u.value,
                            A !== !0 || x === null) {
                                const T = S + M * 4
                                  , D = y.matrixWorldInverse;
                                c.getNormalMatrix(D),
                                (x === null || x.length < T) && (x = new Float32Array(T));
                                for (let w = 0, U = S; w !== M; ++w,
                                U += 4)
                                    o.copy(v[w]).applyMatrix4(D, c),
                                    o.normal.toArray(x, U),
                                    x[U + 3] = o.constant
                            }
                            u.value = x,
                            u.needsUpdate = !0
                        }
                        return t.numPlanes = M,
                        t.numIntersection = 0,
                        x
                    }
                }
                function RP(e) {
                    let t = new WeakMap;
                    function n(o, c) {
                        return c === fp ? o.mapping = Qc : c === ng && (o.mapping = ih),
                        o
                    }
                    function i(o) {
                        if (o && o.isTexture) {
                            const c = o.mapping;
                            if (c === fp || c === ng)
                                if (t.has(o)) {
                                    const u = t.get(o).texture;
                                    return n(u, o.mapping)
                                } else {
                                    const u = o.image;
                                    if (u && u.height > 0) {
                                        const f = new GC(u.height);
                                        return f.fromEquirectangularTexture(e, o),
                                        t.set(o, f),
                                        o.addEventListener("dispose", s),
                                        n(f.texture, o.mapping)
                                    } else
                                        return null
                                }
                        }
                        return o
                    }
                    function s(o) {
                        const c = o.target;
                        c.removeEventListener("dispose", s);
                        const u = t.get(c);
                        u !== void 0 && (t.delete(c),
                        u.dispose())
                    }
                    function a() {
                        t = new WeakMap
                    }
                    return {
                        get: i,
                        dispose: a
                    }
                }
                const Zp = 4
                  , W2 = [.125, .215, .35, .446, .526, .582]
                  , Ff = 20
                  , QT = new qg
                  , Y2 = new ft;
                let ZT = null
                  , KT = 0
                  , JT = 0
                  , $T = !1;
                const Hf = (1 + Math.sqrt(5)) / 2
                  , Kp = 1 / Hf
                  , q2 = [new ae(-Hf,Kp,0), new ae(Hf,Kp,0), new ae(-Kp,0,Hf), new ae(Kp,0,Hf), new ae(0,Hf,-Kp), new ae(0,Hf,Kp), new ae(-1,1,-1), new ae(1,1,-1), new ae(-1,1,1), new ae(1,1,1)]
                  , UP = new ae;
                var eM = class {
                    constructor(e) {
                        this._renderer = e,
                        this._pingPongRenderTarget = null,
                        this._lodMax = 0,
                        this._cubeSize = 0,
                        this._lodPlanes = [],
                        this._sizeLods = [],
                        this._sigmas = [],
                        this._blurMaterial = null,
                        this._cubemapMaterial = null,
                        this._equirectMaterial = null,
                        this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(e, t=0, n=.1, i=100, s={}) {
                        const {size: a=256, position: o=UP} = s;
                        ZT = this._renderer.getRenderTarget(),
                        KT = this._renderer.getActiveCubeFace(),
                        JT = this._renderer.getActiveMipmapLevel(),
                        $T = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1,
                        this._setSize(a);
                        const c = this._allocateTargets();
                        return c.depthBuffer = !0,
                        this._sceneToCubeUV(e, n, i, c, o),
                        t > 0 && this._blur(c, 0, 0, t),
                        this._applyPMREM(c),
                        this._cleanup(c),
                        c
                    }
                    fromEquirectangular(e, t=null) {
                        return this._fromTexture(e, t)
                    }
                    fromCubemap(e, t=null) {
                        return this._fromTexture(e, t)
                    }
                    compileCubemapShader() {
                        this._cubemapMaterial === null && (this._cubemapMaterial = Z2(),
                        this._compileMaterial(this._cubemapMaterial))
                    }
                    compileEquirectangularShader() {
                        this._equirectMaterial === null && (this._equirectMaterial = Q2(),
                        this._compileMaterial(this._equirectMaterial))
                    }
                    dispose() {
                        this._dispose(),
                        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                        this._equirectMaterial !== null && this._equirectMaterial.dispose()
                    }
                    _setSize(e) {
                        this._lodMax = Math.floor(Math.log2(e)),
                        this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        this._blurMaterial !== null && this._blurMaterial.dispose(),
                        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                        for (let e = 0; e < this._lodPlanes.length; e++)
                            this._lodPlanes[e].dispose()
                    }
                    _cleanup(e) {
                        this._renderer.setRenderTarget(ZT, KT, JT),
                        this._renderer.xr.enabled = $T,
                        e.scissorTest = !1,
                        MS(e, 0, 0, e.width, e.height)
                    }
                    _fromTexture(e, t) {
                        e.mapping === Qc || e.mapping === ih ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                        ZT = this._renderer.getRenderTarget(),
                        KT = this._renderer.getActiveCubeFace(),
                        JT = this._renderer.getActiveMipmapLevel(),
                        $T = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1;
                        const n = t || this._allocateTargets();
                        return this._textureToCubeUV(e, n),
                        this._applyPMREM(n),
                        this._cleanup(n),
                        n
                    }
                    _allocateTargets() {
                        const e = 3 * Math.max(this._cubeSize, 112)
                          , t = 4 * this._cubeSize
                          , n = {
                            magFilter: mi,
                            minFilter: mi,
                            generateMipmaps: !1,
                            type: ff,
                            format: ps,
                            colorSpace: rc,
                            depthBuffer: !1
                        }
                          , i = j2(e, t, n);
                        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                            this._pingPongRenderTarget !== null && this._dispose(),
                            this._pingPongRenderTarget = j2(e, t, n);
                            const {_lodMax: s} = this;
                            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = OP(s)),
                            this._blurMaterial = NP(s, e, t)
                        }
                        return i
                    }
                    _compileMaterial(e) {
                        const t = new oi(this._lodPlanes[0],e);
                        this._renderer.compile(t, QT)
                    }
                    _sceneToCubeUV(e, t, n, i, s) {
                        const a = new Hi(90,1,t,n)
                          , o = [1, -1, 1, 1, 1, 1]
                          , c = [1, 1, 1, -1, -1, -1]
                          , u = this._renderer
                          , f = u.autoClear
                          , m = u.toneMapping;
                        u.getClearColor(Y2),
                        u.toneMapping = al,
                        u.autoClear = !1,
                        u.state.buffers.depth.getReversed() && (u.setRenderTarget(i),
                        u.clearDepth(),
                        u.setRenderTarget(null));
                        const v = new nu({
                            name: "PMREM.Background",
                            side: Ds,
                            depthWrite: !1,
                            depthTest: !1
                        })
                          , y = new oi(new dh,v);
                        let S = !1;
                        const A = e.background;
                        A ? A.isColor && (v.color.copy(A),
                        e.background = null,
                        S = !0) : (v.color.copy(Y2),
                        S = !0);
                        for (let M = 0; M < 6; M++) {
                            const x = M % 3;
                            x === 0 ? (a.up.set(0, o[M], 0),
                            a.position.set(s.x, s.y, s.z),
                            a.lookAt(s.x + c[M], s.y, s.z)) : x === 1 ? (a.up.set(0, 0, o[M]),
                            a.position.set(s.x, s.y, s.z),
                            a.lookAt(s.x, s.y + c[M], s.z)) : (a.up.set(0, o[M], 0),
                            a.position.set(s.x, s.y, s.z),
                            a.lookAt(s.x, s.y, s.z + c[M]));
                            const T = this._cubeSize;
                            MS(i, x * T, M > 2 ? T : 0, T, T),
                            u.setRenderTarget(i),
                            S && u.render(y, a),
                            u.render(e, a)
                        }
                        y.geometry.dispose(),
                        y.material.dispose(),
                        u.toneMapping = m,
                        u.autoClear = f,
                        e.background = A
                    }
                    _textureToCubeUV(e, t) {
                        const n = this._renderer
                          , i = e.mapping === Qc || e.mapping === ih;
                        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Z2()),
                        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Q2());
                        const s = i ? this._cubemapMaterial : this._equirectMaterial
                          , a = new oi(this._lodPlanes[0],s)
                          , o = s.uniforms;
                        o.envMap.value = e;
                        const c = this._cubeSize;
                        MS(t, 0, 0, 3 * c, 2 * c),
                        n.setRenderTarget(t),
                        n.render(a, QT)
                    }
                    _applyPMREM(e) {
                        const t = this._renderer
                          , n = t.autoClear;
                        t.autoClear = !1;
                        const i = this._lodPlanes.length;
                        for (let s = 1; s < i; s++) {
                            const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
                              , o = q2[(i - s - 1) % q2.length];
                            this._blur(e, s - 1, s, a, o)
                        }
                        t.autoClear = n
                    }
                    _blur(e, t, n, i, s) {
                        const a = this._pingPongRenderTarget;
                        this._halfBlur(e, a, t, n, i, "latitudinal", s),
                        this._halfBlur(a, e, n, n, i, "longitudinal", s)
                    }
                    _halfBlur(e, t, n, i, s, a, o) {
                        const c = this._renderer
                          , u = this._blurMaterial;
                        a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                        const f = 3
                          , m = new oi(this._lodPlanes[i],u)
                          , v = u.uniforms
                          , y = this._sizeLods[n] - 1
                          , S = isFinite(s) ? Math.PI / (2 * y) : 2 * Math.PI / (2 * Ff - 1)
                          , A = s / S
                          , M = isFinite(s) ? 1 + Math.floor(f * A) : Ff;
                        M > Ff && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${Ff}`);
                        const x = [];
                        let T = 0;
                        for (let L = 0; L < Ff; ++L) {
                            const N = L / A
                              , z = Math.exp(-N * N / 2);
                            x.push(z),
                            L === 0 ? T += z : L < M && (T += 2 * z)
                        }
                        for (let L = 0; L < x.length; L++)
                            x[L] = x[L] / T;
                        v.envMap.value = e.texture,
                        v.samples.value = M,
                        v.weights.value = x,
                        v.latitudinal.value = a === "latitudinal",
                        o && (v.poleAxis.value = o);
                        const {_lodMax: D} = this;
                        v.dTheta.value = S,
                        v.mipInt.value = D - n;
                        const w = this._sizeLods[i]
                          , U = 3 * w * (i > D - Zp ? i - D + Zp : 0)
                          , O = 4 * (this._cubeSize - w);
                        MS(t, U, O, 3 * w, 2 * w),
                        c.setRenderTarget(t),
                        c.render(m, QT)
                    }
                }
                ;
                function OP(e) {
                    const t = []
                      , n = []
                      , i = [];
                    let s = e;
                    const a = e - Zp + 1 + W2.length;
                    for (let o = 0; o < a; o++) {
                        const c = Math.pow(2, s);
                        n.push(c);
                        let u = 1 / c;
                        o > e - Zp ? u = W2[o - e + Zp - 1] : o === 0 && (u = 0),
                        i.push(u);
                        const f = 1 / (c - 2)
                          , m = -f
                          , v = 1 + f
                          , y = [m, m, v, m, v, v, m, m, v, v, m, v]
                          , S = 6
                          , A = 6
                          , M = 3
                          , x = 2
                          , T = 1
                          , D = new Float32Array(M * A * S)
                          , w = new Float32Array(x * A * S)
                          , U = new Float32Array(T * A * S);
                        for (let L = 0; L < S; L++) {
                            const N = L % 3 * 2 / 3 - 1
                              , z = L > 2 ? 0 : -1
                              , I = [N, z, 0, N + 2 / 3, z, 0, N + 2 / 3, z + 1, 0, N, z, 0, N + 2 / 3, z + 1, 0, N, z + 1, 0];
                            D.set(I, M * A * L),
                            w.set(y, x * A * L);
                            const B = [L, L, L, L, L, L];
                            U.set(B, T * A * L)
                        }
                        const O = new sn;
                        O.setAttribute("position", new Ln(D,M)),
                        O.setAttribute("uv", new Ln(w,x)),
                        O.setAttribute("faceIndex", new Ln(U,T)),
                        t.push(O),
                        s > Zp && s--
                    }
                    return {
                        lodPlanes: t,
                        sizeLods: n,
                        sigmas: i
                    }
                }
                function j2(e, t, n) {
                    const i = new Vn(e,t,n);
                    return i.texture.mapping = dp,
                    i.texture.name = "PMREM.cubeUv",
                    i.scissorTest = !0,
                    i
                }
                function MS(e, t, n, i, s) {
                    e.viewport.set(t, n, i, s),
                    e.scissor.set(t, n, i, s)
                }
                function NP(e, t, n) {
                    const i = new Float32Array(Ff)
                      , s = new ae(0,1,0);
                    return new kn({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: Ff,
                            CUBEUV_TEXEL_WIDTH: 1 / t,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${e}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: i
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: s
                            }
                        },
                        vertexShader: tM(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                        blending: pi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function Q2() {
                    return new kn({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            }
                        },
                        vertexShader: tM(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                        blending: pi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function Z2() {
                    return new kn({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            }
                        },
                        vertexShader: tM(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                        blending: pi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function tM() {
                    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                }
                function BP(e) {
                    let t = new WeakMap
                      , n = null;
                    function i(c) {
                        if (c && c.isTexture) {
                            const u = c.mapping
                              , f = u === fp || u === ng
                              , m = u === Qc || u === ih;
                            if (f || m) {
                                let v = t.get(c);
                                const y = v !== void 0 ? v.texture.pmremVersion : 0;
                                if (c.isRenderTargetTexture && c.pmremVersion !== y)
                                    return n === null && (n = new eM(e)),
                                    v = f ? n.fromEquirectangular(c, v) : n.fromCubemap(c, v),
                                    v.texture.pmremVersion = c.pmremVersion,
                                    t.set(c, v),
                                    v.texture;
                                if (v !== void 0)
                                    return v.texture;
                                {
                                    const S = c.image;
                                    return f && S && S.height > 0 || m && S && s(S) ? (n === null && (n = new eM(e)),
                                    v = f ? n.fromEquirectangular(c) : n.fromCubemap(c),
                                    v.texture.pmremVersion = c.pmremVersion,
                                    t.set(c, v),
                                    c.addEventListener("dispose", a),
                                    v.texture) : null
                                }
                            }
                        }
                        return c
                    }
                    function s(c) {
                        let u = 0;
                        const f = 6;
                        for (let m = 0; m < f; m++)
                            c[m] !== void 0 && u++;
                        return u === f
                    }
                    function a(c) {
                        const u = c.target;
                        u.removeEventListener("dispose", a);
                        const f = t.get(u);
                        f !== void 0 && (t.delete(u),
                        f.dispose())
                    }
                    function o() {
                        t = new WeakMap,
                        n !== null && (n.dispose(),
                        n = null)
                    }
                    return {
                        get: i,
                        dispose: o
                    }
                }
                function LP(e) {
                    const t = {};
                    function n(i) {
                        if (t[i] !== void 0)
                            return t[i];
                        let s;
                        switch (i) {
                        case "WEBGL_depth_texture":
                            s = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            s = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            s = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            s = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            s = e.getExtension(i)
                        }
                        return t[i] = s,
                        s
                    }
                    return {
                        has: function(i) {
                            return n(i) !== null
                        },
                        init: function() {
                            n("EXT_color_buffer_float"),
                            n("WEBGL_clip_cull_distance"),
                            n("OES_texture_float_linear"),
                            n("EXT_color_buffer_half_float"),
                            n("WEBGL_multisampled_render_to_texture"),
                            n("WEBGL_render_shared_exponent")
                        },
                        get: function(i) {
                            const s = n(i);
                            return s === null && vg("THREE.WebGLRenderer: " + i + " extension not supported."),
                            s
                        }
                    }
                }
                function IP(e, t, n, i) {
                    const s = {}
                      , a = new WeakMap;
                    function o(v) {
                        const y = v.target;
                        y.index !== null && t.remove(y.index);
                        for (const A in y.attributes)
                            t.remove(y.attributes[A]);
                        y.removeEventListener("dispose", o),
                        delete s[y.id];
                        const S = a.get(y);
                        S && (t.remove(S),
                        a.delete(y)),
                        i.releaseStatesOfGeometry(y),
                        y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount,
                        n.memory.geometries--
                    }
                    function c(v, y) {
                        return s[y.id] === !0 || (y.addEventListener("dispose", o),
                        s[y.id] = !0,
                        n.memory.geometries++),
                        y
                    }
                    function u(v) {
                        const y = v.attributes;
                        for (const S in y)
                            t.update(y[S], e.ARRAY_BUFFER)
                    }
                    function f(v) {
                        const y = []
                          , S = v.index
                          , A = v.attributes.position;
                        let M = 0;
                        if (S !== null) {
                            const D = S.array;
                            M = S.version;
                            for (let w = 0, U = D.length; w < U; w += 3) {
                                const O = D[w + 0]
                                  , L = D[w + 1]
                                  , N = D[w + 2];
                                y.push(O, L, L, N, N, O)
                            }
                        } else if (A !== void 0) {
                            const D = A.array;
                            M = A.version;
                            for (let w = 0, U = D.length / 3 - 1; w < U; w += 3) {
                                const O = w + 0
                                  , L = w + 1
                                  , N = w + 2;
                                y.push(O, L, L, N, N, O)
                            }
                        } else
                            return;
                        const x = new (_C(y) ? QA : jA)(y,1);
                        x.version = M;
                        const T = a.get(v);
                        T && t.remove(T),
                        a.set(v, x)
                    }
                    function m(v) {
                        const y = a.get(v);
                        if (y) {
                            const S = v.index;
                            S !== null && y.version < S.version && f(v)
                        } else
                            f(v);
                        return a.get(v)
                    }
                    return {
                        get: c,
                        update: u,
                        getWireframeAttribute: m
                    }
                }
                function PP(e, t, n) {
                    let i;
                    function s(y) {
                        i = y
                    }
                    let a, o;
                    function c(y) {
                        a = y.type,
                        o = y.bytesPerElement
                    }
                    function u(y, S) {
                        e.drawElements(i, S, a, y * o),
                        n.update(S, i, 1)
                    }
                    function f(y, S, A) {
                        A !== 0 && (e.drawElementsInstanced(i, S, a, y * o, A),
                        n.update(S, i, A))
                    }
                    function m(y, S, A) {
                        if (A === 0)
                            return;
                        t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, S, 0, a, y, 0, A);
                        let M = 0;
                        for (let x = 0; x < A; x++)
                            M += S[x];
                        n.update(M, i, 1)
                    }
                    function v(y, S, A, M) {
                        if (A === 0)
                            return;
                        const x = t.get("WEBGL_multi_draw");
                        if (x === null)
                            for (let T = 0; T < y.length; T++)
                                f(y[T] / o, S[T], M[T]);
                        else {
                            x.multiDrawElementsInstancedWEBGL(i, S, 0, a, y, 0, M, 0, A);
                            let T = 0;
                            for (let D = 0; D < A; D++)
                                T += S[D] * M[D];
                            n.update(T, i, 1)
                        }
                    }
                    this.setMode = s,
                    this.setIndex = c,
                    this.render = u,
                    this.renderInstances = f,
                    this.renderMultiDraw = m,
                    this.renderMultiDrawInstances = v
                }
                function zP(e) {
                    const t = {
                        geometries: 0,
                        textures: 0
                    }
                      , n = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    function i(a, o, c) {
                        switch (n.calls++,
                        o) {
                        case e.TRIANGLES:
                            n.triangles += c * (a / 3);
                            break;
                        case e.LINES:
                            n.lines += c * (a / 2);
                            break;
                        case e.LINE_STRIP:
                            n.lines += c * (a - 1);
                            break;
                        case e.LINE_LOOP:
                            n.lines += c * a;
                            break;
                        case e.POINTS:
                            n.points += c * a;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                            break
                        }
                    }
                    function s() {
                        n.calls = 0,
                        n.triangles = 0,
                        n.points = 0,
                        n.lines = 0
                    }
                    return {
                        memory: t,
                        render: n,
                        programs: null,
                        autoReset: !0,
                        reset: s,
                        update: i
                    }
                }
                function FP(e, t, n) {
                    const i = new WeakMap
                      , s = new hn;
                    function a(o, c, u) {
                        const f = o.morphTargetInfluences
                          , m = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
                          , v = m !== void 0 ? m.length : 0;
                        let y = i.get(c);
                        if (y === void 0 || y.count !== v) {
                            let B = function() {
                                z.dispose(),
                                i.delete(c),
                                c.removeEventListener("dispose", B)
                            };
                            var S = B;
                            y !== void 0 && y.texture.dispose();
                            const A = c.morphAttributes.position !== void 0
                              , M = c.morphAttributes.normal !== void 0
                              , x = c.morphAttributes.color !== void 0
                              , T = c.morphAttributes.position || []
                              , D = c.morphAttributes.normal || []
                              , w = c.morphAttributes.color || [];
                            let U = 0;
                            A === !0 && (U = 1),
                            M === !0 && (U = 2),
                            x === !0 && (U = 3);
                            let O = c.attributes.position.count * U
                              , L = 1;
                            O > t.maxTextureSize && (L = Math.ceil(O / t.maxTextureSize),
                            O = t.maxTextureSize);
                            const N = new Float32Array(O * L * 4 * v)
                              , z = new T_(N,O,L,v);
                            z.type = na,
                            z.needsUpdate = !0;
                            const I = U * 4;
                            for (let G = 0; G < v; G++) {
                                const X = T[G]
                                  , q = D[G]
                                  , Q = w[G]
                                  , oe = O * L * 4 * G;
                                for (let k = 0; k < X.count; k++) {
                                    const W = k * I;
                                    A === !0 && (s.fromBufferAttribute(X, k),
                                    N[oe + W + 0] = s.x,
                                    N[oe + W + 1] = s.y,
                                    N[oe + W + 2] = s.z,
                                    N[oe + W + 3] = 0),
                                    M === !0 && (s.fromBufferAttribute(q, k),
                                    N[oe + W + 4] = s.x,
                                    N[oe + W + 5] = s.y,
                                    N[oe + W + 6] = s.z,
                                    N[oe + W + 7] = 0),
                                    x === !0 && (s.fromBufferAttribute(Q, k),
                                    N[oe + W + 8] = s.x,
                                    N[oe + W + 9] = s.y,
                                    N[oe + W + 10] = s.z,
                                    N[oe + W + 11] = Q.itemSize === 4 ? s.w : 1)
                                }
                            }
                            y = {
                                count: v,
                                texture: z,
                                size: new Oe(O,L)
                            },
                            i.set(c, y),
                            c.addEventListener("dispose", B)
                        }
                        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
                            u.getUniforms().setValue(e, "morphTexture", o.morphTexture, n);
                        else {
                            let A = 0;
                            for (let x = 0; x < f.length; x++)
                                A += f[x];
                            const M = c.morphTargetsRelative ? 1 : 1 - A;
                            u.getUniforms().setValue(e, "morphTargetBaseInfluence", M),
                            u.getUniforms().setValue(e, "morphTargetInfluences", f)
                        }
                        u.getUniforms().setValue(e, "morphTargetsTexture", y.texture, n),
                        u.getUniforms().setValue(e, "morphTargetsTextureSize", y.size)
                    }
                    return {
                        update: a
                    }
                }
                function HP(e, t, n, i) {
                    let s = new WeakMap;
                    function a(u) {
                        const f = i.render.frame
                          , m = u.geometry
                          , v = t.get(u, m);
                        if (s.get(v) !== f && (t.update(v),
                        s.set(v, f)),
                        u.isInstancedMesh && (u.hasEventListener("dispose", c) === !1 && u.addEventListener("dispose", c),
                        s.get(u) !== f && (n.update(u.instanceMatrix, e.ARRAY_BUFFER),
                        u.instanceColor !== null && n.update(u.instanceColor, e.ARRAY_BUFFER),
                        s.set(u, f))),
                        u.isSkinnedMesh) {
                            const y = u.skeleton;
                            s.get(y) !== f && (y.update(),
                            s.set(y, f))
                        }
                        return v
                    }
                    function o() {
                        s = new WeakMap
                    }
                    function c(u) {
                        const f = u.target;
                        f.removeEventListener("dispose", c),
                        n.remove(f.instanceMatrix),
                        f.instanceColor !== null && n.remove(f.instanceColor)
                    }
                    return {
                        update: a,
                        dispose: o
                    }
                }
                const K2 = new Fi
                  , J2 = new Og(1,1)
                  , $2 = new T_
                  , e1 = new M_
                  , t1 = new Tg
                  , n1 = []
                  , i1 = []
                  , s1 = new Float32Array(16)
                  , a1 = new Float32Array(9)
                  , r1 = new Float32Array(4);
                function Jp(e, t, n) {
                    const i = e[0];
                    if (i <= 0 || i > 0)
                        return e;
                    const s = t * n;
                    let a = n1[s];
                    if (a === void 0 && (a = new Float32Array(s),
                    n1[s] = a),
                    t !== 0) {
                        i.toArray(a, 0);
                        for (let o = 1, c = 0; o !== t; ++o)
                            c += n,
                            e[o].toArray(a, c)
                    }
                    return a
                }
                function Rs(e, t) {
                    if (e.length !== t.length)
                        return !1;
                    for (let n = 0, i = e.length; n < i; n++)
                        if (e[n] !== t[n])
                            return !1;
                    return !0
                }
                function Us(e, t) {
                    for (let n = 0, i = t.length; n < i; n++)
                        e[n] = t[n]
                }
                function bS(e, t) {
                    let n = i1[t];
                    n === void 0 && (n = new Int32Array(t),
                    i1[t] = n);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e.allocateTextureUnit();
                    return n
                }
                function GP(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1f(this.addr, t),
                    n[0] = t)
                }
                function VP(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform2fv(this.addr, t),
                        Us(n, t)
                    }
                }
                function kP(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else if (t.r !== void 0)
                        (n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b),
                        n[0] = t.r,
                        n[1] = t.g,
                        n[2] = t.b);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform3fv(this.addr, t),
                        Us(n, t)
                    }
                }
                function XP(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform4fv(this.addr, t),
                        Us(n, t)
                    }
                }
                function WP(e, t) {
                    const n = this.cache
                      , i = t.elements;
                    if (i === void 0) {
                        if (Rs(n, t))
                            return;
                        e.uniformMatrix2fv(this.addr, !1, t),
                        Us(n, t)
                    } else {
                        if (Rs(n, i))
                            return;
                        r1.set(i),
                        e.uniformMatrix2fv(this.addr, !1, r1),
                        Us(n, i)
                    }
                }
                function YP(e, t) {
                    const n = this.cache
                      , i = t.elements;
                    if (i === void 0) {
                        if (Rs(n, t))
                            return;
                        e.uniformMatrix3fv(this.addr, !1, t),
                        Us(n, t)
                    } else {
                        if (Rs(n, i))
                            return;
                        a1.set(i),
                        e.uniformMatrix3fv(this.addr, !1, a1),
                        Us(n, i)
                    }
                }
                function qP(e, t) {
                    const n = this.cache
                      , i = t.elements;
                    if (i === void 0) {
                        if (Rs(n, t))
                            return;
                        e.uniformMatrix4fv(this.addr, !1, t),
                        Us(n, t)
                    } else {
                        if (Rs(n, i))
                            return;
                        s1.set(i),
                        e.uniformMatrix4fv(this.addr, !1, s1),
                        Us(n, i)
                    }
                }
                function jP(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1i(this.addr, t),
                    n[0] = t)
                }
                function QP(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform2iv(this.addr, t),
                        Us(n, t)
                    }
                }
                function ZP(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform3iv(this.addr, t),
                        Us(n, t)
                    }
                }
                function KP(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform4iv(this.addr, t),
                        Us(n, t)
                    }
                }
                function JP(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1ui(this.addr, t),
                    n[0] = t)
                }
                function $P(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform2uiv(this.addr, t),
                        Us(n, t)
                    }
                }
                function e4(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform3uiv(this.addr, t),
                        Us(n, t)
                    }
                }
                function t4(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (Rs(n, t))
                            return;
                        e.uniform4uiv(this.addr, t),
                        Us(n, t)
                    }
                }
                function n4(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s);
                    let a;
                    this.type === e.SAMPLER_2D_SHADOW ? (J2.compareFunction = EA,
                    a = J2) : a = K2,
                    n.setTexture2D(t || a, s)
                }
                function i4(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s),
                    n.setTexture3D(t || e1, s)
                }
                function s4(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s),
                    n.setTextureCube(t || t1, s)
                }
                function a4(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s),
                    n.setTexture2DArray(t || $2, s)
                }
                function r4(e) {
                    switch (e) {
                    case 5126:
                        return GP;
                    case 35664:
                        return VP;
                    case 35665:
                        return kP;
                    case 35666:
                        return XP;
                    case 35674:
                        return WP;
                    case 35675:
                        return YP;
                    case 35676:
                        return qP;
                    case 5124:
                    case 35670:
                        return jP;
                    case 35667:
                    case 35671:
                        return QP;
                    case 35668:
                    case 35672:
                        return ZP;
                    case 35669:
                    case 35673:
                        return KP;
                    case 5125:
                        return JP;
                    case 36294:
                        return $P;
                    case 36295:
                        return e4;
                    case 36296:
                        return t4;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return n4;
                    case 35679:
                    case 36299:
                    case 36307:
                        return i4;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return s4;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return a4
                    }
                }
                function o4(e, t) {
                    e.uniform1fv(this.addr, t)
                }
                function l4(e, t) {
                    const n = Jp(t, this.size, 2);
                    e.uniform2fv(this.addr, n)
                }
                function c4(e, t) {
                    const n = Jp(t, this.size, 3);
                    e.uniform3fv(this.addr, n)
                }
                function u4(e, t) {
                    const n = Jp(t, this.size, 4);
                    e.uniform4fv(this.addr, n)
                }
                function h4(e, t) {
                    const n = Jp(t, this.size, 4);
                    e.uniformMatrix2fv(this.addr, !1, n)
                }
                function f4(e, t) {
                    const n = Jp(t, this.size, 9);
                    e.uniformMatrix3fv(this.addr, !1, n)
                }
                function d4(e, t) {
                    const n = Jp(t, this.size, 16);
                    e.uniformMatrix4fv(this.addr, !1, n)
                }
                function p4(e, t) {
                    e.uniform1iv(this.addr, t)
                }
                function m4(e, t) {
                    e.uniform2iv(this.addr, t)
                }
                function v4(e, t) {
                    e.uniform3iv(this.addr, t)
                }
                function g4(e, t) {
                    e.uniform4iv(this.addr, t)
                }
                function y4(e, t) {
                    e.uniform1uiv(this.addr, t)
                }
                function _4(e, t) {
                    e.uniform2uiv(this.addr, t)
                }
                function S4(e, t) {
                    e.uniform3uiv(this.addr, t)
                }
                function x4(e, t) {
                    e.uniform4uiv(this.addr, t)
                }
                function A4(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , a = bS(n, s);
                    Rs(i, a) || (e.uniform1iv(this.addr, a),
                    Us(i, a));
                    for (let o = 0; o !== s; ++o)
                        n.setTexture2D(t[o] || K2, a[o])
                }
                function T4(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , a = bS(n, s);
                    Rs(i, a) || (e.uniform1iv(this.addr, a),
                    Us(i, a));
                    for (let o = 0; o !== s; ++o)
                        n.setTexture3D(t[o] || e1, a[o])
                }
                function M4(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , a = bS(n, s);
                    Rs(i, a) || (e.uniform1iv(this.addr, a),
                    Us(i, a));
                    for (let o = 0; o !== s; ++o)
                        n.setTextureCube(t[o] || t1, a[o])
                }
                function b4(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , a = bS(n, s);
                    Rs(i, a) || (e.uniform1iv(this.addr, a),
                    Us(i, a));
                    for (let o = 0; o !== s; ++o)
                        n.setTexture2DArray(t[o] || $2, a[o])
                }
                function E4(e) {
                    switch (e) {
                    case 5126:
                        return o4;
                    case 35664:
                        return l4;
                    case 35665:
                        return c4;
                    case 35666:
                        return u4;
                    case 35674:
                        return h4;
                    case 35675:
                        return f4;
                    case 35676:
                        return d4;
                    case 5124:
                    case 35670:
                        return p4;
                    case 35667:
                    case 35671:
                        return m4;
                    case 35668:
                    case 35672:
                        return v4;
                    case 35669:
                    case 35673:
                        return g4;
                    case 5125:
                        return y4;
                    case 36294:
                        return _4;
                    case 36295:
                        return S4;
                    case 36296:
                        return x4;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return A4;
                    case 35679:
                    case 36299:
                    case 36307:
                        return T4;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return M4;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return b4
                    }
                }
                var C4 = class {
                    constructor(e, t, n) {
                        this.id = e,
                        this.addr = n,
                        this.cache = [],
                        this.type = t.type,
                        this.setValue = r4(t.type)
                    }
                }
                  , w4 = class {
                    constructor(e, t, n) {
                        this.id = e,
                        this.addr = n,
                        this.cache = [],
                        this.type = t.type,
                        this.size = t.size,
                        this.setValue = E4(t.type)
                    }
                }
                  , D4 = class {
                    constructor(e) {
                        this.id = e,
                        this.seq = [],
                        this.map = {}
                    }
                    setValue(e, t, n) {
                        const i = this.seq;
                        for (let s = 0, a = i.length; s !== a; ++s) {
                            const o = i[s];
                            o.setValue(e, t[o.id], n)
                        }
                    }
                }
                ;
                const nM = /(\w+)(\])?(\[|\.)?/g;
                function o1(e, t) {
                    e.seq.push(t),
                    e.map[t.id] = t
                }
                function R4(e, t, n) {
                    const i = e.name
                      , s = i.length;
                    for (nM.lastIndex = 0; ; ) {
                        const a = nM.exec(i)
                          , o = nM.lastIndex;
                        let c = a[1];
                        const u = a[2] === "]"
                          , f = a[3];
                        if (u && (c = c | 0),
                        f === void 0 || f === "[" && o + 2 === s) {
                            o1(n, f === void 0 ? new C4(c,e,t) : new w4(c,e,t));
                            break
                        } else {
                            let m = n.map[c];
                            m === void 0 && (m = new D4(c),
                            o1(n, m)),
                            n = m
                        }
                    }
                }
                var ES = class {
                    constructor(e, t) {
                        this.seq = [],
                        this.map = {};
                        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                        for (let i = 0; i < n; ++i) {
                            const s = e.getActiveUniform(t, i)
                              , a = e.getUniformLocation(t, s.name);
                            R4(s, a, this)
                        }
                    }
                    setValue(e, t, n, i) {
                        const s = this.map[t];
                        s !== void 0 && s.setValue(e, n, i)
                    }
                    setOptional(e, t, n) {
                        const i = t[n];
                        i !== void 0 && this.setValue(e, n, i)
                    }
                    static upload(e, t, n, i) {
                        for (let s = 0, a = t.length; s !== a; ++s) {
                            const o = t[s]
                              , c = n[o.id];
                            c.needsUpdate !== !1 && o.setValue(e, c.value, i)
                        }
                    }
                    static seqWithValue(e, t) {
                        const n = [];
                        for (let i = 0, s = e.length; i !== s; ++i) {
                            const a = e[i];
                            a.id in t && n.push(a)
                        }
                        return n
                    }
                }
                ;
                function l1(e, t, n) {
                    const i = e.createShader(t);
                    return e.shaderSource(i, n),
                    e.compileShader(i),
                    i
                }
                const U4 = 37297;
                let O4 = 0;
                function N4(e, t) {
                    const n = e.split(`
`)
                      , i = []
                      , s = Math.max(t - 6, 0)
                      , a = Math.min(t + 6, n.length);
                    for (let o = s; o < a; o++) {
                        const c = o + 1;
                        i.push(`${c === t ? ">" : " "} ${c}: ${n[o]}`)
                    }
                    return i.join(`
`)
                }
                const c1 = new nn;
                function B4(e) {
                    Rn._getMatrix(c1, Rn.workingColorSpace, e);
                    const t = `mat3( ${c1.elements.map(n => n.toFixed(4))} )`;
                    switch (Rn.getTransfer(e)) {
                    case fg:
                        return [t, "LinearTransferOETF"];
                    case Jn:
                        return [t, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space: ", e),
                        [t, "LinearTransferOETF"]
                    }
                }
                function u1(e, t, n) {
                    const i = e.getShaderParameter(t, e.COMPILE_STATUS)
                      , s = (e.getShaderInfoLog(t) || "").trim();
                    if (i && s === "")
                        return "";
                    const a = /ERROR: 0:(\d+)/.exec(s);
                    if (a) {
                        const o = parseInt(a[1]);
                        return n.toUpperCase() + `

` + s + `

` + N4(e.getShaderSource(t), o)
                    } else
                        return s
                }
                function L4(e, t) {
                    const n = B4(t);
                    return [`vec4 ${e}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
                }
                function I4(e, t) {
                    let n;
                    switch (t) {
                    case $E:
                        n = "Linear";
                        break;
                    case eC:
                        n = "Reinhard";
                        break;
                    case tC:
                        n = "Cineon";
                        break;
                    case mA:
                        n = "ACESFilmic";
                        break;
                    case iC:
                        n = "AgX";
                        break;
                    case sC:
                        n = "Neutral";
                        break;
                    case nC:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                        n = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }
                const CS = new ae;
                function P4() {
                    Rn.getLuminanceCoefficients(CS);
                    const e = CS.x.toFixed(4)
                      , t = CS.y.toFixed(4)
                      , n = CS.z.toFixed(4);
                    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${e}, ${t}, ${n} );`, "	return dot( weights, rgb );", "}"].join(`
`)
                }
                function z4(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(jg).join(`
`)
                }
                function F4(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        i !== !1 && t.push("#define " + n + " " + i)
                    }
                    return t.join(`
`)
                }
                function H4(e, t) {
                    const n = {}
                      , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let s = 0; s < i; s++) {
                        const a = e.getActiveAttrib(t, s)
                          , o = a.name;
                        let c = 1;
                        a.type === e.FLOAT_MAT2 && (c = 2),
                        a.type === e.FLOAT_MAT3 && (c = 3),
                        a.type === e.FLOAT_MAT4 && (c = 4),
                        n[o] = {
                            type: a.type,
                            location: e.getAttribLocation(t, o),
                            locationSize: c
                        }
                    }
                    return n
                }
                function jg(e) {
                    return e !== ""
                }
                function h1(e, t) {
                    const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
                }
                function f1(e, t) {
                    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
                }
                const G4 = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function iM(e) {
                    return e.replace(G4, k4)
                }
                const V4 = new Map;
                function k4(e, t) {
                    let n = an[t];
                    if (n === void 0) {
                        const i = V4.get(t);
                        if (i !== void 0)
                            n = an[i],
                            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, i);
                        else
                            throw new Error("Can not resolve #include <" + t + ">")
                    }
                    return iM(n)
                }
                const X4 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function d1(e) {
                    return e.replace(X4, W4)
                }
                function W4(e, t, n, i) {
                    let s = "";
                    for (let a = parseInt(t); a < parseInt(n); a++)
                        s += i.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
                    return s
                }
                function p1(e) {
                    let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`;
                    return e.precision === "highp" ? t += `
#define HIGH_PRECISION` : e.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : e.precision === "lowp" && (t += `
#define LOW_PRECISION`),
                    t
                }
                function Y4(e) {
                    let t = "SHADOWMAP_TYPE_BASIC";
                    return e.shadowMapType === Iy ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === Zv ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === sl && (t = "SHADOWMAP_TYPE_VSM"),
                    t
                }
                function q4(e) {
                    let t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap)
                        switch (e.envMapMode) {
                        case Qc:
                        case ih:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case dp:
                            t = "ENVMAP_TYPE_CUBE_UV";
                            break
                        }
                    return t
                }
                function j4(e) {
                    let t = "ENVMAP_MODE_REFLECTION";
                    if (e.envMap)
                        switch (e.envMapMode) {
                        case ih:
                            t = "ENVMAP_MODE_REFRACTION";
                            break
                        }
                    return t
                }
                function Q4(e) {
                    let t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap)
                        switch (e.combine) {
                        case tg:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case KE:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case JE:
                            t = "ENVMAP_BLENDING_ADD";
                            break
                        }
                    return t
                }
                function Z4(e) {
                    const t = e.envMapCubeUVHeight;
                    if (t === null)
                        return null;
                    const n = Math.log2(t) - 2
                      , i = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }
                function K4(e, t, n, i) {
                    const s = e.getContext()
                      , a = n.defines;
                    let o = n.vertexShader
                      , c = n.fragmentShader;
                    const u = Y4(n)
                      , f = q4(n)
                      , m = j4(n)
                      , v = Q4(n)
                      , y = Z4(n)
                      , S = z4(n)
                      , A = F4(a)
                      , M = s.createProgram();
                    let x, T, D = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
                    n.isRawShaderMaterial ? (x = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A].filter(jg).join(`
`),
                    x.length > 0 && (x += `
`),
                    T = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A].filter(jg).join(`
`),
                    T.length > 0 && (T += `
`)) : (x = [p1(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(jg).join(`
`),
                    T = [p1(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, A, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + v : "", y ? "#define CUBEUV_TEXEL_WIDTH " + y.texelWidth : "", y ? "#define CUBEUV_TEXEL_HEIGHT " + y.texelHeight : "", y ? "#define CUBEUV_MAX_MIP " + y.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== al ? "#define TONE_MAPPING" : "", n.toneMapping !== al ? an.tonemapping_pars_fragment : "", n.toneMapping !== al ? I4("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", an.colorspace_pars_fragment, L4("linearToOutputTexel", n.outputColorSpace), P4(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(jg).join(`
`)),
                    o = iM(o),
                    o = h1(o, n),
                    o = f1(o, n),
                    c = iM(c),
                    c = h1(c, n),
                    c = f1(c, n),
                    o = d1(o),
                    c = d1(c),
                    n.isRawShaderMaterial !== !0 && (D = `#version 300 es
`,
                    x = [S, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + x,
                    T = ["#define varying in", n.glslVersion === CA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === CA ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + T);
                    const w = D + x + o
                      , U = D + T + c
                      , O = l1(s, s.VERTEX_SHADER, w)
                      , L = l1(s, s.FRAGMENT_SHADER, U);
                    s.attachShader(M, O),
                    s.attachShader(M, L),
                    n.index0AttributeName !== void 0 ? s.bindAttribLocation(M, 0, n.index0AttributeName) : n.morphTargets === !0 && s.bindAttribLocation(M, 0, "position"),
                    s.linkProgram(M);
                    function N(G) {
                        if (e.debug.checkShaderErrors) {
                            const X = s.getProgramInfoLog(M) || ""
                              , q = s.getShaderInfoLog(O) || ""
                              , Q = s.getShaderInfoLog(L) || ""
                              , oe = X.trim()
                              , k = q.trim()
                              , W = Q.trim();
                            let V = !0
                              , Z = !0;
                            if (s.getProgramParameter(M, s.LINK_STATUS) === !1)
                                if (V = !1,
                                typeof e.debug.onShaderError == "function")
                                    e.debug.onShaderError(s, M, O, L);
                                else {
                                    const j = u1(s, O, "vertex")
                                      , ee = u1(s, L, "fragment");
                                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(M, s.VALIDATE_STATUS) + `

Material Name: ` + G.name + `
Material Type: ` + G.type + `

Program Info Log: ` + oe + `
` + j + `
` + ee)
                                }
                            else
                                oe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", oe) : (k === "" || W === "") && (Z = !1);
                            Z && (G.diagnostics = {
                                runnable: V,
                                programLog: oe,
                                vertexShader: {
                                    log: k,
                                    prefix: x
                                },
                                fragmentShader: {
                                    log: W,
                                    prefix: T
                                }
                            })
                        }
                        s.deleteShader(O),
                        s.deleteShader(L),
                        z = new ES(s,M),
                        I = H4(s, M)
                    }
                    let z;
                    this.getUniforms = function() {
                        return z === void 0 && N(this),
                        z
                    }
                    ;
                    let I;
                    this.getAttributes = function() {
                        return I === void 0 && N(this),
                        I
                    }
                    ;
                    let B = n.rendererExtensionParallelShaderCompile === !1;
                    return this.isReady = function() {
                        return B === !1 && (B = s.getProgramParameter(M, U4)),
                        B
                    }
                    ,
                    this.destroy = function() {
                        i.releaseStatesOfProgram(this),
                        s.deleteProgram(M),
                        this.program = void 0
                    }
                    ,
                    this.type = n.shaderType,
                    this.name = n.shaderName,
                    this.id = O4++,
                    this.cacheKey = t,
                    this.usedTimes = 1,
                    this.program = M,
                    this.vertexShader = O,
                    this.fragmentShader = L,
                    this
                }
                let J4 = 0;
                var $4 = class {
                    constructor() {
                        this.shaderCache = new Map,
                        this.materialCache = new Map
                    }
                    update(e) {
                        const t = e.vertexShader
                          , n = e.fragmentShader
                          , i = this._getShaderStage(t)
                          , s = this._getShaderStage(n)
                          , a = this._getShaderCacheForMaterial(e);
                        return a.has(i) === !1 && (a.add(i),
                        i.usedTimes++),
                        a.has(s) === !1 && (a.add(s),
                        s.usedTimes++),
                        this
                    }
                    remove(e) {
                        const t = this.materialCache.get(e);
                        for (const n of t)
                            n.usedTimes--,
                            n.usedTimes === 0 && this.shaderCache.delete(n.code);
                        return this.materialCache.delete(e),
                        this
                    }
                    getVertexShaderID(e) {
                        return this._getShaderStage(e.vertexShader).id
                    }
                    getFragmentShaderID(e) {
                        return this._getShaderStage(e.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear(),
                        this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(e) {
                        const t = this.materialCache;
                        let n = t.get(e);
                        return n === void 0 && (n = new Set,
                        t.set(e, n)),
                        n
                    }
                    _getShaderStage(e) {
                        const t = this.shaderCache;
                        let n = t.get(e);
                        return n === void 0 && (n = new ez(e),
                        t.set(e, n)),
                        n
                    }
                }
                  , ez = class {
                    constructor(e) {
                        this.id = J4++,
                        this.code = e,
                        this.usedTimes = 0
                    }
                }
                ;
                function tz(e, t, n, i, s, a, o) {
                    const c = new wp
                      , u = new $4
                      , f = new Set
                      , m = []
                      , v = s.logarithmicDepthBuffer
                      , y = s.vertexTextures;
                    let S = s.precision;
                    const A = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                    function M(I) {
                        return f.add(I),
                        I === 0 ? "uv" : `uv${I}`
                    }
                    function x(I, B, G, X, q) {
                        const Q = X.fog
                          , oe = q.geometry
                          , k = I.isMeshStandardMaterial ? X.environment : null
                          , W = (I.isMeshStandardMaterial ? n : t).get(I.envMap || k)
                          , V = W && W.mapping === dp ? W.image.height : null
                          , Z = A[I.type];
                        I.precision !== null && (S = s.getMaxPrecision(I.precision),
                        S !== I.precision && console.warn("THREE.WebGLProgram.getParameters:", I.precision, "not supported, using", S, "instead."));
                        const j = oe.morphAttributes.position || oe.morphAttributes.normal || oe.morphAttributes.color
                          , ee = j !== void 0 ? j.length : 0;
                        let H = 0;
                        oe.morphAttributes.position !== void 0 && (H = 1),
                        oe.morphAttributes.normal !== void 0 && (H = 2),
                        oe.morphAttributes.color !== void 0 && (H = 3);
                        let ie, se, K, le;
                        if (Z) {
                            const Ot = fl[Z];
                            ie = Ot.vertexShader,
                            se = Ot.fragmentShader
                        } else
                            ie = I.vertexShader,
                            se = I.fragmentShader,
                            u.update(I),
                            K = u.getVertexShaderID(I),
                            le = u.getFragmentShaderID(I);
                        const ue = e.getRenderTarget()
                          , de = e.state.buffers.depth.getReversed()
                          , qe = q.isInstancedMesh === !0
                          , ze = q.isBatchedMesh === !0
                          , Ee = !!I.map
                          , re = !!I.matcap
                          , Le = !!W
                          , he = !!I.aoMap
                          , ye = !!I.lightMap
                          , xe = !!I.bumpMap
                          , ge = !!I.normalMap
                          , Te = !!I.displacementMap
                          , Ae = !!I.emissiveMap
                          , we = !!I.metalnessMap
                          , it = !!I.roughnessMap
                          , je = I.anisotropy > 0
                          , $ = I.clearcoat > 0
                          , Y = I.dispersion > 0
                          , pe = I.iridescence > 0
                          , He = I.sheen > 0
                          , Re = I.transmission > 0
                          , De = je && !!I.anisotropyMap
                          , rt = $ && !!I.clearcoatMap
                          , $e = $ && !!I.clearcoatNormalMap
                          , ct = $ && !!I.clearcoatRoughnessMap
                          , gt = pe && !!I.iridescenceMap
                          , Ie = pe && !!I.iridescenceThicknessMap
                          , Je = He && !!I.sheenColorMap
                          , Ze = He && !!I.sheenRoughnessMap
                          , ht = !!I.specularMap
                          , lt = !!I.specularColorMap
                          , At = !!I.specularIntensityMap
                          , fe = Re && !!I.transmissionMap
                          , ot = Re && !!I.thicknessMap
                          , tt = !!I.gradientMap
                          , xt = !!I.alphaMap
                          , Qe = I.alphaTest > 0
                          , Ne = !!I.alphaHash
                          , dt = !!I.extensions;
                        let _t = al;
                        I.toneMapped && (ue === null || ue.isXRRenderTarget === !0) && (_t = e.toneMapping);
                        const Ct = {
                            shaderID: Z,
                            shaderType: I.type,
                            shaderName: I.name,
                            vertexShader: ie,
                            fragmentShader: se,
                            defines: I.defines,
                            customVertexShaderID: K,
                            customFragmentShaderID: le,
                            isRawShaderMaterial: I.isRawShaderMaterial === !0,
                            glslVersion: I.glslVersion,
                            precision: S,
                            batching: ze,
                            batchingColor: ze && q._colorsTexture !== null,
                            instancing: qe,
                            instancingColor: qe && q.instanceColor !== null,
                            instancingMorph: qe && q.morphTexture !== null,
                            supportsVertexTextures: y,
                            outputColorSpace: ue === null ? e.outputColorSpace : ue.isXRRenderTarget === !0 ? ue.texture.colorSpace : rc,
                            alphaToCoverage: !!I.alphaToCoverage,
                            map: Ee,
                            matcap: re,
                            envMap: Le,
                            envMapMode: Le && W.mapping,
                            envMapCubeUVHeight: V,
                            aoMap: he,
                            lightMap: ye,
                            bumpMap: xe,
                            normalMap: ge,
                            displacementMap: y && Te,
                            emissiveMap: Ae,
                            normalMapObjectSpace: ge && I.normalMapType === cC,
                            normalMapTangentSpace: ge && I.normalMapType === ah,
                            metalnessMap: we,
                            roughnessMap: it,
                            anisotropy: je,
                            anisotropyMap: De,
                            clearcoat: $,
                            clearcoatMap: rt,
                            clearcoatNormalMap: $e,
                            clearcoatRoughnessMap: ct,
                            dispersion: Y,
                            iridescence: pe,
                            iridescenceMap: gt,
                            iridescenceThicknessMap: Ie,
                            sheen: He,
                            sheenColorMap: Je,
                            sheenRoughnessMap: Ze,
                            specularMap: ht,
                            specularColorMap: lt,
                            specularIntensityMap: At,
                            transmission: Re,
                            transmissionMap: fe,
                            thicknessMap: ot,
                            gradientMap: tt,
                            opaque: I.transparent === !1 && I.blending === uf && I.alphaToCoverage === !1,
                            alphaMap: xt,
                            alphaTest: Qe,
                            alphaHash: Ne,
                            combine: I.combine,
                            mapUv: Ee && M(I.map.channel),
                            aoMapUv: he && M(I.aoMap.channel),
                            lightMapUv: ye && M(I.lightMap.channel),
                            bumpMapUv: xe && M(I.bumpMap.channel),
                            normalMapUv: ge && M(I.normalMap.channel),
                            displacementMapUv: Te && M(I.displacementMap.channel),
                            emissiveMapUv: Ae && M(I.emissiveMap.channel),
                            metalnessMapUv: we && M(I.metalnessMap.channel),
                            roughnessMapUv: it && M(I.roughnessMap.channel),
                            anisotropyMapUv: De && M(I.anisotropyMap.channel),
                            clearcoatMapUv: rt && M(I.clearcoatMap.channel),
                            clearcoatNormalMapUv: $e && M(I.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: ct && M(I.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: gt && M(I.iridescenceMap.channel),
                            iridescenceThicknessMapUv: Ie && M(I.iridescenceThicknessMap.channel),
                            sheenColorMapUv: Je && M(I.sheenColorMap.channel),
                            sheenRoughnessMapUv: Ze && M(I.sheenRoughnessMap.channel),
                            specularMapUv: ht && M(I.specularMap.channel),
                            specularColorMapUv: lt && M(I.specularColorMap.channel),
                            specularIntensityMapUv: At && M(I.specularIntensityMap.channel),
                            transmissionMapUv: fe && M(I.transmissionMap.channel),
                            thicknessMapUv: ot && M(I.thicknessMap.channel),
                            alphaMapUv: xt && M(I.alphaMap.channel),
                            vertexTangents: !!oe.attributes.tangent && (ge || je),
                            vertexColors: I.vertexColors,
                            vertexAlphas: I.vertexColors === !0 && !!oe.attributes.color && oe.attributes.color.itemSize === 4,
                            pointsUvs: q.isPoints === !0 && !!oe.attributes.uv && (Ee || xt),
                            fog: !!Q,
                            useFog: I.fog === !0,
                            fogExp2: !!Q && Q.isFogExp2,
                            flatShading: I.flatShading === !0 && I.wireframe === !1,
                            sizeAttenuation: I.sizeAttenuation === !0,
                            logarithmicDepthBuffer: v,
                            reversedDepthBuffer: de,
                            skinning: q.isSkinnedMesh === !0,
                            morphTargets: oe.morphAttributes.position !== void 0,
                            morphNormals: oe.morphAttributes.normal !== void 0,
                            morphColors: oe.morphAttributes.color !== void 0,
                            morphTargetsCount: ee,
                            morphTextureStride: H,
                            numDirLights: B.directional.length,
                            numPointLights: B.point.length,
                            numSpotLights: B.spot.length,
                            numSpotLightMaps: B.spotLightMap.length,
                            numRectAreaLights: B.rectArea.length,
                            numHemiLights: B.hemi.length,
                            numDirLightShadows: B.directionalShadowMap.length,
                            numPointLightShadows: B.pointShadowMap.length,
                            numSpotLightShadows: B.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps,
                            numLightProbes: B.numLightProbes,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            dithering: I.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && G.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: _t,
                            decodeVideoTexture: Ee && I.map.isVideoTexture === !0 && Rn.getTransfer(I.map.colorSpace) === Jn,
                            decodeVideoTextureEmissive: Ae && I.emissiveMap.isVideoTexture === !0 && Rn.getTransfer(I.emissiveMap.colorSpace) === Jn,
                            premultipliedAlpha: I.premultipliedAlpha,
                            doubleSided: I.side === $a,
                            flipSided: I.side === Ds,
                            useDepthPacking: I.depthPacking >= 0,
                            depthPacking: I.depthPacking || 0,
                            index0AttributeName: I.index0AttributeName,
                            extensionClipCullDistance: dt && I.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (dt && I.extensions.multiDraw === !0 || ze) && i.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: I.customProgramCacheKey()
                        };
                        return Ct.vertexUv1s = f.has(1),
                        Ct.vertexUv2s = f.has(2),
                        Ct.vertexUv3s = f.has(3),
                        f.clear(),
                        Ct
                    }
                    function T(I) {
                        const B = [];
                        if (I.shaderID ? B.push(I.shaderID) : (B.push(I.customVertexShaderID),
                        B.push(I.customFragmentShaderID)),
                        I.defines !== void 0)
                            for (const G in I.defines)
                                B.push(G),
                                B.push(I.defines[G]);
                        return I.isRawShaderMaterial === !1 && (D(B, I),
                        w(B, I),
                        B.push(e.outputColorSpace)),
                        B.push(I.customProgramCacheKey),
                        B.join()
                    }
                    function D(I, B) {
                        I.push(B.precision),
                        I.push(B.outputColorSpace),
                        I.push(B.envMapMode),
                        I.push(B.envMapCubeUVHeight),
                        I.push(B.mapUv),
                        I.push(B.alphaMapUv),
                        I.push(B.lightMapUv),
                        I.push(B.aoMapUv),
                        I.push(B.bumpMapUv),
                        I.push(B.normalMapUv),
                        I.push(B.displacementMapUv),
                        I.push(B.emissiveMapUv),
                        I.push(B.metalnessMapUv),
                        I.push(B.roughnessMapUv),
                        I.push(B.anisotropyMapUv),
                        I.push(B.clearcoatMapUv),
                        I.push(B.clearcoatNormalMapUv),
                        I.push(B.clearcoatRoughnessMapUv),
                        I.push(B.iridescenceMapUv),
                        I.push(B.iridescenceThicknessMapUv),
                        I.push(B.sheenColorMapUv),
                        I.push(B.sheenRoughnessMapUv),
                        I.push(B.specularMapUv),
                        I.push(B.specularColorMapUv),
                        I.push(B.specularIntensityMapUv),
                        I.push(B.transmissionMapUv),
                        I.push(B.thicknessMapUv),
                        I.push(B.combine),
                        I.push(B.fogExp2),
                        I.push(B.sizeAttenuation),
                        I.push(B.morphTargetsCount),
                        I.push(B.morphAttributeCount),
                        I.push(B.numDirLights),
                        I.push(B.numPointLights),
                        I.push(B.numSpotLights),
                        I.push(B.numSpotLightMaps),
                        I.push(B.numHemiLights),
                        I.push(B.numRectAreaLights),
                        I.push(B.numDirLightShadows),
                        I.push(B.numPointLightShadows),
                        I.push(B.numSpotLightShadows),
                        I.push(B.numSpotLightShadowsWithMaps),
                        I.push(B.numLightProbes),
                        I.push(B.shadowMapType),
                        I.push(B.toneMapping),
                        I.push(B.numClippingPlanes),
                        I.push(B.numClipIntersection),
                        I.push(B.depthPacking)
                    }
                    function w(I, B) {
                        c.disableAll(),
                        B.supportsVertexTextures && c.enable(0),
                        B.instancing && c.enable(1),
                        B.instancingColor && c.enable(2),
                        B.instancingMorph && c.enable(3),
                        B.matcap && c.enable(4),
                        B.envMap && c.enable(5),
                        B.normalMapObjectSpace && c.enable(6),
                        B.normalMapTangentSpace && c.enable(7),
                        B.clearcoat && c.enable(8),
                        B.iridescence && c.enable(9),
                        B.alphaTest && c.enable(10),
                        B.vertexColors && c.enable(11),
                        B.vertexAlphas && c.enable(12),
                        B.vertexUv1s && c.enable(13),
                        B.vertexUv2s && c.enable(14),
                        B.vertexUv3s && c.enable(15),
                        B.vertexTangents && c.enable(16),
                        B.anisotropy && c.enable(17),
                        B.alphaHash && c.enable(18),
                        B.batching && c.enable(19),
                        B.dispersion && c.enable(20),
                        B.batchingColor && c.enable(21),
                        B.gradientMap && c.enable(22),
                        I.push(c.mask),
                        c.disableAll(),
                        B.fog && c.enable(0),
                        B.useFog && c.enable(1),
                        B.flatShading && c.enable(2),
                        B.logarithmicDepthBuffer && c.enable(3),
                        B.reversedDepthBuffer && c.enable(4),
                        B.skinning && c.enable(5),
                        B.morphTargets && c.enable(6),
                        B.morphNormals && c.enable(7),
                        B.morphColors && c.enable(8),
                        B.premultipliedAlpha && c.enable(9),
                        B.shadowMapEnabled && c.enable(10),
                        B.doubleSided && c.enable(11),
                        B.flipSided && c.enable(12),
                        B.useDepthPacking && c.enable(13),
                        B.dithering && c.enable(14),
                        B.transmission && c.enable(15),
                        B.sheen && c.enable(16),
                        B.opaque && c.enable(17),
                        B.pointsUvs && c.enable(18),
                        B.decodeVideoTexture && c.enable(19),
                        B.decodeVideoTextureEmissive && c.enable(20),
                        B.alphaToCoverage && c.enable(21),
                        I.push(c.mask)
                    }
                    function U(I) {
                        const B = A[I.type];
                        let G;
                        if (B) {
                            const X = fl[B];
                            G = JA.clone(X.uniforms)
                        } else
                            G = I.uniforms;
                        return G
                    }
                    function O(I, B) {
                        let G;
                        for (let X = 0, q = m.length; X < q; X++) {
                            const Q = m[X];
                            if (Q.cacheKey === B) {
                                G = Q,
                                ++G.usedTimes;
                                break
                            }
                        }
                        return G === void 0 && (G = new K4(e,B,I,a),
                        m.push(G)),
                        G
                    }
                    function L(I) {
                        if (--I.usedTimes === 0) {
                            const B = m.indexOf(I);
                            m[B] = m[m.length - 1],
                            m.pop(),
                            I.destroy()
                        }
                    }
                    function N(I) {
                        u.remove(I)
                    }
                    function z() {
                        u.dispose()
                    }
                    return {
                        getParameters: x,
                        getProgramCacheKey: T,
                        getUniforms: U,
                        acquireProgram: O,
                        releaseProgram: L,
                        releaseShaderCache: N,
                        programs: m,
                        dispose: z
                    }
                }
                function nz() {
                    let e = new WeakMap;
                    function t(o) {
                        return e.has(o)
                    }
                    function n(o) {
                        let c = e.get(o);
                        return c === void 0 && (c = {},
                        e.set(o, c)),
                        c
                    }
                    function i(o) {
                        e.delete(o)
                    }
                    function s(o, c, u) {
                        e.get(o)[c] = u
                    }
                    function a() {
                        e = new WeakMap
                    }
                    return {
                        has: t,
                        get: n,
                        remove: i,
                        update: s,
                        dispose: a
                    }
                }
                function iz(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                }
                function m1(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                }
                function v1() {
                    const e = [];
                    let t = 0;
                    const n = []
                      , i = []
                      , s = [];
                    function a() {
                        t = 0,
                        n.length = 0,
                        i.length = 0,
                        s.length = 0
                    }
                    function o(v, y, S, A, M, x) {
                        let T = e[t];
                        return T === void 0 ? (T = {
                            id: v.id,
                            object: v,
                            geometry: y,
                            material: S,
                            groupOrder: A,
                            renderOrder: v.renderOrder,
                            z: M,
                            group: x
                        },
                        e[t] = T) : (T.id = v.id,
                        T.object = v,
                        T.geometry = y,
                        T.material = S,
                        T.groupOrder = A,
                        T.renderOrder = v.renderOrder,
                        T.z = M,
                        T.group = x),
                        t++,
                        T
                    }
                    function c(v, y, S, A, M, x) {
                        const T = o(v, y, S, A, M, x);
                        S.transmission > 0 ? i.push(T) : S.transparent === !0 ? s.push(T) : n.push(T)
                    }
                    function u(v, y, S, A, M, x) {
                        const T = o(v, y, S, A, M, x);
                        S.transmission > 0 ? i.unshift(T) : S.transparent === !0 ? s.unshift(T) : n.unshift(T)
                    }
                    function f(v, y) {
                        n.length > 1 && n.sort(v || iz),
                        i.length > 1 && i.sort(y || m1),
                        s.length > 1 && s.sort(y || m1)
                    }
                    function m() {
                        for (let v = t, y = e.length; v < y; v++) {
                            const S = e[v];
                            if (S.id === null)
                                break;
                            S.id = null,
                            S.object = null,
                            S.geometry = null,
                            S.material = null,
                            S.group = null
                        }
                    }
                    return {
                        opaque: n,
                        transmissive: i,
                        transparent: s,
                        init: a,
                        push: c,
                        unshift: u,
                        finish: m,
                        sort: f
                    }
                }
                function sz() {
                    let e = new WeakMap;
                    function t(i, s) {
                        const a = e.get(i);
                        let o;
                        return a === void 0 ? (o = new v1,
                        e.set(i, [o])) : s >= a.length ? (o = new v1,
                        a.push(o)) : o = a[s],
                        o
                    }
                    function n() {
                        e = new WeakMap
                    }
                    return {
                        get: t,
                        dispose: n
                    }
                }
                function az() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (e[t.id] !== void 0)
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new ae,
                                    color: new ft
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new ae,
                                    direction: new ae,
                                    color: new ft,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new ae,
                                    color: new ft,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new ae,
                                    skyColor: new ft,
                                    groundColor: new ft
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new ft,
                                    position: new ae,
                                    halfWidth: new ae,
                                    halfHeight: new ae
                                };
                                break
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                function rz() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (e[t.id] !== void 0)
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Oe
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Oe
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Oe,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                let oz = 0;
                function lz(e, t) {
                    return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
                }
                function cz(e) {
                    const t = new az
                      , n = rz()
                      , i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                    for (let f = 0; f < 9; f++)
                        i.probe.push(new ae);
                    const s = new ae
                      , a = new Xt
                      , o = new Xt;
                    function c(f) {
                        let m = 0
                          , v = 0
                          , y = 0;
                        for (let I = 0; I < 9; I++)
                            i.probe[I].set(0, 0, 0);
                        let S = 0
                          , A = 0
                          , M = 0
                          , x = 0
                          , T = 0
                          , D = 0
                          , w = 0
                          , U = 0
                          , O = 0
                          , L = 0
                          , N = 0;
                        f.sort(lz);
                        for (let I = 0, B = f.length; I < B; I++) {
                            const G = f[I]
                              , X = G.color
                              , q = G.intensity
                              , Q = G.distance
                              , oe = G.shadow && G.shadow.map ? G.shadow.map.texture : null;
                            if (G.isAmbientLight)
                                m += X.r * q,
                                v += X.g * q,
                                y += X.b * q;
                            else if (G.isLightProbe) {
                                for (let k = 0; k < 9; k++)
                                    i.probe[k].addScaledVector(G.sh.coefficients[k], q);
                                N++
                            } else if (G.isDirectionalLight) {
                                const k = t.get(G);
                                if (k.color.copy(G.color).multiplyScalar(G.intensity),
                                G.castShadow) {
                                    const W = G.shadow
                                      , V = n.get(G);
                                    V.shadowIntensity = W.intensity,
                                    V.shadowBias = W.bias,
                                    V.shadowNormalBias = W.normalBias,
                                    V.shadowRadius = W.radius,
                                    V.shadowMapSize = W.mapSize,
                                    i.directionalShadow[S] = V,
                                    i.directionalShadowMap[S] = oe,
                                    i.directionalShadowMatrix[S] = G.shadow.matrix,
                                    D++
                                }
                                i.directional[S] = k,
                                S++
                            } else if (G.isSpotLight) {
                                const k = t.get(G);
                                k.position.setFromMatrixPosition(G.matrixWorld),
                                k.color.copy(X).multiplyScalar(q),
                                k.distance = Q,
                                k.coneCos = Math.cos(G.angle),
                                k.penumbraCos = Math.cos(G.angle * (1 - G.penumbra)),
                                k.decay = G.decay,
                                i.spot[M] = k;
                                const W = G.shadow;
                                if (G.map && (i.spotLightMap[O] = G.map,
                                O++,
                                W.updateMatrices(G),
                                G.castShadow && L++),
                                i.spotLightMatrix[M] = W.matrix,
                                G.castShadow) {
                                    const V = n.get(G);
                                    V.shadowIntensity = W.intensity,
                                    V.shadowBias = W.bias,
                                    V.shadowNormalBias = W.normalBias,
                                    V.shadowRadius = W.radius,
                                    V.shadowMapSize = W.mapSize,
                                    i.spotShadow[M] = V,
                                    i.spotShadowMap[M] = oe,
                                    U++
                                }
                                M++
                            } else if (G.isRectAreaLight) {
                                const k = t.get(G);
                                k.color.copy(X).multiplyScalar(q),
                                k.halfWidth.set(G.width * .5, 0, 0),
                                k.halfHeight.set(0, G.height * .5, 0),
                                i.rectArea[x] = k,
                                x++
                            } else if (G.isPointLight) {
                                const k = t.get(G);
                                if (k.color.copy(G.color).multiplyScalar(G.intensity),
                                k.distance = G.distance,
                                k.decay = G.decay,
                                G.castShadow) {
                                    const W = G.shadow
                                      , V = n.get(G);
                                    V.shadowIntensity = W.intensity,
                                    V.shadowBias = W.bias,
                                    V.shadowNormalBias = W.normalBias,
                                    V.shadowRadius = W.radius,
                                    V.shadowMapSize = W.mapSize,
                                    V.shadowCameraNear = W.camera.near,
                                    V.shadowCameraFar = W.camera.far,
                                    i.pointShadow[A] = V,
                                    i.pointShadowMap[A] = oe,
                                    i.pointShadowMatrix[A] = G.shadow.matrix,
                                    w++
                                }
                                i.point[A] = k,
                                A++
                            } else if (G.isHemisphereLight) {
                                const k = t.get(G);
                                k.skyColor.copy(G.color).multiplyScalar(q),
                                k.groundColor.copy(G.groundColor).multiplyScalar(q),
                                i.hemi[T] = k,
                                T++
                            }
                        }
                        x > 0 && (e.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Mt.LTC_FLOAT_1,
                        i.rectAreaLTC2 = Mt.LTC_FLOAT_2) : (i.rectAreaLTC1 = Mt.LTC_HALF_1,
                        i.rectAreaLTC2 = Mt.LTC_HALF_2)),
                        i.ambient[0] = m,
                        i.ambient[1] = v,
                        i.ambient[2] = y;
                        const z = i.hash;
                        (z.directionalLength !== S || z.pointLength !== A || z.spotLength !== M || z.rectAreaLength !== x || z.hemiLength !== T || z.numDirectionalShadows !== D || z.numPointShadows !== w || z.numSpotShadows !== U || z.numSpotMaps !== O || z.numLightProbes !== N) && (i.directional.length = S,
                        i.spot.length = M,
                        i.rectArea.length = x,
                        i.point.length = A,
                        i.hemi.length = T,
                        i.directionalShadow.length = D,
                        i.directionalShadowMap.length = D,
                        i.pointShadow.length = w,
                        i.pointShadowMap.length = w,
                        i.spotShadow.length = U,
                        i.spotShadowMap.length = U,
                        i.directionalShadowMatrix.length = D,
                        i.pointShadowMatrix.length = w,
                        i.spotLightMatrix.length = U + O - L,
                        i.spotLightMap.length = O,
                        i.numSpotLightShadowsWithMaps = L,
                        i.numLightProbes = N,
                        z.directionalLength = S,
                        z.pointLength = A,
                        z.spotLength = M,
                        z.rectAreaLength = x,
                        z.hemiLength = T,
                        z.numDirectionalShadows = D,
                        z.numPointShadows = w,
                        z.numSpotShadows = U,
                        z.numSpotMaps = O,
                        z.numLightProbes = N,
                        i.version = oz++)
                    }
                    function u(f, m) {
                        let v = 0
                          , y = 0
                          , S = 0
                          , A = 0
                          , M = 0;
                        const x = m.matrixWorldInverse;
                        for (let T = 0, D = f.length; T < D; T++) {
                            const w = f[T];
                            if (w.isDirectionalLight) {
                                const U = i.directional[v];
                                U.direction.setFromMatrixPosition(w.matrixWorld),
                                s.setFromMatrixPosition(w.target.matrixWorld),
                                U.direction.sub(s),
                                U.direction.transformDirection(x),
                                v++
                            } else if (w.isSpotLight) {
                                const U = i.spot[S];
                                U.position.setFromMatrixPosition(w.matrixWorld),
                                U.position.applyMatrix4(x),
                                U.direction.setFromMatrixPosition(w.matrixWorld),
                                s.setFromMatrixPosition(w.target.matrixWorld),
                                U.direction.sub(s),
                                U.direction.transformDirection(x),
                                S++
                            } else if (w.isRectAreaLight) {
                                const U = i.rectArea[A];
                                U.position.setFromMatrixPosition(w.matrixWorld),
                                U.position.applyMatrix4(x),
                                o.identity(),
                                a.copy(w.matrixWorld),
                                a.premultiply(x),
                                o.extractRotation(a),
                                U.halfWidth.set(w.width * .5, 0, 0),
                                U.halfHeight.set(0, w.height * .5, 0),
                                U.halfWidth.applyMatrix4(o),
                                U.halfHeight.applyMatrix4(o),
                                A++
                            } else if (w.isPointLight) {
                                const U = i.point[y];
                                U.position.setFromMatrixPosition(w.matrixWorld),
                                U.position.applyMatrix4(x),
                                y++
                            } else if (w.isHemisphereLight) {
                                const U = i.hemi[M];
                                U.direction.setFromMatrixPosition(w.matrixWorld),
                                U.direction.transformDirection(x),
                                M++
                            }
                        }
                    }
                    return {
                        setup: c,
                        setupView: u,
                        state: i
                    }
                }
                function g1(e) {
                    const t = new cz(e)
                      , n = []
                      , i = [];
                    function s(m) {
                        f.camera = m,
                        n.length = 0,
                        i.length = 0
                    }
                    function a(m) {
                        n.push(m)
                    }
                    function o(m) {
                        i.push(m)
                    }
                    function c() {
                        t.setup(n)
                    }
                    function u(m) {
                        t.setupView(n, m)
                    }
                    const f = {
                        lightsArray: n,
                        shadowsArray: i,
                        camera: null,
                        lights: t,
                        transmissionRenderTarget: {}
                    };
                    return {
                        init: s,
                        state: f,
                        setupLights: c,
                        setupLightsView: u,
                        pushLight: a,
                        pushShadow: o
                    }
                }
                function uz(e) {
                    let t = new WeakMap;
                    function n(s, a=0) {
                        const o = t.get(s);
                        let c;
                        return o === void 0 ? (c = new g1(e),
                        t.set(s, [c])) : a >= o.length ? (c = new g1(e),
                        o.push(c)) : c = o[a],
                        c
                    }
                    function i() {
                        t = new WeakMap
                    }
                    return {
                        get: n,
                        dispose: i
                    }
                }
                const hz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
                  , fz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
                function dz(e, t, n) {
                    let i = new kp;
                    const s = new Oe
                      , a = new Oe
                      , o = new hn
                      , c = new Fg({
                        depthPacking: Eo
                    })
                      , u = new pS
                      , f = {}
                      , m = n.maxTextureSize
                      , v = {
                        [ic]: Ds,
                        [Ds]: ic,
                        [$a]: $a
                    }
                      , y = new kn({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Oe
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: hz,
                        fragmentShader: fz
                    })
                      , S = y.clone();
                    S.defines.HORIZONTAL_PASS = 1;
                    const A = new sn;
                    A.setAttribute("position", new Ln(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                    const M = new oi(A,y)
                      , x = this;
                    this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = Iy;
                    let T = this.type;
                    this.render = function(L, N, z) {
                        if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || L.length === 0)
                            return;
                        const I = e.getRenderTarget()
                          , B = e.getActiveCubeFace()
                          , G = e.getActiveMipmapLevel()
                          , X = e.state;
                        X.setBlending(pi),
                        X.buffers.depth.getReversed() === !0 ? X.buffers.color.setClear(0, 0, 0, 0) : X.buffers.color.setClear(1, 1, 1, 1),
                        X.buffers.depth.setTest(!0),
                        X.setScissorTest(!1);
                        const q = T !== sl && this.type === sl
                          , Q = T === sl && this.type !== sl;
                        for (let oe = 0, k = L.length; oe < k; oe++) {
                            const W = L[oe]
                              , V = W.shadow;
                            if (V === void 0) {
                                console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
                                continue
                            }
                            if (V.autoUpdate === !1 && V.needsUpdate === !1)
                                continue;
                            s.copy(V.mapSize);
                            const Z = V.getFrameExtents();
                            if (s.multiply(Z),
                            a.copy(V.mapSize),
                            (s.x > m || s.y > m) && (s.x > m && (a.x = Math.floor(m / Z.x),
                            s.x = a.x * Z.x,
                            V.mapSize.x = a.x),
                            s.y > m && (a.y = Math.floor(m / Z.y),
                            s.y = a.y * Z.y,
                            V.mapSize.y = a.y)),
                            V.map === null || q === !0 || Q === !0) {
                                const ee = this.type !== sl ? {
                                    minFilter: ri,
                                    magFilter: ri
                                } : {};
                                V.map !== null && V.map.dispose(),
                                V.map = new Vn(s.x,s.y,ee),
                                V.map.texture.name = W.name + ".shadowMap",
                                V.camera.updateProjectionMatrix()
                            }
                            e.setRenderTarget(V.map),
                            e.clear();
                            const j = V.getViewportCount();
                            for (let ee = 0; ee < j; ee++) {
                                const H = V.getViewport(ee);
                                o.set(a.x * H.x, a.y * H.y, a.x * H.z, a.y * H.w),
                                X.viewport(o),
                                V.updateMatrices(W, ee),
                                i = V.getFrustum(),
                                U(N, z, V.camera, W, this.type)
                            }
                            V.isPointLightShadow !== !0 && this.type === sl && D(V, z),
                            V.needsUpdate = !1
                        }
                        T = this.type,
                        x.needsUpdate = !1,
                        e.setRenderTarget(I, B, G)
                    }
                    ;
                    function D(L, N) {
                        const z = t.update(M);
                        y.defines.VSM_SAMPLES !== L.blurSamples && (y.defines.VSM_SAMPLES = L.blurSamples,
                        S.defines.VSM_SAMPLES = L.blurSamples,
                        y.needsUpdate = !0,
                        S.needsUpdate = !0),
                        L.mapPass === null && (L.mapPass = new Vn(s.x,s.y)),
                        y.uniforms.shadow_pass.value = L.map.texture,
                        y.uniforms.resolution.value = L.mapSize,
                        y.uniforms.radius.value = L.radius,
                        e.setRenderTarget(L.mapPass),
                        e.clear(),
                        e.renderBufferDirect(N, null, z, y, M, null),
                        S.uniforms.shadow_pass.value = L.mapPass.texture,
                        S.uniforms.resolution.value = L.mapSize,
                        S.uniforms.radius.value = L.radius,
                        e.setRenderTarget(L.map),
                        e.clear(),
                        e.renderBufferDirect(N, null, z, S, M, null)
                    }
                    function w(L, N, z, I) {
                        let B = null;
                        const G = z.isPointLight === !0 ? L.customDistanceMaterial : L.customDepthMaterial;
                        if (G !== void 0)
                            B = G;
                        else if (B = z.isPointLight === !0 ? u : c,
                        e.localClippingEnabled && N.clipShadows === !0 && Array.isArray(N.clippingPlanes) && N.clippingPlanes.length !== 0 || N.displacementMap && N.displacementScale !== 0 || N.alphaMap && N.alphaTest > 0 || N.map && N.alphaTest > 0 || N.alphaToCoverage === !0) {
                            const X = B.uuid
                              , q = N.uuid;
                            let Q = f[X];
                            Q === void 0 && (Q = {},
                            f[X] = Q);
                            let oe = Q[q];
                            oe === void 0 && (oe = B.clone(),
                            Q[q] = oe,
                            N.addEventListener("dispose", O)),
                            B = oe
                        }
                        if (B.visible = N.visible,
                        B.wireframe = N.wireframe,
                        I === sl ? B.side = N.shadowSide !== null ? N.shadowSide : N.side : B.side = N.shadowSide !== null ? N.shadowSide : v[N.side],
                        B.alphaMap = N.alphaMap,
                        B.alphaTest = N.alphaToCoverage === !0 ? .5 : N.alphaTest,
                        B.map = N.map,
                        B.clipShadows = N.clipShadows,
                        B.clippingPlanes = N.clippingPlanes,
                        B.clipIntersection = N.clipIntersection,
                        B.displacementMap = N.displacementMap,
                        B.displacementScale = N.displacementScale,
                        B.displacementBias = N.displacementBias,
                        B.wireframeLinewidth = N.wireframeLinewidth,
                        B.linewidth = N.linewidth,
                        z.isPointLight === !0 && B.isMeshDistanceMaterial === !0) {
                            const X = e.properties.get(B);
                            X.light = z
                        }
                        return B
                    }
                    function U(L, N, z, I, B) {
                        if (L.visible === !1)
                            return;
                        if (L.layers.test(N.layers) && (L.isMesh || L.isLine || L.isPoints) && (L.castShadow || L.receiveShadow && B === sl) && (!L.frustumCulled || i.intersectsObject(L))) {
                            L.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, L.matrixWorld);
                            const X = t.update(L)
                              , q = L.material;
                            if (Array.isArray(q)) {
                                const Q = X.groups;
                                for (let oe = 0, k = Q.length; oe < k; oe++) {
                                    const W = Q[oe]
                                      , V = q[W.materialIndex];
                                    if (V && V.visible) {
                                        const Z = w(L, V, I, B);
                                        L.onBeforeShadow(e, L, N, z, X, Z, W),
                                        e.renderBufferDirect(z, null, X, Z, L, W),
                                        L.onAfterShadow(e, L, N, z, X, Z, W)
                                    }
                                }
                            } else if (q.visible) {
                                const Q = w(L, q, I, B);
                                L.onBeforeShadow(e, L, N, z, X, Q, null),
                                e.renderBufferDirect(z, null, X, Q, L, null),
                                L.onAfterShadow(e, L, N, z, X, Q, null)
                            }
                        }
                        const G = L.children;
                        for (let X = 0, q = G.length; X < q; X++)
                            U(G[X], N, z, I, B)
                    }
                    function O(L) {
                        L.target.removeEventListener("dispose", O);
                        for (const N in f) {
                            const z = f[N]
                              , I = L.target.uuid;
                            I in z && (z[I].dispose(),
                            delete z[I])
                        }
                    }
                }
                const pz = {
                    [Kv]: Jv,
                    [up]: eg,
                    [hf]: hp,
                    [nh]: $v,
                    [Jv]: Kv,
                    [eg]: up,
                    [hp]: hf,
                    [$v]: nh
                };
                function mz(e, t) {
                    function n() {
                        let fe = !1;
                        const ot = new hn;
                        let tt = null;
                        const xt = new hn(0,0,0,0);
                        return {
                            setMask: function(Qe) {
                                tt !== Qe && !fe && (e.colorMask(Qe, Qe, Qe, Qe),
                                tt = Qe)
                            },
                            setLocked: function(Qe) {
                                fe = Qe
                            },
                            setClear: function(Qe, Ne, dt, _t, Ct) {
                                Ct === !0 && (Qe *= _t,
                                Ne *= _t,
                                dt *= _t),
                                ot.set(Qe, Ne, dt, _t),
                                xt.equals(ot) === !1 && (e.clearColor(Qe, Ne, dt, _t),
                                xt.copy(ot))
                            },
                            reset: function() {
                                fe = !1,
                                tt = null,
                                xt.set(-1, 0, 0, 0)
                            }
                        }
                    }
                    function i() {
                        let fe = !1
                          , ot = !1
                          , tt = null
                          , xt = null
                          , Qe = null;
                        return {
                            setReversed: function(Ne) {
                                if (ot !== Ne) {
                                    const dt = t.get("EXT_clip_control");
                                    Ne ? dt.clipControlEXT(dt.LOWER_LEFT_EXT, dt.ZERO_TO_ONE_EXT) : dt.clipControlEXT(dt.LOWER_LEFT_EXT, dt.NEGATIVE_ONE_TO_ONE_EXT),
                                    ot = Ne;
                                    const _t = Qe;
                                    Qe = null,
                                    this.setClear(_t)
                                }
                            },
                            getReversed: function() {
                                return ot
                            },
                            setTest: function(Ne) {
                                Ne ? ue(e.DEPTH_TEST) : de(e.DEPTH_TEST)
                            },
                            setMask: function(Ne) {
                                tt !== Ne && !fe && (e.depthMask(Ne),
                                tt = Ne)
                            },
                            setFunc: function(Ne) {
                                if (ot && (Ne = pz[Ne]),
                                xt !== Ne) {
                                    switch (Ne) {
                                    case Kv:
                                        e.depthFunc(e.NEVER);
                                        break;
                                    case Jv:
                                        e.depthFunc(e.ALWAYS);
                                        break;
                                    case up:
                                        e.depthFunc(e.LESS);
                                        break;
                                    case nh:
                                        e.depthFunc(e.LEQUAL);
                                        break;
                                    case hf:
                                        e.depthFunc(e.EQUAL);
                                        break;
                                    case $v:
                                        e.depthFunc(e.GEQUAL);
                                        break;
                                    case eg:
                                        e.depthFunc(e.GREATER);
                                        break;
                                    case hp:
                                        e.depthFunc(e.NOTEQUAL);
                                        break;
                                    default:
                                        e.depthFunc(e.LEQUAL)
                                    }
                                    xt = Ne
                                }
                            },
                            setLocked: function(Ne) {
                                fe = Ne
                            },
                            setClear: function(Ne) {
                                Qe !== Ne && (ot && (Ne = 1 - Ne),
                                e.clearDepth(Ne),
                                Qe = Ne)
                            },
                            reset: function() {
                                fe = !1,
                                tt = null,
                                xt = null,
                                Qe = null,
                                ot = !1
                            }
                        }
                    }
                    function s() {
                        let fe = !1
                          , ot = null
                          , tt = null
                          , xt = null
                          , Qe = null
                          , Ne = null
                          , dt = null
                          , _t = null
                          , Ct = null;
                        return {
                            setTest: function(Ot) {
                                fe || (Ot ? ue(e.STENCIL_TEST) : de(e.STENCIL_TEST))
                            },
                            setMask: function(Ot) {
                                ot !== Ot && !fe && (e.stencilMask(Ot),
                                ot = Ot)
                            },
                            setFunc: function(Ot, Mn, Un) {
                                (tt !== Ot || xt !== Mn || Qe !== Un) && (e.stencilFunc(Ot, Mn, Un),
                                tt = Ot,
                                xt = Mn,
                                Qe = Un)
                            },
                            setOp: function(Ot, Mn, Un) {
                                (Ne !== Ot || dt !== Mn || _t !== Un) && (e.stencilOp(Ot, Mn, Un),
                                Ne = Ot,
                                dt = Mn,
                                _t = Un)
                            },
                            setLocked: function(Ot) {
                                fe = Ot
                            },
                            setClear: function(Ot) {
                                Ct !== Ot && (e.clearStencil(Ot),
                                Ct = Ot)
                            },
                            reset: function() {
                                fe = !1,
                                ot = null,
                                tt = null,
                                xt = null,
                                Qe = null,
                                Ne = null,
                                dt = null,
                                _t = null,
                                Ct = null
                            }
                        }
                    }
                    const a = new n
                      , o = new i
                      , c = new s
                      , u = new WeakMap
                      , f = new WeakMap;
                    let m = {}
                      , v = {}
                      , y = new WeakMap
                      , S = []
                      , A = null
                      , M = !1
                      , x = null
                      , T = null
                      , D = null
                      , w = null
                      , U = null
                      , O = null
                      , L = null
                      , N = new ft(0,0,0)
                      , z = 0
                      , I = !1
                      , B = null
                      , G = null
                      , X = null
                      , q = null
                      , Q = null;
                    const oe = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    let k = !1
                      , W = 0;
                    const V = e.getParameter(e.VERSION);
                    V.indexOf("WebGL") !== -1 ? (W = parseFloat(/^WebGL (\d)/.exec(V)[1]),
                    k = W >= 1) : V.indexOf("OpenGL ES") !== -1 && (W = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),
                    k = W >= 2);
                    let Z = null
                      , j = {};
                    const ee = e.getParameter(e.SCISSOR_BOX)
                      , H = e.getParameter(e.VIEWPORT)
                      , ie = new hn().fromArray(ee)
                      , se = new hn().fromArray(H);
                    function K(fe, ot, tt, xt) {
                        const Qe = new Uint8Array(4)
                          , Ne = e.createTexture();
                        e.bindTexture(fe, Ne),
                        e.texParameteri(fe, e.TEXTURE_MIN_FILTER, e.NEAREST),
                        e.texParameteri(fe, e.TEXTURE_MAG_FILTER, e.NEAREST);
                        for (let dt = 0; dt < tt; dt++)
                            fe === e.TEXTURE_3D || fe === e.TEXTURE_2D_ARRAY ? e.texImage3D(ot, 0, e.RGBA, 1, 1, xt, 0, e.RGBA, e.UNSIGNED_BYTE, Qe) : e.texImage2D(ot + dt, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, Qe);
                        return Ne
                    }
                    const le = {};
                    le[e.TEXTURE_2D] = K(e.TEXTURE_2D, e.TEXTURE_2D, 1),
                    le[e.TEXTURE_CUBE_MAP] = K(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                    le[e.TEXTURE_2D_ARRAY] = K(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
                    le[e.TEXTURE_3D] = K(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
                    a.setClear(0, 0, 0, 1),
                    o.setClear(1),
                    c.setClear(0),
                    ue(e.DEPTH_TEST),
                    o.setFunc(nh),
                    xe(!1),
                    ge(hA),
                    ue(e.CULL_FACE),
                    he(pi);
                    function ue(fe) {
                        m[fe] !== !0 && (e.enable(fe),
                        m[fe] = !0)
                    }
                    function de(fe) {
                        m[fe] !== !1 && (e.disable(fe),
                        m[fe] = !1)
                    }
                    function qe(fe, ot) {
                        return v[fe] !== ot ? (e.bindFramebuffer(fe, ot),
                        v[fe] = ot,
                        fe === e.DRAW_FRAMEBUFFER && (v[e.FRAMEBUFFER] = ot),
                        fe === e.FRAMEBUFFER && (v[e.DRAW_FRAMEBUFFER] = ot),
                        !0) : !1
                    }
                    function ze(fe, ot) {
                        let tt = S
                          , xt = !1;
                        if (fe) {
                            tt = y.get(ot),
                            tt === void 0 && (tt = [],
                            y.set(ot, tt));
                            const Qe = fe.textures;
                            if (tt.length !== Qe.length || tt[0] !== e.COLOR_ATTACHMENT0) {
                                for (let Ne = 0, dt = Qe.length; Ne < dt; Ne++)
                                    tt[Ne] = e.COLOR_ATTACHMENT0 + Ne;
                                tt.length = Qe.length,
                                xt = !0
                            }
                        } else
                            tt[0] !== e.BACK && (tt[0] = e.BACK,
                            xt = !0);
                        xt && e.drawBuffers(tt)
                    }
                    function Ee(fe) {
                        return A !== fe ? (e.useProgram(fe),
                        A = fe,
                        !0) : !1
                    }
                    const re = {
                        [th]: e.FUNC_ADD,
                        [BE]: e.FUNC_SUBTRACT,
                        [LE]: e.FUNC_REVERSE_SUBTRACT
                    };
                    re[IE] = e.MIN,
                    re[PE] = e.MAX;
                    const Le = {
                        [zE]: e.ZERO,
                        [FE]: e.ONE,
                        [HE]: e.SRC_COLOR,
                        [Py]: e.SRC_ALPHA,
                        [YE]: e.SRC_ALPHA_SATURATE,
                        [XE]: e.DST_COLOR,
                        [VE]: e.DST_ALPHA,
                        [GE]: e.ONE_MINUS_SRC_COLOR,
                        [zy]: e.ONE_MINUS_SRC_ALPHA,
                        [WE]: e.ONE_MINUS_DST_COLOR,
                        [kE]: e.ONE_MINUS_DST_ALPHA,
                        [qE]: e.CONSTANT_COLOR,
                        [jE]: e.ONE_MINUS_CONSTANT_COLOR,
                        [QE]: e.CONSTANT_ALPHA,
                        [ZE]: e.ONE_MINUS_CONSTANT_ALPHA
                    };
                    function he(fe, ot, tt, xt, Qe, Ne, dt, _t, Ct, Ot) {
                        if (fe === pi) {
                            M === !0 && (de(e.BLEND),
                            M = !1);
                            return
                        }
                        if (M === !1 && (ue(e.BLEND),
                        M = !0),
                        fe !== NE) {
                            if (fe !== x || Ot !== I) {
                                if ((T !== th || U !== th) && (e.blendEquation(e.FUNC_ADD),
                                T = th,
                                U = th),
                                Ot)
                                    switch (fe) {
                                    case uf:
                                        e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case fA:
                                        e.blendFunc(e.ONE, e.ONE);
                                        break;
                                    case dA:
                                        e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                        break;
                                    case pA:
                                        e.blendFuncSeparate(e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ZERO, e.ONE);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", fe);
                                        break
                                    }
                                else
                                    switch (fe) {
                                    case uf:
                                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case fA:
                                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE);
                                        break;
                                    case dA:
                                        console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                                        break;
                                    case pA:
                                        console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", fe);
                                        break
                                    }
                                D = null,
                                w = null,
                                O = null,
                                L = null,
                                N.set(0, 0, 0),
                                z = 0,
                                x = fe,
                                I = Ot
                            }
                            return
                        }
                        Qe = Qe || ot,
                        Ne = Ne || tt,
                        dt = dt || xt,
                        (ot !== T || Qe !== U) && (e.blendEquationSeparate(re[ot], re[Qe]),
                        T = ot,
                        U = Qe),
                        (tt !== D || xt !== w || Ne !== O || dt !== L) && (e.blendFuncSeparate(Le[tt], Le[xt], Le[Ne], Le[dt]),
                        D = tt,
                        w = xt,
                        O = Ne,
                        L = dt),
                        (_t.equals(N) === !1 || Ct !== z) && (e.blendColor(_t.r, _t.g, _t.b, Ct),
                        N.copy(_t),
                        z = Ct),
                        x = fe,
                        I = !1
                    }
                    function ye(fe, ot) {
                        fe.side === $a ? de(e.CULL_FACE) : ue(e.CULL_FACE);
                        let tt = fe.side === Ds;
                        ot && (tt = !tt),
                        xe(tt),
                        fe.blending === uf && fe.transparent === !1 ? he(pi) : he(fe.blending, fe.blendEquation, fe.blendSrc, fe.blendDst, fe.blendEquationAlpha, fe.blendSrcAlpha, fe.blendDstAlpha, fe.blendColor, fe.blendAlpha, fe.premultipliedAlpha),
                        o.setFunc(fe.depthFunc),
                        o.setTest(fe.depthTest),
                        o.setMask(fe.depthWrite),
                        a.setMask(fe.colorWrite);
                        const xt = fe.stencilWrite;
                        c.setTest(xt),
                        xt && (c.setMask(fe.stencilWriteMask),
                        c.setFunc(fe.stencilFunc, fe.stencilRef, fe.stencilFuncMask),
                        c.setOp(fe.stencilFail, fe.stencilZFail, fe.stencilZPass)),
                        Ae(fe.polygonOffset, fe.polygonOffsetFactor, fe.polygonOffsetUnits),
                        fe.alphaToCoverage === !0 ? ue(e.SAMPLE_ALPHA_TO_COVERAGE) : de(e.SAMPLE_ALPHA_TO_COVERAGE)
                    }
                    function xe(fe) {
                        B !== fe && (fe ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                        B = fe)
                    }
                    function ge(fe) {
                        fe !== RE ? (ue(e.CULL_FACE),
                        fe !== G && (fe === hA ? e.cullFace(e.BACK) : fe === UE ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : de(e.CULL_FACE),
                        G = fe
                    }
                    function Te(fe) {
                        fe !== X && (k && e.lineWidth(fe),
                        X = fe)
                    }
                    function Ae(fe, ot, tt) {
                        fe ? (ue(e.POLYGON_OFFSET_FILL),
                        (q !== ot || Q !== tt) && (e.polygonOffset(ot, tt),
                        q = ot,
                        Q = tt)) : de(e.POLYGON_OFFSET_FILL)
                    }
                    function we(fe) {
                        fe ? ue(e.SCISSOR_TEST) : de(e.SCISSOR_TEST)
                    }
                    function it(fe) {
                        fe === void 0 && (fe = e.TEXTURE0 + oe - 1),
                        Z !== fe && (e.activeTexture(fe),
                        Z = fe)
                    }
                    function je(fe, ot, tt) {
                        tt === void 0 && (Z === null ? tt = e.TEXTURE0 + oe - 1 : tt = Z);
                        let xt = j[tt];
                        xt === void 0 && (xt = {
                            type: void 0,
                            texture: void 0
                        },
                        j[tt] = xt),
                        (xt.type !== fe || xt.texture !== ot) && (Z !== tt && (e.activeTexture(tt),
                        Z = tt),
                        e.bindTexture(fe, ot || le[fe]),
                        xt.type = fe,
                        xt.texture = ot)
                    }
                    function $() {
                        const fe = j[Z];
                        fe !== void 0 && fe.type !== void 0 && (e.bindTexture(fe.type, null),
                        fe.type = void 0,
                        fe.texture = void 0)
                    }
                    function Y() {
                        try {
                            e.compressedTexImage2D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function pe() {
                        try {
                            e.compressedTexImage3D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function He() {
                        try {
                            e.texSubImage2D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function Re() {
                        try {
                            e.texSubImage3D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function De() {
                        try {
                            e.compressedTexSubImage2D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function rt() {
                        try {
                            e.compressedTexSubImage3D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function $e() {
                        try {
                            e.texStorage2D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function ct() {
                        try {
                            e.texStorage3D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function gt() {
                        try {
                            e.texImage2D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function Ie() {
                        try {
                            e.texImage3D(...arguments)
                        } catch (fe) {
                            console.error("THREE.WebGLState:", fe)
                        }
                    }
                    function Je(fe) {
                        ie.equals(fe) === !1 && (e.scissor(fe.x, fe.y, fe.z, fe.w),
                        ie.copy(fe))
                    }
                    function Ze(fe) {
                        se.equals(fe) === !1 && (e.viewport(fe.x, fe.y, fe.z, fe.w),
                        se.copy(fe))
                    }
                    function ht(fe, ot) {
                        let tt = f.get(ot);
                        tt === void 0 && (tt = new WeakMap,
                        f.set(ot, tt));
                        let xt = tt.get(fe);
                        xt === void 0 && (xt = e.getUniformBlockIndex(ot, fe.name),
                        tt.set(fe, xt))
                    }
                    function lt(fe, ot) {
                        const tt = f.get(ot).get(fe);
                        u.get(ot) !== tt && (e.uniformBlockBinding(ot, tt, fe.__bindingPointIndex),
                        u.set(ot, tt))
                    }
                    function At() {
                        e.disable(e.BLEND),
                        e.disable(e.CULL_FACE),
                        e.disable(e.DEPTH_TEST),
                        e.disable(e.POLYGON_OFFSET_FILL),
                        e.disable(e.SCISSOR_TEST),
                        e.disable(e.STENCIL_TEST),
                        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                        e.blendEquation(e.FUNC_ADD),
                        e.blendFunc(e.ONE, e.ZERO),
                        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                        e.blendColor(0, 0, 0, 0),
                        e.colorMask(!0, !0, !0, !0),
                        e.clearColor(0, 0, 0, 0),
                        e.depthMask(!0),
                        e.depthFunc(e.LESS),
                        o.setReversed(!1),
                        e.clearDepth(1),
                        e.stencilMask(4294967295),
                        e.stencilFunc(e.ALWAYS, 0, 4294967295),
                        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                        e.clearStencil(0),
                        e.cullFace(e.BACK),
                        e.frontFace(e.CCW),
                        e.polygonOffset(0, 0),
                        e.activeTexture(e.TEXTURE0),
                        e.bindFramebuffer(e.FRAMEBUFFER, null),
                        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        e.useProgram(null),
                        e.lineWidth(1),
                        e.scissor(0, 0, e.canvas.width, e.canvas.height),
                        e.viewport(0, 0, e.canvas.width, e.canvas.height),
                        m = {},
                        Z = null,
                        j = {},
                        v = {},
                        y = new WeakMap,
                        S = [],
                        A = null,
                        M = !1,
                        x = null,
                        T = null,
                        D = null,
                        w = null,
                        U = null,
                        O = null,
                        L = null,
                        N = new ft(0,0,0),
                        z = 0,
                        I = !1,
                        B = null,
                        G = null,
                        X = null,
                        q = null,
                        Q = null,
                        ie.set(0, 0, e.canvas.width, e.canvas.height),
                        se.set(0, 0, e.canvas.width, e.canvas.height),
                        a.reset(),
                        o.reset(),
                        c.reset()
                    }
                    return {
                        buffers: {
                            color: a,
                            depth: o,
                            stencil: c
                        },
                        enable: ue,
                        disable: de,
                        bindFramebuffer: qe,
                        drawBuffers: ze,
                        useProgram: Ee,
                        setBlending: he,
                        setMaterial: ye,
                        setFlipSided: xe,
                        setCullFace: ge,
                        setLineWidth: Te,
                        setPolygonOffset: Ae,
                        setScissorTest: we,
                        activeTexture: it,
                        bindTexture: je,
                        unbindTexture: $,
                        compressedTexImage2D: Y,
                        compressedTexImage3D: pe,
                        texImage2D: gt,
                        texImage3D: Ie,
                        updateUBOMapping: ht,
                        uniformBlockBinding: lt,
                        texStorage2D: $e,
                        texStorage3D: ct,
                        texSubImage2D: He,
                        texSubImage3D: Re,
                        compressedTexSubImage2D: De,
                        compressedTexSubImage3D: rt,
                        scissor: Je,
                        viewport: Ze,
                        reset: At
                    }
                }
                function vz(e, t, n, i, s, a, o) {
                    const c = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
                      , u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
                      , f = new Oe
                      , m = new WeakMap;
                    let v;
                    const y = new WeakMap;
                    let S = !1;
                    try {
                        S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
                    } catch {}
                    function A($, Y) {
                        return S ? new OffscreenCanvas($,Y) : mg("canvas")
                    }
                    function M($, Y, pe) {
                        let He = 1;
                        const Re = je($);
                        if ((Re.width > pe || Re.height > pe) && (He = pe / Math.max(Re.width, Re.height)),
                        He < 1)
                            if (typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && $ instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && $ instanceof ImageBitmap || typeof VideoFrame < "u" && $ instanceof VideoFrame) {
                                const De = Math.floor(He * Re.width)
                                  , rt = Math.floor(He * Re.height);
                                v === void 0 && (v = A(De, rt));
                                const $e = Y ? A(De, rt) : v;
                                return $e.width = De,
                                $e.height = rt,
                                $e.getContext("2d").drawImage($, 0, 0, De, rt),
                                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Re.width + "x" + Re.height + ") to (" + De + "x" + rt + ")."),
                                $e
                            } else
                                return "data"in $ && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Re.width + "x" + Re.height + ")."),
                                $;
                        return $
                    }
                    function x($) {
                        return $.generateMipmaps
                    }
                    function T($) {
                        e.generateMipmap($)
                    }
                    function D($) {
                        return $.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : $.isWebGL3DRenderTarget ? e.TEXTURE_3D : $.isWebGLArrayRenderTarget || $.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
                    }
                    function w($, Y, pe, He, Re=!1) {
                        if ($ !== null) {
                            if (e[$] !== void 0)
                                return e[$];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + $ + "'")
                        }
                        let De = Y;
                        if (Y === e.RED && (pe === e.FLOAT && (De = e.R32F),
                        pe === e.HALF_FLOAT && (De = e.R16F),
                        pe === e.UNSIGNED_BYTE && (De = e.R8)),
                        Y === e.RED_INTEGER && (pe === e.UNSIGNED_BYTE && (De = e.R8UI),
                        pe === e.UNSIGNED_SHORT && (De = e.R16UI),
                        pe === e.UNSIGNED_INT && (De = e.R32UI),
                        pe === e.BYTE && (De = e.R8I),
                        pe === e.SHORT && (De = e.R16I),
                        pe === e.INT && (De = e.R32I)),
                        Y === e.RG && (pe === e.FLOAT && (De = e.RG32F),
                        pe === e.HALF_FLOAT && (De = e.RG16F),
                        pe === e.UNSIGNED_BYTE && (De = e.RG8)),
                        Y === e.RG_INTEGER && (pe === e.UNSIGNED_BYTE && (De = e.RG8UI),
                        pe === e.UNSIGNED_SHORT && (De = e.RG16UI),
                        pe === e.UNSIGNED_INT && (De = e.RG32UI),
                        pe === e.BYTE && (De = e.RG8I),
                        pe === e.SHORT && (De = e.RG16I),
                        pe === e.INT && (De = e.RG32I)),
                        Y === e.RGB_INTEGER && (pe === e.UNSIGNED_BYTE && (De = e.RGB8UI),
                        pe === e.UNSIGNED_SHORT && (De = e.RGB16UI),
                        pe === e.UNSIGNED_INT && (De = e.RGB32UI),
                        pe === e.BYTE && (De = e.RGB8I),
                        pe === e.SHORT && (De = e.RGB16I),
                        pe === e.INT && (De = e.RGB32I)),
                        Y === e.RGBA_INTEGER && (pe === e.UNSIGNED_BYTE && (De = e.RGBA8UI),
                        pe === e.UNSIGNED_SHORT && (De = e.RGBA16UI),
                        pe === e.UNSIGNED_INT && (De = e.RGBA32UI),
                        pe === e.BYTE && (De = e.RGBA8I),
                        pe === e.SHORT && (De = e.RGBA16I),
                        pe === e.INT && (De = e.RGBA32I)),
                        Y === e.RGB && (pe === e.UNSIGNED_INT_5_9_9_9_REV && (De = e.RGB9_E5),
                        pe === e.UNSIGNED_INT_10F_11F_11F_REV && (De = e.R11F_G11F_B10F)),
                        Y === e.RGBA) {
                            const rt = Re ? fg : Rn.getTransfer(He);
                            pe === e.FLOAT && (De = e.RGBA32F),
                            pe === e.HALF_FLOAT && (De = e.RGBA16F),
                            pe === e.UNSIGNED_BYTE && (De = rt === Jn ? e.SRGB8_ALPHA8 : e.RGBA8),
                            pe === e.UNSIGNED_SHORT_4_4_4_4 && (De = e.RGBA4),
                            pe === e.UNSIGNED_SHORT_5_5_5_1 && (De = e.RGB5_A1)
                        }
                        return (De === e.R16F || De === e.R32F || De === e.RG16F || De === e.RG32F || De === e.RGBA16F || De === e.RGBA32F) && t.get("EXT_color_buffer_float"),
                        De
                    }
                    function U($, Y) {
                        let pe;
                        return $ ? Y === null || Y === ac || Y === df ? pe = e.DEPTH24_STENCIL8 : Y === na ? pe = e.DEPTH32F_STENCIL8 : Y === mp && (pe = e.DEPTH24_STENCIL8,
                        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : Y === null || Y === ac || Y === df ? pe = e.DEPTH_COMPONENT24 : Y === na ? pe = e.DEPTH_COMPONENT32F : Y === mp && (pe = e.DEPTH_COMPONENT16),
                        pe
                    }
                    function O($, Y) {
                        return x($) === !0 || $.isFramebufferTexture && $.minFilter !== ri && $.minFilter !== mi ? Math.log2(Math.max(Y.width, Y.height)) + 1 : $.mipmaps !== void 0 && $.mipmaps.length > 0 ? $.mipmaps.length : $.isCompressedTexture && Array.isArray($.image) ? Y.mipmaps.length : 1
                    }
                    function L($) {
                        const Y = $.target;
                        Y.removeEventListener("dispose", L),
                        z(Y),
                        Y.isVideoTexture && m.delete(Y)
                    }
                    function N($) {
                        const Y = $.target;
                        Y.removeEventListener("dispose", N),
                        B(Y)
                    }
                    function z($) {
                        const Y = i.get($);
                        if (Y.__webglInit === void 0)
                            return;
                        const pe = $.source
                          , He = y.get(pe);
                        if (He) {
                            const Re = He[Y.__cacheKey];
                            Re.usedTimes--,
                            Re.usedTimes === 0 && I($),
                            Object.keys(He).length === 0 && y.delete(pe)
                        }
                        i.remove($)
                    }
                    function I($) {
                        const Y = i.get($);
                        e.deleteTexture(Y.__webglTexture);
                        const pe = $.source
                          , He = y.get(pe);
                        delete He[Y.__cacheKey],
                        o.memory.textures--
                    }
                    function B($) {
                        const Y = i.get($);
                        if ($.depthTexture && ($.depthTexture.dispose(),
                        i.remove($.depthTexture)),
                        $.isWebGLCubeRenderTarget)
                            for (let He = 0; He < 6; He++) {
                                if (Array.isArray(Y.__webglFramebuffer[He]))
                                    for (let Re = 0; Re < Y.__webglFramebuffer[He].length; Re++)
                                        e.deleteFramebuffer(Y.__webglFramebuffer[He][Re]);
                                else
                                    e.deleteFramebuffer(Y.__webglFramebuffer[He]);
                                Y.__webglDepthbuffer && e.deleteRenderbuffer(Y.__webglDepthbuffer[He])
                            }
                        else {
                            if (Array.isArray(Y.__webglFramebuffer))
                                for (let He = 0; He < Y.__webglFramebuffer.length; He++)
                                    e.deleteFramebuffer(Y.__webglFramebuffer[He]);
                            else
                                e.deleteFramebuffer(Y.__webglFramebuffer);
                            if (Y.__webglDepthbuffer && e.deleteRenderbuffer(Y.__webglDepthbuffer),
                            Y.__webglMultisampledFramebuffer && e.deleteFramebuffer(Y.__webglMultisampledFramebuffer),
                            Y.__webglColorRenderbuffer)
                                for (let He = 0; He < Y.__webglColorRenderbuffer.length; He++)
                                    Y.__webglColorRenderbuffer[He] && e.deleteRenderbuffer(Y.__webglColorRenderbuffer[He]);
                            Y.__webglDepthRenderbuffer && e.deleteRenderbuffer(Y.__webglDepthRenderbuffer)
                        }
                        const pe = $.textures;
                        for (let He = 0, Re = pe.length; He < Re; He++) {
                            const De = i.get(pe[He]);
                            De.__webglTexture && (e.deleteTexture(De.__webglTexture),
                            o.memory.textures--),
                            i.remove(pe[He])
                        }
                        i.remove($)
                    }
                    let G = 0;
                    function X() {
                        G = 0
                    }
                    function q() {
                        const $ = G;
                        return $ >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + $ + " texture units while this GPU supports only " + s.maxTextures),
                        G += 1,
                        $
                    }
                    function Q($) {
                        const Y = [];
                        return Y.push($.wrapS),
                        Y.push($.wrapT),
                        Y.push($.wrapR || 0),
                        Y.push($.magFilter),
                        Y.push($.minFilter),
                        Y.push($.anisotropy),
                        Y.push($.internalFormat),
                        Y.push($.format),
                        Y.push($.type),
                        Y.push($.generateMipmaps),
                        Y.push($.premultiplyAlpha),
                        Y.push($.flipY),
                        Y.push($.unpackAlignment),
                        Y.push($.colorSpace),
                        Y.join()
                    }
                    function oe($, Y) {
                        const pe = i.get($);
                        if ($.isVideoTexture && we($),
                        $.isRenderTargetTexture === !1 && $.isExternalTexture !== !0 && $.version > 0 && pe.__version !== $.version) {
                            const He = $.image;
                            if (He === null)
                                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                            else if (He.complete === !1)
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                            else {
                                le(pe, $, Y);
                                return
                            }
                        } else
                            $.isExternalTexture && (pe.__webglTexture = $.sourceTexture ? $.sourceTexture : null);
                        n.bindTexture(e.TEXTURE_2D, pe.__webglTexture, e.TEXTURE0 + Y)
                    }
                    function k($, Y) {
                        const pe = i.get($);
                        if ($.isRenderTargetTexture === !1 && $.version > 0 && pe.__version !== $.version) {
                            le(pe, $, Y);
                            return
                        }
                        n.bindTexture(e.TEXTURE_2D_ARRAY, pe.__webglTexture, e.TEXTURE0 + Y)
                    }
                    function W($, Y) {
                        const pe = i.get($);
                        if ($.isRenderTargetTexture === !1 && $.version > 0 && pe.__version !== $.version) {
                            le(pe, $, Y);
                            return
                        }
                        n.bindTexture(e.TEXTURE_3D, pe.__webglTexture, e.TEXTURE0 + Y)
                    }
                    function V($, Y) {
                        const pe = i.get($);
                        if ($.version > 0 && pe.__version !== $.version) {
                            ue(pe, $, Y);
                            return
                        }
                        n.bindTexture(e.TEXTURE_CUBE_MAP, pe.__webglTexture, e.TEXTURE0 + Y)
                    }
                    const Z = {
                        [sh]: e.REPEAT,
                        [bo]: e.CLAMP_TO_EDGE,
                        [ig]: e.MIRRORED_REPEAT
                    }
                      , j = {
                        [ri]: e.NEAREST,
                        [gA]: e.NEAREST_MIPMAP_NEAREST,
                        [pp]: e.NEAREST_MIPMAP_LINEAR,
                        [mi]: e.LINEAR,
                        [sg]: e.LINEAR_MIPMAP_NEAREST,
                        [sc]: e.LINEAR_MIPMAP_LINEAR
                    }
                      , ee = {
                        [uC]: e.NEVER,
                        [vC]: e.ALWAYS,
                        [hC]: e.LESS,
                        [EA]: e.LEQUAL,
                        [fC]: e.EQUAL,
                        [mC]: e.GEQUAL,
                        [dC]: e.GREATER,
                        [pC]: e.NOTEQUAL
                    };
                    function H($, Y) {
                        if (Y.type === na && t.has("OES_texture_float_linear") === !1 && (Y.magFilter === mi || Y.magFilter === sg || Y.magFilter === pp || Y.magFilter === sc || Y.minFilter === mi || Y.minFilter === sg || Y.minFilter === pp || Y.minFilter === sc) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                        e.texParameteri($, e.TEXTURE_WRAP_S, Z[Y.wrapS]),
                        e.texParameteri($, e.TEXTURE_WRAP_T, Z[Y.wrapT]),
                        ($ === e.TEXTURE_3D || $ === e.TEXTURE_2D_ARRAY) && e.texParameteri($, e.TEXTURE_WRAP_R, Z[Y.wrapR]),
                        e.texParameteri($, e.TEXTURE_MAG_FILTER, j[Y.magFilter]),
                        e.texParameteri($, e.TEXTURE_MIN_FILTER, j[Y.minFilter]),
                        Y.compareFunction && (e.texParameteri($, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                        e.texParameteri($, e.TEXTURE_COMPARE_FUNC, ee[Y.compareFunction])),
                        t.has("EXT_texture_filter_anisotropic") === !0) {
                            if (Y.magFilter === ri || Y.minFilter !== pp && Y.minFilter !== sc || Y.type === na && t.has("OES_texture_float_linear") === !1)
                                return;
                            if (Y.anisotropy > 1 || i.get(Y).__currentAnisotropy) {
                                const pe = t.get("EXT_texture_filter_anisotropic");
                                e.texParameterf($, pe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Y.anisotropy, s.getMaxAnisotropy())),
                                i.get(Y).__currentAnisotropy = Y.anisotropy
                            }
                        }
                    }
                    function ie($, Y) {
                        let pe = !1;
                        $.__webglInit === void 0 && ($.__webglInit = !0,
                        Y.addEventListener("dispose", L));
                        const He = Y.source;
                        let Re = y.get(He);
                        Re === void 0 && (Re = {},
                        y.set(He, Re));
                        const De = Q(Y);
                        if (De !== $.__cacheKey) {
                            Re[De] === void 0 && (Re[De] = {
                                texture: e.createTexture(),
                                usedTimes: 0
                            },
                            o.memory.textures++,
                            pe = !0),
                            Re[De].usedTimes++;
                            const rt = Re[$.__cacheKey];
                            rt !== void 0 && (Re[$.__cacheKey].usedTimes--,
                            rt.usedTimes === 0 && I(Y)),
                            $.__cacheKey = De,
                            $.__webglTexture = Re[De].texture
                        }
                        return pe
                    }
                    function se($, Y, pe) {
                        return Math.floor(Math.floor($ / pe) / Y)
                    }
                    function K($, Y, pe, He) {
                        const De = $.updateRanges;
                        if (De.length === 0)
                            n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, Y.width, Y.height, pe, He, Y.data);
                        else {
                            De.sort( (Ie, Je) => Ie.start - Je.start);
                            let rt = 0;
                            for (let Ie = 1; Ie < De.length; Ie++) {
                                const Je = De[rt]
                                  , Ze = De[Ie]
                                  , ht = Je.start + Je.count
                                  , lt = se(Ze.start, Y.width, 4)
                                  , At = se(Je.start, Y.width, 4);
                                Ze.start <= ht + 1 && lt === At && se(Ze.start + Ze.count - 1, Y.width, 4) === lt ? Je.count = Math.max(Je.count, Ze.start + Ze.count - Je.start) : (++rt,
                                De[rt] = Ze)
                            }
                            De.length = rt + 1;
                            const $e = e.getParameter(e.UNPACK_ROW_LENGTH)
                              , ct = e.getParameter(e.UNPACK_SKIP_PIXELS)
                              , gt = e.getParameter(e.UNPACK_SKIP_ROWS);
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, Y.width);
                            for (let Ie = 0, Je = De.length; Ie < Je; Ie++) {
                                const Ze = De[Ie]
                                  , ht = Math.floor(Ze.start / 4)
                                  , lt = Math.ceil(Ze.count / 4)
                                  , At = ht % Y.width
                                  , fe = Math.floor(ht / Y.width)
                                  , ot = lt
                                  , tt = 1;
                                e.pixelStorei(e.UNPACK_SKIP_PIXELS, At),
                                e.pixelStorei(e.UNPACK_SKIP_ROWS, fe),
                                n.texSubImage2D(e.TEXTURE_2D, 0, At, fe, ot, tt, pe, He, Y.data)
                            }
                            $.clearUpdateRanges(),
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, $e),
                            e.pixelStorei(e.UNPACK_SKIP_PIXELS, ct),
                            e.pixelStorei(e.UNPACK_SKIP_ROWS, gt)
                        }
                    }
                    function le($, Y, pe) {
                        let He = e.TEXTURE_2D;
                        (Y.isDataArrayTexture || Y.isCompressedArrayTexture) && (He = e.TEXTURE_2D_ARRAY),
                        Y.isData3DTexture && (He = e.TEXTURE_3D);
                        const Re = ie($, Y)
                          , De = Y.source;
                        n.bindTexture(He, $.__webglTexture, e.TEXTURE0 + pe);
                        const rt = i.get(De);
                        if (De.version !== rt.__version || Re === !0) {
                            n.activeTexture(e.TEXTURE0 + pe);
                            const $e = Rn.getPrimaries(Rn.workingColorSpace)
                              , ct = Y.colorSpace === rl ? null : Rn.getPrimaries(Y.colorSpace)
                              , gt = Y.colorSpace === rl || $e === ct ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, Y.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, Y.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, gt);
                            let Ie = M(Y.image, !1, s.maxTextureSize);
                            Ie = it(Y, Ie);
                            const Je = a.convert(Y.format, Y.colorSpace)
                              , Ze = a.convert(Y.type);
                            let ht = w(Y.internalFormat, Je, Ze, Y.colorSpace, Y.isVideoTexture);
                            H(He, Y);
                            let lt;
                            const At = Y.mipmaps
                              , fe = Y.isVideoTexture !== !0
                              , ot = rt.__version === void 0 || Re === !0
                              , tt = De.dataReady
                              , xt = O(Y, Ie);
                            if (Y.isDepthTexture)
                                ht = U(Y.format === pf, Y.type),
                                ot && (fe ? n.texStorage2D(e.TEXTURE_2D, 1, ht, Ie.width, Ie.height) : n.texImage2D(e.TEXTURE_2D, 0, ht, Ie.width, Ie.height, 0, Je, Ze, null));
                            else if (Y.isDataTexture)
                                if (At.length > 0) {
                                    fe && ot && n.texStorage2D(e.TEXTURE_2D, xt, ht, At[0].width, At[0].height);
                                    for (let Qe = 0, Ne = At.length; Qe < Ne; Qe++)
                                        lt = At[Qe],
                                        fe ? tt && n.texSubImage2D(e.TEXTURE_2D, Qe, 0, 0, lt.width, lt.height, Je, Ze, lt.data) : n.texImage2D(e.TEXTURE_2D, Qe, ht, lt.width, lt.height, 0, Je, Ze, lt.data);
                                    Y.generateMipmaps = !1
                                } else
                                    fe ? (ot && n.texStorage2D(e.TEXTURE_2D, xt, ht, Ie.width, Ie.height),
                                    tt && K(Y, Ie, Je, Ze)) : n.texImage2D(e.TEXTURE_2D, 0, ht, Ie.width, Ie.height, 0, Je, Ze, Ie.data);
                            else if (Y.isCompressedTexture)
                                if (Y.isCompressedArrayTexture) {
                                    fe && ot && n.texStorage3D(e.TEXTURE_2D_ARRAY, xt, ht, At[0].width, At[0].height, Ie.depth);
                                    for (let Qe = 0, Ne = At.length; Qe < Ne; Qe++)
                                        if (lt = At[Qe],
                                        Y.format !== ps)
                                            if (Je !== null)
                                                if (fe) {
                                                    if (tt)
                                                        if (Y.layerUpdates.size > 0) {
                                                            const dt = jT(lt.width, lt.height, Y.format, Y.type);
                                                            for (const _t of Y.layerUpdates) {
                                                                const Ct = lt.data.subarray(_t * dt / lt.data.BYTES_PER_ELEMENT, (_t + 1) * dt / lt.data.BYTES_PER_ELEMENT);
                                                                n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, Qe, 0, 0, _t, lt.width, lt.height, 1, Je, Ct)
                                                            }
                                                            Y.clearLayerUpdates()
                                                        } else
                                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, Qe, 0, 0, 0, lt.width, lt.height, Ie.depth, Je, lt.data)
                                                } else
                                                    n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, Qe, ht, lt.width, lt.height, Ie.depth, 0, lt.data, 0, 0);
                                            else
                                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                        else
                                            fe ? tt && n.texSubImage3D(e.TEXTURE_2D_ARRAY, Qe, 0, 0, 0, lt.width, lt.height, Ie.depth, Je, Ze, lt.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, Qe, ht, lt.width, lt.height, Ie.depth, 0, Je, Ze, lt.data)
                                } else {
                                    fe && ot && n.texStorage2D(e.TEXTURE_2D, xt, ht, At[0].width, At[0].height);
                                    for (let Qe = 0, Ne = At.length; Qe < Ne; Qe++)
                                        lt = At[Qe],
                                        Y.format !== ps ? Je !== null ? fe ? tt && n.compressedTexSubImage2D(e.TEXTURE_2D, Qe, 0, 0, lt.width, lt.height, Je, lt.data) : n.compressedTexImage2D(e.TEXTURE_2D, Qe, ht, lt.width, lt.height, 0, lt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : fe ? tt && n.texSubImage2D(e.TEXTURE_2D, Qe, 0, 0, lt.width, lt.height, Je, Ze, lt.data) : n.texImage2D(e.TEXTURE_2D, Qe, ht, lt.width, lt.height, 0, Je, Ze, lt.data)
                                }
                            else if (Y.isDataArrayTexture)
                                if (fe) {
                                    if (ot && n.texStorage3D(e.TEXTURE_2D_ARRAY, xt, ht, Ie.width, Ie.height, Ie.depth),
                                    tt)
                                        if (Y.layerUpdates.size > 0) {
                                            const Qe = jT(Ie.width, Ie.height, Y.format, Y.type);
                                            for (const Ne of Y.layerUpdates) {
                                                const dt = Ie.data.subarray(Ne * Qe / Ie.data.BYTES_PER_ELEMENT, (Ne + 1) * Qe / Ie.data.BYTES_PER_ELEMENT);
                                                n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, Ne, Ie.width, Ie.height, 1, Je, Ze, dt)
                                            }
                                            Y.clearLayerUpdates()
                                        } else
                                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, Je, Ze, Ie.data)
                                } else
                                    n.texImage3D(e.TEXTURE_2D_ARRAY, 0, ht, Ie.width, Ie.height, Ie.depth, 0, Je, Ze, Ie.data);
                            else if (Y.isData3DTexture)
                                fe ? (ot && n.texStorage3D(e.TEXTURE_3D, xt, ht, Ie.width, Ie.height, Ie.depth),
                                tt && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, Je, Ze, Ie.data)) : n.texImage3D(e.TEXTURE_3D, 0, ht, Ie.width, Ie.height, Ie.depth, 0, Je, Ze, Ie.data);
                            else if (Y.isFramebufferTexture) {
                                if (ot)
                                    if (fe)
                                        n.texStorage2D(e.TEXTURE_2D, xt, ht, Ie.width, Ie.height);
                                    else {
                                        let Qe = Ie.width
                                          , Ne = Ie.height;
                                        for (let dt = 0; dt < xt; dt++)
                                            n.texImage2D(e.TEXTURE_2D, dt, ht, Qe, Ne, 0, Je, Ze, null),
                                            Qe >>= 1,
                                            Ne >>= 1
                                    }
                            } else if (At.length > 0) {
                                if (fe && ot) {
                                    const Qe = je(At[0]);
                                    n.texStorage2D(e.TEXTURE_2D, xt, ht, Qe.width, Qe.height)
                                }
                                for (let Qe = 0, Ne = At.length; Qe < Ne; Qe++)
                                    lt = At[Qe],
                                    fe ? tt && n.texSubImage2D(e.TEXTURE_2D, Qe, 0, 0, Je, Ze, lt) : n.texImage2D(e.TEXTURE_2D, Qe, ht, Je, Ze, lt);
                                Y.generateMipmaps = !1
                            } else if (fe) {
                                if (ot) {
                                    const Qe = je(Ie);
                                    n.texStorage2D(e.TEXTURE_2D, xt, ht, Qe.width, Qe.height)
                                }
                                tt && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, Je, Ze, Ie)
                            } else
                                n.texImage2D(e.TEXTURE_2D, 0, ht, Je, Ze, Ie);
                            x(Y) && T(He),
                            rt.__version = De.version,
                            Y.onUpdate && Y.onUpdate(Y)
                        }
                        $.__version = Y.version
                    }
                    function ue($, Y, pe) {
                        if (Y.image.length !== 6)
                            return;
                        const He = ie($, Y)
                          , Re = Y.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, $.__webglTexture, e.TEXTURE0 + pe);
                        const De = i.get(Re);
                        if (Re.version !== De.__version || He === !0) {
                            n.activeTexture(e.TEXTURE0 + pe);
                            const rt = Rn.getPrimaries(Rn.workingColorSpace)
                              , $e = Y.colorSpace === rl ? null : Rn.getPrimaries(Y.colorSpace)
                              , ct = Y.colorSpace === rl || rt === $e ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, Y.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, Y.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, ct);
                            const gt = Y.isCompressedTexture || Y.image[0].isCompressedTexture
                              , Ie = Y.image[0] && Y.image[0].isDataTexture
                              , Je = [];
                            for (let Ne = 0; Ne < 6; Ne++)
                                !gt && !Ie ? Je[Ne] = M(Y.image[Ne], !0, s.maxCubemapSize) : Je[Ne] = Ie ? Y.image[Ne].image : Y.image[Ne],
                                Je[Ne] = it(Y, Je[Ne]);
                            const Ze = Je[0]
                              , ht = a.convert(Y.format, Y.colorSpace)
                              , lt = a.convert(Y.type)
                              , At = w(Y.internalFormat, ht, lt, Y.colorSpace)
                              , fe = Y.isVideoTexture !== !0
                              , ot = De.__version === void 0 || He === !0
                              , tt = Re.dataReady;
                            let xt = O(Y, Ze);
                            H(e.TEXTURE_CUBE_MAP, Y);
                            let Qe;
                            if (gt) {
                                fe && ot && n.texStorage2D(e.TEXTURE_CUBE_MAP, xt, At, Ze.width, Ze.height);
                                for (let Ne = 0; Ne < 6; Ne++) {
                                    Qe = Je[Ne].mipmaps;
                                    for (let dt = 0; dt < Qe.length; dt++) {
                                        const _t = Qe[dt];
                                        Y.format !== ps ? ht !== null ? fe ? tt && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt, 0, 0, _t.width, _t.height, ht, _t.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt, At, _t.width, _t.height, 0, _t.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : fe ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt, 0, 0, _t.width, _t.height, ht, lt, _t.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt, At, _t.width, _t.height, 0, ht, lt, _t.data)
                                    }
                                }
                            } else {
                                if (Qe = Y.mipmaps,
                                fe && ot) {
                                    Qe.length > 0 && xt++;
                                    const Ne = je(Je[0]);
                                    n.texStorage2D(e.TEXTURE_CUBE_MAP, xt, At, Ne.width, Ne.height)
                                }
                                for (let Ne = 0; Ne < 6; Ne++)
                                    if (Ie) {
                                        fe ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, 0, 0, Je[Ne].width, Je[Ne].height, ht, lt, Je[Ne].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, At, Je[Ne].width, Je[Ne].height, 0, ht, lt, Je[Ne].data);
                                        for (let dt = 0; dt < Qe.length; dt++) {
                                            const _t = Qe[dt].image[Ne].image;
                                            fe ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt + 1, 0, 0, _t.width, _t.height, ht, lt, _t.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt + 1, At, _t.width, _t.height, 0, ht, lt, _t.data)
                                        }
                                    } else {
                                        fe ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, 0, 0, ht, lt, Je[Ne]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, At, ht, lt, Je[Ne]);
                                        for (let dt = 0; dt < Qe.length; dt++) {
                                            const _t = Qe[dt];
                                            fe ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt + 1, 0, 0, ht, lt, _t.image[Ne]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, dt + 1, At, ht, lt, _t.image[Ne])
                                        }
                                    }
                            }
                            x(Y) && T(e.TEXTURE_CUBE_MAP),
                            De.__version = Re.version,
                            Y.onUpdate && Y.onUpdate(Y)
                        }
                        $.__version = Y.version
                    }
                    function de($, Y, pe, He, Re, De) {
                        const rt = a.convert(pe.format, pe.colorSpace)
                          , $e = a.convert(pe.type)
                          , ct = w(pe.internalFormat, rt, $e, pe.colorSpace)
                          , gt = i.get(Y)
                          , Ie = i.get(pe);
                        if (Ie.__renderTarget = Y,
                        !gt.__hasExternalTextures) {
                            const Je = Math.max(1, Y.width >> De)
                              , Ze = Math.max(1, Y.height >> De);
                            Re === e.TEXTURE_3D || Re === e.TEXTURE_2D_ARRAY ? n.texImage3D(Re, De, ct, Je, Ze, Y.depth, 0, rt, $e, null) : n.texImage2D(Re, De, ct, Je, Ze, 0, rt, $e, null)
                        }
                        n.bindFramebuffer(e.FRAMEBUFFER, $),
                        Ae(Y) ? c.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, He, Re, Ie.__webglTexture, 0, Te(Y)) : (Re === e.TEXTURE_2D || Re >= e.TEXTURE_CUBE_MAP_POSITIVE_X && Re <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, He, Re, Ie.__webglTexture, De),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                    function qe($, Y, pe) {
                        if (e.bindRenderbuffer(e.RENDERBUFFER, $),
                        Y.depthBuffer) {
                            const He = Y.depthTexture
                              , Re = He && He.isDepthTexture ? He.type : null
                              , De = U(Y.stencilBuffer, Re)
                              , rt = Y.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                              , $e = Te(Y);
                            Ae(Y) ? c.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, $e, De, Y.width, Y.height) : pe ? e.renderbufferStorageMultisample(e.RENDERBUFFER, $e, De, Y.width, Y.height) : e.renderbufferStorage(e.RENDERBUFFER, De, Y.width, Y.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, rt, e.RENDERBUFFER, $)
                        } else {
                            const He = Y.textures;
                            for (let Re = 0; Re < He.length; Re++) {
                                const De = He[Re]
                                  , rt = a.convert(De.format, De.colorSpace)
                                  , $e = a.convert(De.type)
                                  , ct = w(De.internalFormat, rt, $e, De.colorSpace)
                                  , gt = Te(Y);
                                pe && Ae(Y) === !1 ? e.renderbufferStorageMultisample(e.RENDERBUFFER, gt, ct, Y.width, Y.height) : Ae(Y) ? c.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, gt, ct, Y.width, Y.height) : e.renderbufferStorage(e.RENDERBUFFER, ct, Y.width, Y.height)
                            }
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null)
                    }
                    function ze($, Y) {
                        if (Y && Y.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, $),
                        !(Y.depthTexture && Y.depthTexture.isDepthTexture))
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        const pe = i.get(Y.depthTexture);
                        pe.__renderTarget = Y,
                        (!pe.__webglTexture || Y.depthTexture.image.width !== Y.width || Y.depthTexture.image.height !== Y.height) && (Y.depthTexture.image.width = Y.width,
                        Y.depthTexture.image.height = Y.height,
                        Y.depthTexture.needsUpdate = !0),
                        oe(Y.depthTexture, 0);
                        const He = pe.__webglTexture
                          , Re = Te(Y);
                        if (Y.depthTexture.format === vp)
                            Ae(Y) ? c.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, He, 0, Re) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, He, 0);
                        else if (Y.depthTexture.format === pf)
                            Ae(Y) ? c.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, He, 0, Re) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, He, 0);
                        else
                            throw new Error("Unknown depthTexture format")
                    }
                    function Ee($) {
                        const Y = i.get($)
                          , pe = $.isWebGLCubeRenderTarget === !0;
                        if (Y.__boundDepthTexture !== $.depthTexture) {
                            const He = $.depthTexture;
                            if (Y.__depthDisposeCallback && Y.__depthDisposeCallback(),
                            He) {
                                const Re = () => {
                                    delete Y.__boundDepthTexture,
                                    delete Y.__depthDisposeCallback,
                                    He.removeEventListener("dispose", Re)
                                }
                                ;
                                He.addEventListener("dispose", Re),
                                Y.__depthDisposeCallback = Re
                            }
                            Y.__boundDepthTexture = He
                        }
                        if ($.depthTexture && !Y.__autoAllocateDepthBuffer) {
                            if (pe)
                                throw new Error("target.depthTexture not supported in Cube render targets");
                            const He = $.texture.mipmaps;
                            He && He.length > 0 ? ze(Y.__webglFramebuffer[0], $) : ze(Y.__webglFramebuffer, $)
                        } else if (pe) {
                            Y.__webglDepthbuffer = [];
                            for (let He = 0; He < 6; He++)
                                if (n.bindFramebuffer(e.FRAMEBUFFER, Y.__webglFramebuffer[He]),
                                Y.__webglDepthbuffer[He] === void 0)
                                    Y.__webglDepthbuffer[He] = e.createRenderbuffer(),
                                    qe(Y.__webglDepthbuffer[He], $, !1);
                                else {
                                    const Re = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                      , De = Y.__webglDepthbuffer[He];
                                    e.bindRenderbuffer(e.RENDERBUFFER, De),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, Re, e.RENDERBUFFER, De)
                                }
                        } else {
                            const He = $.texture.mipmaps;
                            if (He && He.length > 0 ? n.bindFramebuffer(e.FRAMEBUFFER, Y.__webglFramebuffer[0]) : n.bindFramebuffer(e.FRAMEBUFFER, Y.__webglFramebuffer),
                            Y.__webglDepthbuffer === void 0)
                                Y.__webglDepthbuffer = e.createRenderbuffer(),
                                qe(Y.__webglDepthbuffer, $, !1);
                            else {
                                const Re = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , De = Y.__webglDepthbuffer;
                                e.bindRenderbuffer(e.RENDERBUFFER, De),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, Re, e.RENDERBUFFER, De)
                            }
                        }
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                    function re($, Y, pe) {
                        const He = i.get($);
                        Y !== void 0 && de(He.__webglFramebuffer, $, $.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                        pe !== void 0 && Ee($)
                    }
                    function Le($) {
                        const Y = $.texture
                          , pe = i.get($)
                          , He = i.get(Y);
                        $.addEventListener("dispose", N);
                        const Re = $.textures
                          , De = $.isWebGLCubeRenderTarget === !0
                          , rt = Re.length > 1;
                        if (rt || (He.__webglTexture === void 0 && (He.__webglTexture = e.createTexture()),
                        He.__version = Y.version,
                        o.memory.textures++),
                        De) {
                            pe.__webglFramebuffer = [];
                            for (let $e = 0; $e < 6; $e++)
                                if (Y.mipmaps && Y.mipmaps.length > 0) {
                                    pe.__webglFramebuffer[$e] = [];
                                    for (let ct = 0; ct < Y.mipmaps.length; ct++)
                                        pe.__webglFramebuffer[$e][ct] = e.createFramebuffer()
                                } else
                                    pe.__webglFramebuffer[$e] = e.createFramebuffer()
                        } else {
                            if (Y.mipmaps && Y.mipmaps.length > 0) {
                                pe.__webglFramebuffer = [];
                                for (let $e = 0; $e < Y.mipmaps.length; $e++)
                                    pe.__webglFramebuffer[$e] = e.createFramebuffer()
                            } else
                                pe.__webglFramebuffer = e.createFramebuffer();
                            if (rt)
                                for (let $e = 0, ct = Re.length; $e < ct; $e++) {
                                    const gt = i.get(Re[$e]);
                                    gt.__webglTexture === void 0 && (gt.__webglTexture = e.createTexture(),
                                    o.memory.textures++)
                                }
                            if ($.samples > 0 && Ae($) === !1) {
                                pe.__webglMultisampledFramebuffer = e.createFramebuffer(),
                                pe.__webglColorRenderbuffer = [],
                                n.bindFramebuffer(e.FRAMEBUFFER, pe.__webglMultisampledFramebuffer);
                                for (let $e = 0; $e < Re.length; $e++) {
                                    const ct = Re[$e];
                                    pe.__webglColorRenderbuffer[$e] = e.createRenderbuffer(),
                                    e.bindRenderbuffer(e.RENDERBUFFER, pe.__webglColorRenderbuffer[$e]);
                                    const gt = a.convert(ct.format, ct.colorSpace)
                                      , Ie = a.convert(ct.type)
                                      , Je = w(ct.internalFormat, gt, Ie, ct.colorSpace, $.isXRRenderTarget === !0)
                                      , Ze = Te($);
                                    e.renderbufferStorageMultisample(e.RENDERBUFFER, Ze, Je, $.width, $.height),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + $e, e.RENDERBUFFER, pe.__webglColorRenderbuffer[$e])
                                }
                                e.bindRenderbuffer(e.RENDERBUFFER, null),
                                $.depthBuffer && (pe.__webglDepthRenderbuffer = e.createRenderbuffer(),
                                qe(pe.__webglDepthRenderbuffer, $, !0)),
                                n.bindFramebuffer(e.FRAMEBUFFER, null)
                            }
                        }
                        if (De) {
                            n.bindTexture(e.TEXTURE_CUBE_MAP, He.__webglTexture),
                            H(e.TEXTURE_CUBE_MAP, Y);
                            for (let $e = 0; $e < 6; $e++)
                                if (Y.mipmaps && Y.mipmaps.length > 0)
                                    for (let ct = 0; ct < Y.mipmaps.length; ct++)
                                        de(pe.__webglFramebuffer[$e][ct], $, Y, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + $e, ct);
                                else
                                    de(pe.__webglFramebuffer[$e], $, Y, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + $e, 0);
                            x(Y) && T(e.TEXTURE_CUBE_MAP),
                            n.unbindTexture()
                        } else if (rt) {
                            for (let $e = 0, ct = Re.length; $e < ct; $e++) {
                                const gt = Re[$e]
                                  , Ie = i.get(gt);
                                let Je = e.TEXTURE_2D;
                                ($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) && (Je = $.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                                n.bindTexture(Je, Ie.__webglTexture),
                                H(Je, gt),
                                de(pe.__webglFramebuffer, $, gt, e.COLOR_ATTACHMENT0 + $e, Je, 0),
                                x(gt) && T(Je)
                            }
                            n.unbindTexture()
                        } else {
                            let $e = e.TEXTURE_2D;
                            if (($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) && ($e = $.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                            n.bindTexture($e, He.__webglTexture),
                            H($e, Y),
                            Y.mipmaps && Y.mipmaps.length > 0)
                                for (let ct = 0; ct < Y.mipmaps.length; ct++)
                                    de(pe.__webglFramebuffer[ct], $, Y, e.COLOR_ATTACHMENT0, $e, ct);
                            else
                                de(pe.__webglFramebuffer, $, Y, e.COLOR_ATTACHMENT0, $e, 0);
                            x(Y) && T($e),
                            n.unbindTexture()
                        }
                        $.depthBuffer && Ee($)
                    }
                    function he($) {
                        const Y = $.textures;
                        for (let pe = 0, He = Y.length; pe < He; pe++) {
                            const Re = Y[pe];
                            if (x(Re)) {
                                const De = D($)
                                  , rt = i.get(Re).__webglTexture;
                                n.bindTexture(De, rt),
                                T(De),
                                n.unbindTexture()
                            }
                        }
                    }
                    const ye = []
                      , xe = [];
                    function ge($) {
                        if ($.samples > 0) {
                            if (Ae($) === !1) {
                                const Y = $.textures
                                  , pe = $.width
                                  , He = $.height;
                                let Re = e.COLOR_BUFFER_BIT;
                                const De = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , rt = i.get($)
                                  , $e = Y.length > 1;
                                if ($e)
                                    for (let gt = 0; gt < Y.length; gt++)
                                        n.bindFramebuffer(e.FRAMEBUFFER, rt.__webglMultisampledFramebuffer),
                                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + gt, e.RENDERBUFFER, null),
                                        n.bindFramebuffer(e.FRAMEBUFFER, rt.__webglFramebuffer),
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + gt, e.TEXTURE_2D, null, 0);
                                n.bindFramebuffer(e.READ_FRAMEBUFFER, rt.__webglMultisampledFramebuffer);
                                const ct = $.texture.mipmaps;
                                ct && ct.length > 0 ? n.bindFramebuffer(e.DRAW_FRAMEBUFFER, rt.__webglFramebuffer[0]) : n.bindFramebuffer(e.DRAW_FRAMEBUFFER, rt.__webglFramebuffer);
                                for (let gt = 0; gt < Y.length; gt++) {
                                    if ($.resolveDepthBuffer && ($.depthBuffer && (Re |= e.DEPTH_BUFFER_BIT),
                                    $.stencilBuffer && $.resolveStencilBuffer && (Re |= e.STENCIL_BUFFER_BIT)),
                                    $e) {
                                        e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, rt.__webglColorRenderbuffer[gt]);
                                        const Ie = i.get(Y[gt]).__webglTexture;
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, Ie, 0)
                                    }
                                    e.blitFramebuffer(0, 0, pe, He, 0, 0, pe, He, Re, e.NEAREST),
                                    u === !0 && (ye.length = 0,
                                    xe.length = 0,
                                    ye.push(e.COLOR_ATTACHMENT0 + gt),
                                    $.depthBuffer && $.resolveDepthBuffer === !1 && (ye.push(De),
                                    xe.push(De),
                                    e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, xe)),
                                    e.invalidateFramebuffer(e.READ_FRAMEBUFFER, ye))
                                }
                                if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                                $e)
                                    for (let gt = 0; gt < Y.length; gt++) {
                                        n.bindFramebuffer(e.FRAMEBUFFER, rt.__webglMultisampledFramebuffer),
                                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + gt, e.RENDERBUFFER, rt.__webglColorRenderbuffer[gt]);
                                        const Ie = i.get(Y[gt]).__webglTexture;
                                        n.bindFramebuffer(e.FRAMEBUFFER, rt.__webglFramebuffer),
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + gt, e.TEXTURE_2D, Ie, 0)
                                    }
                                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, rt.__webglMultisampledFramebuffer)
                            } else if ($.depthBuffer && $.resolveDepthBuffer === !1 && u) {
                                const Y = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [Y])
                            }
                        }
                    }
                    function Te($) {
                        return Math.min(s.maxSamples, $.samples)
                    }
                    function Ae($) {
                        const Y = i.get($);
                        return $.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && Y.__useRenderToTexture !== !1
                    }
                    function we($) {
                        const Y = o.render.frame;
                        m.get($) !== Y && (m.set($, Y),
                        $.update())
                    }
                    function it($, Y) {
                        const pe = $.colorSpace
                          , He = $.format
                          , Re = $.type;
                        return $.isCompressedTexture === !0 || $.isVideoTexture === !0 || pe !== rc && pe !== rl && (Rn.getTransfer(pe) === Jn ? (He !== ps || Re !== gi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", pe)),
                        Y
                    }
                    function je($) {
                        return typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement ? (f.width = $.naturalWidth || $.width,
                        f.height = $.naturalHeight || $.height) : typeof VideoFrame < "u" && $ instanceof VideoFrame ? (f.width = $.displayWidth,
                        f.height = $.displayHeight) : (f.width = $.width,
                        f.height = $.height),
                        f
                    }
                    this.allocateTextureUnit = q,
                    this.resetTextureUnits = X,
                    this.setTexture2D = oe,
                    this.setTexture2DArray = k,
                    this.setTexture3D = W,
                    this.setTextureCube = V,
                    this.rebindTextures = re,
                    this.setupRenderTarget = Le,
                    this.updateRenderTargetMipmap = he,
                    this.updateMultisampleRenderTarget = ge,
                    this.setupDepthRenderbuffer = Ee,
                    this.setupFrameBufferTexture = de,
                    this.useMultisampledRTT = Ae
                }
                function y1(e, t) {
                    function n(i, s=rl) {
                        let a;
                        const o = Rn.getTransfer(s);
                        if (i === gi)
                            return e.UNSIGNED_BYTE;
                        if (i === Gy)
                            return e.UNSIGNED_SHORT_4_4_4_4;
                        if (i === Vy)
                            return e.UNSIGNED_SHORT_5_5_5_1;
                        if (i === SA)
                            return e.UNSIGNED_INT_5_9_9_9_REV;
                        if (i === xA)
                            return e.UNSIGNED_INT_10F_11F_11F_REV;
                        if (i === yA)
                            return e.BYTE;
                        if (i === _A)
                            return e.SHORT;
                        if (i === mp)
                            return e.UNSIGNED_SHORT;
                        if (i === Hy)
                            return e.INT;
                        if (i === ac)
                            return e.UNSIGNED_INT;
                        if (i === na)
                            return e.FLOAT;
                        if (i === ff)
                            return e.HALF_FLOAT;
                        if (i === AA)
                            return e.ALPHA;
                        if (i === TA)
                            return e.RGB;
                        if (i === ps)
                            return e.RGBA;
                        if (i === vp)
                            return e.DEPTH_COMPONENT;
                        if (i === pf)
                            return e.DEPTH_STENCIL;
                        if (i === gp)
                            return e.RED;
                        if (i === ag)
                            return e.RED_INTEGER;
                        if (i === ky)
                            return e.RG;
                        if (i === Xy)
                            return e.RG_INTEGER;
                        if (i === Wy)
                            return e.RGBA_INTEGER;
                        if (i === rg || i === og || i === lg || i === cg)
                            if (o === Jn)
                                if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                                a !== null) {
                                    if (i === rg)
                                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (i === og)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (i === lg)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (i === cg)
                                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                } else
                                    return null;
                            else if (a = t.get("WEBGL_compressed_texture_s3tc"),
                            a !== null) {
                                if (i === rg)
                                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (i === og)
                                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (i === lg)
                                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (i === cg)
                                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } else
                                return null;
                        if (i === Yy || i === qy || i === jy || i === Qy)
                            if (a = t.get("WEBGL_compressed_texture_pvrtc"),
                            a !== null) {
                                if (i === Yy)
                                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (i === qy)
                                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (i === jy)
                                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (i === Qy)
                                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            } else
                                return null;
                        if (i === Zy || i === Ky || i === Jy)
                            if (a = t.get("WEBGL_compressed_texture_etc"),
                            a !== null) {
                                if (i === Zy || i === Ky)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                                if (i === Jy)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                            } else
                                return null;
                        if (i === $y || i === e_ || i === t_ || i === n_ || i === i_ || i === s_ || i === a_ || i === r_ || i === o_ || i === l_ || i === c_ || i === u_ || i === h_ || i === f_)
                            if (a = t.get("WEBGL_compressed_texture_astc"),
                            a !== null) {
                                if (i === $y)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (i === e_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (i === t_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (i === n_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (i === i_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (i === s_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (i === a_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (i === r_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (i === o_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (i === l_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (i === c_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (i === u_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (i === h_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (i === f_)
                                    return o === Jn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                            } else
                                return null;
                        if (i === d_ || i === p_ || i === m_)
                            if (a = t.get("EXT_texture_compression_bptc"),
                            a !== null) {
                                if (i === d_)
                                    return o === Jn ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (i === p_)
                                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (i === m_)
                                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            } else
                                return null;
                        if (i === v_ || i === g_ || i === y_ || i === __)
                            if (a = t.get("EXT_texture_compression_rgtc"),
                            a !== null) {
                                if (i === v_)
                                    return a.COMPRESSED_RED_RGTC1_EXT;
                                if (i === g_)
                                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (i === y_)
                                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (i === __)
                                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            } else
                                return null;
                        return i === df ? e.UNSIGNED_INT_24_8 : e[i] !== void 0 ? e[i] : null
                    }
                    return {
                        convert: n
                    }
                }
                const gz = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
                  , yz = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
                var _z = class {
                    constructor() {
                        this.texture = null,
                        this.mesh = null,
                        this.depthNear = 0,
                        this.depthFar = 0
                    }
                    init(e, t) {
                        if (this.texture === null) {
                            const n = new uT(e.texture);
                            (e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) && (this.depthNear = e.depthNear,
                            this.depthFar = e.depthFar),
                            this.texture = n
                        }
                    }
                    getMesh(e) {
                        if (this.texture !== null && this.mesh === null) {
                            const t = e.cameras[0].viewport
                              , n = new kn({
                                vertexShader: gz,
                                fragmentShader: yz,
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: t.z
                                    },
                                    depthHeight: {
                                        value: t.w
                                    }
                                }
                            });
                            this.mesh = new oi(new wf(20,20),n)
                        }
                        return this.mesh
                    }
                    reset() {
                        this.texture = null,
                        this.mesh = null
                    }
                    getDepthTexture() {
                        return this.texture
                    }
                }
                  , Sz = class extends qr {
                    constructor(e, t) {
                        super();
                        const n = this;
                        let i = null
                          , s = 1
                          , a = null
                          , o = "local-floor"
                          , c = 1
                          , u = null
                          , f = null
                          , m = null
                          , v = null
                          , y = null
                          , S = null;
                        const A = typeof XRWebGLBinding < "u"
                          , M = new _z
                          , x = {}
                          , T = t.getContextAttributes();
                        let D = null
                          , w = null;
                        const U = []
                          , O = []
                          , L = new Oe;
                        let N = null;
                        const z = new Hi;
                        z.viewport = new hn;
                        const I = new Hi;
                        I.viewport = new hn;
                        const B = [z, I]
                          , G = new C2;
                        let X = null
                          , q = null;
                        this.cameraAutoUpdate = !0,
                        this.enabled = !1,
                        this.isPresenting = !1,
                        this.getController = function(K) {
                            let le = U[K];
                            return le === void 0 && (le = new G_,
                            U[K] = le),
                            le.getTargetRaySpace()
                        }
                        ,
                        this.getControllerGrip = function(K) {
                            let le = U[K];
                            return le === void 0 && (le = new G_,
                            U[K] = le),
                            le.getGripSpace()
                        }
                        ,
                        this.getHand = function(K) {
                            let le = U[K];
                            return le === void 0 && (le = new G_,
                            U[K] = le),
                            le.getHandSpace()
                        }
                        ;
                        function Q(K) {
                            const le = O.indexOf(K.inputSource);
                            if (le === -1)
                                return;
                            const ue = U[le];
                            ue !== void 0 && (ue.update(K.inputSource, K.frame, u || a),
                            ue.dispatchEvent({
                                type: K.type,
                                data: K.inputSource
                            }))
                        }
                        function oe() {
                            i.removeEventListener("select", Q),
                            i.removeEventListener("selectstart", Q),
                            i.removeEventListener("selectend", Q),
                            i.removeEventListener("squeeze", Q),
                            i.removeEventListener("squeezestart", Q),
                            i.removeEventListener("squeezeend", Q),
                            i.removeEventListener("end", oe),
                            i.removeEventListener("inputsourceschange", k);
                            for (let K = 0; K < U.length; K++) {
                                const le = O[K];
                                le !== null && (O[K] = null,
                                U[K].disconnect(le))
                            }
                            X = null,
                            q = null,
                            M.reset();
                            for (const K in x)
                                delete x[K];
                            e.setRenderTarget(D),
                            y = null,
                            v = null,
                            m = null,
                            i = null,
                            w = null,
                            se.stop(),
                            n.isPresenting = !1,
                            e.setPixelRatio(N),
                            e.setSize(L.width, L.height, !1),
                            n.dispatchEvent({
                                type: "sessionend"
                            })
                        }
                        this.setFramebufferScaleFactor = function(K) {
                            s = K,
                            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }
                        ,
                        this.setReferenceSpaceType = function(K) {
                            o = K,
                            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }
                        ,
                        this.getReferenceSpace = function() {
                            return u || a
                        }
                        ,
                        this.setReferenceSpace = function(K) {
                            u = K
                        }
                        ,
                        this.getBaseLayer = function() {
                            return v !== null ? v : y
                        }
                        ,
                        this.getBinding = function() {
                            return m === null && A && (m = new XRWebGLBinding(i,t)),
                            m
                        }
                        ,
                        this.getFrame = function() {
                            return S
                        }
                        ,
                        this.getSession = function() {
                            return i
                        }
                        ,
                        this.setSession = async function(K) {
                            if (i = K,
                            i !== null) {
                                if (D = e.getRenderTarget(),
                                i.addEventListener("select", Q),
                                i.addEventListener("selectstart", Q),
                                i.addEventListener("selectend", Q),
                                i.addEventListener("squeeze", Q),
                                i.addEventListener("squeezestart", Q),
                                i.addEventListener("squeezeend", Q),
                                i.addEventListener("end", oe),
                                i.addEventListener("inputsourceschange", k),
                                T.xrCompatible !== !0 && await t.makeXRCompatible(),
                                N = e.getPixelRatio(),
                                e.getSize(L),
                                A && "createProjectionLayer"in XRWebGLBinding.prototype) {
                                    let le = null
                                      , ue = null
                                      , de = null;
                                    T.depth && (de = T.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                                    le = T.stencil ? pf : vp,
                                    ue = T.stencil ? df : ac);
                                    const qe = {
                                        colorFormat: t.RGBA8,
                                        depthFormat: de,
                                        scaleFactor: s
                                    };
                                    m = this.getBinding(),
                                    v = m.createProjectionLayer(qe),
                                    i.updateRenderState({
                                        layers: [v]
                                    }),
                                    e.setPixelRatio(1),
                                    e.setSize(v.textureWidth, v.textureHeight, !1),
                                    w = new Vn(v.textureWidth,v.textureHeight,{
                                        format: ps,
                                        type: gi,
                                        depthTexture: new Og(v.textureWidth,v.textureHeight,ue,void 0,void 0,void 0,void 0,void 0,void 0,le),
                                        stencilBuffer: T.stencil,
                                        colorSpace: e.outputColorSpace,
                                        samples: T.antialias ? 4 : 0,
                                        resolveDepthBuffer: v.ignoreDepthValues === !1,
                                        resolveStencilBuffer: v.ignoreDepthValues === !1
                                    })
                                } else {
                                    const le = {
                                        antialias: T.antialias,
                                        alpha: !0,
                                        depth: T.depth,
                                        stencil: T.stencil,
                                        framebufferScaleFactor: s
                                    };
                                    y = new XRWebGLLayer(i,t,le),
                                    i.updateRenderState({
                                        baseLayer: y
                                    }),
                                    e.setPixelRatio(1),
                                    e.setSize(y.framebufferWidth, y.framebufferHeight, !1),
                                    w = new Vn(y.framebufferWidth,y.framebufferHeight,{
                                        format: ps,
                                        type: gi,
                                        colorSpace: e.outputColorSpace,
                                        stencilBuffer: T.stencil,
                                        resolveDepthBuffer: y.ignoreDepthValues === !1,
                                        resolveStencilBuffer: y.ignoreDepthValues === !1
                                    })
                                }
                                w.isXRRenderTarget = !0,
                                this.setFoveation(c),
                                u = null,
                                a = await i.requestReferenceSpace(o),
                                se.setContext(i),
                                se.start(),
                                n.isPresenting = !0,
                                n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        }
                        ,
                        this.getEnvironmentBlendMode = function() {
                            if (i !== null)
                                return i.environmentBlendMode
                        }
                        ,
                        this.getDepthTexture = function() {
                            return M.getDepthTexture()
                        }
                        ;
                        function k(K) {
                            for (let le = 0; le < K.removed.length; le++) {
                                const ue = K.removed[le]
                                  , de = O.indexOf(ue);
                                de >= 0 && (O[de] = null,
                                U[de].disconnect(ue))
                            }
                            for (let le = 0; le < K.added.length; le++) {
                                const ue = K.added[le];
                                let de = O.indexOf(ue);
                                if (de === -1) {
                                    for (let ze = 0; ze < U.length; ze++)
                                        if (ze >= O.length) {
                                            O.push(ue),
                                            de = ze;
                                            break
                                        } else if (O[ze] === null) {
                                            O[ze] = ue,
                                            de = ze;
                                            break
                                        }
                                    if (de === -1)
                                        break
                                }
                                const qe = U[de];
                                qe && qe.connect(ue)
                            }
                        }
                        const W = new ae
                          , V = new ae;
                        function Z(K, le, ue) {
                            W.setFromMatrixPosition(le.matrixWorld),
                            V.setFromMatrixPosition(ue.matrixWorld);
                            const de = W.distanceTo(V)
                              , qe = le.projectionMatrix.elements
                              , ze = ue.projectionMatrix.elements
                              , Ee = qe[14] / (qe[10] - 1)
                              , re = qe[14] / (qe[10] + 1)
                              , Le = (qe[9] + 1) / qe[5]
                              , he = (qe[9] - 1) / qe[5]
                              , ye = (qe[8] - 1) / qe[0]
                              , xe = (ze[8] + 1) / ze[0]
                              , ge = Ee * ye
                              , Te = Ee * xe
                              , Ae = de / (-ye + xe)
                              , we = Ae * -ye;
                            if (le.matrixWorld.decompose(K.position, K.quaternion, K.scale),
                            K.translateX(we),
                            K.translateZ(Ae),
                            K.matrixWorld.compose(K.position, K.quaternion, K.scale),
                            K.matrixWorldInverse.copy(K.matrixWorld).invert(),
                            qe[10] === -1)
                                K.projectionMatrix.copy(le.projectionMatrix),
                                K.projectionMatrixInverse.copy(le.projectionMatrixInverse);
                            else {
                                const it = Ee + Ae
                                  , je = re + Ae
                                  , $ = ge - we
                                  , Y = Te + (de - we)
                                  , pe = Le * re / je * it
                                  , He = he * re / je * it;
                                K.projectionMatrix.makePerspective($, Y, pe, He, it, je),
                                K.projectionMatrixInverse.copy(K.projectionMatrix).invert()
                            }
                        }
                        function j(K, le) {
                            le === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(le.matrixWorld, K.matrix),
                            K.matrixWorldInverse.copy(K.matrixWorld).invert()
                        }
                        this.updateCamera = function(K) {
                            if (i === null)
                                return;
                            let le = K.near
                              , ue = K.far;
                            M.texture !== null && (M.depthNear > 0 && (le = M.depthNear),
                            M.depthFar > 0 && (ue = M.depthFar)),
                            G.near = I.near = z.near = le,
                            G.far = I.far = z.far = ue,
                            (X !== G.near || q !== G.far) && (i.updateRenderState({
                                depthNear: G.near,
                                depthFar: G.far
                            }),
                            X = G.near,
                            q = G.far),
                            G.layers.mask = K.layers.mask | 6,
                            z.layers.mask = G.layers.mask & 3,
                            I.layers.mask = G.layers.mask & 5;
                            const de = K.parent
                              , qe = G.cameras;
                            j(G, de);
                            for (let ze = 0; ze < qe.length; ze++)
                                j(qe[ze], de);
                            qe.length === 2 ? Z(G, z, I) : G.projectionMatrix.copy(z.projectionMatrix),
                            ee(K, G, de)
                        }
                        ;
                        function ee(K, le, ue) {
                            ue === null ? K.matrix.copy(le.matrixWorld) : (K.matrix.copy(ue.matrixWorld),
                            K.matrix.invert(),
                            K.matrix.multiply(le.matrixWorld)),
                            K.matrix.decompose(K.position, K.quaternion, K.scale),
                            K.updateMatrixWorld(!0),
                            K.projectionMatrix.copy(le.projectionMatrix),
                            K.projectionMatrixInverse.copy(le.projectionMatrixInverse),
                            K.isPerspectiveCamera && (K.fov = _p * 2 * Math.atan(1 / K.projectionMatrix.elements[5]),
                            K.zoom = 1)
                        }
                        this.getCamera = function() {
                            return G
                        }
                        ,
                        this.getFoveation = function() {
                            if (!(v === null && y === null))
                                return c
                        }
                        ,
                        this.setFoveation = function(K) {
                            c = K,
                            v !== null && (v.fixedFoveation = K),
                            y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = K)
                        }
                        ,
                        this.hasDepthSensing = function() {
                            return M.texture !== null
                        }
                        ,
                        this.getDepthSensingMesh = function() {
                            return M.getMesh(G)
                        }
                        ,
                        this.getCameraTexture = function(K) {
                            return x[K]
                        }
                        ;
                        let H = null;
                        function ie(K, le) {
                            if (f = le.getViewerPose(u || a),
                            S = le,
                            f !== null) {
                                const ue = f.views;
                                y !== null && (e.setRenderTargetFramebuffer(w, y.framebuffer),
                                e.setRenderTarget(w));
                                let de = !1;
                                ue.length !== G.cameras.length && (G.cameras.length = 0,
                                de = !0);
                                for (let ze = 0; ze < ue.length; ze++) {
                                    const Ee = ue[ze];
                                    let re = null;
                                    if (y !== null)
                                        re = y.getViewport(Ee);
                                    else {
                                        const he = m.getViewSubImage(v, Ee);
                                        re = he.viewport,
                                        ze === 0 && (e.setRenderTargetTextures(w, he.colorTexture, he.depthStencilTexture),
                                        e.setRenderTarget(w))
                                    }
                                    let Le = B[ze];
                                    Le === void 0 && (Le = new Hi,
                                    Le.layers.enable(ze),
                                    Le.viewport = new hn,
                                    B[ze] = Le),
                                    Le.matrix.fromArray(Ee.transform.matrix),
                                    Le.matrix.decompose(Le.position, Le.quaternion, Le.scale),
                                    Le.projectionMatrix.fromArray(Ee.projectionMatrix),
                                    Le.projectionMatrixInverse.copy(Le.projectionMatrix).invert(),
                                    Le.viewport.set(re.x, re.y, re.width, re.height),
                                    ze === 0 && (G.matrix.copy(Le.matrix),
                                    G.matrix.decompose(G.position, G.quaternion, G.scale)),
                                    de === !0 && G.cameras.push(Le)
                                }
                                const qe = i.enabledFeatures;
                                if (qe && qe.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && A) {
                                    m = n.getBinding();
                                    const ze = m.getDepthInformation(ue[0]);
                                    ze && ze.isValid && ze.texture && M.init(ze, i.renderState)
                                }
                                if (qe && qe.includes("camera-access") && A) {
                                    e.state.unbindTexture(),
                                    m = n.getBinding();
                                    for (let ze = 0; ze < ue.length; ze++) {
                                        const Ee = ue[ze].camera;
                                        if (Ee) {
                                            let re = x[Ee];
                                            re || (re = new uT,
                                            x[Ee] = re),
                                            re.sourceTexture = m.getCameraImage(Ee)
                                        }
                                    }
                                }
                            }
                            for (let ue = 0; ue < U.length; ue++) {
                                const de = O[ue]
                                  , qe = U[ue];
                                de !== null && qe !== void 0 && qe.update(de, le, u || a)
                            }
                            H && H(K, le),
                            le.detectedPlanes && n.dispatchEvent({
                                type: "planesdetected",
                                data: le
                            }),
                            S = null
                        }
                        const se = new X2;
                        se.setAnimationLoop(ie),
                        this.setAnimationLoop = function(K) {
                            H = K
                        }
                        ,
                        this.dispose = function() {}
                    }
                }
                ;
                const Gf = new Co
                  , xz = new Xt;
                function Az(e, t) {
                    function n(x, T) {
                        x.matrixAutoUpdate === !0 && x.updateMatrix(),
                        T.value.copy(x.matrix)
                    }
                    function i(x, T) {
                        T.color.getRGB(x.fogColor.value, PC(e)),
                        T.isFog ? (x.fogNear.value = T.near,
                        x.fogFar.value = T.far) : T.isFogExp2 && (x.fogDensity.value = T.density)
                    }
                    function s(x, T, D, w, U) {
                        T.isMeshBasicMaterial || T.isMeshLambertMaterial ? a(x, T) : T.isMeshToonMaterial ? (a(x, T),
                        v(x, T)) : T.isMeshPhongMaterial ? (a(x, T),
                        m(x, T)) : T.isMeshStandardMaterial ? (a(x, T),
                        y(x, T),
                        T.isMeshPhysicalMaterial && S(x, T, U)) : T.isMeshMatcapMaterial ? (a(x, T),
                        A(x, T)) : T.isMeshDepthMaterial ? a(x, T) : T.isMeshDistanceMaterial ? (a(x, T),
                        M(x, T)) : T.isMeshNormalMaterial ? a(x, T) : T.isLineBasicMaterial ? (o(x, T),
                        T.isLineDashedMaterial && c(x, T)) : T.isPointsMaterial ? u(x, T, D, w) : T.isSpriteMaterial ? f(x, T) : T.isShadowMaterial ? (x.color.value.copy(T.color),
                        x.opacity.value = T.opacity) : T.isShaderMaterial && (T.uniformsNeedUpdate = !1)
                    }
                    function a(x, T) {
                        x.opacity.value = T.opacity,
                        T.color && x.diffuse.value.copy(T.color),
                        T.emissive && x.emissive.value.copy(T.emissive).multiplyScalar(T.emissiveIntensity),
                        T.map && (x.map.value = T.map,
                        n(T.map, x.mapTransform)),
                        T.alphaMap && (x.alphaMap.value = T.alphaMap,
                        n(T.alphaMap, x.alphaMapTransform)),
                        T.bumpMap && (x.bumpMap.value = T.bumpMap,
                        n(T.bumpMap, x.bumpMapTransform),
                        x.bumpScale.value = T.bumpScale,
                        T.side === Ds && (x.bumpScale.value *= -1)),
                        T.normalMap && (x.normalMap.value = T.normalMap,
                        n(T.normalMap, x.normalMapTransform),
                        x.normalScale.value.copy(T.normalScale),
                        T.side === Ds && x.normalScale.value.negate()),
                        T.displacementMap && (x.displacementMap.value = T.displacementMap,
                        n(T.displacementMap, x.displacementMapTransform),
                        x.displacementScale.value = T.displacementScale,
                        x.displacementBias.value = T.displacementBias),
                        T.emissiveMap && (x.emissiveMap.value = T.emissiveMap,
                        n(T.emissiveMap, x.emissiveMapTransform)),
                        T.specularMap && (x.specularMap.value = T.specularMap,
                        n(T.specularMap, x.specularMapTransform)),
                        T.alphaTest > 0 && (x.alphaTest.value = T.alphaTest);
                        const D = t.get(T)
                          , w = D.envMap
                          , U = D.envMapRotation;
                        w && (x.envMap.value = w,
                        Gf.copy(U),
                        Gf.x *= -1,
                        Gf.y *= -1,
                        Gf.z *= -1,
                        w.isCubeTexture && w.isRenderTargetTexture === !1 && (Gf.y *= -1,
                        Gf.z *= -1),
                        x.envMapRotation.value.setFromMatrix4(xz.makeRotationFromEuler(Gf)),
                        x.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
                        x.reflectivity.value = T.reflectivity,
                        x.ior.value = T.ior,
                        x.refractionRatio.value = T.refractionRatio),
                        T.lightMap && (x.lightMap.value = T.lightMap,
                        x.lightMapIntensity.value = T.lightMapIntensity,
                        n(T.lightMap, x.lightMapTransform)),
                        T.aoMap && (x.aoMap.value = T.aoMap,
                        x.aoMapIntensity.value = T.aoMapIntensity,
                        n(T.aoMap, x.aoMapTransform))
                    }
                    function o(x, T) {
                        x.diffuse.value.copy(T.color),
                        x.opacity.value = T.opacity,
                        T.map && (x.map.value = T.map,
                        n(T.map, x.mapTransform))
                    }
                    function c(x, T) {
                        x.dashSize.value = T.dashSize,
                        x.totalSize.value = T.dashSize + T.gapSize,
                        x.scale.value = T.scale
                    }
                    function u(x, T, D, w) {
                        x.diffuse.value.copy(T.color),
                        x.opacity.value = T.opacity,
                        x.size.value = T.size * D,
                        x.scale.value = w * .5,
                        T.map && (x.map.value = T.map,
                        n(T.map, x.uvTransform)),
                        T.alphaMap && (x.alphaMap.value = T.alphaMap,
                        n(T.alphaMap, x.alphaMapTransform)),
                        T.alphaTest > 0 && (x.alphaTest.value = T.alphaTest)
                    }
                    function f(x, T) {
                        x.diffuse.value.copy(T.color),
                        x.opacity.value = T.opacity,
                        x.rotation.value = T.rotation,
                        T.map && (x.map.value = T.map,
                        n(T.map, x.mapTransform)),
                        T.alphaMap && (x.alphaMap.value = T.alphaMap,
                        n(T.alphaMap, x.alphaMapTransform)),
                        T.alphaTest > 0 && (x.alphaTest.value = T.alphaTest)
                    }
                    function m(x, T) {
                        x.specular.value.copy(T.specular),
                        x.shininess.value = Math.max(T.shininess, 1e-4)
                    }
                    function v(x, T) {
                        T.gradientMap && (x.gradientMap.value = T.gradientMap)
                    }
                    function y(x, T) {
                        x.metalness.value = T.metalness,
                        T.metalnessMap && (x.metalnessMap.value = T.metalnessMap,
                        n(T.metalnessMap, x.metalnessMapTransform)),
                        x.roughness.value = T.roughness,
                        T.roughnessMap && (x.roughnessMap.value = T.roughnessMap,
                        n(T.roughnessMap, x.roughnessMapTransform)),
                        T.envMap && (x.envMapIntensity.value = T.envMapIntensity)
                    }
                    function S(x, T, D) {
                        x.ior.value = T.ior,
                        T.sheen > 0 && (x.sheenColor.value.copy(T.sheenColor).multiplyScalar(T.sheen),
                        x.sheenRoughness.value = T.sheenRoughness,
                        T.sheenColorMap && (x.sheenColorMap.value = T.sheenColorMap,
                        n(T.sheenColorMap, x.sheenColorMapTransform)),
                        T.sheenRoughnessMap && (x.sheenRoughnessMap.value = T.sheenRoughnessMap,
                        n(T.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
                        T.clearcoat > 0 && (x.clearcoat.value = T.clearcoat,
                        x.clearcoatRoughness.value = T.clearcoatRoughness,
                        T.clearcoatMap && (x.clearcoatMap.value = T.clearcoatMap,
                        n(T.clearcoatMap, x.clearcoatMapTransform)),
                        T.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = T.clearcoatRoughnessMap,
                        n(T.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
                        T.clearcoatNormalMap && (x.clearcoatNormalMap.value = T.clearcoatNormalMap,
                        n(T.clearcoatNormalMap, x.clearcoatNormalMapTransform),
                        x.clearcoatNormalScale.value.copy(T.clearcoatNormalScale),
                        T.side === Ds && x.clearcoatNormalScale.value.negate())),
                        T.dispersion > 0 && (x.dispersion.value = T.dispersion),
                        T.iridescence > 0 && (x.iridescence.value = T.iridescence,
                        x.iridescenceIOR.value = T.iridescenceIOR,
                        x.iridescenceThicknessMinimum.value = T.iridescenceThicknessRange[0],
                        x.iridescenceThicknessMaximum.value = T.iridescenceThicknessRange[1],
                        T.iridescenceMap && (x.iridescenceMap.value = T.iridescenceMap,
                        n(T.iridescenceMap, x.iridescenceMapTransform)),
                        T.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = T.iridescenceThicknessMap,
                        n(T.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
                        T.transmission > 0 && (x.transmission.value = T.transmission,
                        x.transmissionSamplerMap.value = D.texture,
                        x.transmissionSamplerSize.value.set(D.width, D.height),
                        T.transmissionMap && (x.transmissionMap.value = T.transmissionMap,
                        n(T.transmissionMap, x.transmissionMapTransform)),
                        x.thickness.value = T.thickness,
                        T.thicknessMap && (x.thicknessMap.value = T.thicknessMap,
                        n(T.thicknessMap, x.thicknessMapTransform)),
                        x.attenuationDistance.value = T.attenuationDistance,
                        x.attenuationColor.value.copy(T.attenuationColor)),
                        T.anisotropy > 0 && (x.anisotropyVector.value.set(T.anisotropy * Math.cos(T.anisotropyRotation), T.anisotropy * Math.sin(T.anisotropyRotation)),
                        T.anisotropyMap && (x.anisotropyMap.value = T.anisotropyMap,
                        n(T.anisotropyMap, x.anisotropyMapTransform))),
                        x.specularIntensity.value = T.specularIntensity,
                        x.specularColor.value.copy(T.specularColor),
                        T.specularColorMap && (x.specularColorMap.value = T.specularColorMap,
                        n(T.specularColorMap, x.specularColorMapTransform)),
                        T.specularIntensityMap && (x.specularIntensityMap.value = T.specularIntensityMap,
                        n(T.specularIntensityMap, x.specularIntensityMapTransform))
                    }
                    function A(x, T) {
                        T.matcap && (x.matcap.value = T.matcap)
                    }
                    function M(x, T) {
                        const D = t.get(T).light;
                        x.referencePosition.value.setFromMatrixPosition(D.matrixWorld),
                        x.nearDistance.value = D.shadow.camera.near,
                        x.farDistance.value = D.shadow.camera.far
                    }
                    return {
                        refreshFogUniforms: i,
                        refreshMaterialUniforms: s
                    }
                }
                function Tz(e, t, n, i) {
                    let s = {}
                      , a = {}
                      , o = [];
                    const c = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
                    function u(D, w) {
                        const U = w.program;
                        i.uniformBlockBinding(D, U)
                    }
                    function f(D, w) {
                        let U = s[D.id];
                        U === void 0 && (A(D),
                        U = m(D),
                        s[D.id] = U,
                        D.addEventListener("dispose", x));
                        const O = w.program;
                        i.updateUBOMapping(D, O);
                        const L = t.render.frame;
                        a[D.id] !== L && (y(D),
                        a[D.id] = L)
                    }
                    function m(D) {
                        const w = v();
                        D.__bindingPointIndex = w;
                        const U = e.createBuffer()
                          , O = D.__size
                          , L = D.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, U),
                        e.bufferData(e.UNIFORM_BUFFER, O, L),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, w, U),
                        U
                    }
                    function v() {
                        for (let D = 0; D < c; D++)
                            if (o.indexOf(D) === -1)
                                return o.push(D),
                                D;
                        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                        0
                    }
                    function y(D) {
                        const w = s[D.id]
                          , U = D.uniforms
                          , O = D.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, w);
                        for (let L = 0, N = U.length; L < N; L++) {
                            const z = Array.isArray(U[L]) ? U[L] : [U[L]];
                            for (let I = 0, B = z.length; I < B; I++) {
                                const G = z[I];
                                if (S(G, L, I, O) === !0) {
                                    const X = G.__offset
                                      , q = Array.isArray(G.value) ? G.value : [G.value];
                                    let Q = 0;
                                    for (let oe = 0; oe < q.length; oe++) {
                                        const k = q[oe]
                                          , W = M(k);
                                        typeof k == "number" || typeof k == "boolean" ? (G.__data[0] = k,
                                        e.bufferSubData(e.UNIFORM_BUFFER, X + Q, G.__data)) : k.isMatrix3 ? (G.__data[0] = k.elements[0],
                                        G.__data[1] = k.elements[1],
                                        G.__data[2] = k.elements[2],
                                        G.__data[3] = 0,
                                        G.__data[4] = k.elements[3],
                                        G.__data[5] = k.elements[4],
                                        G.__data[6] = k.elements[5],
                                        G.__data[7] = 0,
                                        G.__data[8] = k.elements[6],
                                        G.__data[9] = k.elements[7],
                                        G.__data[10] = k.elements[8],
                                        G.__data[11] = 0) : (k.toArray(G.__data, Q),
                                        Q += W.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, X, G.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }
                    function S(D, w, U, O) {
                        const L = D.value
                          , N = w + "_" + U;
                        if (O[N] === void 0)
                            return typeof L == "number" || typeof L == "boolean" ? O[N] = L : O[N] = L.clone(),
                            !0;
                        {
                            const z = O[N];
                            if (typeof L == "number" || typeof L == "boolean") {
                                if (z !== L)
                                    return O[N] = L,
                                    !0
                            } else if (z.equals(L) === !1)
                                return z.copy(L),
                                !0
                        }
                        return !1
                    }
                    function A(D) {
                        const w = D.uniforms;
                        let U = 0;
                        const O = 16;
                        for (let N = 0, z = w.length; N < z; N++) {
                            const I = Array.isArray(w[N]) ? w[N] : [w[N]];
                            for (let B = 0, G = I.length; B < G; B++) {
                                const X = I[B]
                                  , q = Array.isArray(X.value) ? X.value : [X.value];
                                for (let Q = 0, oe = q.length; Q < oe; Q++) {
                                    const k = q[Q]
                                      , W = M(k)
                                      , V = U % O
                                      , Z = V % W.boundary
                                      , j = V + Z;
                                    U += Z,
                                    j !== 0 && O - j < W.storage && (U += O - j),
                                    X.__data = new Float32Array(W.storage / Float32Array.BYTES_PER_ELEMENT),
                                    X.__offset = U,
                                    U += W.storage
                                }
                            }
                        }
                        const L = U % O;
                        return L > 0 && (U += O - L),
                        D.__size = U,
                        D.__cache = {},
                        this
                    }
                    function M(D) {
                        const w = {
                            boundary: 0,
                            storage: 0
                        };
                        return typeof D == "number" || typeof D == "boolean" ? (w.boundary = 4,
                        w.storage = 4) : D.isVector2 ? (w.boundary = 8,
                        w.storage = 8) : D.isVector3 || D.isColor ? (w.boundary = 16,
                        w.storage = 12) : D.isVector4 ? (w.boundary = 16,
                        w.storage = 16) : D.isMatrix3 ? (w.boundary = 48,
                        w.storage = 48) : D.isMatrix4 ? (w.boundary = 64,
                        w.storage = 64) : D.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", D),
                        w
                    }
                    function x(D) {
                        const w = D.target;
                        w.removeEventListener("dispose", x);
                        const U = o.indexOf(w.__bindingPointIndex);
                        o.splice(U, 1),
                        e.deleteBuffer(s[w.id]),
                        delete s[w.id],
                        delete a[w.id]
                    }
                    function T() {
                        for (const D in s)
                            e.deleteBuffer(s[D]);
                        o = [],
                        s = {},
                        a = {}
                    }
                    return {
                        bind: u,
                        update: f,
                        dispose: T
                    }
                }
                var _1 = class {
                    constructor(e={}) {
                        const {canvas: t=SC(), context: n=null, depth: i=!0, stencil: s=!1, alpha: a=!1, antialias: o=!1, premultipliedAlpha: c=!0, preserveDrawingBuffer: u=!1, powerPreference: f="default", failIfMajorPerformanceCaveat: m=!1, reversedDepthBuffer: v=!1} = e;
                        this.isWebGLRenderer = !0;
                        let y;
                        if (n !== null) {
                            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                            y = n.getContextAttributes().alpha
                        } else
                            y = a;
                        const S = new Uint32Array(4)
                          , A = new Int32Array(4);
                        let M = null
                          , x = null;
                        const T = []
                          , D = [];
                        this.domElement = t,
                        this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        },
                        this.autoClear = !0,
                        this.autoClearColor = !0,
                        this.autoClearDepth = !0,
                        this.autoClearStencil = !0,
                        this.sortObjects = !0,
                        this.clippingPlanes = [],
                        this.localClippingEnabled = !1,
                        this.toneMapping = al,
                        this.toneMappingExposure = 1,
                        this.transmissionResolutionScale = 1;
                        const w = this;
                        let U = !1;
                        this._outputColorSpace = Zt;
                        let O = 0
                          , L = 0
                          , N = null
                          , z = -1
                          , I = null;
                        const B = new hn
                          , G = new hn;
                        let X = null;
                        const q = new ft(0);
                        let Q = 0
                          , oe = t.width
                          , k = t.height
                          , W = 1
                          , V = null
                          , Z = null;
                        const j = new hn(0,0,oe,k)
                          , ee = new hn(0,0,oe,k);
                        let H = !1;
                        const ie = new kp;
                        let se = !1
                          , K = !1;
                        const le = new Xt
                          , ue = new ae
                          , de = new hn
                          , qe = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };
                        let ze = !1;
                        function Ee() {
                            return N === null ? W : 1
                        }
                        let re = n;
                        function Le(te, Se) {
                            return t.getContext(te, Se)
                        }
                        try {
                            const te = {
                                alpha: !0,
                                depth: i,
                                stencil: s,
                                antialias: o,
                                premultipliedAlpha: c,
                                preserveDrawingBuffer: u,
                                powerPreference: f,
                                failIfMajorPerformanceCaveat: m
                            };
                            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${jc}`),
                            t.addEventListener("webglcontextlost", ot, !1),
                            t.addEventListener("webglcontextrestored", tt, !1),
                            t.addEventListener("webglcontextcreationerror", xt, !1),
                            re === null) {
                                const Se = "webgl2";
                                if (re = Le(Se, te),
                                re === null)
                                    throw Le(Se) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                            }
                        } catch (te) {
                            throw console.error("THREE.WebGLRenderer: " + te.message),
                            te
                        }
                        let he, ye, xe, ge, Te, Ae, we, it, je, $, Y, pe, He, Re, De, rt, $e, ct, gt, Ie, Je, Ze, ht, lt;
                        function At() {
                            he = new LP(re),
                            he.init(),
                            Ze = new y1(re,he),
                            ye = new wP(re,he,e,Ze),
                            xe = new mz(re,he),
                            ye.reversedDepthBuffer && v && xe.buffers.depth.setReversed(!0),
                            ge = new zP(re),
                            Te = new nz,
                            Ae = new vz(re,he,xe,Te,ye,Ze,ge),
                            we = new RP(w),
                            it = new BP(w),
                            je = new TP(re),
                            ht = new EP(re,je),
                            $ = new IP(re,je,ge,ht),
                            Y = new HP(re,$,je,ge),
                            gt = new FP(re,ye,Ae),
                            rt = new DP(Te),
                            pe = new tz(w,we,it,he,ye,ht,rt),
                            He = new Az(w,Te),
                            Re = new sz,
                            De = new uz(he),
                            ct = new bP(w,we,it,xe,Y,y,c),
                            $e = new dz(w,Y,ye),
                            lt = new Tz(re,ge,ye,xe),
                            Ie = new CP(re,he,ge),
                            Je = new PP(re,he,ge),
                            ge.programs = pe.programs,
                            w.capabilities = ye,
                            w.extensions = he,
                            w.properties = Te,
                            w.renderLists = Re,
                            w.shadowMap = $e,
                            w.state = xe,
                            w.info = ge
                        }
                        At();
                        const fe = new Sz(w,re);
                        this.xr = fe,
                        this.getContext = function() {
                            return re
                        }
                        ,
                        this.getContextAttributes = function() {
                            return re.getContextAttributes()
                        }
                        ,
                        this.forceContextLoss = function() {
                            const te = he.get("WEBGL_lose_context");
                            te && te.loseContext()
                        }
                        ,
                        this.forceContextRestore = function() {
                            const te = he.get("WEBGL_lose_context");
                            te && te.restoreContext()
                        }
                        ,
                        this.getPixelRatio = function() {
                            return W
                        }
                        ,
                        this.setPixelRatio = function(te) {
                            te !== void 0 && (W = te,
                            this.setSize(oe, k, !1))
                        }
                        ,
                        this.getSize = function(te) {
                            return te.set(oe, k)
                        }
                        ,
                        this.setSize = function(te, Se, Ge=!0) {
                            if (fe.isPresenting) {
                                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                                return
                            }
                            oe = te,
                            k = Se,
                            t.width = Math.floor(te * W),
                            t.height = Math.floor(Se * W),
                            Ge === !0 && (t.style.width = te + "px",
                            t.style.height = Se + "px"),
                            this.setViewport(0, 0, te, Se)
                        }
                        ,
                        this.getDrawingBufferSize = function(te) {
                            return te.set(oe * W, k * W).floor()
                        }
                        ,
                        this.setDrawingBufferSize = function(te, Se, Ge) {
                            oe = te,
                            k = Se,
                            W = Ge,
                            t.width = Math.floor(te * Ge),
                            t.height = Math.floor(Se * Ge),
                            this.setViewport(0, 0, te, Se)
                        }
                        ,
                        this.getCurrentViewport = function(te) {
                            return te.copy(B)
                        }
                        ,
                        this.getViewport = function(te) {
                            return te.copy(j)
                        }
                        ,
                        this.setViewport = function(te, Se, Ge, Ue) {
                            te.isVector4 ? j.set(te.x, te.y, te.z, te.w) : j.set(te, Se, Ge, Ue),
                            xe.viewport(B.copy(j).multiplyScalar(W).round())
                        }
                        ,
                        this.getScissor = function(te) {
                            return te.copy(ee)
                        }
                        ,
                        this.setScissor = function(te, Se, Ge, Ue) {
                            te.isVector4 ? ee.set(te.x, te.y, te.z, te.w) : ee.set(te, Se, Ge, Ue),
                            xe.scissor(G.copy(ee).multiplyScalar(W).round())
                        }
                        ,
                        this.getScissorTest = function() {
                            return H
                        }
                        ,
                        this.setScissorTest = function(te) {
                            xe.setScissorTest(H = te)
                        }
                        ,
                        this.setOpaqueSort = function(te) {
                            V = te
                        }
                        ,
                        this.setTransparentSort = function(te) {
                            Z = te
                        }
                        ,
                        this.getClearColor = function(te) {
                            return te.copy(ct.getClearColor())
                        }
                        ,
                        this.setClearColor = function() {
                            ct.setClearColor(...arguments)
                        }
                        ,
                        this.getClearAlpha = function() {
                            return ct.getClearAlpha()
                        }
                        ,
                        this.setClearAlpha = function() {
                            ct.setClearAlpha(...arguments)
                        }
                        ,
                        this.clear = function(te=!0, Se=!0, Ge=!0) {
                            let Ue = 0;
                            if (te) {
                                let ce = !1;
                                if (N !== null) {
                                    const at = N.texture.format;
                                    ce = at === Wy || at === Xy || at === ag
                                }
                                if (ce) {
                                    const at = N.texture.type
                                      , yt = at === gi || at === ac || at === mp || at === df || at === Gy || at === Vy
                                      , pt = ct.getClearColor()
                                      , St = ct.getClearAlpha()
                                      , Lt = pt.r
                                      , Ut = pt.g
                                      , Dt = pt.b;
                                    yt ? (S[0] = Lt,
                                    S[1] = Ut,
                                    S[2] = Dt,
                                    S[3] = St,
                                    re.clearBufferuiv(re.COLOR, 0, S)) : (A[0] = Lt,
                                    A[1] = Ut,
                                    A[2] = Dt,
                                    A[3] = St,
                                    re.clearBufferiv(re.COLOR, 0, A))
                                } else
                                    Ue |= re.COLOR_BUFFER_BIT
                            }
                            Se && (Ue |= re.DEPTH_BUFFER_BIT),
                            Ge && (Ue |= re.STENCIL_BUFFER_BIT,
                            this.state.buffers.stencil.setMask(4294967295)),
                            re.clear(Ue)
                        }
                        ,
                        this.clearColor = function() {
                            this.clear(!0, !1, !1)
                        }
                        ,
                        this.clearDepth = function() {
                            this.clear(!1, !0, !1)
                        }
                        ,
                        this.clearStencil = function() {
                            this.clear(!1, !1, !0)
                        }
                        ,
                        this.dispose = function() {
                            t.removeEventListener("webglcontextlost", ot, !1),
                            t.removeEventListener("webglcontextrestored", tt, !1),
                            t.removeEventListener("webglcontextcreationerror", xt, !1),
                            ct.dispose(),
                            Re.dispose(),
                            De.dispose(),
                            Te.dispose(),
                            we.dispose(),
                            it.dispose(),
                            Y.dispose(),
                            ht.dispose(),
                            lt.dispose(),
                            pe.dispose(),
                            fe.dispose(),
                            fe.removeEventListener("sessionstart", Mn),
                            fe.removeEventListener("sessionend", Un),
                            On.stop()
                        }
                        ;
                        function ot(te) {
                            te.preventDefault(),
                            console.log("THREE.WebGLRenderer: Context Lost."),
                            U = !0
                        }
                        function tt() {
                            console.log("THREE.WebGLRenderer: Context Restored."),
                            U = !1;
                            const te = ge.autoReset
                              , Se = $e.enabled
                              , Ge = $e.autoUpdate
                              , Ue = $e.needsUpdate
                              , ce = $e.type;
                            At(),
                            ge.autoReset = te,
                            $e.enabled = Se,
                            $e.autoUpdate = Ge,
                            $e.needsUpdate = Ue,
                            $e.type = ce
                        }
                        function xt(te) {
                            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", te.statusMessage)
                        }
                        function Qe(te) {
                            const Se = te.target;
                            Se.removeEventListener("dispose", Qe),
                            Ne(Se)
                        }
                        function Ne(te) {
                            dt(te),
                            Te.remove(te)
                        }
                        function dt(te) {
                            const Se = Te.get(te).programs;
                            Se !== void 0 && (Se.forEach(function(Ge) {
                                pe.releaseProgram(Ge)
                            }),
                            te.isShaderMaterial && pe.releaseShaderCache(te))
                        }
                        this.renderBufferDirect = function(te, Se, Ge, Ue, ce, at) {
                            Se === null && (Se = qe);
                            const yt = ce.isMesh && ce.matrixWorld.determinant() < 0
                              , pt = Qt(te, Se, Ge, Ue, ce);
                            xe.setMaterial(Ue, yt);
                            let St = Ge.index
                              , Lt = 1;
                            if (Ue.wireframe === !0) {
                                if (St = $.getWireframeAttribute(Ge),
                                St === void 0)
                                    return;
                                Lt = 2
                            }
                            const Ut = Ge.drawRange
                              , Dt = Ge.attributes.position;
                            let Kt = Ut.start * Lt
                              , bn = (Ut.start + Ut.count) * Lt;
                            at !== null && (Kt = Math.max(Kt, at.start * Lt),
                            bn = Math.min(bn, (at.start + at.count) * Lt)),
                            St !== null ? (Kt = Math.max(Kt, 0),
                            bn = Math.min(bn, St.count)) : Dt != null && (Kt = Math.max(Kt, 0),
                            bn = Math.min(bn, Dt.count));
                            const _n = bn - Kt;
                            if (_n < 0 || _n === 1 / 0)
                                return;
                            ht.setup(ce, Ue, pt, Ge, St);
                            let Wn, dn = Ie;
                            if (St !== null && (Wn = je.get(St),
                            dn = Je,
                            dn.setIndex(Wn)),
                            ce.isMesh)
                                Ue.wireframe === !0 ? (xe.setLineWidth(Ue.wireframeLinewidth * Ee()),
                                dn.setMode(re.LINES)) : dn.setMode(re.TRIANGLES);
                            else if (ce.isLine) {
                                let Et = Ue.linewidth;
                                Et === void 0 && (Et = 1),
                                xe.setLineWidth(Et * Ee()),
                                ce.isLineSegments ? dn.setMode(re.LINES) : ce.isLineLoop ? dn.setMode(re.LINE_LOOP) : dn.setMode(re.LINE_STRIP)
                            } else
                                ce.isPoints ? dn.setMode(re.POINTS) : ce.isSprite && dn.setMode(re.TRIANGLES);
                            if (ce.isBatchedMesh)
                                if (ce._multiDrawInstances !== null)
                                    vg("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                                    dn.renderMultiDrawInstances(ce._multiDrawStarts, ce._multiDrawCounts, ce._multiDrawCount, ce._multiDrawInstances);
                                else if (he.get("WEBGL_multi_draw"))
                                    dn.renderMultiDraw(ce._multiDrawStarts, ce._multiDrawCounts, ce._multiDrawCount);
                                else {
                                    const Et = ce._multiDrawStarts
                                      , vn = ce._multiDrawCounts
                                      , Ht = ce._multiDrawCount
                                      , Ni = St ? je.get(St).bytesPerElement : 1
                                      , Ua = Te.get(Ue).currentProgram.getUniforms();
                                    for (let Ti = 0; Ti < Ht; Ti++)
                                        Ua.setValue(re, "_gl_DrawID", Ti),
                                        dn.render(Et[Ti] / Ni, vn[Ti])
                                }
                            else if (ce.isInstancedMesh)
                                dn.renderInstances(Kt, _n, ce.count);
                            else if (Ge.isInstancedBufferGeometry) {
                                const Et = Ge._maxInstanceCount !== void 0 ? Ge._maxInstanceCount : 1 / 0
                                  , vn = Math.min(Ge.instanceCount, Et);
                                dn.renderInstances(Kt, _n, vn)
                            } else
                                dn.render(Kt, _n)
                        }
                        ;
                        function _t(te, Se, Ge) {
                            te.transparent === !0 && te.side === $a && te.forceSinglePass === !1 ? (te.side = Ds,
                            te.needsUpdate = !0,
                            ei(te, Se, Ge),
                            te.side = ic,
                            te.needsUpdate = !0,
                            ei(te, Se, Ge),
                            te.side = $a) : ei(te, Se, Ge)
                        }
                        this.compile = function(te, Se, Ge=null) {
                            Ge === null && (Ge = te),
                            x = De.get(Ge),
                            x.init(Se),
                            D.push(x),
                            Ge.traverseVisible(function(ce) {
                                ce.isLight && ce.layers.test(Se.layers) && (x.pushLight(ce),
                                ce.castShadow && x.pushShadow(ce))
                            }),
                            te !== Ge && te.traverseVisible(function(ce) {
                                ce.isLight && ce.layers.test(Se.layers) && (x.pushLight(ce),
                                ce.castShadow && x.pushShadow(ce))
                            }),
                            x.setupLights();
                            const Ue = new Set;
                            return te.traverse(function(ce) {
                                if (!(ce.isMesh || ce.isPoints || ce.isLine || ce.isSprite))
                                    return;
                                const at = ce.material;
                                if (at)
                                    if (Array.isArray(at))
                                        for (let yt = 0; yt < at.length; yt++) {
                                            const pt = at[yt];
                                            _t(pt, Ge, ce),
                                            Ue.add(pt)
                                        }
                                    else
                                        _t(at, Ge, ce),
                                        Ue.add(at)
                            }),
                            x = D.pop(),
                            Ue
                        }
                        ,
                        this.compileAsync = function(te, Se, Ge=null) {
                            const Ue = this.compile(te, Se, Ge);
                            return new Promise(ce => {
                                function at() {
                                    if (Ue.forEach(function(yt) {
                                        Te.get(yt).currentProgram.isReady() && Ue.delete(yt)
                                    }),
                                    Ue.size === 0) {
                                        ce(te);
                                        return
                                    }
                                    setTimeout(at, 10)
                                }
                                he.get("KHR_parallel_shader_compile") !== null ? at() : setTimeout(at, 10)
                            }
                            )
                        }
                        ;
                        let Ct = null;
                        function Ot(te) {
                            Ct && Ct(te)
                        }
                        function Mn() {
                            On.stop()
                        }
                        function Un() {
                            On.start()
                        }
                        const On = new X2;
                        On.setAnimationLoop(Ot),
                        typeof self < "u" && On.setContext(self),
                        this.setAnimationLoop = function(te) {
                            Ct = te,
                            fe.setAnimationLoop(te),
                            te === null ? On.stop() : On.start()
                        }
                        ,
                        fe.addEventListener("sessionstart", Mn),
                        fe.addEventListener("sessionend", Un),
                        this.render = function(te, Se) {
                            if (Se !== void 0 && Se.isCamera !== !0) {
                                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                return
                            }
                            if (U === !0)
                                return;
                            if (te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(),
                            Se.parent === null && Se.matrixWorldAutoUpdate === !0 && Se.updateMatrixWorld(),
                            fe.enabled === !0 && fe.isPresenting === !0 && (fe.cameraAutoUpdate === !0 && fe.updateCamera(Se),
                            Se = fe.getCamera()),
                            te.isScene === !0 && te.onBeforeRender(w, te, Se, N),
                            x = De.get(te, D.length),
                            x.init(Se),
                            D.push(x),
                            le.multiplyMatrices(Se.projectionMatrix, Se.matrixWorldInverse),
                            ie.setFromProjectionMatrix(le, Yr, Se.reversedDepth),
                            K = this.localClippingEnabled,
                            se = rt.init(this.clippingPlanes, K),
                            M = Re.get(te, T.length),
                            M.init(),
                            T.push(M),
                            fe.enabled === !0 && fe.isPresenting === !0) {
                                const at = w.xr.getDepthSensingMesh();
                                at !== null && ki(at, Se, -1 / 0, w.sortObjects)
                            }
                            ki(te, Se, 0, w.sortObjects),
                            M.finish(),
                            w.sortObjects === !0 && M.sort(V, Z),
                            ze = fe.enabled === !1 || fe.isPresenting === !1 || fe.hasDepthSensing() === !1,
                            ze && ct.addToRenderList(M, te),
                            this.info.render.frame++,
                            se === !0 && rt.beginShadows();
                            const Ge = x.state.shadowsArray;
                            $e.render(Ge, te, Se),
                            se === !0 && rt.endShadows(),
                            this.info.autoReset === !0 && this.info.reset();
                            const Ue = M.opaque
                              , ce = M.transmissive;
                            if (x.setupLights(),
                            Se.isArrayCamera) {
                                const at = Se.cameras;
                                if (ce.length > 0)
                                    for (let yt = 0, pt = at.length; yt < pt; yt++) {
                                        const St = at[yt];
                                        Ls(Ue, ce, te, St)
                                    }
                                ze && ct.render(te);
                                for (let yt = 0, pt = at.length; yt < pt; yt++) {
                                    const St = at[yt];
                                    Bs(M, te, St, St.viewport)
                                }
                            } else
                                ce.length > 0 && Ls(Ue, ce, te, Se),
                                ze && ct.render(te),
                                Bs(M, te, Se);
                            N !== null && L === 0 && (Ae.updateMultisampleRenderTarget(N),
                            Ae.updateRenderTargetMipmap(N)),
                            te.isScene === !0 && te.onAfterRender(w, te, Se),
                            ht.resetDefaultState(),
                            z = -1,
                            I = null,
                            D.pop(),
                            D.length > 0 ? (x = D[D.length - 1],
                            se === !0 && rt.setGlobalState(w.clippingPlanes, x.state.camera)) : x = null,
                            T.pop(),
                            T.length > 0 ? M = T[T.length - 1] : M = null
                        }
                        ;
                        function ki(te, Se, Ge, Ue) {
                            if (te.visible === !1)
                                return;
                            if (te.layers.test(Se.layers)) {
                                if (te.isGroup)
                                    Ge = te.renderOrder;
                                else if (te.isLOD)
                                    te.autoUpdate === !0 && te.update(Se);
                                else if (te.isLight)
                                    x.pushLight(te),
                                    te.castShadow && x.pushShadow(te);
                                else if (te.isSprite) {
                                    if (!te.frustumCulled || ie.intersectsSprite(te)) {
                                        Ue && de.setFromMatrixPosition(te.matrixWorld).applyMatrix4(le);
                                        const at = Y.update(te)
                                          , yt = te.material;
                                        yt.visible && M.push(te, at, yt, Ge, de.z, null)
                                    }
                                } else if ((te.isMesh || te.isLine || te.isPoints) && (!te.frustumCulled || ie.intersectsObject(te))) {
                                    const at = Y.update(te)
                                      , yt = te.material;
                                    if (Ue && (te.boundingSphere !== void 0 ? (te.boundingSphere === null && te.computeBoundingSphere(),
                                    de.copy(te.boundingSphere.center)) : (at.boundingSphere === null && at.computeBoundingSphere(),
                                    de.copy(at.boundingSphere.center)),
                                    de.applyMatrix4(te.matrixWorld).applyMatrix4(le)),
                                    Array.isArray(yt)) {
                                        const pt = at.groups;
                                        for (let St = 0, Lt = pt.length; St < Lt; St++) {
                                            const Ut = pt[St]
                                              , Dt = yt[Ut.materialIndex];
                                            Dt && Dt.visible && M.push(te, at, Dt, Ge, de.z, Ut)
                                        }
                                    } else
                                        yt.visible && M.push(te, at, yt, Ge, de.z, null)
                                }
                            }
                            const ce = te.children;
                            for (let at = 0, yt = ce.length; at < yt; at++)
                                ki(ce[at], Se, Ge, Ue)
                        }
                        function Bs(te, Se, Ge, Ue) {
                            const ce = te.opaque
                              , at = te.transmissive
                              , yt = te.transparent;
                            x.setupLightsView(Ge),
                            se === !0 && rt.setGlobalState(w.clippingPlanes, Ge),
                            Ue && xe.viewport(B.copy(Ue)),
                            ce.length > 0 && Ai(ce, Se, Ge),
                            at.length > 0 && Ai(at, Se, Ge),
                            yt.length > 0 && Ai(yt, Se, Ge),
                            xe.buffers.depth.setTest(!0),
                            xe.buffers.depth.setMask(!0),
                            xe.buffers.color.setMask(!0),
                            xe.setPolygonOffset(!1)
                        }
                        function Ls(te, Se, Ge, Ue) {
                            if ((Ge.isScene === !0 ? Ge.overrideMaterial : null) !== null)
                                return;
                            x.state.transmissionRenderTarget[Ue.id] === void 0 && (x.state.transmissionRenderTarget[Ue.id] = new Vn(1,1,{
                                generateMipmaps: !0,
                                type: he.has("EXT_color_buffer_half_float") || he.has("EXT_color_buffer_float") ? ff : gi,
                                minFilter: sc,
                                samples: 4,
                                stencilBuffer: s,
                                resolveDepthBuffer: !1,
                                resolveStencilBuffer: !1,
                                colorSpace: Rn.workingColorSpace
                            }));
                            const ce = x.state.transmissionRenderTarget[Ue.id]
                              , at = Ue.viewport || B;
                            ce.setSize(at.z * w.transmissionResolutionScale, at.w * w.transmissionResolutionScale);
                            const yt = w.getRenderTarget()
                              , pt = w.getActiveCubeFace()
                              , St = w.getActiveMipmapLevel();
                            w.setRenderTarget(ce),
                            w.getClearColor(q),
                            Q = w.getClearAlpha(),
                            Q < 1 && w.setClearColor(16777215, .5),
                            w.clear(),
                            ze && ct.render(Ge);
                            const Lt = w.toneMapping;
                            w.toneMapping = al;
                            const Ut = Ue.viewport;
                            if (Ue.viewport !== void 0 && (Ue.viewport = void 0),
                            x.setupLightsView(Ue),
                            se === !0 && rt.setGlobalState(w.clippingPlanes, Ue),
                            Ai(te, Ge, Ue),
                            Ae.updateMultisampleRenderTarget(ce),
                            Ae.updateRenderTargetMipmap(ce),
                            he.has("WEBGL_multisampled_render_to_texture") === !1) {
                                let Dt = !1;
                                for (let Kt = 0, bn = Se.length; Kt < bn; Kt++) {
                                    const _n = Se[Kt]
                                      , Wn = _n.object
                                      , dn = _n.geometry
                                      , Et = _n.material
                                      , vn = _n.group;
                                    if (Et.side === $a && Wn.layers.test(Ue.layers)) {
                                        const Ht = Et.side;
                                        Et.side = Ds,
                                        Et.needsUpdate = !0,
                                        _s(Wn, Ge, Ue, dn, Et, vn),
                                        Et.side = Ht,
                                        Et.needsUpdate = !0,
                                        Dt = !0
                                    }
                                }
                                Dt === !0 && (Ae.updateMultisampleRenderTarget(ce),
                                Ae.updateRenderTargetMipmap(ce))
                            }
                            w.setRenderTarget(yt, pt, St),
                            w.setClearColor(q, Q),
                            Ut !== void 0 && (Ue.viewport = Ut),
                            w.toneMapping = Lt
                        }
                        function Ai(te, Se, Ge) {
                            const Ue = Se.isScene === !0 ? Se.overrideMaterial : null;
                            for (let ce = 0, at = te.length; ce < at; ce++) {
                                const yt = te[ce]
                                  , pt = yt.object
                                  , St = yt.geometry
                                  , Lt = yt.group;
                                let Ut = yt.material;
                                Ut.allowOverride === !0 && Ue !== null && (Ut = Ue),
                                pt.layers.test(Ge.layers) && _s(pt, Se, Ge, St, Ut, Lt)
                            }
                        }
                        function _s(te, Se, Ge, Ue, ce, at) {
                            te.onBeforeRender(w, Se, Ge, Ue, ce, at),
                            te.modelViewMatrix.multiplyMatrices(Ge.matrixWorldInverse, te.matrixWorld),
                            te.normalMatrix.getNormalMatrix(te.modelViewMatrix),
                            ce.onBeforeRender(w, Se, Ge, Ue, te, at),
                            ce.transparent === !0 && ce.side === $a && ce.forceSinglePass === !1 ? (ce.side = Ds,
                            ce.needsUpdate = !0,
                            w.renderBufferDirect(Ge, Se, Ue, ce, te, at),
                            ce.side = ic,
                            ce.needsUpdate = !0,
                            w.renderBufferDirect(Ge, Se, Ue, ce, te, at),
                            ce.side = $a) : w.renderBufferDirect(Ge, Se, Ue, ce, te, at),
                            te.onAfterRender(w, Se, Ge, Ue, ce, at)
                        }
                        function ei(te, Se, Ge) {
                            Se.isScene !== !0 && (Se = qe);
                            const Ue = Te.get(te)
                              , ce = x.state.lights
                              , at = x.state.shadowsArray
                              , yt = ce.state.version
                              , pt = pe.getParameters(te, ce.state, at, Se, Ge)
                              , St = pe.getProgramCacheKey(pt);
                            let Lt = Ue.programs;
                            Ue.environment = te.isMeshStandardMaterial ? Se.environment : null,
                            Ue.fog = Se.fog,
                            Ue.envMap = (te.isMeshStandardMaterial ? it : we).get(te.envMap || Ue.environment),
                            Ue.envMapRotation = Ue.environment !== null && te.envMap === null ? Se.environmentRotation : te.envMapRotation,
                            Lt === void 0 && (te.addEventListener("dispose", Qe),
                            Lt = new Map,
                            Ue.programs = Lt);
                            let Ut = Lt.get(St);
                            if (Ut !== void 0) {
                                if (Ue.currentProgram === Ut && Ue.lightsStateVersion === yt)
                                    return Oi(te, pt),
                                    Ut
                            } else
                                pt.uniforms = pe.getUniforms(te),
                                te.onBeforeCompile(pt, w),
                                Ut = pe.acquireProgram(pt, St),
                                Lt.set(St, Ut),
                                Ue.uniforms = pt.uniforms;
                            const Dt = Ue.uniforms;
                            return (!te.isShaderMaterial && !te.isRawShaderMaterial || te.clipping === !0) && (Dt.clippingPlanes = rt.uniform),
                            Oi(te, pt),
                            Ue.needsLights = lr(te),
                            Ue.lightsStateVersion = yt,
                            Ue.needsLights && (Dt.ambientLightColor.value = ce.state.ambient,
                            Dt.lightProbe.value = ce.state.probe,
                            Dt.directionalLights.value = ce.state.directional,
                            Dt.directionalLightShadows.value = ce.state.directionalShadow,
                            Dt.spotLights.value = ce.state.spot,
                            Dt.spotLightShadows.value = ce.state.spotShadow,
                            Dt.rectAreaLights.value = ce.state.rectArea,
                            Dt.ltc_1.value = ce.state.rectAreaLTC1,
                            Dt.ltc_2.value = ce.state.rectAreaLTC2,
                            Dt.pointLights.value = ce.state.point,
                            Dt.pointLightShadows.value = ce.state.pointShadow,
                            Dt.hemisphereLights.value = ce.state.hemi,
                            Dt.directionalShadowMap.value = ce.state.directionalShadowMap,
                            Dt.directionalShadowMatrix.value = ce.state.directionalShadowMatrix,
                            Dt.spotShadowMap.value = ce.state.spotShadowMap,
                            Dt.spotLightMatrix.value = ce.state.spotLightMatrix,
                            Dt.spotLightMap.value = ce.state.spotLightMap,
                            Dt.pointShadowMap.value = ce.state.pointShadowMap,
                            Dt.pointShadowMatrix.value = ce.state.pointShadowMatrix),
                            Ue.currentProgram = Ut,
                            Ue.uniformsList = null,
                            Ut
                        }
                        function ti(te) {
                            if (te.uniformsList === null) {
                                const Se = te.currentProgram.getUniforms();
                                te.uniformsList = ES.seqWithValue(Se.seq, te.uniforms)
                            }
                            return te.uniformsList
                        }
                        function Oi(te, Se) {
                            const Ge = Te.get(te);
                            Ge.outputColorSpace = Se.outputColorSpace,
                            Ge.batching = Se.batching,
                            Ge.batchingColor = Se.batchingColor,
                            Ge.instancing = Se.instancing,
                            Ge.instancingColor = Se.instancingColor,
                            Ge.instancingMorph = Se.instancingMorph,
                            Ge.skinning = Se.skinning,
                            Ge.morphTargets = Se.morphTargets,
                            Ge.morphNormals = Se.morphNormals,
                            Ge.morphColors = Se.morphColors,
                            Ge.morphTargetsCount = Se.morphTargetsCount,
                            Ge.numClippingPlanes = Se.numClippingPlanes,
                            Ge.numIntersection = Se.numClipIntersection,
                            Ge.vertexAlphas = Se.vertexAlphas,
                            Ge.vertexTangents = Se.vertexTangents,
                            Ge.toneMapping = Se.toneMapping
                        }
                        function Qt(te, Se, Ge, Ue, ce) {
                            Se.isScene !== !0 && (Se = qe),
                            Ae.resetTextureUnits();
                            const at = Se.fog
                              , yt = Ue.isMeshStandardMaterial ? Se.environment : null
                              , pt = N === null ? w.outputColorSpace : N.isXRRenderTarget === !0 ? N.texture.colorSpace : rc
                              , St = (Ue.isMeshStandardMaterial ? it : we).get(Ue.envMap || yt)
                              , Lt = Ue.vertexColors === !0 && !!Ge.attributes.color && Ge.attributes.color.itemSize === 4
                              , Ut = !!Ge.attributes.tangent && (!!Ue.normalMap || Ue.anisotropy > 0)
                              , Dt = !!Ge.morphAttributes.position
                              , Kt = !!Ge.morphAttributes.normal
                              , bn = !!Ge.morphAttributes.color;
                            let _n = al;
                            Ue.toneMapped && (N === null || N.isXRRenderTarget === !0) && (_n = w.toneMapping);
                            const Wn = Ge.morphAttributes.position || Ge.morphAttributes.normal || Ge.morphAttributes.color
                              , dn = Wn !== void 0 ? Wn.length : 0
                              , Et = Te.get(Ue)
                              , vn = x.state.lights;
                            if (se === !0 && (K === !0 || te !== I)) {
                                const qn = te === I && Ue.id === z;
                                rt.setState(Ue, te, qn)
                            }
                            let Ht = !1;
                            Ue.version === Et.__version ? (Et.needsLights && Et.lightsStateVersion !== vn.state.version || Et.outputColorSpace !== pt || ce.isBatchedMesh && Et.batching === !1 || !ce.isBatchedMesh && Et.batching === !0 || ce.isBatchedMesh && Et.batchingColor === !0 && ce.colorTexture === null || ce.isBatchedMesh && Et.batchingColor === !1 && ce.colorTexture !== null || ce.isInstancedMesh && Et.instancing === !1 || !ce.isInstancedMesh && Et.instancing === !0 || ce.isSkinnedMesh && Et.skinning === !1 || !ce.isSkinnedMesh && Et.skinning === !0 || ce.isInstancedMesh && Et.instancingColor === !0 && ce.instanceColor === null || ce.isInstancedMesh && Et.instancingColor === !1 && ce.instanceColor !== null || ce.isInstancedMesh && Et.instancingMorph === !0 && ce.morphTexture === null || ce.isInstancedMesh && Et.instancingMorph === !1 && ce.morphTexture !== null || Et.envMap !== St || Ue.fog === !0 && Et.fog !== at || Et.numClippingPlanes !== void 0 && (Et.numClippingPlanes !== rt.numPlanes || Et.numIntersection !== rt.numIntersection) || Et.vertexAlphas !== Lt || Et.vertexTangents !== Ut || Et.morphTargets !== Dt || Et.morphNormals !== Kt || Et.morphColors !== bn || Et.toneMapping !== _n || Et.morphTargetsCount !== dn) && (Ht = !0) : (Ht = !0,
                            Et.__version = Ue.version);
                            let Ni = Et.currentProgram;
                            Ht === !0 && (Ni = ei(Ue, Se, ce));
                            let Ua = !1
                              , Ti = !1
                              , Oa = !1;
                            const Jt = Ni.getUniforms()
                              , Ss = Et.uniforms;
                            if (xe.useProgram(Ni.program) && (Ua = !0,
                            Ti = !0,
                            Oa = !0),
                            Ue.id !== z && (z = Ue.id,
                            Ti = !0),
                            Ua || I !== te) {
                                xe.buffers.depth.getReversed() && te.reversedDepth !== !0 && (te._reversedDepth = !0,
                                te.updateProjectionMatrix()),
                                Jt.setValue(re, "projectionMatrix", te.projectionMatrix),
                                Jt.setValue(re, "viewMatrix", te.matrixWorldInverse);
                                const qn = Jt.map.cameraPosition;
                                qn !== void 0 && qn.setValue(re, ue.setFromMatrixPosition(te.matrixWorld)),
                                ye.logarithmicDepthBuffer && Jt.setValue(re, "logDepthBufFC", 2 / (Math.log(te.far + 1) / Math.LN2)),
                                (Ue.isMeshPhongMaterial || Ue.isMeshToonMaterial || Ue.isMeshLambertMaterial || Ue.isMeshBasicMaterial || Ue.isMeshStandardMaterial || Ue.isShaderMaterial) && Jt.setValue(re, "isOrthographic", te.isOrthographicCamera === !0),
                                I !== te && (I = te,
                                Ti = !0,
                                Oa = !0)
                            }
                            if (ce.isSkinnedMesh) {
                                Jt.setOptional(re, ce, "bindMatrix"),
                                Jt.setOptional(re, ce, "bindMatrixInverse");
                                const qn = ce.skeleton;
                                qn && (qn.boneTexture === null && qn.computeBoneTexture(),
                                Jt.setValue(re, "boneTexture", qn.boneTexture, Ae))
                            }
                            ce.isBatchedMesh && (Jt.setOptional(re, ce, "batchingTexture"),
                            Jt.setValue(re, "batchingTexture", ce._matricesTexture, Ae),
                            Jt.setOptional(re, ce, "batchingIdTexture"),
                            Jt.setValue(re, "batchingIdTexture", ce._indirectTexture, Ae),
                            Jt.setOptional(re, ce, "batchingColorTexture"),
                            ce._colorsTexture !== null && Jt.setValue(re, "batchingColorTexture", ce._colorsTexture, Ae));
                            const Nn = Ge.morphAttributes;
                            if ((Nn.position !== void 0 || Nn.normal !== void 0 || Nn.color !== void 0) && gt.update(ce, Ge, Ni),
                            (Ti || Et.receiveShadow !== ce.receiveShadow) && (Et.receiveShadow = ce.receiveShadow,
                            Jt.setValue(re, "receiveShadow", ce.receiveShadow)),
                            Ue.isMeshGouraudMaterial && Ue.envMap !== null && (Ss.envMap.value = St,
                            Ss.flipEnvMap.value = St.isCubeTexture && St.isRenderTargetTexture === !1 ? -1 : 1),
                            Ue.isMeshStandardMaterial && Ue.envMap === null && Se.environment !== null && (Ss.envMapIntensity.value = Se.environmentIntensity),
                            Ti && (Jt.setValue(re, "toneMappingExposure", w.toneMappingExposure),
                            Et.needsLights && Xi(Ss, Oa),
                            at && Ue.fog === !0 && He.refreshFogUniforms(Ss, at),
                            He.refreshMaterialUniforms(Ss, Ue, W, k, x.state.transmissionRenderTarget[te.id]),
                            ES.upload(re, ti(Et), Ss, Ae)),
                            Ue.isShaderMaterial && Ue.uniformsNeedUpdate === !0 && (ES.upload(re, ti(Et), Ss, Ae),
                            Ue.uniformsNeedUpdate = !1),
                            Ue.isSpriteMaterial && Jt.setValue(re, "center", ce.center),
                            Jt.setValue(re, "modelViewMatrix", ce.modelViewMatrix),
                            Jt.setValue(re, "normalMatrix", ce.normalMatrix),
                            Jt.setValue(re, "modelMatrix", ce.matrixWorld),
                            Ue.isShaderMaterial || Ue.isRawShaderMaterial) {
                                const qn = Ue.uniformsGroups;
                                for (let ls = 0, Na = qn.length; ls < Na; ls++) {
                                    const $i = qn[ls];
                                    lt.update($i, Ni),
                                    lt.bind($i, Ni)
                                }
                            }
                            return Ni
                        }
                        function Xi(te, Se) {
                            te.ambientLightColor.needsUpdate = Se,
                            te.lightProbe.needsUpdate = Se,
                            te.directionalLights.needsUpdate = Se,
                            te.directionalLightShadows.needsUpdate = Se,
                            te.pointLights.needsUpdate = Se,
                            te.pointLightShadows.needsUpdate = Se,
                            te.spotLights.needsUpdate = Se,
                            te.spotLightShadows.needsUpdate = Se,
                            te.rectAreaLights.needsUpdate = Se,
                            te.hemisphereLights.needsUpdate = Se
                        }
                        function lr(te) {
                            return te.isMeshLambertMaterial || te.isMeshToonMaterial || te.isMeshPhongMaterial || te.isMeshStandardMaterial || te.isShadowMaterial || te.isShaderMaterial && te.lights === !0
                        }
                        this.getActiveCubeFace = function() {
                            return O
                        }
                        ,
                        this.getActiveMipmapLevel = function() {
                            return L
                        }
                        ,
                        this.getRenderTarget = function() {
                            return N
                        }
                        ,
                        this.setRenderTargetTextures = function(te, Se, Ge) {
                            const Ue = Te.get(te);
                            Ue.__autoAllocateDepthBuffer = te.resolveDepthBuffer === !1,
                            Ue.__autoAllocateDepthBuffer === !1 && (Ue.__useRenderToTexture = !1),
                            Te.get(te.texture).__webglTexture = Se,
                            Te.get(te.depthTexture).__webglTexture = Ue.__autoAllocateDepthBuffer ? void 0 : Ge,
                            Ue.__hasExternalTextures = !0
                        }
                        ,
                        this.setRenderTargetFramebuffer = function(te, Se) {
                            const Ge = Te.get(te);
                            Ge.__webglFramebuffer = Se,
                            Ge.__useDefaultFramebuffer = Se === void 0
                        }
                        ;
                        const Cr = re.createFramebuffer();
                        this.setRenderTarget = function(te, Se=0, Ge=0) {
                            N = te,
                            O = Se,
                            L = Ge;
                            let Ue = !0
                              , ce = null
                              , at = !1
                              , yt = !1;
                            if (te) {
                                const pt = Te.get(te);
                                if (pt.__useDefaultFramebuffer !== void 0)
                                    xe.bindFramebuffer(re.FRAMEBUFFER, null),
                                    Ue = !1;
                                else if (pt.__webglFramebuffer === void 0)
                                    Ae.setupRenderTarget(te);
                                else if (pt.__hasExternalTextures)
                                    Ae.rebindTextures(te, Te.get(te.texture).__webglTexture, Te.get(te.depthTexture).__webglTexture);
                                else if (te.depthBuffer) {
                                    const Ut = te.depthTexture;
                                    if (pt.__boundDepthTexture !== Ut) {
                                        if (Ut !== null && Te.has(Ut) && (te.width !== Ut.image.width || te.height !== Ut.image.height))
                                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                        Ae.setupDepthRenderbuffer(te)
                                    }
                                }
                                const St = te.texture;
                                (St.isData3DTexture || St.isDataArrayTexture || St.isCompressedArrayTexture) && (yt = !0);
                                const Lt = Te.get(te).__webglFramebuffer;
                                te.isWebGLCubeRenderTarget ? (Array.isArray(Lt[Se]) ? ce = Lt[Se][Ge] : ce = Lt[Se],
                                at = !0) : te.samples > 0 && Ae.useMultisampledRTT(te) === !1 ? ce = Te.get(te).__webglMultisampledFramebuffer : Array.isArray(Lt) ? ce = Lt[Ge] : ce = Lt,
                                B.copy(te.viewport),
                                G.copy(te.scissor),
                                X = te.scissorTest
                            } else
                                B.copy(j).multiplyScalar(W).floor(),
                                G.copy(ee).multiplyScalar(W).floor(),
                                X = H;
                            if (Ge !== 0 && (ce = Cr),
                            xe.bindFramebuffer(re.FRAMEBUFFER, ce) && Ue && xe.drawBuffers(te, ce),
                            xe.viewport(B),
                            xe.scissor(G),
                            xe.setScissorTest(X),
                            at) {
                                const pt = Te.get(te.texture);
                                re.framebufferTexture2D(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_CUBE_MAP_POSITIVE_X + Se, pt.__webglTexture, Ge)
                            } else if (yt) {
                                const pt = Se;
                                for (let St = 0; St < te.textures.length; St++) {
                                    const Lt = Te.get(te.textures[St]);
                                    re.framebufferTextureLayer(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0 + St, Lt.__webglTexture, Ge, pt)
                                }
                            } else if (te !== null && Ge !== 0) {
                                const pt = Te.get(te.texture);
                                re.framebufferTexture2D(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_2D, pt.__webglTexture, Ge)
                            }
                            z = -1
                        }
                        ,
                        this.readRenderTargetPixels = function(te, Se, Ge, Ue, ce, at, yt, pt=0) {
                            if (!(te && te.isWebGLRenderTarget)) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                return
                            }
                            let St = Te.get(te).__webglFramebuffer;
                            if (te.isWebGLCubeRenderTarget && yt !== void 0 && (St = St[yt]),
                            St) {
                                xe.bindFramebuffer(re.FRAMEBUFFER, St);
                                try {
                                    const Lt = te.textures[pt]
                                      , Ut = Lt.format
                                      , Dt = Lt.type;
                                    if (!ye.textureFormatReadable(Ut)) {
                                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                        return
                                    }
                                    if (!ye.textureTypeReadable(Dt)) {
                                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        return
                                    }
                                    Se >= 0 && Se <= te.width - Ue && Ge >= 0 && Ge <= te.height - ce && (te.textures.length > 1 && re.readBuffer(re.COLOR_ATTACHMENT0 + pt),
                                    re.readPixels(Se, Ge, Ue, ce, Ze.convert(Ut), Ze.convert(Dt), at))
                                } finally {
                                    const Lt = N !== null ? Te.get(N).__webglFramebuffer : null;
                                    xe.bindFramebuffer(re.FRAMEBUFFER, Lt)
                                }
                            }
                        }
                        ,
                        this.readRenderTargetPixelsAsync = async function(te, Se, Ge, Ue, ce, at, yt, pt=0) {
                            if (!(te && te.isWebGLRenderTarget))
                                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                            let St = Te.get(te).__webglFramebuffer;
                            if (te.isWebGLCubeRenderTarget && yt !== void 0 && (St = St[yt]),
                            St)
                                if (Se >= 0 && Se <= te.width - Ue && Ge >= 0 && Ge <= te.height - ce) {
                                    xe.bindFramebuffer(re.FRAMEBUFFER, St);
                                    const Lt = te.textures[pt]
                                      , Ut = Lt.format
                                      , Dt = Lt.type;
                                    if (!ye.textureFormatReadable(Ut))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                    if (!ye.textureTypeReadable(Dt))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                    const Kt = re.createBuffer();
                                    re.bindBuffer(re.PIXEL_PACK_BUFFER, Kt),
                                    re.bufferData(re.PIXEL_PACK_BUFFER, at.byteLength, re.STREAM_READ),
                                    te.textures.length > 1 && re.readBuffer(re.COLOR_ATTACHMENT0 + pt),
                                    re.readPixels(Se, Ge, Ue, ce, Ze.convert(Ut), Ze.convert(Dt), 0);
                                    const bn = N !== null ? Te.get(N).__webglFramebuffer : null;
                                    xe.bindFramebuffer(re.FRAMEBUFFER, bn);
                                    const _n = re.fenceSync(re.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                    return re.flush(),
                                    await HB(re, _n, 4),
                                    re.bindBuffer(re.PIXEL_PACK_BUFFER, Kt),
                                    re.getBufferSubData(re.PIXEL_PACK_BUFFER, 0, at),
                                    re.deleteBuffer(Kt),
                                    re.deleteSync(_n),
                                    at
                                } else
                                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                        ,
                        this.copyFramebufferToTexture = function(te, Se=null, Ge=0) {
                            const Ue = Math.pow(2, -Ge)
                              , ce = Math.floor(te.image.width * Ue)
                              , at = Math.floor(te.image.height * Ue)
                              , yt = Se !== null ? Se.x : 0
                              , pt = Se !== null ? Se.y : 0;
                            Ae.setTexture2D(te, 0),
                            re.copyTexSubImage2D(re.TEXTURE_2D, Ge, 0, 0, yt, pt, ce, at),
                            xe.unbindTexture()
                        }
                        ;
                        const Sl = re.createFramebuffer()
                          , Ch = re.createFramebuffer();
                        this.copyTextureToTexture = function(te, Se, Ge=null, Ue=null, ce=0, at=null) {
                            at === null && (ce !== 0 ? (vg("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                            at = ce,
                            ce = 0) : at = 0);
                            let yt, pt, St, Lt, Ut, Dt, Kt, bn, _n;
                            const Wn = te.isCompressedTexture ? te.mipmaps[at] : te.image;
                            if (Ge !== null)
                                yt = Ge.max.x - Ge.min.x,
                                pt = Ge.max.y - Ge.min.y,
                                St = Ge.isBox3 ? Ge.max.z - Ge.min.z : 1,
                                Lt = Ge.min.x,
                                Ut = Ge.min.y,
                                Dt = Ge.isBox3 ? Ge.min.z : 0;
                            else {
                                const Nn = Math.pow(2, -ce);
                                yt = Math.floor(Wn.width * Nn),
                                pt = Math.floor(Wn.height * Nn),
                                te.isDataArrayTexture ? St = Wn.depth : te.isData3DTexture ? St = Math.floor(Wn.depth * Nn) : St = 1,
                                Lt = 0,
                                Ut = 0,
                                Dt = 0
                            }
                            Ue !== null ? (Kt = Ue.x,
                            bn = Ue.y,
                            _n = Ue.z) : (Kt = 0,
                            bn = 0,
                            _n = 0);
                            const dn = Ze.convert(Se.format)
                              , Et = Ze.convert(Se.type);
                            let vn;
                            Se.isData3DTexture ? (Ae.setTexture3D(Se, 0),
                            vn = re.TEXTURE_3D) : Se.isDataArrayTexture || Se.isCompressedArrayTexture ? (Ae.setTexture2DArray(Se, 0),
                            vn = re.TEXTURE_2D_ARRAY) : (Ae.setTexture2D(Se, 0),
                            vn = re.TEXTURE_2D),
                            re.pixelStorei(re.UNPACK_FLIP_Y_WEBGL, Se.flipY),
                            re.pixelStorei(re.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Se.premultiplyAlpha),
                            re.pixelStorei(re.UNPACK_ALIGNMENT, Se.unpackAlignment);
                            const Ht = re.getParameter(re.UNPACK_ROW_LENGTH)
                              , Ni = re.getParameter(re.UNPACK_IMAGE_HEIGHT)
                              , Ua = re.getParameter(re.UNPACK_SKIP_PIXELS)
                              , Ti = re.getParameter(re.UNPACK_SKIP_ROWS)
                              , Oa = re.getParameter(re.UNPACK_SKIP_IMAGES);
                            re.pixelStorei(re.UNPACK_ROW_LENGTH, Wn.width),
                            re.pixelStorei(re.UNPACK_IMAGE_HEIGHT, Wn.height),
                            re.pixelStorei(re.UNPACK_SKIP_PIXELS, Lt),
                            re.pixelStorei(re.UNPACK_SKIP_ROWS, Ut),
                            re.pixelStorei(re.UNPACK_SKIP_IMAGES, Dt);
                            const Jt = te.isDataArrayTexture || te.isData3DTexture
                              , Ss = Se.isDataArrayTexture || Se.isData3DTexture;
                            if (te.isDepthTexture) {
                                const Nn = Te.get(te)
                                  , qn = Te.get(Se)
                                  , ls = Te.get(Nn.__renderTarget)
                                  , Na = Te.get(qn.__renderTarget);
                                xe.bindFramebuffer(re.READ_FRAMEBUFFER, ls.__webglFramebuffer),
                                xe.bindFramebuffer(re.DRAW_FRAMEBUFFER, Na.__webglFramebuffer);
                                for (let $i = 0; $i < St; $i++)
                                    Jt && (re.framebufferTextureLayer(re.READ_FRAMEBUFFER, re.COLOR_ATTACHMENT0, Te.get(te).__webglTexture, ce, Dt + $i),
                                    re.framebufferTextureLayer(re.DRAW_FRAMEBUFFER, re.COLOR_ATTACHMENT0, Te.get(Se).__webglTexture, at, _n + $i)),
                                    re.blitFramebuffer(Lt, Ut, yt, pt, Kt, bn, yt, pt, re.DEPTH_BUFFER_BIT, re.NEAREST);
                                xe.bindFramebuffer(re.READ_FRAMEBUFFER, null),
                                xe.bindFramebuffer(re.DRAW_FRAMEBUFFER, null)
                            } else if (ce !== 0 || te.isRenderTargetTexture || Te.has(te)) {
                                const Nn = Te.get(te)
                                  , qn = Te.get(Se);
                                xe.bindFramebuffer(re.READ_FRAMEBUFFER, Sl),
                                xe.bindFramebuffer(re.DRAW_FRAMEBUFFER, Ch);
                                for (let ls = 0; ls < St; ls++)
                                    Jt ? re.framebufferTextureLayer(re.READ_FRAMEBUFFER, re.COLOR_ATTACHMENT0, Nn.__webglTexture, ce, Dt + ls) : re.framebufferTexture2D(re.READ_FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_2D, Nn.__webglTexture, ce),
                                    Ss ? re.framebufferTextureLayer(re.DRAW_FRAMEBUFFER, re.COLOR_ATTACHMENT0, qn.__webglTexture, at, _n + ls) : re.framebufferTexture2D(re.DRAW_FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_2D, qn.__webglTexture, at),
                                    ce !== 0 ? re.blitFramebuffer(Lt, Ut, yt, pt, Kt, bn, yt, pt, re.COLOR_BUFFER_BIT, re.NEAREST) : Ss ? re.copyTexSubImage3D(vn, at, Kt, bn, _n + ls, Lt, Ut, yt, pt) : re.copyTexSubImage2D(vn, at, Kt, bn, Lt, Ut, yt, pt);
                                xe.bindFramebuffer(re.READ_FRAMEBUFFER, null),
                                xe.bindFramebuffer(re.DRAW_FRAMEBUFFER, null)
                            } else
                                Ss ? te.isDataTexture || te.isData3DTexture ? re.texSubImage3D(vn, at, Kt, bn, _n, yt, pt, St, dn, Et, Wn.data) : Se.isCompressedArrayTexture ? re.compressedTexSubImage3D(vn, at, Kt, bn, _n, yt, pt, St, dn, Wn.data) : re.texSubImage3D(vn, at, Kt, bn, _n, yt, pt, St, dn, Et, Wn) : te.isDataTexture ? re.texSubImage2D(re.TEXTURE_2D, at, Kt, bn, yt, pt, dn, Et, Wn.data) : te.isCompressedTexture ? re.compressedTexSubImage2D(re.TEXTURE_2D, at, Kt, bn, Wn.width, Wn.height, dn, Wn.data) : re.texSubImage2D(re.TEXTURE_2D, at, Kt, bn, yt, pt, dn, Et, Wn);
                            re.pixelStorei(re.UNPACK_ROW_LENGTH, Ht),
                            re.pixelStorei(re.UNPACK_IMAGE_HEIGHT, Ni),
                            re.pixelStorei(re.UNPACK_SKIP_PIXELS, Ua),
                            re.pixelStorei(re.UNPACK_SKIP_ROWS, Ti),
                            re.pixelStorei(re.UNPACK_SKIP_IMAGES, Oa),
                            at === 0 && Se.generateMipmaps && re.generateMipmap(vn),
                            xe.unbindTexture()
                        }
                        ,
                        this.initRenderTarget = function(te) {
                            Te.get(te).__webglFramebuffer === void 0 && Ae.setupRenderTarget(te)
                        }
                        ,
                        this.initTexture = function(te) {
                            te.isCubeTexture ? Ae.setTextureCube(te, 0) : te.isData3DTexture ? Ae.setTexture3D(te, 0) : te.isDataArrayTexture || te.isCompressedArrayTexture ? Ae.setTexture2DArray(te, 0) : Ae.setTexture2D(te, 0),
                            xe.unbindTexture()
                        }
                        ,
                        this.resetState = function() {
                            O = 0,
                            L = 0,
                            N = null,
                            xe.reset(),
                            ht.reset()
                        }
                        ,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    get coordinateSystem() {
                        return Yr
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e;
                        const t = this.getContext();
                        t.drawingBufferColorSpace = Rn._getDrawingBufferColorSpace(e),
                        t.unpackColorSpace = Rn._getUnpackColorSpace()
                    }
                }
                  , Mz = un({
                    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js": (e => {
                        var t = cp();
                        function n(y, S) {
                            return y === S && (y !== 0 || 1 / y === 1 / S) || y !== y && S !== S
                        }
                        var i = typeof Object.is == "function" ? Object.is : n
                          , s = t.useState
                          , a = t.useEffect
                          , o = t.useLayoutEffect
                          , c = t.useDebugValue;
                        function u(y, S) {
                            var A = S()
                              , M = s({
                                inst: {
                                    value: A,
                                    getSnapshot: S
                                }
                            })
                              , x = M[0].inst
                              , T = M[1];
                            return o(function() {
                                x.value = A,
                                x.getSnapshot = S,
                                f(x) && T({
                                    inst: x
                                })
                            }, [y, A, S]),
                            a(function() {
                                return f(x) && T({
                                    inst: x
                                }),
                                y(function() {
                                    f(x) && T({
                                        inst: x
                                    })
                                })
                            }, [y]),
                            c(A),
                            A
                        }
                        function f(y) {
                            var S = y.getSnapshot;
                            y = y.value;
                            try {
                                var A = S();
                                return !i(y, A)
                            } catch {
                                return !0
                            }
                        }
                        function m(y, S) {
                            return S()
                        }
                        var v = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? m : u;
                        e.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : v
                    }
                    )
                })
                  , bz = un({
                    "node_modules/use-sync-external-store/shim/index.js": ( (e, t) => {
                        t.exports = Mz()
                    }
                    )
                })
                  , Ez = un({
                    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js": (e => {
                        var t = cp()
                          , n = bz();
                        function i(m, v) {
                            return m === v && (m !== 0 || 1 / m === 1 / v) || m !== m && v !== v
                        }
                        var s = typeof Object.is == "function" ? Object.is : i
                          , a = n.useSyncExternalStore
                          , o = t.useRef
                          , c = t.useEffect
                          , u = t.useMemo
                          , f = t.useDebugValue;
                        e.useSyncExternalStoreWithSelector = function(m, v, y, S, A) {
                            var M = o(null);
                            if (M.current === null) {
                                var x = {
                                    hasValue: !1,
                                    value: null
                                };
                                M.current = x
                            } else
                                x = M.current;
                            M = u(function() {
                                function D(N) {
                                    if (!w) {
                                        if (w = !0,
                                        U = N,
                                        N = S(N),
                                        A !== void 0 && x.hasValue) {
                                            var z = x.value;
                                            if (A(z, N))
                                                return O = z
                                        }
                                        return O = N
                                    }
                                    if (z = O,
                                    s(U, N))
                                        return z;
                                    var I = S(N);
                                    return A !== void 0 && A(z, I) ? (U = N,
                                    z) : (U = N,
                                    O = I)
                                }
                                var w = !1, U, O, L = y === void 0 ? null : y;
                                return [function() {
                                    return D(v())
                                }
                                , L === null ? void 0 : function() {
                                    return D(L())
                                }
                                ]
                            }, [v, y, S, A]);
                            var T = a(m, M[0], M[1]);
                            return c(function() {
                                x.hasValue = !0,
                                x.value = T
                            }, [T]),
                            f(T),
                            T
                        }
                    }
                    )
                })
                  , Cz = un({
                    "node_modules/use-sync-external-store/shim/with-selector.js": ( (e, t) => {
                        t.exports = Ez()
                    }
                    )
                })
                  , wz = _r(Cz(), 1);
                const S1 = e => {
                    let t;
                    const n = new Set
                      , i = (f, m) => {
                        const v = typeof f == "function" ? f(t) : f;
                        if (!Object.is(v, t)) {
                            const y = t;
                            t = m ?? (typeof v != "object" || v === null) ? v : Object.assign({}, t, v),
                            n.forEach(S => S(t, y))
                        }
                    }
                      , s = () => t
                      , c = {
                        setState: i,
                        getState: s,
                        getInitialState: () => u,
                        subscribe: f => (n.add(f),
                        () => n.delete(f))
                    }
                      , u = t = e(i, s, c);
                    return c
                }
                  , Dz = (e => e ? S1(e) : S1)
                  , {useSyncExternalStoreWithSelector: Rz} = wz.default
                  , Uz = e => e;
                function Oz(e, t=Uz, n) {
                    const i = Rz(e.subscribe, e.getState, e.getInitialState, t, n);
                    return We.useDebugValue(i),
                    i
                }
                const x1 = (e, t) => {
                    const n = Dz(e)
                      , i = (s, a=t) => Oz(n, s, a);
                    return Object.assign(i, n),
                    i
                }
                  , A1 = ( (e, t) => e ? x1(e, t) : x1)
                  , Nz = e => typeof e == "object" && typeof e.then == "function"
                  , Vf = [];
                function T1(e, t, n= (i, s) => i === s) {
                    if (e === t)
                        return !0;
                    if (!e || !t)
                        return !1;
                    const i = e.length;
                    if (t.length !== i)
                        return !1;
                    for (let s = 0; s < i; s++)
                        if (!n(e[s], t[s]))
                            return !1;
                    return !0
                }
                function M1(e, t=null, n=!1, i={}) {
                    t === null && (t = [e]);
                    for (const a of Vf)
                        if (T1(t, a.keys, a.equal)) {
                            if (n)
                                return;
                            if (Object.prototype.hasOwnProperty.call(a, "error"))
                                throw a.error;
                            if (Object.prototype.hasOwnProperty.call(a, "response"))
                                return i.lifespan && i.lifespan > 0 && (a.timeout && clearTimeout(a.timeout),
                                a.timeout = setTimeout(a.remove, i.lifespan)),
                                a.response;
                            if (!n)
                                throw a.promise
                        }
                    const s = {
                        keys: t,
                        equal: i.equal,
                        remove: () => {
                            const a = Vf.indexOf(s);
                            a !== -1 && Vf.splice(a, 1)
                        }
                        ,
                        promise: (Nz(e) ? e : e(...t)).then(a => {
                            s.response = a,
                            i.lifespan && i.lifespan > 0 && (s.timeout = setTimeout(s.remove, i.lifespan))
                        }
                        ).catch(a => s.error = a)
                    };
                    if (Vf.push(s),
                    !n)
                        throw s.promise
                }
                const Bz = (e, t, n) => M1(e, t, !1, n)
                  , Lz = (e, t, n) => void M1(e, t, !0, n)
                  , Iz = e => {
                    if (e === void 0 || e.length === 0)
                        Vf.splice(0, Vf.length);
                    else {
                        const t = Vf.find(n => T1(e, n.keys, n.equal));
                        t && t.remove()
                    }
                }
                ;
                var Pz = un({
                    "node_modules/scheduler/cjs/scheduler.production.js": (e => {
                        function t(k, W) {
                            var V = k.length;
                            k.push(W);
                            e: for (; 0 < V; ) {
                                var Z = V - 1 >>> 1
                                  , j = k[Z];
                                if (0 < s(j, W))
                                    k[Z] = W,
                                    k[V] = j,
                                    V = Z;
                                else
                                    break e
                            }
                        }
                        function n(k) {
                            return k.length === 0 ? null : k[0]
                        }
                        function i(k) {
                            if (k.length === 0)
                                return null;
                            var W = k[0]
                              , V = k.pop();
                            if (V !== W) {
                                k[0] = V;
                                e: for (var Z = 0, j = k.length, ee = j >>> 1; Z < ee; ) {
                                    var H = 2 * (Z + 1) - 1
                                      , ie = k[H]
                                      , se = H + 1
                                      , K = k[se];
                                    if (0 > s(ie, V))
                                        se < j && 0 > s(K, ie) ? (k[Z] = K,
                                        k[se] = V,
                                        Z = se) : (k[Z] = ie,
                                        k[H] = V,
                                        Z = H);
                                    else if (se < j && 0 > s(K, V))
                                        k[Z] = K,
                                        k[se] = V,
                                        Z = se;
                                    else
                                        break e
                                }
                            }
                            return W
                        }
                        function s(k, W) {
                            var V = k.sortIndex - W.sortIndex;
                            return V !== 0 ? V : k.id - W.id
                        }
                        if (typeof performance == "object" && typeof performance.now == "function") {
                            var a = performance;
                            e.unstable_now = function() {
                                return a.now()
                            }
                        } else {
                            var o = Date
                              , c = o.now();
                            e.unstable_now = function() {
                                return o.now() - c
                            }
                        }
                        var u = []
                          , f = []
                          , m = 1
                          , v = null
                          , y = 3
                          , S = !1
                          , A = !1
                          , M = !1
                          , x = typeof setTimeout == "function" ? setTimeout : null
                          , T = typeof clearTimeout == "function" ? clearTimeout : null
                          , D = typeof setImmediate < "u" ? setImmediate : null;
                        function w(k) {
                            for (var W = n(f); W !== null; ) {
                                if (W.callback === null)
                                    i(f);
                                else if (W.startTime <= k)
                                    i(f),
                                    W.sortIndex = W.expirationTime,
                                    t(u, W);
                                else
                                    break;
                                W = n(f)
                            }
                        }
                        function U(k) {
                            if (M = !1,
                            w(k),
                            !A)
                                if (n(u) !== null)
                                    A = !0,
                                    Q();
                                else {
                                    var W = n(f);
                                    W !== null && oe(U, W.startTime - k)
                                }
                        }
                        var O = !1
                          , L = -1
                          , N = 5
                          , z = -1;
                        function I() {
                            return !(e.unstable_now() - z < N)
                        }
                        function B() {
                            if (O) {
                                var k = e.unstable_now();
                                z = k;
                                var W = !0;
                                try {
                                    e: {
                                        A = !1,
                                        M && (M = !1,
                                        T(L),
                                        L = -1),
                                        S = !0;
                                        var V = y;
                                        try {
                                            t: {
                                                for (w(k),
                                                v = n(u); v !== null && !(v.expirationTime > k && I()); ) {
                                                    var Z = v.callback;
                                                    if (typeof Z == "function") {
                                                        v.callback = null,
                                                        y = v.priorityLevel;
                                                        var j = Z(v.expirationTime <= k);
                                                        if (k = e.unstable_now(),
                                                        typeof j == "function") {
                                                            v.callback = j,
                                                            w(k),
                                                            W = !0;
                                                            break t
                                                        }
                                                        v === n(u) && i(u),
                                                        w(k)
                                                    } else
                                                        i(u);
                                                    v = n(u)
                                                }
                                                if (v !== null)
                                                    W = !0;
                                                else {
                                                    var ee = n(f);
                                                    ee !== null && oe(U, ee.startTime - k),
                                                    W = !1
                                                }
                                            }
                                            break e
                                        } finally {
                                            v = null,
                                            y = V,
                                            S = !1
                                        }
                                        W = void 0
                                    }
                                } finally {
                                    W ? G() : O = !1
                                }
                            }
                        }
                        var G;
                        if (typeof D == "function")
                            G = function() {
                                D(B)
                            }
                            ;
                        else if (typeof MessageChannel < "u") {
                            var X = new MessageChannel
                              , q = X.port2;
                            X.port1.onmessage = B,
                            G = function() {
                                q.postMessage(null)
                            }
                        } else
                            G = function() {
                                x(B, 0)
                            }
                            ;
                        function Q() {
                            O || (O = !0,
                            G())
                        }
                        function oe(k, W) {
                            L = x(function() {
                                k(e.unstable_now())
                            }, W)
                        }
                        e.unstable_IdlePriority = 5,
                        e.unstable_ImmediatePriority = 1,
                        e.unstable_LowPriority = 4,
                        e.unstable_NormalPriority = 3,
                        e.unstable_Profiling = null,
                        e.unstable_UserBlockingPriority = 2,
                        e.unstable_cancelCallback = function(k) {
                            k.callback = null
                        }
                        ,
                        e.unstable_continueExecution = function() {
                            A || S || (A = !0,
                            Q())
                        }
                        ,
                        e.unstable_forceFrameRate = function(k) {
                            0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : N = 0 < k ? Math.floor(1e3 / k) : 5
                        }
                        ,
                        e.unstable_getCurrentPriorityLevel = function() {
                            return y
                        }
                        ,
                        e.unstable_getFirstCallbackNode = function() {
                            return n(u)
                        }
                        ,
                        e.unstable_next = function(k) {
                            switch (y) {
                            case 1:
                            case 2:
                            case 3:
                                var W = 3;
                                break;
                            default:
                                W = y
                            }
                            var V = y;
                            y = W;
                            try {
                                return k()
                            } finally {
                                y = V
                            }
                        }
                        ,
                        e.unstable_pauseExecution = function() {}
                        ,
                        e.unstable_requestPaint = function() {}
                        ,
                        e.unstable_runWithPriority = function(k, W) {
                            switch (k) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                k = 3
                            }
                            var V = y;
                            y = k;
                            try {
                                return W()
                            } finally {
                                y = V
                            }
                        }
                        ,
                        e.unstable_scheduleCallback = function(k, W, V) {
                            var Z = e.unstable_now();
                            switch (typeof V == "object" && V !== null ? (V = V.delay,
                            V = typeof V == "number" && 0 < V ? Z + V : Z) : V = Z,
                            k) {
                            case 1:
                                var j = -1;
                                break;
                            case 2:
                                j = 250;
                                break;
                            case 5:
                                j = 1073741823;
                                break;
                            case 4:
                                j = 1e4;
                                break;
                            default:
                                j = 5e3
                            }
                            return j = V + j,
                            k = {
                                id: m++,
                                callback: W,
                                priorityLevel: k,
                                startTime: V,
                                expirationTime: j,
                                sortIndex: -1
                            },
                            V > Z ? (k.sortIndex = V,
                            t(f, k),
                            n(u) === null && k === n(f) && (M ? (T(L),
                            L = -1) : M = !0,
                            oe(U, V - Z))) : (k.sortIndex = j,
                            t(u, k),
                            A || S || (A = !0,
                            Q())),
                            k
                        }
                        ,
                        e.unstable_shouldYield = I,
                        e.unstable_wrapCallback = function(k) {
                            var W = y;
                            return function() {
                                var V = y;
                                y = W;
                                try {
                                    return k.apply(this, arguments)
                                } finally {
                                    y = V
                                }
                            }
                        }
                    }
                    )
                })
                  , sM = un({
                    "node_modules/scheduler/index.js": ( (e, t) => {
                        t.exports = Pz()
                    }
                    )
                })
                  , zz = un({
                    "node_modules/react-reconciler/cjs/react-reconciler.production.js": ( (e, t) => {
                        t.exports = function(n) {
                            function i(h, d, _, E) {
                                return new Km(h,d,_,E)
                            }
                            function s() {}
                            function a(h) {
                                var d = "https://react.dev/errors/" + h;
                                if (1 < arguments.length) {
                                    d += "?args[]=" + encodeURIComponent(arguments[1]);
                                    for (var _ = 2; _ < arguments.length; _++)
                                        d += "&args[]=" + encodeURIComponent(arguments[_])
                                }
                                return "Minified React error #" + h + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                            }
                            function o(h) {
                                return h === null || typeof h != "object" ? null : (h = sv && h[sv] || h["@@iterator"],
                                typeof h == "function" ? h : null)
                            }
                            function c(h) {
                                if (h == null)
                                    return null;
                                if (typeof h == "function")
                                    return h.$$typeof === Oc ? null : h.displayName || h.name || null;
                                if (typeof h == "string")
                                    return h;
                                switch (h) {
                                case Ou:
                                    return "Fragment";
                                case zr:
                                    return "Portal";
                                case iv:
                                    return "Profiler";
                                case nv:
                                    return "StrictMode";
                                case Rd:
                                    return "Suspense";
                                case kl:
                                    return "SuspenseList"
                                }
                                if (typeof h == "object")
                                    switch (h.$$typeof) {
                                    case po:
                                        return (h.displayName || "Context") + ".Provider";
                                    case Vl:
                                        return (h._context.displayName || "Context") + ".Consumer";
                                    case Nu:
                                        var d = h.render;
                                        return h = h.displayName,
                                        h || (h = d.displayName || d.name || "",
                                        h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"),
                                        h;
                                    case Fh:
                                        return d = h.displayName || null,
                                        d !== null ? d : c(h.type) || "Memo";
                                    case Fr:
                                        d = h._payload,
                                        h = h._init;
                                        try {
                                            return c(h(d))
                                        } catch {}
                                    }
                                return null
                            }
                            function u(h) {
                                if (Ud === void 0)
                                    try {
                                        throw Error()
                                    } catch (_) {
                                        var d = _.stack.trim().match(/\n( *(at )?)/);
                                        Ud = d && d[1] || "",
                                        av = -1 < _.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < _.stack.indexOf("@") ? "@unknown:0:0" : ""
                                    }
                                return `
` + Ud + h + av
                            }
                            function f(h, d) {
                                if (!h || Xl)
                                    return "";
                                Xl = !0;
                                var _ = Error.prepareStackTrace;
                                Error.prepareStackTrace = void 0;
                                try {
                                    var E = {
                                        DetermineComponentFrameRoot: function() {
                                            try {
                                                if (d) {
                                                    var Tt = function() {
                                                        throw Error()
                                                    };
                                                    if (Object.defineProperty(Tt.prototype, "props", {
                                                        set: function() {
                                                            throw Error()
                                                        }
                                                    }),
                                                    typeof Reflect == "object" && Reflect.construct) {
                                                        try {
                                                            Reflect.construct(Tt, [])
                                                        } catch (qt) {
                                                            var bt = qt
                                                        }
                                                        Reflect.construct(h, [], Tt)
                                                    } else {
                                                        try {
                                                            Tt.call()
                                                        } catch (qt) {
                                                            bt = qt
                                                        }
                                                        h.call(Tt.prototype)
                                                    }
                                                } else {
                                                    try {
                                                        throw Error()
                                                    } catch (qt) {
                                                        bt = qt
                                                    }
                                                    (Tt = h()) && typeof Tt.catch == "function" && Tt.catch(function() {})
                                                }
                                            } catch (qt) {
                                                if (qt && bt && typeof qt.stack == "string")
                                                    return [qt.stack, bt.stack]
                                            }
                                            return [null, null]
                                        }
                                    };
                                    E.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                                    var R = Object.getOwnPropertyDescriptor(E.DetermineComponentFrameRoot, "name");
                                    R && R.configurable && Object.defineProperty(E.DetermineComponentFrameRoot, "name", {
                                        value: "DetermineComponentFrameRoot"
                                    });
                                    var P = E.DetermineComponentFrameRoot()
                                      , ne = P[0]
                                      , me = P[1];
                                    if (ne && me) {
                                        var Ce = ne.split(`
`)
                                          , et = me.split(`
`);
                                        for (R = E = 0; E < Ce.length && !Ce[E].includes("DetermineComponentFrameRoot"); )
                                            E++;
                                        for (; R < et.length && !et[R].includes("DetermineComponentFrameRoot"); )
                                            R++;
                                        if (E === Ce.length || R === et.length)
                                            for (E = Ce.length - 1,
                                            R = et.length - 1; 1 <= E && 0 <= R && Ce[E] !== et[R]; )
                                                R--;
                                        for (; 1 <= E && 0 <= R; E--,
                                        R--)
                                            if (Ce[E] !== et[R]) {
                                                if (E !== 1 || R !== 1)
                                                    do
                                                        if (E--,
                                                        R--,
                                                        0 > R || Ce[E] !== et[R]) {
                                                            var mt = `
` + Ce[E].replace(" at new ", " at ");
                                                            return h.displayName && mt.includes("<anonymous>") && (mt = mt.replace("<anonymous>", h.displayName)),
                                                            mt
                                                        }
                                                    while (1 <= E && 0 <= R);
                                                break
                                            }
                                    }
                                } finally {
                                    Xl = !1,
                                    Error.prepareStackTrace = _
                                }
                                return (_ = h ? h.displayName || h.name : "") ? u(_) : ""
                            }
                            function m(h) {
                                switch (h.tag) {
                                case 26:
                                case 27:
                                case 5:
                                    return u(h.type);
                                case 16:
                                    return u("Lazy");
                                case 13:
                                    return u("Suspense");
                                case 19:
                                    return u("SuspenseList");
                                case 0:
                                case 15:
                                    return h = f(h.type, !1),
                                    h;
                                case 11:
                                    return h = f(h.type.render, !1),
                                    h;
                                case 1:
                                    return h = f(h.type, !0),
                                    h;
                                default:
                                    return ""
                                }
                            }
                            function v(h) {
                                try {
                                    var d = "";
                                    do
                                        d += m(h),
                                        h = h.return;
                                    while (h);
                                    return d
                                } catch (_) {
                                    return `
Error generating stack: ` + _.message + `
` + _.stack
                                }
                            }
                            function y(h) {
                                var d = h
                                  , _ = h;
                                if (h.alternate)
                                    for (; d.return; )
                                        d = d.return;
                                else {
                                    h = d;
                                    do
                                        d = h,
                                        (d.flags & 4098) !== 0 && (_ = d.return),
                                        h = d.return;
                                    while (h)
                                }
                                return d.tag === 3 ? _ : null
                            }
                            function S(h) {
                                if (y(h) !== h)
                                    throw Error(a(188))
                            }
                            function A(h) {
                                var d = h.alternate;
                                if (!d) {
                                    if (d = y(h),
                                    d === null)
                                        throw Error(a(188));
                                    return d !== h ? null : h
                                }
                                for (var _ = h, E = d; ; ) {
                                    var R = _.return;
                                    if (R === null)
                                        break;
                                    var P = R.alternate;
                                    if (P === null) {
                                        if (E = R.return,
                                        E !== null) {
                                            _ = E;
                                            continue
                                        }
                                        break
                                    }
                                    if (R.child === P.child) {
                                        for (P = R.child; P; ) {
                                            if (P === _)
                                                return S(R),
                                                h;
                                            if (P === E)
                                                return S(R),
                                                d;
                                            P = P.sibling
                                        }
                                        throw Error(a(188))
                                    }
                                    if (_.return !== E.return)
                                        _ = R,
                                        E = P;
                                    else {
                                        for (var ne = !1, me = R.child; me; ) {
                                            if (me === _) {
                                                ne = !0,
                                                _ = R,
                                                E = P;
                                                break
                                            }
                                            if (me === E) {
                                                ne = !0,
                                                E = R,
                                                _ = P;
                                                break
                                            }
                                            me = me.sibling
                                        }
                                        if (!ne) {
                                            for (me = P.child; me; ) {
                                                if (me === _) {
                                                    ne = !0,
                                                    _ = P,
                                                    E = R;
                                                    break
                                                }
                                                if (me === E) {
                                                    ne = !0,
                                                    E = P,
                                                    _ = R;
                                                    break
                                                }
                                                me = me.sibling
                                            }
                                            if (!ne)
                                                throw Error(a(189))
                                        }
                                    }
                                    if (_.alternate !== E)
                                        throw Error(a(190))
                                }
                                if (_.tag !== 3)
                                    throw Error(a(188));
                                return _.stateNode.current === _ ? h : d
                            }
                            function M(h) {
                                var d = h.tag;
                                if (d === 5 || d === 26 || d === 27 || d === 6)
                                    return h;
                                for (h = h.child; h !== null; ) {
                                    if (d = M(h),
                                    d !== null)
                                        return d;
                                    h = h.sibling
                                }
                                return null
                            }
                            function x(h) {
                                var d = h.tag;
                                if (d === 5 || d === 26 || d === 27 || d === 6)
                                    return h;
                                for (h = h.child; h !== null; ) {
                                    if (h.tag !== 4 && (d = x(h),
                                    d !== null))
                                        return d;
                                    h = h.sibling
                                }
                                return null
                            }
                            function T(h) {
                                return {
                                    current: h
                                }
                            }
                            function D(h) {
                                0 > Qo || (h.current = jh[Qo],
                                jh[Qo] = null,
                                Qo--)
                            }
                            function w(h, d) {
                                Qo++,
                                jh[Qo] = h.current,
                                h.current = d
                            }
                            function U(h) {
                                return h >>>= 0,
                                h === 0 ? 32 : 31 - (Qh(h) / cy | 0) | 0
                            }
                            function O(h) {
                                var d = h & 42;
                                if (d !== 0)
                                    return d;
                                switch (h & -h) {
                                case 1:
                                    return 1;
                                case 2:
                                    return 2;
                                case 4:
                                    return 4;
                                case 8:
                                    return 8;
                                case 16:
                                    return 16;
                                case 32:
                                    return 32;
                                case 64:
                                    return 64;
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                    return h & 4194176;
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    return h & 62914560;
                                case 67108864:
                                    return 67108864;
                                case 134217728:
                                    return 134217728;
                                case 268435456:
                                    return 268435456;
                                case 536870912:
                                    return 536870912;
                                case 1073741824:
                                    return 0;
                                default:
                                    return h
                                }
                            }
                            function L(h, d) {
                                var _ = h.pendingLanes;
                                if (_ === 0)
                                    return 0;
                                var E = 0
                                  , R = h.suspendedLanes
                                  , P = h.pingedLanes
                                  , ne = h.warmLanes;
                                h = h.finishedLanes !== 0;
                                var me = _ & 134217727;
                                return me !== 0 ? (_ = me & ~R,
                                _ !== 0 ? E = O(_) : (P &= me,
                                P !== 0 ? E = O(P) : h || (ne = me & ~ne,
                                ne !== 0 && (E = O(ne))))) : (me = _ & ~R,
                                me !== 0 ? E = O(me) : P !== 0 ? E = O(P) : h || (ne = _ & ~ne,
                                ne !== 0 && (E = O(ne)))),
                                E === 0 ? 0 : d !== 0 && d !== E && (d & R) === 0 && (R = E & -E,
                                ne = d & -d,
                                R >= ne || R === 32 && (ne & 4194176) !== 0) ? d : E
                            }
                            function N(h, d) {
                                return (h.pendingLanes & ~(h.suspendedLanes & ~h.pingedLanes) & d) === 0
                            }
                            function z(h, d) {
                                switch (h) {
                                case 1:
                                case 2:
                                case 4:
                                case 8:
                                    return d + 250;
                                case 16:
                                case 32:
                                case 64:
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                    return d + 5e3;
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    return -1;
                                case 67108864:
                                case 134217728:
                                case 268435456:
                                case 536870912:
                                case 1073741824:
                                    return -1;
                                default:
                                    return -1
                                }
                            }
                            function I() {
                                var h = Pu;
                                return Pu <<= 1,
                                (Pu & 4194176) === 0 && (Pu = 128),
                                h
                            }
                            function B() {
                                var h = Zh;
                                return Zh <<= 1,
                                (Zh & 62914560) === 0 && (Zh = 4194304),
                                h
                            }
                            function G(h) {
                                for (var d = [], _ = 0; 31 > _; _++)
                                    d.push(h);
                                return d
                            }
                            function X(h, d) {
                                h.pendingLanes |= d,
                                d !== 268435456 && (h.suspendedLanes = 0,
                                h.pingedLanes = 0,
                                h.warmLanes = 0)
                            }
                            function q(h, d, _, E, R, P) {
                                var ne = h.pendingLanes;
                                h.pendingLanes = _,
                                h.suspendedLanes = 0,
                                h.pingedLanes = 0,
                                h.warmLanes = 0,
                                h.expiredLanes &= _,
                                h.entangledLanes &= _,
                                h.errorRecoveryDisabledLanes &= _,
                                h.shellSuspendCounter = 0;
                                var me = h.entanglements
                                  , Ce = h.expirationTimes
                                  , et = h.hiddenUpdates;
                                for (_ = ne & ~_; 0 < _; ) {
                                    var mt = 31 - ma(_)
                                      , Tt = 1 << mt;
                                    me[mt] = 0,
                                    Ce[mt] = -1;
                                    var bt = et[mt];
                                    if (bt !== null)
                                        for (et[mt] = null,
                                        mt = 0; mt < bt.length; mt++) {
                                            var qt = bt[mt];
                                            qt !== null && (qt.lane &= -536870913)
                                        }
                                    _ &= ~Tt
                                }
                                E !== 0 && Q(h, E, 0),
                                P !== 0 && R === 0 && h.tag !== 0 && (h.suspendedLanes |= P & ~(ne & ~d))
                            }
                            function Q(h, d, _) {
                                h.pendingLanes |= d,
                                h.suspendedLanes &= ~d;
                                var E = 31 - ma(d);
                                h.entangledLanes |= d,
                                h.entanglements[E] = h.entanglements[E] | 1073741824 | _ & 4194218
                            }
                            function oe(h, d) {
                                var _ = h.entangledLanes |= d;
                                for (h = h.entanglements; _; ) {
                                    var E = 31 - ma(_)
                                      , R = 1 << E;
                                    R & d | h[E] & d && (h[E] |= d),
                                    _ &= ~R
                                }
                            }
                            function k(h) {
                                return h &= -h,
                                2 < h ? 8 < h ? (h & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                            }
                            function W(h) {
                                if (va && typeof va.onCommitFiberRoot == "function")
                                    try {
                                        va.onCommitFiberRoot(Fu, h, void 0, (h.current.flags & 128) === 128)
                                    } catch {}
                            }
                            function V(h) {
                                if (typeof dy == "function" && Iv(h),
                                va && typeof va.setStrictMode == "function")
                                    try {
                                        va.setStrictMode(Fu, h)
                                    } catch {}
                            }
                            function Z(h, d) {
                                return h === d && (h !== 0 || 1 / h === 1 / d) || h !== h && d !== d
                            }
                            function j(h, d) {
                                if (typeof h == "object" && h !== null) {
                                    var _ = qd.get(h);
                                    return _ !== void 0 ? _ : (d = {
                                        value: h,
                                        source: d,
                                        stack: v(d)
                                    },
                                    qd.set(h, d),
                                    d)
                                }
                                return {
                                    value: h,
                                    source: d,
                                    stack: v(d)
                                }
                            }
                            function ee(h, d) {
                                fi[Ei++] = $h,
                                fi[Ei++] = Jh,
                                Jh = h,
                                $h = d
                            }
                            function H(h, d, _) {
                                ka[Xa++] = yo,
                                ka[Xa++] = dr,
                                ka[Xa++] = Hr,
                                Hr = h;
                                var E = yo;
                                h = dr;
                                var R = 32 - ma(E) - 1;
                                E &= ~(1 << R),
                                _ += 1;
                                var P = 32 - ma(d) + R;
                                if (30 < P) {
                                    var ne = R - R % 5;
                                    P = (E & (1 << ne) - 1).toString(32),
                                    E >>= ne,
                                    R -= ne,
                                    yo = 1 << 32 - ma(d) + R | _ << R | E,
                                    dr = P + h
                                } else
                                    yo = 1 << P | _ << R | E,
                                    dr = h
                            }
                            function ie(h) {
                                h.return !== null && (ee(h, 1),
                                H(h, 1, 0))
                            }
                            function se(h) {
                                for (; h === Jh; )
                                    Jh = fi[--Ei],
                                    fi[Ei] = null,
                                    $h = fi[--Ei],
                                    fi[Ei] = null;
                                for (; h === Hr; )
                                    Hr = ka[--Xa],
                                    ka[Xa] = null,
                                    dr = ka[--Xa],
                                    ka[Xa] = null,
                                    yo = ka[--Xa],
                                    ka[Xa] = null
                            }
                            function K(h, d) {
                                w(Gr, d),
                                w(ef, h),
                                w(ds, null),
                                h = Nc(d),
                                D(ds),
                                w(ds, h)
                            }
                            function le() {
                                D(ds),
                                D(ef),
                                D(Gr)
                            }
                            function ue(h) {
                                h.memoizedState !== null && w(Hu, h);
                                var d = ds.current
                                  , _ = V0(d, h.type);
                                d !== _ && (w(ef, h),
                                w(ds, _))
                            }
                            function de(h) {
                                ef.current === h && (D(ds),
                                D(ef)),
                                Hu.current === h && (D(Hu),
                                mo ? Vt._currentValue = pa : Vt._currentValue2 = pa)
                            }
                            function qe(h) {
                                var d = Error(a(418, ""));
                                throw he(j(d, h)),
                                tf
                            }
                            function ze(h, d) {
                                if (!Js)
                                    throw Error(a(175));
                                Ux(h.stateNode, h.type, h.memoizedProps, d, h) || qe(h)
                            }
                            function Ee(h) {
                                for (Gs = h.return; Gs; )
                                    switch (Gs.tag) {
                                    case 3:
                                    case 27:
                                        pr = !0;
                                        return;
                                    case 5:
                                    case 13:
                                        pr = !1;
                                        return;
                                    default:
                                        Gs = Gs.return
                                    }
                            }
                            function re(h) {
                                if (!Js || h !== Gs)
                                    return !1;
                                if (!En)
                                    return Ee(h),
                                    En = !0,
                                    !1;
                                var d = !1;
                                if (Es ? h.tag !== 3 && h.tag !== 27 && (h.tag !== 5 || sy(h.type) && !jl(h.type, h.memoizedProps)) && (d = !0) : h.tag !== 3 && (h.tag !== 5 || sy(h.type) && !jl(h.type, h.memoizedProps)) && (d = !0),
                                d && ws && qe(h),
                                Ee(h),
                                h.tag === 13) {
                                    if (!Js)
                                        throw Error(a(316));
                                    if (h = h.memoizedState,
                                    h = h !== null ? h.dehydrated : null,
                                    !h)
                                        throw Error(a(317));
                                    ws = ny(h)
                                } else
                                    ws = Gs ? Tv(h.stateNode) : null;
                                return !0
                            }
                            function Le() {
                                Js && (ws = Gs = null,
                                En = !1)
                            }
                            function he(h) {
                                Wa === null ? Wa = [h] : Wa.push(h)
                            }
                            function ye() {
                                for (var h = Zl, d = Gu = Zl = 0; d < h; ) {
                                    var _ = Ya[d];
                                    Ya[d++] = null;
                                    var E = Ya[d];
                                    Ya[d++] = null;
                                    var R = Ya[d];
                                    Ya[d++] = null;
                                    var P = Ya[d];
                                    if (Ya[d++] = null,
                                    E !== null && R !== null) {
                                        var ne = E.pending;
                                        ne === null ? R.next = R : (R.next = ne.next,
                                        ne.next = R),
                                        E.pending = R
                                    }
                                    P !== 0 && Ae(_, R, P)
                                }
                            }
                            function xe(h, d, _, E) {
                                Ya[Zl++] = h,
                                Ya[Zl++] = d,
                                Ya[Zl++] = _,
                                Ya[Zl++] = E,
                                Gu |= E,
                                h.lanes |= E,
                                h = h.alternate,
                                h !== null && (h.lanes |= E)
                            }
                            function ge(h, d, _, E) {
                                return xe(h, d, _, E),
                                we(h)
                            }
                            function Te(h, d) {
                                return xe(h, null, null, d),
                                we(h)
                            }
                            function Ae(h, d, _) {
                                h.lanes |= _;
                                var E = h.alternate;
                                E !== null && (E.lanes |= _);
                                for (var R = !1, P = h.return; P !== null; )
                                    P.childLanes |= _,
                                    E = P.alternate,
                                    E !== null && (E.childLanes |= _),
                                    P.tag === 22 && (h = P.stateNode,
                                    h === null || h._visibility & 1 || (R = !0)),
                                    h = P,
                                    P = P.return;
                                R && d !== null && h.tag === 3 && (P = h.stateNode,
                                R = 31 - ma(_),
                                P = P.hiddenUpdates,
                                h = P[R],
                                h === null ? P[R] = [d] : h.push(d),
                                d.lane = _ | 536870912)
                            }
                            function we(h) {
                                if (50 < Xc)
                                    throw Xc = 0,
                                    xa = null,
                                    Error(a(185));
                                for (var d = h.return; d !== null; )
                                    h = d,
                                    d = h.return;
                                return h.tag === 3 ? h.stateNode : null
                            }
                            function it(h) {
                                h !== Pc && h.next === null && (Pc === null ? Vu = Pc = h : Pc = Pc.next = h),
                                sf = !0,
                                nf || (nf = !0,
                                Re($))
                            }
                            function je(h, d) {
                                if (!Vr && sf) {
                                    Vr = !0;
                                    do
                                        for (var _ = !1, E = Vu; E !== null; ) {
                                            if (!d)
                                                if (h !== 0) {
                                                    var R = E.pendingLanes;
                                                    if (R === 0)
                                                        var P = 0;
                                                    else {
                                                        var ne = E.suspendedLanes
                                                          , me = E.pingedLanes;
                                                        P = (1 << 31 - ma(42 | h) + 1) - 1,
                                                        P &= R & ~(ne & ~me),
                                                        P = P & 201326677 ? P & 201326677 | 1 : P ? P | 2 : 0
                                                    }
                                                    P !== 0 && (_ = !0,
                                                    He(E, P))
                                                } else
                                                    P = rn,
                                                    P = L(E, E === cn ? P : 0),
                                                    (P & 3) === 0 || N(E, P) || (_ = !0,
                                                    He(E, P));
                                            E = E.next
                                        }
                                    while (_);
                                    Vr = !1
                                }
                            }
                            function $() {
                                sf = nf = !1;
                                var h = 0;
                                Kl !== 0 && (Ql() && (h = Kl),
                                Kl = 0);
                                for (var d = Cs(), _ = null, E = Vu; E !== null; ) {
                                    var R = E.next
                                      , P = Y(E, d);
                                    P === 0 ? (E.next = null,
                                    _ === null ? Vu = R : _.next = R,
                                    R === null && (Pc = _)) : (_ = E,
                                    (h !== 0 || (P & 3) !== 0) && (sf = !0)),
                                    E = R
                                }
                                je(h, !1)
                            }
                            function Y(h, d) {
                                for (var _ = h.suspendedLanes, E = h.pingedLanes, R = h.expirationTimes, P = h.pendingLanes & -62914561; 0 < P; ) {
                                    var ne = 31 - ma(P)
                                      , me = 1 << ne
                                      , Ce = R[ne];
                                    Ce === -1 ? ((me & _) === 0 || (me & E) !== 0) && (R[ne] = z(me, d)) : Ce <= d && (h.expiredLanes |= me),
                                    P &= ~me
                                }
                                if (d = cn,
                                _ = rn,
                                _ = L(h, h === d ? _ : 0),
                                E = h.callbackNode,
                                _ === 0 || h === d && Qn === 2 || h.cancelPendingCommit !== null)
                                    return E !== null && E !== null && Kh(E),
                                    h.callbackNode = null,
                                    h.callbackPriority = 0;
                                if ((_ & 3) === 0 || N(h, _)) {
                                    if (d = _ & -_,
                                    d === h.callbackPriority)
                                        return d;
                                    switch (E !== null && Kh(E),
                                    k(_)) {
                                    case 2:
                                    case 8:
                                        _ = Lx;
                                        break;
                                    case 32:
                                        _ = Lv;
                                        break;
                                    case 268435456:
                                        _ = Yd;
                                        break;
                                    default:
                                        _ = Lv
                                    }
                                    return E = pe.bind(null, h),
                                    _ = zu(_, E),
                                    h.callbackPriority = d,
                                    h.callbackNode = _,
                                    d
                                }
                                return E !== null && E !== null && Kh(E),
                                h.callbackPriority = 2,
                                h.callbackNode = null,
                                2
                            }
                            function pe(h, d) {
                                var _ = h.callbackNode;
                                if (hs() && h.callbackNode !== _)
                                    return null;
                                var E = rn;
                                return E = L(h, h === cn ? E : 0),
                                E === 0 ? null : (Bh(h, E, d),
                                Y(h, Cs()),
                                h.callbackNode != null && h.callbackNode === _ ? pe.bind(null, h) : null)
                            }
                            function He(h, d) {
                                if (hs())
                                    return null;
                                Bh(h, d, !0)
                            }
                            function Re(h) {
                                qi ? Ld(function() {
                                    (Pt & 6) !== 0 ? zu(fy, h) : h()
                                }) : zu(fy, h)
                            }
                            function De() {
                                return Kl === 0 && (Kl = I()),
                                Kl
                            }
                            function rt(h, d) {
                                if (af === null) {
                                    var _ = af = [];
                                    jd = 0,
                                    ga = De(),
                                    Jl = {
                                        status: "pending",
                                        value: void 0,
                                        then: function(E) {
                                            _.push(E)
                                        }
                                    }
                                }
                                return jd++,
                                d.then($e, $e),
                                d
                            }
                            function $e() {
                                if (--jd === 0 && af !== null) {
                                    Jl !== null && (Jl.status = "fulfilled");
                                    var h = af;
                                    af = null,
                                    ga = 0,
                                    Jl = null;
                                    for (var d = 0; d < h.length; d++)
                                        (0,
                                        h[d])()
                                }
                            }
                            function ct(h, d) {
                                var _ = []
                                  , E = {
                                    status: "pending",
                                    value: null,
                                    reason: null,
                                    then: function(R) {
                                        _.push(R)
                                    }
                                };
                                return h.then(function() {
                                    E.status = "fulfilled",
                                    E.value = d;
                                    for (var R = 0; R < _.length; R++)
                                        (0,
                                        _[R])(d)
                                }, function(R) {
                                    for (E.status = "rejected",
                                    E.reason = R,
                                    R = 0; R < _.length; R++)
                                        (0,
                                        _[R])(void 0)
                                }),
                                E
                            }
                            function gt(h) {
                                h.updateQueue = {
                                    baseState: h.memoizedState,
                                    firstBaseUpdate: null,
                                    lastBaseUpdate: null,
                                    shared: {
                                        pending: null,
                                        lanes: 0,
                                        hiddenCallbacks: null
                                    },
                                    callbacks: null
                                }
                            }
                            function Ie(h, d) {
                                h = h.updateQueue,
                                d.updateQueue === h && (d.updateQueue = {
                                    baseState: h.baseState,
                                    firstBaseUpdate: h.firstBaseUpdate,
                                    lastBaseUpdate: h.lastBaseUpdate,
                                    shared: h.shared,
                                    callbacks: null
                                })
                            }
                            function Je(h) {
                                return {
                                    lane: h,
                                    tag: 0,
                                    payload: null,
                                    callback: null,
                                    next: null
                                }
                            }
                            function Ze(h, d, _) {
                                var E = h.updateQueue;
                                if (E === null)
                                    return null;
                                if (E = E.shared,
                                (Pt & 2) !== 0) {
                                    var R = E.pending;
                                    return R === null ? d.next = d : (d.next = R.next,
                                    R.next = d),
                                    E.pending = d,
                                    d = we(h),
                                    Ae(h, null, _),
                                    d
                                }
                                return xe(h, E, d, _),
                                we(h)
                            }
                            function ht(h, d, _) {
                                if (d = d.updateQueue,
                                d !== null && (d = d.shared,
                                (_ & 4194176) !== 0)) {
                                    var E = d.lanes;
                                    E &= h.pendingLanes,
                                    _ |= E,
                                    d.lanes = _,
                                    oe(h, _)
                                }
                            }
                            function lt(h, d) {
                                var _ = h.updateQueue
                                  , E = h.alternate;
                                if (E !== null && (E = E.updateQueue,
                                _ === E)) {
                                    var R = null
                                      , P = null;
                                    if (_ = _.firstBaseUpdate,
                                    _ !== null) {
                                        do {
                                            var ne = {
                                                lane: _.lane,
                                                tag: _.tag,
                                                payload: _.payload,
                                                callback: null,
                                                next: null
                                            };
                                            P === null ? R = P = ne : P = P.next = ne,
                                            _ = _.next
                                        } while (_ !== null);
                                        P === null ? R = P = d : P = P.next = d
                                    } else
                                        R = P = d;
                                    _ = {
                                        baseState: E.baseState,
                                        firstBaseUpdate: R,
                                        lastBaseUpdate: P,
                                        shared: E.shared,
                                        callbacks: E.callbacks
                                    },
                                    h.updateQueue = _;
                                    return
                                }
                                h = _.lastBaseUpdate,
                                h === null ? _.firstBaseUpdate = d : h.next = d,
                                _.lastBaseUpdate = d
                            }
                            function At() {
                                if (ku) {
                                    var h = Jl;
                                    if (h !== null)
                                        throw h
                                }
                            }
                            function fe(h, d, _, E) {
                                ku = !1;
                                var R = h.updateQueue;
                                Zo = !1;
                                var P = R.firstBaseUpdate
                                  , ne = R.lastBaseUpdate
                                  , me = R.shared.pending;
                                if (me !== null) {
                                    R.shared.pending = null;
                                    var Ce = me
                                      , et = Ce.next;
                                    Ce.next = null,
                                    ne === null ? P = et : ne.next = et,
                                    ne = Ce;
                                    var mt = h.alternate;
                                    mt !== null && (mt = mt.updateQueue,
                                    me = mt.lastBaseUpdate,
                                    me !== ne && (me === null ? mt.firstBaseUpdate = et : me.next = et,
                                    mt.lastBaseUpdate = Ce))
                                }
                                if (P !== null) {
                                    var Tt = R.baseState;
                                    ne = 0,
                                    mt = et = Ce = null,
                                    me = P;
                                    do {
                                        var bt = me.lane & -536870913
                                          , qt = bt !== me.lane;
                                        if (qt ? (rn & bt) === bt : (E & bt) === bt) {
                                            bt !== 0 && bt === ga && (ku = !0),
                                            mt !== null && (mt = mt.next = {
                                                lane: 0,
                                                tag: me.tag,
                                                payload: me.payload,
                                                callback: null,
                                                next: null
                                            });
                                            e: {
                                                var Aa = h
                                                  , cf = me;
                                                bt = d;
                                                var Wc = _;
                                                switch (cf.tag) {
                                                case 1:
                                                    if (Aa = cf.payload,
                                                    typeof Aa == "function") {
                                                        Tt = Aa.call(Wc, Tt, bt);
                                                        break e
                                                    }
                                                    Tt = Aa;
                                                    break e;
                                                case 3:
                                                    Aa.flags = Aa.flags & -65537 | 128;
                                                case 0:
                                                    if (Aa = cf.payload,
                                                    bt = typeof Aa == "function" ? Aa.call(Wc, Tt, bt) : Aa,
                                                    bt == null)
                                                        break e;
                                                    Tt = Uc({}, Tt, bt);
                                                    break e;
                                                case 2:
                                                    Zo = !0
                                                }
                                            }
                                            bt = me.callback,
                                            bt !== null && (h.flags |= 64,
                                            qt && (h.flags |= 8192),
                                            qt = R.callbacks,
                                            qt === null ? R.callbacks = [bt] : qt.push(bt))
                                        } else
                                            qt = {
                                                lane: bt,
                                                tag: me.tag,
                                                payload: me.payload,
                                                callback: me.callback,
                                                next: null
                                            },
                                            mt === null ? (et = mt = qt,
                                            Ce = Tt) : mt = mt.next = qt,
                                            ne |= bt;
                                        if (me = me.next,
                                        me === null) {
                                            if (me = R.shared.pending,
                                            me === null)
                                                break;
                                            qt = me,
                                            me = qt.next,
                                            qt.next = null,
                                            R.lastBaseUpdate = qt,
                                            R.shared.pending = null
                                        }
                                    } while (!0);
                                    mt === null && (Ce = Tt),
                                    R.baseState = Ce,
                                    R.firstBaseUpdate = et,
                                    R.lastBaseUpdate = mt,
                                    P === null && (R.shared.lanes = 0),
                                    Za |= ne,
                                    h.lanes = ne,
                                    h.memoizedState = Tt
                                }
                            }
                            function ot(h, d) {
                                if (typeof h != "function")
                                    throw Error(a(191, h));
                                h.call(d)
                            }
                            function tt(h, d) {
                                var _ = h.callbacks;
                                if (_ !== null)
                                    for (h.callbacks = null,
                                    h = 0; h < _.length; h++)
                                        ot(_[h], d)
                            }
                            function xt(h, d) {
                                if (Va(h, d))
                                    return !0;
                                if (typeof h != "object" || h === null || typeof d != "object" || d === null)
                                    return !1;
                                var _ = Object.keys(h)
                                  , E = Object.keys(d);
                                if (_.length !== E.length)
                                    return !1;
                                for (E = 0; E < _.length; E++) {
                                    var R = _[E];
                                    if (!rf.call(d, R) || !Va(h[R], d[R]))
                                        return !1
                                }
                                return !0
                            }
                            function Qe(h) {
                                return h = h.status,
                                h === "fulfilled" || h === "rejected"
                            }
                            function Ne() {}
                            function dt(h, d, _) {
                                switch (_ = h[_],
                                _ === void 0 ? h.push(d) : _ !== d && (d.then(Ne, Ne),
                                d = _),
                                d.status) {
                                case "fulfilled":
                                    return d.value;
                                case "rejected":
                                    throw h = d.reason,
                                    h === Yn ? Error(a(483)) : h;
                                default:
                                    if (typeof d.status == "string")
                                        d.then(Ne, Ne);
                                    else {
                                        if (h = cn,
                                        h !== null && 100 < h.shellSuspendCounter)
                                            throw Error(a(482));
                                        h = d,
                                        h.status = "pending",
                                        h.then(function(E) {
                                            if (d.status === "pending") {
                                                var R = d;
                                                R.status = "fulfilled",
                                                R.value = E
                                            }
                                        }, function(E) {
                                            if (d.status === "pending") {
                                                var R = d;
                                                R.status = "rejected",
                                                R.reason = E
                                            }
                                        })
                                    }
                                    switch (d.status) {
                                    case "fulfilled":
                                        return d.value;
                                    case "rejected":
                                        throw h = d.reason,
                                        h === Yn ? Error(a(483)) : h
                                    }
                                    throw zc = d,
                                    Yn
                                }
                            }
                            function _t() {
                                if (zc === null)
                                    throw Error(a(459));
                                var h = zc;
                                return zc = null,
                                h
                            }
                            function Ct(h) {
                                var d = mr;
                                return mr += 1,
                                _o === null && (_o = []),
                                dt(_o, h, d)
                            }
                            function Ot(h, d) {
                                d = d.props.ref,
                                h.ref = d !== void 0 ? d : null
                            }
                            function Mn(h, d) {
                                throw d.$$typeof === tv ? Error(a(525)) : (h = Object.prototype.toString.call(d),
                                Error(a(31, h === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : h)))
                            }
                            function Un(h) {
                                var d = h._init;
                                return d(h._payload)
                            }
                            function On(h) {
                                function d(Fe, Me) {
                                    if (h) {
                                        var Xe = Fe.deletions;
                                        Xe === null ? (Fe.deletions = [Me],
                                        Fe.flags |= 16) : Xe.push(Me)
                                    }
                                }
                                function _(Fe, Me) {
                                    if (!h)
                                        return null;
                                    for (; Me !== null; )
                                        d(Fe, Me),
                                        Me = Me.sibling;
                                    return null
                                }
                                function E(Fe) {
                                    for (var Me = new Map; Fe !== null; )
                                        Fe.key !== null ? Me.set(Fe.key, Fe) : Me.set(Fe.index, Fe),
                                        Fe = Fe.sibling;
                                    return Me
                                }
                                function R(Fe, Me) {
                                    return Fe = Fs(Fe, Me),
                                    Fe.index = 0,
                                    Fe.sibling = null,
                                    Fe
                                }
                                function P(Fe, Me, Xe) {
                                    return Fe.index = Xe,
                                    h ? (Xe = Fe.alternate,
                                    Xe !== null ? (Xe = Xe.index,
                                    Xe < Me ? (Fe.flags |= 33554434,
                                    Me) : Xe) : (Fe.flags |= 33554434,
                                    Me)) : (Fe.flags |= 1048576,
                                    Me)
                                }
                                function ne(Fe) {
                                    return h && Fe.alternate === null && (Fe.flags |= 33554434),
                                    Fe
                                }
                                function me(Fe, Me, Xe, ut) {
                                    return Me === null || Me.tag !== 6 ? (Me = Gl(Xe, Fe.mode, ut),
                                    Me.return = Fe,
                                    Me) : (Me = R(Me, Xe),
                                    Me.return = Fe,
                                    Me)
                                }
                                function Ce(Fe, Me, Xe, ut) {
                                    var Bt = Xe.type;
                                    return Bt === Ou ? mt(Fe, Me, Xe.props.children, ut, Xe.key) : Me !== null && (Me.elementType === Bt || typeof Bt == "object" && Bt !== null && Bt.$$typeof === Fr && Un(Bt) === Me.type) ? (Me = R(Me, Xe.props),
                                    Ot(Me, Xe),
                                    Me.return = Fe,
                                    Me) : (Me = hr(Xe.type, Xe.key, Xe.props, null, Fe.mode, ut),
                                    Ot(Me, Xe),
                                    Me.return = Fe,
                                    Me)
                                }
                                function et(Fe, Me, Xe, ut) {
                                    return Me === null || Me.tag !== 4 || Me.stateNode.containerInfo !== Xe.containerInfo || Me.stateNode.implementation !== Xe.implementation ? (Me = Uu(Xe, Fe.mode, ut),
                                    Me.return = Fe,
                                    Me) : (Me = R(Me, Xe.children || []),
                                    Me.return = Fe,
                                    Me)
                                }
                                function mt(Fe, Me, Xe, ut, Bt) {
                                    return Me === null || Me.tag !== 7 ? (Me = Xo(Xe, Fe.mode, ut, Bt),
                                    Me.return = Fe,
                                    Me) : (Me = R(Me, Xe),
                                    Me.return = Fe,
                                    Me)
                                }
                                function Tt(Fe, Me, Xe) {
                                    if (typeof Me == "string" && Me !== "" || typeof Me == "number" || typeof Me == "bigint")
                                        return Me = Gl("" + Me, Fe.mode, Xe),
                                        Me.return = Fe,
                                        Me;
                                    if (typeof Me == "object" && Me !== null) {
                                        switch (Me.$$typeof) {
                                        case Wo:
                                            return Xe = hr(Me.type, Me.key, Me.props, null, Fe.mode, Xe),
                                            Ot(Xe, Me),
                                            Xe.return = Fe,
                                            Xe;
                                        case zr:
                                            return Me = Uu(Me, Fe.mode, Xe),
                                            Me.return = Fe,
                                            Me;
                                        case Fr:
                                            var ut = Me._init;
                                            return Me = ut(Me._payload),
                                            Tt(Fe, Me, Xe)
                                        }
                                        if (Wl(Me) || o(Me))
                                            return Me = Xo(Me, Fe.mode, Xe, null),
                                            Me.return = Fe,
                                            Me;
                                        if (typeof Me.then == "function")
                                            return Tt(Fe, Ct(Me), Xe);
                                        if (Me.$$typeof === po)
                                            return Tt(Fe, Dh(Fe, Me), Xe);
                                        Mn(Fe, Me)
                                    }
                                    return null
                                }
                                function bt(Fe, Me, Xe, ut) {
                                    var Bt = Me !== null ? Me.key : null;
                                    if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number" || typeof Xe == "bigint")
                                        return Bt !== null ? null : me(Fe, Me, "" + Xe, ut);
                                    if (typeof Xe == "object" && Xe !== null) {
                                        switch (Xe.$$typeof) {
                                        case Wo:
                                            return Xe.key === Bt ? Ce(Fe, Me, Xe, ut) : null;
                                        case zr:
                                            return Xe.key === Bt ? et(Fe, Me, Xe, ut) : null;
                                        case Fr:
                                            return Bt = Xe._init,
                                            Xe = Bt(Xe._payload),
                                            bt(Fe, Me, Xe, ut)
                                        }
                                        if (Wl(Xe) || o(Xe))
                                            return Bt !== null ? null : mt(Fe, Me, Xe, ut, null);
                                        if (typeof Xe.then == "function")
                                            return bt(Fe, Me, Ct(Xe), ut);
                                        if (Xe.$$typeof === po)
                                            return bt(Fe, Me, Dh(Fe, Xe), ut);
                                        Mn(Fe, Xe)
                                    }
                                    return null
                                }
                                function qt(Fe, Me, Xe, ut, Bt) {
                                    if (typeof ut == "string" && ut !== "" || typeof ut == "number" || typeof ut == "bigint")
                                        return Fe = Fe.get(Xe) || null,
                                        me(Me, Fe, "" + ut, Bt);
                                    if (typeof ut == "object" && ut !== null) {
                                        switch (ut.$$typeof) {
                                        case Wo:
                                            return Fe = Fe.get(ut.key === null ? Xe : ut.key) || null,
                                            Ce(Me, Fe, ut, Bt);
                                        case zr:
                                            return Fe = Fe.get(ut.key === null ? Xe : ut.key) || null,
                                            et(Me, Fe, ut, Bt);
                                        case Fr:
                                            var ii = ut._init;
                                            return ut = ii(ut._payload),
                                            qt(Fe, Me, Xe, ut, Bt)
                                        }
                                        if (Wl(ut) || o(ut))
                                            return Fe = Fe.get(Xe) || null,
                                            mt(Me, Fe, ut, Bt, null);
                                        if (typeof ut.then == "function")
                                            return qt(Fe, Me, Xe, Ct(ut), Bt);
                                        if (ut.$$typeof === po)
                                            return qt(Fe, Me, Xe, Dh(Me, ut), Bt);
                                        Mn(Me, ut)
                                    }
                                    return null
                                }
                                function Aa(Fe, Me, Xe, ut) {
                                    for (var Bt = null, ii = null, kt = Me, wn = Me = 0, ss = null; kt !== null && wn < Xe.length; wn++) {
                                        kt.index > wn ? (ss = kt,
                                        kt = null) : ss = kt.sibling;
                                        var Dn = bt(Fe, kt, Xe[wn], ut);
                                        if (Dn === null) {
                                            kt === null && (kt = ss);
                                            break
                                        }
                                        h && kt && Dn.alternate === null && d(Fe, kt),
                                        Me = P(Dn, Me, wn),
                                        ii === null ? Bt = Dn : ii.sibling = Dn,
                                        ii = Dn,
                                        kt = ss
                                    }
                                    if (wn === Xe.length)
                                        return _(Fe, kt),
                                        En && ee(Fe, wn),
                                        Bt;
                                    if (kt === null) {
                                        for (; wn < Xe.length; wn++)
                                            kt = Tt(Fe, Xe[wn], ut),
                                            kt !== null && (Me = P(kt, Me, wn),
                                            ii === null ? Bt = kt : ii.sibling = kt,
                                            ii = kt);
                                        return En && ee(Fe, wn),
                                        Bt
                                    }
                                    for (kt = E(kt); wn < Xe.length; wn++)
                                        ss = qt(kt, Fe, wn, Xe[wn], ut),
                                        ss !== null && (h && ss.alternate !== null && kt.delete(ss.key === null ? wn : ss.key),
                                        Me = P(ss, Me, wn),
                                        ii === null ? Bt = ss : ii.sibling = ss,
                                        ii = ss);
                                    return h && kt.forEach(function(il) {
                                        return d(Fe, il)
                                    }),
                                    En && ee(Fe, wn),
                                    Bt
                                }
                                function cf(Fe, Me, Xe, ut) {
                                    if (Xe == null)
                                        throw Error(a(151));
                                    for (var Bt = null, ii = null, kt = Me, wn = Me = 0, ss = null, Dn = Xe.next(); kt !== null && !Dn.done; wn++,
                                    Dn = Xe.next()) {
                                        kt.index > wn ? (ss = kt,
                                        kt = null) : ss = kt.sibling;
                                        var il = bt(Fe, kt, Dn.value, ut);
                                        if (il === null) {
                                            kt === null && (kt = ss);
                                            break
                                        }
                                        h && kt && il.alternate === null && d(Fe, kt),
                                        Me = P(il, Me, wn),
                                        ii === null ? Bt = il : ii.sibling = il,
                                        ii = il,
                                        kt = ss
                                    }
                                    if (Dn.done)
                                        return _(Fe, kt),
                                        En && ee(Fe, wn),
                                        Bt;
                                    if (kt === null) {
                                        for (; !Dn.done; wn++,
                                        Dn = Xe.next())
                                            Dn = Tt(Fe, Dn.value, ut),
                                            Dn !== null && (Me = P(Dn, Me, wn),
                                            ii === null ? Bt = Dn : ii.sibling = Dn,
                                            ii = Dn);
                                        return En && ee(Fe, wn),
                                        Bt
                                    }
                                    for (kt = E(kt); !Dn.done; wn++,
                                    Dn = Xe.next())
                                        Dn = qt(kt, Fe, wn, Dn.value, ut),
                                        Dn !== null && (h && Dn.alternate !== null && kt.delete(Dn.key === null ? wn : Dn.key),
                                        Me = P(Dn, Me, wn),
                                        ii === null ? Bt = Dn : ii.sibling = Dn,
                                        ii = Dn);
                                    return h && kt.forEach(function(ip) {
                                        return d(Fe, ip)
                                    }),
                                    En && ee(Fe, wn),
                                    Bt
                                }
                                function Wc(Fe, Me, Xe, ut) {
                                    if (typeof Xe == "object" && Xe !== null && Xe.type === Ou && Xe.key === null && (Xe = Xe.props.children),
                                    typeof Xe == "object" && Xe !== null) {
                                        switch (Xe.$$typeof) {
                                        case Wo:
                                            e: {
                                                for (var Bt = Xe.key; Me !== null; ) {
                                                    if (Me.key === Bt) {
                                                        if (Bt = Xe.type,
                                                        Bt === Ou) {
                                                            if (Me.tag === 7) {
                                                                _(Fe, Me.sibling),
                                                                ut = R(Me, Xe.props.children),
                                                                ut.return = Fe,
                                                                Fe = ut;
                                                                break e
                                                            }
                                                        } else if (Me.elementType === Bt || typeof Bt == "object" && Bt !== null && Bt.$$typeof === Fr && Un(Bt) === Me.type) {
                                                            _(Fe, Me.sibling),
                                                            ut = R(Me, Xe.props),
                                                            Ot(ut, Xe),
                                                            ut.return = Fe,
                                                            Fe = ut;
                                                            break e
                                                        }
                                                        _(Fe, Me);
                                                        break
                                                    } else
                                                        d(Fe, Me);
                                                    Me = Me.sibling
                                                }
                                                Xe.type === Ou ? (ut = Xo(Xe.props.children, Fe.mode, ut, Xe.key),
                                                ut.return = Fe,
                                                Fe = ut) : (ut = hr(Xe.type, Xe.key, Xe.props, null, Fe.mode, ut),
                                                Ot(ut, Xe),
                                                ut.return = Fe,
                                                Fe = ut)
                                            }
                                            return ne(Fe);
                                        case zr:
                                            e: {
                                                for (Bt = Xe.key; Me !== null; ) {
                                                    if (Me.key === Bt)
                                                        if (Me.tag === 4 && Me.stateNode.containerInfo === Xe.containerInfo && Me.stateNode.implementation === Xe.implementation) {
                                                            _(Fe, Me.sibling),
                                                            ut = R(Me, Xe.children || []),
                                                            ut.return = Fe,
                                                            Fe = ut;
                                                            break e
                                                        } else {
                                                            _(Fe, Me);
                                                            break
                                                        }
                                                    else
                                                        d(Fe, Me);
                                                    Me = Me.sibling
                                                }
                                                ut = Uu(Xe, Fe.mode, ut),
                                                ut.return = Fe,
                                                Fe = ut
                                            }
                                            return ne(Fe);
                                        case Fr:
                                            return Bt = Xe._init,
                                            Xe = Bt(Xe._payload),
                                            Wc(Fe, Me, Xe, ut)
                                        }
                                        if (Wl(Xe))
                                            return Aa(Fe, Me, Xe, ut);
                                        if (o(Xe)) {
                                            if (Bt = o(Xe),
                                            typeof Bt != "function")
                                                throw Error(a(150));
                                            return Xe = Bt.call(Xe),
                                            cf(Fe, Me, Xe, ut)
                                        }
                                        if (typeof Xe.then == "function")
                                            return Wc(Fe, Me, Ct(Xe), ut);
                                        if (Xe.$$typeof === po)
                                            return Wc(Fe, Me, Dh(Fe, Xe), ut);
                                        Mn(Fe, Xe)
                                    }
                                    return typeof Xe == "string" && Xe !== "" || typeof Xe == "number" || typeof Xe == "bigint" ? (Xe = "" + Xe,
                                    Me !== null && Me.tag === 6 ? (_(Fe, Me.sibling),
                                    ut = R(Me, Xe),
                                    ut.return = Fe,
                                    Fe = ut) : (_(Fe, Me),
                                    ut = Gl(Xe, Fe.mode, ut),
                                    ut.return = Fe,
                                    Fe = ut),
                                    ne(Fe)) : _(Fe, Me)
                                }
                                return function(Fe, Me, Xe, ut) {
                                    try {
                                        mr = 0;
                                        var Bt = Wc(Fe, Me, Xe, ut);
                                        return _o = null,
                                        Bt
                                    } catch (kt) {
                                        if (kt === Yn)
                                            throw kt;
                                        var ii = i(29, kt, null, Fe.mode);
                                        return ii.lanes = ut,
                                        ii.return = Fe,
                                        ii
                                    }
                                }
                            }
                            function ki(h, d) {
                                h = kr,
                                w(qa, h),
                                w(So, d),
                                kr = h | d.baseLanes
                            }
                            function Bs() {
                                w(qa, kr),
                                w(So, So.current)
                            }
                            function Ls() {
                                kr = qa.current,
                                D(So),
                                D(qa)
                            }
                            function Ai(h) {
                                var d = h.alternate;
                                w(ji, ji.current & 1),
                                w(ja, h),
                                vr === null && (d === null || So.current !== null || d.memoizedState !== null) && (vr = h)
                            }
                            function _s(h) {
                                if (h.tag === 22) {
                                    if (w(ji, ji.current),
                                    w(ja, h),
                                    vr === null) {
                                        var d = h.alternate;
                                        d !== null && d.memoizedState !== null && (vr = h)
                                    }
                                } else
                                    ei(h)
                            }
                            function ei() {
                                w(ji, ji.current),
                                w(ja, ja.current)
                            }
                            function ti(h) {
                                D(ja),
                                vr === h && (vr = null),
                                D(ji)
                            }
                            function Oi(h) {
                                for (var d = h; d !== null; ) {
                                    if (d.tag === 13) {
                                        var _ = d.memoizedState;
                                        if (_ !== null && (_ = _.dehydrated,
                                        _ === null || Hd(_) || qh(_)))
                                            return d
                                    } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) {
                                        if ((d.flags & 128) !== 0)
                                            return d
                                    } else if (d.child !== null) {
                                        d.child.return = d,
                                        d = d.child;
                                        continue
                                    }
                                    if (d === h)
                                        break;
                                    for (; d.sibling === null; ) {
                                        if (d.return === null || d.return === h)
                                            return null;
                                        d = d.return
                                    }
                                    d.sibling.return = d.return,
                                    d = d.sibling
                                }
                                return null
                            }
                            function Qt() {
                                throw Error(a(321))
                            }
                            function Xi(h, d) {
                                if (d === null)
                                    return !1;
                                for (var _ = 0; _ < d.length && _ < h.length; _++)
                                    if (!Va(h[_], d[_]))
                                        return !1;
                                return !0
                            }
                            function lr(h, d, _, E, R, P) {
                                return xo = P,
                                $t = d,
                                d.memoizedState = null,
                                d.updateQueue = null,
                                d.lanes = 0,
                                Ft.H = h === null || h.memoizedState === null ? Qi : Vs,
                                Ko = !1,
                                P = _(E, R),
                                Ko = !1,
                                di && (P = Sl(d, _, E, R)),
                                Cr(h),
                                P
                            }
                            function Cr(h) {
                                Ft.H = Cn;
                                var d = Bn !== null && Bn.next !== null;
                                if (xo = 0,
                                Li = Bn = $t = null,
                                gr = !1,
                                Ci = 0,
                                Xu = null,
                                d)
                                    throw Error(a(300));
                                h === null || Ii || (h = h.dependencies,
                                h !== null && Rl(h) && (Ii = !0))
                            }
                            function Sl(h, d, _, E) {
                                $t = h;
                                var R = 0;
                                do {
                                    if (di && (Xu = null),
                                    Ci = 0,
                                    di = !1,
                                    25 <= R)
                                        throw Error(a(301));
                                    if (R += 1,
                                    Li = Bn = null,
                                    h.updateQueue != null) {
                                        var P = h.updateQueue;
                                        P.lastEffect = null,
                                        P.events = null,
                                        P.stores = null,
                                        P.memoCache != null && (P.memoCache.index = 0)
                                    }
                                    Ft.H = ec,
                                    P = d(_, E)
                                } while (di);
                                return P
                            }
                            function Ch() {
                                var h = Ft.H
                                  , d = h.useState()[0];
                                return d = typeof d.then == "function" ? at(d) : d,
                                h = h.useState()[0],
                                (Bn !== null ? Bn.memoizedState : null) !== h && ($t.flags |= 1024),
                                d
                            }
                            function te() {
                                var h = of !== 0;
                                return of = 0,
                                h
                            }
                            function Se(h, d, _) {
                                d.updateQueue = h.updateQueue,
                                d.flags &= -2053,
                                h.lanes &= ~_
                            }
                            function Ge(h) {
                                if (gr) {
                                    for (h = h.memoizedState; h !== null; ) {
                                        var d = h.queue;
                                        d !== null && (d.pending = null),
                                        h = h.next
                                    }
                                    gr = !1
                                }
                                xo = 0,
                                Li = Bn = $t = null,
                                di = !1,
                                Ci = of = 0,
                                Xu = null
                            }
                            function Ue() {
                                var h = {
                                    memoizedState: null,
                                    baseState: null,
                                    baseQueue: null,
                                    queue: null,
                                    next: null
                                };
                                return Li === null ? $t.memoizedState = Li = h : Li = Li.next = h,
                                Li
                            }
                            function ce() {
                                if (Bn === null) {
                                    var h = $t.alternate;
                                    h = h !== null ? h.memoizedState : null
                                } else
                                    h = Bn.next;
                                var d = Li === null ? $t.memoizedState : Li.next;
                                if (d !== null)
                                    Li = d,
                                    Bn = h;
                                else {
                                    if (h === null)
                                        throw $t.alternate === null ? Error(a(467)) : Error(a(310));
                                    Bn = h,
                                    h = {
                                        memoizedState: Bn.memoizedState,
                                        baseState: Bn.baseState,
                                        baseQueue: Bn.baseQueue,
                                        queue: Bn.queue,
                                        next: null
                                    },
                                    Li === null ? $t.memoizedState = Li = h : Li = Li.next = h
                                }
                                return Li
                            }
                            function at(h) {
                                var d = Ci;
                                return Ci += 1,
                                Xu === null && (Xu = []),
                                h = dt(Xu, h, d),
                                d = $t,
                                (Li === null ? d.memoizedState : Li.next) === null && (d = d.alternate,
                                Ft.H = d === null || d.memoizedState === null ? Qi : Vs),
                                h
                            }
                            function yt(h) {
                                if (h !== null && typeof h == "object") {
                                    if (typeof h.then == "function")
                                        return at(h);
                                    if (h.$$typeof === po)
                                        return Ts(h)
                                }
                                throw Error(a(438, String(h)))
                            }
                            function pt(h) {
                                var d = null
                                  , _ = $t.updateQueue;
                                if (_ !== null && (d = _.memoCache),
                                d == null) {
                                    var E = $t.alternate;
                                    E !== null && (E = E.updateQueue,
                                    E !== null && (E = E.memoCache,
                                    E != null && (d = {
                                        data: E.data.map(function(R) {
                                            return R.slice()
                                        }),
                                        index: 0
                                    })))
                                }
                                if (d ??= {
                                    data: [],
                                    index: 0
                                },
                                _ === null && (_ = Zd(),
                                $t.updateQueue = _),
                                _.memoCache = d,
                                _ = d.data[d.index],
                                _ === void 0)
                                    for (_ = d.data[d.index] = Array(h),
                                    E = 0; E < h; E++)
                                        _[E] = G0;
                                return d.index++,
                                _
                            }
                            function St(h, d) {
                                return typeof d == "function" ? d(h) : d
                            }
                            function Lt(h) {
                                var d = ce();
                                return Ut(d, Bn, h)
                            }
                            function Ut(h, d, _) {
                                var E = h.queue;
                                if (E === null)
                                    throw Error(a(311));
                                E.lastRenderedReducer = _;
                                var R = h.baseQueue
                                  , P = E.pending;
                                if (P !== null) {
                                    if (R !== null) {
                                        var ne = R.next;
                                        R.next = P.next,
                                        P.next = ne
                                    }
                                    d.baseQueue = R = P,
                                    E.pending = null
                                }
                                if (P = h.baseState,
                                R === null)
                                    h.memoizedState = P;
                                else {
                                    d = R.next;
                                    var me = ne = null
                                      , Ce = null
                                      , et = d
                                      , mt = !1;
                                    do {
                                        var Tt = et.lane & -536870913;
                                        if (Tt !== et.lane ? (rn & Tt) === Tt : (xo & Tt) === Tt) {
                                            var bt = et.revertLane;
                                            if (bt === 0)
                                                Ce !== null && (Ce = Ce.next = {
                                                    lane: 0,
                                                    revertLane: 0,
                                                    action: et.action,
                                                    hasEagerState: et.hasEagerState,
                                                    eagerState: et.eagerState,
                                                    next: null
                                                }),
                                                Tt === ga && (mt = !0);
                                            else if ((xo & bt) === bt) {
                                                et = et.next,
                                                bt === ga && (mt = !0);
                                                continue
                                            } else
                                                Tt = {
                                                    lane: 0,
                                                    revertLane: et.revertLane,
                                                    action: et.action,
                                                    hasEagerState: et.hasEagerState,
                                                    eagerState: et.eagerState,
                                                    next: null
                                                },
                                                Ce === null ? (me = Ce = Tt,
                                                ne = P) : Ce = Ce.next = Tt,
                                                $t.lanes |= bt,
                                                Za |= bt;
                                            Tt = et.action,
                                            Ko && _(P, Tt),
                                            P = et.hasEagerState ? et.eagerState : _(P, Tt)
                                        } else
                                            bt = {
                                                lane: Tt,
                                                revertLane: et.revertLane,
                                                action: et.action,
                                                hasEagerState: et.hasEagerState,
                                                eagerState: et.eagerState,
                                                next: null
                                            },
                                            Ce === null ? (me = Ce = bt,
                                            ne = P) : Ce = Ce.next = bt,
                                            $t.lanes |= Tt,
                                            Za |= Tt;
                                        et = et.next
                                    } while (et !== null && et !== d);
                                    if (Ce === null ? ne = P : Ce.next = me,
                                    !Va(P, h.memoizedState) && (Ii = !0,
                                    mt && (_ = Jl,
                                    _ !== null)))
                                        throw _;
                                    h.memoizedState = P,
                                    h.baseState = ne,
                                    h.baseQueue = Ce,
                                    E.lastRenderedState = P
                                }
                                return R === null && (E.lanes = 0),
                                [h.memoizedState, E.dispatch]
                            }
                            function Dt(h) {
                                var d = ce()
                                  , _ = d.queue;
                                if (_ === null)
                                    throw Error(a(311));
                                _.lastRenderedReducer = h;
                                var E = _.dispatch
                                  , R = _.pending
                                  , P = d.memoizedState;
                                if (R !== null) {
                                    _.pending = null;
                                    var ne = R = R.next;
                                    do
                                        P = h(P, ne.action),
                                        ne = ne.next;
                                    while (ne !== R);
                                    Va(P, d.memoizedState) || (Ii = !0),
                                    d.memoizedState = P,
                                    d.baseQueue === null && (d.baseState = P),
                                    _.lastRenderedState = P
                                }
                                return [P, E]
                            }
                            function Kt(h, d, _) {
                                var E = $t
                                  , R = ce()
                                  , P = En;
                                if (P) {
                                    if (_ === void 0)
                                        throw Error(a(407));
                                    _ = _()
                                } else
                                    _ = d();
                                var ne = !Va((Bn || R).memoizedState, _);
                                if (ne && (R.memoizedState = _,
                                Ii = !0),
                                R = R.queue,
                                so(Wn.bind(null, E, R, h), [h]),
                                R.getSnapshot !== d || ne || Li !== null && Li.memoizedState.tag & 1) {
                                    if (E.flags |= 2048,
                                    no(9, _n.bind(null, E, R, _, d), {
                                        destroy: void 0
                                    }, null),
                                    cn === null)
                                        throw Error(a(349));
                                    P || (xo & 60) !== 0 || bn(E, d, _)
                                }
                                return _
                            }
                            function bn(h, d, _) {
                                h.flags |= 16384,
                                h = {
                                    getSnapshot: d,
                                    value: _
                                },
                                d = $t.updateQueue,
                                d === null ? (d = Zd(),
                                $t.updateQueue = d,
                                d.stores = [h]) : (_ = d.stores,
                                _ === null ? d.stores = [h] : _.push(h))
                            }
                            function _n(h, d, _, E) {
                                d.value = _,
                                d.getSnapshot = E,
                                dn(d) && Et(h)
                            }
                            function Wn(h, d, _) {
                                return _(function() {
                                    dn(d) && Et(h)
                                })
                            }
                            function dn(h) {
                                var d = h.getSnapshot;
                                h = h.value;
                                try {
                                    var _ = d();
                                    return !Va(h, _)
                                } catch {
                                    return !0
                                }
                            }
                            function Et(h) {
                                var d = Te(h, 2);
                                d !== null && zs(d, h, 2)
                            }
                            function vn(h) {
                                var d = Ue();
                                if (typeof h == "function") {
                                    var _ = h;
                                    if (h = _(),
                                    Ko) {
                                        V(!0);
                                        try {
                                            _()
                                        } finally {
                                            V(!1)
                                        }
                                    }
                                }
                                return d.memoizedState = d.baseState = h,
                                d.queue = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: St,
                                    lastRenderedState: h
                                },
                                d
                            }
                            function Ht(h, d, _, E) {
                                return h.baseState = _,
                                Ut(h, Bn, typeof E == "function" ? E : St)
                            }
                            function Ni(h, d, _, E, R) {
                                if (La(h))
                                    throw Error(a(485));
                                if (h = d.action,
                                h !== null) {
                                    var P = {
                                        payload: R,
                                        action: h,
                                        next: null,
                                        isTransition: !0,
                                        status: "pending",
                                        value: null,
                                        reason: null,
                                        listeners: [],
                                        then: function(ne) {
                                            P.listeners.push(ne)
                                        }
                                    };
                                    Ft.T !== null ? _(!0) : P.isTransition = !1,
                                    E(P),
                                    _ = d.pending,
                                    _ === null ? (P.next = d.pending = P,
                                    Ua(d, P)) : (P.next = _.next,
                                    d.pending = _.next = P)
                                }
                            }
                            function Ua(h, d) {
                                var _ = d.action
                                  , E = d.payload
                                  , R = h.state;
                                if (d.isTransition) {
                                    var P = Ft.T
                                      , ne = {};
                                    Ft.T = ne;
                                    try {
                                        var me = _(R, E)
                                          , Ce = Ft.S;
                                        Ce !== null && Ce(ne, me),
                                        Ti(h, d, me)
                                    } catch (et) {
                                        Jt(h, d, et)
                                    } finally {
                                        Ft.T = P
                                    }
                                } else
                                    try {
                                        P = _(R, E),
                                        Ti(h, d, P)
                                    } catch (et) {
                                        Jt(h, d, et)
                                    }
                            }
                            function Ti(h, d, _) {
                                _ !== null && typeof _ == "object" && typeof _.then == "function" ? _.then(function(E) {
                                    Oa(h, d, E)
                                }, function(E) {
                                    return Jt(h, d, E)
                                }) : Oa(h, d, _)
                            }
                            function Oa(h, d, _) {
                                d.status = "fulfilled",
                                d.value = _,
                                Ss(d),
                                h.state = _,
                                d = h.pending,
                                d !== null && (_ = d.next,
                                _ === d ? h.pending = null : (_ = _.next,
                                d.next = _,
                                Ua(h, _)))
                            }
                            function Jt(h, d, _) {
                                var E = h.pending;
                                if (h.pending = null,
                                E !== null) {
                                    E = E.next;
                                    do
                                        d.status = "rejected",
                                        d.reason = _,
                                        Ss(d),
                                        d = d.next;
                                    while (d !== E)
                                }
                                h.action = null
                            }
                            function Ss(h) {
                                h = h.listeners;
                                for (var d = 0; d < h.length; d++)
                                    (0,
                                    h[d])()
                            }
                            function Nn(h, d) {
                                return d
                            }
                            function qn(h, d) {
                                if (En) {
                                    var _ = cn.formState;
                                    if (_ !== null) {
                                        e: {
                                            var E = $t;
                                            if (En) {
                                                if (ws) {
                                                    var R = j0(ws, pr);
                                                    if (R) {
                                                        ws = Tv(R),
                                                        E = Q0(R);
                                                        break e
                                                    }
                                                }
                                                qe(E)
                                            }
                                            E = !1
                                        }
                                        E && (d = _[0])
                                    }
                                }
                                _ = Ue(),
                                _.memoizedState = _.baseState = d,
                                E = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: Nn,
                                    lastRenderedState: d
                                },
                                _.queue = E,
                                _ = Sc.bind(null, $t, E),
                                E.dispatch = _,
                                E = vn(!1);
                                var P = ao.bind(null, $t, !1, E.queue);
                                return E = Ue(),
                                R = {
                                    state: d,
                                    dispatch: null,
                                    action: h,
                                    pending: null
                                },
                                E.queue = R,
                                _ = Ni.bind(null, $t, R, P, _),
                                R.dispatch = _,
                                E.memoizedState = h,
                                [d, _, !1]
                            }
                            function ls(h) {
                                var d = ce();
                                return Na(d, Bn, h)
                            }
                            function Na(h, d, _) {
                                d = Ut(h, d, Nn)[0],
                                h = Lt(St)[0],
                                d = typeof d == "object" && d !== null && typeof d.then == "function" ? at(d) : d;
                                var E = ce()
                                  , R = E.queue
                                  , P = R.dispatch;
                                return _ !== E.memoizedState && ($t.flags |= 2048,
                                no(9, $i.bind(null, R, _), {
                                    destroy: void 0
                                }, null)),
                                [d, P, h]
                            }
                            function $i(h, d) {
                                h.action = d
                            }
                            function yc(h) {
                                var d = ce()
                                  , _ = Bn;
                                if (_ !== null)
                                    return Na(d, _, h);
                                ce(),
                                d = d.memoizedState,
                                _ = ce();
                                var E = _.queue.dispatch;
                                return _.memoizedState = h,
                                [d, E, !1]
                            }
                            function no(h, d, _, E) {
                                return h = {
                                    tag: h,
                                    create: d,
                                    inst: _,
                                    deps: E,
                                    next: null
                                },
                                d = $t.updateQueue,
                                d === null && (d = Zd(),
                                $t.updateQueue = d),
                                _ = d.lastEffect,
                                _ === null ? d.lastEffect = h.next = h : (E = _.next,
                                _.next = h,
                                h.next = E,
                                d.lastEffect = h),
                                h
                            }
                            function io() {
                                return ce().memoizedState
                            }
                            function xl(h, d, _, E) {
                                var R = Ue();
                                $t.flags |= h,
                                R.memoizedState = no(1 | d, _, {
                                    destroy: void 0
                                }, E === void 0 ? null : E)
                            }
                            function wr(h, d, _, E) {
                                var R = ce();
                                E = E === void 0 ? null : E;
                                var P = R.memoizedState.inst;
                                Bn !== null && E !== null && Xi(E, Bn.memoizedState.deps) ? R.memoizedState = no(d, _, P, E) : ($t.flags |= h,
                                R.memoizedState = no(1 | d, _, P, E))
                            }
                            function mu(h, d) {
                                xl(8390656, 8, h, d)
                            }
                            function so(h, d) {
                                wr(2048, 8, h, d)
                            }
                            function Bo(h, d) {
                                return wr(4, 2, h, d)
                            }
                            function Lo(h, d) {
                                return wr(4, 4, h, d)
                            }
                            function Dr(h, d) {
                                if (typeof d == "function") {
                                    h = h();
                                    var _ = d(h);
                                    return function() {
                                        typeof _ == "function" ? _() : d(null)
                                    }
                                }
                                if (d != null)
                                    return h = h(),
                                    d.current = h,
                                    function() {
                                        d.current = null
                                    }
                            }
                            function Ba(h, d, _) {
                                _ = _ != null ? _.concat([h]) : null,
                                wr(4, 4, Dr.bind(null, d, h), _)
                            }
                            function Rr() {}
                            function Al(h, d) {
                                var _ = ce();
                                d = d === void 0 ? null : d;
                                var E = _.memoizedState;
                                return d !== null && Xi(d, E[1]) ? E[0] : (_.memoizedState = [h, d],
                                h)
                            }
                            function Ur(h, d) {
                                var _ = ce();
                                d = d === void 0 ? null : d;
                                var E = _.memoizedState;
                                if (d !== null && Xi(d, E[1]))
                                    return E[0];
                                if (E = h(),
                                Ko) {
                                    V(!0);
                                    try {
                                        h()
                                    } finally {
                                        V(!1)
                                    }
                                }
                                return _.memoizedState = [E, d],
                                E
                            }
                            function Or(h, d, _) {
                                return _ === void 0 || (xo & 1073741824) !== 0 ? h.memoizedState = d : (h.memoizedState = _,
                                h = co(),
                                $t.lanes |= h,
                                Za |= h,
                                _)
                            }
                            function Tl(h, d, _, E) {
                                return Va(_, d) ? _ : So.current !== null ? (h = Or(h, _, E),
                                Va(h, d) || (Ii = !0),
                                h) : (xo & 42) === 0 ? (Ii = !0,
                                h.memoizedState = _) : (h = co(),
                                $t.lanes |= h,
                                Za |= h,
                                d)
                            }
                            function Ml(h, d, _, E, R) {
                                var P = ns();
                                Hs(P !== 0 && 8 > P ? P : 8);
                                var ne = Ft.T
                                  , me = {};
                                Ft.T = me,
                                ao(h, !1, d, _);
                                try {
                                    var Ce = R()
                                      , et = Ft.S;
                                    if (et !== null && et(me, Ce),
                                    Ce !== null && typeof Ce == "object" && typeof Ce.then == "function") {
                                        var mt = ct(Ce, E);
                                        Nr(h, d, mt, Ks(h))
                                    } else
                                        Nr(h, d, E, Ks(h))
                                } catch (Tt) {
                                    Nr(h, d, {
                                        then: function() {},
                                        status: "rejected",
                                        reason: Tt
                                    }, Ks())
                                } finally {
                                    Hs(P),
                                    Ft.T = ne
                                }
                            }
                            function vu(h) {
                                var d = h.memoizedState;
                                if (d !== null)
                                    return d;
                                d = {
                                    memoizedState: pa,
                                    baseState: pa,
                                    baseQueue: null,
                                    queue: {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: St,
                                        lastRenderedState: pa
                                    },
                                    next: null
                                };
                                var _ = {};
                                return d.next = {
                                    memoizedState: _,
                                    baseState: _,
                                    baseQueue: null,
                                    queue: {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: St,
                                        lastRenderedState: _
                                    },
                                    next: null
                                },
                                h.memoizedState = d,
                                h = h.alternate,
                                h !== null && (h.memoizedState = d),
                                d
                            }
                            function es() {
                                return Ts(Vt)
                            }
                            function la() {
                                return ce().memoizedState
                            }
                            function _c() {
                                return ce().memoizedState
                            }
                            function bl(h) {
                                for (var d = h.return; d !== null; ) {
                                    switch (d.tag) {
                                    case 24:
                                    case 3:
                                        var _ = Ks();
                                        h = Je(_);
                                        var E = Ze(d, h, _);
                                        E !== null && (zs(E, d, _),
                                        ht(E, d, _)),
                                        d = {
                                            cache: pd()
                                        },
                                        h.payload = d;
                                        return
                                    }
                                    d = d.return
                                }
                            }
                            function cr(h, d, _) {
                                var E = Ks();
                                _ = {
                                    lane: E,
                                    revertLane: 0,
                                    action: _,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                },
                                La(h) ? ca(d, _) : (_ = ge(h, d, _, E),
                                _ !== null && (zs(_, h, E),
                                gu(_, d, E)))
                            }
                            function Sc(h, d, _) {
                                var E = Ks();
                                Nr(h, d, _, E)
                            }
                            function Nr(h, d, _, E) {
                                var R = {
                                    lane: E,
                                    revertLane: 0,
                                    action: _,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                };
                                if (La(h))
                                    ca(d, R);
                                else {
                                    var P = h.alternate;
                                    if (h.lanes === 0 && (P === null || P.lanes === 0) && (P = d.lastRenderedReducer,
                                    P !== null))
                                        try {
                                            var ne = d.lastRenderedState
                                              , me = P(ne, _);
                                            if (R.hasEagerState = !0,
                                            R.eagerState = me,
                                            Va(me, ne))
                                                return xe(h, d, R, 0),
                                                cn === null && ye(),
                                                !1
                                        } catch {}
                                    if (_ = ge(h, d, R, E),
                                    _ !== null)
                                        return zs(_, h, E),
                                        gu(_, d, E),
                                        !0
                                }
                                return !1
                            }
                            function ao(h, d, _, E) {
                                if (E = {
                                    lane: 2,
                                    revertLane: De(),
                                    action: E,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                },
                                La(h)) {
                                    if (d)
                                        throw Error(a(479))
                                } else
                                    d = ge(h, _, E, 2),
                                    d !== null && zs(d, h, 2)
                            }
                            function La(h) {
                                var d = h.alternate;
                                return h === $t || d !== null && d === $t
                            }
                            function ca(h, d) {
                                di = gr = !0;
                                var _ = h.pending;
                                _ === null ? d.next = d : (d.next = _.next,
                                _.next = d),
                                h.pending = d
                            }
                            function gu(h, d, _) {
                                if ((_ & 4194176) !== 0) {
                                    var E = d.lanes;
                                    E &= h.pendingLanes,
                                    _ |= E,
                                    d.lanes = _,
                                    oe(h, _)
                                }
                            }
                            function Wi(h, d, _, E) {
                                d = h.memoizedState,
                                _ = _(E, d),
                                _ = _ == null ? d : Uc({}, d, _),
                                h.memoizedState = _,
                                h.lanes === 0 && (h.updateQueue.baseState = _)
                            }
                            function ur(h, d, _, E, R, P, ne) {
                                return h = h.stateNode,
                                typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(E, P, ne) : d.prototype && d.prototype.isPureReactComponent ? !xt(_, E) || !xt(R, P) : !0
                            }
                            function Br(h, d, _, E) {
                                h = d.state,
                                typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(_, E),
                                typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(_, E),
                                d.state !== h && Kd.enqueueReplaceState(d, d.state, null)
                            }
                            function ua(h, d) {
                                var _ = d;
                                if ("ref"in d) {
                                    _ = {};
                                    for (var E in d)
                                        E !== "ref" && (_[E] = d[E])
                                }
                                if (h = h.defaultProps) {
                                    _ === d && (_ = Uc({}, _));
                                    for (var R in h)
                                        _[R] === void 0 && (_[R] = h[R])
                                }
                                return _
                            }
                            function ro(h, d) {
                                try {
                                    var _ = h.onUncaughtError;
                                    _(d.value, {
                                        componentStack: d.stack
                                    })
                                } catch (E) {
                                    setTimeout(function() {
                                        throw E
                                    })
                                }
                            }
                            function El(h, d, _) {
                                try {
                                    var E = h.onCaughtError;
                                    E(_.value, {
                                        componentStack: _.stack,
                                        errorBoundary: d.tag === 1 ? d.stateNode : null
                                    })
                                } catch (R) {
                                    setTimeout(function() {
                                        throw R
                                    })
                                }
                            }
                            function ts(h, d, _) {
                                return _ = Je(_),
                                _.tag = 3,
                                _.payload = {
                                    element: null
                                },
                                _.callback = function() {
                                    ro(h, d)
                                }
                                ,
                                _
                            }
                            function Cl(h) {
                                return h = Je(h),
                                h.tag = 3,
                                h
                            }
                            function oo(h, d, _, E) {
                                var R = _.type.getDerivedStateFromError;
                                if (typeof R == "function") {
                                    var P = E.value;
                                    h.payload = function() {
                                        return R(P)
                                    }
                                    ,
                                    h.callback = function() {
                                        El(d, _, E)
                                    }
                                }
                                var ne = _.stateNode;
                                ne !== null && typeof ne.componentDidCatch == "function" && (h.callback = function() {
                                    El(d, _, E),
                                    typeof R != "function" && (Ja === null ? Ja = new Set([this]) : Ja.add(this));
                                    var me = E.stack;
                                    this.componentDidCatch(E.value, {
                                        componentStack: me !== null ? me : ""
                                    })
                                }
                                )
                            }
                            function xc(h, d, _, E, R) {
                                if (_.flags |= 32768,
                                E !== null && typeof E == "object" && typeof E.then == "function") {
                                    if (d = _.alternate,
                                    d !== null && Ac(d, _, R, !0),
                                    _ = ja.current,
                                    _ !== null) {
                                        switch (_.tag) {
                                        case 13:
                                            return vr === null ? da() : _.alternate === null && xn === 0 && (xn = 3),
                                            _.flags &= -257,
                                            _.flags |= 65536,
                                            _.lanes = R,
                                            E === Qd ? _.flags |= 16384 : (d = _.updateQueue,
                                            d === null ? _.updateQueue = new Set([E]) : d.add(E),
                                            wd(h, E, R)),
                                            !1;
                                        case 22:
                                            return _.flags |= 65536,
                                            E === Qd ? _.flags |= 16384 : (d = _.updateQueue,
                                            d === null ? (d = {
                                                transitions: null,
                                                markerInstances: null,
                                                retryQueue: new Set([E])
                                            },
                                            _.updateQueue = d) : (_ = d.retryQueue,
                                            _ === null ? d.retryQueue = new Set([E]) : _.add(E)),
                                            wd(h, E, R)),
                                            !1
                                        }
                                        throw Error(a(435, _.tag))
                                    }
                                    return wd(h, E, R),
                                    da(),
                                    !1
                                }
                                if (En)
                                    return d = ja.current,
                                    d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256),
                                    d.flags |= 65536,
                                    d.lanes = R,
                                    E !== tf && (h = Error(a(422), {
                                        cause: E
                                    }),
                                    he(j(h, _)))) : (E !== tf && (d = Error(a(423), {
                                        cause: E
                                    }),
                                    he(j(d, _))),
                                    h = h.current.alternate,
                                    h.flags |= 65536,
                                    R &= -R,
                                    h.lanes |= R,
                                    E = j(E, _),
                                    R = ts(h.stateNode, E, R),
                                    lt(h, R),
                                    xn !== 4 && (xn = 2)),
                                    !1;
                                var P = Error(a(520), {
                                    cause: E
                                });
                                if (P = j(P, _),
                                Yu === null ? Yu = [P] : Yu.push(P),
                                xn !== 4 && (xn = 2),
                                d === null)
                                    return !0;
                                E = j(E, _),
                                _ = d;
                                do {
                                    switch (_.tag) {
                                    case 3:
                                        return _.flags |= 65536,
                                        h = R & -R,
                                        _.lanes |= h,
                                        h = ts(_.stateNode, E, h),
                                        lt(_, h),
                                        !1;
                                    case 1:
                                        if (d = _.type,
                                        P = _.stateNode,
                                        (_.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || P !== null && typeof P.componentDidCatch == "function" && (Ja === null || !Ja.has(P))))
                                            return _.flags |= 65536,
                                            R &= -R,
                                            _.lanes |= R,
                                            R = Cl(R),
                                            oo(R, h, _, E),
                                            lt(_, R),
                                            !1
                                    }
                                    _ = _.return
                                } while (_ !== null);
                                return !1
                            }
                            function Yi(h, d, _, E) {
                                d.child = h === null ? zv(d, null, _, E) : $l(d, h.child, _, E)
                            }
                            function fd(h, d, _, E, R) {
                                _ = _.render;
                                var P = d.ref;
                                if ("ref"in E) {
                                    var ne = {};
                                    for (var me in E)
                                        me !== "ref" && (ne[me] = E[me])
                                } else
                                    ne = E;
                                return Tc(d),
                                E = lr(h, d, _, ne, P, R),
                                me = te(),
                                h !== null && !Ii ? (Se(h, d, R),
                                Io(h, d, R)) : (En && me && ie(d),
                                d.flags |= 1,
                                Yi(h, d, E, R),
                                d.child)
                            }
                            function xs(h, d, _, E, R) {
                                if (h === null) {
                                    var P = _.type;
                                    return typeof P == "function" && !Vo(P) && P.defaultProps === void 0 && _.compare === null ? (d.tag = 15,
                                    d.type = P,
                                    Is(h, d, P, E, R)) : (h = hr(_.type, null, E, d, d.mode, R),
                                    h.ref = d.ref,
                                    h.return = d,
                                    d.child = h)
                                }
                                if (P = h.child,
                                !Im(h, R)) {
                                    var ne = P.memoizedProps;
                                    if (_ = _.compare,
                                    _ = _ !== null ? _ : xt,
                                    _(ne, E) && h.ref === d.ref)
                                        return Io(h, d, R)
                                }
                                return d.flags |= 1,
                                h = Fs(P, E),
                                h.ref = d.ref,
                                h.return = d,
                                d.child = h
                            }
                            function Is(h, d, _, E, R) {
                                if (h !== null) {
                                    var P = h.memoizedProps;
                                    if (xt(P, E) && h.ref === d.ref)
                                        if (Ii = !1,
                                        d.pendingProps = E = P,
                                        Im(h, R))
                                            (h.flags & 131072) !== 0 && (Ii = !0);
                                        else
                                            return d.lanes = h.lanes,
                                            Io(h, d, R)
                                }
                                return Rm(h, d, _, E, R)
                            }
                            function As(h, d, _) {
                                var E = d.pendingProps
                                  , R = E.children
                                  , P = (d.stateNode._pendingVisibility & 2) !== 0
                                  , ne = h !== null ? h.memoizedState : null;
                                if (wl(h, d),
                                E.mode === "hidden" || P) {
                                    if ((d.flags & 128) !== 0) {
                                        if (E = ne !== null ? ne.baseLanes | _ : _,
                                        h !== null) {
                                            for (R = d.child = h.child,
                                            P = 0; R !== null; )
                                                P = P | R.lanes | R.childLanes,
                                                R = R.sibling;
                                            d.childLanes = P & ~E
                                        } else
                                            d.childLanes = 0,
                                            d.child = null;
                                        return Lr(h, d, E, _)
                                    }
                                    if ((_ & 536870912) !== 0)
                                        d.memoizedState = {
                                            baseLanes: 0,
                                            cachePool: null
                                        },
                                        h !== null && md(d, ne !== null ? ne.cachePool : null),
                                        ne !== null ? ki(d, ne) : Bs(),
                                        _s(d);
                                    else
                                        return d.lanes = d.childLanes = 536870912,
                                        Lr(h, d, ne !== null ? ne.baseLanes | _ : _, _)
                                } else
                                    ne !== null ? (md(d, ne.cachePool),
                                    ki(d, ne),
                                    ei(d),
                                    d.memoizedState = null) : (h !== null && md(d, null),
                                    Bs(),
                                    ei(d));
                                return Yi(h, d, R, _),
                                d.child
                            }
                            function Lr(h, d, _, E) {
                                var R = Ul();
                                return R = R === null ? null : {
                                    parent: mo ? Pn._currentValue : Pn._currentValue2,
                                    pool: R
                                },
                                d.memoizedState = {
                                    baseLanes: _,
                                    cachePool: R
                                },
                                h !== null && md(d, null),
                                Bs(),
                                _s(d),
                                h !== null && Ac(h, d, E, !0),
                                null
                            }
                            function wl(h, d) {
                                var _ = d.ref;
                                if (_ === null)
                                    h !== null && h.ref !== null && (d.flags |= 2097664);
                                else {
                                    if (typeof _ != "function" && typeof _ != "object")
                                        throw Error(a(284));
                                    (h === null || h.ref !== _) && (d.flags |= 2097664)
                                }
                            }
                            function Rm(h, d, _, E, R) {
                                return Tc(d),
                                _ = lr(h, d, _, E, void 0, R),
                                E = te(),
                                h !== null && !Ii ? (Se(h, d, R),
                                Io(h, d, R)) : (En && E && ie(d),
                                d.flags |= 1,
                                Yi(h, d, _, R),
                                d.child)
                            }
                            function T0(h, d, _, E, R, P) {
                                return Tc(d),
                                d.updateQueue = null,
                                _ = Sl(d, E, _, R),
                                Cr(h),
                                E = te(),
                                h !== null && !Ii ? (Se(h, d, P),
                                Io(h, d, P)) : (En && E && ie(d),
                                d.flags |= 1,
                                Yi(h, d, _, P),
                                d.child)
                            }
                            function Um(h, d, _, E, R) {
                                if (Tc(d),
                                d.stateNode === null) {
                                    var P = Ic
                                      , ne = _.contextType;
                                    typeof ne == "object" && ne !== null && (P = Ts(ne)),
                                    P = new _(E,P),
                                    d.memoizedState = P.state !== null && P.state !== void 0 ? P.state : null,
                                    P.updater = Kd,
                                    d.stateNode = P,
                                    P._reactInternals = d,
                                    P = d.stateNode,
                                    P.props = E,
                                    P.state = d.memoizedState,
                                    P.refs = {},
                                    gt(d),
                                    ne = _.contextType,
                                    P.context = typeof ne == "object" && ne !== null ? Ts(ne) : Ic,
                                    P.state = d.memoizedState,
                                    ne = _.getDerivedStateFromProps,
                                    typeof ne == "function" && (Wi(d, _, ne, E),
                                    P.state = d.memoizedState),
                                    typeof _.getDerivedStateFromProps == "function" || typeof P.getSnapshotBeforeUpdate == "function" || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (ne = P.state,
                                    typeof P.componentWillMount == "function" && P.componentWillMount(),
                                    typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount(),
                                    ne !== P.state && Kd.enqueueReplaceState(P, P.state, null),
                                    fe(d, E, P, R),
                                    At(),
                                    P.state = d.memoizedState),
                                    typeof P.componentDidMount == "function" && (d.flags |= 4194308),
                                    E = !0
                                } else if (h === null) {
                                    P = d.stateNode;
                                    var me = d.memoizedProps
                                      , Ce = ua(_, me);
                                    P.props = Ce;
                                    var et = P.context
                                      , mt = _.contextType;
                                    ne = Ic,
                                    typeof mt == "object" && mt !== null && (ne = Ts(mt));
                                    var Tt = _.getDerivedStateFromProps;
                                    mt = typeof Tt == "function" || typeof P.getSnapshotBeforeUpdate == "function",
                                    me = d.pendingProps !== me,
                                    mt || typeof P.UNSAFE_componentWillReceiveProps != "function" && typeof P.componentWillReceiveProps != "function" || (me || et !== ne) && Br(d, P, E, ne),
                                    Zo = !1;
                                    var bt = d.memoizedState;
                                    P.state = bt,
                                    fe(d, E, P, R),
                                    At(),
                                    et = d.memoizedState,
                                    me || bt !== et || Zo ? (typeof Tt == "function" && (Wi(d, _, Tt, E),
                                    et = d.memoizedState),
                                    (Ce = Zo || ur(d, _, Ce, E, bt, et, ne)) ? (mt || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (typeof P.componentWillMount == "function" && P.componentWillMount(),
                                    typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount()),
                                    typeof P.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof P.componentDidMount == "function" && (d.flags |= 4194308),
                                    d.memoizedProps = E,
                                    d.memoizedState = et),
                                    P.props = E,
                                    P.state = et,
                                    P.context = ne,
                                    E = Ce) : (typeof P.componentDidMount == "function" && (d.flags |= 4194308),
                                    E = !1)
                                } else {
                                    P = d.stateNode,
                                    Ie(h, d),
                                    ne = d.memoizedProps,
                                    mt = ua(_, ne),
                                    P.props = mt,
                                    Tt = d.pendingProps,
                                    bt = P.context,
                                    et = _.contextType,
                                    Ce = Ic,
                                    typeof et == "object" && et !== null && (Ce = Ts(et)),
                                    me = _.getDerivedStateFromProps,
                                    (et = typeof me == "function" || typeof P.getSnapshotBeforeUpdate == "function") || typeof P.UNSAFE_componentWillReceiveProps != "function" && typeof P.componentWillReceiveProps != "function" || (ne !== Tt || bt !== Ce) && Br(d, P, E, Ce),
                                    Zo = !1,
                                    bt = d.memoizedState,
                                    P.state = bt,
                                    fe(d, E, P, R),
                                    At();
                                    var qt = d.memoizedState;
                                    ne !== Tt || bt !== qt || Zo || h !== null && h.dependencies !== null && Rl(h.dependencies) ? (typeof me == "function" && (Wi(d, _, me, E),
                                    qt = d.memoizedState),
                                    (mt = Zo || ur(d, _, mt, E, bt, qt, Ce) || h !== null && h.dependencies !== null && Rl(h.dependencies)) ? (et || typeof P.UNSAFE_componentWillUpdate != "function" && typeof P.componentWillUpdate != "function" || (typeof P.componentWillUpdate == "function" && P.componentWillUpdate(E, qt, Ce),
                                    typeof P.UNSAFE_componentWillUpdate == "function" && P.UNSAFE_componentWillUpdate(E, qt, Ce)),
                                    typeof P.componentDidUpdate == "function" && (d.flags |= 4),
                                    typeof P.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof P.componentDidUpdate != "function" || ne === h.memoizedProps && bt === h.memoizedState || (d.flags |= 4),
                                    typeof P.getSnapshotBeforeUpdate != "function" || ne === h.memoizedProps && bt === h.memoizedState || (d.flags |= 1024),
                                    d.memoizedProps = E,
                                    d.memoizedState = qt),
                                    P.props = E,
                                    P.state = qt,
                                    P.context = Ce,
                                    E = mt) : (typeof P.componentDidUpdate != "function" || ne === h.memoizedProps && bt === h.memoizedState || (d.flags |= 4),
                                    typeof P.getSnapshotBeforeUpdate != "function" || ne === h.memoizedProps && bt === h.memoizedState || (d.flags |= 1024),
                                    E = !1)
                                }
                                return P = E,
                                wl(h, d),
                                E = (d.flags & 128) !== 0,
                                P || E ? (P = d.stateNode,
                                _ = E && typeof _.getDerivedStateFromError != "function" ? null : P.render(),
                                d.flags |= 1,
                                h !== null && E ? (d.child = $l(d, h.child, null, R),
                                d.child = $l(d, null, _, R)) : Yi(h, d, _, R),
                                d.memoizedState = P.state,
                                h = d.child) : h = Io(h, d, R),
                                h
                            }
                            function M0(h, d, _, E) {
                                return Le(),
                                d.flags |= 256,
                                Yi(h, d, _, E),
                                d.child
                            }
                            function Om(h) {
                                return {
                                    baseLanes: h,
                                    cachePool: D0()
                                }
                            }
                            function Nm(h, d, _) {
                                return h = h !== null ? h.childLanes & ~_ : 0,
                                d && (h |= Sa),
                                h
                            }
                            function b0(h, d, _) {
                                var E = d.pendingProps, R = !1, P = (d.flags & 128) !== 0, ne;
                                if ((ne = P) || (ne = h !== null && h.memoizedState === null ? !1 : (ji.current & 2) !== 0),
                                ne && (R = !0,
                                d.flags &= -129),
                                ne = (d.flags & 32) !== 0,
                                d.flags &= -33,
                                h === null) {
                                    if (En) {
                                        if (R ? Ai(d) : ei(d),
                                        En) {
                                            var me = ws, Ce;
                                            (Ce = me) && (me = ey(me, pr),
                                            me !== null ? (d.memoizedState = {
                                                dehydrated: me,
                                                treeContext: Hr !== null ? {
                                                    id: yo,
                                                    overflow: dr
                                                } : null,
                                                retryLane: 536870912
                                            },
                                            Ce = i(18, null, null, 0),
                                            Ce.stateNode = me,
                                            Ce.return = d,
                                            d.child = Ce,
                                            Gs = d,
                                            ws = null,
                                            Ce = !0) : Ce = !1),
                                            Ce || qe(d)
                                        }
                                        if (me = d.memoizedState,
                                        me !== null && (me = me.dehydrated,
                                        me !== null))
                                            return qh(me) ? d.lanes = 16 : d.lanes = 536870912,
                                            null;
                                        ti(d)
                                    }
                                    return me = E.children,
                                    E = E.fallback,
                                    R ? (ei(d),
                                    R = d.mode,
                                    me = Bm({
                                        mode: "hidden",
                                        children: me
                                    }, R),
                                    E = Xo(E, R, _, null),
                                    me.return = d,
                                    E.return = d,
                                    me.sibling = E,
                                    d.child = me,
                                    R = d.child,
                                    R.memoizedState = Om(_),
                                    R.childLanes = Nm(h, ne, _),
                                    d.memoizedState = ks,
                                    E) : (Ai(d),
                                    wh(d, me))
                                }
                                if (Ce = h.memoizedState,
                                Ce !== null && (me = Ce.dehydrated,
                                me !== null)) {
                                    if (P)
                                        d.flags & 256 ? (Ai(d),
                                        d.flags &= -257,
                                        d = Lm(h, d, _)) : d.memoizedState !== null ? (ei(d),
                                        d.child = h.child,
                                        d.flags |= 128,
                                        d = null) : (ei(d),
                                        R = E.fallback,
                                        me = d.mode,
                                        E = Bm({
                                            mode: "visible",
                                            children: E.children
                                        }, me),
                                        R = Xo(R, me, _, null),
                                        R.flags |= 2,
                                        E.return = d,
                                        R.return = d,
                                        E.sibling = R,
                                        d.child = E,
                                        $l(d, h.child, null, _),
                                        E = d.child,
                                        E.memoizedState = Om(_),
                                        E.childLanes = Nm(h, ne, _),
                                        d.memoizedState = ks,
                                        d = R);
                                    else if (Ai(d),
                                    qh(me))
                                        ne = q0(me).digest,
                                        E = Error(a(419)),
                                        E.stack = "",
                                        E.digest = ne,
                                        he({
                                            value: E,
                                            source: null,
                                            stack: null
                                        }),
                                        d = Lm(h, d, _);
                                    else if (Ii || Ac(h, d, _, !1),
                                    ne = (_ & h.childLanes) !== 0,
                                    Ii || ne) {
                                        if (ne = cn,
                                        ne !== null) {
                                            if (E = _ & -_,
                                            (E & 42) !== 0)
                                                E = 1;
                                            else
                                                switch (E) {
                                                case 2:
                                                    E = 1;
                                                    break;
                                                case 8:
                                                    E = 4;
                                                    break;
                                                case 32:
                                                    E = 16;
                                                    break;
                                                case 128:
                                                case 256:
                                                case 512:
                                                case 1024:
                                                case 2048:
                                                case 4096:
                                                case 8192:
                                                case 16384:
                                                case 32768:
                                                case 65536:
                                                case 131072:
                                                case 262144:
                                                case 524288:
                                                case 1048576:
                                                case 2097152:
                                                case 4194304:
                                                case 8388608:
                                                case 16777216:
                                                case 33554432:
                                                    E = 64;
                                                    break;
                                                case 268435456:
                                                    E = 134217728;
                                                    break;
                                                default:
                                                    E = 0
                                                }
                                            if (E = (E & (ne.suspendedLanes | _)) !== 0 ? 0 : E,
                                            E !== 0 && E !== Ce.retryLane)
                                                throw Ce.retryLane = E,
                                                Te(h, E),
                                                zs(ne, h, E),
                                                my
                                        }
                                        Hd(me) || da(),
                                        d = Lm(h, d, _)
                                    } else
                                        Hd(me) ? (d.flags |= 128,
                                        d.child = h.child,
                                        d = Dc.bind(null, h),
                                        Rx(me, d),
                                        d = null) : (h = Ce.treeContext,
                                        Js && (ws = K0(me),
                                        Gs = d,
                                        En = !0,
                                        Wa = null,
                                        pr = !1,
                                        h !== null && (ka[Xa++] = yo,
                                        ka[Xa++] = dr,
                                        ka[Xa++] = Hr,
                                        yo = h.id,
                                        dr = h.overflow,
                                        Hr = d)),
                                        d = wh(d, E.children),
                                        d.flags |= 4096);
                                    return d
                                }
                                return R ? (ei(d),
                                R = E.fallback,
                                me = d.mode,
                                Ce = h.child,
                                P = Ce.sibling,
                                E = Fs(Ce, {
                                    mode: "hidden",
                                    children: E.children
                                }),
                                E.subtreeFlags = Ce.subtreeFlags & 31457280,
                                P !== null ? R = Fs(P, R) : (R = Xo(R, me, _, null),
                                R.flags |= 2),
                                R.return = d,
                                E.return = d,
                                E.sibling = R,
                                d.child = E,
                                E = R,
                                R = d.child,
                                me = h.child.memoizedState,
                                me === null ? me = Om(_) : (Ce = me.cachePool,
                                Ce !== null ? (P = mo ? Pn._currentValue : Pn._currentValue2,
                                Ce = Ce.parent !== P ? {
                                    parent: P,
                                    pool: P
                                } : Ce) : Ce = D0(),
                                me = {
                                    baseLanes: me.baseLanes | _,
                                    cachePool: Ce
                                }),
                                R.memoizedState = me,
                                R.childLanes = Nm(h, ne, _),
                                d.memoizedState = ks,
                                E) : (Ai(d),
                                _ = h.child,
                                h = _.sibling,
                                _ = Fs(_, {
                                    mode: "visible",
                                    children: E.children
                                }),
                                _.return = d,
                                _.sibling = null,
                                h !== null && (ne = d.deletions,
                                ne === null ? (d.deletions = [h],
                                d.flags |= 16) : ne.push(h)),
                                d.child = _,
                                d.memoizedState = null,
                                _)
                            }
                            function wh(h, d) {
                                return d = Bm({
                                    mode: "visible",
                                    children: d
                                }, h.mode),
                                d.return = h,
                                h.child = d
                            }
                            function Bm(h, d) {
                                return Dd(h, d, 0, null)
                            }
                            function Lm(h, d, _) {
                                return $l(d, h.child, null, _),
                                h = wh(d, d.pendingProps.children),
                                h.flags |= 2,
                                d.memoizedState = null,
                                h
                            }
                            function E0(h, d, _) {
                                h.lanes |= d;
                                var E = h.alternate;
                                E !== null && (E.lanes |= d),
                                Pm(h.return, d, _)
                            }
                            function dd(h, d, _, E, R) {
                                var P = h.memoizedState;
                                P === null ? h.memoizedState = {
                                    isBackwards: d,
                                    rendering: null,
                                    renderingStartTime: 0,
                                    last: E,
                                    tail: _,
                                    tailMode: R
                                } : (P.isBackwards = d,
                                P.rendering = null,
                                P.renderingStartTime = 0,
                                P.last = E,
                                P.tail = _,
                                P.tailMode = R)
                            }
                            function C0(h, d, _) {
                                var E = d.pendingProps
                                  , R = E.revealOrder
                                  , P = E.tail;
                                if (Yi(h, d, E.children, _),
                                E = ji.current,
                                (E & 2) !== 0)
                                    E = E & 1 | 2,
                                    d.flags |= 128;
                                else {
                                    if (h !== null && (h.flags & 128) !== 0)
                                        e: for (h = d.child; h !== null; ) {
                                            if (h.tag === 13)
                                                h.memoizedState !== null && E0(h, _, d);
                                            else if (h.tag === 19)
                                                E0(h, _, d);
                                            else if (h.child !== null) {
                                                h.child.return = h,
                                                h = h.child;
                                                continue
                                            }
                                            if (h === d)
                                                break e;
                                            for (; h.sibling === null; ) {
                                                if (h.return === null || h.return === d)
                                                    break e;
                                                h = h.return
                                            }
                                            h.sibling.return = h.return,
                                            h = h.sibling
                                        }
                                    E &= 1
                                }
                                switch (w(ji, E),
                                R) {
                                case "forwards":
                                    for (_ = d.child,
                                    R = null; _ !== null; )
                                        h = _.alternate,
                                        h !== null && Oi(h) === null && (R = _),
                                        _ = _.sibling;
                                    _ = R,
                                    _ === null ? (R = d.child,
                                    d.child = null) : (R = _.sibling,
                                    _.sibling = null),
                                    dd(d, !1, R, _, P);
                                    break;
                                case "backwards":
                                    for (_ = null,
                                    R = d.child,
                                    d.child = null; R !== null; ) {
                                        if (h = R.alternate,
                                        h !== null && Oi(h) === null) {
                                            d.child = R;
                                            break
                                        }
                                        h = R.sibling,
                                        R.sibling = _,
                                        _ = R,
                                        R = h
                                    }
                                    dd(d, !0, _, null, P);
                                    break;
                                case "together":
                                    dd(d, !1, null, null, void 0);
                                    break;
                                default:
                                    d.memoizedState = null
                                }
                                return d.child
                            }
                            function Io(h, d, _) {
                                if (h !== null && (d.dependencies = h.dependencies),
                                Za |= d.lanes,
                                (_ & d.childLanes) === 0)
                                    if (h !== null) {
                                        if (Ac(h, d, _, !1),
                                        (_ & d.childLanes) === 0)
                                            return null
                                    } else
                                        return null;
                                if (h !== null && d.child !== h.child)
                                    throw Error(a(153));
                                if (d.child !== null) {
                                    for (h = d.child,
                                    _ = Fs(h, h.pendingProps),
                                    d.child = _,
                                    _.return = d; h.sibling !== null; )
                                        h = h.sibling,
                                        _ = _.sibling = Fs(h, h.pendingProps),
                                        _.return = d;
                                    _.sibling = null
                                }
                                return d.child
                            }
                            function Im(h, d) {
                                return (h.lanes & d) !== 0 ? !0 : (h = h.dependencies,
                                !!(h !== null && Rl(h)))
                            }
                            function Cx(h, d, _) {
                                switch (d.tag) {
                                case 3:
                                    K(d, d.stateNode.containerInfo),
                                    Dl(d, Pn, h.memoizedState.cache),
                                    Le();
                                    break;
                                case 27:
                                case 5:
                                    ue(d);
                                    break;
                                case 4:
                                    K(d, d.stateNode.containerInfo);
                                    break;
                                case 10:
                                    Dl(d, d.type, d.memoizedProps.value);
                                    break;
                                case 13:
                                    var E = d.memoizedState;
                                    if (E !== null)
                                        return E.dehydrated !== null ? (Ai(d),
                                        d.flags |= 128,
                                        null) : (_ & d.child.childLanes) !== 0 ? b0(h, d, _) : (Ai(d),
                                        h = Io(h, d, _),
                                        h !== null ? h.sibling : null);
                                    Ai(d);
                                    break;
                                case 19:
                                    var R = (h.flags & 128) !== 0;
                                    if (E = (_ & d.childLanes) !== 0,
                                    E || (Ac(h, d, _, !1),
                                    E = (_ & d.childLanes) !== 0),
                                    R) {
                                        if (E)
                                            return C0(h, d, _);
                                        d.flags |= 128
                                    }
                                    if (R = d.memoizedState,
                                    R !== null && (R.rendering = null,
                                    R.tail = null,
                                    R.lastEffect = null),
                                    w(ji, ji.current),
                                    E)
                                        break;
                                    return null;
                                case 22:
                                case 23:
                                    return d.lanes = 0,
                                    As(h, d, _);
                                case 24:
                                    Dl(d, Pn, h.memoizedState.cache)
                                }
                                return Io(h, d, _)
                            }
                            function w0(h, d, _) {
                                if (h !== null)
                                    if (h.memoizedProps !== d.pendingProps)
                                        Ii = !0;
                                    else {
                                        if (!Im(h, _) && (d.flags & 128) === 0)
                                            return Ii = !1,
                                            Cx(h, d, _);
                                        Ii = (h.flags & 131072) !== 0
                                    }
                                else
                                    Ii = !1,
                                    En && (d.flags & 1048576) !== 0 && H(d, $h, d.index);
                                switch (d.lanes = 0,
                                d.tag) {
                                case 16:
                                    e: {
                                        h = d.pendingProps;
                                        var E = d.elementType
                                          , R = E._init;
                                        if (E = R(E._payload),
                                        d.type = E,
                                        typeof E == "function")
                                            Vo(E) ? (h = ua(E, h),
                                            d.tag = 1,
                                            d = Um(null, d, E, h, _)) : (d.tag = 0,
                                            d = Rm(null, d, E, h, _));
                                        else {
                                            if (E != null) {
                                                if (R = E.$$typeof,
                                                R === Nu) {
                                                    d.tag = 11,
                                                    d = fd(null, d, E, h, _);
                                                    break e
                                                } else if (R === Fh) {
                                                    d.tag = 14,
                                                    d = xs(null, d, E, h, _);
                                                    break e
                                                }
                                            }
                                            throw d = c(E) || E,
                                            Error(a(306, d, ""))
                                        }
                                    }
                                    return d;
                                case 0:
                                    return Rm(h, d, d.type, d.pendingProps, _);
                                case 1:
                                    return E = d.type,
                                    R = ua(E, d.pendingProps),
                                    Um(h, d, E, R, _);
                                case 3:
                                    e: {
                                        if (K(d, d.stateNode.containerInfo),
                                        h === null)
                                            throw Error(a(387));
                                        var P = d.pendingProps;
                                        R = d.memoizedState,
                                        E = R.element,
                                        Ie(h, d),
                                        fe(d, P, null, _);
                                        var ne = d.memoizedState;
                                        if (P = ne.cache,
                                        Dl(d, Pn, P),
                                        P !== R.cache && zm(d, [Pn], _, !0),
                                        At(),
                                        P = ne.element,
                                        Js && R.isDehydrated)
                                            if (R = {
                                                element: P,
                                                isDehydrated: !1,
                                                cache: ne.cache
                                            },
                                            d.updateQueue.baseState = R,
                                            d.memoizedState = R,
                                            d.flags & 256) {
                                                d = M0(h, d, P, _);
                                                break e
                                            } else if (P !== E) {
                                                E = j(Error(a(424)), d),
                                                he(E),
                                                d = M0(h, d, P, _);
                                                break e
                                            } else
                                                for (Js && (ws = Z0(d.stateNode.containerInfo),
                                                Gs = d,
                                                En = !0,
                                                Wa = null,
                                                pr = !0),
                                                _ = zv(d, null, P, _),
                                                d.child = _; _; )
                                                    _.flags = _.flags & -3 | 4096,
                                                    _ = _.sibling;
                                        else {
                                            if (Le(),
                                            P === E) {
                                                d = Io(h, d, _);
                                                break e
                                            }
                                            Yi(h, d, P, _)
                                        }
                                        d = d.child
                                    }
                                    return d;
                                case 26:
                                    if (Ga)
                                        return wl(h, d),
                                        h === null ? (_ = Wd(d.type, null, d.pendingProps, null)) ? d.memoizedState = _ : En || (d.stateNode = Ox(d.type, d.pendingProps, Gr.current, d)) : d.memoizedState = Wd(d.type, h.memoizedProps, d.pendingProps, h.memoizedState),
                                        null;
                                case 27:
                                    if (Es)
                                        return ue(d),
                                        h === null && Es && En && (E = d.stateNode = Bv(d.type, d.pendingProps, Gr.current, ds.current, !1),
                                        Gs = d,
                                        pr = !0,
                                        ws = Gd(E)),
                                        E = d.pendingProps.children,
                                        h !== null || En ? Yi(h, d, E, _) : d.child = $l(d, null, E, _),
                                        wl(h, d),
                                        d.child;
                                case 5:
                                    return h === null && En && (ay(d.type, d.pendingProps, ds.current),
                                    (R = E = ws) && (E = J0(E, d.type, d.pendingProps, pr),
                                    E !== null ? (d.stateNode = E,
                                    Gs = d,
                                    ws = Gd(E),
                                    pr = !1,
                                    R = !0) : R = !1),
                                    R || qe(d)),
                                    ue(d),
                                    R = d.type,
                                    P = d.pendingProps,
                                    ne = h !== null ? h.memoizedProps : null,
                                    E = P.children,
                                    jl(R, P) ? E = null : ne !== null && jl(R, ne) && (d.flags |= 32),
                                    d.memoizedState !== null && (R = lr(h, d, Ch, null, null, _),
                                    mo ? Vt._currentValue = R : Vt._currentValue2 = R),
                                    wl(h, d),
                                    Yi(h, d, E, _),
                                    d.child;
                                case 6:
                                    return h === null && En && (ry(d.pendingProps, ds.current),
                                    (h = _ = ws) && (_ = $0(_, d.pendingProps, pr),
                                    _ !== null ? (d.stateNode = _,
                                    Gs = d,
                                    ws = null,
                                    h = !0) : h = !1),
                                    h || qe(d)),
                                    null;
                                case 13:
                                    return b0(h, d, _);
                                case 4:
                                    return K(d, d.stateNode.containerInfo),
                                    E = d.pendingProps,
                                    h === null ? d.child = $l(d, null, E, _) : Yi(h, d, E, _),
                                    d.child;
                                case 11:
                                    return fd(h, d, d.type, d.pendingProps, _);
                                case 7:
                                    return Yi(h, d, d.pendingProps, _),
                                    d.child;
                                case 8:
                                    return Yi(h, d, d.pendingProps.children, _),
                                    d.child;
                                case 12:
                                    return Yi(h, d, d.pendingProps.children, _),
                                    d.child;
                                case 10:
                                    return E = d.pendingProps,
                                    Dl(d, d.type, E.value),
                                    Yi(h, d, E.children, _),
                                    d.child;
                                case 9:
                                    return R = d.type._context,
                                    E = d.pendingProps.children,
                                    Tc(d),
                                    R = Ts(R),
                                    E = E(R),
                                    d.flags |= 1,
                                    Yi(h, d, E, _),
                                    d.child;
                                case 14:
                                    return xs(h, d, d.type, d.pendingProps, _);
                                case 15:
                                    return Is(h, d, d.type, d.pendingProps, _);
                                case 19:
                                    return C0(h, d, _);
                                case 22:
                                    return As(h, d, _);
                                case 24:
                                    return Tc(d),
                                    E = Ts(Pn),
                                    h === null ? (R = Ul(),
                                    R === null && (R = cn,
                                    P = pd(),
                                    R.pooledCache = P,
                                    P.refCount++,
                                    P !== null && (R.pooledCacheLanes |= _),
                                    R = P),
                                    d.memoizedState = {
                                        parent: E,
                                        cache: R
                                    },
                                    gt(d),
                                    Dl(d, Pn, R)) : ((h.lanes & _) !== 0 && (Ie(h, d),
                                    fe(d, null, null, _),
                                    At()),
                                    R = h.memoizedState,
                                    P = d.memoizedState,
                                    R.parent !== E ? (R = {
                                        parent: E,
                                        cache: E
                                    },
                                    d.memoizedState = R,
                                    d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = R),
                                    Dl(d, Pn, E)) : (E = P.cache,
                                    Dl(d, Pn, E),
                                    E !== R.cache && zm(d, [Pn], _, !0))),
                                    Yi(h, d, d.pendingProps.children, _),
                                    d.child;
                                case 29:
                                    throw d.pendingProps
                                }
                                throw Error(a(156, d.tag))
                            }
                            function Dl(h, d, _) {
                                mo ? (w(ya, d._currentValue),
                                d._currentValue = _) : (w(ya, d._currentValue2),
                                d._currentValue2 = _)
                            }
                            function Po(h) {
                                var d = ya.current;
                                mo ? h._currentValue = d : h._currentValue2 = d,
                                D(ya)
                            }
                            function Pm(h, d, _) {
                                for (; h !== null; ) {
                                    var E = h.alternate;
                                    if ((h.childLanes & d) !== d ? (h.childLanes |= d,
                                    E !== null && (E.childLanes |= d)) : E !== null && (E.childLanes & d) !== d && (E.childLanes |= d),
                                    h === _)
                                        break;
                                    h = h.return
                                }
                            }
                            function zm(h, d, _, E) {
                                var R = h.child;
                                for (R !== null && (R.return = h); R !== null; ) {
                                    var P = R.dependencies;
                                    if (P !== null) {
                                        var ne = R.child;
                                        P = P.firstContext;
                                        e: for (; P !== null; ) {
                                            var me = P;
                                            P = R;
                                            for (var Ce = 0; Ce < d.length; Ce++)
                                                if (me.context === d[Ce]) {
                                                    P.lanes |= _,
                                                    me = P.alternate,
                                                    me !== null && (me.lanes |= _),
                                                    Pm(P.return, _, h),
                                                    E || (ne = null);
                                                    break e
                                                }
                                            P = me.next
                                        }
                                    } else if (R.tag === 18) {
                                        if (ne = R.return,
                                        ne === null)
                                            throw Error(a(341));
                                        ne.lanes |= _,
                                        P = ne.alternate,
                                        P !== null && (P.lanes |= _),
                                        Pm(ne, _, h),
                                        ne = null
                                    } else
                                        ne = R.child;
                                    if (ne !== null)
                                        ne.return = R;
                                    else
                                        for (ne = R; ne !== null; ) {
                                            if (ne === h) {
                                                ne = null;
                                                break
                                            }
                                            if (R = ne.sibling,
                                            R !== null) {
                                                R.return = ne.return,
                                                ne = R;
                                                break
                                            }
                                            ne = ne.return
                                        }
                                    R = ne
                                }
                            }
                            function Ac(h, d, _, E) {
                                h = null;
                                for (var R = d, P = !1; R !== null; ) {
                                    if (!P) {
                                        if ((R.flags & 524288) !== 0)
                                            P = !0;
                                        else if ((R.flags & 262144) !== 0)
                                            break
                                    }
                                    if (R.tag === 10) {
                                        var ne = R.alternate;
                                        if (ne === null)
                                            throw Error(a(387));
                                        if (ne = ne.memoizedProps,
                                        ne !== null) {
                                            var me = R.type;
                                            Va(R.pendingProps.value, ne.value) || (h !== null ? h.push(me) : h = [me])
                                        }
                                    } else if (R === Hu.current) {
                                        if (ne = R.alternate,
                                        ne === null)
                                            throw Error(a(387));
                                        ne.memoizedState.memoizedState !== R.memoizedState.memoizedState && (h !== null ? h.push(Vt) : h = [Vt])
                                    }
                                    R = R.return
                                }
                                h !== null && zm(d, h, _, E),
                                d.flags |= 262144
                            }
                            function Rl(h) {
                                for (h = h.firstContext; h !== null; ) {
                                    var d = h.context;
                                    if (!Va(mo ? d._currentValue : d._currentValue2, h.memoizedValue))
                                        return !0;
                                    h = h.next
                                }
                                return !1
                            }
                            function Tc(h) {
                                tc = h,
                                wi = null,
                                h = h.dependencies,
                                h !== null && (h.firstContext = null)
                            }
                            function Ts(h) {
                                return Fm(tc, h)
                            }
                            function Dh(h, d) {
                                return tc === null && Tc(h),
                                Fm(h, d)
                            }
                            function Fm(h, d) {
                                var _ = mo ? d._currentValue : d._currentValue2;
                                if (d = {
                                    context: d,
                                    memoizedValue: _,
                                    next: null
                                },
                                wi === null) {
                                    if (h === null)
                                        throw Error(a(308));
                                    wi = d,
                                    h.dependencies = {
                                        lanes: 0,
                                        firstContext: d
                                    },
                                    h.flags |= 524288
                                } else
                                    wi = wi.next = d;
                                return _
                            }
                            function pd() {
                                return {
                                    controller: new vy,
                                    data: new Map,
                                    refCount: 0
                                }
                            }
                            function yu(h) {
                                h.refCount--,
                                h.refCount === 0 && Jo(Fc, function() {
                                    h.controller.abort()
                                })
                            }
                            function Ul() {
                                var h = $o.current;
                                return h !== null ? h : cn.pooledCache
                            }
                            function md(h, d) {
                                d === null ? w($o, $o.current) : w($o, d.pool)
                            }
                            function D0() {
                                var h = Ul();
                                return h === null ? null : {
                                    parent: mo ? Pn._currentValue : Pn._currentValue2,
                                    pool: h
                                }
                            }
                            function Ia(h) {
                                h.flags |= 4
                            }
                            function Hm(h, d) {
                                if (h !== null && h.child === d.child)
                                    return !1;
                                if ((d.flags & 16) !== 0)
                                    return !0;
                                for (h = d.child; h !== null; ) {
                                    if ((h.flags & 13878) !== 0 || (h.subtreeFlags & 13878) !== 0)
                                        return !0;
                                    h = h.sibling
                                }
                                return !1
                            }
                            function vd(h, d, _, E) {
                                if (bs)
                                    for (_ = d.child; _ !== null; ) {
                                        if (_.tag === 5 || _.tag === 6)
                                            Yo(h, _.stateNode);
                                        else if (!(_.tag === 4 || Es && _.tag === 27) && _.child !== null) {
                                            _.child.return = _,
                                            _ = _.child;
                                            continue
                                        }
                                        if (_ === d)
                                            break;
                                        for (; _.sibling === null; ) {
                                            if (_.return === null || _.return === d)
                                                return;
                                            _ = _.return
                                        }
                                        _.sibling.return = _.return,
                                        _ = _.sibling
                                    }
                                else if (Fa)
                                    for (var R = d.child; R !== null; ) {
                                        if (R.tag === 5) {
                                            var P = R.stateNode;
                                            _ && E && (P = xv(P, R.type, R.memoizedProps)),
                                            Yo(h, P)
                                        } else if (R.tag === 6)
                                            P = R.stateNode,
                                            _ && E && (P = Av(P, R.memoizedProps)),
                                            Yo(h, P);
                                        else if (R.tag !== 4) {
                                            if (R.tag === 22 && R.memoizedState !== null)
                                                P = R.child,
                                                P !== null && (P.return = R),
                                                vd(h, R, !0, !0);
                                            else if (R.child !== null) {
                                                R.child.return = R,
                                                R = R.child;
                                                continue
                                            }
                                        }
                                        if (R === d)
                                            break;
                                        for (; R.sibling === null; ) {
                                            if (R.return === null || R.return === d)
                                                return;
                                            R = R.return
                                        }
                                        R.sibling.return = R.return,
                                        R = R.sibling
                                    }
                            }
                            function _u(h, d, _, E) {
                                if (Fa)
                                    for (var R = d.child; R !== null; ) {
                                        if (R.tag === 5) {
                                            var P = R.stateNode;
                                            _ && E && (P = xv(P, R.type, R.memoizedProps)),
                                            _v(h, P)
                                        } else if (R.tag === 6)
                                            P = R.stateNode,
                                            _ && E && (P = Av(P, R.memoizedProps)),
                                            _v(h, P);
                                        else if (R.tag !== 4) {
                                            if (R.tag === 22 && R.memoizedState !== null)
                                                P = R.child,
                                                P !== null && (P.return = R),
                                                _u(h, R, !(R.memoizedProps !== null && R.memoizedProps.mode === "manual"), !0);
                                            else if (R.child !== null) {
                                                R.child.return = R,
                                                R = R.child;
                                                continue
                                            }
                                        }
                                        if (R === d)
                                            break;
                                        for (; R.sibling === null; ) {
                                            if (R.return === null || R.return === d)
                                                return;
                                            R = R.return
                                        }
                                        R.sibling.return = R.return,
                                        R = R.sibling
                                    }
                            }
                            function Su(h, d) {
                                if (Fa && Hm(h, d)) {
                                    h = d.stateNode;
                                    var _ = h.containerInfo
                                      , E = Fd();
                                    _u(E, d, !1, !1),
                                    h.pendingChildren = E,
                                    Ia(d),
                                    Y0(_, E)
                                }
                            }
                            function Gm(h, d, _, E) {
                                if (bs)
                                    h.memoizedProps !== E && Ia(d);
                                else if (Fa) {
                                    var R = h.stateNode
                                      , P = h.memoizedProps;
                                    if ((h = Hm(h, d)) || P !== E) {
                                        var ne = ds.current;
                                        P = yv(R, _, P, E, !h, null),
                                        P === R ? d.stateNode = R : (ql(P, _, E, ne) && Ia(d),
                                        d.stateNode = P,
                                        h ? vd(P, d, !1, !1) : Ia(d))
                                    } else
                                        d.stateNode = R
                                }
                            }
                            function xu(h, d, _) {
                                if (k0(d, _)) {
                                    if (h.flags |= 16777216,
                                    !qo(d, _))
                                        if (Lh())
                                            h.flags |= 8192;
                                        else
                                            throw zc = Qd,
                                            Pv
                                } else
                                    h.flags &= -16777217
                            }
                            function Vm(h, d) {
                                if (oy(d)) {
                                    if (h.flags |= 16777216,
                                    !Ov(d))
                                        if (Lh())
                                            h.flags |= 8192;
                                        else
                                            throw zc = Qd,
                                            Pv
                                } else
                                    h.flags &= -16777217
                            }
                            function Rh(h, d) {
                                d !== null && (h.flags |= 4),
                                h.flags & 16384 && (d = h.tag !== 22 ? B() : 536870912,
                                h.lanes |= d,
                                tl |= d)
                            }
                            function Mc(h, d) {
                                if (!En)
                                    switch (h.tailMode) {
                                    case "hidden":
                                        d = h.tail;
                                        for (var _ = null; d !== null; )
                                            d.alternate !== null && (_ = d),
                                            d = d.sibling;
                                        _ === null ? h.tail = null : _.sibling = null;
                                        break;
                                    case "collapsed":
                                        _ = h.tail;
                                        for (var E = null; _ !== null; )
                                            _.alternate !== null && (E = _),
                                            _ = _.sibling;
                                        E === null ? d || h.tail === null ? h.tail = null : h.tail.sibling = null : E.sibling = null
                                    }
                            }
                            function ui(h) {
                                var d = h.alternate !== null && h.alternate.child === h.child
                                  , _ = 0
                                  , E = 0;
                                if (d)
                                    for (var R = h.child; R !== null; )
                                        _ |= R.lanes | R.childLanes,
                                        E |= R.subtreeFlags & 31457280,
                                        E |= R.flags & 31457280,
                                        R.return = h,
                                        R = R.sibling;
                                else
                                    for (R = h.child; R !== null; )
                                        _ |= R.lanes | R.childLanes,
                                        E |= R.subtreeFlags,
                                        E |= R.flags,
                                        R.return = h,
                                        R = R.sibling;
                                return h.subtreeFlags |= E,
                                h.childLanes = _,
                                d
                            }
                            function R0(h, d, _) {
                                var E = d.pendingProps;
                                switch (se(d),
                                d.tag) {
                                case 16:
                                case 15:
                                case 0:
                                case 11:
                                case 7:
                                case 8:
                                case 12:
                                case 9:
                                case 14:
                                    return ui(d),
                                    null;
                                case 1:
                                    return ui(d),
                                    null;
                                case 3:
                                    return _ = d.stateNode,
                                    E = null,
                                    h !== null && (E = h.memoizedState.cache),
                                    d.memoizedState.cache !== E && (d.flags |= 2048),
                                    Po(Pn),
                                    le(),
                                    _.pendingContext && (_.context = _.pendingContext,
                                    _.pendingContext = null),
                                    (h === null || h.child === null) && (re(d) ? Ia(d) : h === null || h.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024,
                                    Wa !== null && (Fo(Wa),
                                    Wa = null))),
                                    Su(h, d),
                                    ui(d),
                                    null;
                                case 26:
                                    if (Ga) {
                                        _ = d.type;
                                        var R = d.memoizedState;
                                        return h === null ? (Ia(d),
                                        R !== null ? (ui(d),
                                        Vm(d, R)) : (ui(d),
                                        xu(d, _, E))) : R ? R !== h.memoizedState ? (Ia(d),
                                        ui(d),
                                        Vm(d, R)) : (ui(d),
                                        d.flags &= -16777217) : (bs ? h.memoizedProps !== E && Ia(d) : Gm(h, d, _, E),
                                        ui(d),
                                        xu(d, _, E)),
                                        null
                                    }
                                case 27:
                                    if (Es) {
                                        if (de(d),
                                        _ = Gr.current,
                                        R = d.type,
                                        h !== null && d.stateNode != null)
                                            bs ? h.memoizedProps !== E && Ia(d) : Gm(h, d, R, E);
                                        else {
                                            if (!E) {
                                                if (d.stateNode === null)
                                                    throw Error(a(166));
                                                return ui(d),
                                                null
                                            }
                                            h = ds.current,
                                            re(d) ? ze(d, h) : (h = Bv(R, E, _, h, !0),
                                            d.stateNode = h,
                                            Ia(d))
                                        }
                                        return ui(d),
                                        null
                                    }
                                case 5:
                                    if (de(d),
                                    _ = d.type,
                                    h !== null && d.stateNode != null)
                                        Gm(h, d, _, E);
                                    else {
                                        if (!E) {
                                            if (d.stateNode === null)
                                                throw Error(a(166));
                                            return ui(d),
                                            null
                                        }
                                        h = ds.current,
                                        re(d) ? ze(d, h) : (R = ov(_, E, Gr.current, h, d),
                                        vd(R, d, !1, !1),
                                        d.stateNode = R,
                                        ql(R, _, E, h) && Ia(d))
                                    }
                                    return ui(d),
                                    xu(d, d.type, d.pendingProps),
                                    null;
                                case 6:
                                    if (h && d.stateNode != null)
                                        _ = h.memoizedProps,
                                        bs ? _ !== E && Ia(d) : Fa && (_ !== E ? (d.stateNode = Nd(E, Gr.current, ds.current, d),
                                        Ia(d)) : d.stateNode = h.stateNode);
                                    else {
                                        if (typeof E != "string" && d.stateNode === null)
                                            throw Error(a(166));
                                        if (h = Gr.current,
                                        _ = ds.current,
                                        re(d)) {
                                            if (!Js)
                                                throw Error(a(176));
                                            if (h = d.stateNode,
                                            _ = d.memoizedProps,
                                            E = null,
                                            R = Gs,
                                            R !== null)
                                                switch (R.tag) {
                                                case 27:
                                                case 5:
                                                    E = R.memoizedProps
                                                }
                                            ty(h, _, d, E) || qe(d)
                                        } else
                                            d.stateNode = Nd(E, h, _, d)
                                    }
                                    return ui(d),
                                    null;
                                case 13:
                                    if (E = d.memoizedState,
                                    h === null || h.memoizedState !== null && h.memoizedState.dehydrated !== null) {
                                        if (R = re(d),
                                        E !== null && E.dehydrated !== null) {
                                            if (h === null) {
                                                if (!R)
                                                    throw Error(a(318));
                                                if (!Js)
                                                    throw Error(a(344));
                                                if (R = d.memoizedState,
                                                R = R !== null ? R.dehydrated : null,
                                                !R)
                                                    throw Error(a(317));
                                                Lu(R, d)
                                            } else
                                                Le(),
                                                (d.flags & 128) === 0 && (d.memoizedState = null),
                                                d.flags |= 4;
                                            ui(d),
                                            R = !1
                                        } else
                                            Wa !== null && (Fo(Wa),
                                            Wa = null),
                                            R = !0;
                                        if (!R)
                                            return d.flags & 256 ? (ti(d),
                                            d) : (ti(d),
                                            null)
                                    }
                                    if (ti(d),
                                    (d.flags & 128) !== 0)
                                        return d.lanes = _,
                                        d;
                                    if (_ = E !== null,
                                    h = h !== null && h.memoizedState !== null,
                                    _) {
                                        E = d.child,
                                        R = null,
                                        E.alternate !== null && E.alternate.memoizedState !== null && E.alternate.memoizedState.cachePool !== null && (R = E.alternate.memoizedState.cachePool.pool);
                                        var P = null;
                                        E.memoizedState !== null && E.memoizedState.cachePool !== null && (P = E.memoizedState.cachePool.pool),
                                        P !== R && (E.flags |= 2048)
                                    }
                                    return _ !== h && _ && (d.child.flags |= 8192),
                                    Rh(d, d.updateQueue),
                                    ui(d),
                                    null;
                                case 4:
                                    return le(),
                                    Su(h, d),
                                    h === null && uv(d.stateNode.containerInfo),
                                    ui(d),
                                    null;
                                case 10:
                                    return Po(d.type),
                                    ui(d),
                                    null;
                                case 19:
                                    if (D(ji),
                                    R = d.memoizedState,
                                    R === null)
                                        return ui(d),
                                        null;
                                    if (E = (d.flags & 128) !== 0,
                                    P = R.rendering,
                                    P === null)
                                        if (E)
                                            Mc(R, !1);
                                        else {
                                            if (xn !== 0 || h !== null && (h.flags & 128) !== 0)
                                                for (h = d.child; h !== null; ) {
                                                    if (P = Oi(h),
                                                    P !== null) {
                                                        for (d.flags |= 128,
                                                        Mc(R, !1),
                                                        h = P.updateQueue,
                                                        d.updateQueue = h,
                                                        Rh(d, h),
                                                        d.subtreeFlags = 0,
                                                        h = _,
                                                        _ = d.child; _ !== null; )
                                                            ko(_, h),
                                                            _ = _.sibling;
                                                        return w(ji, ji.current & 1 | 2),
                                                        d.child
                                                    }
                                                    h = h.sibling
                                                }
                                            R.tail !== null && Cs() > Si && (d.flags |= 128,
                                            E = !0,
                                            Mc(R, !1),
                                            d.lanes = 4194304)
                                        }
                                    else {
                                        if (!E)
                                            if (h = Oi(P),
                                            h !== null) {
                                                if (d.flags |= 128,
                                                E = !0,
                                                h = h.updateQueue,
                                                d.updateQueue = h,
                                                Rh(d, h),
                                                Mc(R, !0),
                                                R.tail === null && R.tailMode === "hidden" && !P.alternate && !En)
                                                    return ui(d),
                                                    null
                                            } else
                                                2 * Cs() - R.renderingStartTime > Si && _ !== 536870912 && (d.flags |= 128,
                                                E = !0,
                                                Mc(R, !1),
                                                d.lanes = 4194304);
                                        R.isBackwards ? (P.sibling = d.child,
                                        d.child = P) : (h = R.last,
                                        h !== null ? h.sibling = P : d.child = P,
                                        R.last = P)
                                    }
                                    return R.tail !== null ? (d = R.tail,
                                    R.rendering = d,
                                    R.tail = d.sibling,
                                    R.renderingStartTime = Cs(),
                                    d.sibling = null,
                                    h = ji.current,
                                    w(ji, E ? h & 1 | 2 : h & 1),
                                    d) : (ui(d),
                                    null);
                                case 22:
                                case 23:
                                    return ti(d),
                                    Ls(),
                                    E = d.memoizedState !== null,
                                    h !== null ? h.memoizedState !== null !== E && (d.flags |= 8192) : E && (d.flags |= 8192),
                                    E ? (_ & 536870912) !== 0 && (d.flags & 128) === 0 && (ui(d),
                                    d.subtreeFlags & 6 && (d.flags |= 8192)) : ui(d),
                                    _ = d.updateQueue,
                                    _ !== null && Rh(d, _.retryQueue),
                                    _ = null,
                                    h !== null && h.memoizedState !== null && h.memoizedState.cachePool !== null && (_ = h.memoizedState.cachePool.pool),
                                    E = null,
                                    d.memoizedState !== null && d.memoizedState.cachePool !== null && (E = d.memoizedState.cachePool.pool),
                                    E !== _ && (d.flags |= 2048),
                                    h !== null && D($o),
                                    null;
                                case 24:
                                    return _ = null,
                                    h !== null && (_ = h.memoizedState.cache),
                                    d.memoizedState.cache !== _ && (d.flags |= 2048),
                                    Po(Pn),
                                    ui(d),
                                    null;
                                case 25:
                                    return null
                                }
                                throw Error(a(156, d.tag))
                            }
                            function U0(h, d) {
                                switch (se(d),
                                d.tag) {
                                case 1:
                                    return h = d.flags,
                                    h & 65536 ? (d.flags = h & -65537 | 128,
                                    d) : null;
                                case 3:
                                    return Po(Pn),
                                    le(),
                                    h = d.flags,
                                    (h & 65536) !== 0 && (h & 128) === 0 ? (d.flags = h & -65537 | 128,
                                    d) : null;
                                case 26:
                                case 27:
                                case 5:
                                    return de(d),
                                    null;
                                case 13:
                                    if (ti(d),
                                    h = d.memoizedState,
                                    h !== null && h.dehydrated !== null) {
                                        if (d.alternate === null)
                                            throw Error(a(340));
                                        Le()
                                    }
                                    return h = d.flags,
                                    h & 65536 ? (d.flags = h & -65537 | 128,
                                    d) : null;
                                case 19:
                                    return D(ji),
                                    null;
                                case 4:
                                    return le(),
                                    null;
                                case 10:
                                    return Po(d.type),
                                    null;
                                case 22:
                                case 23:
                                    return ti(d),
                                    Ls(),
                                    h !== null && D($o),
                                    h = d.flags,
                                    h & 65536 ? (d.flags = h & -65537 | 128,
                                    d) : null;
                                case 24:
                                    return Po(Pn),
                                    null;
                                case 25:
                                    return null;
                                default:
                                    return null
                                }
                            }
                            function km(h, d) {
                                switch (se(d),
                                d.tag) {
                                case 3:
                                    Po(Pn),
                                    le();
                                    break;
                                case 26:
                                case 27:
                                case 5:
                                    de(d);
                                    break;
                                case 4:
                                    le();
                                    break;
                                case 13:
                                    ti(d);
                                    break;
                                case 19:
                                    D(ji);
                                    break;
                                case 10:
                                    Po(d.type);
                                    break;
                                case 22:
                                case 23:
                                    ti(d),
                                    Ls(),
                                    h !== null && D($o);
                                    break;
                                case 24:
                                    Po(Pn)
                                }
                            }
                            function Uh(h, d) {
                                try {
                                    var _ = d.updateQueue
                                      , E = _ !== null ? _.lastEffect : null;
                                    if (E !== null) {
                                        var R = E.next;
                                        _ = R;
                                        do {
                                            if ((_.tag & h) === h) {
                                                E = void 0;
                                                var P = _.create
                                                  , ne = _.inst;
                                                E = P(),
                                                ne.destroy = E
                                            }
                                            _ = _.next
                                        } while (_ !== R)
                                    }
                                } catch (me) {
                                    pn(d, d.return, me)
                                }
                            }
                            function Ol(h, d, _) {
                                try {
                                    var E = d.updateQueue
                                      , R = E !== null ? E.lastEffect : null;
                                    if (R !== null) {
                                        var P = R.next;
                                        E = P;
                                        do {
                                            if ((E.tag & h) === h) {
                                                var ne = E.inst
                                                  , me = ne.destroy;
                                                if (me !== void 0) {
                                                    ne.destroy = void 0,
                                                    R = d;
                                                    var Ce = _;
                                                    try {
                                                        me()
                                                    } catch (et) {
                                                        pn(R, Ce, et)
                                                    }
                                                }
                                            }
                                            E = E.next
                                        } while (E !== P)
                                    }
                                } catch (et) {
                                    pn(d, d.return, et)
                                }
                            }
                            function O0(h) {
                                var d = h.updateQueue;
                                if (d !== null) {
                                    var _ = h.stateNode;
                                    try {
                                        tt(d, _)
                                    } catch (E) {
                                        pn(h, h.return, E)
                                    }
                                }
                            }
                            function N0(h, d, _) {
                                _.props = ua(h.type, h.memoizedProps),
                                _.state = h.memoizedState;
                                try {
                                    _.componentWillUnmount()
                                } catch (E) {
                                    pn(h, d, E)
                                }
                            }
                            function bc(h, d) {
                                try {
                                    var _ = h.ref;
                                    if (_ !== null) {
                                        var E = h.stateNode;
                                        switch (h.tag) {
                                        case 26:
                                        case 27:
                                        case 5:
                                            var R = Bu(E);
                                            break;
                                        default:
                                            R = E
                                        }
                                        typeof _ == "function" ? h.refCleanup = _(R) : _.current = R
                                    }
                                } catch (P) {
                                    pn(h, d, P)
                                }
                            }
                            function hi(h, d) {
                                var _ = h.ref
                                  , E = h.refCleanup;
                                if (_ !== null)
                                    if (typeof E == "function")
                                        try {
                                            E()
                                        } catch (R) {
                                            pn(h, d, R)
                                        } finally {
                                            h.refCleanup = null,
                                            h = h.alternate,
                                            h != null && (h.refCleanup = null)
                                        }
                                    else if (typeof _ == "function")
                                        try {
                                            _(null)
                                        } catch (R) {
                                            pn(h, d, R)
                                        }
                                    else
                                        _.current = null
                            }
                            function Au(h) {
                                var d = h.type
                                  , _ = h.memoizedProps
                                  , E = h.stateNode;
                                try {
                                    Dx(E, d, _, h)
                                } catch (R) {
                                    pn(h, h.return, R)
                                }
                            }
                            function Xm(h, d, _) {
                                try {
                                    pv(h.stateNode, h.type, _, d, h)
                                } catch (E) {
                                    pn(h, h.return, E)
                                }
                            }
                            function Wm(h) {
                                return h.tag === 5 || h.tag === 3 || (Ga ? h.tag === 26 : !1) || (Es ? h.tag === 27 : !1) || h.tag === 4
                            }
                            function gd(h) {
                                e: for (; ; ) {
                                    for (; h.sibling === null; ) {
                                        if (h.return === null || Wm(h.return))
                                            return null;
                                        h = h.return
                                    }
                                    for (h.sibling.return = h.return,
                                    h = h.sibling; h.tag !== 5 && h.tag !== 6 && (!Es || h.tag !== 27) && h.tag !== 18; ) {
                                        if (h.flags & 2 || h.child === null || h.tag === 4)
                                            continue e;
                                        h.child.return = h,
                                        h = h.child
                                    }
                                    if (!(h.flags & 2))
                                        return h.stateNode
                                }
                            }
                            function yd(h, d, _) {
                                var E = h.tag;
                                if (E === 5 || E === 6)
                                    h = h.stateNode,
                                    d ? vv(_, h, d) : X0(_, h);
                                else if (!(E === 4 || Es && E === 27) && (h = h.child,
                                h !== null))
                                    for (yd(h, d, _),
                                    h = h.sibling; h !== null; )
                                        yd(h, d, _),
                                        h = h.sibling
                            }
                            function Tu(h, d, _) {
                                var E = h.tag;
                                if (E === 5 || E === 6)
                                    h = h.stateNode,
                                    d ? mv(_, h, d) : dv(_, h);
                                else if (!(E === 4 || Es && E === 27) && (h = h.child,
                                h !== null))
                                    for (Tu(h, d, _),
                                    h = h.sibling; h !== null; )
                                        Tu(h, d, _),
                                        h = h.sibling
                            }
                            function B0(h, d, _) {
                                h = h.containerInfo;
                                try {
                                    Sv(h, _)
                                } catch (E) {
                                    pn(d, d.return, E)
                                }
                            }
                            function Mu(h, d) {
                                for (Yl(h.containerInfo),
                                Di = d; Di !== null; )
                                    if (h = Di,
                                    d = h.child,
                                    (h.subtreeFlags & 1028) !== 0 && d !== null)
                                        d.return = h,
                                        Di = d;
                                    else
                                        for (; Di !== null; ) {
                                            h = Di;
                                            var _ = h.alternate;
                                            switch (d = h.flags,
                                            h.tag) {
                                            case 0:
                                                break;
                                            case 11:
                                            case 15:
                                                break;
                                            case 1:
                                                if ((d & 1024) !== 0 && _ !== null) {
                                                    d = void 0;
                                                    var E = h
                                                      , R = _.memoizedProps;
                                                    _ = _.memoizedState;
                                                    var P = E.stateNode;
                                                    try {
                                                        var ne = ua(E.type, R, E.elementType === E.type);
                                                        d = P.getSnapshotBeforeUpdate(ne, _),
                                                        P.__reactInternalSnapshotBeforeUpdate = d
                                                    } catch (me) {
                                                        pn(E, E.return, me)
                                                    }
                                                }
                                                break;
                                            case 3:
                                                (d & 1024) !== 0 && bs && zd(h.stateNode.containerInfo);
                                                break;
                                            case 5:
                                            case 26:
                                            case 27:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            default:
                                                if ((d & 1024) !== 0)
                                                    throw Error(a(163))
                                            }
                                            if (d = h.sibling,
                                            d !== null) {
                                                d.return = h.return,
                                                Di = d;
                                                break
                                            }
                                            Di = h.return
                                        }
                                return ne = Hc,
                                Hc = !1,
                                ne
                            }
                            function _d(h, d, _) {
                                var E = _.flags;
                                switch (_.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    lo(h, _),
                                    E & 4 && Uh(5, _);
                                    break;
                                case 1:
                                    if (lo(h, _),
                                    E & 4)
                                        if (h = _.stateNode,
                                        d === null)
                                            try {
                                                h.componentDidMount()
                                            } catch (me) {
                                                pn(_, _.return, me)
                                            }
                                        else {
                                            var R = ua(_.type, d.memoizedProps);
                                            d = d.memoizedState;
                                            try {
                                                h.componentDidUpdate(R, d, h.__reactInternalSnapshotBeforeUpdate)
                                            } catch (me) {
                                                pn(_, _.return, me)
                                            }
                                        }
                                    E & 64 && O0(_),
                                    E & 512 && bc(_, _.return);
                                    break;
                                case 3:
                                    if (lo(h, _),
                                    E & 64 && (E = _.updateQueue,
                                    E !== null)) {
                                        if (h = null,
                                        _.child !== null)
                                            switch (_.child.tag) {
                                            case 27:
                                            case 5:
                                                h = Bu(_.child.stateNode);
                                                break;
                                            case 1:
                                                h = _.child.stateNode
                                            }
                                        try {
                                            tt(E, h)
                                        } catch (me) {
                                            pn(_, _.return, me)
                                        }
                                    }
                                    break;
                                case 26:
                                    if (Ga) {
                                        lo(h, _),
                                        E & 512 && bc(_, _.return);
                                        break
                                    }
                                case 27:
                                case 5:
                                    lo(h, _),
                                    d === null && E & 4 && Au(_),
                                    E & 512 && bc(_, _.return);
                                    break;
                                case 12:
                                    lo(h, _);
                                    break;
                                case 13:
                                    lo(h, _),
                                    E & 4 && Nl(h, _);
                                    break;
                                case 22:
                                    if (R = _.memoizedState !== null || is,
                                    !R) {
                                        d = d !== null && d.memoizedState !== null || _i;
                                        var P = is
                                          , ne = _i;
                                        is = R,
                                        (_i = d) && !ne ? Ll(h, _, (_.subtreeFlags & 8772) !== 0) : lo(h, _),
                                        is = P,
                                        _i = ne
                                    }
                                    E & 512 && (_.memoizedProps.mode === "manual" ? bc(_, _.return) : hi(_, _.return));
                                    break;
                                default:
                                    lo(h, _)
                                }
                            }
                            function bu(h) {
                                var d = h.alternate;
                                d !== null && (h.alternate = null,
                                bu(d)),
                                h.child = null,
                                h.deletions = null,
                                h.sibling = null,
                                h.tag === 5 && (d = h.stateNode,
                                d !== null && hv(d)),
                                h.stateNode = null,
                                h.return = null,
                                h.dependencies = null,
                                h.memoizedProps = null,
                                h.memoizedState = null,
                                h.pendingProps = null,
                                h.stateNode = null,
                                h.updateQueue = null
                            }
                            function Pa(h, d, _) {
                                for (_ = _.child; _ !== null; )
                                    Sd(h, d, _),
                                    _ = _.sibling
                            }
                            function Sd(h, d, _) {
                                if (va && typeof va.onCommitFiberUnmount == "function")
                                    try {
                                        va.onCommitFiberUnmount(Fu, _)
                                    } catch {}
                                switch (_.tag) {
                                case 26:
                                    if (Ga) {
                                        _i || hi(_, d),
                                        Pa(h, d, _),
                                        _.memoizedState ? Cv(_.memoizedState) : _.stateNode && Rv(_.stateNode);
                                        break
                                    }
                                case 27:
                                    if (Es) {
                                        _i || hi(_, d);
                                        var E = Pi
                                          , R = _a;
                                        Pi = _.stateNode,
                                        Pa(h, d, _),
                                        ly(_.stateNode),
                                        Pi = E,
                                        _a = R;
                                        break
                                    }
                                case 5:
                                    _i || hi(_, d);
                                case 6:
                                    if (bs) {
                                        if (E = Pi,
                                        R = _a,
                                        Pi = null,
                                        Pa(h, d, _),
                                        Pi = E,
                                        _a = R,
                                        Pi !== null)
                                            if (_a)
                                                try {
                                                    Bi(Pi, _.stateNode)
                                                } catch (P) {
                                                    pn(_, d, P)
                                                }
                                            else
                                                try {
                                                    $s(Pi, _.stateNode)
                                                } catch (P) {
                                                    pn(_, d, P)
                                                }
                                    } else
                                        Pa(h, d, _);
                                    break;
                                case 18:
                                    bs && Pi !== null && (_a ? Mv(Pi, _.stateNode) : iy(Pi, _.stateNode));
                                    break;
                                case 4:
                                    bs ? (E = Pi,
                                    R = _a,
                                    Pi = _.stateNode.containerInfo,
                                    _a = !0,
                                    Pa(h, d, _),
                                    Pi = E,
                                    _a = R) : (Fa && B0(_.stateNode, _, Fd()),
                                    Pa(h, d, _));
                                    break;
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    _i || Ol(2, _, d),
                                    _i || Ol(4, _, d),
                                    Pa(h, d, _);
                                    break;
                                case 1:
                                    _i || (hi(_, d),
                                    E = _.stateNode,
                                    typeof E.componentWillUnmount == "function" && N0(_, d, E)),
                                    Pa(h, d, _);
                                    break;
                                case 21:
                                    Pa(h, d, _);
                                    break;
                                case 22:
                                    _i || hi(_, d),
                                    _i = (E = _i) || _.memoizedState !== null,
                                    Pa(h, d, _),
                                    _i = E;
                                    break;
                                default:
                                    Pa(h, d, _)
                                }
                            }
                            function Nl(h, d) {
                                if (Js && d.memoizedState === null && (h = d.alternate,
                                h !== null && (h = h.memoizedState,
                                h !== null && (h = h.dehydrated,
                                h !== null))))
                                    try {
                                        kd(h)
                                    } catch (_) {
                                        pn(d, d.return, _)
                                    }
                            }
                            function Eu(h) {
                                switch (h.tag) {
                                case 13:
                                case 19:
                                    var d = h.stateNode;
                                    return d === null && (d = h.stateNode = new Wu),
                                    d;
                                case 22:
                                    return h = h.stateNode,
                                    d = h._retryCache,
                                    d === null && (d = h._retryCache = new Wu),
                                    d;
                                default:
                                    throw Error(a(435, h.tag))
                                }
                            }
                            function Oh(h, d) {
                                var _ = Eu(h);
                                d.forEach(function(E) {
                                    var R = Zm.bind(null, h, E);
                                    _.has(E) || (_.add(E),
                                    E.then(R, R))
                                })
                            }
                            function Qs(h, d) {
                                var _ = d.deletions;
                                if (_ !== null)
                                    for (var E = 0; E < _.length; E++) {
                                        var R = _[E]
                                          , P = h
                                          , ne = d;
                                        if (bs) {
                                            var me = ne;
                                            e: for (; me !== null; ) {
                                                switch (me.tag) {
                                                case 27:
                                                case 5:
                                                    Pi = me.stateNode,
                                                    _a = !1;
                                                    break e;
                                                case 3:
                                                    Pi = me.stateNode.containerInfo,
                                                    _a = !0;
                                                    break e;
                                                case 4:
                                                    Pi = me.stateNode.containerInfo,
                                                    _a = !0;
                                                    break e
                                                }
                                                me = me.return
                                            }
                                            if (Pi === null)
                                                throw Error(a(160));
                                            Sd(P, ne, R),
                                            Pi = null,
                                            _a = !1
                                        } else
                                            Sd(P, ne, R);
                                        P = R.alternate,
                                        P !== null && (P.return = null),
                                        R.return = null
                                    }
                                if (d.subtreeFlags & 13878)
                                    for (d = d.child; d !== null; )
                                        Bl(d, h),
                                        d = d.sibling
                            }
                            function Bl(h, d) {
                                var _ = h.alternate
                                  , E = h.flags;
                                switch (h.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Qs(d, h),
                                    ha(h),
                                    E & 4 && (Ol(3, h, h.return),
                                    Uh(3, h),
                                    Ol(5, h, h.return));
                                    break;
                                case 1:
                                    Qs(d, h),
                                    ha(h),
                                    E & 512 && (_i || _ === null || hi(_, _.return)),
                                    E & 64 && is && (h = h.updateQueue,
                                    h !== null && (E = h.callbacks,
                                    E !== null && (_ = h.shared.hiddenCallbacks,
                                    h.shared.hiddenCallbacks = _ === null ? E : _.concat(E))));
                                    break;
                                case 26:
                                    if (Ga) {
                                        var R = ea;
                                        Qs(d, h),
                                        ha(h),
                                        E & 512 && (_i || _ === null || hi(_, _.return)),
                                        E & 4 && (E = _ !== null ? _.memoizedState : null,
                                        d = h.memoizedState,
                                        _ === null ? d === null ? h.stateNode === null ? h.stateNode = wv(R, h.type, h.memoizedProps, h) : Dv(R, h.type, h.stateNode) : h.stateNode = Ev(R, d, h.memoizedProps) : E !== d ? (E === null ? _.stateNode !== null && Rv(_.stateNode) : Cv(E),
                                        d === null ? Dv(R, h.type, h.stateNode) : Ev(R, d, h.memoizedProps)) : d === null && h.stateNode !== null && Xm(h, h.memoizedProps, _.memoizedProps));
                                        break
                                    }
                                case 27:
                                    if (Es && E & 4 && h.alternate === null) {
                                        R = h.stateNode;
                                        var P = h.memoizedProps;
                                        try {
                                            Nx(R),
                                            Bx(h.type, P, R, h)
                                        } catch (mt) {
                                            pn(h, h.return, mt)
                                        }
                                    }
                                case 5:
                                    if (Qs(d, h),
                                    ha(h),
                                    E & 512 && (_i || _ === null || hi(_, _.return)),
                                    bs) {
                                        if (h.flags & 32) {
                                            d = h.stateNode;
                                            try {
                                                Wh(d)
                                            } catch (mt) {
                                                pn(h, h.return, mt)
                                            }
                                        }
                                        E & 4 && h.stateNode != null && (d = h.memoizedProps,
                                        Xm(h, d, _ !== null ? _.memoizedProps : d)),
                                        E & 1024 && (nc = !0)
                                    }
                                    break;
                                case 6:
                                    if (Qs(d, h),
                                    ha(h),
                                    E & 4 && bs) {
                                        if (h.stateNode === null)
                                            throw Error(a(162));
                                        E = h.memoizedProps,
                                        _ = _ !== null ? _.memoizedProps : E,
                                        d = h.stateNode;
                                        try {
                                            W0(d, _, E)
                                        } catch (mt) {
                                            pn(h, h.return, mt)
                                        }
                                    }
                                    break;
                                case 3:
                                    if (Ga ? (Uv(),
                                    R = ea,
                                    ea = Xd(d.containerInfo),
                                    Qs(d, h),
                                    ea = R) : Qs(d, h),
                                    ha(h),
                                    E & 4) {
                                        if (bs && Js && _ !== null && _.memoizedState.isDehydrated)
                                            try {
                                                Vd(d.containerInfo)
                                            } catch (mt) {
                                                pn(h, h.return, mt)
                                            }
                                        if (Fa) {
                                            E = d.containerInfo,
                                            _ = d.pendingChildren;
                                            try {
                                                Sv(E, _)
                                            } catch (mt) {
                                                pn(h, h.return, mt)
                                            }
                                        }
                                    }
                                    nc && (nc = !1,
                                    Ym(h));
                                    break;
                                case 4:
                                    Ga ? (_ = ea,
                                    ea = Xd(h.stateNode.containerInfo),
                                    Qs(d, h),
                                    ha(h),
                                    ea = _) : (Qs(d, h),
                                    ha(h)),
                                    E & 4 && Fa && B0(h.stateNode, h, h.stateNode.pendingChildren);
                                    break;
                                case 12:
                                    Qs(d, h),
                                    ha(h);
                                    break;
                                case 13:
                                    Qs(d, h),
                                    ha(h),
                                    h.child.flags & 8192 && h.memoizedState !== null != (_ !== null && _.memoizedState !== null) && (Ao = Cs()),
                                    E & 4 && (E = h.updateQueue,
                                    E !== null && (h.updateQueue = null,
                                    Oh(h, E)));
                                    break;
                                case 22:
                                    E & 512 && (_i || _ === null || hi(_, _.return)),
                                    R = h.memoizedState !== null;
                                    var ne = _ !== null && _.memoizedState !== null
                                      , me = is
                                      , Ce = _i;
                                    if (is = me || R,
                                    _i = Ce || ne,
                                    Qs(d, h),
                                    _i = Ce,
                                    is = me,
                                    ha(h),
                                    d = h.stateNode,
                                    d._current = h,
                                    d._visibility &= -3,
                                    d._visibility |= d._pendingVisibility & 2,
                                    E & 8192 && (d._visibility = R ? d._visibility & -2 : d._visibility | 1,
                                    R && (d = is || _i,
                                    _ === null || ne || d || Cu(h)),
                                    bs && (h.memoizedProps === null || h.memoizedProps.mode !== "manual"))) {
                                        e: if (_ = null,
                                        bs)
                                            for (d = h; ; ) {
                                                if (d.tag === 5 || Ga && d.tag === 26 || Es && d.tag === 27) {
                                                    if (_ === null) {
                                                        ne = _ = d;
                                                        try {
                                                            P = ne.stateNode,
                                                            R ? Yh(P) : gv(ne.stateNode, ne.memoizedProps)
                                                        } catch (mt) {
                                                            pn(ne, ne.return, mt)
                                                        }
                                                    }
                                                } else if (d.tag === 6) {
                                                    if (_ === null) {
                                                        ne = d;
                                                        try {
                                                            var et = ne.stateNode;
                                                            R ? Pd(et) : jo(et, ne.memoizedProps)
                                                        } catch (mt) {
                                                            pn(ne, ne.return, mt)
                                                        }
                                                    }
                                                } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === h) && d.child !== null) {
                                                    d.child.return = d,
                                                    d = d.child;
                                                    continue
                                                }
                                                if (d === h)
                                                    break e;
                                                for (; d.sibling === null; ) {
                                                    if (d.return === null || d.return === h)
                                                        break e;
                                                    _ === d && (_ = null),
                                                    d = d.return
                                                }
                                                _ === d && (_ = null),
                                                d.sibling.return = d.return,
                                                d = d.sibling
                                            }
                                    }
                                    E & 4 && (E = h.updateQueue,
                                    E !== null && (_ = E.retryQueue,
                                    _ !== null && (E.retryQueue = null,
                                    Oh(h, _))));
                                    break;
                                case 19:
                                    Qs(d, h),
                                    ha(h),
                                    E & 4 && (E = h.updateQueue,
                                    E !== null && (h.updateQueue = null,
                                    Oh(h, E)));
                                    break;
                                case 21:
                                    break;
                                default:
                                    Qs(d, h),
                                    ha(h)
                                }
                            }
                            function ha(h) {
                                var d = h.flags;
                                if (d & 2) {
                                    try {
                                        if (bs && (!Es || h.tag !== 27)) {
                                            e: {
                                                for (var _ = h.return; _ !== null; ) {
                                                    if (Wm(_)) {
                                                        var E = _;
                                                        break e
                                                    }
                                                    _ = _.return
                                                }
                                                throw Error(a(160))
                                            }
                                            switch (E.tag) {
                                            case 27:
                                                if (Es) {
                                                    var R = E.stateNode
                                                      , P = gd(h);
                                                    Tu(h, P, R);
                                                    break
                                                }
                                            case 5:
                                                var ne = E.stateNode;
                                                E.flags & 32 && (Wh(ne),
                                                E.flags &= -33);
                                                var me = gd(h);
                                                Tu(h, me, ne);
                                                break;
                                            case 3:
                                            case 4:
                                                var Ce = E.stateNode.containerInfo
                                                  , et = gd(h);
                                                yd(h, et, Ce);
                                                break;
                                            default:
                                                throw Error(a(161))
                                            }
                                        }
                                    } catch (mt) {
                                        pn(h, h.return, mt)
                                    }
                                    h.flags &= -3
                                }
                                d & 4096 && (h.flags &= -4097)
                            }
                            function Ym(h) {
                                if (h.subtreeFlags & 1024)
                                    for (h = h.child; h !== null; ) {
                                        var d = h;
                                        Ym(d),
                                        d.tag === 5 && d.flags & 1024 && jn(d.stateNode),
                                        h = h.sibling
                                    }
                            }
                            function lo(h, d) {
                                if (d.subtreeFlags & 8772)
                                    for (d = d.child; d !== null; )
                                        _d(h, d.alternate, d),
                                        d = d.sibling
                            }
                            function Cu(h) {
                                for (h = h.child; h !== null; ) {
                                    var d = h;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        Ol(4, d, d.return),
                                        Cu(d);
                                        break;
                                    case 1:
                                        hi(d, d.return);
                                        var _ = d.stateNode;
                                        typeof _.componentWillUnmount == "function" && N0(d, d.return, _),
                                        Cu(d);
                                        break;
                                    case 26:
                                    case 27:
                                    case 5:
                                        hi(d, d.return),
                                        Cu(d);
                                        break;
                                    case 22:
                                        hi(d, d.return),
                                        d.memoizedState === null && Cu(d);
                                        break;
                                    default:
                                        Cu(d)
                                    }
                                    h = h.sibling
                                }
                            }
                            function Ll(h, d, _) {
                                for (_ = _ && (d.subtreeFlags & 8772) !== 0,
                                d = d.child; d !== null; ) {
                                    var E = d.alternate
                                      , R = h
                                      , P = d
                                      , ne = P.flags;
                                    switch (P.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ll(R, P, _),
                                        Uh(4, P);
                                        break;
                                    case 1:
                                        if (Ll(R, P, _),
                                        E = P,
                                        R = E.stateNode,
                                        typeof R.componentDidMount == "function")
                                            try {
                                                R.componentDidMount()
                                            } catch (et) {
                                                pn(E, E.return, et)
                                            }
                                        if (E = P,
                                        R = E.updateQueue,
                                        R !== null) {
                                            var me = E.stateNode;
                                            try {
                                                var Ce = R.shared.hiddenCallbacks;
                                                if (Ce !== null)
                                                    for (R.shared.hiddenCallbacks = null,
                                                    R = 0; R < Ce.length; R++)
                                                        ot(Ce[R], me)
                                            } catch (et) {
                                                pn(E, E.return, et)
                                            }
                                        }
                                        _ && ne & 64 && O0(P),
                                        bc(P, P.return);
                                        break;
                                    case 26:
                                    case 27:
                                    case 5:
                                        Ll(R, P, _),
                                        _ && E === null && ne & 4 && Au(P),
                                        bc(P, P.return);
                                        break;
                                    case 12:
                                        Ll(R, P, _);
                                        break;
                                    case 13:
                                        Ll(R, P, _),
                                        _ && ne & 4 && Nl(R, P);
                                        break;
                                    case 22:
                                        P.memoizedState === null && Ll(R, P, _),
                                        bc(P, P.return);
                                        break;
                                    default:
                                        Ll(R, P, _)
                                    }
                                    d = d.sibling
                                }
                            }
                            function qm(h, d) {
                                var _ = null;
                                h !== null && h.memoizedState !== null && h.memoizedState.cachePool !== null && (_ = h.memoizedState.cachePool.pool),
                                h = null,
                                d.memoizedState !== null && d.memoizedState.cachePool !== null && (h = d.memoizedState.cachePool.pool),
                                h !== _ && (h != null && h.refCount++,
                                _ != null && yu(_))
                            }
                            function xd(h, d) {
                                h = null,
                                d.alternate !== null && (h = d.alternate.memoizedState.cache),
                                d = d.memoizedState.cache,
                                d !== h && (d.refCount++,
                                h != null && yu(h))
                            }
                            function zo(h, d, _, E) {
                                if (d.subtreeFlags & 10256)
                                    for (d = d.child; d !== null; )
                                        Ad(h, d, _, E),
                                        d = d.sibling
                            }
                            function Ad(h, d, _, E) {
                                var R = d.flags;
                                switch (d.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    zo(h, d, _, E),
                                    R & 2048 && Uh(9, d);
                                    break;
                                case 3:
                                    zo(h, d, _, E),
                                    R & 2048 && (h = null,
                                    d.alternate !== null && (h = d.alternate.memoizedState.cache),
                                    d = d.memoizedState.cache,
                                    d !== h && (d.refCount++,
                                    h != null && yu(h)));
                                    break;
                                case 12:
                                    if (R & 2048) {
                                        zo(h, d, _, E),
                                        h = d.stateNode;
                                        try {
                                            var P = d.memoizedProps
                                              , ne = P.id
                                              , me = P.onPostCommit;
                                            typeof me == "function" && me(ne, d.alternate === null ? "mount" : "update", h.passiveEffectDuration, -0)
                                        } catch (Ce) {
                                            pn(d, d.return, Ce)
                                        }
                                    } else
                                        zo(h, d, _, E);
                                    break;
                                case 23:
                                    break;
                                case 22:
                                    P = d.stateNode,
                                    d.memoizedState !== null ? P._visibility & 4 ? zo(h, d, _, E) : Il(h, d) : P._visibility & 4 ? zo(h, d, _, E) : (P._visibility |= 4,
                                    Ps(h, d, _, E, (d.subtreeFlags & 10256) !== 0)),
                                    R & 2048 && qm(d.alternate, d);
                                    break;
                                case 24:
                                    zo(h, d, _, E),
                                    R & 2048 && xd(d.alternate, d);
                                    break;
                                default:
                                    zo(h, d, _, E)
                                }
                            }
                            function Ps(h, d, _, E, R) {
                                for (R = R && (d.subtreeFlags & 10256) !== 0,
                                d = d.child; d !== null; ) {
                                    var P = h
                                      , ne = d
                                      , me = _
                                      , Ce = E
                                      , et = ne.flags;
                                    switch (ne.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ps(P, ne, me, Ce, R),
                                        Uh(8, ne);
                                        break;
                                    case 23:
                                        break;
                                    case 22:
                                        var mt = ne.stateNode;
                                        ne.memoizedState !== null ? mt._visibility & 4 ? Ps(P, ne, me, Ce, R) : Il(P, ne) : (mt._visibility |= 4,
                                        Ps(P, ne, me, Ce, R)),
                                        R && et & 2048 && qm(ne.alternate, ne);
                                        break;
                                    case 24:
                                        Ps(P, ne, me, Ce, R),
                                        R && et & 2048 && xd(ne.alternate, ne);
                                        break;
                                    default:
                                        Ps(P, ne, me, Ce, R)
                                    }
                                    d = d.sibling
                                }
                            }
                            function Il(h, d) {
                                if (d.subtreeFlags & 10256)
                                    for (d = d.child; d !== null; ) {
                                        var _ = h
                                          , E = d
                                          , R = E.flags;
                                        switch (E.tag) {
                                        case 22:
                                            Il(_, E),
                                            R & 2048 && qm(E.alternate, E);
                                            break;
                                        case 24:
                                            Il(_, E),
                                            R & 2048 && xd(E.alternate, E);
                                            break;
                                        default:
                                            Il(_, E)
                                        }
                                        d = d.sibling
                                    }
                            }
                            function cs(h) {
                                if (h.subtreeFlags & Gc)
                                    for (h = h.child; h !== null; )
                                        Ec(h),
                                        h = h.sibling
                            }
                            function Ec(h) {
                                switch (h.tag) {
                                case 26:
                                    cs(h),
                                    h.flags & Gc && (h.memoizedState !== null ? Nv(ea, h.memoizedState, h.memoizedProps) : Mi(h.type, h.memoizedProps));
                                    break;
                                case 5:
                                    cs(h),
                                    h.flags & Gc && Mi(h.type, h.memoizedProps);
                                    break;
                                case 3:
                                case 4:
                                    if (Ga) {
                                        var d = ea;
                                        ea = Xd(h.stateNode.containerInfo),
                                        cs(h),
                                        ea = d
                                    } else
                                        cs(h);
                                    break;
                                case 22:
                                    h.memoizedState === null && (d = h.alternate,
                                    d !== null && d.memoizedState !== null ? (d = Gc,
                                    Gc = 16777216,
                                    cs(h),
                                    Gc = d) : cs(h));
                                    break;
                                default:
                                    cs(h)
                                }
                            }
                            function Td(h) {
                                var d = h.alternate;
                                if (d !== null && (h = d.child,
                                h !== null)) {
                                    d.child = null;
                                    do
                                        d = h.sibling,
                                        h.sibling = null,
                                        h = d;
                                    while (h !== null)
                                }
                            }
                            function Pl(h) {
                                var d = h.deletions;
                                if ((h.flags & 16) !== 0) {
                                    if (d !== null)
                                        for (var _ = 0; _ < d.length; _++) {
                                            var E = d[_];
                                            Di = E,
                                            zl(E, h)
                                        }
                                    Td(h)
                                }
                                if (h.subtreeFlags & 10256)
                                    for (h = h.child; h !== null; )
                                        Nh(h),
                                        h = h.sibling
                            }
                            function Nh(h) {
                                switch (h.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pl(h),
                                    h.flags & 2048 && Ol(9, h, h.return);
                                    break;
                                case 3:
                                    Pl(h);
                                    break;
                                case 12:
                                    Pl(h);
                                    break;
                                case 22:
                                    var d = h.stateNode;
                                    h.memoizedState !== null && d._visibility & 4 && (h.return === null || h.return.tag !== 13) ? (d._visibility &= -5,
                                    wu(h)) : Pl(h);
                                    break;
                                default:
                                    Pl(h)
                                }
                            }
                            function wu(h) {
                                var d = h.deletions;
                                if ((h.flags & 16) !== 0) {
                                    if (d !== null)
                                        for (var _ = 0; _ < d.length; _++) {
                                            var E = d[_];
                                            Di = E,
                                            zl(E, h)
                                        }
                                    Td(h)
                                }
                                for (h = h.child; h !== null; ) {
                                    switch (d = h,
                                    d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ol(8, d, d.return),
                                        wu(d);
                                        break;
                                    case 22:
                                        _ = d.stateNode,
                                        _._visibility & 4 && (_._visibility &= -5,
                                        wu(d));
                                        break;
                                    default:
                                        wu(d)
                                    }
                                    h = h.sibling
                                }
                            }
                            function zl(h, d) {
                                for (; Di !== null; ) {
                                    var _ = Di;
                                    switch (_.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ol(8, _, d);
                                        break;
                                    case 23:
                                    case 22:
                                        if (_.memoizedState !== null && _.memoizedState.cachePool !== null) {
                                            var E = _.memoizedState.cachePool.pool;
                                            E != null && E.refCount++
                                        }
                                        break;
                                    case 24:
                                        yu(_.memoizedState.cache)
                                    }
                                    if (E = _.child,
                                    E !== null)
                                        E.return = _,
                                        Di = E;
                                    else
                                        e: for (_ = h; Di !== null; ) {
                                            E = Di;
                                            var R = E.sibling
                                              , P = E.return;
                                            if (bu(E),
                                            E === _) {
                                                Di = null;
                                                break e
                                            }
                                            if (R !== null) {
                                                R.return = P,
                                                Di = R;
                                                break e
                                            }
                                            Di = P
                                        }
                                }
                            }
                            function Md(h) {
                                var d = cv(h);
                                if (d != null) {
                                    if (typeof d.memoizedProps["data-testname"] != "string")
                                        throw Error(a(364));
                                    return d
                                }
                                if (h = Lc(h),
                                h === null)
                                    throw Error(a(362));
                                return h.stateNode.current
                            }
                            function Du(h, d) {
                                var _ = h.tag;
                                switch (d.$$typeof) {
                                case lf:
                                    if (h.type === d.value)
                                        return !0;
                                    break;
                                case ep:
                                    e: {
                                        for (d = d.value,
                                        h = [h, 0],
                                        _ = 0; _ < h.length; ) {
                                            var E = h[_++]
                                              , R = E.tag
                                              , P = h[_++]
                                              , ne = d[P];
                                            if (R !== 5 && R !== 26 && R !== 27 || !go(E)) {
                                                for (; ne != null && Du(E, ne); )
                                                    P++,
                                                    ne = d[P];
                                                if (P === d.length) {
                                                    d = !0;
                                                    break e
                                                } else
                                                    for (E = E.child; E !== null; )
                                                        h.push(E, P),
                                                        E = E.sibling
                                            }
                                        }
                                        d = !1
                                    }
                                    return d;
                                case tp:
                                    if ((_ === 5 || _ === 26 || _ === 27) && wx(h.stateNode, d.value))
                                        return !0;
                                    break;
                                case zn:
                                    if ((_ === 5 || _ === 6 || _ === 26 || _ === 27) && (h = Xh(h),
                                    h !== null && 0 <= h.indexOf(d.value)))
                                        return !0;
                                    break;
                                case Sn:
                                    if ((_ === 5 || _ === 26 || _ === 27) && (h = h.memoizedProps["data-testname"],
                                    typeof h == "string" && h.toLowerCase() === d.value.toLowerCase()))
                                        return !0;
                                    break;
                                default:
                                    throw Error(a(365))
                                }
                                return !1
                            }
                            function Fl(h) {
                                switch (h.$$typeof) {
                                case lf:
                                    return "<" + (c(h.value) || "Unknown") + ">";
                                case ep:
                                    return ":has(" + (Fl(h) || "") + ")";
                                case tp:
                                    return '[role="' + h.value + '"]';
                                case zn:
                                    return '"' + h.value + '"';
                                case Sn:
                                    return '[data-testname="' + h.value + '"]';
                                default:
                                    throw Error(a(365))
                                }
                            }
                            function L0(h, d) {
                                var _ = [];
                                h = [h, 0];
                                for (var E = 0; E < h.length; ) {
                                    var R = h[E++]
                                      , P = R.tag
                                      , ne = h[E++]
                                      , me = d[ne];
                                    if (P !== 5 && P !== 26 && P !== 27 || !go(R)) {
                                        for (; me != null && Du(R, me); )
                                            ne++,
                                            me = d[ne];
                                        if (ne === d.length)
                                            _.push(R);
                                        else
                                            for (R = R.child; R !== null; )
                                                h.push(R, ne),
                                                R = R.sibling
                                    }
                                }
                                return _
                            }
                            function Zs(h, d) {
                                if (!vo)
                                    throw Error(a(363));
                                h = Md(h),
                                h = L0(h, d),
                                d = [],
                                h = Array.from(h);
                                for (var _ = 0; _ < h.length; ) {
                                    var E = h[_++]
                                      , R = E.tag;
                                    if (R === 5 || R === 26 || R === 27)
                                        go(E) || d.push(E.stateNode);
                                    else
                                        for (E = E.child; E !== null; )
                                            h.push(E),
                                            E = E.sibling
                                }
                                return d
                            }
                            function Ks() {
                                if ((Pt & 2) !== 0 && rn !== 0)
                                    return rn & -rn;
                                if (Ft.T !== null) {
                                    var h = ga;
                                    return h !== 0 ? h : De()
                                }
                                return fr()
                            }
                            function co() {
                                Sa === 0 && (Sa = (rn & 536870912) === 0 || En ? I() : 536870912);
                                var h = ja.current;
                                return h !== null && (h.flags |= 32),
                                Sa
                            }
                            function zs(h, d, _) {
                                (h === cn && Qn === 2 || h.cancelPendingCommit !== null) && (Pr(h, 0),
                                Ir(h, rn, Sa, !1)),
                                X(h, _),
                                ((Pt & 2) === 0 || h !== cn) && (h === cn && ((Pt & 2) === 0 && (Xr |= _),
                                xn === 4 && Ir(h, rn, Sa, !1)),
                                it(h))
                            }
                            function Bh(h, d, _) {
                                if ((Pt & 6) !== 0)
                                    throw Error(a(327));
                                var E = !_ && (d & 60) === 0 && (d & h.expiredLanes) === 0 || N(h, d)
                                  , R = E ? fo(h, d) : uo(h, d, !0)
                                  , P = E;
                                do {
                                    if (R === 0) {
                                        Qa && !E && Ir(h, d, 0, !1);
                                        break
                                    } else if (R === 6)
                                        Ir(h, d, 0, !Fn);
                                    else {
                                        if (_ = h.current.alternate,
                                        P && !I0(_)) {
                                            R = uo(h, d, !1),
                                            P = !1;
                                            continue
                                        }
                                        if (R === 2) {
                                            if (P = d,
                                            h.errorRecoveryDisabledLanes & P)
                                                var ne = 0;
                                            else
                                                ne = h.pendingLanes & -536870913,
                                                ne = ne !== 0 ? ne : ne & 536870912 ? 536870912 : 0;
                                            if (ne !== 0) {
                                                d = ne;
                                                e: {
                                                    var me = h;
                                                    R = Yu;
                                                    var Ce = Js && me.current.memoizedState.isDehydrated;
                                                    if (Ce && (Pr(me, ne).flags |= 256),
                                                    ne = uo(me, ne, !1),
                                                    ne !== 2) {
                                                        if (el && !Ce) {
                                                            me.errorRecoveryDisabledLanes |= P,
                                                            Xr |= P,
                                                            R = 4;
                                                            break e
                                                        }
                                                        P = Ka,
                                                        Ka = R,
                                                        P !== null && Fo(P)
                                                    }
                                                    R = ne
                                                }
                                                if (P = !1,
                                                R !== 2)
                                                    continue
                                            }
                                        }
                                        if (R === 1) {
                                            Pr(h, 0),
                                            Ir(h, d, 0, !0);
                                            break
                                        }
                                        e: {
                                            switch (E = h,
                                            R) {
                                            case 0:
                                            case 1:
                                                throw Error(a(345));
                                            case 4:
                                                if ((d & 4194176) === d) {
                                                    Ir(E, d, Sa, !Fn);
                                                    break e
                                                }
                                                break;
                                            case 2:
                                                Ka = null;
                                                break;
                                            case 3:
                                            case 5:
                                                break;
                                            default:
                                                throw Error(a(329))
                                            }
                                            if (E.finishedWork = _,
                                            E.finishedLanes = d,
                                            (d & 62914560) === d && (P = Ao + 300 - Cs(),
                                            10 < P)) {
                                                if (Ir(E, d, Sa, !Fn),
                                                L(E, 0) !== 0)
                                                    break e;
                                                E.timeoutHandle = lv(bd.bind(null, E, _, Ka, Wr, qu, d, Sa, Xr, tl, Fn, 2, -0, 0), P);
                                                break e
                                            }
                                            bd(E, _, Ka, Wr, qu, d, Sa, Xr, tl, Fn, 0, -0, 0)
                                        }
                                    }
                                    break
                                } while (!0);
                                it(h)
                            }
                            function Fo(h) {
                                Ka === null ? Ka = h : Ka.push.apply(Ka, h)
                            }
                            function bd(h, d, _, E, R, P, ne, me, Ce, et, mt, Tt, bt) {
                                var qt = d.subtreeFlags;
                                if ((qt & 8192 || (qt & 16785408) === 16785408) && (Ha(),
                                Ec(d),
                                d = Bd(),
                                d !== null)) {
                                    h.cancelPendingCommit = d(ni.bind(null, h, _, E, R, ne, me, Ce, 1, Tt, bt)),
                                    Ir(h, P, ne, !et);
                                    return
                                }
                                ni(h, _, E, R, ne, me, Ce, mt, Tt, bt)
                            }
                            function I0(h) {
                                for (var d = h; ; ) {
                                    var _ = d.tag;
                                    if ((_ === 0 || _ === 11 || _ === 15) && d.flags & 16384 && (_ = d.updateQueue,
                                    _ !== null && (_ = _.stores,
                                    _ !== null)))
                                        for (var E = 0; E < _.length; E++) {
                                            var R = _[E]
                                              , P = R.getSnapshot;
                                            R = R.value;
                                            try {
                                                if (!Va(P(), R))
                                                    return !1
                                            } catch {
                                                return !1
                                            }
                                        }
                                    if (_ = d.child,
                                    d.subtreeFlags & 16384 && _ !== null)
                                        _.return = d,
                                        d = _;
                                    else {
                                        if (d === h)
                                            break;
                                        for (; d.sibling === null; ) {
                                            if (d.return === null || d.return === h)
                                                return !0;
                                            d = d.return
                                        }
                                        d.sibling.return = d.return,
                                        d = d.sibling
                                    }
                                }
                                return !0
                            }
                            function Ir(h, d, _, E) {
                                d &= ~Xs,
                                d &= ~Xr,
                                h.suspendedLanes |= d,
                                h.pingedLanes &= ~d,
                                E && (h.warmLanes |= d),
                                E = h.expirationTimes;
                                for (var R = d; 0 < R; ) {
                                    var P = 31 - ma(R)
                                      , ne = 1 << P;
                                    E[P] = -1,
                                    R &= ~ne
                                }
                                _ !== 0 && Q(h, _, d)
                            }
                            function jm() {
                                return (Pt & 6) === 0 ? (je(0, !1),
                                !1) : !0
                            }
                            function fa() {
                                if (jt !== null) {
                                    if (Qn === 0)
                                        var h = jt.return;
                                    else
                                        h = jt,
                                        wi = tc = null,
                                        Ge(h),
                                        _o = null,
                                        mr = 0,
                                        h = jt;
                                    for (; h !== null; )
                                        km(h.alternate, h),
                                        h = h.return;
                                    jt = null
                                }
                            }
                            function Pr(h, d) {
                                h.finishedWork = null,
                                h.finishedLanes = 0;
                                var _ = h.timeoutHandle;
                                _ !== Bc && (h.timeoutHandle = Bc,
                                kh(_)),
                                _ = h.cancelPendingCommit,
                                _ !== null && (h.cancelPendingCommit = null,
                                _()),
                                fa(),
                                cn = h,
                                jt = _ = Fs(h.current, null),
                                rn = d,
                                Qn = 0,
                                zi = null,
                                Fn = !1,
                                Qa = N(h, d),
                                el = !1,
                                tl = Sa = Xs = Xr = Za = xn = 0,
                                Ka = Yu = null,
                                qu = !1,
                                (d & 8) !== 0 && (d |= d & 32);
                                var E = h.entangledLanes;
                                if (E !== 0)
                                    for (h = h.entanglements,
                                    E &= d; 0 < E; ) {
                                        var R = 31 - ma(E)
                                          , P = 1 << R;
                                        d |= h[R],
                                        E &= ~P
                                    }
                                return kr = d,
                                ye(),
                                _
                            }
                            function Cc(h, d) {
                                $t = null,
                                Ft.H = Cn,
                                d === Yn ? (d = _t(),
                                Qn = 3) : d === Pv ? (d = _t(),
                                Qn = 4) : Qn = d === my ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1,
                                zi = d,
                                jt === null && (xn = 1,
                                ro(h, j(d, h.current)))
                            }
                            function Lh() {
                                var h = ja.current;
                                return h === null ? !0 : (rn & 4194176) === rn ? vr === null : (rn & 62914560) === rn || (rn & 536870912) !== 0 ? h === vr : !1
                            }
                            function Ru() {
                                var h = Ft.H;
                                return Ft.H = Cn,
                                h === null ? Cn : h
                            }
                            function za() {
                                var h = Ft.A;
                                return Ft.A = $d,
                                h
                            }
                            function da() {
                                xn = 4,
                                Fn || (rn & 4194176) !== rn && ja.current !== null || (Qa = !0),
                                (Za & 134217727) === 0 && (Xr & 134217727) === 0 || cn === null || Ir(cn, rn, Sa, !1)
                            }
                            function uo(h, d, _) {
                                var E = Pt;
                                Pt |= 2;
                                var R = Ru()
                                  , P = za();
                                (cn !== h || rn !== d) && (Wr = null,
                                Pr(h, d)),
                                d = !1;
                                var ne = xn;
                                e: do
                                    try {
                                        if (Qn !== 0 && jt !== null) {
                                            var me = jt
                                              , Ce = zi;
                                            switch (Qn) {
                                            case 8:
                                                fa(),
                                                ne = 6;
                                                break e;
                                            case 3:
                                            case 2:
                                            case 6:
                                                ja.current === null && (d = !0);
                                                var et = Qn;
                                                if (Qn = 0,
                                                zi = null,
                                                Hl(h, me, Ce, et),
                                                _ && Qa) {
                                                    ne = 0;
                                                    break e
                                                }
                                                break;
                                            default:
                                                et = Qn,
                                                Qn = 0,
                                                zi = null,
                                                Hl(h, me, Ce, et)
                                            }
                                        }
                                        ho(),
                                        ne = xn;
                                        break
                                    } catch (mt) {
                                        Cc(h, mt)
                                    }
                                while (!0);
                                return d && h.shellSuspendCounter++,
                                wi = tc = null,
                                Pt = E,
                                Ft.H = R,
                                Ft.A = P,
                                jt === null && (cn = null,
                                rn = 0,
                                ye()),
                                ne
                            }
                            function ho() {
                                for (; jt !== null; )
                                    Qm(jt)
                            }
                            function fo(h, d) {
                                var _ = Pt;
                                Pt |= 2;
                                var E = Ru()
                                  , R = za();
                                cn !== h || rn !== d ? (Wr = null,
                                Si = Cs() + 500,
                                Pr(h, d)) : Qa = N(h, d);
                                e: do
                                    try {
                                        if (Qn !== 0 && jt !== null) {
                                            d = jt;
                                            var P = zi;
                                            t: switch (Qn) {
                                            case 1:
                                                Qn = 0,
                                                zi = null,
                                                Hl(h, d, P, 1);
                                                break;
                                            case 2:
                                                if (Qe(P)) {
                                                    Qn = 0,
                                                    zi = null,
                                                    Ed(d);
                                                    break
                                                }
                                                d = function() {
                                                    Qn === 2 && cn === h && (Qn = 7),
                                                    it(h)
                                                }
                                                ,
                                                P.then(d, d);
                                                break e;
                                            case 3:
                                                Qn = 7;
                                                break e;
                                            case 4:
                                                Qn = 5;
                                                break e;
                                            case 7:
                                                Qe(P) ? (Qn = 0,
                                                zi = null,
                                                Ed(d)) : (Qn = 0,
                                                zi = null,
                                                Hl(h, d, P, 7));
                                                break;
                                            case 5:
                                                var ne = null;
                                                switch (jt.tag) {
                                                case 26:
                                                    ne = jt.memoizedState;
                                                case 5:
                                                case 27:
                                                    var me = jt
                                                      , Ce = me.type
                                                      , et = me.pendingProps;
                                                    if (ne ? Ov(ne) : qo(Ce, et)) {
                                                        Qn = 0,
                                                        zi = null;
                                                        var mt = me.sibling;
                                                        if (mt !== null)
                                                            jt = mt;
                                                        else {
                                                            var Tt = me.return;
                                                            Tt !== null ? (jt = Tt,
                                                            Ih(Tt)) : jt = null
                                                        }
                                                        break t
                                                    }
                                                }
                                                Qn = 0,
                                                zi = null,
                                                Hl(h, d, P, 5);
                                                break;
                                            case 6:
                                                Qn = 0,
                                                zi = null,
                                                Hl(h, d, P, 6);
                                                break;
                                            case 8:
                                                fa(),
                                                xn = 6;
                                                break e;
                                            default:
                                                throw Error(a(462))
                                            }
                                        }
                                        Ho();
                                        break
                                    } catch (bt) {
                                        Cc(h, bt)
                                    }
                                while (!0);
                                return wi = tc = null,
                                Ft.H = E,
                                Ft.A = R,
                                Pt = _,
                                jt !== null ? 0 : (cn = null,
                                rn = 0,
                                ye(),
                                xn)
                            }
                            function Ho() {
                                for (; jt !== null && !uy(); )
                                    Qm(jt)
                            }
                            function Qm(h) {
                                var d = w0(h.alternate, h, kr);
                                h.memoizedProps = h.pendingProps,
                                d === null ? Ih(h) : jt = d
                            }
                            function Ed(h) {
                                var d = h
                                  , _ = d.alternate;
                                switch (d.tag) {
                                case 15:
                                case 0:
                                    d = T0(_, d, d.pendingProps, d.type, void 0, rn);
                                    break;
                                case 11:
                                    d = T0(_, d, d.pendingProps, d.type.render, d.ref, rn);
                                    break;
                                case 5:
                                    Ge(d);
                                default:
                                    km(_, d),
                                    d = jt = ko(d, kr),
                                    d = w0(_, d, kr)
                                }
                                h.memoizedProps = h.pendingProps,
                                d === null ? Ih(h) : jt = d
                            }
                            function Hl(h, d, _, E) {
                                wi = tc = null,
                                Ge(d),
                                _o = null,
                                mr = 0;
                                var R = d.return;
                                try {
                                    if (xc(h, R, d, _, rn)) {
                                        xn = 1,
                                        ro(h, j(_, h.current)),
                                        jt = null;
                                        return
                                    }
                                } catch (P) {
                                    if (R !== null)
                                        throw jt = R,
                                        P;
                                    xn = 1,
                                    ro(h, j(_, h.current)),
                                    jt = null;
                                    return
                                }
                                d.flags & 32768 ? (En || E === 1 ? h = !0 : Qa || (rn & 536870912) !== 0 ? h = !1 : (Fn = h = !0,
                                (E === 2 || E === 3 || E === 6) && (E = ja.current,
                                E !== null && E.tag === 13 && (E.flags |= 16384))),
                                us(d, h)) : Ih(d)
                            }
                            function Ih(h) {
                                var d = h;
                                do {
                                    if ((d.flags & 32768) !== 0) {
                                        us(d, Fn);
                                        return
                                    }
                                    h = d.return;
                                    var _ = R0(d.alternate, d, kr);
                                    if (_ !== null) {
                                        jt = _;
                                        return
                                    }
                                    if (d = d.sibling,
                                    d !== null) {
                                        jt = d;
                                        return
                                    }
                                    jt = d = h
                                } while (d !== null);
                                xn === 0 && (xn = 5)
                            }
                            function us(h, d) {
                                do {
                                    var _ = U0(h.alternate, h);
                                    if (_ !== null) {
                                        _.flags &= 32767,
                                        jt = _;
                                        return
                                    }
                                    if (_ = h.return,
                                    _ !== null && (_.flags |= 32768,
                                    _.subtreeFlags = 0,
                                    _.deletions = null),
                                    !d && (h = h.sibling,
                                    h !== null)) {
                                        jt = h;
                                        return
                                    }
                                    jt = h = _
                                } while (h !== null);
                                xn = 6,
                                jt = null
                            }
                            function ni(h, d, _, E, R, P, ne, me, Ce, et) {
                                var mt = Ft.T
                                  , Tt = ns();
                                try {
                                    Hs(2),
                                    Ft.T = null,
                                    gn(h, d, _, E, Tt, R, P, ne, me, Ce, et)
                                } finally {
                                    Ft.T = mt,
                                    Hs(Tt)
                                }
                            }
                            function gn(h, d, _, E, R, P, ne, me) {
                                do
                                    hs();
                                while (nl !== null);
                                if ((Pt & 6) !== 0)
                                    throw Error(a(327));
                                var Ce = h.finishedWork;
                                if (E = h.finishedLanes,
                                Ce === null)
                                    return null;
                                if (h.finishedWork = null,
                                h.finishedLanes = 0,
                                Ce === h.current)
                                    throw Error(a(177));
                                h.callbackNode = null,
                                h.callbackPriority = 0,
                                h.cancelPendingCommit = null;
                                var et = Ce.lanes | Ce.childLanes;
                                if (et |= Gu,
                                q(h, E, et, P, ne, me),
                                h === cn && (jt = cn = null,
                                rn = 0),
                                (Ce.subtreeFlags & 10256) === 0 && (Ce.flags & 10256) === 0 || yr || (yr = !0,
                                np = et,
                                kc = _,
                                Ph(Lv, function() {
                                    return hs(!0),
                                    null
                                })),
                                _ = (Ce.flags & 15990) !== 0,
                                (Ce.subtreeFlags & 15990) !== 0 || _ ? (_ = Ft.T,
                                Ft.T = null,
                                P = ns(),
                                Hs(2),
                                ne = Pt,
                                Pt |= 4,
                                Mu(h, Ce),
                                Bl(Ce, h),
                                rv(h.containerInfo),
                                h.current = Ce,
                                _d(h, Ce.alternate, Ce),
                                hy(),
                                Pt = ne,
                                Hs(P),
                                Ft.T = _) : h.current = Ce,
                                yr ? (yr = !1,
                                nl = h,
                                Vc = E) : Go(h, et),
                                et = h.pendingLanes,
                                et === 0 && (Ja = null),
                                W(Ce.stateNode, R),
                                it(h),
                                d !== null)
                                    for (R = h.onRecoverableError,
                                    Ce = 0; Ce < d.length; Ce++)
                                        et = d[Ce],
                                        R(et.value, {
                                            componentStack: et.stack
                                        });
                                return (Vc & 3) !== 0 && hs(),
                                et = h.pendingLanes,
                                (E & 4194218) !== 0 && (et & 42) !== 0 ? h === xa ? Xc++ : (Xc = 0,
                                xa = h) : Xc = 0,
                                je(0, !1),
                                null
                            }
                            function Go(h, d) {
                                (h.pooledCacheLanes &= d) === 0 && (d = h.pooledCache,
                                d != null && (h.pooledCache = null,
                                yu(d)))
                            }
                            function hs() {
                                if (nl !== null) {
                                    var h = nl
                                      , d = np;
                                    np = 0;
                                    var _ = k(Vc)
                                      , E = 32 > _ ? 32 : _;
                                    _ = Ft.T;
                                    var R = ns();
                                    try {
                                        if (Hs(E),
                                        Ft.T = null,
                                        nl === null)
                                            var P = !1;
                                        else {
                                            E = kc,
                                            kc = null;
                                            var ne = nl
                                              , me = Vc;
                                            if (nl = null,
                                            Vc = 0,
                                            (Pt & 6) !== 0)
                                                throw Error(a(331));
                                            var Ce = Pt;
                                            if (Pt |= 4,
                                            Nh(ne.current),
                                            Ad(ne, ne.current, me, E),
                                            Pt = Ce,
                                            je(0, !1),
                                            va && typeof va.onPostCommitFiberRoot == "function")
                                                try {
                                                    va.onPostCommitFiberRoot(Fu, ne)
                                                } catch {}
                                            P = !0
                                        }
                                        return P
                                    } finally {
                                        Hs(R),
                                        Ft.T = _,
                                        Go(h, d)
                                    }
                                }
                                return !1
                            }
                            function Cd(h, d, _) {
                                d = j(_, d),
                                d = ts(h.stateNode, d, 2),
                                h = Ze(h, d, 2),
                                h !== null && (X(h, 2),
                                it(h))
                            }
                            function pn(h, d, _) {
                                if (h.tag === 3)
                                    Cd(h, h, _);
                                else
                                    for (; d !== null; ) {
                                        if (d.tag === 3) {
                                            Cd(d, h, _);
                                            break
                                        } else if (d.tag === 1) {
                                            var E = d.stateNode;
                                            if (typeof d.type.getDerivedStateFromError == "function" || typeof E.componentDidCatch == "function" && (Ja === null || !Ja.has(E))) {
                                                h = j(_, h),
                                                _ = Cl(2),
                                                E = Ze(d, _, 2),
                                                E !== null && (oo(_, E, d, h),
                                                X(E, 2),
                                                it(E));
                                                break
                                            }
                                        }
                                        d = d.return
                                    }
                            }
                            function wd(h, d, _) {
                                var E = h.pingCache;
                                if (E === null) {
                                    E = h.pingCache = new mn;
                                    var R = new Set;
                                    E.set(d, R)
                                } else
                                    R = E.get(d),
                                    R === void 0 && (R = new Set,
                                    E.set(d, R));
                                R.has(_) || (el = !0,
                                R.add(_),
                                h = P0.bind(null, h, d, _),
                                d.then(h, h))
                            }
                            function P0(h, d, _) {
                                var E = h.pingCache;
                                E !== null && E.delete(d),
                                h.pingedLanes |= h.suspendedLanes & _,
                                h.warmLanes &= ~_,
                                cn === h && (rn & _) === _ && (xn === 4 || xn === 3 && (rn & 62914560) === rn && 300 > Cs() - Ao ? (Pt & 2) === 0 && Pr(h, 0) : Xs |= _,
                                tl === rn && (tl = 0)),
                                it(h)
                            }
                            function wc(h, d) {
                                d === 0 && (d = B()),
                                h = Te(h, d),
                                h !== null && (X(h, d),
                                it(h))
                            }
                            function Dc(h) {
                                var d = h.memoizedState
                                  , _ = 0;
                                d !== null && (_ = d.retryLane),
                                wc(h, _)
                            }
                            function Zm(h, d) {
                                var _ = 0;
                                switch (h.tag) {
                                case 13:
                                    var E = h.stateNode
                                      , R = h.memoizedState;
                                    R !== null && (_ = R.retryLane);
                                    break;
                                case 19:
                                    E = h.stateNode;
                                    break;
                                case 22:
                                    E = h.stateNode._retryCache;
                                    break;
                                default:
                                    throw Error(a(314))
                                }
                                E !== null && E.delete(d),
                                wc(h, _)
                            }
                            function Ph(h, d) {
                                return zu(h, d)
                            }
                            function Km(h, d, _, E) {
                                this.tag = h,
                                this.key = _,
                                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                                this.index = 0,
                                this.refCleanup = this.ref = null,
                                this.pendingProps = d,
                                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                                this.mode = E,
                                this.subtreeFlags = this.flags = 0,
                                this.deletions = null,
                                this.childLanes = this.lanes = 0,
                                this.alternate = null
                            }
                            function Vo(h) {
                                return h = h.prototype,
                                !(!h || !h.isReactComponent)
                            }
                            function Fs(h, d) {
                                var _ = h.alternate;
                                return _ === null ? (_ = i(h.tag, d, h.key, h.mode),
                                _.elementType = h.elementType,
                                _.type = h.type,
                                _.stateNode = h.stateNode,
                                _.alternate = h,
                                h.alternate = _) : (_.pendingProps = d,
                                _.type = h.type,
                                _.flags = 0,
                                _.subtreeFlags = 0,
                                _.deletions = null),
                                _.flags = h.flags & 31457280,
                                _.childLanes = h.childLanes,
                                _.lanes = h.lanes,
                                _.child = h.child,
                                _.memoizedProps = h.memoizedProps,
                                _.memoizedState = h.memoizedState,
                                _.updateQueue = h.updateQueue,
                                d = h.dependencies,
                                _.dependencies = d === null ? null : {
                                    lanes: d.lanes,
                                    firstContext: d.firstContext
                                },
                                _.sibling = h.sibling,
                                _.index = h.index,
                                _.ref = h.ref,
                                _.refCleanup = h.refCleanup,
                                _
                            }
                            function ko(h, d) {
                                h.flags &= 31457282;
                                var _ = h.alternate;
                                return _ === null ? (h.childLanes = 0,
                                h.lanes = d,
                                h.child = null,
                                h.subtreeFlags = 0,
                                h.memoizedProps = null,
                                h.memoizedState = null,
                                h.updateQueue = null,
                                h.dependencies = null,
                                h.stateNode = null) : (h.childLanes = _.childLanes,
                                h.lanes = _.lanes,
                                h.child = _.child,
                                h.subtreeFlags = 0,
                                h.deletions = null,
                                h.memoizedProps = _.memoizedProps,
                                h.memoizedState = _.memoizedState,
                                h.updateQueue = _.updateQueue,
                                h.type = _.type,
                                d = _.dependencies,
                                h.dependencies = d === null ? null : {
                                    lanes: d.lanes,
                                    firstContext: d.firstContext
                                }),
                                h
                            }
                            function hr(h, d, _, E, R, P) {
                                var ne = 0;
                                if (E = h,
                                typeof h == "function")
                                    Vo(h) && (ne = 1);
                                else if (typeof h == "string")
                                    ne = Ga && Es ? bv(h, _, ds.current) ? 26 : Iu(h) ? 27 : 5 : Ga ? bv(h, _, ds.current) ? 26 : 5 : Es && Iu(h) ? 27 : 5;
                                else
                                    e: switch (h) {
                                    case Ou:
                                        return Xo(_.children, R, P, d);
                                    case nv:
                                        ne = 8,
                                        R |= 24;
                                        break;
                                    case iv:
                                        return h = i(12, _, d, R | 2),
                                        h.elementType = iv,
                                        h.lanes = P,
                                        h;
                                    case Rd:
                                        return h = i(13, _, d, R),
                                        h.elementType = Rd,
                                        h.lanes = P,
                                        h;
                                    case kl:
                                        return h = i(19, _, d, R),
                                        h.elementType = kl,
                                        h.lanes = P,
                                        h;
                                    case Hh:
                                        return Dd(_, R, P, d);
                                    default:
                                        if (typeof h == "object" && h !== null)
                                            switch (h.$$typeof) {
                                            case H0:
                                            case po:
                                                ne = 10;
                                                break e;
                                            case Vl:
                                                ne = 9;
                                                break e;
                                            case Nu:
                                                ne = 11;
                                                break e;
                                            case Fh:
                                                ne = 14;
                                                break e;
                                            case Fr:
                                                ne = 16,
                                                E = null;
                                                break e
                                            }
                                        ne = 29,
                                        _ = Error(a(130, h === null ? "null" : typeof h, "")),
                                        E = null
                                    }
                                return d = i(ne, _, d, R),
                                d.elementType = h,
                                d.type = E,
                                d.lanes = P,
                                d
                            }
                            function Xo(h, d, _, E) {
                                return h = i(7, h, E, d),
                                h.lanes = _,
                                h
                            }
                            function Dd(h, d, _, E) {
                                h = i(22, h, E, d),
                                h.elementType = Hh,
                                h.lanes = _;
                                var R = {
                                    _visibility: 1,
                                    _pendingVisibility: 1,
                                    _pendingMarkers: null,
                                    _retryCache: null,
                                    _transitions: null,
                                    _current: null,
                                    detach: function() {
                                        var P = R._current;
                                        if (P === null)
                                            throw Error(a(456));
                                        if ((R._pendingVisibility & 2) === 0) {
                                            var ne = Te(P, 2);
                                            ne !== null && (R._pendingVisibility |= 2,
                                            zs(ne, P, 2))
                                        }
                                    },
                                    attach: function() {
                                        var P = R._current;
                                        if (P === null)
                                            throw Error(a(456));
                                        if ((R._pendingVisibility & 2) !== 0) {
                                            var ne = Te(P, 2);
                                            ne !== null && (R._pendingVisibility &= -3,
                                            zs(ne, P, 2))
                                        }
                                    }
                                };
                                return h.stateNode = R,
                                h
                            }
                            function Gl(h, d, _) {
                                return h = i(6, h, null, d),
                                h.lanes = _,
                                h
                            }
                            function Uu(h, d, _) {
                                return d = i(4, h.children !== null ? h.children : [], h.key, d),
                                d.lanes = _,
                                d.stateNode = {
                                    containerInfo: h.containerInfo,
                                    pendingChildren: null,
                                    implementation: h.implementation
                                },
                                d
                            }
                            function Rc(h, d, _, E, R, P, ne, me) {
                                this.tag = 1,
                                this.containerInfo = h,
                                this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                                this.timeoutHandle = Bc,
                                this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                                this.callbackPriority = 0,
                                this.expirationTimes = G(-1),
                                this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                                this.entanglements = G(0),
                                this.hiddenUpdates = G(null),
                                this.identifierPrefix = E,
                                this.onUncaughtError = R,
                                this.onCaughtError = P,
                                this.onRecoverableError = ne,
                                this.pooledCache = null,
                                this.pooledCacheLanes = 0,
                                this.formState = me,
                                this.incompleteTransitions = new Map
                            }
                            function fs(h, d, _, E, R, P, ne, me, Ce, et, mt, Tt) {
                                return h = new Rc(h,d,_,ne,me,Ce,et,Tt),
                                d = 1,
                                P === !0 && (d |= 24),
                                P = i(3, null, null, d),
                                h.current = P,
                                P.stateNode = h,
                                d = pd(),
                                d.refCount++,
                                h.pooledCache = d,
                                d.refCount++,
                                P.memoizedState = {
                                    element: E,
                                    isDehydrated: _,
                                    cache: d
                                },
                                gt(P),
                                h
                            }
                            function zh(h) {
                                return h ? (h = Ic,
                                h) : Ic
                            }
                            function Jm(h) {
                                var d = h._reactInternals;
                                if (d === void 0)
                                    throw typeof h.render == "function" ? Error(a(188)) : (h = Object.keys(h).join(","),
                                    Error(a(268, h)));
                                return h = A(d),
                                h = h !== null ? M(h) : null,
                                h === null ? null : Bu(h.stateNode)
                            }
                            function z0(h, d, _, E, R, P) {
                                R = zh(R),
                                E.context === null ? E.context = R : E.pendingContext = R,
                                E = Je(d),
                                E.payload = {
                                    element: _
                                },
                                P = P === void 0 ? null : P,
                                P !== null && (E.callback = P),
                                _ = Ze(h, E, d),
                                _ !== null && (zs(_, h, d),
                                ht(_, h, d))
                            }
                            function F0(h, d) {
                                if (h = h.memoizedState,
                                h !== null && h.dehydrated !== null) {
                                    var _ = h.retryLane;
                                    h.retryLane = _ !== 0 && _ < d ? _ : d
                                }
                            }
                            function $m(h, d) {
                                F0(h, d),
                                (h = h.alternate) && F0(h, d)
                            }
                            var It = {}, ev = cp(), Ms = sM(), Uc = Object.assign, tv = Symbol.for("react.element"), Wo = Symbol.for("react.transitional.element"), zr = Symbol.for("react.portal"), Ou = Symbol.for("react.fragment"), nv = Symbol.for("react.strict_mode"), iv = Symbol.for("react.profiler"), H0 = Symbol.for("react.provider"), Vl = Symbol.for("react.consumer"), po = Symbol.for("react.context"), Nu = Symbol.for("react.forward_ref"), Rd = Symbol.for("react.suspense"), kl = Symbol.for("react.suspense_list"), Fh = Symbol.for("react.memo"), Fr = Symbol.for("react.lazy"), Hh = Symbol.for("react.offscreen"), G0 = Symbol.for("react.memo_cache_sentinel"), sv = Symbol.iterator, Oc = Symbol.for("react.client.reference"), Ft = ev.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Ud, av, Xl = !1, Wl = Array.isArray, Od = n.rendererVersion, Gh = n.rendererPackageName, Vh = n.extraDevToolsConfig, Bu = n.getPublicInstance, Nc = n.getRootHostContext, V0 = n.getChildHostContext, Yl = n.prepareForCommit, rv = n.resetAfterCommit, ov = n.createInstance, Yo = n.appendInitialChild, ql = n.finalizeInitialChildren, jl = n.shouldSetTextContent, Nd = n.createTextInstance, lv = n.scheduleTimeout, kh = n.cancelTimeout, Bc = n.noTimeout, mo = n.isPrimaryRenderer;
                            n.warnsIfNotActing;
                            var bs = n.supportsMutation
                              , Fa = n.supportsPersistence
                              , Js = n.supportsHydration
                              , cv = n.getInstanceFromNode;
                            n.beforeActiveInstanceBlur,
                            n.afterActiveInstanceBlur;
                            var uv = n.preparePortalMount;
                            n.prepareScopeUpdate,
                            n.getInstanceFromScope;
                            var Hs = n.setCurrentUpdatePriority
                              , ns = n.getCurrentUpdatePriority
                              , fr = n.resolveUpdatePriority;
                            n.resolveEventType,
                            n.resolveEventTimeStamp;
                            var Ql = n.shouldAttemptEagerTransition
                              , hv = n.detachDeletedInstance;
                            n.requestPostPaintCallback;
                            var k0 = n.maySuspendCommit
                              , qo = n.preloadInstance
                              , Ha = n.startSuspendingCommit
                              , Mi = n.suspendInstance
                              , Bd = n.waitForCommitToBeReady
                              , pa = n.NotPendingTransition
                              , Vt = n.HostTransitionContext
                              , jn = n.resetFormInstance;
                            n.bindToConsole;
                            var qi = n.supportsMicrotasks
                              , Ld = n.scheduleMicrotask
                              , vo = n.supportsTestSelectors
                              , Lc = n.findFiberRoot
                              , Id = n.getBoundingRect
                              , Xh = n.getTextContent
                              , go = n.isHiddenSubtree
                              , wx = n.matchAccessibilityRole
                              , bi = n.setFocusIfFocusable
                              , fv = n.setupIntersectionObserver
                              , dv = n.appendChild
                              , X0 = n.appendChildToContainer
                              , W0 = n.commitTextUpdate
                              , Dx = n.commitMount
                              , pv = n.commitUpdate
                              , mv = n.insertBefore
                              , vv = n.insertInContainerBefore
                              , $s = n.removeChild
                              , Bi = n.removeChildFromContainer
                              , Wh = n.resetTextContent
                              , Yh = n.hideInstance
                              , Pd = n.hideTextInstance
                              , gv = n.unhideInstance
                              , jo = n.unhideTextInstance
                              , zd = n.clearContainer
                              , yv = n.cloneInstance
                              , Fd = n.createContainerChildSet
                              , _v = n.appendChildToContainerChildSet
                              , Y0 = n.finalizeContainerChildren
                              , Sv = n.replaceContainerChildren
                              , xv = n.cloneHiddenInstance
                              , Av = n.cloneHiddenTextInstance
                              , Hd = n.isSuspenseInstancePending
                              , qh = n.isSuspenseInstanceFallback
                              , q0 = n.getSuspenseInstanceFallbackErrorDetails
                              , Rx = n.registerSuspenseInstanceRetry
                              , j0 = n.canHydrateFormStateMarker
                              , Q0 = n.isFormStateMarkerMatching
                              , Tv = n.getNextHydratableSibling
                              , Gd = n.getFirstHydratableChild
                              , Z0 = n.getFirstHydratableChildWithinContainer
                              , K0 = n.getFirstHydratableChildWithinSuspenseInstance
                              , J0 = n.canHydrateInstance
                              , $0 = n.canHydrateTextInstance
                              , ey = n.canHydrateSuspenseInstance
                              , Ux = n.hydrateInstance
                              , ty = n.hydrateTextInstance
                              , Lu = n.hydrateSuspenseInstance
                              , ny = n.getNextHydratableInstanceAfterSuspenseInstance
                              , Vd = n.commitHydratedContainer
                              , kd = n.commitHydratedSuspenseInstance
                              , iy = n.clearSuspenseBoundary
                              , Mv = n.clearSuspenseBoundaryFromContainer
                              , sy = n.shouldDeleteUnhydratedTailInstances;
                            n.diffHydratedPropsForDevWarnings,
                            n.diffHydratedTextForDevWarnings,
                            n.describeHydratableInstanceForDevWarnings;
                            var ay = n.validateHydratableInstance
                              , ry = n.validateHydratableTextInstance
                              , Ga = n.supportsResources
                              , bv = n.isHostHoistableType
                              , Xd = n.getHoistableRoot
                              , Wd = n.getResource
                              , Ev = n.acquireResource
                              , Cv = n.releaseResource
                              , wv = n.hydrateHoistable
                              , Dv = n.mountHoistable
                              , Rv = n.unmountHoistable
                              , Ox = n.createHoistableInstance
                              , Uv = n.prepareToCommitHoistables
                              , oy = n.mayResourceSuspendCommit
                              , Ov = n.preloadResource
                              , Nv = n.suspendResource
                              , Es = n.supportsSingletons
                              , Bv = n.resolveSingletonInstance
                              , Nx = n.clearSingleton
                              , Bx = n.acquireSingletonInstance
                              , ly = n.releaseSingletonInstance
                              , Iu = n.isHostSingletonType
                              , jh = []
                              , Qo = -1
                              , Ic = {}
                              , ma = Math.clz32 ? Math.clz32 : U
                              , Qh = Math.log
                              , cy = Math.LN2
                              , Pu = 128
                              , Zh = 4194304
                              , zu = Ms.unstable_scheduleCallback
                              , Kh = Ms.unstable_cancelCallback
                              , uy = Ms.unstable_shouldYield
                              , hy = Ms.unstable_requestPaint
                              , Cs = Ms.unstable_now
                              , fy = Ms.unstable_ImmediatePriority
                              , Lx = Ms.unstable_UserBlockingPriority
                              , Lv = Ms.unstable_NormalPriority
                              , Yd = Ms.unstable_IdlePriority
                              , dy = Ms.log
                              , Iv = Ms.unstable_setDisableYieldValue
                              , Fu = null
                              , va = null
                              , Va = typeof Object.is == "function" ? Object.is : Z
                              , qd = new WeakMap
                              , fi = []
                              , Ei = 0
                              , Jh = null
                              , $h = 0
                              , ka = []
                              , Xa = 0
                              , Hr = null
                              , yo = 1
                              , dr = ""
                              , ds = T(null)
                              , ef = T(null)
                              , Gr = T(null)
                              , Hu = T(null)
                              , Gs = null
                              , ws = null
                              , En = !1
                              , Wa = null
                              , pr = !1
                              , tf = Error(a(519))
                              , Ya = []
                              , Zl = 0
                              , Gu = 0
                              , Vu = null
                              , Pc = null
                              , nf = !1
                              , sf = !1
                              , Vr = !1
                              , Kl = 0
                              , af = null
                              , jd = 0
                              , ga = 0
                              , Jl = null
                              , Zo = !1
                              , ku = !1
                              , rf = Object.prototype.hasOwnProperty
                              , Yn = Error(a(460))
                              , Pv = Error(a(474))
                              , Qd = {
                                then: function() {}
                            }
                              , zc = null
                              , _o = null
                              , mr = 0
                              , $l = On(!0)
                              , zv = On(!1)
                              , So = T(null)
                              , qa = T(0)
                              , ja = T(null)
                              , vr = null
                              , ji = T(0)
                              , xo = 0
                              , $t = null
                              , Bn = null
                              , Li = null
                              , gr = !1
                              , di = !1
                              , Ko = !1
                              , of = 0
                              , Ci = 0
                              , Xu = null
                              , py = 0
                              , Zd = function() {
                                return {
                                    lastEffect: null,
                                    events: null,
                                    stores: null,
                                    memoCache: null
                                }
                            }
                              , Cn = {
                                readContext: Ts,
                                use: yt,
                                useCallback: Qt,
                                useContext: Qt,
                                useEffect: Qt,
                                useImperativeHandle: Qt,
                                useLayoutEffect: Qt,
                                useInsertionEffect: Qt,
                                useMemo: Qt,
                                useReducer: Qt,
                                useRef: Qt,
                                useState: Qt,
                                useDebugValue: Qt,
                                useDeferredValue: Qt,
                                useTransition: Qt,
                                useSyncExternalStore: Qt,
                                useId: Qt
                            };
                            Cn.useCacheRefresh = Qt,
                            Cn.useMemoCache = Qt,
                            Cn.useHostTransitionStatus = Qt,
                            Cn.useFormState = Qt,
                            Cn.useActionState = Qt,
                            Cn.useOptimistic = Qt;
                            var Qi = {
                                readContext: Ts,
                                use: yt,
                                useCallback: function(h, d) {
                                    return Ue().memoizedState = [h, d === void 0 ? null : d],
                                    h
                                },
                                useContext: Ts,
                                useEffect: mu,
                                useImperativeHandle: function(h, d, _) {
                                    _ = _ != null ? _.concat([h]) : null,
                                    xl(4194308, 4, Dr.bind(null, d, h), _)
                                },
                                useLayoutEffect: function(h, d) {
                                    return xl(4194308, 4, h, d)
                                },
                                useInsertionEffect: function(h, d) {
                                    xl(4, 2, h, d)
                                },
                                useMemo: function(h, d) {
                                    var _ = Ue();
                                    d = d === void 0 ? null : d;
                                    var E = h();
                                    if (Ko) {
                                        V(!0);
                                        try {
                                            h()
                                        } finally {
                                            V(!1)
                                        }
                                    }
                                    return _.memoizedState = [E, d],
                                    E
                                },
                                useReducer: function(h, d, _) {
                                    var E = Ue();
                                    if (_ !== void 0) {
                                        var R = _(d);
                                        if (Ko) {
                                            V(!0);
                                            try {
                                                _(d)
                                            } finally {
                                                V(!1)
                                            }
                                        }
                                    } else
                                        R = d;
                                    return E.memoizedState = E.baseState = R,
                                    h = {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: h,
                                        lastRenderedState: R
                                    },
                                    E.queue = h,
                                    h = h.dispatch = cr.bind(null, $t, h),
                                    [E.memoizedState, h]
                                },
                                useRef: function(h) {
                                    var d = Ue();
                                    return h = {
                                        current: h
                                    },
                                    d.memoizedState = h
                                },
                                useState: function(h) {
                                    h = vn(h);
                                    var d = h.queue
                                      , _ = Sc.bind(null, $t, d);
                                    return d.dispatch = _,
                                    [h.memoizedState, _]
                                },
                                useDebugValue: Rr,
                                useDeferredValue: function(h, d) {
                                    var _ = Ue();
                                    return Or(_, h, d)
                                },
                                useTransition: function() {
                                    var h = vn(!1);
                                    return h = Ml.bind(null, $t, h.queue, !0, !1),
                                    Ue().memoizedState = h,
                                    [!1, h]
                                },
                                useSyncExternalStore: function(h, d, _) {
                                    var E = $t
                                      , R = Ue();
                                    if (En) {
                                        if (_ === void 0)
                                            throw Error(a(407));
                                        _ = _()
                                    } else {
                                        if (_ = d(),
                                        cn === null)
                                            throw Error(a(349));
                                        (rn & 60) !== 0 || bn(E, d, _)
                                    }
                                    R.memoizedState = _;
                                    var P = {
                                        value: _,
                                        getSnapshot: d
                                    };
                                    return R.queue = P,
                                    mu(Wn.bind(null, E, P, h), [h]),
                                    E.flags |= 2048,
                                    no(9, _n.bind(null, E, P, _, d), {
                                        destroy: void 0
                                    }, null),
                                    _
                                },
                                useId: function() {
                                    var h = Ue()
                                      , d = cn.identifierPrefix;
                                    if (En) {
                                        var _ = dr
                                          , E = yo;
                                        _ = (E & ~(1 << 32 - ma(E) - 1)).toString(32) + _,
                                        d = ":" + d + "R" + _,
                                        _ = of++,
                                        0 < _ && (d += "H" + _.toString(32)),
                                        d += ":"
                                    } else
                                        _ = py++,
                                        d = ":" + d + "r" + _.toString(32) + ":";
                                    return h.memoizedState = d
                                },
                                useCacheRefresh: function() {
                                    return Ue().memoizedState = bl.bind(null, $t)
                                }
                            };
                            Qi.useMemoCache = pt,
                            Qi.useHostTransitionStatus = es,
                            Qi.useFormState = qn,
                            Qi.useActionState = qn,
                            Qi.useOptimistic = function(h) {
                                var d = Ue();
                                d.memoizedState = d.baseState = h;
                                var _ = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: null,
                                    lastRenderedState: null
                                };
                                return d.queue = _,
                                d = ao.bind(null, $t, !0, _),
                                _.dispatch = d,
                                [h, d]
                            }
                            ;
                            var Vs = {
                                readContext: Ts,
                                use: yt,
                                useCallback: Al,
                                useContext: Ts,
                                useEffect: so,
                                useImperativeHandle: Ba,
                                useInsertionEffect: Bo,
                                useLayoutEffect: Lo,
                                useMemo: Ur,
                                useReducer: Lt,
                                useRef: io,
                                useState: function() {
                                    return Lt(St)
                                },
                                useDebugValue: Rr,
                                useDeferredValue: function(h, d) {
                                    var _ = ce();
                                    return Tl(_, Bn.memoizedState, h, d)
                                },
                                useTransition: function() {
                                    var h = Lt(St)[0]
                                      , d = ce().memoizedState;
                                    return [typeof h == "boolean" ? h : at(h), d]
                                },
                                useSyncExternalStore: Kt,
                                useId: la
                            };
                            Vs.useCacheRefresh = _c,
                            Vs.useMemoCache = pt,
                            Vs.useHostTransitionStatus = es,
                            Vs.useFormState = ls,
                            Vs.useActionState = ls,
                            Vs.useOptimistic = function(h, d) {
                                var _ = ce();
                                return Ht(_, Bn, h, d)
                            }
                            ;
                            var ec = {
                                readContext: Ts,
                                use: yt,
                                useCallback: Al,
                                useContext: Ts,
                                useEffect: so,
                                useImperativeHandle: Ba,
                                useInsertionEffect: Bo,
                                useLayoutEffect: Lo,
                                useMemo: Ur,
                                useReducer: Dt,
                                useRef: io,
                                useState: function() {
                                    return Dt(St)
                                },
                                useDebugValue: Rr,
                                useDeferredValue: function(h, d) {
                                    var _ = ce();
                                    return Bn === null ? Or(_, h, d) : Tl(_, Bn.memoizedState, h, d)
                                },
                                useTransition: function() {
                                    var h = Dt(St)[0]
                                      , d = ce().memoizedState;
                                    return [typeof h == "boolean" ? h : at(h), d]
                                },
                                useSyncExternalStore: Kt,
                                useId: la
                            };
                            ec.useCacheRefresh = _c,
                            ec.useMemoCache = pt,
                            ec.useHostTransitionStatus = es,
                            ec.useFormState = yc,
                            ec.useActionState = yc,
                            ec.useOptimistic = function(h, d) {
                                var _ = ce();
                                return Bn !== null ? Ht(_, Bn, h, d) : (_.baseState = h,
                                [h, _.queue.dispatch])
                            }
                            ;
                            var Kd = {
                                isMounted: function(h) {
                                    return (h = h._reactInternals) ? y(h) === h : !1
                                },
                                enqueueSetState: function(h, d, _) {
                                    h = h._reactInternals;
                                    var E = Ks()
                                      , R = Je(E);
                                    R.payload = d,
                                    _ != null && (R.callback = _),
                                    d = Ze(h, R, E),
                                    d !== null && (zs(d, h, E),
                                    ht(d, h, E))
                                },
                                enqueueReplaceState: function(h, d, _) {
                                    h = h._reactInternals;
                                    var E = Ks()
                                      , R = Je(E);
                                    R.tag = 1,
                                    R.payload = d,
                                    _ != null && (R.callback = _),
                                    d = Ze(h, R, E),
                                    d !== null && (zs(d, h, E),
                                    ht(d, h, E))
                                },
                                enqueueForceUpdate: function(h, d) {
                                    h = h._reactInternals;
                                    var _ = Ks()
                                      , E = Je(_);
                                    E.tag = 2,
                                    d != null && (E.callback = d),
                                    d = Ze(h, E, _),
                                    d !== null && (zs(d, h, _),
                                    ht(d, h, _))
                                }
                            }
                              , Fv = typeof reportError == "function" ? reportError : function(h) {
                                if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                    var d = new window.ErrorEvent("error",{
                                        bubbles: !0,
                                        cancelable: !0,
                                        message: typeof h == "object" && h !== null && typeof h.message == "string" ? String(h.message) : String(h),
                                        error: h
                                    });
                                    if (!window.dispatchEvent(d))
                                        return
                                } else if (typeof process == "object" && typeof process.emit == "function") {
                                    process.emit("uncaughtException", h);
                                    return
                                }
                                console.error(h)
                            }
                              , my = Error(a(461))
                              , Ii = !1
                              , ks = {
                                dehydrated: null,
                                treeContext: null,
                                retryLane: 0
                            }
                              , ya = T(null)
                              , tc = null
                              , wi = null
                              , vy = typeof AbortController < "u" ? AbortController : function() {
                                var h = []
                                  , d = this.signal = {
                                    aborted: !1,
                                    addEventListener: function(_, E) {
                                        h.push(E)
                                    }
                                };
                                this.abort = function() {
                                    d.aborted = !0,
                                    h.forEach(function(_) {
                                        return _()
                                    })
                                }
                            }
                              , Jo = Ms.unstable_scheduleCallback
                              , Fc = Ms.unstable_NormalPriority
                              , Pn = {
                                $$typeof: po,
                                Consumer: null,
                                Provider: null,
                                _currentValue: null,
                                _currentValue2: null,
                                _threadCount: 0
                            }
                              , Jd = Ft.S;
                            Ft.S = function(h, d) {
                                typeof d == "object" && d !== null && typeof d.then == "function" && rt(h, d),
                                Jd !== null && Jd(h, d)
                            }
                            ;
                            var $o = T(null)
                              , is = !1
                              , _i = !1
                              , nc = !1
                              , Wu = typeof WeakSet == "function" ? WeakSet : Set
                              , Di = null
                              , Hc = !1
                              , Pi = null
                              , _a = !1
                              , ea = null
                              , Gc = 8192
                              , $d = {
                                getCacheForType: function(h) {
                                    var d = Ts(Pn)
                                      , _ = d.data.get(h);
                                    return _ === void 0 && (_ = h(),
                                    d.data.set(h, _)),
                                    _
                                }
                            }
                              , lf = 0
                              , ep = 1
                              , tp = 2
                              , Sn = 3
                              , zn = 4;
                            if (typeof Symbol == "function" && Symbol.for) {
                                var en = Symbol.for;
                                lf = en("selector.component"),
                                ep = en("selector.has_pseudo_class"),
                                tp = en("selector.role"),
                                Sn = en("selector.test_id"),
                                zn = en("selector.text")
                            }
                            var mn = typeof WeakMap == "function" ? WeakMap : Map
                              , Pt = 0
                              , cn = null
                              , jt = null
                              , rn = 0
                              , Qn = 0
                              , zi = null
                              , Fn = !1
                              , Qa = !1
                              , el = !1
                              , kr = 0
                              , xn = 0
                              , Za = 0
                              , Xr = 0
                              , Xs = 0
                              , Sa = 0
                              , tl = 0
                              , Yu = null
                              , Ka = null
                              , qu = !1
                              , Ao = 0
                              , Si = 1 / 0
                              , Wr = null
                              , Ja = null
                              , yr = !1
                              , nl = null
                              , Vc = 0
                              , np = 0
                              , kc = null
                              , Xc = 0
                              , xa = null;
                            return It.attemptContinuousHydration = function(h) {
                                if (h.tag === 13) {
                                    var d = Te(h, 67108864);
                                    d !== null && zs(d, h, 67108864),
                                    $m(h, 67108864)
                                }
                            }
                            ,
                            It.attemptHydrationAtCurrentPriority = function(h) {
                                if (h.tag === 13) {
                                    var d = Ks()
                                      , _ = Te(h, d);
                                    _ !== null && zs(_, h, d),
                                    $m(h, d)
                                }
                            }
                            ,
                            It.attemptSynchronousHydration = function(h) {
                                switch (h.tag) {
                                case 3:
                                    if (h = h.stateNode,
                                    h.current.memoizedState.isDehydrated) {
                                        var d = O(h.pendingLanes);
                                        if (d !== 0) {
                                            for (h.pendingLanes |= 2,
                                            h.entangledLanes |= 2; d; ) {
                                                var _ = 1 << 31 - ma(d);
                                                h.entanglements[1] |= _,
                                                d &= ~_
                                            }
                                            it(h),
                                            (Pt & 6) === 0 && (Si = Cs() + 500,
                                            je(0, !1))
                                        }
                                    }
                                    break;
                                case 13:
                                    d = Te(h, 2),
                                    d !== null && zs(d, h, 2),
                                    jm(),
                                    $m(h, 2)
                                }
                            }
                            ,
                            It.batchedUpdates = function(h, d) {
                                return h(d)
                            }
                            ,
                            It.createComponentSelector = function(h) {
                                return {
                                    $$typeof: lf,
                                    value: h
                                }
                            }
                            ,
                            It.createContainer = function(h, d, _, E, R, P, ne, me, Ce, et) {
                                return fs(h, d, !1, null, _, E, P, ne, me, Ce, et, null)
                            }
                            ,
                            It.createHasPseudoClassSelector = function(h) {
                                return {
                                    $$typeof: ep,
                                    value: h
                                }
                            }
                            ,
                            It.createHydrationContainer = function(h, d, _, E, R, P, ne, me, Ce, et, mt, Tt, bt) {
                                return h = fs(_, E, !0, h, R, P, me, Ce, et, mt, Tt, bt),
                                h.context = zh(null),
                                _ = h.current,
                                E = Ks(),
                                R = Je(E),
                                R.callback = d ?? null,
                                Ze(_, R, E),
                                h.current.lanes = E,
                                X(h, E),
                                it(h),
                                h
                            }
                            ,
                            It.createPortal = function(h, d, _) {
                                var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                                return {
                                    $$typeof: zr,
                                    key: E == null ? null : "" + E,
                                    children: h,
                                    containerInfo: d,
                                    implementation: _
                                }
                            }
                            ,
                            It.createRoleSelector = function(h) {
                                return {
                                    $$typeof: tp,
                                    value: h
                                }
                            }
                            ,
                            It.createTestNameSelector = function(h) {
                                return {
                                    $$typeof: Sn,
                                    value: h
                                }
                            }
                            ,
                            It.createTextSelector = function(h) {
                                return {
                                    $$typeof: zn,
                                    value: h
                                }
                            }
                            ,
                            It.defaultOnCaughtError = function(h) {
                                console.error(h)
                            }
                            ,
                            It.defaultOnRecoverableError = function(h) {
                                Fv(h)
                            }
                            ,
                            It.defaultOnUncaughtError = function(h) {
                                Fv(h)
                            }
                            ,
                            It.deferredUpdates = function(h) {
                                var d = Ft.T
                                  , _ = ns();
                                try {
                                    return Hs(32),
                                    Ft.T = null,
                                    h()
                                } finally {
                                    Hs(_),
                                    Ft.T = d
                                }
                            }
                            ,
                            It.discreteUpdates = function(h, d, _, E, R) {
                                var P = Ft.T
                                  , ne = ns();
                                try {
                                    return Hs(2),
                                    Ft.T = null,
                                    h(d, _, E, R)
                                } finally {
                                    Hs(ne),
                                    Ft.T = P,
                                    Pt === 0 && (Si = Cs() + 500)
                                }
                            }
                            ,
                            It.findAllNodes = Zs,
                            It.findBoundingRects = function(h, d) {
                                if (!vo)
                                    throw Error(a(363));
                                d = Zs(h, d),
                                h = [];
                                for (var _ = 0; _ < d.length; _++)
                                    h.push(Id(d[_]));
                                for (d = h.length - 1; 0 < d; d--) {
                                    _ = h[d];
                                    for (var E = _.x, R = E + _.width, P = _.y, ne = P + _.height, me = d - 1; 0 <= me; me--)
                                        if (d !== me) {
                                            var Ce = h[me]
                                              , et = Ce.x
                                              , mt = et + Ce.width
                                              , Tt = Ce.y
                                              , bt = Tt + Ce.height;
                                            if (E >= et && P >= Tt && R <= mt && ne <= bt) {
                                                h.splice(d, 1);
                                                break
                                            } else if (E !== et || _.width !== Ce.width || bt < P || Tt > ne) {
                                                if (!(P !== Tt || _.height !== Ce.height || mt < E || et > R)) {
                                                    et > E && (Ce.width += et - E,
                                                    Ce.x = E),
                                                    mt < R && (Ce.width = R - et),
                                                    h.splice(d, 1);
                                                    break
                                                }
                                            } else {
                                                Tt > P && (Ce.height += Tt - P,
                                                Ce.y = P),
                                                bt < ne && (Ce.height = ne - Tt),
                                                h.splice(d, 1);
                                                break
                                            }
                                        }
                                }
                                return h
                            }
                            ,
                            It.findHostInstance = Jm,
                            It.findHostInstanceWithNoPortals = function(h) {
                                return h = A(h),
                                h = h !== null ? x(h) : null,
                                h === null ? null : Bu(h.stateNode)
                            }
                            ,
                            It.findHostInstanceWithWarning = function(h) {
                                return Jm(h)
                            }
                            ,
                            It.flushPassiveEffects = hs,
                            It.flushSyncFromReconciler = function(h) {
                                var d = Pt;
                                Pt |= 1;
                                var _ = Ft.T
                                  , E = ns();
                                try {
                                    if (Hs(2),
                                    Ft.T = null,
                                    h)
                                        return h()
                                } finally {
                                    Hs(E),
                                    Ft.T = _,
                                    Pt = d,
                                    (Pt & 6) === 0 && je(0, !1)
                                }
                            }
                            ,
                            It.flushSyncWork = jm,
                            It.focusWithin = function(h, d) {
                                if (!vo)
                                    throw Error(a(363));
                                for (h = Md(h),
                                d = L0(h, d),
                                d = Array.from(d),
                                h = 0; h < d.length; ) {
                                    var _ = d[h++]
                                      , E = _.tag;
                                    if (!go(_)) {
                                        if ((E === 5 || E === 26 || E === 27) && bi(_.stateNode))
                                            return !0;
                                        for (_ = _.child; _ !== null; )
                                            d.push(_),
                                            _ = _.sibling
                                    }
                                }
                                return !1
                            }
                            ,
                            It.getFindAllNodesFailureDescription = function(h, d) {
                                if (!vo)
                                    throw Error(a(363));
                                var _ = 0
                                  , E = [];
                                h = [Md(h), 0];
                                for (var R = 0; R < h.length; ) {
                                    var P = h[R++]
                                      , ne = P.tag
                                      , me = h[R++]
                                      , Ce = d[me];
                                    if ((ne !== 5 && ne !== 26 && ne !== 27 || !go(P)) && (Du(P, Ce) && (E.push(Fl(Ce)),
                                    me++,
                                    me > _ && (_ = me)),
                                    me < d.length))
                                        for (P = P.child; P !== null; )
                                            h.push(P, me),
                                            P = P.sibling
                                }
                                if (_ < d.length) {
                                    for (h = []; _ < d.length; _++)
                                        h.push(Fl(d[_]));
                                    return `findAllNodes was able to match part of the selector:
  ` + (E.join(" > ") + `

No matching component was found for:
  `) + h.join(" > ")
                                }
                                return null
                            }
                            ,
                            It.getPublicRootInstance = function(h) {
                                if (h = h.current,
                                !h.child)
                                    return null;
                                switch (h.child.tag) {
                                case 27:
                                case 5:
                                    return Bu(h.child.stateNode);
                                default:
                                    return h.child.stateNode
                                }
                            }
                            ,
                            It.injectIntoDevTools = function() {
                                var h = {
                                    bundleType: 0,
                                    version: Od,
                                    rendererPackageName: Gh,
                                    currentDispatcherRef: Ft,
                                    findFiberByHostInstance: cv,
                                    reconcilerVersion: "19.0.0"
                                };
                                if (Vh !== null && (h.rendererConfig = Vh),
                                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
                                    h = !1;
                                else {
                                    var d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                                    if (d.isDisabled || !d.supportsFiber)
                                        h = !0;
                                    else {
                                        try {
                                            Fu = d.inject(h),
                                            va = d
                                        } catch {}
                                        h = !!d.checkDCE
                                    }
                                }
                                return h
                            }
                            ,
                            It.isAlreadyRendering = function() {
                                return !1
                            }
                            ,
                            It.observeVisibleRects = function(h, d, _, E) {
                                if (!vo)
                                    throw Error(a(363));
                                h = Zs(h, d);
                                var R = fv(h, _, E).disconnect;
                                return {
                                    disconnect: function() {
                                        R()
                                    }
                                }
                            }
                            ,
                            It.shouldError = function() {
                                return null
                            }
                            ,
                            It.shouldSuspend = function() {
                                return !1
                            }
                            ,
                            It.startHostTransition = function(h, d, _, E) {
                                if (h.tag !== 5)
                                    throw Error(a(476));
                                var R = vu(h).queue;
                                Ml(h, R, d, pa, _ === null ? s : function() {
                                    var P = vu(h).next.queue;
                                    return Nr(h, P, {}, Ks()),
                                    _(E)
                                }
                                )
                            }
                            ,
                            It.updateContainer = function(h, d, _, E) {
                                var R = d.current
                                  , P = Ks();
                                return z0(R, P, h, d, _, E),
                                P
                            }
                            ,
                            It.updateContainerSync = function(h, d, _, E) {
                                return d.tag === 0 && hs(),
                                z0(d.current, 2, h, d, _, E),
                                2
                            }
                            ,
                            It
                        }
                        ,
                        t.exports.default = t.exports,
                        Object.defineProperty(t.exports, "__esModule", {
                            value: !0
                        })
                    }
                    )
                })
                  , b1 = un({
                    "node_modules/react-reconciler/index.js": ( (e, t) => {
                        t.exports = zz()
                    }
                    )
                })
                  , Fz = un({
                    "node_modules/react/cjs/react-jsx-runtime.production.js": (e => {
                        var t = Symbol.for("react.transitional.element")
                          , n = Symbol.for("react.fragment");
                        function i(s, a, o) {
                            var c = null;
                            if (o !== void 0 && (c = "" + o),
                            a.key !== void 0 && (c = "" + a.key),
                            "key"in a) {
                                o = {};
                                for (var u in a)
                                    u !== "key" && (o[u] = a[u])
                            } else
                                o = a;
                            return a = o.ref,
                            {
                                $$typeof: t,
                                type: s,
                                key: c,
                                ref: a !== void 0 ? a : null,
                                props: o
                            }
                        }
                        e.Fragment = n,
                        e.jsx = i,
                        e.jsxs = i
                    }
                    )
                })
                  , Hz = un({
                    "node_modules/react/jsx-runtime.js": ( (e, t) => {
                        t.exports = Fz()
                    }
                    )
                })
                  , vt = _r(Hz())
                  , Gz = _r(b1())
                  , E1 = _r(sM());
                const UX = ( () => {
                    var e, t;
                    return typeof window < "u" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative")
                }
                )() ? We.useLayoutEffect : We.useEffect;
                function aM(e, t, n) {
                    if (!e)
                        return;
                    if (n(e) === !0)
                        return e;
                    let i = t ? e.return : e.child;
                    for (; i; ) {
                        const s = aM(i, t, n);
                        if (s)
                            return s;
                        i = t ? null : i.sibling
                    }
                }
                function C1(e) {
                    try {
                        return Object.defineProperties(e, {
                            _currentRenderer: {
                                get() {
                                    return null
                                },
                                set() {}
                            },
                            _currentRenderer2: {
                                get() {
                                    return null
                                },
                                set() {}
                            }
                        })
                    } catch {
                        return e
                    }
                }
                const rM = C1(We.createContext(null));
                var w1 = class extends We.Component {
                    render() {
                        return We.createElement(rM.Provider, {
                            value: this._reactInternals
                        }, this.props.children)
                    }
                }
                ;
                function D1() {
                    const e = We.useContext(rM);
                    if (e === null)
                        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
                    const t = We.useId();
                    return We.useMemo( () => {
                        for (const n of [e, e?.alternate]) {
                            if (!n)
                                continue;
                            const i = aM(n, !1, s => {
                                let a = s.memoizedState;
                                for (; a; ) {
                                    if (a.memoizedState === t)
                                        return !0;
                                    a = a.next
                                }
                            }
                            );
                            if (i)
                                return i
                        }
                    }
                    , [e, t])
                }
                const Vz = Symbol.for("react.context")
                  , kz = e => e !== null && typeof e == "object" && "$$typeof"in e && e.$$typeof === Vz;
                function Xz() {
                    const e = D1()
                      , [t] = We.useState( () => new Map);
                    t.clear();
                    let n = e;
                    for (; n; ) {
                        const i = n.type;
                        kz(i) && i !== rM && !t.has(i) && t.set(i, We.use(C1(i))),
                        n = n.return
                    }
                    return t
                }
                function Wz() {
                    const e = Xz();
                    return We.useMemo( () => Array.from(e.keys()).reduce( (t, n) => i => We.createElement(t, null, We.createElement(n.Provider, {
                        ...i,
                        value: e.get(n)
                    })), t => We.createElement(w1, {
                        ...t
                    })), [e])
                }
                function R1(e) {
                    let t = e.root;
                    for (; t.getState().previousRoot; )
                        t = t.getState().previousRoot;
                    return t
                }
                const OX = We.act
                  , U1 = e => e && e.isOrthographicCamera
                  , Yz = e => e && e.hasOwnProperty("current")
                  , qz = e => e != null && (typeof e == "string" || typeof e == "number" || e.isColor)
                  , Qg = ( (e, t) => typeof window < "u" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative"))() ? We.useLayoutEffect : We.useEffect;
                function oM(e) {
                    const t = We.useRef(e);
                    return Qg( () => void (t.current = e), [e]),
                    t
                }
                function jz() {
                    const e = D1()
                      , t = Wz();
                    return We.useMemo( () => ({children: n}) => {
                        const i = aM(e, !0, s => s.type === We.StrictMode) ? We.StrictMode : We.Fragment;
                        return (0,
                        vt.jsx)(i, {
                            children: (0,
                            vt.jsx)(t, {
                                children: n
                            })
                        })
                    }
                    , [e, t])
                }
                function Qz({set: e}) {
                    return Qg( () => (e(new Promise( () => null)),
                    () => e(!1)), [e]),
                    null
                }
                const Zz = (e => (e = class extends We.Component {
                    constructor(...n) {
                        super(...n),
                        this.state = {
                            error: !1
                        }
                    }
                    componentDidCatch(n) {
                        this.props.set(n)
                    }
                    render() {
                        return this.state.error ? null : this.props.children
                    }
                }
                ,
                e.getDerivedStateFromError = () => ({
                    error: !0
                }),
                e))();
                function O1(e) {
                    var t;
                    const n = typeof window < "u" ? (t = window.devicePixelRatio) != null ? t : 2 : 1;
                    return Array.isArray(e) ? Math.min(Math.max(e[0], n), e[1]) : e
                }
                function $p(e) {
                    var t;
                    return (t = e.__r3f) == null ? void 0 : t.root.getState()
                }
                const Ri = {
                    obj: e => e === Object(e) && !Ri.arr(e) && typeof e != "function",
                    fun: e => typeof e == "function",
                    str: e => typeof e == "string",
                    num: e => typeof e == "number",
                    boo: e => typeof e == "boolean",
                    und: e => e === void 0,
                    nul: e => e === null,
                    arr: e => Array.isArray(e),
                    equ(e, t, {arrays: n="shallow", objects: i="reference", strict: s=!0}={}) {
                        if (typeof e != typeof t || !!e != !!t)
                            return !1;
                        if (Ri.str(e) || Ri.num(e) || Ri.boo(e))
                            return e === t;
                        const a = Ri.obj(e);
                        if (a && i === "reference")
                            return e === t;
                        const o = Ri.arr(e);
                        if (o && n === "reference")
                            return e === t;
                        if ((o || a) && e === t)
                            return !0;
                        let c;
                        for (c in e)
                            if (!(c in t))
                                return !1;
                        if (a && n === "shallow" && i === "shallow") {
                            for (c in s ? t : e)
                                if (!Ri.equ(e[c], t[c], {
                                    strict: s,
                                    objects: "reference"
                                }))
                                    return !1
                        } else
                            for (c in s ? t : e)
                                if (e[c] !== t[c])
                                    return !1;
                        if (Ri.und(c)) {
                            if (o && e.length === 0 && t.length === 0 || a && Object.keys(e).length === 0 && Object.keys(t).length === 0)
                                return !0;
                            if (e !== t)
                                return !1
                        }
                        return !0
                    }
                };
                function Kz(e) {
                    const t = {
                        nodes: {},
                        materials: {},
                        meshes: {}
                    };
                    return e && e.traverse(n => {
                        n.name && (t.nodes[n.name] = n),
                        n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material),
                        n.isMesh && !t.meshes[n.name] && (t.meshes[n.name] = n)
                    }
                    ),
                    t
                }
                function Jz(e) {
                    e.type !== "Scene" && (e.dispose == null || e.dispose());
                    for (const t in e) {
                        const n = e[t];
                        n?.type !== "Scene" && (n == null || n.dispose == null || n.dispose())
                    }
                }
                const N1 = ["children", "key", "ref"];
                function $z(e) {
                    const t = {};
                    for (const n in e)
                        N1.includes(n) || (t[n] = e[n]);
                    return t
                }
                function wS(e, t, n, i) {
                    const s = e;
                    let a = s?.__r3f;
                    return a || (a = {
                        root: t,
                        type: n,
                        parent: null,
                        children: [],
                        props: $z(i),
                        object: s,
                        eventCount: 0,
                        handlers: {},
                        isHidden: !1
                    },
                    s && (s.__r3f = a)),
                    a
                }
                function Zg(e, t) {
                    let n = e[t];
                    if (!t.includes("-"))
                        return {
                            root: e,
                            key: t,
                            target: n
                        };
                    n = e;
                    for (const s of t.split("-")) {
                        var i;
                        t = s,
                        e = n,
                        n = (i = n) == null ? void 0 : i[t]
                    }
                    return {
                        root: e,
                        key: t,
                        target: n
                    }
                }
                const B1 = /-\d+$/;
                function DS(e, t) {
                    if (Ri.str(t.props.attach)) {
                        if (B1.test(t.props.attach)) {
                            const s = t.props.attach.replace(B1, "")
                              , {root: a, key: o} = Zg(e.object, s);
                            Array.isArray(a[o]) || (a[o] = [])
                        }
                        const {root: n, key: i} = Zg(e.object, t.props.attach);
                        t.previousAttach = n[i],
                        n[i] = t.object
                    } else
                        Ri.fun(t.props.attach) && (t.previousAttach = t.props.attach(e.object, t.object))
                }
                function RS(e, t) {
                    if (Ri.str(t.props.attach)) {
                        const {root: n, key: i} = Zg(e.object, t.props.attach)
                          , s = t.previousAttach;
                        s === void 0 ? delete n[i] : n[i] = s
                    } else
                        t.previousAttach == null || t.previousAttach(e.object, t.object);
                    delete t.previousAttach
                }
                const lM = [...N1, "args", "dispose", "attach", "object", "onUpdate", "dispose"]
                  , L1 = new Map;
                function eF(e) {
                    let t = L1.get(e.constructor);
                    try {
                        t || (t = new e.constructor,
                        L1.set(e.constructor, t))
                    } catch {}
                    return t
                }
                function tF(e, t) {
                    const n = {};
                    for (const i in t)
                        if (!lM.includes(i) && !Ri.equ(t[i], e.props[i])) {
                            n[i] = t[i];
                            for (const s in t)
                                s.startsWith(`${i}-`) && (n[s] = t[s])
                        }
                    for (const i in e.props) {
                        if (lM.includes(i) || t.hasOwnProperty(i))
                            continue;
                        const {root: s, key: a} = Zg(e.object, i);
                        if (s.constructor && s.constructor.length === 0) {
                            const o = eF(s);
                            Ri.und(o) || (n[a] = o[a])
                        } else
                            n[a] = 0
                    }
                    return n
                }
                const nF = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"]
                  , iF = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
                function yh(e, t) {
                    var n;
                    const i = e.__r3f
                      , s = i && R1(i).getState()
                      , a = i?.eventCount;
                    for (const c in t) {
                        let u = t[c];
                        if (lM.includes(c))
                            continue;
                        if (i && iF.test(c)) {
                            typeof u == "function" ? i.handlers[c] = u : delete i.handlers[c],
                            i.eventCount = Object.keys(i.handlers).length;
                            continue
                        }
                        if (u === void 0)
                            continue;
                        let {root: f, key: m, target: v} = Zg(e, c);
                        if (v instanceof wp && u instanceof wp)
                            v.mask = u.mask;
                        else if (v instanceof ft && qz(u))
                            v.set(u);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && typeof v.copy == "function" && u != null && u.constructor && v.constructor === u.constructor)
                            v.copy(u);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && Array.isArray(u))
                            typeof v.fromArray == "function" ? v.fromArray(u) : v.set(...u);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && typeof u == "number")
                            typeof v.setScalar == "function" ? v.setScalar(u) : v.set(u);
                        else {
                            var o;
                            f[m] = u,
                            s && !s.linear && nF.includes(m) && (o = f[m]) != null && o.isTexture && f[m].format === ps && f[m].type === gi && (f[m].colorSpace = Zt)
                        }
                    }
                    if (i != null && i.parent && s != null && s.internal && (n = i.object) != null && n.isObject3D && a !== i.eventCount) {
                        const c = i.object
                          , u = s.internal.interaction.indexOf(c);
                        u > -1 && s.internal.interaction.splice(u, 1),
                        i.eventCount && c.raycast !== null && s.internal.interaction.push(c)
                    }
                    return i && i.props.attach === void 0 && (i.object.isBufferGeometry ? i.props.attach = "geometry" : i.object.isMaterial && (i.props.attach = "material")),
                    i && em(i),
                    e
                }
                function em(e) {
                    var t;
                    if (!e.parent)
                        return;
                    e.props.onUpdate == null || e.props.onUpdate(e.object);
                    const n = (t = e.root) == null || t.getState == null ? void 0 : t.getState();
                    n && n.internal.frames === 0 && n.invalidate()
                }
                function I1(e, t) {
                    e.manual || (U1(e) ? (e.left = t.width / -2,
                    e.right = t.width / 2,
                    e.top = t.height / 2,
                    e.bottom = t.height / -2) : e.aspect = t.width / t.height,
                    e.updateProjectionMatrix())
                }
                const sr = e => e?.isObject3D;
                function US(e) {
                    return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId
                }
                function P1(e, t, n, i) {
                    const s = n.get(t);
                    s && (n.delete(t),
                    n.size === 0 && (e.delete(i),
                    s.target.releasePointerCapture(i)))
                }
                function sF(e, t) {
                    const {internal: n} = e.getState();
                    n.interaction = n.interaction.filter(i => i !== t),
                    n.initialHits = n.initialHits.filter(i => i !== t),
                    n.hovered.forEach( (i, s) => {
                        (i.eventObject === t || i.object === t) && n.hovered.delete(s)
                    }
                    ),
                    n.capturedMap.forEach( (i, s) => {
                        P1(n.capturedMap, t, i, s)
                    }
                    )
                }
                function aF(e) {
                    function t(u) {
                        const {internal: f} = e.getState()
                          , m = u.offsetX - f.initialClick[0]
                          , v = u.offsetY - f.initialClick[1];
                        return Math.round(Math.sqrt(m * m + v * v))
                    }
                    function n(u) {
                        return u.filter(f => ["Move", "Over", "Enter", "Out", "Leave"].some(m => {
                            var v;
                            return (v = f.__r3f) == null ? void 0 : v.handlers["onPointer" + m]
                        }
                        ))
                    }
                    function i(u, f) {
                        const m = e.getState()
                          , v = new Set
                          , y = []
                          , S = f ? f(m.internal.interaction) : m.internal.interaction;
                        for (let T = 0; T < S.length; T++) {
                            const D = $p(S[T]);
                            D && (D.raycaster.camera = void 0)
                        }
                        m.previousRoot || m.events.compute == null || m.events.compute(u, m);
                        function A(T) {
                            const D = $p(T);
                            if (!D || !D.events.enabled || D.raycaster.camera === null)
                                return [];
                            if (D.raycaster.camera === void 0) {
                                var w;
                                D.events.compute == null || D.events.compute(u, D, (w = D.previousRoot) == null ? void 0 : w.getState()),
                                D.raycaster.camera === void 0 && (D.raycaster.camera = null)
                            }
                            return D.raycaster.camera ? D.raycaster.intersectObject(T, !0) : []
                        }
                        let M = S.flatMap(A).sort( (T, D) => {
                            const w = $p(T.object)
                              , U = $p(D.object);
                            return !w || !U ? T.distance - D.distance : U.events.priority - w.events.priority || T.distance - D.distance
                        }
                        ).filter(T => {
                            const D = US(T);
                            return v.has(D) ? !1 : (v.add(D),
                            !0)
                        }
                        );
                        m.events.filter && (M = m.events.filter(M, m));
                        for (const T of M) {
                            let D = T.object;
                            for (; D; ) {
                                var x;
                                (x = D.__r3f) != null && x.eventCount && y.push({
                                    ...T,
                                    eventObject: D
                                }),
                                D = D.parent
                            }
                        }
                        if ("pointerId"in u && m.internal.capturedMap.has(u.pointerId))
                            for (let T of m.internal.capturedMap.get(u.pointerId).values())
                                v.has(US(T.intersection)) || y.push(T.intersection);
                        return y
                    }
                    function s(u, f, m, v) {
                        if (u.length) {
                            const y = {
                                stopped: !1
                            };
                            for (const S of u) {
                                let A = $p(S.object);
                                if (A || S.object.traverseAncestors(M => {
                                    const x = $p(M);
                                    if (x)
                                        return A = x,
                                        !1
                                }
                                ),
                                A) {
                                    const {raycaster: M, pointer: x, camera: T, internal: D} = A
                                      , w = new ae(x.x,x.y,0).unproject(T)
                                      , U = I => {
                                        var B, G;
                                        return (B = (G = D.capturedMap.get(I)) == null ? void 0 : G.has(S.eventObject)) != null ? B : !1
                                    }
                                      , O = I => {
                                        const B = {
                                            intersection: S,
                                            target: f.target
                                        };
                                        D.capturedMap.has(I) ? D.capturedMap.get(I).set(S.eventObject, B) : D.capturedMap.set(I, new Map([[S.eventObject, B]])),
                                        f.target.setPointerCapture(I)
                                    }
                                      , L = I => {
                                        const B = D.capturedMap.get(I);
                                        B && P1(D.capturedMap, S.eventObject, B, I)
                                    }
                                    ;
                                    let N = {};
                                    for (let I in f) {
                                        let B = f[I];
                                        typeof B != "function" && (N[I] = B)
                                    }
                                    let z = {
                                        ...S,
                                        ...N,
                                        pointer: x,
                                        intersections: u,
                                        stopped: y.stopped,
                                        delta: m,
                                        unprojectedPoint: w,
                                        ray: M.ray,
                                        camera: T,
                                        stopPropagation() {
                                            const I = "pointerId"in f && D.capturedMap.get(f.pointerId);
                                            if ((!I || I.has(S.eventObject)) && (z.stopped = y.stopped = !0,
                                            D.hovered.size && Array.from(D.hovered.values()).find(B => B.eventObject === S.eventObject))) {
                                                const B = u.slice(0, u.indexOf(S));
                                                a([...B, S])
                                            }
                                        },
                                        target: {
                                            hasPointerCapture: U,
                                            setPointerCapture: O,
                                            releasePointerCapture: L
                                        },
                                        currentTarget: {
                                            hasPointerCapture: U,
                                            setPointerCapture: O,
                                            releasePointerCapture: L
                                        },
                                        nativeEvent: f
                                    };
                                    if (v(z),
                                    y.stopped === !0)
                                        break
                                }
                            }
                        }
                        return u
                    }
                    function a(u) {
                        const {internal: f} = e.getState();
                        for (const m of f.hovered.values())
                            if (!u.length || !u.find(v => v.object === m.object && v.index === m.index && v.instanceId === m.instanceId)) {
                                const v = m.eventObject.__r3f;
                                if (f.hovered.delete(US(m)),
                                v != null && v.eventCount) {
                                    const y = v.handlers
                                      , S = {
                                        ...m,
                                        intersections: u
                                    };
                                    y.onPointerOut == null || y.onPointerOut(S),
                                    y.onPointerLeave == null || y.onPointerLeave(S)
                                }
                            }
                    }
                    function o(u, f) {
                        for (let m = 0; m < f.length; m++) {
                            const v = f[m].__r3f;
                            v == null || v.handlers.onPointerMissed == null || v.handlers.onPointerMissed(u)
                        }
                    }
                    function c(u) {
                        switch (u) {
                        case "onPointerLeave":
                        case "onPointerCancel":
                            return () => a([]);
                        case "onLostPointerCapture":
                            return f => {
                                const {internal: m} = e.getState();
                                "pointerId"in f && m.capturedMap.has(f.pointerId) && requestAnimationFrame( () => {
                                    m.capturedMap.has(f.pointerId) && (m.capturedMap.delete(f.pointerId),
                                    a([]))
                                }
                                )
                            }
                        }
                        return function(m) {
                            const {onPointerMissed: v, internal: y} = e.getState();
                            y.lastEvent.current = m;
                            const S = u === "onPointerMove"
                              , A = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick"
                              , M = i(m, S ? n : void 0)
                              , x = A ? t(m) : 0;
                            u === "onPointerDown" && (y.initialClick = [m.offsetX, m.offsetY],
                            y.initialHits = M.map(D => D.eventObject)),
                            A && !M.length && x <= 2 && (o(m, y.interaction),
                            v && v(m)),
                            S && a(M);
                            function T(D) {
                                const w = D.eventObject
                                  , U = w.__r3f;
                                if (!(U != null && U.eventCount))
                                    return;
                                const O = U.handlers;
                                if (S) {
                                    if (O.onPointerOver || O.onPointerEnter || O.onPointerOut || O.onPointerLeave) {
                                        const L = US(D)
                                          , N = y.hovered.get(L);
                                        N ? N.stopped && D.stopPropagation() : (y.hovered.set(L, D),
                                        O.onPointerOver == null || O.onPointerOver(D),
                                        O.onPointerEnter == null || O.onPointerEnter(D))
                                    }
                                    O.onPointerMove == null || O.onPointerMove(D)
                                } else {
                                    const L = O[u];
                                    L ? (!A || y.initialHits.includes(w)) && (o(m, y.interaction.filter(N => !y.initialHits.includes(N))),
                                    L(D)) : A && y.initialHits.includes(w) && o(m, y.interaction.filter(N => !y.initialHits.includes(N)))
                                }
                            }
                            s(M, m, x, T)
                        }
                    }
                    return {
                        handlePointer: c
                    }
                }
                const z1 = e => !!(e != null && e.render)
                  , cM = We.createContext(null)
                  , rF = (e, t) => {
                    const n = A1( (c, u) => {
                        const f = new ae
                          , m = new ae
                          , v = new ae;
                        function y(x=u().camera, T=m, D=u().size) {
                            const {width: w, height: U, top: O, left: L} = D
                              , N = w / U;
                            T.isVector3 ? v.copy(T) : v.set(...T);
                            const z = x.getWorldPosition(f).distanceTo(v);
                            if (U1(x))
                                return {
                                    width: w / x.zoom,
                                    height: U / x.zoom,
                                    top: O,
                                    left: L,
                                    factor: 1,
                                    distance: z,
                                    aspect: N
                                };
                            {
                                const I = x.fov * Math.PI / 180
                                  , B = 2 * Math.tan(I / 2) * z
                                  , G = B * (w / U);
                                return {
                                    width: G,
                                    height: B,
                                    top: O,
                                    left: L,
                                    factor: w / G,
                                    distance: z,
                                    aspect: N
                                }
                            }
                        }
                        let S;
                        const A = x => c(T => ({
                            performance: {
                                ...T.performance,
                                current: x
                            }
                        }))
                          , M = new Oe;
                        return {
                            set: c,
                            get: u,
                            gl: null,
                            camera: null,
                            raycaster: null,
                            events: {
                                priority: 1,
                                enabled: !0,
                                connected: !1
                            },
                            scene: null,
                            xr: null,
                            invalidate: (x=1) => e(u(), x),
                            advance: (x, T) => t(x, T, u()),
                            legacy: !1,
                            linear: !1,
                            flat: !1,
                            controls: null,
                            clock: new FT,
                            pointer: M,
                            mouse: M,
                            frameloop: "always",
                            onPointerMissed: void 0,
                            performance: {
                                current: 1,
                                min: .5,
                                max: 1,
                                debounce: 200,
                                regress: () => {
                                    const x = u();
                                    S && clearTimeout(S),
                                    x.performance.current !== x.performance.min && A(x.performance.min),
                                    S = setTimeout( () => A(u().performance.max), x.performance.debounce)
                                }
                            },
                            size: {
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0
                            },
                            viewport: {
                                initialDpr: 0,
                                dpr: 0,
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0,
                                aspect: 0,
                                distance: 0,
                                factor: 0,
                                getCurrentViewport: y
                            },
                            setEvents: x => c(T => ({
                                ...T,
                                events: {
                                    ...T.events,
                                    ...x
                                }
                            })),
                            setSize: (x, T, D=0, w=0) => {
                                const U = u().camera
                                  , O = {
                                    width: x,
                                    height: T,
                                    top: D,
                                    left: w
                                };
                                c(L => ({
                                    size: O,
                                    viewport: {
                                        ...L.viewport,
                                        ...y(U, m, O)
                                    }
                                }))
                            }
                            ,
                            setDpr: x => c(T => {
                                const D = O1(x);
                                return {
                                    viewport: {
                                        ...T.viewport,
                                        dpr: D,
                                        initialDpr: T.viewport.initialDpr || D
                                    }
                                }
                            }
                            ),
                            setFrameloop: (x="always") => {
                                const T = u().clock;
                                T.stop(),
                                T.elapsedTime = 0,
                                x !== "never" && (T.start(),
                                T.elapsedTime = 0),
                                c( () => ({
                                    frameloop: x
                                }))
                            }
                            ,
                            previousRoot: void 0,
                            internal: {
                                interaction: [],
                                hovered: new Map,
                                subscribers: [],
                                initialClick: [0, 0],
                                initialHits: [],
                                capturedMap: new Map,
                                lastEvent: We.createRef(),
                                active: !1,
                                frames: 0,
                                priority: 0,
                                subscribe: (x, T, D) => {
                                    const w = u().internal;
                                    return w.priority = w.priority + (T > 0 ? 1 : 0),
                                    w.subscribers.push({
                                        ref: x,
                                        priority: T,
                                        store: D
                                    }),
                                    w.subscribers = w.subscribers.sort( (U, O) => U.priority - O.priority),
                                    () => {
                                        const U = u().internal;
                                        U != null && U.subscribers && (U.priority = U.priority - (T > 0 ? 1 : 0),
                                        U.subscribers = U.subscribers.filter(O => O.ref !== x))
                                    }
                                }
                            }
                        }
                    }
                    )
                      , i = n.getState();
                    let s = i.size
                      , a = i.viewport.dpr
                      , o = i.camera;
                    return n.subscribe( () => {
                        const {camera: c, size: u, viewport: f, gl: m, set: v} = n.getState();
                        if (u.width !== s.width || u.height !== s.height || f.dpr !== a) {
                            s = u,
                            a = f.dpr,
                            I1(c, u),
                            f.dpr > 0 && m.setPixelRatio(f.dpr);
                            const y = typeof HTMLCanvasElement < "u" && m.domElement instanceof HTMLCanvasElement;
                            m.setSize(u.width, u.height, y)
                        }
                        c !== o && (o = c,
                        v(y => ({
                            viewport: {
                                ...y.viewport,
                                ...y.viewport.getCurrentViewport(c)
                            }
                        })))
                    }
                    ),
                    n.subscribe(c => e(c)),
                    n
                }
                ;
                function uM() {
                    const e = We.useContext(cM);
                    if (!e)
                        throw new Error("R3F: Hooks can only be used within the Canvas component!");
                    return e
                }
                function Ro(e=n => n, t) {
                    return uM()(e, t)
                }
                function kf(e, t=0) {
                    const n = uM()
                      , i = n.getState().internal.subscribe
                      , s = oM(e);
                    return Qg( () => i(s, t, n), [t, i, n]),
                    null
                }
                const F1 = new WeakMap
                  , oF = e => {
                    var t;
                    return typeof e == "function" && (e == null || (t = e.prototype) == null ? void 0 : t.constructor) === e
                }
                ;
                function H1(e, t) {
                    return function(n, ...i) {
                        let s;
                        return oF(n) ? (s = F1.get(n),
                        s || (s = new n,
                        F1.set(n, s))) : s = n,
                        e && e(s),
                        Promise.all(i.map(a => new Promise( (o, c) => s.load(a, u => {
                            sr(u?.scene) && Object.assign(u, Kz(u.scene)),
                            o(u)
                        }
                        , t, u => c(new Error(`Could not load ${a}: ${u?.message}`))))))
                    }
                }
                function G1(e, t, n, i) {
                    const s = Array.isArray(t) ? t : [t]
                      , a = Bz(H1(n, i), [e, ...s], {
                        equal: Ri.equ
                    });
                    return Array.isArray(t) ? a : a[0]
                }
                G1.preload = function(e, t, n) {
                    const i = Array.isArray(t) ? t : [t];
                    return Lz(H1(n), [e, ...i])
                }
                ,
                G1.clear = function(e, t) {
                    return Iz([e, ...Array.isArray(t) ? t : [t]])
                }
                ;
                function lF(e) {
                    const t = (0,
                    Gz.default)(e);
                    return t.injectIntoDevTools({
                        bundleType: 0,
                        rendererPackageName: "@react-three/fiber",
                        version: We.version
                    }),
                    t
                }
                const V1 = 0
                  , tm = {}
                  , cF = /^three(?=[A-Z])/
                  , OS = e => `${e[0].toUpperCase()}${e.slice(1)}`;
                let uF = 0;
                const hF = e => typeof e == "function";
                function hM(e) {
                    if (hF(e)) {
                        const t = `${uF++}`;
                        return tm[t] = e,
                        t
                    } else
                        Object.assign(tm, e)
                }
                function k1(e, t) {
                    const n = OS(e)
                      , i = tm[n];
                    if (e !== "primitive" && !i)
                        throw new Error(`R3F: ${n} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
                    if (e === "primitive" && !t.object)
                        throw new Error("R3F: Primitives without 'object' are invalid!");
                    if (t.args !== void 0 && !Array.isArray(t.args))
                        throw new Error("R3F: The args prop must be an array!")
                }
                function fF(e, t, n) {
                    var i;
                    return e = OS(e)in tm ? e : e.replace(cF, ""),
                    k1(e, t),
                    e === "primitive" && (i = t.object) != null && i.__r3f && delete t.object.__r3f,
                    wS(t.object, n, e, t)
                }
                function dF(e) {
                    if (!e.isHidden) {
                        var t;
                        e.props.attach && (t = e.parent) != null && t.object ? RS(e.parent, e) : sr(e.object) && (e.object.visible = !1),
                        e.isHidden = !0,
                        em(e)
                    }
                }
                function X1(e) {
                    if (e.isHidden) {
                        var t;
                        e.props.attach && (t = e.parent) != null && t.object ? DS(e.parent, e) : sr(e.object) && e.props.visible !== !1 && (e.object.visible = !0),
                        e.isHidden = !1,
                        em(e)
                    }
                }
                function fM(e, t, n) {
                    const i = t.root.getState();
                    if (!(!e.parent && e.object !== i.scene)) {
                        if (!t.object) {
                            var s, a;
                            const o = tm[OS(t.type)];
                            t.object = (s = t.props.object) != null ? s : new o(...(a = t.props.args) != null ? a : []),
                            t.object.__r3f = t
                        }
                        if (yh(t.object, t.props),
                        t.props.attach)
                            DS(e, t);
                        else if (sr(t.object) && sr(e.object)) {
                            const o = e.object.children.indexOf(n?.object);
                            if (n && o !== -1) {
                                const c = e.object.children.indexOf(t.object);
                                if (c !== -1) {
                                    e.object.children.splice(c, 1);
                                    const u = c < o ? o - 1 : o;
                                    e.object.children.splice(u, 0, t.object)
                                } else
                                    t.object.parent = e.object,
                                    e.object.children.splice(o, 0, t.object),
                                    t.object.dispatchEvent({
                                        type: "added"
                                    }),
                                    e.object.dispatchEvent({
                                        type: "childadded",
                                        child: t.object
                                    })
                            } else
                                e.object.add(t.object)
                        }
                        for (const o of t.children)
                            fM(t, o);
                        em(t)
                    }
                }
                function dM(e, t) {
                    t && (t.parent = e,
                    e.children.push(t),
                    fM(e, t))
                }
                function W1(e, t, n) {
                    if (!t || !n)
                        return;
                    t.parent = e;
                    const i = e.children.indexOf(n);
                    i !== -1 ? e.children.splice(i, 0, t) : e.children.push(t),
                    fM(e, t, n)
                }
                function Y1(e) {
                    if (typeof e.dispose == "function") {
                        const t = () => {
                            try {
                                e.dispose()
                            } catch {}
                        }
                        ;
                        typeof IS_REACT_ACT_ENVIRONMENT < "u" ? t() : (0,
                        E1.unstable_scheduleCallback)(E1.unstable_IdlePriority, t)
                    }
                }
                function pM(e, t, n) {
                    if (!t)
                        return;
                    t.parent = null;
                    const i = e.children.indexOf(t);
                    i !== -1 && e.children.splice(i, 1),
                    t.props.attach ? RS(e, t) : sr(t.object) && sr(e.object) && (e.object.remove(t.object),
                    sF(R1(t), t.object));
                    const s = t.props.dispose !== null && n !== !1;
                    for (let a = t.children.length - 1; a >= 0; a--) {
                        const o = t.children[a];
                        pM(t, o, s)
                    }
                    t.children.length = 0,
                    delete t.object.__r3f,
                    s && t.type !== "primitive" && t.object.type !== "Scene" && Y1(t.object),
                    n === void 0 && em(t)
                }
                function pF(e, t) {
                    for (const n of [e, e.alternate])
                        if (n !== null)
                            if (typeof n.ref == "function") {
                                n.refCleanup == null || n.refCleanup();
                                const i = n.ref(t);
                                typeof i == "function" && (n.refCleanup = i)
                            } else
                                n.ref && (n.ref.current = t)
                }
                const NS = [];
                function mF() {
                    for (const [n] of NS) {
                        const i = n.parent;
                        if (i) {
                            n.props.attach ? RS(i, n) : sr(n.object) && sr(i.object) && i.object.remove(n.object);
                            for (const s of n.children)
                                s.props.attach ? RS(n, s) : sr(s.object) && sr(n.object) && n.object.remove(s.object)
                        }
                        n.isHidden && X1(n),
                        n.object.__r3f && delete n.object.__r3f,
                        n.type !== "primitive" && Y1(n.object)
                    }
                    for (const [n,i,s] of NS) {
                        n.props = i;
                        const a = n.parent;
                        if (a) {
                            var e, t;
                            const o = tm[OS(n.type)];
                            n.object = (e = n.props.object) != null ? e : new o(...(t = n.props.args) != null ? t : []),
                            n.object.__r3f = n,
                            pF(s, n.object),
                            yh(n.object, n.props),
                            n.props.attach ? DS(a, n) : sr(n.object) && sr(a.object) && a.object.add(n.object);
                            for (const c of n.children)
                                c.props.attach ? DS(n, c) : sr(c.object) && sr(n.object) && n.object.add(c.object);
                            em(n)
                        }
                    }
                    NS.length = 0
                }
                const mM = () => {}
                  , q1 = {};
                let BS = V1;
                const vF = 0
                  , gF = 4
                  , LS = lF({
                    isPrimaryRenderer: !1,
                    warnsIfNotActing: !1,
                    supportsMutation: !0,
                    supportsPersistence: !1,
                    supportsHydration: !1,
                    createInstance: fF,
                    removeChild: pM,
                    appendChild: dM,
                    appendInitialChild: dM,
                    insertBefore: W1,
                    appendChildToContainer(e, t) {
                        const n = e.getState().scene.__r3f;
                        !t || !n || dM(n, t)
                    },
                    removeChildFromContainer(e, t) {
                        const n = e.getState().scene.__r3f;
                        !t || !n || pM(n, t)
                    },
                    insertInContainerBefore(e, t, n) {
                        const i = e.getState().scene.__r3f;
                        !t || !n || !i || W1(i, t, n)
                    },
                    getRootHostContext: () => q1,
                    getChildHostContext: () => q1,
                    commitUpdate(e, t, n, i, s) {
                        var a, o, c;
                        k1(t, i);
                        let u = !1;
                        if ((e.type === "primitive" && n.object !== i.object || ((a = i.args) == null ? void 0 : a.length) !== ((o = n.args) == null ? void 0 : o.length) || (c = i.args) != null && c.some( (f, m) => {
                            var v;
                            return f !== ((v = n.args) == null ? void 0 : v[m])
                        }
                        )) && (u = !0),
                        u)
                            NS.push([e, {
                                ...i
                            }, s]);
                        else {
                            const f = tF(e, i);
                            Object.keys(f).length && (Object.assign(e.props, f),
                            yh(e.object, f))
                        }
                        (s.sibling === null || (s.flags & gF) === vF) && mF()
                    },
                    finalizeInitialChildren: () => !1,
                    commitMount() {},
                    getPublicInstance: e => e?.object,
                    prepareForCommit: () => null,
                    preparePortalMount: e => wS(e.getState().scene, e, "", {}),
                    resetAfterCommit: () => {}
                    ,
                    shouldSetTextContent: () => !1,
                    clearContainer: () => !1,
                    hideInstance: dF,
                    unhideInstance: X1,
                    createTextInstance: mM,
                    hideTextInstance: mM,
                    unhideTextInstance: mM,
                    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
                    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
                    noTimeout: -1,
                    getInstanceFromNode: () => null,
                    beforeActiveInstanceBlur() {},
                    afterActiveInstanceBlur() {},
                    detachDeletedInstance() {},
                    prepareScopeUpdate() {},
                    getInstanceFromScope: () => null,
                    shouldAttemptEagerTransition: () => !1,
                    trackSchedulerEvent: () => {}
                    ,
                    resolveEventType: () => null,
                    resolveEventTimeStamp: () => -1.1,
                    requestPostPaintCallback() {},
                    maySuspendCommit: () => !1,
                    preloadInstance: () => !0,
                    startSuspendingCommit() {},
                    suspendInstance() {},
                    waitForCommitToBeReady: () => null,
                    NotPendingTransition: null,
                    HostTransitionContext: We.createContext(null),
                    setCurrentUpdatePriority(e) {
                        BS = e
                    },
                    getCurrentUpdatePriority() {
                        return BS
                    },
                    resolveUpdatePriority() {
                        var e;
                        if (BS !== V1)
                            return BS;
                        switch (typeof window < "u" && ((e = window.event) == null ? void 0 : e.type)) {
                        case "click":
                        case "contextmenu":
                        case "dblclick":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                            return By.DiscreteEventPriority;
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerenter":
                        case "pointerleave":
                        case "wheel":
                            return By.ContinuousEventPriority;
                        default:
                            return By.DefaultEventPriority
                        }
                    },
                    resetFormInstance() {}
                })
                  , Xf = new Map
                  , nm = {
                    objects: "shallow",
                    strict: !1
                };
                function yF(e, t) {
                    if (!t && typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && e.parentElement) {
                        const {width: n, height: i, top: s, left: a} = e.parentElement.getBoundingClientRect();
                        return {
                            width: n,
                            height: i,
                            top: s,
                            left: a
                        }
                    } else if (!t && typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)
                        return {
                            width: e.width,
                            height: e.height,
                            top: 0,
                            left: 0
                        };
                    return {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        ...t
                    }
                }
                function _F(e) {
                    const t = Xf.get(e)
                      , n = t?.fiber
                      , i = t?.store;
                    t && console.warn("R3F.createRoot should only be called once!");
                    const s = typeof reportError == "function" ? reportError : console.error
                      , a = i || rF(AM, K1)
                      , o = n || LS.createContainer(a, By.ConcurrentRoot, null, !1, null, "", s, s, s, null);
                    t || Xf.set(e, {
                        fiber: o,
                        store: a
                    });
                    let c, u, f = !1, m = null;
                    return {
                        async configure(v={}) {
                            let y;
                            m = new Promise(ee => y = ee);
                            let {gl: S, size: A, scene: M, events: x, onCreated: T, shadows: D=!1, linear: w=!1, flat: U=!1, legacy: O=!1, orthographic: L=!1, frameloop: N="always", dpr: z=[1, 2], performance: I, raycaster: B, camera: G, onPointerMissed: X} = v
                              , q = a.getState()
                              , Q = q.gl;
                            if (!q.gl) {
                                const ee = {
                                    canvas: e,
                                    powerPreference: "high-performance",
                                    antialias: !0,
                                    alpha: !0
                                }
                                  , H = typeof S == "function" ? await S(ee) : S;
                                z1(H) ? Q = H : Q = new _1({
                                    ...ee,
                                    ...S
                                }),
                                q.set({
                                    gl: Q
                                })
                            }
                            let oe = q.raycaster;
                            oe || q.set({
                                raycaster: oe = new kT
                            });
                            const {params: k, ...W} = B || {};
                            if (Ri.equ(W, oe, nm) || yh(oe, {
                                ...W
                            }),
                            Ri.equ(k, oe.params, nm) || yh(oe, {
                                params: {
                                    ...oe.params,
                                    ...k
                                }
                            }),
                            !q.camera || q.camera === u && !Ri.equ(u, G, nm)) {
                                u = G;
                                const ee = G?.isCamera
                                  , H = ee ? G : L ? new qg(0,0,0,0,.1,1e3) : new Hi(75,0,.1,1e3);
                                ee || (H.position.z = 5,
                                G && (yh(H, G),
                                H.manual || ("aspect"in G || "left"in G || "right"in G || "bottom"in G || "top"in G) && (H.manual = !0,
                                H.updateProjectionMatrix())),
                                !q.camera && !(G != null && G.rotation) && H.lookAt(0, 0, 0)),
                                q.set({
                                    camera: H
                                }),
                                oe.camera = H
                            }
                            if (!q.scene) {
                                let ee;
                                M != null && M.isScene ? (ee = M,
                                wS(ee, a, "", {})) : (ee = new Pp,
                                wS(ee, a, "", {}),
                                M && yh(ee, M)),
                                q.set({
                                    scene: ee
                                })
                            }
                            x && !q.events.handlers && q.set({
                                events: x(a)
                            });
                            const V = yF(e, A);
                            if (Ri.equ(V, q.size, nm) || q.setSize(V.width, V.height, V.top, V.left),
                            z && q.viewport.dpr !== O1(z) && q.setDpr(z),
                            q.frameloop !== N && q.setFrameloop(N),
                            q.onPointerMissed || q.set({
                                onPointerMissed: X
                            }),
                            I && !Ri.equ(I, q.performance, nm) && q.set(ee => ({
                                performance: {
                                    ...ee.performance,
                                    ...I
                                }
                            })),
                            !q.xr) {
                                var Z;
                                const ee = (se, K) => {
                                    const le = a.getState();
                                    le.frameloop !== "never" && K1(se, !0, le, K)
                                }
                                  , H = () => {
                                    const se = a.getState();
                                    se.gl.xr.enabled = se.gl.xr.isPresenting,
                                    se.gl.xr.setAnimationLoop(se.gl.xr.isPresenting ? ee : null),
                                    se.gl.xr.isPresenting || AM(se)
                                }
                                  , ie = {
                                    connect() {
                                        const se = a.getState().gl;
                                        se.xr.addEventListener("sessionstart", H),
                                        se.xr.addEventListener("sessionend", H)
                                    },
                                    disconnect() {
                                        const se = a.getState().gl;
                                        se.xr.removeEventListener("sessionstart", H),
                                        se.xr.removeEventListener("sessionend", H)
                                    }
                                };
                                typeof ((Z = Q.xr) == null ? void 0 : Z.addEventListener) == "function" && ie.connect(),
                                q.set({
                                    xr: ie
                                })
                            }
                            if (Q.shadowMap) {
                                const ee = Q.shadowMap.enabled
                                  , H = Q.shadowMap.type;
                                if (Q.shadowMap.enabled = !!D,
                                Ri.boo(D))
                                    Q.shadowMap.type = Zv;
                                else if (Ri.str(D)) {
                                    var j;
                                    const ie = {
                                        basic: OE,
                                        percentage: Iy,
                                        soft: Zv,
                                        variance: sl
                                    };
                                    Q.shadowMap.type = (j = ie[D]) != null ? j : Zv
                                } else
                                    Ri.obj(D) && Object.assign(Q.shadowMap, D);
                                (ee !== Q.shadowMap.enabled || H !== Q.shadowMap.type) && (Q.shadowMap.needsUpdate = !0)
                            }
                            return Rn.enabled = !O,
                            f || (Q.outputColorSpace = w ? rc : Zt,
                            Q.toneMapping = U ? al : mA),
                            q.legacy !== O && q.set( () => ({
                                legacy: O
                            })),
                            q.linear !== w && q.set( () => ({
                                linear: w
                            })),
                            q.flat !== U && q.set( () => ({
                                flat: U
                            })),
                            S && !Ri.fun(S) && !z1(S) && !Ri.equ(S, Q, nm) && yh(Q, S),
                            c = T,
                            f = !0,
                            y(),
                            this
                        },
                        render(v) {
                            return !f && !m && this.configure(),
                            m.then( () => {
                                LS.updateContainer((0,
                                vt.jsx)(SF, {
                                    store: a,
                                    children: v,
                                    onCreated: c,
                                    rootElement: e
                                }), o, null, () => {}
                                )
                            }
                            ),
                            a
                        },
                        unmount() {
                            j1(e)
                        }
                    }
                }
                function SF({store: e, children: t, onCreated: n, rootElement: i}) {
                    return Qg( () => {
                        const s = e.getState();
                        s.set(a => ({
                            internal: {
                                ...a.internal,
                                active: !0
                            }
                        })),
                        n && n(s),
                        e.getState().events.connected || s.events.connect == null || s.events.connect(i)
                    }
                    , []),
                    (0,
                    vt.jsx)(cM.Provider, {
                        value: e,
                        children: t
                    })
                }
                function j1(e, t) {
                    const n = Xf.get(e)
                      , i = n?.fiber;
                    if (i) {
                        const s = n?.store.getState();
                        s && (s.internal.active = !1),
                        LS.updateContainer(null, i, null, () => {
                            s && setTimeout( () => {
                                try {
                                    var a, o, c, u;
                                    s.events.disconnect == null || s.events.disconnect(),
                                    (a = s.gl) == null || (o = a.renderLists) == null || o.dispose == null || o.dispose(),
                                    (c = s.gl) == null || c.forceContextLoss == null || c.forceContextLoss(),
                                    (u = s.gl) != null && u.xr && s.xr.disconnect(),
                                    Jz(s.scene),
                                    Xf.delete(e),
                                    t && t(e)
                                } catch {}
                            }
                            , 500)
                        }
                        )
                    }
                }
                function xF(e, t, n) {
                    return (0,
                    vt.jsx)(AF, {
                        children: e,
                        container: t,
                        state: n
                    })
                }
                function AF({state: e={}, children: t, container: n}) {
                    const {events: i, size: s, ...a} = e
                      , o = uM()
                      , [c] = We.useState( () => new kT)
                      , [u] = We.useState( () => new Oe)
                      , f = oM( (v, y) => {
                        let S;
                        if (y.camera && s) {
                            const A = y.camera;
                            S = v.viewport.getCurrentViewport(A, new ae, s),
                            A !== v.camera && I1(A, s)
                        }
                        return {
                            ...v,
                            ...y,
                            scene: n,
                            raycaster: c,
                            pointer: u,
                            mouse: u,
                            previousRoot: o,
                            events: {
                                ...v.events,
                                ...y.events,
                                ...i
                            },
                            size: {
                                ...v.size,
                                ...s
                            },
                            viewport: {
                                ...v.viewport,
                                ...S
                            },
                            setEvents: A => y.set(M => ({
                                ...M,
                                events: {
                                    ...M.events,
                                    ...A
                                }
                            }))
                        }
                    }
                    )
                      , m = We.useMemo( () => {
                        const v = A1( (S, A) => ({
                            ...a,
                            set: S,
                            get: A
                        }))
                          , y = S => v.setState(A => f.current(S, A));
                        return y(o.getState()),
                        o.subscribe(y),
                        v
                    }
                    , [o, n]);
                    return (0,
                    vt.jsx)(vt.Fragment, {
                        children: LS.createPortal((0,
                        vt.jsx)(cM.Provider, {
                            value: m,
                            children: t
                        }), m, null)
                    })
                }
                const TF = new Set
                  , MF = new Set
                  , bF = new Set;
                function vM(e, t) {
                    if (e.size)
                        for (const {callback: n} of e.values())
                            n(t)
                }
                function Kg(e, t) {
                    switch (e) {
                    case "before":
                        return vM(TF, t);
                    case "after":
                        return vM(MF, t);
                    case "tail":
                        return vM(bF, t)
                    }
                }
                let gM, yM;
                function _M(e, t, n) {
                    let i = t.clock.getDelta();
                    t.frameloop === "never" && typeof e == "number" && (i = e - t.clock.elapsedTime,
                    t.clock.oldTime = t.clock.elapsedTime,
                    t.clock.elapsedTime = e),
                    gM = t.internal.subscribers;
                    for (let s = 0; s < gM.length; s++)
                        yM = gM[s],
                        yM.ref.current(yM.store.getState(), i, n);
                    return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera),
                    t.internal.frames = Math.max(0, t.internal.frames - 1),
                    t.frameloop === "always" ? 1 : t.internal.frames
                }
                let IS = !1, SM = !1, xM, Q1, im;
                function Z1(e) {
                    Q1 = requestAnimationFrame(Z1),
                    IS = !0,
                    xM = 0,
                    Kg("before", e),
                    SM = !0;
                    for (const n of Xf.values()) {
                        var t;
                        im = n.store.getState(),
                        im.internal.active && (im.frameloop === "always" || im.internal.frames > 0) && !((t = im.gl.xr) != null && t.isPresenting) && (xM += _M(e, im))
                    }
                    if (SM = !1,
                    Kg("after", e),
                    xM === 0)
                        return Kg("tail", e),
                        IS = !1,
                        cancelAnimationFrame(Q1)
                }
                function AM(e, t=1) {
                    var n;
                    if (!e)
                        return Xf.forEach(i => AM(i.store.getState(), t));
                    (n = e.gl.xr) != null && n.isPresenting || !e.internal.active || e.frameloop === "never" || (t > 1 ? e.internal.frames = Math.min(60, e.internal.frames + t) : SM ? e.internal.frames = 2 : e.internal.frames = 1,
                    IS || (IS = !0,
                    requestAnimationFrame(Z1)))
                }
                function K1(e, t=!0, n, i) {
                    if (t && Kg("before", e),
                    n)
                        _M(e, n, i);
                    else
                        for (const s of Xf.values())
                            _M(e, s.store.getState());
                    t && Kg("after", e)
                }
                const TM = {
                    onClick: ["click", !1],
                    onContextMenu: ["contextmenu", !1],
                    onDoubleClick: ["dblclick", !1],
                    onWheel: ["wheel", !0],
                    onPointerDown: ["pointerdown", !0],
                    onPointerUp: ["pointerup", !0],
                    onPointerLeave: ["pointerleave", !0],
                    onPointerMove: ["pointermove", !0],
                    onPointerCancel: ["pointercancel", !0],
                    onLostPointerCapture: ["lostpointercapture", !0]
                };
                function EF(e) {
                    const {handlePointer: t} = aF(e);
                    return {
                        priority: 1,
                        enabled: !0,
                        compute(n, i, s) {
                            i.pointer.set(n.offsetX / i.size.width * 2 - 1, -(n.offsetY / i.size.height) * 2 + 1),
                            i.raycaster.setFromCamera(i.pointer, i.camera)
                        },
                        connected: void 0,
                        handlers: Object.keys(TM).reduce( (n, i) => ({
                            ...n,
                            [i]: t(i)
                        }), {}),
                        update: () => {
                            var n;
                            const {events: i, internal: s} = e.getState();
                            (n = s.lastEvent) != null && n.current && i.handlers && i.handlers.onPointerMove(s.lastEvent.current)
                        }
                        ,
                        connect: n => {
                            const {set: i, events: s} = e.getState();
                            if (s.disconnect == null || s.disconnect(),
                            i(a => ({
                                events: {
                                    ...a.events,
                                    connected: n
                                }
                            })),
                            s.handlers)
                                for (const a in s.handlers) {
                                    const o = s.handlers[a]
                                      , [c,u] = TM[a];
                                    n.addEventListener(c, o, {
                                        passive: u
                                    })
                                }
                        }
                        ,
                        disconnect: () => {
                            const {set: n, events: i} = e.getState();
                            if (i.connected) {
                                if (i.handlers)
                                    for (const s in i.handlers) {
                                        const a = i.handlers[s]
                                          , [o] = TM[s];
                                        i.connected.removeEventListener(o, a)
                                    }
                                n(s => ({
                                    events: {
                                        ...s.events,
                                        connected: void 0
                                    }
                                }))
                            }
                        }
                    }
                }
                function J1(e, t) {
                    let n;
                    return (...i) => {
                        window.clearTimeout(n),
                        n = window.setTimeout( () => e(...i), t)
                    }
                }
                function CF({debounce: e, scroll: t, polyfill: n, offsetSize: i}={
                    debounce: 0,
                    scroll: !1,
                    offsetSize: !1
                }) {
                    const s = n || (typeof window > "u" ? class {
                    }
                    : window.ResizeObserver);
                    if (!s)
                        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
                    const [a,o] = (0,
                    We.useState)({
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0,
                        bottom: 0,
                        right: 0,
                        x: 0,
                        y: 0
                    })
                      , c = (0,
                    We.useRef)({
                        element: null,
                        scrollContainers: null,
                        resizeObserver: null,
                        lastBounds: a,
                        orientationHandler: null
                    })
                      , u = e ? typeof e == "number" ? e : e.scroll : null
                      , f = e ? typeof e == "number" ? e : e.resize : null
                      , m = (0,
                    We.useRef)(!1);
                    (0,
                    We.useEffect)( () => (m.current = !0,
                    () => void (m.current = !1)));
                    const [v,y,S] = (0,
                    We.useMemo)( () => {
                        const T = () => {
                            if (!c.current.element)
                                return;
                            const {left: D, top: w, width: U, height: O, bottom: L, right: N, x: z, y: I} = c.current.element.getBoundingClientRect()
                              , B = {
                                left: D,
                                top: w,
                                width: U,
                                height: O,
                                bottom: L,
                                right: N,
                                x: z,
                                y: I
                            };
                            c.current.element instanceof HTMLElement && i && (B.height = c.current.element.offsetHeight,
                            B.width = c.current.element.offsetWidth),
                            Object.freeze(B),
                            m.current && !UF(c.current.lastBounds, B) && o(c.current.lastBounds = B)
                        }
                        ;
                        return [T, f ? J1(T, f) : T, u ? J1(T, u) : T]
                    }
                    , [o, i, u, f]);
                    function A() {
                        c.current.scrollContainers && (c.current.scrollContainers.forEach(T => T.removeEventListener("scroll", S, !0)),
                        c.current.scrollContainers = null),
                        c.current.resizeObserver && (c.current.resizeObserver.disconnect(),
                        c.current.resizeObserver = null),
                        c.current.orientationHandler && ("orientation"in screen && "removeEventListener"in screen.orientation ? screen.orientation.removeEventListener("change", c.current.orientationHandler) : "onorientationchange"in window && window.removeEventListener("orientationchange", c.current.orientationHandler))
                    }
                    function M() {
                        c.current.element && (c.current.resizeObserver = new s(S),
                        c.current.resizeObserver.observe(c.current.element),
                        t && c.current.scrollContainers && c.current.scrollContainers.forEach(T => T.addEventListener("scroll", S, {
                            capture: !0,
                            passive: !0
                        })),
                        c.current.orientationHandler = () => {
                            S()
                        }
                        ,
                        "orientation"in screen && "addEventListener"in screen.orientation ? screen.orientation.addEventListener("change", c.current.orientationHandler) : "onorientationchange"in window && window.addEventListener("orientationchange", c.current.orientationHandler))
                    }
                    const x = T => {
                        !T || T === c.current.element || (A(),
                        c.current.element = T,
                        c.current.scrollContainers = $1(T),
                        M())
                    }
                    ;
                    return DF(S, !!t),
                    wF(y),
                    (0,
                    We.useEffect)( () => {
                        A(),
                        M()
                    }
                    , [t, S, y]),
                    (0,
                    We.useEffect)( () => A, []),
                    [x, a, v]
                }
                function wF(e) {
                    (0,
                    We.useEffect)( () => {
                        const t = e;
                        return window.addEventListener("resize", t),
                        () => void window.removeEventListener("resize", t)
                    }
                    , [e])
                }
                function DF(e, t) {
                    (0,
                    We.useEffect)( () => {
                        if (t) {
                            const n = e;
                            return window.addEventListener("scroll", n, {
                                capture: !0,
                                passive: !0
                            }),
                            () => void window.removeEventListener("scroll", n, !0)
                        }
                    }
                    , [e, t])
                }
                function $1(e) {
                    const t = [];
                    if (!e || e === document.body)
                        return t;
                    const {overflow: n, overflowX: i, overflowY: s} = window.getComputedStyle(e);
                    return [n, i, s].some(a => a === "auto" || a === "scroll") && t.push(e),
                    [...t, ...$1(e.parentElement)]
                }
                const RF = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
                  , UF = (e, t) => RF.every(n => e[n] === t[n]);
                var BX = _r(DE())
                  , LX = _r(b1())
                  , IX = _r(sM());
                function OF({ref: e, children: t, fallback: n, resize: i, style: s, gl: a, events: o=EF, eventSource: c, eventPrefix: u, shadows: f, linear: m, flat: v, legacy: y, orthographic: S, frameloop: A, dpr: M, performance: x, raycaster: T, camera: D, scene: w, onPointerMissed: U, onCreated: O, ...L}) {
                    We.useMemo( () => hM(AP), []);
                    const N = jz()
                      , [z,I] = CF({
                        scroll: !0,
                        debounce: {
                            scroll: 50,
                            resize: 0
                        },
                        ...i
                    })
                      , B = We.useRef(null)
                      , G = We.useRef(null);
                    We.useImperativeHandle(e, () => B.current);
                    const X = oM(U)
                      , [q,Q] = We.useState(!1)
                      , [oe,k] = We.useState(!1);
                    if (q)
                        throw q;
                    if (oe)
                        throw oe;
                    const W = We.useRef(null);
                    return Qg( () => {
                        const V = B.current;
                        if (I.width > 0 && I.height > 0 && V) {
                            W.current || (W.current = _F(V));
                            async function Z() {
                                await W.current.configure({
                                    gl: a,
                                    scene: w,
                                    events: o,
                                    shadows: f,
                                    linear: m,
                                    flat: v,
                                    legacy: y,
                                    orthographic: S,
                                    frameloop: A,
                                    dpr: M,
                                    performance: x,
                                    raycaster: T,
                                    camera: D,
                                    size: I,
                                    onPointerMissed: (...j) => X.current == null ? void 0 : X.current(...j),
                                    onCreated: j => {
                                        j.events.connect == null || j.events.connect(c ? Yz(c) ? c.current : c : G.current),
                                        u && j.setEvents({
                                            compute: (ee, H) => {
                                                const ie = ee[u + "X"]
                                                  , se = ee[u + "Y"];
                                                H.pointer.set(ie / H.size.width * 2 - 1, -(se / H.size.height) * 2 + 1),
                                                H.raycaster.setFromCamera(H.pointer, H.camera)
                                            }
                                        }),
                                        O?.(j)
                                    }
                                }),
                                W.current.render((0,
                                vt.jsx)(N, {
                                    children: (0,
                                    vt.jsx)(Zz, {
                                        set: k,
                                        children: (0,
                                        vt.jsx)(We.Suspense, {
                                            fallback: (0,
                                            vt.jsx)(Qz, {
                                                set: Q
                                            }),
                                            children: t ?? null
                                        })
                                    })
                                }))
                            }
                            Z()
                        }
                    }
                    ),
                    We.useEffect( () => {
                        const V = B.current;
                        if (V)
                            return () => j1(V)
                    }
                    , []),
                    (0,
                    vt.jsx)("div", {
                        ref: G,
                        style: {
                            position: "relative",
                            width: "100%",
                            height: "100%",
                            overflow: "hidden",
                            pointerEvents: c ? "none" : "auto",
                            ...s
                        },
                        ...L,
                        children: (0,
                        vt.jsx)("div", {
                            ref: z,
                            style: {
                                width: "100%",
                                height: "100%"
                            },
                            children: (0,
                            vt.jsx)("canvas", {
                                ref: B,
                                style: {
                                    display: "block"
                                },
                                children: n
                            })
                        })
                    })
                }
                function NF(e) {
                    return (0,
                    vt.jsx)(w1, {
                        children: (0,
                        vt.jsx)(OF, {
                            ...e
                        })
                    })
                }
                var MM = 1 / 1e3
                  , BF = 1e3
                  , LF = class {
                    constructor() {
                        this.startTime = performance.now(),
                        this.previousTime = 0,
                        this.currentTime = 0,
                        this._delta = 0,
                        this._elapsed = 0,
                        this._fixedDelta = 1e3 / 60,
                        this.timescale = 1,
                        this.useFixedDelta = !1,
                        this._autoReset = !1
                    }
                    get autoReset() {
                        return this._autoReset
                    }
                    set autoReset(e) {
                        typeof document < "u" && document.hidden !== void 0 && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
                        this._autoReset = e)
                    }
                    get delta() {
                        return this._delta * MM
                    }
                    get fixedDelta() {
                        return this._fixedDelta * MM
                    }
                    set fixedDelta(e) {
                        this._fixedDelta = e * BF
                    }
                    get elapsed() {
                        return this._elapsed * MM
                    }
                    update(e) {
                        this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime,
                        this.currentTime = (e !== void 0 ? e : performance.now()) - this.startTime,
                        this._delta = this.currentTime - this.previousTime),
                        this._delta *= this.timescale,
                        this._elapsed += this._delta
                    }
                    reset() {
                        this._delta = 0,
                        this._elapsed = 0,
                        this.currentTime = performance.now() - this.startTime
                    }
                    getDelta() {
                        return this.delta
                    }
                    getElapsed() {
                        return this.elapsed
                    }
                    handleEvent(e) {
                        document.hidden || (this.currentTime = performance.now() - this.startTime)
                    }
                    dispose() {
                        this.autoReset = !1
                    }
                }
                  , IF = ( () => {
                    const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
                      , t = new Float32Array([0, 0, 2, 0, 0, 2])
                      , n = new sn;
                    return n.setAttribute("position", new Ln(e,3)),
                    n.setAttribute("uv", new Ln(t,2)),
                    n
                }
                )()
                  , sa = class Ub {
                    static get fullscreenGeometry() {
                        return IF
                    }
                    constructor(t="Pass", n=new Pp, i=new Ag) {
                        this.name = t,
                        this.renderer = null,
                        this.scene = n,
                        this.camera = i,
                        this.screen = null,
                        this.rtt = !0,
                        this.needsSwap = !0,
                        this.needsDepthTexture = !1,
                        this.enabled = !0
                    }
                    get renderToScreen() {
                        return !this.rtt
                    }
                    set renderToScreen(t) {
                        if (this.rtt === t) {
                            const n = this.fullscreenMaterial;
                            n !== null && (n.needsUpdate = !0),
                            this.rtt = !t
                        }
                    }
                    set mainScene(t) {}
                    set mainCamera(t) {}
                    setRenderer(t) {
                        this.renderer = t
                    }
                    isEnabled() {
                        return this.enabled
                    }
                    setEnabled(t) {
                        this.enabled = t
                    }
                    get fullscreenMaterial() {
                        return this.screen !== null ? this.screen.material : null
                    }
                    set fullscreenMaterial(t) {
                        let n = this.screen;
                        n !== null ? n.material = t : (n = new oi(Ub.fullscreenGeometry,t),
                        n.frustumCulled = !1,
                        this.scene === null && (this.scene = new Pp),
                        this.scene.add(n),
                        this.screen = n)
                    }
                    getFullscreenMaterial() {
                        return this.fullscreenMaterial
                    }
                    setFullscreenMaterial(t) {
                        this.fullscreenMaterial = t
                    }
                    getDepthTexture() {
                        return null
                    }
                    setDepthTexture(t, n=as) {}
                    render(t, n, i, s, a) {
                        throw new Error("Render method not implemented!")
                    }
                    setSize(t, n) {}
                    initialize(t, n, i) {}
                    dispose() {
                        for (const t of Object.keys(this)) {
                            const n = this[t];
                            (n instanceof Vn || n instanceof qs || n instanceof Fi || n instanceof Ub) && this[t].dispose()
                        }
                        this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose()
                    }
                }
                  , PF = class extends sa {
                    constructor() {
                        super("ClearMaskPass", null, null),
                        this.needsSwap = !1
                    }
                    render(e, t, n, i, s) {
                        const a = e.state.buffers.stencil;
                        a.setLocked(!1),
                        a.setTest(!1)
                    }
                }
                  , zF = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`
                  , Wf = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , eD = class extends kn {
                    constructor() {
                        super({
                            name: "CopyMaterial",
                            uniforms: {
                                inputBuffer: new ke(null),
                                opacity: new ke(1)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: zF,
                            vertexShader: Wf
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    getOpacity(e) {
                        return this.uniforms.opacity.value
                    }
                    setOpacity(e) {
                        this.uniforms.opacity.value = e
                    }
                }
                  , tD = class extends sa {
                    constructor(e, t=!0) {
                        super("CopyPass"),
                        this.fullscreenMaterial = new eD,
                        this.needsSwap = !1,
                        this.renderTarget = e,
                        e === void 0 && (this.renderTarget = new Vn(1,1,{
                            minFilter: mi,
                            magFilter: mi,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "CopyPass.Target"),
                        this.autoResize = t
                    }
                    get resize() {
                        return this.autoResize
                    }
                    set resize(e) {
                        this.autoResize = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    setAutoResizeEnabled(e) {
                        this.autoResize = e
                    }
                    render(e, t, n, i, s) {
                        this.fullscreenMaterial.inputBuffer = t.texture,
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        this.autoResize && this.renderTarget.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && (this.renderTarget.texture.type = n,
                        n !== gi ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : e !== null && e.outputColorSpace === Zt && (this.renderTarget.texture.colorSpace = Zt))
                    }
                }
                  , nD = new ft
                  , sm = class extends sa {
                    constructor(e=!0, t=!0, n=!1) {
                        super("ClearPass", null, null),
                        this.needsSwap = !1,
                        this.color = e,
                        this.depth = t,
                        this.stencil = n,
                        this.overrideClearColor = null,
                        this.overrideClearAlpha = -1
                    }
                    setClearFlags(e, t, n) {
                        this.color = e,
                        this.depth = t,
                        this.stencil = n
                    }
                    getOverrideClearColor() {
                        return this.overrideClearColor
                    }
                    setOverrideClearColor(e) {
                        this.overrideClearColor = e
                    }
                    getOverrideClearAlpha() {
                        return this.overrideClearAlpha
                    }
                    setOverrideClearAlpha(e) {
                        this.overrideClearAlpha = e
                    }
                    render(e, t, n, i, s) {
                        const a = this.overrideClearColor
                          , o = this.overrideClearAlpha
                          , c = e.getClearAlpha()
                          , u = a !== null
                          , f = o >= 0;
                        u ? (e.getClearColor(nD),
                        e.setClearColor(a, f ? o : c)) : f && e.setClearAlpha(o),
                        e.setRenderTarget(this.renderToScreen ? null : t),
                        e.clear(this.color, this.depth, this.stencil),
                        u ? e.setClearColor(nD, c) : f && e.setClearAlpha(c)
                    }
                }
                  , FF = class extends sa {
                    constructor(e, t) {
                        super("MaskPass", e, t),
                        this.needsSwap = !1,
                        this.clearPass = new sm(!1,!1,!0),
                        this.inverse = !1
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get inverted() {
                        return this.inverse
                    }
                    set inverted(e) {
                        this.inverse = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    render(e, t, n, i, s) {
                        const a = e.getContext()
                          , o = e.state.buffers
                          , c = this.scene
                          , u = this.camera
                          , f = this.clearPass
                          , m = this.inverted ? 0 : 1
                          , v = 1 - m;
                        o.color.setMask(!1),
                        o.depth.setMask(!1),
                        o.color.setLocked(!0),
                        o.depth.setLocked(!0),
                        o.stencil.setTest(!0),
                        o.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE),
                        o.stencil.setFunc(a.ALWAYS, m, 4294967295),
                        o.stencil.setClear(v),
                        o.stencil.setLocked(!0),
                        this.clearPass.enabled && (this.renderToScreen ? f.render(e, null) : (f.render(e, t),
                        f.render(e, n))),
                        this.renderToScreen ? (e.setRenderTarget(null),
                        e.render(c, u)) : (e.setRenderTarget(t),
                        e.render(c, u),
                        e.setRenderTarget(n),
                        e.render(c, u)),
                        o.color.setLocked(!1),
                        o.depth.setLocked(!1),
                        o.stencil.setLocked(!1),
                        o.stencil.setFunc(a.EQUAL, 1, 4294967295),
                        o.stencil.setOp(a.KEEP, a.KEEP, a.KEEP),
                        o.stencil.setLocked(!0)
                    }
                }
                  , HF = class {
                    constructor(e=null, {depthBuffer: t=!0, stencilBuffer: n=!1, multisampling: i=0, frameBufferType: s}={}) {
                        this.renderer = null,
                        this.inputBuffer = this.createBuffer(t, n, s, i),
                        this.outputBuffer = this.inputBuffer.clone(),
                        this.copyPass = new tD,
                        this.depthTexture = null,
                        this.passes = [],
                        this.timer = new LF,
                        this.autoRenderToScreen = !0,
                        this.setRenderer(e)
                    }
                    get multisampling() {
                        return this.inputBuffer.samples || 0
                    }
                    set multisampling(e) {
                        const t = this.inputBuffer
                          , n = this.multisampling;
                        n > 0 && e > 0 ? (this.inputBuffer.samples = e,
                        this.outputBuffer.samples = e,
                        this.inputBuffer.dispose(),
                        this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(),
                        this.outputBuffer.dispose(),
                        this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e),
                        this.inputBuffer.depthTexture = this.depthTexture,
                        this.outputBuffer = this.inputBuffer.clone())
                    }
                    getTimer() {
                        return this.timer
                    }
                    getRenderer() {
                        return this.renderer
                    }
                    setRenderer(e) {
                        if (this.renderer = e,
                        e !== null) {
                            const t = e.getSize(new Oe)
                              , n = e.getContext().getContextAttributes().alpha
                              , i = this.inputBuffer.texture.type;
                            i === gi && e.outputColorSpace === Zt && (this.inputBuffer.texture.colorSpace = Zt,
                            this.outputBuffer.texture.colorSpace = Zt,
                            this.inputBuffer.dispose(),
                            this.outputBuffer.dispose()),
                            e.autoClear = !1,
                            this.setSize(t.width, t.height);
                            for (const s of this.passes)
                                s.initialize(e, n, i)
                        }
                    }
                    replaceRenderer(e, t=!0) {
                        const n = this.renderer
                          , i = n.domElement.parentNode;
                        return this.setRenderer(e),
                        t && i !== null && (i.removeChild(n.domElement),
                        i.appendChild(e.domElement)),
                        n
                    }
                    createDepthTexture() {
                        const e = this.depthTexture = new Og;
                        return this.inputBuffer.depthTexture = e,
                        this.inputBuffer.dispose(),
                        this.inputBuffer.stencilBuffer ? (e.format = pf,
                        e.type = df) : e.type = ac,
                        e
                    }
                    deleteDepthTexture() {
                        if (this.depthTexture !== null) {
                            this.depthTexture.dispose(),
                            this.depthTexture = null,
                            this.inputBuffer.depthTexture = null,
                            this.inputBuffer.dispose();
                            for (const e of this.passes)
                                e.setDepthTexture(null)
                        }
                    }
                    createBuffer(e, t, n, i) {
                        const s = this.renderer
                          , a = s === null ? new Oe : s.getDrawingBufferSize(new Oe)
                          , o = {
                            minFilter: mi,
                            magFilter: mi,
                            stencilBuffer: t,
                            depthBuffer: e,
                            type: n
                        }
                          , c = new Vn(a.width,a.height,o);
                        return i > 0 && (c.ignoreDepthForMultisampleCopy = !1,
                        c.samples = i),
                        n === gi && s !== null && s.outputColorSpace === Zt && (c.texture.colorSpace = Zt),
                        c.texture.name = "EffectComposer.Buffer",
                        c.texture.generateMipmaps = !1,
                        c
                    }
                    setMainScene(e) {
                        for (const t of this.passes)
                            t.mainScene = e
                    }
                    setMainCamera(e) {
                        for (const t of this.passes)
                            t.mainCamera = e
                    }
                    addPass(e, t) {
                        const n = this.passes
                          , i = this.renderer
                          , s = i.getDrawingBufferSize(new Oe)
                          , a = i.getContext().getContextAttributes().alpha
                          , o = this.inputBuffer.texture.type;
                        if (e.setRenderer(i),
                        e.setSize(s.width, s.height),
                        e.initialize(i, a, o),
                        this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1),
                        e.renderToScreen && (this.autoRenderToScreen = !1)),
                        t !== void 0 ? n.splice(t, 0, e) : n.push(e),
                        this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0),
                        e.needsDepthTexture || this.depthTexture !== null)
                            if (this.depthTexture === null) {
                                const c = this.createDepthTexture();
                                for (e of n)
                                    e.setDepthTexture(c)
                            } else
                                e.setDepthTexture(this.depthTexture)
                    }
                    removePass(e) {
                        const t = this.passes
                          , n = t.indexOf(e);
                        if (n !== -1 && t.splice(n, 1).length > 0) {
                            if (this.depthTexture !== null) {
                                const i = (s, a) => s || a.needsDepthTexture;
                                t.reduce(i, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null),
                                this.deleteDepthTexture())
                            }
                            this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1,
                            t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                        }
                    }
                    removeAllPasses() {
                        const e = this.passes;
                        this.deleteDepthTexture(),
                        e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1),
                        this.passes = [])
                    }
                    render(e) {
                        const t = this.renderer
                          , n = this.copyPass;
                        let i = this.inputBuffer, s = this.outputBuffer, a = !1, o, c, u;
                        e === void 0 && (this.timer.update(),
                        e = this.timer.getDelta());
                        for (const f of this.passes)
                            f.enabled && (f.render(t, i, s, e, a),
                            f.needsSwap && (a && (n.renderToScreen = f.renderToScreen,
                            o = t.getContext(),
                            c = t.state.buffers.stencil,
                            c.setFunc(o.NOTEQUAL, 1, 4294967295),
                            n.render(t, i, s, e, a),
                            c.setFunc(o.EQUAL, 1, 4294967295)),
                            u = i,
                            i = s,
                            s = u),
                            f instanceof FF ? a = !0 : f instanceof PF && (a = !1))
                    }
                    setSize(e, t, n) {
                        const i = this.renderer
                          , s = i.getSize(new Oe);
                        (e === void 0 || t === void 0) && (e = s.width,
                        t = s.height),
                        (s.width !== e || s.height !== t) && i.setSize(e, t, n);
                        const a = i.getDrawingBufferSize(new Oe);
                        this.inputBuffer.setSize(a.width, a.height),
                        this.outputBuffer.setSize(a.width, a.height);
                        for (const o of this.passes)
                            o.setSize(a.width, a.height)
                    }
                    reset() {
                        this.dispose(),
                        this.autoRenderToScreen = !0
                    }
                    dispose() {
                        for (const e of this.passes)
                            e.dispose();
                        this.passes = [],
                        this.inputBuffer !== null && this.inputBuffer.dispose(),
                        this.outputBuffer !== null && this.outputBuffer.dispose(),
                        this.deleteDepthTexture(),
                        this.copyPass.dispose(),
                        this.timer.dispose(),
                        sa.fullscreenGeometry.dispose()
                    }
                }
                  , ar = {
                    NONE: 0,
                    DEPTH: 1,
                    CONVOLUTION: 2
                }
                  , Xn = {
                    FRAGMENT_HEAD: "FRAGMENT_HEAD",
                    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                    VERTEX_HEAD: "VERTEX_HEAD",
                    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
                }
                  , GF = class {
                    constructor() {
                        this.shaderParts = new Map([[Xn.FRAGMENT_HEAD, null], [Xn.FRAGMENT_MAIN_UV, null], [Xn.FRAGMENT_MAIN_IMAGE, null], [Xn.VERTEX_HEAD, null], [Xn.VERTEX_MAIN_SUPPORT, null]]),
                        this.defines = new Map,
                        this.uniforms = new Map,
                        this.blendModes = new Map,
                        this.extensions = new Set,
                        this.attributes = ar.NONE,
                        this.varyings = new Set,
                        this.uvTransformation = !1,
                        this.readDepth = !1,
                        this.colorSpace = rc
                    }
                }
                  , bM = !1
                  , iD = class {
                    constructor(e=null) {
                        this.originalMaterials = new Map,
                        this.material = null,
                        this.materials = null,
                        this.materialsBackSide = null,
                        this.materialsDoubleSide = null,
                        this.materialsFlatShaded = null,
                        this.materialsFlatShadedBackSide = null,
                        this.materialsFlatShadedDoubleSide = null,
                        this.setMaterial(e),
                        this.meshCount = 0,
                        this.replaceMaterial = t => {
                            if (t.isMesh) {
                                let n;
                                if (t.material.flatShading)
                                    switch (t.material.side) {
                                    case $a:
                                        n = this.materialsFlatShadedDoubleSide;
                                        break;
                                    case Ds:
                                        n = this.materialsFlatShadedBackSide;
                                        break;
                                    default:
                                        n = this.materialsFlatShaded;
                                        break
                                    }
                                else
                                    switch (t.material.side) {
                                    case $a:
                                        n = this.materialsDoubleSide;
                                        break;
                                    case Ds:
                                        n = this.materialsBackSide;
                                        break;
                                    default:
                                        n = this.materials;
                                        break
                                    }
                                this.originalMaterials.set(t, t.material),
                                t.isSkinnedMesh ? t.material = n[2] : t.isInstancedMesh ? t.material = n[1] : t.material = n[0],
                                ++this.meshCount
                            }
                        }
                    }
                    cloneMaterial(e) {
                        if (!(e instanceof kn))
                            return e.clone();
                        const t = e.uniforms
                          , n = new Map;
                        for (const s in t) {
                            const a = t[s].value;
                            a.isRenderTargetTexture && (t[s].value = null,
                            n.set(s, a))
                        }
                        const i = e.clone();
                        for (const s of n)
                            t[s[0]].value = s[1],
                            i.uniforms[s[0]].value = s[1];
                        return i
                    }
                    setMaterial(e) {
                        if (this.disposeMaterials(),
                        this.material = e,
                        e !== null) {
                            const t = this.materials = [this.cloneMaterial(e), this.cloneMaterial(e), this.cloneMaterial(e)];
                            for (const n of t)
                                n.uniforms = Object.assign({}, e.uniforms),
                                n.side = ic;
                            t[2].skinning = !0,
                            this.materialsBackSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.side = Ds,
                                i
                            }
                            ),
                            this.materialsDoubleSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.side = $a,
                                i
                            }
                            ),
                            this.materialsFlatShaded = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.flatShading = !0,
                                i
                            }
                            ),
                            this.materialsFlatShadedBackSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.flatShading = !0,
                                i.side = Ds,
                                i
                            }
                            ),
                            this.materialsFlatShadedDoubleSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.flatShading = !0,
                                i.side = $a,
                                i
                            }
                            )
                        }
                    }
                    render(e, t, n) {
                        const i = e.shadowMap.enabled;
                        if (e.shadowMap.enabled = !1,
                        bM) {
                            const s = this.originalMaterials;
                            this.meshCount = 0,
                            t.traverse(this.replaceMaterial),
                            e.render(t, n);
                            for (const a of s)
                                a[0].material = a[1];
                            this.meshCount !== s.size && s.clear()
                        } else {
                            const s = t.overrideMaterial;
                            t.overrideMaterial = this.material,
                            e.render(t, n),
                            t.overrideMaterial = s
                        }
                        e.shadowMap.enabled = i
                    }
                    disposeMaterials() {
                        if (this.material !== null) {
                            const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                            for (const t of e)
                                t.dispose()
                        }
                    }
                    dispose() {
                        this.originalMaterials.clear(),
                        this.disposeMaterials()
                    }
                    static get workaroundEnabled() {
                        return bM
                    }
                    static set workaroundEnabled(e) {
                        bM = e
                    }
                }
                  , _h = -1
                  , Zn = class extends qr {
                    constructor(e, t=_h, n=_h, i=1) {
                        super(),
                        this.resizable = e,
                        this.baseSize = new Oe(1,1),
                        this.preferredSize = new Oe(t,n),
                        this.target = this.preferredSize,
                        this.s = i,
                        this.effectiveSize = new Oe,
                        this.addEventListener("change", () => this.updateEffectiveSize()),
                        this.updateEffectiveSize()
                    }
                    updateEffectiveSize() {
                        const e = this.baseSize
                          , t = this.preferredSize
                          , n = this.effectiveSize
                          , i = this.scale;
                        t.width !== _h ? n.width = t.width : t.height !== _h ? n.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : n.width = Math.round(e.width * i),
                        t.height !== _h ? n.height = t.height : t.width !== _h ? n.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : n.height = Math.round(e.height * i)
                    }
                    get width() {
                        return this.effectiveSize.width
                    }
                    set width(e) {
                        this.preferredWidth = e
                    }
                    get height() {
                        return this.effectiveSize.height
                    }
                    set height(e) {
                        this.preferredHeight = e
                    }
                    getWidth() {
                        return this.width
                    }
                    getHeight() {
                        return this.height
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(e) {
                        this.s !== e && (this.s = e,
                        this.preferredSize.setScalar(_h),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    get baseWidth() {
                        return this.baseSize.width
                    }
                    set baseWidth(e) {
                        this.baseSize.width !== e && (this.baseSize.width = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseWidth() {
                        return this.baseWidth
                    }
                    setBaseWidth(e) {
                        this.baseWidth = e
                    }
                    get baseHeight() {
                        return this.baseSize.height
                    }
                    set baseHeight(e) {
                        this.baseSize.height !== e && (this.baseSize.height = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseHeight() {
                        return this.baseHeight
                    }
                    setBaseHeight(e) {
                        this.baseHeight = e
                    }
                    setBaseSize(e, t) {
                        (this.baseSize.width !== e || this.baseSize.height !== t) && (this.baseSize.set(e, t),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    get preferredWidth() {
                        return this.preferredSize.width
                    }
                    set preferredWidth(e) {
                        this.preferredSize.width !== e && (this.preferredSize.width = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredWidth() {
                        return this.preferredWidth
                    }
                    setPreferredWidth(e) {
                        this.preferredWidth = e
                    }
                    get preferredHeight() {
                        return this.preferredSize.height
                    }
                    set preferredHeight(e) {
                        this.preferredSize.height !== e && (this.preferredSize.height = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredHeight() {
                        return this.preferredHeight
                    }
                    setPreferredHeight(e) {
                        this.preferredHeight = e
                    }
                    setPreferredSize(e, t) {
                        (this.preferredSize.width !== e || this.preferredSize.height !== t) && (this.preferredSize.set(e, t),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    copy(e) {
                        this.s = e.scale,
                        this.baseSize.set(e.baseWidth, e.baseHeight),
                        this.preferredSize.set(e.preferredWidth, e.preferredHeight),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height)
                    }
                    static get AUTO_SIZE() {
                        return _h
                    }
                }
                  , VF = class {
                    constructor(e=0) {
                        this.nextId = e
                    }
                    getNextId() {
                        return this.nextId++
                    }
                    reset(e=0) {
                        return this.nextId = e,
                        this
                    }
                }
                  , EM = new VF(2)
                  , sD = class extends Set {
                    constructor(e, t=EM.getNextId()) {
                        super(),
                        this.exclusive = !1,
                        this._layer = t,
                        (this._layer < 1 || this._layer > 31) && (console.warn("Layer out of range, resetting to 2"),
                        EM.reset(2),
                        this._layer = EM.getNextId()),
                        e !== void 0 && this.set(e)
                    }
                    get layer() {
                        return this._layer
                    }
                    set layer(e) {
                        const t = this._layer;
                        for (const n of this)
                            n.layers.disable(t),
                            n.layers.enable(e);
                        this._layer = e
                    }
                    getLayer() {
                        return this.layer
                    }
                    setLayer(e) {
                        this.layer = e
                    }
                    isExclusive() {
                        return this.exclusive
                    }
                    setExclusive(e) {
                        this.exclusive = e
                    }
                    clear() {
                        const e = this.layer;
                        for (const t of this)
                            t.layers.disable(e);
                        return super.clear()
                    }
                    set(e) {
                        this.clear();
                        for (const t of e)
                            this.add(t);
                        return this
                    }
                    indexOf(e) {
                        return this.has(e) ? 0 : -1
                    }
                    add(e) {
                        return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer),
                        super.add(e)
                    }
                    delete(e) {
                        return this.has(e) && e.layers.disable(this.layer),
                        super.delete(e)
                    }
                    toggle(e) {
                        let t;
                        return this.has(e) ? (this.delete(e),
                        t = !1) : (this.add(e),
                        t = !0),
                        t
                    }
                    setVisible(e) {
                        for (const t of this)
                            e ? t.layers.enable(0) : t.layers.disable(0);
                        return this
                    }
                }
                  , Wt = {
                    SKIP: 9,
                    SET: 30,
                    ADD: 0,
                    ALPHA: 1,
                    AVERAGE: 2,
                    COLOR: 3,
                    COLOR_BURN: 4,
                    COLOR_DODGE: 5,
                    DARKEN: 6,
                    DIFFERENCE: 7,
                    DIVIDE: 8,
                    DST: 9,
                    EXCLUSION: 10,
                    HARD_LIGHT: 11,
                    HARD_MIX: 12,
                    HUE: 13,
                    INVERT: 14,
                    INVERT_RGB: 15,
                    LIGHTEN: 16,
                    LINEAR_BURN: 17,
                    LINEAR_DODGE: 18,
                    LINEAR_LIGHT: 19,
                    LUMINOSITY: 20,
                    MULTIPLY: 21,
                    NEGATION: 22,
                    NORMAL: 23,
                    OVERLAY: 24,
                    PIN_LIGHT: 25,
                    REFLECT: 26,
                    SATURATION: 27,
                    SCREEN: 28,
                    SOFT_LIGHT: 29,
                    SRC: 30,
                    SUBTRACT: 31,
                    VIVID_LIGHT: 32
                }
                  , kF = new Map([[Wt.ADD, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}"], [Wt.ALPHA, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}"], [Wt.AVERAGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}"], [Wt.COLOR, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}"], [Wt.COLOR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}"], [Wt.COLOR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}"], [Wt.DARKEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}"], [Wt.DIFFERENCE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}"], [Wt.DIVIDE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}"], [Wt.DST, null], [Wt.EXCLUSION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}"], [Wt.HARD_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}"], [Wt.HARD_MIX, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}"], [Wt.HUE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}"], [Wt.INVERT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}"], [Wt.INVERT_RGB, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}"], [Wt.LIGHTEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}"], [Wt.LINEAR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}"], [Wt.LINEAR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}"], [Wt.LINEAR_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}"], [Wt.LUMINOSITY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}"], [Wt.MULTIPLY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}"], [Wt.NEGATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}"], [Wt.NORMAL, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"], [Wt.OVERLAY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}"], [Wt.PIN_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}"], [Wt.REFLECT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}"], [Wt.SATURATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}"], [Wt.SCREEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}"], [Wt.SOFT_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}"], [Wt.SRC, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"], [Wt.SUBTRACT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}"], [Wt.VIVID_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}"]])
                  , XF = class extends qr {
                    constructor(e, t=1) {
                        super(),
                        this._blendFunction = e,
                        this.opacity = new ke(t)
                    }
                    getOpacity() {
                        return this.opacity.value
                    }
                    setOpacity(e) {
                        this.opacity.value = e
                    }
                    get blendFunction() {
                        return this._blendFunction
                    }
                    set blendFunction(e) {
                        this._blendFunction = e,
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    getBlendFunction() {
                        return this.blendFunction
                    }
                    setBlendFunction(e) {
                        this.blendFunction = e
                    }
                    getShaderCode() {
                        return kF.get(this.blendFunction)
                    }
                }
                  , Vi = class extends qr {
                    constructor(e, t, {attributes: n=ar.NONE, blendFunction: i=Wt.NORMAL, defines: s=new Map, uniforms: a=new Map, extensions: o=null, vertexShader: c=null}={}) {
                        super(),
                        this.name = e,
                        this.renderer = null,
                        this.attributes = n,
                        this.fragmentShader = t,
                        this.vertexShader = c,
                        this.defines = s,
                        this.uniforms = a,
                        this.extensions = o,
                        this.blendMode = new XF(i),
                        this.blendMode.addEventListener("change", u => this.setChanged()),
                        this._inputColorSpace = rc,
                        this._outputColorSpace = rl
                    }
                    get inputColorSpace() {
                        return this._inputColorSpace
                    }
                    set inputColorSpace(e) {
                        this._inputColorSpace = e,
                        this.setChanged()
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e,
                        this.setChanged()
                    }
                    set mainScene(e) {}
                    set mainCamera(e) {}
                    getName() {
                        return this.name
                    }
                    setRenderer(e) {
                        this.renderer = e
                    }
                    getDefines() {
                        return this.defines
                    }
                    getUniforms() {
                        return this.uniforms
                    }
                    getExtensions() {
                        return this.extensions
                    }
                    getBlendMode() {
                        return this.blendMode
                    }
                    getAttributes() {
                        return this.attributes
                    }
                    setAttributes(e) {
                        this.attributes = e,
                        this.setChanged()
                    }
                    getFragmentShader() {
                        return this.fragmentShader
                    }
                    setFragmentShader(e) {
                        this.fragmentShader = e,
                        this.setChanged()
                    }
                    getVertexShader() {
                        return this.vertexShader
                    }
                    setVertexShader(e) {
                        this.vertexShader = e,
                        this.setChanged()
                    }
                    setChanged() {
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    setDepthTexture(e, t=as) {}
                    update(e, t, n) {}
                    setSize(e, t) {}
                    initialize(e, t, n) {}
                    dispose() {
                        for (const e of Object.keys(this)) {
                            const t = this[e];
                            (t instanceof Vn || t instanceof qs || t instanceof Fi || t instanceof sa) && this[e].dispose()
                        }
                    }
                }
                  , am = {
                    VERY_SMALL: 0,
                    SMALL: 1,
                    MEDIUM: 2,
                    LARGE: 3,
                    VERY_LARGE: 4,
                    HUGE: 5
                }
                  , WF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`
                  , YF = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , qF = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]
                  , jF = class extends kn {
                    constructor(e=new hn) {
                        super({
                            name: "KawaseBlurMaterial",
                            uniforms: {
                                inputBuffer: new ke(null),
                                texelSize: new ke(new hn),
                                scale: new ke(1),
                                kernel: new ke(0)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: WF,
                            vertexShader: YF
                        }),
                        this.setTexelSize(e.x, e.y),
                        this.kernelSize = am.MEDIUM
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.inputBuffer = e
                    }
                    get kernelSequence() {
                        return qF[this.kernelSize]
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(e) {
                        this.uniforms.scale.value = e
                    }
                    getScale() {
                        return this.uniforms.scale.value
                    }
                    setScale(e) {
                        this.uniforms.scale.value = e
                    }
                    getKernel() {
                        return null
                    }
                    get kernel() {
                        return this.uniforms.kernel.value
                    }
                    set kernel(e) {
                        this.uniforms.kernel.value = e
                    }
                    setKernel(e) {
                        this.kernel = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t, e * .5, t * .5)
                    }
                    setSize(e, t) {
                        const n = 1 / e
                          , i = 1 / t;
                        this.uniforms.texelSize.value.set(n, i, n * .5, i * .5)
                    }
                }
                  , PS = class extends sa {
                    constructor({kernelSize: e=am.MEDIUM, resolutionScale: t=.5, width: n=Zn.AUTO_SIZE, height: i=Zn.AUTO_SIZE, resolutionX: s=n, resolutionY: a=i}={}) {
                        super("KawaseBlurPass"),
                        this.renderTargetA = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetA.texture.name = "Blur.Target.A",
                        this.renderTargetB = this.renderTargetA.clone(),
                        this.renderTargetB.texture.name = "Blur.Target.B";
                        const o = this.resolution = new Zn(this,s,a,t);
                        o.addEventListener("change", c => this.setSize(o.baseWidth, o.baseHeight)),
                        this._blurMaterial = new jF,
                        this._blurMaterial.kernelSize = e,
                        this.copyMaterial = new eD
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get blurMaterial() {
                        return this._blurMaterial
                    }
                    set blurMaterial(e) {
                        this._blurMaterial = e
                    }
                    get dithering() {
                        return this.copyMaterial.dithering
                    }
                    set dithering(e) {
                        this.copyMaterial.dithering = e
                    }
                    get kernelSize() {
                        return this.blurMaterial.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurMaterial.kernelSize = e
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get scale() {
                        return this.blurMaterial.scale
                    }
                    set scale(e) {
                        this.blurMaterial.scale = e
                    }
                    getScale() {
                        return this.blurMaterial.scale
                    }
                    setScale(e) {
                        this.blurMaterial.scale = e
                    }
                    getKernelSize() {
                        return this.kernelSize
                    }
                    setKernelSize(e) {
                        this.kernelSize = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, s) {
                        const a = this.scene
                          , o = this.camera
                          , c = this.renderTargetA
                          , u = this.renderTargetB
                          , f = this.blurMaterial
                          , m = f.kernelSequence;
                        let v = t;
                        this.fullscreenMaterial = f;
                        for (let y = 0, S = m.length; y < S; ++y) {
                            const A = (y & 1) === 0 ? c : u;
                            f.kernel = m[y],
                            f.inputBuffer = v.texture,
                            e.setRenderTarget(A),
                            e.render(a, o),
                            v = A
                        }
                        this.fullscreenMaterial = this.copyMaterial,
                        this.copyMaterial.inputBuffer = v.texture,
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        e.render(a, o)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.renderTargetA.setSize(i, s),
                        this.renderTargetB.setSize(i, s),
                        this.blurMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && (this.renderTargetA.texture.type = n,
                        this.renderTargetB.texture.type = n,
                        n !== gi ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : e !== null && e.outputColorSpace === Zt && (this.renderTargetA.texture.colorSpace = Zt,
                        this.renderTargetB.texture.colorSpace = Zt))
                    }
                    static get AUTO_SIZE() {
                        return Zn.AUTO_SIZE
                    }
                }
                  , QF = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`
                  , ZF = class extends kn {
                    constructor(e=!1, t=null) {
                        super({
                            name: "LuminanceMaterial",
                            defines: {
                                THREE_REVISION: jc.replace(/\D+/g, "")
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                threshold: new ke(0),
                                smoothing: new ke(1),
                                range: new ke(null)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: QF,
                            vertexShader: Wf
                        }),
                        this.colorOutput = e,
                        this.luminanceRange = t
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get threshold() {
                        return this.uniforms.threshold.value
                    }
                    set threshold(e) {
                        this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
                        this.uniforms.threshold.value = e
                    }
                    getThreshold() {
                        return this.threshold
                    }
                    setThreshold(e) {
                        this.threshold = e
                    }
                    get smoothing() {
                        return this.uniforms.smoothing.value
                    }
                    set smoothing(e) {
                        this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
                        this.uniforms.smoothing.value = e
                    }
                    getSmoothingFactor() {
                        return this.smoothing
                    }
                    setSmoothingFactor(e) {
                        this.smoothing = e
                    }
                    get useThreshold() {
                        return this.threshold > 0 || this.smoothing > 0
                    }
                    set useThreshold(e) {}
                    get colorOutput() {
                        return this.defines.COLOR !== void 0
                    }
                    set colorOutput(e) {
                        e ? this.defines.COLOR = "1" : delete this.defines.COLOR,
                        this.needsUpdate = !0
                    }
                    isColorOutputEnabled(e) {
                        return this.colorOutput
                    }
                    setColorOutputEnabled(e) {
                        this.colorOutput = e
                    }
                    get useRange() {
                        return this.luminanceRange !== null
                    }
                    set useRange(e) {
                        this.luminanceRange = null
                    }
                    get luminanceRange() {
                        return this.uniforms.range.value
                    }
                    set luminanceRange(e) {
                        e !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE,
                        this.uniforms.range.value = e,
                        this.needsUpdate = !0
                    }
                    getLuminanceRange() {
                        return this.luminanceRange
                    }
                    setLuminanceRange(e) {
                        this.luminanceRange = e
                    }
                }
                  , KF = class extends sa {
                    constructor({renderTarget: e, luminanceRange: t, colorOutput: n, resolutionScale: i=1, width: s=Zn.AUTO_SIZE, height: a=Zn.AUTO_SIZE, resolutionX: o=s, resolutionY: c=a}={}) {
                        super("LuminancePass"),
                        this.fullscreenMaterial = new ZF(n,t),
                        this.needsSwap = !1,
                        this.renderTarget = e,
                        this.renderTarget === void 0 && (this.renderTarget = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "LuminancePass.Target");
                        const u = this.resolution = new Zn(this,o,c,i);
                        u.addEventListener("change", f => this.setSize(u.baseWidth, u.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    render(e, t, n, i, s) {
                        const a = this.fullscreenMaterial;
                        a.inputBuffer = t.texture,
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && n !== gi && (this.renderTarget.texture.type = n,
                        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                }
                  , JF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`
                  , $F = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , e5 = class extends kn {
                    constructor() {
                        super({
                            name: "DownsamplingMaterial",
                            uniforms: {
                                inputBuffer: new ke(null),
                                texelSize: new ke(new Oe)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: JF,
                            vertexShader: $F
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , t5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`
                  , n5 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , i5 = class extends kn {
                    constructor() {
                        super({
                            name: "UpsamplingMaterial",
                            uniforms: {
                                inputBuffer: new ke(null),
                                supportBuffer: new ke(null),
                                texelSize: new ke(new Oe),
                                radius: new ke(.85)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: t5,
                            vertexShader: n5
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set supportBuffer(e) {
                        this.uniforms.supportBuffer.value = e
                    }
                    get radius() {
                        return this.uniforms.radius.value
                    }
                    set radius(e) {
                        this.uniforms.radius.value = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , s5 = class extends sa {
                    constructor() {
                        super("MipmapBlurPass"),
                        this.needsSwap = !1,
                        this.renderTarget = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "Upsampling.Mipmap0",
                        this.downsamplingMipmaps = [],
                        this.upsamplingMipmaps = [],
                        this.downsamplingMaterial = new e5,
                        this.upsamplingMaterial = new i5,
                        this.resolution = new Oe
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    get levels() {
                        return this.downsamplingMipmaps.length
                    }
                    set levels(e) {
                        if (this.levels !== e) {
                            const t = this.renderTarget;
                            this.dispose(),
                            this.downsamplingMipmaps = [],
                            this.upsamplingMipmaps = [];
                            for (let n = 0; n < e; ++n) {
                                const i = t.clone();
                                i.texture.name = "Downsampling.Mipmap" + n,
                                this.downsamplingMipmaps.push(i)
                            }
                            this.upsamplingMipmaps.push(t);
                            for (let n = 1, i = e - 1; n < i; ++n) {
                                const s = t.clone();
                                s.texture.name = "Upsampling.Mipmap" + n,
                                this.upsamplingMipmaps.push(s)
                            }
                            this.setSize(this.resolution.x, this.resolution.y)
                        }
                    }
                    get radius() {
                        return this.upsamplingMaterial.radius
                    }
                    set radius(e) {
                        this.upsamplingMaterial.radius = e
                    }
                    render(e, t, n, i, s) {
                        const {scene: a, camera: o} = this
                          , {downsamplingMaterial: c, upsamplingMaterial: u} = this
                          , {downsamplingMipmaps: f, upsamplingMipmaps: m} = this;
                        let v = t;
                        this.fullscreenMaterial = c;
                        for (let y = 0, S = f.length; y < S; ++y) {
                            const A = f[y];
                            c.setSize(v.width, v.height),
                            c.inputBuffer = v.texture,
                            e.setRenderTarget(A),
                            e.render(a, o),
                            v = A
                        }
                        this.fullscreenMaterial = u;
                        for (let y = m.length - 1; y >= 0; --y) {
                            const S = m[y];
                            u.setSize(v.width, v.height),
                            u.inputBuffer = v.texture,
                            u.supportBuffer = f[y].texture,
                            e.setRenderTarget(S),
                            e.render(a, o),
                            v = S
                        }
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.set(e, t);
                        let i = n.width
                          , s = n.height;
                        for (let a = 0, o = this.downsamplingMipmaps.length; a < o; ++a)
                            i = Math.round(i * .5),
                            s = Math.round(s * .5),
                            this.downsamplingMipmaps[a].setSize(i, s),
                            a < this.upsamplingMipmaps.length && this.upsamplingMipmaps[a].setSize(i, s)
                    }
                    initialize(e, t, n) {
                        if (n !== void 0) {
                            const i = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                            for (const s of i)
                                s.texture.type = n;
                            if (n !== gi)
                                this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                                this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                            else if (e !== null && e.outputColorSpace === Zt)
                                for (const s of i)
                                    s.texture.colorSpace = Zt
                        }
                    }
                    dispose() {
                        super.dispose();
                        for (const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
                            e.dispose()
                    }
                }
                  , a5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`
                  , aD = class extends Vi {
                    constructor({blendFunction: e=Wt.SCREEN, luminanceThreshold: t=1, luminanceSmoothing: n=.03, mipmapBlur: i=!0, intensity: s=1, radius: a=.85, levels: o=8, kernelSize: c=am.LARGE, resolutionScale: u=.5, width: f=Zn.AUTO_SIZE, height: m=Zn.AUTO_SIZE, resolutionX: v=f, resolutionY: y=m}={}) {
                        super("BloomEffect", a5, {
                            blendFunction: e,
                            uniforms: new Map([["map", new ke(null)], ["intensity", new ke(s)]])
                        }),
                        this.renderTarget = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "Bloom.Target",
                        this.blurPass = new PS({
                            kernelSize: c
                        }),
                        this.luminancePass = new KF({
                            colorOutput: !0
                        }),
                        this.luminanceMaterial.threshold = t,
                        this.luminanceMaterial.smoothing = n,
                        this.mipmapBlurPass = new s5,
                        this.mipmapBlurPass.enabled = i,
                        this.mipmapBlurPass.radius = a,
                        this.mipmapBlurPass.levels = o,
                        this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
                        const S = this.resolution = new Zn(this,v,y,u);
                        S.addEventListener("change", A => this.setSize(S.baseWidth, S.baseHeight))
                    }
                    get texture() {
                        return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
                    }
                    getTexture() {
                        return this.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getLuminancePass() {
                        return this.luminancePass
                    }
                    get luminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    getLuminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get dithering() {
                        return this.blurPass.dithering
                    }
                    set dithering(e) {
                        this.blurPass.dithering = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    get distinction() {
                        return console.warn(this.name, "distinction was removed"),
                        1
                    }
                    set distinction(e) {
                        console.warn(this.name, "distinction was removed")
                    }
                    get intensity() {
                        return this.uniforms.get("intensity").value
                    }
                    set intensity(e) {
                        this.uniforms.get("intensity").value = e
                    }
                    getIntensity() {
                        return this.intensity
                    }
                    setIntensity(e) {
                        this.intensity = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    update(e, t, n) {
                        const i = this.renderTarget
                          , s = this.luminancePass;
                        s.enabled ? (s.render(e, t),
                        this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, s.renderTarget) : this.blurPass.render(e, s.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, t) : this.blurPass.render(e, t, i)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height),
                        this.blurPass.resolution.copy(n),
                        this.luminancePass.setSize(e, t),
                        this.mipmapBlurPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, n),
                        this.luminancePass.initialize(e, t, n),
                        this.mipmapBlurPass.initialize(e, t, n),
                        n !== void 0 && (this.renderTarget.texture.type = n,
                        e !== null && e.outputColorSpace === Zt && (this.renderTarget.texture.colorSpace = Zt))
                    }
                }
                  , r5 = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}"
                  , o5 = class extends Vi {
                    constructor({blendFunction: e=Wt.SRC, brightness: t=0, contrast: n=0}={}) {
                        super("BrightnessContrastEffect", r5, {
                            blendFunction: e,
                            uniforms: new Map([["brightness", new ke(t)], ["contrast", new ke(n)]])
                        }),
                        this.inputColorSpace = Zt
                    }
                    get brightness() {
                        return this.uniforms.get("brightness").value
                    }
                    set brightness(e) {
                        this.uniforms.get("brightness").value = e
                    }
                    getBrightness() {
                        return this.brightness
                    }
                    setBrightness(e) {
                        this.brightness = e
                    }
                    get contrast() {
                        return this.uniforms.get("contrast").value
                    }
                    set contrast(e) {
                        this.uniforms.get("contrast").value = e
                    }
                    getContrast() {
                        return this.contrast
                    }
                    setContrast(e) {
                        this.contrast = e
                    }
                }
                  , l5 = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}"
                  , c5 = class extends Vi {
                    constructor(e) {
                        super("ColorAverageEffect", l5, {
                            blendFunction: e
                        })
                    }
                }
                  , u5 = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}"
                  , h5 = class extends Vi {
                    constructor({blendFunction: e, bits: t=16}={}) {
                        super("ColorDepthEffect", u5, {
                            blendFunction: e,
                            uniforms: new Map([["factor", new ke(1)]])
                        }),
                        this.bits = 0,
                        this.bitDepth = t
                    }
                    get bitDepth() {
                        return this.bits
                    }
                    set bitDepth(e) {
                        this.bits = e,
                        this.uniforms.get("factor").value = Math.pow(2, e / 3)
                    }
                    getBitDepth() {
                        return this.bitDepth
                    }
                    setBitDepth(e) {
                        this.bitDepth = e
                    }
                }
                  , f5 = `#ifdef RADIAL_MODULATION
uniform float modulationOffset;
#endif
varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;
#ifdef RADIAL_MODULATION
const vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}
#else
if(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}
#endif
outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}`
                  , d5 = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}"
                  , p5 = class extends Vi {
                    constructor({offset: e=new Oe(.001,5e-4), radialModulation: t=!1, modulationOffset: n=.15}={}) {
                        super("ChromaticAberrationEffect", f5, {
                            vertexShader: d5,
                            attributes: ar.CONVOLUTION,
                            uniforms: new Map([["offset", new ke(e)], ["modulationOffset", new ke(n)]])
                        }),
                        this.radialModulation = t
                    }
                    get offset() {
                        return this.uniforms.get("offset").value
                    }
                    set offset(e) {
                        this.uniforms.get("offset").value = e
                    }
                    get radialModulation() {
                        return this.defines.has("RADIAL_MODULATION")
                    }
                    set radialModulation(e) {
                        e ? this.defines.set("RADIAL_MODULATION", "1") : this.defines.delete("RADIAL_MODULATION"),
                        this.setChanged()
                    }
                    get modulationOffset() {
                        return this.uniforms.get("modulationOffset").value
                    }
                    set modulationOffset(e) {
                        this.uniforms.get("modulationOffset").value = e
                    }
                    getOffset() {
                        return this.offset
                    }
                    setOffset(e) {
                        this.offset = e
                    }
                }
                  , m5 = `void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){
#ifdef INVERTED
vec3 color=vec3(1.0-depth);
#else
vec3 color=vec3(depth);
#endif
outputColor=vec4(color,inputColor.a);}`
                  , v5 = class extends Vi {
                    constructor({blendFunction: e=Wt.SRC, inverted: t=!1}={}) {
                        super("DepthEffect", m5, {
                            blendFunction: e,
                            attributes: ar.DEPTH
                        }),
                        this.inverted = t
                    }
                    get inverted() {
                        return this.defines.has("INVERTED")
                    }
                    set inverted(e) {
                        this.inverted !== e && (e ? this.defines.set("INVERTED", "1") : this.defines.delete("INVERTED"),
                        this.setChanged())
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                }
                  , rD = {
                    RED: 0,
                    GREEN: 1,
                    BLUE: 2,
                    ALPHA: 3
                }
                  , CM = {
                    DISCARD: 0,
                    MULTIPLY: 1,
                    MULTIPLY_RGB_SET_ALPHA: 2,
                    MULTIPLY_RGB: 3
                }
                  , g5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;
#else
float coc=texture2D(cocBuffer,vUv).g*scale;
#endif
if(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);
#else
vec2 step=texelSize*coc;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`
                  , zS = class extends kn {
                    constructor(e=!1, t=!1) {
                        super({
                            name: "BokehMaterial",
                            defines: {
                                PASS: e ? "2" : "1"
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                cocBuffer: new ke(null),
                                texelSize: new ke(new Oe),
                                kernel64: new ke(null),
                                kernel16: new ke(null),
                                scale: new ke(1)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: g5,
                            vertexShader: Wf
                        }),
                        t && (this.defines.FOREGROUND = "1"),
                        this.generateKernel()
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set cocBuffer(e) {
                        this.uniforms.cocBuffer.value = e
                    }
                    setCoCBuffer(e) {
                        this.uniforms.cocBuffer.value = e
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(e) {
                        this.uniforms.scale.value = e
                    }
                    getScale(e) {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    generateKernel() {
                        const e = 2.39996323
                          , t = new Float64Array(128)
                          , n = new Float64Array(32);
                        let i = 0
                          , s = 0;
                        for (let a = 0, o = Math.sqrt(80); a < 80; ++a) {
                            const c = a * e
                              , u = Math.sqrt(a) / o
                              , f = u * Math.cos(c)
                              , m = u * Math.sin(c);
                            a % 5 === 0 ? (n[s++] = f,
                            n[s++] = m) : (t[i++] = f,
                            t[i++] = m)
                        }
                        this.uniforms.kernel64.value = t,
                        this.uniforms.kernel16.value = n
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                ;
                function rm(e, t, n) {
                    return e * (t - n) - t
                }
                function Yf(e, t, n) {
                    return Math.min(Math.max((e + t) / (t - n), 0), 1)
                }
                var y5 = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#ifdef LOG_DEPTH
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#endif
return depth;}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`
                  , _5 = class extends kn {
                    constructor(e) {
                        super({
                            name: "CircleOfConfusionMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new ke(null),
                                focusDistance: new ke(0),
                                focusRange: new ke(0),
                                cameraNear: new ke(.3),
                                cameraFar: new ke(1e3)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: y5,
                            vertexShader: Wf
                        }),
                        this.uniforms.focalLength = this.uniforms.focusRange,
                        this.copyCameraSettings(e)
                    }
                    get near() {
                        return this.uniforms.cameraNear.value
                    }
                    get far() {
                        return this.uniforms.cameraFar.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=as) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    get focusDistance() {
                        return this.uniforms.focusDistance.value
                    }
                    set focusDistance(e) {
                        this.uniforms.focusDistance.value = e
                    }
                    get worldFocusDistance() {
                        return -rm(this.focusDistance, this.near, this.far)
                    }
                    set worldFocusDistance(e) {
                        this.focusDistance = Yf(-e, this.near, this.far)
                    }
                    getFocusDistance(e) {
                        this.uniforms.focusDistance.value = e
                    }
                    setFocusDistance(e) {
                        this.uniforms.focusDistance.value = e
                    }
                    get focalLength() {
                        return this.focusRange
                    }
                    set focalLength(e) {
                        this.focusRange = e
                    }
                    get focusRange() {
                        return this.uniforms.focusRange.value
                    }
                    set focusRange(e) {
                        this.uniforms.focusRange.value = e
                    }
                    get worldFocusRange() {
                        return -rm(this.focusRange, this.near, this.far)
                    }
                    set worldFocusRange(e) {
                        this.focusRange = Yf(-e, this.near, this.far)
                    }
                    getFocalLength(e) {
                        return this.focusRange
                    }
                    setFocalLength(e) {
                        this.focusRange = e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near,
                        this.uniforms.cameraFar.value = e.far,
                        e instanceof Hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                }
                  , S5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 3
vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);
#elif MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`
                  , x5 = class extends kn {
                    constructor(e=null) {
                        super({
                            name: "MaskMaterial",
                            uniforms: {
                                maskTexture: new ke(e),
                                inputBuffer: new ke(null),
                                strength: new ke(1)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: S5,
                            vertexShader: Wf
                        }),
                        this.colorChannel = rD.RED,
                        this.maskFunction = CM.DISCARD
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set maskTexture(e) {
                        this.uniforms.maskTexture.value = e,
                        delete this.defines.MASK_PRECISION_HIGH,
                        e.type !== gi && (this.defines.MASK_PRECISION_HIGH = "1"),
                        this.needsUpdate = !0
                    }
                    setMaskTexture(e) {
                        this.maskTexture = e
                    }
                    set colorChannel(e) {
                        this.defines.COLOR_CHANNEL = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setColorChannel(e) {
                        this.colorChannel = e
                    }
                    set maskFunction(e) {
                        this.defines.MASK_FUNCTION = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setMaskFunction(e) {
                        this.maskFunction = e
                    }
                    get inverted() {
                        return this.defines.INVERTED !== void 0
                    }
                    set inverted(e) {
                        this.inverted && !e ? delete this.defines.INVERTED : e && (this.defines.INVERTED = "1"),
                        this.needsUpdate = !0
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    get strength() {
                        return this.uniforms.strength.value
                    }
                    set strength(e) {
                        this.uniforms.strength.value = e
                    }
                    getStrength() {
                        return this.strength
                    }
                    setStrength(e) {
                        this.strength = e
                    }
                }
                  , Kr = class extends sa {
                    constructor(e, t="inputBuffer") {
                        super("ShaderPass"),
                        this.fullscreenMaterial = e,
                        this.input = t
                    }
                    setInput(e) {
                        this.input = e
                    }
                    render(e, t, n, i, s) {
                        const a = this.fullscreenMaterial.uniforms;
                        t !== null && a !== void 0 && a[this.input] !== void 0 && (a[this.input].value = t.texture),
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        e.render(this.scene, this.camera)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && n !== gi && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                }
                  , A5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);
#if MASK_FUNCTION == 1
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);
#else
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);
#endif
vec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}`
                  , T5 = class extends Vi {
                    constructor(e, {blendFunction: t, worldFocusDistance: n, worldFocusRange: i, focusDistance: s=0, focalLength: a=.1, focusRange: o=a, bokehScale: c=1, resolutionScale: u=1, width: f=Zn.AUTO_SIZE, height: m=Zn.AUTO_SIZE, resolutionX: v=f, resolutionY: y=m}={}) {
                        super("DepthOfFieldEffect", A5, {
                            blendFunction: t,
                            attributes: ar.DEPTH,
                            uniforms: new Map([["nearColorBuffer", new ke(null)], ["farColorBuffer", new ke(null)], ["nearCoCBuffer", new ke(null)], ["farCoCBuffer", new ke(null)], ["scale", new ke(1)]])
                        }),
                        this.camera = e,
                        this.renderTarget = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "DoF.Intermediate",
                        this.renderTargetMasked = this.renderTarget.clone(),
                        this.renderTargetMasked.texture.name = "DoF.Masked.Far",
                        this.renderTargetNear = this.renderTarget.clone(),
                        this.renderTargetNear.texture.name = "DoF.Bokeh.Near",
                        this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture,
                        this.renderTargetFar = this.renderTarget.clone(),
                        this.renderTargetFar.texture.name = "DoF.Bokeh.Far",
                        this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture,
                        this.renderTargetCoC = this.renderTarget.clone(),
                        this.renderTargetCoC.texture.name = "DoF.CoC",
                        this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture,
                        this.renderTargetCoCBlurred = this.renderTargetCoC.clone(),
                        this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred",
                        this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture,
                        this.cocPass = new Kr(new _5(e));
                        const S = this.cocMaterial;
                        S.focusDistance = s,
                        S.focusRange = o,
                        n !== void 0 && (S.worldFocusDistance = n),
                        i !== void 0 && (S.worldFocusRange = i),
                        this.blurPass = new PS({
                            resolutionScale: u,
                            resolutionX: v,
                            resolutionY: y,
                            kernelSize: am.MEDIUM
                        }),
                        this.maskPass = new Kr(new x5(this.renderTargetCoC.texture));
                        const A = this.maskPass.fullscreenMaterial;
                        A.colorChannel = rD.GREEN,
                        this.maskFunction = CM.MULTIPLY_RGB,
                        this.bokehNearBasePass = new Kr(new zS(!1,!0)),
                        this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture,
                        this.bokehNearFillPass = new Kr(new zS(!0,!0)),
                        this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture,
                        this.bokehFarBasePass = new Kr(new zS(!1,!1)),
                        this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture,
                        this.bokehFarFillPass = new Kr(new zS(!0,!1)),
                        this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture,
                        this.target = null;
                        const M = this.resolution = new Zn(this,v,y,u);
                        M.addEventListener("change", x => this.setSize(M.baseWidth, M.baseHeight)),
                        this.bokehScale = c
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.cocMaterial.copyCameraSettings(e)
                    }
                    get cocTexture() {
                        return this.renderTargetCoC.texture
                    }
                    get maskFunction() {
                        return this.maskPass.fullscreenMaterial.maskFunction
                    }
                    set maskFunction(e) {
                        this.maskFunction !== e && (this.defines.set("MASK_FUNCTION", e.toFixed(0)),
                        this.maskPass.fullscreenMaterial.maskFunction = e,
                        this.setChanged())
                    }
                    get cocMaterial() {
                        return this.cocPass.fullscreenMaterial
                    }
                    get circleOfConfusionMaterial() {
                        return this.cocMaterial
                    }
                    getCircleOfConfusionMaterial() {
                        return this.cocMaterial
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get bokehScale() {
                        return this.uniforms.get("scale").value
                    }
                    set bokehScale(e) {
                        this.bokehNearBasePass.fullscreenMaterial.scale = e,
                        this.bokehNearFillPass.fullscreenMaterial.scale = e,
                        this.bokehFarBasePass.fullscreenMaterial.scale = e,
                        this.bokehFarFillPass.fullscreenMaterial.scale = e,
                        this.maskPass.fullscreenMaterial.strength = e,
                        this.uniforms.get("scale").value = e
                    }
                    getBokehScale() {
                        return this.bokehScale
                    }
                    setBokehScale(e) {
                        this.bokehScale = e
                    }
                    getTarget() {
                        return this.target
                    }
                    setTarget(e) {
                        this.target = e
                    }
                    calculateFocusDistance(e) {
                        const t = this.camera
                          , n = t.position.distanceTo(e);
                        return Yf(-n, t.near, t.far)
                    }
                    setDepthTexture(e, t=as) {
                        this.cocMaterial.depthBuffer = e,
                        this.cocMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        const i = this.renderTarget
                          , s = this.renderTargetCoC
                          , a = this.renderTargetCoCBlurred
                          , o = this.renderTargetMasked;
                        if (this.target !== null) {
                            const c = this.calculateFocusDistance(this.target);
                            this.cocMaterial.focusDistance = c
                        }
                        this.cocPass.render(e, null, s),
                        this.blurPass.render(e, s, a),
                        this.maskPass.render(e, t, o),
                        this.bokehFarBasePass.render(e, o, i),
                        this.bokehFarFillPass.render(e, i, this.renderTargetFar),
                        this.bokehNearBasePass.render(e, t, i),
                        this.bokehNearFillPass.render(e, i, this.renderTargetNear)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.cocPass.setSize(e, t),
                        this.blurPass.setSize(e, t),
                        this.maskPass.setSize(e, t),
                        this.renderTargetFar.setSize(e, t),
                        this.renderTargetCoC.setSize(e, t),
                        this.renderTargetMasked.setSize(e, t),
                        this.renderTarget.setSize(i, s),
                        this.renderTargetNear.setSize(i, s),
                        this.renderTargetCoCBlurred.setSize(i, s),
                        this.bokehNearBasePass.fullscreenMaterial.setSize(e, t),
                        this.bokehNearFillPass.fullscreenMaterial.setSize(e, t),
                        this.bokehFarBasePass.fullscreenMaterial.setSize(e, t),
                        this.bokehFarFillPass.fullscreenMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.cocPass.initialize(e, t, n),
                        this.maskPass.initialize(e, t, n),
                        this.bokehNearBasePass.initialize(e, t, n),
                        this.bokehNearFillPass.initialize(e, t, n),
                        this.bokehFarBasePass.initialize(e, t, n),
                        this.bokehFarFillPass.initialize(e, t, n),
                        this.blurPass.initialize(e, t, gi),
                        e.capabilities.logarithmicDepthBuffer && (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
                        n !== void 0 && (this.renderTarget.texture.type = n,
                        this.renderTargetNear.texture.type = n,
                        this.renderTargetFar.texture.type = n,
                        this.renderTargetMasked.texture.type = n,
                        e !== null && e.outputColorSpace === Zt && (this.renderTarget.texture.colorSpace = Zt,
                        this.renderTargetNear.texture.colorSpace = Zt,
                        this.renderTargetFar.texture.colorSpace = Zt,
                        this.renderTargetMasked.texture.colorSpace = Zt))
                    }
                }
                  , M5 = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}"
                  , b5 = class extends Vi {
                    constructor({blendFunction: e, angle: t=Math.PI * .5, scale: n=1}={}) {
                        super("DotScreenEffect", M5, {
                            blendFunction: e,
                            uniforms: new Map([["angle", new ke(new Oe)], ["scale", new ke(n)]])
                        }),
                        this.angle = t
                    }
                    get angle() {
                        return Math.acos(this.uniforms.get("angle").value.y)
                    }
                    set angle(e) {
                        this.uniforms.get("angle").value.set(Math.sin(e), Math.cos(e))
                    }
                    getAngle() {
                        return this.angle
                    }
                    setAngle(e) {
                        this.angle = e
                    }
                    get scale() {
                        return this.uniforms.get("scale").value
                    }
                    set scale(e) {
                        this.uniforms.get("scale").value = e
                    }
                }
                  , E5 = `#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))
#define ONE_OVER_TWELVE 0.08333333333333333
varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}`
                  , C5 = "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}"
                  , w5 = class extends Vi {
                    constructor({blendFunction: e=Wt.SRC}={}) {
                        super("FXAAEffect", E5, {
                            vertexShader: C5,
                            blendFunction: e,
                            defines: new Map([["EDGE_THRESHOLD_MIN", "0.0312"], ["EDGE_THRESHOLD_MAX", "0.125"], ["SUBPIXEL_QUALITY", "0.75"], ["SAMPLES", "12"]])
                        })
                    }
                    get minEdgeThreshold() {
                        return Number(this.defines.get("EDGE_THRESHOLD_MIN"))
                    }
                    set minEdgeThreshold(e) {
                        this.defines.set("EDGE_THRESHOLD_MIN", e.toFixed(12)),
                        this.setChanged()
                    }
                    get maxEdgeThreshold() {
                        return Number(this.defines.get("EDGE_THRESHOLD_MAX"))
                    }
                    set maxEdgeThreshold(e) {
                        this.defines.set("EDGE_THRESHOLD_MAX", e.toFixed(12)),
                        this.setChanged()
                    }
                    get subpixelQuality() {
                        return Number(this.defines.get("SUBPIXEL_QUALITY"))
                    }
                    set subpixelQuality(e) {
                        this.defines.set("SUBPIXEL_QUALITY", e.toFixed(12)),
                        this.setChanged()
                    }
                    get samples() {
                        return Number(this.defines.get("SAMPLES"))
                    }
                    set samples(e) {
                        this.defines.set("SAMPLES", e.toFixed(0)),
                        this.setChanged()
                    }
                }
                  , qf = {
                    DISABLED: 0,
                    SPORADIC: 1,
                    CONSTANT_MILD: 2,
                    CONSTANT_WILD: 3
                };
                function D5(e, t, n) {
                    const i = new Map([[gp, 1], [ky, 2], [ps, 4]]);
                    let s;
                    if (i.has(t) || console.error("Invalid noise texture format"),
                    n === gi) {
                        s = new Uint8Array(e * i.get(t));
                        for (let a = 0, o = s.length; a < o; ++a)
                            s[a] = Math.random() * 255 + .5
                    } else {
                        s = new Float32Array(e * i.get(t));
                        for (let a = 0, o = s.length; a < o; ++a)
                            s[a] = Math.random()
                    }
                    return s
                }
                var wM = class extends ul {
                    constructor(e, t, n=gp, i=gi) {
                        super(D5(e * t, n, i), e, t, n, i),
                        this.needsUpdate = !0
                    }
                }
                  , R5 = "uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}"
                  , FS = "Glitch.Generated";
                function Tr(e, t) {
                    return e + Math.random() * (t - e)
                }
                var U5 = class extends Vi {
                    constructor({chromaticAberrationOffset: e=null, delay: t=new Oe(1.5,3.5), duration: n=new Oe(.6,1), strength: i=new Oe(.3,1), columns: s=.05, ratio: a=.85, perturbationMap: o=null, dtSize: c=64}={}) {
                        if (super("GlitchEffect", R5, {
                            uniforms: new Map([["perturbationMap", new ke(null)], ["columns", new ke(s)], ["active", new ke(!1)], ["random", new ke(1)], ["seeds", new ke(new Oe)], ["distortion", new ke(new Oe)]])
                        }),
                        o === null) {
                            const u = new wM(c,c,ps);
                            u.name = FS,
                            this.perturbationMap = u
                        } else
                            this.perturbationMap = o;
                        this.time = 0,
                        this.distortion = this.uniforms.get("distortion").value,
                        this.delay = t,
                        this.duration = n,
                        this.breakPoint = new Oe(Tr(this.delay.x, this.delay.y),Tr(this.duration.x, this.duration.y)),
                        this.strength = i,
                        this.mode = qf.SPORADIC,
                        this.ratio = a,
                        this.chromaticAberrationOffset = e
                    }
                    get seeds() {
                        return this.uniforms.get("seeds").value
                    }
                    get active() {
                        return this.uniforms.get("active").value
                    }
                    isActive() {
                        return this.active
                    }
                    get minDelay() {
                        return this.delay.x
                    }
                    set minDelay(e) {
                        this.delay.x = e
                    }
                    getMinDelay() {
                        return this.delay.x
                    }
                    setMinDelay(e) {
                        this.delay.x = e
                    }
                    get maxDelay() {
                        return this.delay.y
                    }
                    set maxDelay(e) {
                        this.delay.y = e
                    }
                    getMaxDelay() {
                        return this.delay.y
                    }
                    setMaxDelay(e) {
                        this.delay.y = e
                    }
                    get minDuration() {
                        return this.duration.x
                    }
                    set minDuration(e) {
                        this.duration.x = e
                    }
                    getMinDuration() {
                        return this.duration.x
                    }
                    setMinDuration(e) {
                        this.duration.x = e
                    }
                    get maxDuration() {
                        return this.duration.y
                    }
                    set maxDuration(e) {
                        this.duration.y = e
                    }
                    getMaxDuration() {
                        return this.duration.y
                    }
                    setMaxDuration(e) {
                        this.duration.y = e
                    }
                    get minStrength() {
                        return this.strength.x
                    }
                    set minStrength(e) {
                        this.strength.x = e
                    }
                    getMinStrength() {
                        return this.strength.x
                    }
                    setMinStrength(e) {
                        this.strength.x = e
                    }
                    get maxStrength() {
                        return this.strength.y
                    }
                    set maxStrength(e) {
                        this.strength.y = e
                    }
                    getMaxStrength() {
                        return this.strength.y
                    }
                    setMaxStrength(e) {
                        this.strength.y = e
                    }
                    getMode() {
                        return this.mode
                    }
                    setMode(e) {
                        this.mode = e
                    }
                    getGlitchRatio() {
                        return 1 - this.ratio
                    }
                    setGlitchRatio(e) {
                        this.ratio = Math.min(Math.max(1 - e, 0), 1)
                    }
                    get columns() {
                        return this.uniforms.get("columns").value
                    }
                    set columns(e) {
                        this.uniforms.get("columns").value = e
                    }
                    getGlitchColumns() {
                        return this.columns
                    }
                    setGlitchColumns(e) {
                        this.columns = e
                    }
                    getChromaticAberrationOffset() {
                        return this.chromaticAberrationOffset
                    }
                    setChromaticAberrationOffset(e) {
                        this.chromaticAberrationOffset = e
                    }
                    get perturbationMap() {
                        return this.uniforms.get("perturbationMap").value
                    }
                    set perturbationMap(e) {
                        const t = this.perturbationMap;
                        t !== null && t.name === FS && t.dispose(),
                        e.minFilter = e.magFilter = ri,
                        e.wrapS = e.wrapT = sh,
                        e.generateMipmaps = !1,
                        this.uniforms.get("perturbationMap").value = e
                    }
                    getPerturbationMap() {
                        return this.perturbationMap
                    }
                    setPerturbationMap(e) {
                        this.perturbationMap = e
                    }
                    generatePerturbationMap(e=64) {
                        const t = new wM(e,e,ps);
                        return t.name = FS,
                        t
                    }
                    update(e, t, n) {
                        const i = this.mode
                          , s = this.breakPoint
                          , a = this.chromaticAberrationOffset
                          , o = this.strength;
                        let c = this.time, u = !1, f = 0, m = 0, v;
                        i !== qf.DISABLED && (i === qf.SPORADIC && (c += n,
                        v = c > s.x,
                        c >= s.x + s.y && (s.set(Tr(this.delay.x, this.delay.y), Tr(this.duration.x, this.duration.y)),
                        c = 0)),
                        f = Math.random(),
                        this.uniforms.get("random").value = f,
                        v && f > this.ratio || i === qf.CONSTANT_WILD ? (u = !0,
                        f *= o.y * .03,
                        m = Tr(-Math.PI, Math.PI),
                        this.seeds.set(Tr(-o.y, o.y), Tr(-o.y, o.y)),
                        this.distortion.set(Tr(0, 1), Tr(0, 1))) : (v || i === qf.CONSTANT_MILD) && (u = !0,
                        f *= o.x * .03,
                        m = Tr(-Math.PI, Math.PI),
                        this.seeds.set(Tr(-o.x, o.x), Tr(-o.x, o.x)),
                        this.distortion.set(Tr(0, 1), Tr(0, 1))),
                        this.time = c),
                        a !== null && (u ? a.set(Math.cos(m), Math.sin(m)).multiplyScalar(f) : a.set(0, 0)),
                        this.uniforms.get("active").value = u
                    }
                    dispose() {
                        const e = this.perturbationMap;
                        e !== null && e.name === FS && e.dispose()
                    }
                }
                  , Jg = {
                    DEFAULT: 0,
                    KEEP_MAX_DEPTH: 1,
                    DISCARD_MAX_DEPTH: 2
                }
                  , O5 = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;
#endif
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;
#endif
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`
                  , oD = class extends kn {
                    constructor() {
                        super({
                            name: "DepthMaskMaterial",
                            defines: {
                                DEPTH_EPSILON: "0.0001",
                                DEPTH_PACKING_0: "0",
                                DEPTH_PACKING_1: "0",
                                DEPTH_TEST_STRATEGY: Jg.KEEP_MAX_DEPTH
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                depthBuffer0: new ke(null),
                                depthBuffer1: new ke(null),
                                cameraNearFar: new ke(new Oe(1,1))
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: O5,
                            vertexShader: Wf
                        }),
                        this.depthMode = up
                    }
                    set depthBuffer0(e) {
                        this.uniforms.depthBuffer0.value = e
                    }
                    set depthPacking0(e) {
                        this.defines.DEPTH_PACKING_0 = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer0(e, t=as) {
                        this.depthBuffer0 = e,
                        this.depthPacking0 = t
                    }
                    set depthBuffer1(e) {
                        this.uniforms.depthBuffer1.value = e
                    }
                    set depthPacking1(e) {
                        this.defines.DEPTH_PACKING_1 = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer1(e, t=as) {
                        this.depthBuffer1 = e,
                        this.depthPacking1 = t
                    }
                    get maxDepthStrategy() {
                        return Number(this.defines.DEPTH_TEST_STRATEGY)
                    }
                    set maxDepthStrategy(e) {
                        this.defines.DEPTH_TEST_STRATEGY = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    get keepFar() {
                        return this.maxDepthStrategy
                    }
                    set keepFar(e) {
                        this.maxDepthStrategy = e ? Jg.KEEP_MAX_DEPTH : Jg.DISCARD_MAX_DEPTH
                    }
                    getMaxDepthStrategy() {
                        return this.maxDepthStrategy
                    }
                    setMaxDepthStrategy(e) {
                        this.maxDepthStrategy = e
                    }
                    get epsilon() {
                        return Number(this.defines.DEPTH_EPSILON)
                    }
                    set epsilon(e) {
                        this.defines.DEPTH_EPSILON = e.toFixed(16),
                        this.needsUpdate = !0
                    }
                    getEpsilon() {
                        return this.epsilon
                    }
                    setEpsilon(e) {
                        this.epsilon = e
                    }
                    get depthMode() {
                        return Number(this.defines.DEPTH_MODE)
                    }
                    set depthMode(e) {
                        let t;
                        switch (e) {
                        case Kv:
                            t = "false";
                            break;
                        case Jv:
                            t = "true";
                            break;
                        case hf:
                            t = "abs(d1 - d0) <= DEPTH_EPSILON";
                            break;
                        case hp:
                            t = "abs(d1 - d0) > DEPTH_EPSILON";
                            break;
                        case up:
                            t = "d0 > d1";
                            break;
                        case nh:
                            t = "d0 >= d1";
                            break;
                        case $v:
                            t = "d0 <= d1";
                            break;
                        case eg:
                        default:
                            t = "d0 < d1";
                            break
                        }
                        this.defines.DEPTH_MODE = e.toFixed(0),
                        this.defines["depthTest(d0, d1)"] = t,
                        this.needsUpdate = !0
                    }
                    getDepthMode() {
                        return this.depthMode
                    }
                    setDepthMode(e) {
                        this.depthMode = e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNearFar.value.set(e.near, e.far),
                        e instanceof Hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                }
                  , N5 = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);
#include <dithering_fragment>
}`
                  , B5 = class extends kn {
                    constructor(e) {
                        super({
                            name: "GodRaysMaterial",
                            defines: {
                                SAMPLES_INT: "60",
                                SAMPLES_FLOAT: "60.0"
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                lightPosition: new ke(e),
                                density: new ke(1),
                                decay: new ke(1),
                                weight: new ke(1),
                                exposure: new ke(1),
                                clampMax: new ke(1)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: N5,
                            vertexShader: Wf
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get lightPosition() {
                        return this.uniforms.lightPosition.value
                    }
                    getLightPosition() {
                        return this.uniforms.lightPosition.value
                    }
                    setLightPosition(e) {
                        this.uniforms.lightPosition.value = e
                    }
                    get density() {
                        return this.uniforms.density.value
                    }
                    set density(e) {
                        this.uniforms.density.value = e
                    }
                    getDensity() {
                        return this.uniforms.density.value
                    }
                    setDensity(e) {
                        this.uniforms.density.value = e
                    }
                    get decay() {
                        return this.uniforms.decay.value
                    }
                    set decay(e) {
                        this.uniforms.decay.value = e
                    }
                    getDecay() {
                        return this.uniforms.decay.value
                    }
                    setDecay(e) {
                        this.uniforms.decay.value = e
                    }
                    get weight() {
                        return this.uniforms.weight.value
                    }
                    set weight(e) {
                        this.uniforms.weight.value = e
                    }
                    getWeight() {
                        return this.uniforms.weight.value
                    }
                    setWeight(e) {
                        this.uniforms.weight.value = e
                    }
                    get exposure() {
                        return this.uniforms.exposure.value
                    }
                    set exposure(e) {
                        this.uniforms.exposure.value = e
                    }
                    getExposure() {
                        return this.uniforms.exposure.value
                    }
                    setExposure(e) {
                        this.uniforms.exposure.value = e
                    }
                    get maxIntensity() {
                        return this.uniforms.clampMax.value
                    }
                    set maxIntensity(e) {
                        this.uniforms.clampMax.value = e
                    }
                    getMaxIntensity() {
                        return this.uniforms.clampMax.value
                    }
                    setMaxIntensity(e) {
                        this.uniforms.clampMax.value = e
                    }
                    get samples() {
                        return Number(this.defines.SAMPLES_INT)
                    }
                    set samples(e) {
                        const t = Math.floor(e);
                        this.defines.SAMPLES_INT = t.toFixed(0),
                        this.defines.SAMPLES_FLOAT = t.toFixed(1),
                        this.needsUpdate = !0
                    }
                    getSamples() {
                        return this.samples
                    }
                    setSamples(e) {
                        this.samples = e
                    }
                }
                  , $g = class extends sa {
                    constructor(e, t, n=null) {
                        super("RenderPass", e, t),
                        this.needsSwap = !1,
                        this.clearPass = new sm,
                        this.overrideMaterialManager = n === null ? null : new iD(n),
                        this.ignoreBackground = !1,
                        this.skipShadowMapUpdate = !1,
                        this.selection = null
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get renderToScreen() {
                        return super.renderToScreen
                    }
                    set renderToScreen(e) {
                        super.renderToScreen = e,
                        this.clearPass.renderToScreen = e
                    }
                    get overrideMaterial() {
                        const e = this.overrideMaterialManager;
                        return e !== null ? e.material : null
                    }
                    set overrideMaterial(e) {
                        const t = this.overrideMaterialManager;
                        e !== null ? t !== null ? t.setMaterial(e) : this.overrideMaterialManager = new iD(e) : t !== null && (t.dispose(),
                        this.overrideMaterialManager = null)
                    }
                    getOverrideMaterial() {
                        return this.overrideMaterial
                    }
                    setOverrideMaterial(e) {
                        this.overrideMaterial = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getSelection() {
                        return this.selection
                    }
                    setSelection(e) {
                        this.selection = e
                    }
                    isBackgroundDisabled() {
                        return this.ignoreBackground
                    }
                    setBackgroundDisabled(e) {
                        this.ignoreBackground = e
                    }
                    isShadowMapDisabled() {
                        return this.skipShadowMapUpdate
                    }
                    setShadowMapDisabled(e) {
                        this.skipShadowMapUpdate = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    render(e, t, n, i, s) {
                        const a = this.scene
                          , o = this.camera
                          , c = this.selection
                          , u = o.layers.mask
                          , f = a.background
                          , m = e.shadowMap.autoUpdate
                          , v = this.renderToScreen ? null : t;
                        c !== null && o.layers.set(c.getLayer()),
                        this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
                        (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (a.background = null),
                        this.clearPass.enabled && this.clearPass.render(e, t),
                        e.setRenderTarget(v),
                        this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(e, a, o) : e.render(a, o),
                        o.layers.mask = u,
                        a.background = f,
                        e.shadowMap.autoUpdate = m
                    }
                }
                  , L5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}`
                  , DM = new ae
                  , lD = new Xt
                  , I5 = class extends Vi {
                    constructor(e, t, {blendFunction: n=Wt.SCREEN, samples: i=60, density: s=.96, decay: a=.9, weight: o=.4, exposure: c=.6, clampMax: u=1, blur: f=!0, kernelSize: m=am.SMALL, resolutionScale: v=.5, width: y=Zn.AUTO_SIZE, height: S=Zn.AUTO_SIZE, resolutionX: A=y, resolutionY: M=S}={}) {
                        super("GodRaysEffect", L5, {
                            blendFunction: n,
                            attributes: ar.DEPTH,
                            uniforms: new Map([["map", new ke(null)]])
                        }),
                        this.camera = e,
                        this._lightSource = t,
                        this.lightSource = t,
                        this.lightScene = new Pp,
                        this.screenPosition = new Oe,
                        this.renderTargetA = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetA.texture.name = "GodRays.Target.A",
                        this.renderTargetB = this.renderTargetA.clone(),
                        this.renderTargetB.texture.name = "GodRays.Target.B",
                        this.uniforms.get("map").value = this.renderTargetB.texture,
                        this.renderTargetLight = new Vn(1,1),
                        this.renderTargetLight.texture.name = "GodRays.Light",
                        this.renderTargetLight.depthTexture = new Og,
                        this.renderPassLight = new $g(this.lightScene,e),
                        this.renderPassLight.clearPass.overrideClearColor = new ft(0),
                        this.clearPass = new sm(!0,!1,!1),
                        this.clearPass.overrideClearColor = new ft(0),
                        this.blurPass = new PS({
                            kernelSize: m
                        }),
                        this.blurPass.enabled = f,
                        this.depthMaskPass = new Kr(new oD);
                        const x = this.depthMaskMaterial;
                        x.depthBuffer1 = this.renderTargetLight.depthTexture,
                        x.copyCameraSettings(e),
                        this.godRaysPass = new Kr(new B5(this.screenPosition));
                        const T = this.godRaysMaterial;
                        T.density = s,
                        T.decay = a,
                        T.weight = o,
                        T.exposure = c,
                        T.maxIntensity = u,
                        T.samples = i;
                        const D = this.resolution = new Zn(this,A,M,v);
                        D.addEventListener("change", w => this.setSize(D.baseWidth, D.baseHeight))
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.renderPassLight.mainCamera = e,
                        this.depthMaskMaterial.copyCameraSettings(e)
                    }
                    get lightSource() {
                        return this._lightSource
                    }
                    set lightSource(e) {
                        this._lightSource = e,
                        e !== null && (e.material.depthWrite = !1,
                        e.material.transparent = !0)
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    get texture() {
                        return this.renderTargetB.texture
                    }
                    getTexture() {
                        return this.texture
                    }
                    get depthMaskMaterial() {
                        return this.depthMaskPass.fullscreenMaterial
                    }
                    get godRaysMaterial() {
                        return this.godRaysPass.fullscreenMaterial
                    }
                    getGodRaysMaterial() {
                        return this.godRaysMaterial
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get dithering() {
                        return this.godRaysMaterial.dithering
                    }
                    set dithering(e) {
                        const t = this.godRaysMaterial;
                        t.dithering = e,
                        t.needsUpdate = !0
                    }
                    get blur() {
                        return this.blurPass.enabled
                    }
                    set blur(e) {
                        this.blurPass.enabled = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    get samples() {
                        return this.godRaysMaterial.samples
                    }
                    set samples(e) {
                        this.godRaysMaterial.samples = e
                    }
                    setDepthTexture(e, t=as) {
                        this.depthMaskPass.fullscreenMaterial.depthBuffer0 = e,
                        this.depthMaskPass.fullscreenMaterial.depthPacking0 = t
                    }
                    update(e, t, n) {
                        const i = this.lightSource
                          , s = i.parent
                          , a = i.matrixAutoUpdate
                          , o = this.renderTargetA
                          , c = this.renderTargetLight;
                        i.material.depthWrite = !0,
                        i.matrixAutoUpdate = !1,
                        i.updateWorldMatrix(!0, !1),
                        s !== null && (a || lD.copy(i.matrix),
                        i.matrix.copy(i.matrixWorld)),
                        this.lightScene.add(i),
                        this.renderPassLight.render(e, c),
                        this.clearPass.render(e, o),
                        this.depthMaskPass.render(e, c, o),
                        i.material.depthWrite = !1,
                        i.matrixAutoUpdate = a,
                        s !== null && (a || i.matrix.copy(lD),
                        s.add(i)),
                        DM.setFromMatrixPosition(i.matrixWorld).project(this.camera),
                        this.screenPosition.set(Math.min(Math.max((DM.x + 1) * .5, -1), 2), Math.min(Math.max((DM.y + 1) * .5, -1), 2)),
                        this.blurPass.enabled && this.blurPass.render(e, o, o),
                        this.godRaysPass.render(e, o, this.renderTargetB)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.renderTargetA.setSize(i, s),
                        this.renderTargetB.setSize(i, s),
                        this.renderTargetLight.setSize(i, s),
                        this.blurPass.resolution.copy(n)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, n),
                        this.renderPassLight.initialize(e, t, n),
                        this.depthMaskPass.initialize(e, t, n),
                        this.godRaysPass.initialize(e, t, n),
                        n !== void 0 && (this.renderTargetA.texture.type = n,
                        this.renderTargetB.texture.type = n,
                        this.renderTargetLight.texture.type = n,
                        e !== null && e.outputColorSpace === Zt && (this.renderTargetA.texture.colorSpace = Zt,
                        this.renderTargetB.texture.colorSpace = Zt,
                        this.renderTargetLight.texture.colorSpace = Zt))
                    }
                }
                  , P5 = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}"
                  , z5 = class extends Vi {
                    constructor({blendFunction: e=Wt.OVERLAY, scale: t=1, lineWidth: n=0}={}) {
                        super("GridEffect", P5, {
                            blendFunction: e,
                            uniforms: new Map([["scale", new ke(new Oe)], ["lineWidth", new ke(n)]])
                        }),
                        this.resolution = new Oe,
                        this.s = 0,
                        this.scale = t,
                        this.l = 0,
                        this.lineWidth = n
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(e) {
                        this.s = Math.max(e, 1e-6),
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    get lineWidth() {
                        return this.l
                    }
                    set lineWidth(e) {
                        this.l = e,
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getLineWidth() {
                        return this.lineWidth
                    }
                    setLineWidth(e) {
                        this.lineWidth = e
                    }
                    setSize(e, t) {
                        this.resolution.set(e, t);
                        const n = e / t
                          , i = this.scale * (t * .125);
                        this.uniforms.get("scale").value.set(n * i, i),
                        this.uniforms.get("lineWidth").value = i / t + this.lineWidth
                    }
                }
                  , F5 = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}"
                  , H5 = class extends Vi {
                    constructor({blendFunction: e=Wt.SRC, hue: t=0, saturation: n=0}={}) {
                        super("HueSaturationEffect", F5, {
                            blendFunction: e,
                            uniforms: new Map([["hue", new ke(new ae)], ["saturation", new ke(n)]])
                        }),
                        this.hue = t
                    }
                    get saturation() {
                        return this.uniforms.get("saturation").value
                    }
                    set saturation(e) {
                        this.uniforms.get("saturation").value = e
                    }
                    getSaturation() {
                        return this.saturation
                    }
                    setSaturation(e) {
                        this.saturation = e
                    }
                    get hue() {
                        const e = this.uniforms.get("hue").value;
                        return Math.acos((e.x * 3 - 1) / 2)
                    }
                    set hue(e) {
                        const t = Math.sin(e)
                          , n = Math.cos(e);
                        this.uniforms.get("hue").value.set((2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3)
                    }
                    getHue() {
                        return this.hue
                    }
                    setHue(e) {
                        this.hue = e
                    }
                }
                  , e0 = {
                    FULL: 0,
                    SINGLE: 1
                }
                  , cD = {
                    DEPTH: 0,
                    LUMA: 1,
                    COLOR: 2
                }
                  , G5 = {
                    DISABLED: 0,
                    DEPTH: 1,
                    CUSTOM: 2
                }
                  , t0 = {
                    LOW: 0,
                    MEDIUM: 1,
                    HIGH: 2,
                    ULTRA: 3
                }
                  , V5 = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`
                  , k5 = class extends Vi {
                    constructor({blendFunction: e=Wt.SCREEN, premultiply: t=!1}={}) {
                        super("NoiseEffect", V5, {
                            blendFunction: e
                        }),
                        this.premultiply = t
                    }
                    get premultiply() {
                        return this.defines.has("PREMULTIPLY")
                    }
                    set premultiply(e) {
                        this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"),
                        this.setChanged())
                    }
                    isPremultiplied() {
                        return this.premultiply
                    }
                    setPremultiplied(e) {
                        this.premultiply = e
                    }
                }
                  , X5 = `#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`
                  , W5 = `#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`
                  , Y5 = class extends kn {
                    constructor(e=null, t) {
                        super({
                            name: "DepthComparisonMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new ke(null),
                                cameraNear: new ke(.3),
                                cameraFar: new ke(1e3)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: X5,
                            vertexShader: W5
                        }),
                        this.depthBuffer = e,
                        this.depthPacking = Eo,
                        this.copyCameraSettings(t)
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=Eo) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near,
                        this.uniforms.cameraFar.value = e.far,
                        e instanceof Hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                }
                  , q5 = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}"
                  , j5 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , Q5 = class extends kn {
                    constructor(e=new Oe) {
                        super({
                            name: "OutlineMaterial",
                            uniforms: {
                                inputBuffer: new ke(null),
                                texelSize: new ke(new Oe)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: q5,
                            vertexShader: j5
                        }),
                        this.uniforms.texelSize.value.set(e.x, e.y),
                        this.uniforms.maskTexture = this.uniforms.inputBuffer
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , uD = class extends sa {
                    constructor(e, t, {renderTarget: n, resolutionScale: i=1, width: s=Zn.AUTO_SIZE, height: a=Zn.AUTO_SIZE, resolutionX: o=s, resolutionY: c=a}={}) {
                        super("DepthPass"),
                        this.needsSwap = !1,
                        this.renderPass = new $g(e,t,new Fg({
                            depthPacking: Eo
                        }));
                        const u = this.renderPass;
                        u.skipShadowMapUpdate = !0,
                        u.ignoreBackground = !0;
                        const f = u.clearPass;
                        f.overrideClearColor = new ft(16777215),
                        f.overrideClearAlpha = 1,
                        this.renderTarget = n,
                        this.renderTarget === void 0 && (this.renderTarget = new Vn(1,1,{
                            minFilter: ri,
                            magFilter: ri
                        }),
                        this.renderTarget.texture.name = "DepthPass.Target");
                        const m = this.resolution = new Zn(this,o,c,i);
                        m.addEventListener("change", v => this.setSize(m.baseWidth, m.baseHeight))
                    }
                    set mainScene(e) {
                        this.renderPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.renderPass.mainCamera = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, s) {
                        const a = this.renderToScreen ? null : this.renderTarget;
                        this.renderPass.render(e, a)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height)
                    }
                }
                  , Z5 = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texture2D(patternTexture,vUvPattern);
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`
                  , K5 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}"
                  , J5 = class extends Vi {
                    constructor(e, t, {blendFunction: n=Wt.SCREEN, patternTexture: i=null, patternScale: s=1, edgeStrength: a=1, pulseSpeed: o=0, visibleEdgeColor: c=16777215, hiddenEdgeColor: u=2230538, kernelSize: f=am.VERY_SMALL, blur: m=!1, xRay: v=!0, multisampling: y=0, resolutionScale: S=.5, width: A=Zn.AUTO_SIZE, height: M=Zn.AUTO_SIZE, resolutionX: x=A, resolutionY: T=M}={}) {
                        super("OutlineEffect", Z5, {
                            uniforms: new Map([["maskTexture", new ke(null)], ["edgeTexture", new ke(null)], ["edgeStrength", new ke(a)], ["visibleEdgeColor", new ke(new ft(c))], ["hiddenEdgeColor", new ke(new ft(u))], ["pulse", new ke(1)], ["patternScale", new ke(s)], ["patternTexture", new ke(null)]])
                        }),
                        this.blendMode.addEventListener("change", O => {
                            this.blendMode.blendFunction === Wt.ALPHA ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"),
                            this.setChanged()
                        }
                        ),
                        this.blendMode.blendFunction = n,
                        this.patternTexture = i,
                        this.xRay = v,
                        this.scene = e,
                        this.camera = t,
                        this.renderTargetMask = new Vn(1,1),
                        this.renderTargetMask.samples = y,
                        this.renderTargetMask.texture.name = "Outline.Mask",
                        this.uniforms.get("maskTexture").value = this.renderTargetMask.texture,
                        this.renderTargetOutline = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetOutline.texture.name = "Outline.Edges",
                        this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture,
                        this.clearPass = new sm,
                        this.clearPass.overrideClearColor = new ft(0),
                        this.clearPass.overrideClearAlpha = 1,
                        this.depthPass = new uD(e,t),
                        this.maskPass = new $g(e,t,new Y5(this.depthPass.texture,t));
                        const D = this.maskPass.clearPass;
                        D.overrideClearColor = new ft(16777215),
                        D.overrideClearAlpha = 1,
                        this.blurPass = new PS({
                            resolutionScale: S,
                            resolutionX: x,
                            resolutionY: T,
                            kernelSize: f
                        }),
                        this.blurPass.enabled = m;
                        const w = this.blurPass.resolution;
                        w.addEventListener("change", O => this.setSize(w.baseWidth, w.baseHeight)),
                        this.outlinePass = new Kr(new Q5);
                        const U = this.outlinePass.fullscreenMaterial;
                        U.inputBuffer = this.renderTargetMask.texture,
                        this.time = 0,
                        this.forceUpdate = !0,
                        this.selection = new sD,
                        this.pulseSpeed = o
                    }
                    set mainScene(e) {
                        this.scene = e,
                        this.depthPass.mainScene = e,
                        this.maskPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.depthPass.mainCamera = e,
                        this.maskPass.mainCamera = e,
                        this.maskPass.overrideMaterial.copyCameraSettings(e)
                    }
                    get resolution() {
                        return this.blurPass.resolution
                    }
                    getResolution() {
                        return this.blurPass.getResolution()
                    }
                    get multisampling() {
                        return this.renderTargetMask.samples
                    }
                    set multisampling(e) {
                        this.renderTargetMask.samples = e,
                        this.renderTargetMask.dispose()
                    }
                    get patternScale() {
                        return this.uniforms.get("patternScale").value
                    }
                    set patternScale(e) {
                        this.uniforms.get("patternScale").value = e
                    }
                    get edgeStrength() {
                        return this.uniforms.get("edgeStrength").value
                    }
                    set edgeStrength(e) {
                        this.uniforms.get("edgeStrength").value = e
                    }
                    get visibleEdgeColor() {
                        return this.uniforms.get("visibleEdgeColor").value
                    }
                    set visibleEdgeColor(e) {
                        this.uniforms.get("visibleEdgeColor").value = e
                    }
                    get hiddenEdgeColor() {
                        return this.uniforms.get("hiddenEdgeColor").value
                    }
                    set hiddenEdgeColor(e) {
                        this.uniforms.get("hiddenEdgeColor").value = e
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getSelection() {
                        return this.selection
                    }
                    getPulseSpeed() {
                        return this.pulseSpeed
                    }
                    setPulseSpeed(e) {
                        this.pulseSpeed = e
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get selectionLayer() {
                        return this.selection.layer
                    }
                    set selectionLayer(e) {
                        this.selection.layer = e
                    }
                    get dithering() {
                        return this.blurPass.dithering
                    }
                    set dithering(e) {
                        this.blurPass.dithering = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    get blur() {
                        return this.blurPass.enabled
                    }
                    set blur(e) {
                        this.blurPass.enabled = e
                    }
                    get xRay() {
                        return this.defines.has("X_RAY")
                    }
                    set xRay(e) {
                        this.xRay !== e && (e ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"),
                        this.setChanged())
                    }
                    isXRayEnabled() {
                        return this.xRay
                    }
                    setXRayEnabled(e) {
                        this.xRay = e
                    }
                    get patternTexture() {
                        return this.uniforms.get("patternTexture").value
                    }
                    set patternTexture(e) {
                        e !== null ? (e.wrapS = e.wrapT = sh,
                        this.defines.set("USE_PATTERN", "1"),
                        this.setVertexShader(K5)) : (this.defines.delete("USE_PATTERN"),
                        this.setVertexShader(null)),
                        this.uniforms.get("patternTexture").value = e,
                        this.setChanged()
                    }
                    setPatternTexture(e) {
                        this.patternTexture = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    setSelection(e) {
                        return this.selection.set(e),
                        this
                    }
                    clearSelection() {
                        return this.selection.clear(),
                        this
                    }
                    selectObject(e) {
                        return this.selection.add(e),
                        this
                    }
                    deselectObject(e) {
                        return this.selection.delete(e),
                        this
                    }
                    update(e, t, n) {
                        const i = this.scene
                          , s = this.camera
                          , a = this.selection
                          , o = this.uniforms.get("pulse")
                          , c = i.background
                          , u = s.layers.mask;
                        (this.forceUpdate || a.size > 0) && (i.background = null,
                        o.value = 1,
                        this.pulseSpeed > 0 && (o.value = Math.cos(this.time * this.pulseSpeed * 10) * .375 + .625),
                        this.time += n,
                        a.setVisible(!1),
                        this.depthPass.render(e),
                        a.setVisible(!0),
                        s.layers.set(a.layer),
                        this.maskPass.render(e, this.renderTargetMask),
                        s.layers.mask = u,
                        i.background = c,
                        this.outlinePass.render(e, null, this.renderTargetOutline),
                        this.blurPass.enabled && this.blurPass.render(e, this.renderTargetOutline, this.renderTargetOutline)),
                        this.forceUpdate = a.size > 0
                    }
                    setSize(e, t) {
                        this.blurPass.setSize(e, t),
                        this.renderTargetMask.setSize(e, t);
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.depthPass.setSize(i, s),
                        this.renderTargetOutline.setSize(i, s),
                        this.outlinePass.fullscreenMaterial.setSize(i, s)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, gi),
                        n !== void 0 && (this.depthPass.initialize(e, t, n),
                        this.maskPass.initialize(e, t, n),
                        this.outlinePass.initialize(e, t, n))
                    }
                }
                  , $5 = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}"
                  , eH = class extends Vi {
                    constructor(e=30) {
                        super("PixelationEffect", $5, {
                            uniforms: new Map([["active", new ke(!1)], ["d", new ke(new hn)]])
                        }),
                        this.resolution = new Oe,
                        this._granularity = 0,
                        this.granularity = e
                    }
                    get granularity() {
                        return this._granularity
                    }
                    set granularity(e) {
                        let t = Math.floor(e);
                        t % 2 > 0 && (t += 1),
                        this._granularity = t,
                        this.uniforms.get("active").value = t > 0,
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getGranularity() {
                        return this.granularity
                    }
                    setGranularity(e) {
                        this.granularity = e
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.set(e, t);
                        const i = this.granularity
                          , s = i / n.x
                          , a = i / n.y;
                        this.uniforms.get("d").value.set(s, a, 1 / s, 1 / a)
                    }
                }
                  , tH = `uniform float count;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;
#ifdef SCROLL
y+=time*scrollSpeed;
#endif
vec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`
                  , nH = class extends Vi {
                    constructor({blendFunction: e=Wt.OVERLAY, density: t=1.25, scrollSpeed: n=0}={}) {
                        super("ScanlineEffect", tH, {
                            blendFunction: e,
                            uniforms: new Map([["count", new ke(0)], ["scrollSpeed", new ke(0)]])
                        }),
                        this.resolution = new Oe,
                        this.d = t,
                        this.scrollSpeed = n
                    }
                    get density() {
                        return this.d
                    }
                    set density(e) {
                        this.d = e,
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getDensity() {
                        return this.density
                    }
                    setDensity(e) {
                        this.density = e
                    }
                    get scrollSpeed() {
                        return this.uniforms.get("scrollSpeed").value
                    }
                    set scrollSpeed(e) {
                        this.uniforms.get("scrollSpeed").value = e,
                        e === 0 ? this.defines.delete("SCROLL") && this.setChanged() : this.defines.has("SCROLL") || (this.defines.set("SCROLL", "1"),
                        this.setChanged())
                    }
                    setSize(e, t) {
                        this.resolution.set(e, t),
                        this.uniforms.get("count").value = Math.round(t * this.density)
                    }
                }
                  , PX = Math.PI * .5
                  , iH = class extends aD {
                    constructor(e, t, n) {
                        super(n),
                        this.setAttributes(this.getAttributes() | ar.DEPTH),
                        this.camera = t,
                        this.depthPass = new uD(e,t),
                        this.clearPass = new sm(!0,!1,!1),
                        this.clearPass.overrideClearColor = new ft(0),
                        this.depthMaskPass = new Kr(new oD);
                        const i = this.depthMaskMaterial;
                        i.copyCameraSettings(t),
                        i.depthBuffer1 = this.depthPass.texture,
                        i.depthPacking1 = Eo,
                        i.depthMode = hf,
                        this.renderTargetMasked = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetMasked.texture.name = "Bloom.Masked",
                        this.selection = new sD,
                        this._inverted = !1,
                        this._ignoreBackground = !1
                    }
                    set mainScene(e) {
                        this.depthPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.depthPass.mainCamera = e,
                        this.depthMaskMaterial.copyCameraSettings(e)
                    }
                    getSelection() {
                        return this.selection
                    }
                    get depthMaskMaterial() {
                        return this.depthMaskPass.fullscreenMaterial
                    }
                    get inverted() {
                        return this._inverted
                    }
                    set inverted(e) {
                        this._inverted = e,
                        this.depthMaskMaterial.depthMode = e ? hp : hf
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    get ignoreBackground() {
                        return this._ignoreBackground
                    }
                    set ignoreBackground(e) {
                        this._ignoreBackground = e,
                        this.depthMaskMaterial.maxDepthStrategy = e ? Jg.DISCARD_MAX_DEPTH : Jg.KEEP_MAX_DEPTH
                    }
                    isBackgroundDisabled() {
                        return this.ignoreBackground
                    }
                    setBackgroundDisabled(e) {
                        this.ignoreBackground = e
                    }
                    setDepthTexture(e, t=as) {
                        this.depthMaskMaterial.depthBuffer0 = e,
                        this.depthMaskMaterial.depthPacking0 = t
                    }
                    update(e, t, n) {
                        const i = this.camera
                          , s = this.selection
                          , a = this.inverted;
                        let o = t;
                        if (this.ignoreBackground || !a || s.size > 0) {
                            const c = i.layers.mask;
                            i.layers.set(s.layer),
                            this.depthPass.render(e),
                            i.layers.mask = c,
                            o = this.renderTargetMasked,
                            this.clearPass.render(e, o),
                            this.depthMaskPass.render(e, t, o)
                        }
                        super.update(e, o, n)
                    }
                    setSize(e, t) {
                        super.setSize(e, t),
                        this.renderTargetMasked.setSize(e, t),
                        this.depthPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        super.initialize(e, t, n),
                        this.clearPass.initialize(e, t, n),
                        this.depthPass.initialize(e, t, n),
                        this.depthMaskPass.initialize(e, t, n),
                        e !== null && e.capabilities.logarithmicDepthBuffer && (this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
                        n !== void 0 && (this.renderTargetMasked.texture.type = n,
                        e !== null && e.outputColorSpace === Zt && (this.renderTargetMasked.texture.colorSpace = Zt))
                    }
                }
                  , sH = "uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}"
                  , aH = class extends Vi {
                    constructor({blendFunction: e, intensity: t=1}={}) {
                        super("SepiaEffect", sH, {
                            blendFunction: e,
                            uniforms: new Map([["weightsR", new ke(new ae(.393,.769,.189))], ["weightsG", new ke(new ae(.349,.686,.168))], ["weightsB", new ke(new ae(.272,.534,.131))]])
                        })
                    }
                    get intensity() {
                        return this.blendMode.opacity.value
                    }
                    set intensity(e) {
                        this.blendMode.opacity.value = e
                    }
                    getIntensity() {
                        return this.intensity
                    }
                    setIntensity(e) {
                        this.intensity = e
                    }
                    get weightsR() {
                        return this.uniforms.get("weightsR").value
                    }
                    get weightsG() {
                        return this.uniforms.get("weightsG").value
                    }
                    get weightsB() {
                        return this.uniforms.get("weightsB").value
                    }
                }
                  , rH = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`
                  , oH = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`
                  , lH = class extends kn {
                    constructor(e=new Oe, t=cD.COLOR) {
                        super({
                            name: "EdgeDetectionMaterial",
                            defines: {
                                THREE_REVISION: jc.replace(/\D+/g, ""),
                                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                                EDGE_THRESHOLD: "0.1",
                                DEPTH_THRESHOLD: "0.01",
                                PREDICATION_MODE: "0",
                                PREDICATION_THRESHOLD: "0.01",
                                PREDICATION_SCALE: "2.0",
                                PREDICATION_STRENGTH: "1.0",
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                depthBuffer: new ke(null),
                                predicationBuffer: new ke(null),
                                texelSize: new ke(e)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: rH,
                            vertexShader: oH
                        }),
                        this.edgeDetectionMode = t
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=as) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    get edgeDetectionMode() {
                        return Number(this.defines.EDGE_DETECTION_MODE)
                    }
                    set edgeDetectionMode(e) {
                        this.defines.EDGE_DETECTION_MODE = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getEdgeDetectionMode() {
                        return this.edgeDetectionMode
                    }
                    setEdgeDetectionMode(e) {
                        this.edgeDetectionMode = e
                    }
                    get localContrastAdaptationFactor() {
                        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
                    }
                    set localContrastAdaptationFactor(e) {
                        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getLocalContrastAdaptationFactor() {
                        return this.localContrastAdaptationFactor
                    }
                    setLocalContrastAdaptationFactor(e) {
                        this.localContrastAdaptationFactor = e
                    }
                    get edgeDetectionThreshold() {
                        return Number(this.defines.EDGE_THRESHOLD)
                    }
                    set edgeDetectionThreshold(e) {
                        this.defines.EDGE_THRESHOLD = e.toFixed("6"),
                        this.defines.DEPTH_THRESHOLD = (e * .1).toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getEdgeDetectionThreshold() {
                        return this.edgeDetectionThreshold
                    }
                    setEdgeDetectionThreshold(e) {
                        this.edgeDetectionThreshold = e
                    }
                    get predicationMode() {
                        return Number(this.defines.PREDICATION_MODE)
                    }
                    set predicationMode(e) {
                        this.defines.PREDICATION_MODE = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getPredicationMode() {
                        return this.predicationMode
                    }
                    setPredicationMode(e) {
                        this.predicationMode = e
                    }
                    set predicationBuffer(e) {
                        this.uniforms.predicationBuffer.value = e
                    }
                    setPredicationBuffer(e) {
                        this.uniforms.predicationBuffer.value = e
                    }
                    get predicationThreshold() {
                        return Number(this.defines.PREDICATION_THRESHOLD)
                    }
                    set predicationThreshold(e) {
                        this.defines.PREDICATION_THRESHOLD = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getPredicationThreshold() {
                        return this.predicationThreshold
                    }
                    setPredicationThreshold(e) {
                        this.predicationThreshold = e
                    }
                    get predicationScale() {
                        return Number(this.defines.PREDICATION_SCALE)
                    }
                    set predicationScale(e) {
                        this.defines.PREDICATION_SCALE = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getPredicationScale() {
                        return this.predicationScale
                    }
                    setPredicationScale(e) {
                        this.predicationScale = e
                    }
                    get predicationStrength() {
                        return Number(this.defines.PREDICATION_STRENGTH)
                    }
                    set predicationStrength(e) {
                        this.defines.PREDICATION_STRENGTH = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getPredicationStrength() {
                        return this.predicationStrength
                    }
                    setPredicationStrength(e) {
                        this.predicationStrength = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , cH = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`
                  , uH = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , hH = class extends kn {
                    constructor(e=new Oe, t=new Oe) {
                        super({
                            name: "SMAAWeightsMaterial",
                            defines: {
                                MAX_SEARCH_STEPS_INT: "16",
                                MAX_SEARCH_STEPS_FLOAT: "16.0",
                                MAX_SEARCH_STEPS_DIAG_INT: "8",
                                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                                CORNER_ROUNDING: "25",
                                CORNER_ROUNDING_NORM: "0.25",
                                AREATEX_MAX_DISTANCE: "16.0",
                                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                searchTexture: new ke(null),
                                areaTexture: new ke(null),
                                resolution: new ke(t),
                                texelSize: new ke(e)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: cH,
                            vertexShader: uH
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get searchTexture() {
                        return this.uniforms.searchTexture.value
                    }
                    set searchTexture(e) {
                        this.uniforms.searchTexture.value = e
                    }
                    get areaTexture() {
                        return this.uniforms.areaTexture.value
                    }
                    set areaTexture(e) {
                        this.uniforms.areaTexture.value = e
                    }
                    setLookupTextures(e, t) {
                        this.searchTexture = e,
                        this.areaTexture = t
                    }
                    get orthogonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_INT)
                    }
                    set orthogonalSearchSteps(e) {
                        const t = Math.min(Math.max(e, 0), 112);
                        this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"),
                        this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"),
                        this.needsUpdate = !0
                    }
                    setOrthogonalSearchSteps(e) {
                        this.orthogonalSearchSteps = e
                    }
                    get diagonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
                    }
                    set diagonalSearchSteps(e) {
                        const t = Math.min(Math.max(e, 0), 20);
                        this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"),
                        this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"),
                        this.needsUpdate = !0
                    }
                    setDiagonalSearchSteps(e) {
                        this.diagonalSearchSteps = e
                    }
                    get diagonalDetection() {
                        return this.defines.DISABLE_DIAG_DETECTION === void 0
                    }
                    set diagonalDetection(e) {
                        e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1",
                        this.needsUpdate = !0
                    }
                    isDiagonalDetectionEnabled() {
                        return this.diagonalDetection
                    }
                    setDiagonalDetectionEnabled(e) {
                        this.diagonalDetection = e
                    }
                    get cornerRounding() {
                        return Number(this.defines.CORNER_ROUNDING)
                    }
                    set cornerRounding(e) {
                        const t = Math.min(Math.max(e, 0), 100);
                        this.defines.CORNER_ROUNDING = t.toFixed("4"),
                        this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"),
                        this.needsUpdate = !0
                    }
                    setCornerRounding(e) {
                        this.cornerRounding = e
                    }
                    get cornerDetection() {
                        return this.defines.DISABLE_CORNER_DETECTION === void 0
                    }
                    set cornerDetection(e) {
                        e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1",
                        this.needsUpdate = !0
                    }
                    isCornerRoundingEnabled() {
                        return this.cornerDetection
                    }
                    setCornerRoundingEnabled(e) {
                        this.cornerDetection = e
                    }
                    setSize(e, t) {
                        const n = this.uniforms;
                        n.texelSize.value.set(1 / e, 1 / t),
                        n.resolution.value.set(e, t)
                    }
                }
                  , hD = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"
                  , fD = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC"
                  , fH = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}"
                  , dH = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}"
                  , pH = class extends Vi {
                    constructor({blendFunction: e=Wt.SRC, preset: t=t0.MEDIUM, edgeDetectionMode: n=cD.COLOR, predicationMode: i=G5.DISABLED}={}) {
                        super("SMAAEffect", fH, {
                            vertexShader: dH,
                            blendFunction: e,
                            attributes: ar.CONVOLUTION | ar.DEPTH,
                            uniforms: new Map([["weightMap", new ke(null)]])
                        });
                        let s, a;
                        arguments.length > 1 && (s = arguments[0],
                        a = arguments[1],
                        arguments.length > 2 && (t = arguments[2]),
                        arguments.length > 3 && (n = arguments[3])),
                        this.renderTargetEdges = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetEdges.texture.name = "SMAA.Edges",
                        this.renderTargetWeights = this.renderTargetEdges.clone(),
                        this.renderTargetWeights.texture.name = "SMAA.Weights",
                        this.uniforms.get("weightMap").value = this.renderTargetWeights.texture,
                        this.clearPass = new sm(!0,!1,!1),
                        this.clearPass.overrideClearColor = new ft(0),
                        this.clearPass.overrideClearAlpha = 1,
                        this.edgeDetectionPass = new Kr(new lH),
                        this.edgeDetectionMaterial.edgeDetectionMode = n,
                        this.edgeDetectionMaterial.predicationMode = i,
                        this.weightsPass = new Kr(new hH);
                        const o = new mS;
                        o.onLoad = () => {
                            const c = new Fi(s);
                            c.name = "SMAA.Search",
                            c.magFilter = ri,
                            c.minFilter = ri,
                            c.generateMipmaps = !1,
                            c.needsUpdate = !0,
                            c.flipY = !0,
                            this.weightsMaterial.searchTexture = c;
                            const u = new Fi(a);
                            u.name = "SMAA.Area",
                            u.magFilter = mi,
                            u.minFilter = mi,
                            u.generateMipmaps = !1,
                            u.needsUpdate = !0,
                            u.flipY = !1,
                            this.weightsMaterial.areaTexture = u,
                            this.dispatchEvent({
                                type: "load"
                            })
                        }
                        ,
                        o.itemStart("search"),
                        o.itemStart("area"),
                        s !== void 0 && a !== void 0 ? (o.itemEnd("search"),
                        o.itemEnd("area")) : typeof Image < "u" && (s = new Image,
                        a = new Image,
                        s.addEventListener("load", () => o.itemEnd("search")),
                        a.addEventListener("load", () => o.itemEnd("area")),
                        s.src = hD,
                        a.src = fD),
                        this.applyPreset(t)
                    }
                    get edgesTexture() {
                        return this.renderTargetEdges.texture
                    }
                    getEdgesTexture() {
                        return this.edgesTexture
                    }
                    get weightsTexture() {
                        return this.renderTargetWeights.texture
                    }
                    getWeightsTexture() {
                        return this.weightsTexture
                    }
                    get edgeDetectionMaterial() {
                        return this.edgeDetectionPass.fullscreenMaterial
                    }
                    get colorEdgesMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    getEdgeDetectionMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    get weightsMaterial() {
                        return this.weightsPass.fullscreenMaterial
                    }
                    getWeightsMaterial() {
                        return this.weightsMaterial
                    }
                    setEdgeDetectionThreshold(e) {
                        this.edgeDetectionMaterial.edgeDetectionThreshold = e
                    }
                    setOrthogonalSearchSteps(e) {
                        this.weightsMaterial.orthogonalSearchSteps = e
                    }
                    applyPreset(e) {
                        const t = this.edgeDetectionMaterial
                          , n = this.weightsMaterial;
                        switch (e) {
                        case t0.LOW:
                            t.edgeDetectionThreshold = .15,
                            n.orthogonalSearchSteps = 4,
                            n.diagonalDetection = !1,
                            n.cornerDetection = !1;
                            break;
                        case t0.MEDIUM:
                            t.edgeDetectionThreshold = .1,
                            n.orthogonalSearchSteps = 8,
                            n.diagonalDetection = !1,
                            n.cornerDetection = !1;
                            break;
                        case t0.HIGH:
                            t.edgeDetectionThreshold = .1,
                            n.orthogonalSearchSteps = 16,
                            n.diagonalSearchSteps = 8,
                            n.cornerRounding = 25,
                            n.diagonalDetection = !0,
                            n.cornerDetection = !0;
                            break;
                        case t0.ULTRA:
                            t.edgeDetectionThreshold = .05,
                            n.orthogonalSearchSteps = 32,
                            n.diagonalSearchSteps = 16,
                            n.cornerRounding = 25,
                            n.diagonalDetection = !0,
                            n.cornerDetection = !0;
                            break
                        }
                    }
                    setDepthTexture(e, t=as) {
                        this.edgeDetectionMaterial.depthBuffer = e,
                        this.edgeDetectionMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        this.clearPass.render(e, this.renderTargetEdges),
                        this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
                        this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
                    }
                    setSize(e, t) {
                        this.edgeDetectionMaterial.setSize(e, t),
                        this.weightsMaterial.setSize(e, t),
                        this.renderTargetEdges.setSize(e, t),
                        this.renderTargetWeights.setSize(e, t)
                    }
                    dispose() {
                        const {searchTexture: e, areaTexture: t} = this.weightsMaterial;
                        e !== null && t !== null && (e.dispose(),
                        t.dispose()),
                        super.dispose()
                    }
                    static get searchImageDataURL() {
                        return hD
                    }
                    static get areaImageDataURL() {
                        return fD
                    }
                }
                  , mH = `#include <common>
#include <packing>
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
float readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}
#else
uniform lowp sampler2D normalBuffer;
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
uniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);
#ifdef PERSPECTIVE_CAMERA
float linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearSampleDepth=sampleDepth;
#endif
float proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){
#ifdef NORMAL_DEPTH
vec4 normalDepth=texture2D(normalDepthBuffer,vUv);
#else
vec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));
#endif
float ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);
#ifdef PERSPECTIVE_CAMERA
float linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearDepth=depth;
#endif
if(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);
#ifdef LEGACY_INTENSITY
ao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);
#endif
}gl_FragColor.r=ao;}`
                  , vH = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , gH = class extends kn {
                    constructor(e) {
                        super({
                            name: "SSAOMaterial",
                            defines: {
                                SAMPLES_INT: "0",
                                INV_SAMPLES_FLOAT: "0.0",
                                SPIRAL_TURNS: "0.0",
                                RADIUS: "1.0",
                                RADIUS_SQ: "1.0",
                                DISTANCE_SCALING: "1",
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new ke(null),
                                normalBuffer: new ke(null),
                                normalDepthBuffer: new ke(null),
                                noiseTexture: new ke(null),
                                inverseProjectionMatrix: new ke(new Xt),
                                projectionMatrix: new ke(new Xt),
                                texelSize: new ke(new Oe),
                                cameraNearFar: new ke(new Oe),
                                distanceCutoff: new ke(new Oe),
                                proximityCutoff: new ke(new Oe),
                                noiseScale: new ke(new Oe),
                                minRadiusScale: new ke(.33),
                                intensity: new ke(1),
                                fade: new ke(.01),
                                bias: new ke(0)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: mH,
                            vertexShader: vH
                        }),
                        this.copyCameraSettings(e),
                        this.resolution = new Oe,
                        this.r = 1
                    }
                    get near() {
                        return this.uniforms.cameraNearFar.value.x
                    }
                    get far() {
                        return this.uniforms.cameraNearFar.value.y
                    }
                    set normalDepthBuffer(e) {
                        this.uniforms.normalDepthBuffer.value = e,
                        e !== null ? this.defines.NORMAL_DEPTH = "1" : delete this.defines.NORMAL_DEPTH,
                        this.needsUpdate = !0
                    }
                    setNormalDepthBuffer(e) {
                        this.normalDepthBuffer = e
                    }
                    set normalBuffer(e) {
                        this.uniforms.normalBuffer.value = e
                    }
                    setNormalBuffer(e) {
                        this.uniforms.normalBuffer.value = e
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=as) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    set noiseTexture(e) {
                        this.uniforms.noiseTexture.value = e
                    }
                    setNoiseTexture(e) {
                        this.uniforms.noiseTexture.value = e
                    }
                    get samples() {
                        return Number(this.defines.SAMPLES_INT)
                    }
                    set samples(e) {
                        this.defines.SAMPLES_INT = e.toFixed(0),
                        this.defines.INV_SAMPLES_FLOAT = (1 / e).toFixed(9),
                        this.needsUpdate = !0
                    }
                    getSamples() {
                        return this.samples
                    }
                    setSamples(e) {
                        this.samples = e
                    }
                    get rings() {
                        return Number(this.defines.SPIRAL_TURNS)
                    }
                    set rings(e) {
                        this.defines.SPIRAL_TURNS = e.toFixed(1),
                        this.needsUpdate = !0
                    }
                    getRings() {
                        return this.rings
                    }
                    setRings(e) {
                        this.rings = e
                    }
                    get intensity() {
                        return this.uniforms.intensity.value
                    }
                    set intensity(e) {
                        this.uniforms.intensity.value = e,
                        this.defines.LEGACY_INTENSITY === void 0 && (this.defines.LEGACY_INTENSITY = "1",
                        this.needsUpdate = !0)
                    }
                    getIntensity() {
                        return this.uniforms.intensity.value
                    }
                    setIntensity(e) {
                        this.uniforms.intensity.value = e
                    }
                    get fade() {
                        return this.uniforms.fade.value
                    }
                    set fade(e) {
                        this.uniforms.fade.value = e
                    }
                    getFade() {
                        return this.uniforms.fade.value
                    }
                    setFade(e) {
                        this.uniforms.fade.value = e
                    }
                    get bias() {
                        return this.uniforms.bias.value
                    }
                    set bias(e) {
                        this.uniforms.bias.value = e
                    }
                    getBias() {
                        return this.uniforms.bias.value
                    }
                    setBias(e) {
                        this.uniforms.bias.value = e
                    }
                    get minRadiusScale() {
                        return this.uniforms.minRadiusScale.value
                    }
                    set minRadiusScale(e) {
                        this.uniforms.minRadiusScale.value = e
                    }
                    getMinRadiusScale() {
                        return this.uniforms.minRadiusScale.value
                    }
                    setMinRadiusScale(e) {
                        this.uniforms.minRadiusScale.value = e
                    }
                    updateRadius() {
                        const e = this.r * this.resolution.height;
                        this.defines.RADIUS = e.toFixed(11),
                        this.defines.RADIUS_SQ = (e * e).toFixed(11),
                        this.needsUpdate = !0
                    }
                    get radius() {
                        return this.r
                    }
                    set radius(e) {
                        this.r = Math.min(Math.max(e, 1e-6), 1),
                        this.updateRadius()
                    }
                    getRadius() {
                        return this.radius
                    }
                    setRadius(e) {
                        this.radius = e
                    }
                    get distanceScaling() {
                        return !0
                    }
                    set distanceScaling(e) {}
                    isDistanceScalingEnabled() {
                        return this.distanceScaling
                    }
                    setDistanceScalingEnabled(e) {
                        this.distanceScaling = e
                    }
                    get distanceThreshold() {
                        return this.uniforms.distanceCutoff.value.x
                    }
                    set distanceThreshold(e) {
                        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + this.distanceFalloff, 0), 1))
                    }
                    get worldDistanceThreshold() {
                        return -rm(this.distanceThreshold, this.near, this.far)
                    }
                    set worldDistanceThreshold(e) {
                        this.distanceThreshold = Yf(-e, this.near, this.far)
                    }
                    get distanceFalloff() {
                        return this.uniforms.distanceCutoff.value.y - this.distanceThreshold
                    }
                    set distanceFalloff(e) {
                        this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + e, 0), 1)
                    }
                    get worldDistanceFalloff() {
                        return -rm(this.distanceFalloff, this.near, this.far)
                    }
                    set worldDistanceFalloff(e) {
                        this.distanceFalloff = Yf(-e, this.near, this.far)
                    }
                    setDistanceCutoff(e, t) {
                        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1))
                    }
                    get proximityThreshold() {
                        return this.uniforms.proximityCutoff.value.x
                    }
                    set proximityThreshold(e) {
                        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + this.proximityFalloff, 0), 1))
                    }
                    get worldProximityThreshold() {
                        return -rm(this.proximityThreshold, this.near, this.far)
                    }
                    set worldProximityThreshold(e) {
                        this.proximityThreshold = Yf(-e, this.near, this.far)
                    }
                    get proximityFalloff() {
                        return this.uniforms.proximityCutoff.value.y - this.proximityThreshold
                    }
                    set proximityFalloff(e) {
                        this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + e, 0), 1)
                    }
                    get worldProximityFalloff() {
                        return -rm(this.proximityFalloff, this.near, this.far)
                    }
                    set worldProximityFalloff(e) {
                        this.proximityFalloff = Yf(-e, this.near, this.far)
                    }
                    setProximityCutoff(e, t) {
                        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1))
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNearFar.value.set(e.near, e.far),
                        this.uniforms.projectionMatrix.value.copy(e.projectionMatrix),
                        this.uniforms.inverseProjectionMatrix.value.copy(e.projectionMatrix).invert(),
                        e instanceof Hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                    setSize(e, t) {
                        const n = this.uniforms
                          , i = n.noiseTexture.value;
                        i !== null && n.noiseScale.value.set(e / i.image.width, t / i.image.height),
                        n.texelSize.value.set(1 / e, 1 / t),
                        this.resolution.set(e, t),
                        this.updateRadius()
                    }
                }
                  , yH = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`
                  , _H = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , SH = class extends kn {
                    constructor() {
                        super({
                            name: "DepthDownsamplingMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new ke(null),
                                normalBuffer: new ke(null),
                                texelSize: new ke(new Oe)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: yH,
                            vertexShader: _H
                        })
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=as) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    set normalBuffer(e) {
                        this.uniforms.normalBuffer.value = e,
                        e !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS,
                        this.needsUpdate = !0
                    }
                    setNormalBuffer(e) {
                        this.normalBuffer = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , dD = class extends sa {
                    constructor({normalBuffer: e=null, resolutionScale: t=.5, width: n=Zn.AUTO_SIZE, height: i=Zn.AUTO_SIZE, resolutionX: s=n, resolutionY: a=i}={}) {
                        super("DepthDownsamplingPass");
                        const o = new SH;
                        o.normalBuffer = e,
                        this.fullscreenMaterial = o,
                        this.needsDepthTexture = !0,
                        this.needsSwap = !1,
                        this.renderTarget = new Vn(1,1,{
                            minFilter: ri,
                            magFilter: ri,
                            depthBuffer: !1,
                            type: na
                        }),
                        this.renderTarget.texture.name = "DepthDownsamplingPass.Target",
                        this.renderTarget.texture.generateMipmaps = !1;
                        const c = this.resolution = new Zn(this,s,a,t);
                        c.addEventListener("change", u => this.setSize(c.baseWidth, c.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    setDepthTexture(e, t=as) {
                        this.fullscreenMaterial.depthBuffer = e,
                        this.fullscreenMaterial.depthPacking = t
                    }
                    render(e, t, n, i, s) {
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height),
                        this.fullscreenMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        const i = e.getContext();
                        if (!(i.getExtension("EXT_color_buffer_float") || i.getExtension("EXT_color_buffer_half_float")))
                            throw new Error("Rendering to float texture is not supported.")
                    }
                }
                  , xH = `uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;
#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#endif
#ifdef COLORIZE
uniform vec3 color;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;
#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300
vec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);
#else
float ao=aoLinear;
#endif
float l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);
#ifdef COLORIZE
outputColor=vec4(1.0-ao*(1.0-color),inputColor.a);
#else
outputColor=vec4(vec3(1.0-ao),inputColor.a);
#endif
}`
                  , pD = 64
                  , AH = class extends Vi {
                    constructor(e, t, {blendFunction: n=Wt.MULTIPLY, samples: i=9, rings: s=7, normalDepthBuffer: a=null, depthAwareUpsampling: o=!0, worldDistanceThreshold: c, worldDistanceFalloff: u, worldProximityThreshold: f, worldProximityFalloff: m, distanceThreshold: v=.97, distanceFalloff: y=.03, rangeThreshold: S=5e-4, rangeFalloff: A=.001, minRadiusScale: M=.1, luminanceInfluence: x=.7, radius: T=.1825, intensity: D=1, bias: w=.025, fade: U=.01, color: O=null, resolutionScale: L=1, width: N=Zn.AUTO_SIZE, height: z=Zn.AUTO_SIZE, resolutionX: I=N, resolutionY: B=z}={}) {
                        super("SSAOEffect", xH, {
                            blendFunction: n,
                            attributes: ar.DEPTH,
                            defines: new Map([["THRESHOLD", "0.997"]]),
                            uniforms: new Map([["aoBuffer", new ke(null)], ["normalDepthBuffer", new ke(a)], ["luminanceInfluence", new ke(x)], ["color", new ke(null)], ["intensity", new ke(D)], ["scale", new ke(0)]])
                        }),
                        this.renderTarget = new Vn(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "AO.Target",
                        this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
                        const G = this.resolution = new Zn(this,I,B,L);
                        G.addEventListener("change", Q => this.setSize(G.baseWidth, G.baseHeight)),
                        this.camera = e,
                        this.depthDownsamplingPass = new dD({
                            normalBuffer: t,
                            resolutionScale: L
                        }),
                        this.depthDownsamplingPass.enabled = a === null,
                        this.ssaoPass = new Kr(new gH(e));
                        const X = new wM(pD,pD,ps);
                        X.wrapS = X.wrapT = sh;
                        const q = this.ssaoMaterial;
                        q.normalBuffer = t,
                        q.noiseTexture = X,
                        q.minRadiusScale = M,
                        q.samples = i,
                        q.radius = T,
                        q.rings = s,
                        q.fade = U,
                        q.bias = w,
                        q.distanceThreshold = v,
                        q.distanceFalloff = y,
                        q.proximityThreshold = S,
                        q.proximityFalloff = A,
                        c !== void 0 && (q.worldDistanceThreshold = c),
                        u !== void 0 && (q.worldDistanceFalloff = u),
                        f !== void 0 && (q.worldProximityThreshold = f),
                        m !== void 0 && (q.worldProximityFalloff = m),
                        a !== null && (this.ssaoMaterial.normalDepthBuffer = a,
                        this.defines.set("NORMAL_DEPTH", "1")),
                        this.depthAwareUpsampling = o,
                        this.color = O
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.ssaoMaterial.copyCameraSettings(e)
                    }
                    get normalBuffer() {
                        return this.ssaoMaterial.normalBuffer
                    }
                    set normalBuffer(e) {
                        this.ssaoMaterial.normalBuffer = e,
                        this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = e
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get ssaoMaterial() {
                        return this.ssaoPass.fullscreenMaterial
                    }
                    getSSAOMaterial() {
                        return this.ssaoMaterial
                    }
                    get samples() {
                        return this.ssaoMaterial.samples
                    }
                    set samples(e) {
                        this.ssaoMaterial.samples = e
                    }
                    get rings() {
                        return this.ssaoMaterial.rings
                    }
                    set rings(e) {
                        this.ssaoMaterial.rings = e
                    }
                    get radius() {
                        return this.ssaoMaterial.radius
                    }
                    set radius(e) {
                        this.ssaoMaterial.radius = e
                    }
                    get depthAwareUpsampling() {
                        return this.defines.has("DEPTH_AWARE_UPSAMPLING")
                    }
                    set depthAwareUpsampling(e) {
                        this.depthAwareUpsampling !== e && (e ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1") : this.defines.delete("DEPTH_AWARE_UPSAMPLING"),
                        this.setChanged())
                    }
                    isDepthAwareUpsamplingEnabled() {
                        return this.depthAwareUpsampling
                    }
                    setDepthAwareUpsamplingEnabled(e) {
                        this.depthAwareUpsampling = e
                    }
                    get distanceScaling() {
                        return !0
                    }
                    set distanceScaling(e) {}
                    get color() {
                        return this.uniforms.get("color").value
                    }
                    set color(e) {
                        const t = this.uniforms
                          , n = this.defines;
                        e !== null ? n.has("COLORIZE") ? t.get("color").value.set(e) : (n.set("COLORIZE", "1"),
                        t.get("color").value = new ft(e),
                        this.setChanged()) : n.has("COLORIZE") && (n.delete("COLORIZE"),
                        t.get("color").value = null,
                        this.setChanged())
                    }
                    get luminanceInfluence() {
                        return this.uniforms.get("luminanceInfluence").value
                    }
                    set luminanceInfluence(e) {
                        this.uniforms.get("luminanceInfluence").value = e
                    }
                    get intensity() {
                        return this.uniforms.get("intensity").value
                    }
                    set intensity(e) {
                        this.uniforms.get("intensity").value = e
                    }
                    getColor() {
                        return this.color
                    }
                    setColor(e) {
                        this.color = e
                    }
                    setDistanceCutoff(e, t) {
                        this.ssaoMaterial.distanceThreshold = e,
                        this.ssaoMaterial.distanceFalloff = t
                    }
                    setProximityCutoff(e, t) {
                        this.ssaoMaterial.proximityThreshold = e,
                        this.ssaoMaterial.proximityFalloff = t
                    }
                    setDepthTexture(e, t=as) {
                        this.depthDownsamplingPass.setDepthTexture(e, t),
                        this.ssaoMaterial.depthBuffer = e,
                        this.ssaoMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        const i = this.renderTarget;
                        this.depthDownsamplingPass.enabled && this.depthDownsamplingPass.render(e),
                        this.ssaoPass.render(e, null, i)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.ssaoMaterial.copyCameraSettings(this.camera),
                        this.ssaoMaterial.setSize(i, s),
                        this.renderTarget.setSize(i, s),
                        this.depthDownsamplingPass.resolution.scale = n.scale,
                        this.depthDownsamplingPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        try {
                            let i = this.uniforms.get("normalDepthBuffer").value;
                            i === null && (this.depthDownsamplingPass.initialize(e, t, n),
                            i = this.depthDownsamplingPass.texture,
                            this.uniforms.get("normalDepthBuffer").value = i,
                            this.ssaoMaterial.normalDepthBuffer = i,
                            this.defines.set("NORMAL_DEPTH", "1"))
                        } catch {
                            this.depthDownsamplingPass.enabled = !1
                        }
                    }
                }
                  , TH = `#include <packing>
varying vec2 vUv;
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
float readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}
#else
#if INPUT_DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if INPUT_DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
void main(){
#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING
gl_FragColor=texture2D(depthBuffer,vUv);
#else
float depth=readDepth(vUv);
#if OUTPUT_DEPTH_PACKING == 3201
gl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);
#else
gl_FragColor=vec4(vec3(depth),1.0);
#endif
#endif
}`
                  , MH = `varying vec2 vUv;
#if DEPTH_COPY_MODE == 1
uniform vec2 texelPosition;
#endif
void main(){
#if DEPTH_COPY_MODE == 1
vUv=texelPosition;
#else
vUv=position.xy*0.5+0.5;
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`
                  , bH = class extends kn {
                    constructor() {
                        super({
                            name: "DepthCopyMaterial",
                            defines: {
                                INPUT_DEPTH_PACKING: "0",
                                OUTPUT_DEPTH_PACKING: "0",
                                DEPTH_COPY_MODE: "0"
                            },
                            uniforms: {
                                depthBuffer: new ke(null),
                                texelPosition: new ke(new Oe)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: TH,
                            vertexShader: MH
                        }),
                        this.depthCopyMode = e0.FULL
                    }
                    get depthBuffer() {
                        return this.uniforms.depthBuffer.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set inputDepthPacking(e) {
                        this.defines.INPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    get outputDepthPacking() {
                        return Number(this.defines.OUTPUT_DEPTH_PACKING)
                    }
                    set outputDepthPacking(e) {
                        this.defines.OUTPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=as) {
                        this.depthBuffer = e,
                        this.inputDepthPacking = t
                    }
                    getInputDepthPacking() {
                        return Number(this.defines.INPUT_DEPTH_PACKING)
                    }
                    setInputDepthPacking(e) {
                        this.defines.INPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getOutputDepthPacking() {
                        return Number(this.defines.OUTPUT_DEPTH_PACKING)
                    }
                    setOutputDepthPacking(e) {
                        this.defines.OUTPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    get texelPosition() {
                        return this.uniforms.texelPosition.value
                    }
                    getTexelPosition() {
                        return this.uniforms.texelPosition.value
                    }
                    setTexelPosition(e) {
                        this.uniforms.texelPosition.value = e
                    }
                    get mode() {
                        return this.depthCopyMode
                    }
                    set mode(e) {
                        this.depthCopyMode = e,
                        this.defines.DEPTH_COPY_MODE = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getMode() {
                        return this.mode
                    }
                    setMode(e) {
                        this.mode = e
                    }
                }
                  , EH = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`
                  , CH = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}"
                  , wH = class extends kn {
                    constructor(e, t, n, i, s=!1) {
                        super({
                            name: "EffectMaterial",
                            defines: {
                                THREE_REVISION: jc.replace(/\D+/g, ""),
                                DEPTH_PACKING: "0",
                                ENCODE_OUTPUT: "1"
                            },
                            uniforms: {
                                inputBuffer: new ke(null),
                                depthBuffer: new ke(null),
                                resolution: new ke(new Oe),
                                texelSize: new ke(new Oe),
                                cameraNear: new ke(.3),
                                cameraFar: new ke(1e3),
                                aspect: new ke(1),
                                time: new ke(0)
                            },
                            blending: pi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            dithering: s
                        }),
                        e && this.setShaderParts(e),
                        t && this.setDefines(t),
                        n && this.setUniforms(n),
                        this.copyCameraSettings(i)
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get depthBuffer() {
                        return this.uniforms.depthBuffer.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    get depthPacking() {
                        return Number(this.defines.DEPTH_PACKING)
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=as) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    setShaderData(e) {
                        this.setShaderParts(e.shaderParts),
                        this.setDefines(e.defines),
                        this.setUniforms(e.uniforms),
                        this.setExtensions(e.extensions)
                    }
                    setShaderParts(e) {
                        return this.fragmentShader = EH.replace(Xn.FRAGMENT_HEAD, e.get(Xn.FRAGMENT_HEAD) || "").replace(Xn.FRAGMENT_MAIN_UV, e.get(Xn.FRAGMENT_MAIN_UV) || "").replace(Xn.FRAGMENT_MAIN_IMAGE, e.get(Xn.FRAGMENT_MAIN_IMAGE) || ""),
                        this.vertexShader = CH.replace(Xn.VERTEX_HEAD, e.get(Xn.VERTEX_HEAD) || "").replace(Xn.VERTEX_MAIN_SUPPORT, e.get(Xn.VERTEX_MAIN_SUPPORT) || ""),
                        this.needsUpdate = !0,
                        this
                    }
                    setDefines(e) {
                        for (const t of e.entries())
                            this.defines[t[0]] = t[1];
                        return this.needsUpdate = !0,
                        this
                    }
                    setUniforms(e) {
                        for (const t of e.entries())
                            this.uniforms[t[0]] = t[1];
                        return this
                    }
                    setExtensions(e) {
                        this.extensions = {};
                        for (const t of e)
                            this.extensions[t] = !0;
                        return this
                    }
                    get encodeOutput() {
                        return this.defines.ENCODE_OUTPUT !== void 0
                    }
                    set encodeOutput(e) {
                        this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
                        this.needsUpdate = !0)
                    }
                    isOutputEncodingEnabled(e) {
                        return this.encodeOutput
                    }
                    setOutputEncodingEnabled(e) {
                        this.encodeOutput = e
                    }
                    get time() {
                        return this.uniforms.time.value
                    }
                    set time(e) {
                        this.uniforms.time.value = e
                    }
                    setDeltaTime(e) {
                        this.uniforms.time.value += e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near,
                        this.uniforms.cameraFar.value = e.far,
                        e instanceof Hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                    setSize(e, t) {
                        const n = this.uniforms;
                        n.resolution.value.set(e, t),
                        n.texelSize.value.set(1 / e, 1 / t),
                        n.aspect.value = e / t
                    }
                    static get Section() {
                        return Xn
                    }
                }
                  , DH = class extends sa {
                    constructor({depthPacking: e=Eo}={}) {
                        super("DepthCopyPass");
                        const t = new bH;
                        t.outputDepthPacking = e,
                        this.fullscreenMaterial = t,
                        this.needsDepthTexture = !0,
                        this.needsSwap = !1,
                        this.renderTarget = new Vn(1,1,{
                            type: e === Eo ? gi : na,
                            minFilter: ri,
                            magFilter: ri,
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "DepthCopyPass.Target"
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    get depthPacking() {
                        return this.fullscreenMaterial.outputDepthPacking
                    }
                    getDepthPacking() {
                        return this.fullscreenMaterial.outputDepthPacking
                    }
                    setDepthTexture(e, t=as) {
                        this.fullscreenMaterial.depthBuffer = e,
                        this.fullscreenMaterial.inputDepthPacking = t
                    }
                    render(e, t, n, i, s) {
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        this.renderTarget.setSize(e, t)
                    }
                }
                  , RH = Number(jc.replace(/\D+/g, ""))
                  , jf = 255 / 256
                  , UH = new Float32Array([jf / 256 ** 3, jf / 256 ** 2, jf / 256, jf])
                  , OH = new Float32Array([jf, jf / 256, jf / 256 ** 2, 1 / 256 ** 3]);
                function NH(e) {
                    const t = RH >= 167 ? OH : UH;
                    return (e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]) / 255
                }
                var BH = class extends DH {
                    constructor({depthPacking: e=Eo, mode: t=e0.SINGLE}={}) {
                        if (e !== Eo && e !== as)
                            throw new Error(`Unsupported depth packing: ${e}`);
                        super({
                            depthPacking: e
                        }),
                        this.name = "DepthPickingPass",
                        this.fullscreenMaterial.mode = t,
                        this.pixelBuffer = e === Eo ? new Uint8Array(4) : new Float32Array(4),
                        this.callback = null
                    }
                    readDepth(e) {
                        return this.fullscreenMaterial.texelPosition.set(e.x * .5 + .5, e.y * .5 + .5),
                        new Promise(t => {
                            this.callback = t
                        }
                        )
                    }
                    render(e, t, n, i, s) {
                        const a = this.fullscreenMaterial
                          , o = a.mode;
                        if (o === e0.FULL && super.render(e),
                        this.callback !== null) {
                            const c = this.renderTarget
                              , u = this.pixelBuffer
                              , f = c.texture.type !== na;
                            let m = 0
                              , v = 0;
                            if (o === e0.SINGLE)
                                super.render(e);
                            else {
                                const y = a.texelPosition;
                                m = Math.round(y.x * c.width),
                                v = Math.round(y.y * c.height)
                            }
                            e.readRenderTargetPixels(c, m, v, 1, 1, u),
                            this.callback(f ? NH(u) : u[0]),
                            this.callback = null
                        }
                    }
                    setSize(e, t) {
                        this.fullscreenMaterial.mode === e0.FULL && super.setSize(e, t)
                    }
                }
                ;
                function mD(e, t, n) {
                    for (const i of t) {
                        const s = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1)
                          , a = new RegExp("([^\\.])(\\b" + i + "\\b)","g");
                        for (const o of n.entries())
                            o[1] !== null && n.set(o[0], o[1].replace(a, s))
                    }
                }
                function LH(e, t, n) {
                    let i = t.getFragmentShader()
                      , s = t.getVertexShader();
                    const a = i !== void 0 && /mainImage/.test(i)
                      , o = i !== void 0 && /mainUv/.test(i);
                    if (n.attributes |= t.getAttributes(),
                    i === void 0)
                        throw new Error(`Missing fragment shader (${t.name})`);
                    if (o && (n.attributes & ar.CONVOLUTION) !== 0)
                        throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
                    if (!a && !o)
                        throw new Error(`Could not find mainImage or mainUv function (${t.name})`);
                    {
                        const c = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g
                          , u = n.shaderParts;
                        let f = u.get(Xn.FRAGMENT_HEAD) || ""
                          , m = u.get(Xn.FRAGMENT_MAIN_UV) || ""
                          , v = u.get(Xn.FRAGMENT_MAIN_IMAGE) || ""
                          , y = u.get(Xn.VERTEX_HEAD) || ""
                          , S = u.get(Xn.VERTEX_MAIN_SUPPORT) || "";
                        const A = new Set
                          , M = new Set;
                        if (o && (m += `	${e}MainUv(UV);
`,
                        n.uvTransformation = !0),
                        s !== null && /mainSupport/.test(s)) {
                            const D = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
                            S += `	${e}MainSupport(`,
                            S += D ? `vUv);
` : `);
`;
                            for (const w of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                                for (const U of w[1].split(/\s*,\s*/))
                                    n.varyings.add(U),
                                    A.add(U),
                                    M.add(U);
                            for (const w of s.matchAll(c))
                                M.add(w[1])
                        }
                        for (const D of i.matchAll(c))
                            M.add(D[1]);
                        for (const D of t.defines.keys())
                            M.add(D.replace(/\([\w\s,]*\)/g, ""));
                        for (const D of t.uniforms.keys())
                            M.add(D);
                        M.delete("while"),
                        M.delete("for"),
                        M.delete("if"),
                        t.uniforms.forEach( (D, w) => n.uniforms.set(e + w.charAt(0).toUpperCase() + w.slice(1), D)),
                        t.defines.forEach( (D, w) => n.defines.set(e + w.charAt(0).toUpperCase() + w.slice(1), D));
                        const x = new Map([["fragment", i], ["vertex", s]]);
                        mD(e, M, n.defines),
                        mD(e, M, x),
                        i = x.get("fragment"),
                        s = x.get("vertex");
                        const T = t.blendMode;
                        if (n.blendModes.set(T.blendFunction, T),
                        a) {
                            t.inputColorSpace !== null && t.inputColorSpace !== n.colorSpace && (v += t.inputColorSpace === Zt ? `color0 = sRGBTransferOETF(color0);
	` : `color0 = sRGBToLinear(color0);
	`),
                            t.outputColorSpace !== rl ? n.colorSpace = t.outputColorSpace : t.inputColorSpace !== null && (n.colorSpace = t.inputColorSpace);
                            const D = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                            v += `${e}MainImage(color0, UV, `,
                            (n.attributes & ar.DEPTH) !== 0 && D.test(i) && (v += "depth, ",
                            n.readDepth = !0),
                            v += `color1);
	`;
                            const w = e + "BlendOpacity";
                            n.uniforms.set(w, T.opacity),
                            v += `color0 = blend${T.blendFunction}(color0, color1, ${w});

	`,
                            f += `uniform float ${w};

`
                        }
                        if (f += i + `
`,
                        s !== null && (y += s + `
`),
                        u.set(Xn.FRAGMENT_HEAD, f),
                        u.set(Xn.FRAGMENT_MAIN_UV, m),
                        u.set(Xn.FRAGMENT_MAIN_IMAGE, v),
                        u.set(Xn.VERTEX_HEAD, y),
                        u.set(Xn.VERTEX_MAIN_SUPPORT, S),
                        t.extensions !== null)
                            for (const D of t.extensions)
                                n.extensions.add(D)
                    }
                }
                var IH = class extends sa {
                    constructor(e, ...t) {
                        super("EffectPass"),
                        this.fullscreenMaterial = new wH(null,null,null,e),
                        this.listener = n => this.handleEvent(n),
                        this.effects = [],
                        this.setEffects(t),
                        this.skipRendering = !1,
                        this.minTime = 1,
                        this.maxTime = Number.POSITIVE_INFINITY,
                        this.timeScale = 1
                    }
                    set mainScene(e) {
                        for (const t of this.effects)
                            t.mainScene = e
                    }
                    set mainCamera(e) {
                        this.fullscreenMaterial.copyCameraSettings(e);
                        for (const t of this.effects)
                            t.mainCamera = e
                    }
                    get encodeOutput() {
                        return this.fullscreenMaterial.encodeOutput
                    }
                    set encodeOutput(e) {
                        this.fullscreenMaterial.encodeOutput = e
                    }
                    get dithering() {
                        return this.fullscreenMaterial.dithering
                    }
                    set dithering(e) {
                        const t = this.fullscreenMaterial;
                        t.dithering = e,
                        t.needsUpdate = !0
                    }
                    setEffects(e) {
                        for (const t of this.effects)
                            t.removeEventListener("change", this.listener);
                        this.effects = e.sort( (t, n) => n.attributes - t.attributes);
                        for (const t of this.effects)
                            t.addEventListener("change", this.listener)
                    }
                    updateMaterial() {
                        const e = new GF;
                        let t = 0;
                        for (const o of this.effects)
                            if (o.blendMode.blendFunction === Wt.DST)
                                e.attributes |= o.getAttributes() & ar.DEPTH;
                            else {
                                if ((e.attributes & o.getAttributes() & ar.CONVOLUTION) !== 0)
                                    throw new Error(`Convolution effects cannot be merged (${o.name})`);
                                LH("e" + t++, o, e)
                            }
                        let n = e.shaderParts.get(Xn.FRAGMENT_HEAD)
                          , i = e.shaderParts.get(Xn.FRAGMENT_MAIN_IMAGE)
                          , s = e.shaderParts.get(Xn.FRAGMENT_MAIN_UV);
                        const a = /\bblend\b/g;
                        for (const o of e.blendModes.values())
                            n += o.getShaderCode().replace(a, `blend${o.blendFunction}`) + `
`;
                        (e.attributes & ar.DEPTH) !== 0 ? (e.readDepth && (i = `float depth = readDepth(UV);

	` + i),
                        this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1,
                        e.colorSpace === Zt && (i += `color0 = sRGBToLinear(color0);
	`),
                        e.uvTransformation ? (s = `vec2 transformedUv = vUv;
` + s,
                        e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"),
                        e.shaderParts.set(Xn.FRAGMENT_HEAD, n),
                        e.shaderParts.set(Xn.FRAGMENT_MAIN_IMAGE, i),
                        e.shaderParts.set(Xn.FRAGMENT_MAIN_UV, s);
                        for (const [o,c] of e.shaderParts)
                            c !== null && e.shaderParts.set(o, c.trim().replace(/^#/, `
#`));
                        this.skipRendering = t === 0,
                        this.needsSwap = !this.skipRendering,
                        this.fullscreenMaterial.setShaderData(e)
                    }
                    recompile() {
                        this.updateMaterial()
                    }
                    getDepthTexture() {
                        return this.fullscreenMaterial.depthBuffer
                    }
                    setDepthTexture(e, t=as) {
                        this.fullscreenMaterial.depthBuffer = e,
                        this.fullscreenMaterial.depthPacking = t;
                        for (const n of this.effects)
                            n.setDepthTexture(e, t)
                    }
                    render(e, t, n, i, s) {
                        for (const a of this.effects)
                            a.update(e, t, i);
                        if (!this.skipRendering || this.renderToScreen) {
                            const a = this.fullscreenMaterial;
                            a.inputBuffer = t.texture,
                            a.time += i * this.timeScale,
                            e.setRenderTarget(this.renderToScreen ? null : n),
                            e.render(this.scene, this.camera)
                        }
                    }
                    setSize(e, t) {
                        this.fullscreenMaterial.setSize(e, t);
                        for (const n of this.effects)
                            n.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.renderer = e;
                        for (const i of this.effects)
                            i.initialize(e, t, n);
                        this.updateMaterial(),
                        n !== void 0 && n !== gi && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                    dispose() {
                        super.dispose();
                        for (const e of this.effects)
                            e.removeEventListener("change", this.listener),
                            e.dispose()
                    }
                    handleEvent(e) {
                        switch (e.type) {
                        case "change":
                            this.recompile();
                            break
                        }
                    }
                }
                  , PH = class extends sa {
                    constructor(e, t, {renderTarget: n, resolutionScale: i=1, width: s=Zn.AUTO_SIZE, height: a=Zn.AUTO_SIZE, resolutionX: o=s, resolutionY: c=a}={}) {
                        super("NormalPass"),
                        this.needsSwap = !1,
                        this.renderPass = new $g(e,t,new CT);
                        const u = this.renderPass;
                        u.ignoreBackground = !0,
                        u.skipShadowMapUpdate = !0;
                        const f = u.getClearPass();
                        f.overrideClearColor = new ft(7829503),
                        f.overrideClearAlpha = 1,
                        this.renderTarget = n,
                        this.renderTarget === void 0 && (this.renderTarget = new Vn(1,1,{
                            minFilter: ri,
                            magFilter: ri
                        }),
                        this.renderTarget.texture.name = "NormalPass.Target");
                        const m = this.resolution = new Zn(this,o,c,i);
                        m.addEventListener("change", v => this.setSize(m.baseWidth, m.baseHeight))
                    }
                    set mainScene(e) {
                        this.renderPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.renderPass.mainCamera = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, s) {
                        const a = this.renderToScreen ? null : this.renderTarget;
                        this.renderPass.render(e, a, a)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height)
                    }
                }
                  , zX = [new Float32Array(3), new Float32Array(3)]
                  , FX = [new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3)]
                  , HX = [[new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])]]
                  , GX = [new Float32Array(2), new Float32Array(2)]
                  , VX = new Float32Array([0, -.25, .25, -.125, .125, -.375, .375])
                  , kX = [new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125])]
                  , XX = [new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4])]
                  , WX = [new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3])]
                  , YX = new Map([[Ea(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])], [Ea(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])], [Ea(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])], [Ea(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])], [Ea(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])], [Ea(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])], [Ea(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])], [Ea(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])], [Ea(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])], [Ea(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])], [Ea(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])], [Ea(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])], [Ea(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])], [Ea(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])], [Ea(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])], [Ea(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]]);
                function RM(e, t, n) {
                    return e + (t - e) * n
                }
                function Ea(e, t, n, i) {
                    const s = RM(e, t, .75)
                      , a = RM(n, i, .75);
                    return RM(s, a, .875)
                }
                function n0(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n,
                    e
                }
                function UM(e, t) {
                    return UM = Object.setPrototypeOf || function(i, s) {
                        return i.__proto__ = s,
                        i
                    }
                    ,
                    UM(e, t)
                }
                function zH() {
                    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                        return !1;
                    if (typeof Proxy == "function")
                        return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
                        !0
                    } catch {
                        return !1
                    }
                }
                function OM(e, t) {
                    (t == null || t > e.length) && (t = e.length);
                    for (var n = 0, i = new Array(t); n < t; n++)
                        i[n] = e[n];
                    return i
                }
                function FH(e, t) {
                    if (e) {
                        if (typeof e == "string")
                            return OM(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        if (n === "Object" && e.constructor && (n = e.constructor.name),
                        n === "Map" || n === "Set")
                            return Array.from(e);
                        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                            return OM(e, t)
                    }
                }
                function HH(e) {
                    if (Array.isArray(e))
                        return OM(e)
                }
                function GH(e) {
                    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
                        return Array.from(e)
                }
                function VH() {
                    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function kH(e) {
                    return HH(e) || GH(e) || FH(e) || VH()
                }
                var qX = new Oe
                  , jX = new Oe;
                function XH(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                }
                function WH(e, t) {
                    return XH(e - Math.floor(e / t) * t, 0, t)
                }
                function YH(e, t) {
                    var n = WH(t - e, Math.PI * 2);
                    return n > Math.PI && (n -= Math.PI * 2),
                    n
                }
                function NM(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }
                var Uo = function e(t, n, i) {
                    var s = this;
                    NM(this, e),
                    n0(this, "dot2", function(a, o) {
                        return s.x * a + s.y * o
                    }),
                    n0(this, "dot3", function(a, o, c) {
                        return s.x * a + s.y * o + s.z * c
                    }),
                    this.x = t,
                    this.y = n,
                    this.z = i
                }
                  , qH = [new Uo(1,1,0), new Uo(-1,1,0), new Uo(1,-1,0), new Uo(-1,-1,0), new Uo(1,0,1), new Uo(-1,0,1), new Uo(1,0,-1), new Uo(-1,0,-1), new Uo(0,1,1), new Uo(0,-1,1), new Uo(0,1,-1), new Uo(0,-1,-1)]
                  , vD = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
                  , gD = new Array(512)
                  , yD = new Array(512)
                  , jH = function(t) {
                    t > 0 && t < 1 && (t *= 65536),
                    t = Math.floor(t),
                    t < 256 && (t |= t << 8);
                    for (var n = 0; n < 256; n++) {
                        var i;
                        n & 1 ? i = vD[n] ^ t & 255 : i = vD[n] ^ t >> 8 & 255,
                        gD[n] = gD[n + 256] = i,
                        yD[n] = yD[n + 256] = qH[i % 12]
                    }
                };
                jH(0);
                var QX = .5 * (Math.sqrt(3) - 1)
                  , ZX = (3 - Math.sqrt(3)) / 6
                  , KX = 1 / 3
                  , JX = 1 / 6
                  , $X = Math.PI * 2;
                function QH(e) {
                    if (typeof e == "number")
                        e = Math.abs(e);
                    else if (typeof e == "string") {
                        var t = e;
                        e = 0;
                        for (var n = 0; n < t.length; n++)
                            e = (e + (n + 1) * (t.charCodeAt(n) % 96)) % 2147483647
                    }
                    return e === 0 && (e = 311),
                    e
                }
                function _D(e) {
                    var t = QH(e);
                    return function() {
                        var n = t * 48271 % 2147483647;
                        return t = n,
                        n / 2147483647
                    }
                }
                var ZH = function e(t) {
                    var n = this;
                    NM(this, e),
                    n0(this, "seed", 0),
                    n0(this, "init", function(i) {
                        n.seed = i,
                        n.value = _D(i)
                    }),
                    n0(this, "value", _D(this.seed)),
                    this.init(t)
                }
                  , eW = new ZH(Math.random())
                  , KH = function(t) {
                    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .01
                      , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
                      , s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / (2 * Math.PI);
                    return i / Math.atan(1 / n) * Math.atan(Math.sin(2 * Math.PI * t * s) / n)
                }
                  , SD = function(t) {
                    return 1 / (1 + t + .48 * t * t + .235 * t * t * t)
                };
                function Os(e, t, n) {
                    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : .25
                      , s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .01
                      , a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0
                      , o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : SD
                      , c = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : .001
                      , u = "velocity_" + t;
                    if (e.__damp === void 0 && (e.__damp = {}),
                    e.__damp[u] === void 0 && (e.__damp[u] = 0),
                    Math.abs(e[t] - n) <= c)
                        return e[t] = n,
                        !1;
                    i = Math.max(1e-4, i);
                    var f = 2 / i
                      , m = o(f * s)
                      , v = e[t] - n
                      , y = n
                      , S = a * i;
                    v = Math.min(Math.max(v, -S), S),
                    n = e[t] - v;
                    var A = (e.__damp[u] + f * v) * s;
                    e.__damp[u] = (e.__damp[u] - f * A) * m;
                    var M = n + (v + A) * m;
                    return y - e[t] > 0 == M > y && (M = y,
                    e.__damp[u] = (M - y) / s),
                    e[t] = M,
                    !0
                }
                function om(e, t, n, i, s, a, o, c) {
                    return Os(e, t, e[t] + YH(e[t], n), i, s, a, o, c)
                }
                var i0 = new Oe, xD, AD;
                function JH(e, t, n, i, s, a, o) {
                    return typeof t == "number" ? i0.setScalar(t) : Array.isArray(t) ? i0.set(t[0], t[1]) : i0.copy(t),
                    xD = Os(e, "x", i0.x, n, i, s, a, o),
                    AD = Os(e, "y", i0.y, n, i, s, a, o),
                    xD || AD
                }
                var lm = new ae, TD, MD, bD;
                function BM(e, t, n, i, s, a, o) {
                    return typeof t == "number" ? lm.setScalar(t) : Array.isArray(t) ? lm.set(t[0], t[1], t[2]) : lm.copy(t),
                    TD = Os(e, "x", lm.x, n, i, s, a, o),
                    MD = Os(e, "y", lm.y, n, i, s, a, o),
                    bD = Os(e, "z", lm.z, n, i, s, a, o),
                    TD || MD || bD
                }
                var Qf = new hn, ED, CD, wD, DD;
                function $H(e, t, n, i, s, a, o) {
                    return typeof t == "number" ? Qf.setScalar(t) : Array.isArray(t) ? Qf.set(t[0], t[1], t[2], t[3]) : Qf.copy(t),
                    ED = Os(e, "x", Qf.x, n, i, s, a, o),
                    CD = Os(e, "y", Qf.y, n, i, s, a, o),
                    wD = Os(e, "z", Qf.z, n, i, s, a, o),
                    DD = Os(e, "w", Qf.w, n, i, s, a, o),
                    ED || CD || wD || DD
                }
                var s0 = new Co, RD, UD, OD;
                function eG(e, t, n, i, s, a, o) {
                    return Array.isArray(t) ? s0.set(t[0], t[1], t[2], t[3]) : s0.copy(t),
                    RD = om(e, "x", s0.x, n, i, s, a, o),
                    UD = om(e, "y", s0.y, n, i, s, a, o),
                    OD = om(e, "z", s0.z, n, i, s, a, o),
                    RD || UD || OD
                }
                var cm = new ft, ND, BD, LD;
                function tG(e, t, n, i, s, a, o) {
                    return t instanceof ft ? cm.copy(t) : Array.isArray(t) ? cm.setRGB(t[0], t[1], t[2]) : cm.set(t),
                    ND = Os(e, "r", cm.r, n, i, s, a, o),
                    BD = Os(e, "g", cm.g, n, i, s, a, o),
                    LD = Os(e, "b", cm.b, n, i, s, a, o),
                    ND || BD || LD
                }
                var dl = new ia, cu = new hn, ID = new hn, a0 = new hn, PD, zD, FD, HD;
                function GD(e, t, n, i, s, a, o) {
                    var c = e;
                    Array.isArray(t) ? dl.set(t[0], t[1], t[2], t[3]) : dl.copy(t);
                    var u = e.dot(dl) > 0 ? 1 : -1;
                    return dl.x *= u,
                    dl.y *= u,
                    dl.z *= u,
                    dl.w *= u,
                    PD = Os(e, "x", dl.x, n, i, s, a, o),
                    zD = Os(e, "y", dl.y, n, i, s, a, o),
                    FD = Os(e, "z", dl.z, n, i, s, a, o),
                    HD = Os(e, "w", dl.w, n, i, s, a, o),
                    cu.set(e.x, e.y, e.z, e.w).normalize(),
                    ID.set(c.__damp.velocity_x, c.__damp.velocity_y, c.__damp.velocity_z, c.__damp.velocity_w),
                    a0.copy(cu).multiplyScalar(ID.dot(cu) / cu.dot(cu)),
                    c.__damp.velocity_x -= a0.x,
                    c.__damp.velocity_y -= a0.y,
                    c.__damp.velocity_z -= a0.z,
                    c.__damp.velocity_w -= a0.w,
                    e.set(cu.x, cu.y, cu.z, cu.w),
                    PD || zD || FD || HD
                }
                var r0 = new B2, VD, kD, XD;
                function nG(e, t, n, i, s, a, o) {
                    return Array.isArray(t) ? r0.set(t[0], t[1], t[2]) : r0.copy(t),
                    VD = Os(e, "radius", r0.radius, n, i, s, a, o),
                    kD = om(e, "phi", r0.phi, n, i, s, a, o),
                    XD = om(e, "theta", r0.theta, n, i, s, a, o),
                    VD || kD || XD
                }
                var HS = new Xt, WD = new ae, YD = new ia, qD = new ae, jD, QD, ZD;
                function iG(e, t, n, i, s, a, o) {
                    var c = e;
                    return c.__damp === void 0 && (c.__damp = {
                        position: new ae,
                        rotation: new ia,
                        scale: new ae
                    },
                    e.decompose(c.__damp.position, c.__damp.rotation, c.__damp.scale)),
                    Array.isArray(t) ? HS.set.apply(HS, kH(t)) : HS.copy(t),
                    HS.decompose(WD, YD, qD),
                    jD = BM(c.__damp.position, WD, n, i, s, a, o),
                    QD = GD(c.__damp.rotation, YD, n, i, s, a, o),
                    ZD = BM(c.__damp.scale, qD, n, i, s, a, o),
                    e.compose(c.__damp.position, c.__damp.rotation, c.__damp.scale),
                    jD || QD || ZD
                }
                var KD = Object.freeze({
                    __proto__: null,
                    rsqw: KH,
                    exp: SD,
                    damp: Os,
                    dampAngle: om,
                    damp2: JH,
                    damp3: BM,
                    damp4: $H,
                    dampE: eG,
                    dampC: tG,
                    dampQ: GD,
                    dampS: nG,
                    dampM: iG
                });
                function sG(e, t) {
                    if (typeof t != "function" && t !== null)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    t && UM(e, t)
                }
                function GS(e) {
                    return GS = Object.setPrototypeOf ? Object.getPrototypeOf : function(n) {
                        return n.__proto__ || Object.getPrototypeOf(n)
                    }
                    ,
                    GS(e)
                }
                function aG(e) {
                    if (e === void 0)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }
                function rG(e, t) {
                    if (t && (typeof t == "object" || typeof t == "function"))
                        return t;
                    if (t !== void 0)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return aG(e)
                }
                function oG(e) {
                    var t = zH();
                    return function() {
                        var i = GS(e), s;
                        if (t) {
                            var a = GS(this).constructor;
                            s = Reflect.construct(i, arguments, a)
                        } else
                            s = i.apply(this, arguments);
                        return rG(this, s)
                    }
                }
                var tW = (function(e) {
                    sG(n, e);
                    var t = oG(n);
                    function n() {
                        var i, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : .2, c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 16;
                        NM(this, n),
                        i = t.call(this);
                        for (var u = s / 2 - o, f = a / 2 - o, m = o / s, v = (s - o) / s, y = o / a, S = (a - o) / a, A = [u, f, 0, -u, f, 0, -u, -f, 0, u, -f, 0], M = [v, S, m, S, m, y, v, y], x = [3 * (c + 1) + 3, 3 * (c + 1) + 4, c + 4, c + 5, 2 * (c + 1) + 4, 2, 1, 2 * (c + 1) + 3, 3, 4 * (c + 1) + 3, 4, 0], T = [x[0], x[1], x[2], x[0], x[2], x[3], x[4], x[5], x[6], x[4], x[6], x[7], x[8], x[9], x[10], x[8], x[10], x[11]], D, w, U, O, L, N, z, I, B = 0; B < 4; B++) {
                            O = B < 1 || B > 2 ? u : -u,
                            L = B < 2 ? f : -f,
                            N = B < 1 || B > 2 ? v : m,
                            z = B < 2 ? S : y;
                            for (var G = 0; G <= c; G++)
                                D = Math.PI / 2 * (B + G / c),
                                w = Math.cos(D),
                                U = Math.sin(D),
                                A.push(O + o * w, L + o * U, 0),
                                M.push(N + m * w, z + y * U),
                                G < c && (I = (c + 1) * B + G + 4,
                                T.push(B, I, I + 1))
                        }
                        return i.setIndex(new Ln(new Uint32Array(T),1)),
                        i.setAttribute("position", new Ln(new Float32Array(A),3)),
                        i.setAttribute("uv", new Ln(new Float32Array(M),2)),
                        i
                    }
                    return n
                }
                )(sn);
                const nW = parseInt(jc.replace(/\D+/g, "")) >= 162 ? class extends Vn {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, {
                            ...i,
                            count: n
                        }),
                        this.isWebGLMultipleRenderTargets = !0
                    }
                    get texture() {
                        return this.textures
                    }
                }
                : class extends Vn {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isWebGLMultipleRenderTargets = !0;
                        const s = this.texture;
                        this.texture = [];
                        for (let a = 0; a < n; a++)
                            this.texture[a] = s.clone(),
                            this.texture[a].isRenderTargetTexture = !0
                    }
                    setSize(e, t, n=1) {
                        if (this.width !== e || this.height !== t || this.depth !== n) {
                            this.width = e,
                            this.height = t,
                            this.depth = n;
                            for (let i = 0, s = this.texture.length; i < s; i++)
                                this.texture[i].image.width = e,
                                this.texture[i].image.height = t,
                                this.texture[i].image.depth = n;
                            this.dispose()
                        }
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t)
                    }
                    copy(e) {
                        this.dispose(),
                        this.width = e.width,
                        this.height = e.height,
                        this.depth = e.depth,
                        this.scissor.copy(e.scissor),
                        this.scissorTest = e.scissorTest,
                        this.viewport.copy(e.viewport),
                        this.depthBuffer = e.depthBuffer,
                        this.stencilBuffer = e.stencilBuffer,
                        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                        this.texture.length = 0;
                        for (let t = 0, n = e.texture.length; t < n; t++)
                            this.texture[t] = e.texture[t].clone(),
                            this.texture[t].isRenderTargetTexture = !0;
                        return this
                    }
                }
                  , JD = (0,
                We.createContext)(null)
                  , Sh = (0,
                We.createContext)(null)
                  , $D = e => (e.getAttributes() & 2) === 2
                  , lG = (0,
                We.memo)((0,
                We.forwardRef)( ({children: e, camera: t, scene: n, resolutionScale: i, enabled: s=!0, renderPriority: a=1, autoClear: o=!0, depthBuffer: c, enableNormalPass: u, stencilBuffer: f, multisampling: m=8, frameBufferType: v=ff}, y) => {
                    const {gl: S, scene: A, camera: M, size: x} = Ro()
                      , T = n || A
                      , D = t || M
                      , [w,U,O] = (0,
                    We.useMemo)( () => {
                        const z = new HF(S,{
                            depthBuffer: c,
                            stencilBuffer: f,
                            multisampling: m,
                            frameBufferType: v
                        });
                        z.addPass(new $g(T,D));
                        let I = null
                          , B = null;
                        return u && (B = new PH(T,D),
                        B.enabled = !1,
                        z.addPass(B),
                        i !== void 0 && (I = new dD({
                            normalBuffer: B.texture,
                            resolutionScale: i
                        }),
                        I.enabled = !1,
                        z.addPass(I))),
                        [z, B, I]
                    }
                    , [D, S, c, f, m, v, T, u, i]);
                    (0,
                    We.useEffect)( () => w?.setSize(x.width, x.height), [w, x]),
                    kf( (z, I) => {
                        if (s) {
                            const B = S.autoClear;
                            S.autoClear = o,
                            f && !o && S.clearStencil(),
                            w.render(I),
                            S.autoClear = B
                        }
                    }
                    , s ? a : 0);
                    const L = (0,
                    We.useRef)(null);
                    (0,
                    We.useLayoutEffect)( () => {
                        const z = []
                          , I = L.current.__r3f;
                        if (I && w) {
                            const B = I.children;
                            for (let G = 0; G < B.length; G++) {
                                const X = B[G].object;
                                if (X instanceof Vi) {
                                    const q = [X];
                                    if (!$D(X)) {
                                        let oe = null;
                                        for (; (oe = B[G + 1]?.object)instanceof Vi && !$D(oe); )
                                            q.push(oe),
                                            G++
                                    }
                                    const Q = new IH(D,...q);
                                    z.push(Q)
                                } else
                                    X instanceof sa && z.push(X)
                            }
                            for (const G of z)
                                w?.addPass(G);
                            U && (U.enabled = !0),
                            O && (O.enabled = !0)
                        }
                        return () => {
                            for (const B of z)
                                w?.removePass(B);
                            U && (U.enabled = !1),
                            O && (O.enabled = !1)
                        }
                    }
                    , [w, e, D, U, O]),
                    (0,
                    We.useEffect)( () => {
                        const z = S.toneMapping;
                        return S.toneMapping = al,
                        () => {
                            S.toneMapping = z
                        }
                    }
                    , [S]);
                    const N = (0,
                    We.useMemo)( () => ({
                        composer: w,
                        normalPass: U,
                        downSamplingPass: O,
                        resolutionScale: i,
                        camera: D,
                        scene: T
                    }), [w, U, O, i, D, T]);
                    return (0,
                    We.useImperativeHandle)(y, () => w, [w]),
                    (0,
                    vt.jsx)(Sh.Provider, {
                        value: N,
                        children: (0,
                        vt.jsx)("group", {
                            ref: L,
                            children: e
                        })
                    })
                }
                ))
                  , xh = e => typeof e == "object" && e != null && "current"in e ? e.current : e;
                let cG = 0;
                const eR = new WeakMap
                  , Jr = (e, t) => function({blendFunction: n=t?.blendFunction, opacity: i=t?.opacity, ...s}) {
                    let a = eR.get(e);
                    if (!a) {
                        const u = `@react-three/postprocessing/${e.name}-${cG++}`;
                        hM({
                            [u]: e
                        }),
                        eR.set(e, a = u)
                    }
                    const o = Ro(u => u.camera)
                      , c = We.useMemo( () => [...t?.args ?? [], ...s.args ?? [{
                        ...t,
                        ...s
                    }]], [JSON.stringify(s)]);
                    return (0,
                    vt.jsx)(a, {
                        camera: o,
                        "blendMode-blendFunction": n,
                        "blendMode-opacity-value": i,
                        ...s,
                        args: c
                    })
                }
                  , VS = (e, t) => {
                    const n = e[t];
                    return We.useMemo( () => typeof n == "number" ? new Oe(n,n) : n ? new Oe(...n) : new Oe, [n])
                }
                  , uG = (0,
                We.forwardRef)(function({blendFunction: e, worldFocusDistance: t, worldFocusRange: n, focusDistance: i, focusRange: s, focalLength: a, bokehScale: o, resolutionScale: c, resolutionX: u, resolutionY: f, width: m, height: v, target: y, depthTexture: S, ...A}, M) {
                    const {camera: x} = (0,
                    We.useContext)(Sh)
                      , T = y != null
                      , D = (0,
                    We.useMemo)( () => {
                        const w = new T5(x,{
                            blendFunction: e,
                            worldFocusDistance: t,
                            worldFocusRange: n,
                            focusDistance: i,
                            focusRange: s,
                            focalLength: a,
                            bokehScale: o,
                            resolutionScale: c,
                            resolutionX: u,
                            resolutionY: f,
                            width: m,
                            height: v
                        });
                        T && (w.target = new ae),
                        S && w.setDepthTexture(S.texture, S.packing);
                        const U = w.maskPass;
                        return U.maskFunction = CM.MULTIPLY_RGB_SET_ALPHA,
                        w
                    }
                    , [x, e, t, n, i, s, a, o, c, u, f, m, v, T, S]);
                    return (0,
                    We.useEffect)( () => () => {
                        D.dispose()
                    }
                    , [D]),
                    (0,
                    vt.jsx)("primitive", {
                        ...A,
                        ref: M,
                        object: D,
                        target: y
                    })
                })
                  , iW = (0,
                We.forwardRef)( ({target: e=void 0, mouse: t=!1, debug: n=void 0, manual: i=!1, smoothTime: s=.25, ...a}, o) => {
                    const c = (0,
                    We.useRef)(null)
                      , u = (0,
                    We.useRef)(null)
                      , f = (0,
                    We.useRef)(null)
                      , m = Ro( ({scene: O}) => O)
                      , v = Ro( ({pointer: O}) => O)
                      , {composer: y, camera: S} = (0,
                    We.useContext)(Sh)
                      , [A] = (0,
                    We.useState)( () => new BH)
                      , [M] = (0,
                    We.useState)( () => new tD);
                    (0,
                    We.useEffect)( () => (y.addPass(A),
                    y.addPass(M),
                    () => {
                        y.removePass(A),
                        y.removePass(M)
                    }
                    ), [y, A, M]),
                    (0,
                    We.useEffect)( () => () => {
                        A.dispose(),
                        M.dispose()
                    }
                    , [A, M]);
                    const [x] = (0,
                    We.useState)( () => new ae(0,0,0))
                      , [T] = (0,
                    We.useState)( () => new ae(0,0,0))
                      , D = (0,
                    We.useCallback)(async (O, L) => (T.x = O,
                    T.y = L,
                    T.z = await A.readDepth(T),
                    T.z = T.z * 2 - 1,
                    1 - T.z > 1e-7 ? T.unproject(S) : !1), [T, A, S])
                      , w = (0,
                    We.useCallback)(async (O, L=!0) => {
                        if (e)
                            x.set(...e);
                        else {
                            const {x: N, y: z} = t ? v : {
                                x: 0,
                                y: 0
                            }
                              , I = await D(N, z);
                            I && x.copy(I)
                        }
                        L && c.current?.target && (s > 0 && O > 0 ? KD.damp3(c.current.target, x, s, O) : c.current.target.copy(x))
                    }
                    , [e, x, t, D, s, v]);
                    kf(async (O, L) => {
                        i || w(L),
                        u.current && u.current.position.copy(x),
                        f.current && c.current?.target && f.current.position.copy(c.current.target)
                    }
                    );
                    const U = (0,
                    We.useMemo)( () => ({
                        dofRef: c,
                        hitpoint: x,
                        update: w
                    }), [x, w]);
                    return (0,
                    We.useImperativeHandle)(o, () => U, [U]),
                    (0,
                    vt.jsxs)(vt.Fragment, {
                        children: [n ? xF((0,
                        vt.jsxs)(vt.Fragment, {
                            children: [(0,
                            vt.jsxs)("mesh", {
                                ref: u,
                                children: [(0,
                                vt.jsx)("sphereGeometry", {
                                    args: [n, 16, 16]
                                }), (0,
                                vt.jsx)("meshBasicMaterial", {
                                    color: "#00ff00",
                                    opacity: 1,
                                    transparent: !0,
                                    depthWrite: !1
                                })]
                            }), (0,
                            vt.jsxs)("mesh", {
                                ref: f,
                                children: [(0,
                                vt.jsx)("sphereGeometry", {
                                    args: [n / 2, 16, 16]
                                }), (0,
                                vt.jsx)("meshBasicMaterial", {
                                    color: "#00ff00",
                                    opacity: .5,
                                    transparent: !0,
                                    depthWrite: !1
                                })]
                            })]
                        }), m) : null, (0,
                        vt.jsx)(uG, {
                            ref: c,
                            ...a,
                            target: x
                        })]
                    })
                }
                )
                  , hG = {
                    fragmentShader: `
    uniform float time;
    uniform vec2 lensPosition;
    uniform vec2 screenRes;
    uniform vec3 colorGain;
    uniform float starPoints;
    uniform float glareSize;
    uniform float flareSize;
    uniform float flareSpeed;
    uniform float flareShape;
    uniform float haloScale;
    uniform float opacity;
    uniform bool animated;
    uniform bool anamorphic;
    uniform bool enabled;
    uniform bool secondaryGhosts;
    uniform bool starBurst;
    uniform float ghostScale;
    uniform bool aditionalStreaks;
    uniform sampler2D lensDirtTexture;
    vec2 vTexCoord;
    
    float rand(float n){return fract(sin(n) * 43758.5453123);}

    float noise(float p){
      float fl = floor(p);
      float fc = fract(p);
      return mix(rand(fl),rand(fl + 1.0), fc);
    }

    vec3 hsv2rgb(vec3 c)
    {
      vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);
      return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);
    }

    float saturate(float x)
    {
      return clamp(x, 0.,1.);
    }

    vec2 rotateUV(vec2 uv, float rotation)
    {
      return vec2(
          cos(rotation) * uv.x + sin(rotation) * uv.y,
          cos(rotation) * uv.y - sin(rotation) * uv.x
      );
    }

    // Based on https://www.shadertoy.com/view/XtKfRV
    vec3 drawflare(vec2 p, float intensity, float rnd, float speed, int id)
    {
      float flarehueoffset = (1. / 32.) * float(id) * 0.1;
      float lingrad = distance(vec2(0.), p);
      float expgrad = 1. / exp(lingrad * (fract(rnd) * 0.66 + 0.33));
      vec3 colgrad = hsv2rgb(vec3( fract( (expgrad * 8.) + speed * flareSpeed + flarehueoffset), pow(1.-abs(expgrad*2.-1.), 0.45), 20.0 * expgrad * intensity)); //rainbow spectrum effect

      float internalStarPoints;

      if(anamorphic){
        internalStarPoints = 1.0;
      } else{
        internalStarPoints = starPoints;
      }
      
      float blades = length(p * flareShape * sin(internalStarPoints * atan(p.x, p.y)));
      
      float comp = pow(1.-saturate(blades), ( anamorphic ? 100. : 12.));
      comp += saturate(expgrad-0.9) * 3.;
      comp = pow(comp * expgrad, 8. + (1.-intensity) * 5.);
      
      if(flareSpeed > 0.0){
        return vec3(comp) * colgrad;
      } else{
        return vec3(comp) * flareSize * 15.;
      }
    }

    float dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }

    vec3 saturate(vec3 x)
    {
      return clamp(x, vec3(0.0), vec3(1.0));
    }

    // Based on https://www.shadertoy.com/view/XtKfRV
    float glare(vec2 uv, vec2 pos, float size)
    {
      vec2 main;

      if(animated){
        main = rotateUV(uv-pos, time * 0.1);      
      } else{
        main = uv-pos;     
      }
      
      float ang = atan(main.y, main.x) * (anamorphic ? 1.0 : starPoints);
      float dist = length(main); 
      dist = pow(dist, .9);
      
      float f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+.2);

      return f0+f0*(sin((ang))*.2 +.3);
    }

    float sdHex(vec2 p){
      p = abs(p);
      vec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);
      return dot(step(q.xy,q.yx), 1.0-q.yx);
    }

    //Based on https://www.shadertoy.com/view/dllSRX
    float fpow(float x, float k){
      return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;
    }

    vec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){
      uv -= p;
      if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){
          return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.1,sdHex(uv*20.0/s)));
      }
      return vec3(0);
    }

    // Based on https://www.shadertoy.com/view/4sX3Rs
    vec3 LensFlare(vec2 uv, vec2 pos)
    {
      vec2 main = uv-pos;
      vec2 uvd = uv*(length(uv));
      
      float ang = atan(main.x,main.y);
      
      float f0 = .3/(length(uv-pos)*16.0+1.0);
      
      f0 = f0*(sin(noise(sin(ang*3.9-(animated ? time : 0.0) * 0.3) * starPoints))*.2 );
      
      float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;

      float f2 = max(.9/(10.0+32.0*pow(length(uvd+0.99*pos),2.0)),.0)*0.35;
      float f22 = max(.9/(11.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*0.23;
      float f23 = max(.9/(12.0+32.0*pow(length(uvd+0.95*pos),2.0)),.0)*0.6;
      
      vec2 uvx = mix(uv,uvd, 0.1);
      
      float f4 = max(0.01-pow(length(uvx+0.4*pos),2.9),.0)*4.02;
      float f42 = max(0.0-pow(length(uvx+0.45*pos),2.9),.0)*4.1;
      float f43 = max(0.01-pow(length(uvx+0.5*pos),2.9),.0)*4.6;
      
      uvx = mix(uv,uvd,-.4);
      
      float f5 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;
      float f52 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;
      float f53 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;
      
      uvx = mix(uv,uvd, 2.1);
      
      float f6 = max(0.01-pow(length(uvx-0.3*pos),1.61),.0)*3.159;
      float f62 = max(0.01-pow(length(uvx-0.325*pos),1.614),.0)*3.14;
      float f63 = max(0.01-pow(length(uvx-0.389*pos),1.623),.0)*3.12;
      
      vec3 c = vec3(glare(uv,pos, glareSize));

      vec2 prot;

      if(animated){
        prot = rotateUV(uv - pos, (time * 0.1));  
      } else if(anamorphic){
        prot = rotateUV(uv - pos, 1.570796);     
      } else {
        prot = uv - pos;
      }

      c += drawflare(prot, (anamorphic ? flareSize * 10. : flareSize), 0.1, time, 1);
      
      c.r+=f1+f2+f4+f5+f6; c.g+=f1+f22+f42+f52+f62; c.b+=f1+f23+f43+f53+f63;
      c = c*1.3 * vec3(length(uvd)+.09);
      c+=vec3(f0);
      
      return c;
    }

    vec3 cc(vec3 color, float factor,float factor2)
    {
      float w = color.x+color.y+color.z;
      return mix(color,vec3(w)*factor,w*factor2);
    }    

    float rnd(vec2 p)
    {
      float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));
      return f;   
    }

    float rnd(float w)
    {
      float f = fract(sin(w)*1000.);
      return f;   
    }

    float regShape(vec2 p, int N)
    {
      float f;
      
      float a=atan(p.x,p.y)+.2;
      float b=6.28319/float(N);
      f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy)* 2.0  -ghostScale);
          
      return f;
    }

    // Based on https://www.shadertoy.com/view/Xlc3D2
    vec3 circle(vec2 p, float size, float decay, vec3 color, vec3 color2, float dist, vec2 position)
    {
      float l = length(p + position*(dist*2.))+size/2.;
      float l2 = length(p + position*(dist*4.))+size/3.;
      
      float c = max(0.01-pow(length(p + position*dist), size*ghostScale), 0.0)*10.;
      float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*20.), 0.0)*3.;
      float c2 =  max(0.09/pow(length(p-position*dist/.5)*1., .95), 0.0)/20.;
      float s = max(0.02-pow(regShape(p*5. + position*dist*5. + decay, 6) , 1.), 0.0)*1.5;
      
      color = cos(vec3(0.44, .24, .2)*16. + dist/8.)*0.5+.5;
      vec3 f = c*color;
      f += c1*color;
      f += c2*color;  
      f +=  s*color;
      return f;
    }

    vec4 getLensColor(float x){
      return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(0., 0., 0.),
        vec3(0., 0., 0.), smoothstep(0.0, 0.063, x)),
        vec3(0., 0., 0.), smoothstep(0.063, 0.125, x)),
        vec3(0.0, 0., 0.), smoothstep(0.125, 0.188, x)),
        vec3(0.188, 0.131, 0.116), smoothstep(0.188, 0.227, x)),
        vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),
        vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),
        vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),
        vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),
        vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),
        vec3(.1, 0.1, 0.1), smoothstep(0.604, 0.643, x)),
        vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),
        vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),
        vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),
        vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),
        vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),
      1.0);
    }

    float dirtNoise(vec2 p){
      vec2 f = fract(p);
      f = (f * f) * (3.0 - (2.0 * f));    
      float n = dot(floor(p), vec2(1.0, 157.0));
      vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);
      return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);
    } 

    float fbm(vec2 p){
      const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);
      float f = 0.0;
      f += 0.5000*dirtNoise(p); p = m*p*2.02;
      f += 0.2500*dirtNoise(p); p = m*p*2.03;
      f += 0.1250*dirtNoise(p); p = m*p*2.01;
      f += 0.0625*dirtNoise(p);
      return f/0.9375;
    }

    vec4 getLensStar(vec2 p){
      vec2 pp = (p - vec2(0.5)) * 2.0;
      float a = atan(pp.y, pp.x);
      vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));
      float d = sin(clamp(pow(length(vec2(0.5) - p) * 0.5 + haloScale /2., 5.0), 0.0, 1.0) * 3.14159);
      vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 10.6));
      c *= vec3(mix(2.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 1.5) + 0.5) * 0.3275;
      return vec4(vec3(c * 1.0), d);	
    }

    vec4 getLensDirt(vec2 p){
      p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 2.0)) * 0.0825;
      vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.1, 0.0, length(p - vec2(0.25))),
                                            smoothstep(0.4, 0.0, length(p - vec2(0.75)))),
                                            smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.125))))));
      o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;
      o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;
      o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;
      o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;
      o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;
      o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;
      return vec4(clamp(o, vec3(0.15), vec3(1.0)), 1.0);	
    }

    vec4 textureLimited(sampler2D tex, vec2 texCoord){
      if(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){
        return vec4(0.0);
      }else{
        return texture(tex, texCoord); 
      }
    }

    vec4 textureDistorted(sampler2D tex, vec2 texCoord, vec2 direction, vec3 distortion) {
      return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,
                  textureLimited(tex, (texCoord + (direction * distortion.g))).g,
                  textureLimited(tex, (texCoord + (direction * distortion.b))).b,
                  1.0);
    }

    // Based on https://www.shadertoy.com/view/4sK3W3
    vec4 getStartBurst(){
      vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0)) + vec2(0.5)); 
      vec2 texCoord = vec2(1.0) - vTexCoord; 
      vec2 ghostVec = (vec2(0.5) - texCoord) * 0.3 - lensPosition;
      vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0)) * vec2(1.0);
      vec2 haloVec = normalize(ghostVec) * 0.6;
      vec2 haloVecAspectNormalized = ghostVecAspectNormalized * 0.6;
      vec2 texelSize = vec2(1.0) / vec2(screenRes.xy);
      vec3 distortion = vec3(-(texelSize.x * 1.5), 0.2, texelSize.x * 1.5);
      vec4 c = vec4(0.0);
      for (int i = 0; i < 8; i++) {
        vec2 offset = texCoord + (ghostVec * float(i));
        c += textureDistorted(lensDirtTexture, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);
      }                       
      vec2 haloOffset = texCoord + haloVecAspectNormalized; 
      return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(haloScale))))) + 
            (textureDistorted(lensDirtTexture, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));
    } 

    void mainImage(vec4 inputColor, vec2 uv, out vec4 outputColor)
    {
      vec2 myUV = uv -0.5;
      myUV.y *= screenRes.y/screenRes.x;
      vec2 finalLensPosition = lensPosition * 0.5;
      finalLensPosition.y *= screenRes.y/screenRes.x;
      
      //First Lens flare pass
      vec3 finalColor = LensFlare(myUV, finalLensPosition) * 20.0 * colorGain / 256.;

      //Aditional streaks
      if(aditionalStreaks){
        vec3 circColor = vec3(0.9, 0.2, 0.1);
        vec3 circColor2 = vec3(0.3, 0.1, 0.9);

        for(float i=0.;i<10.;i++){
          finalColor += circle(myUV, pow(rnd(i*2000.)*2.8, .1)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, lensPosition);
        }
      }

      //Alternative ghosts
      if(secondaryGhosts){
        vec3 altGhosts = vec3(0);
        altGhosts += renderhex(myUV, -lensPosition*0.25, ghostScale * 1.4, vec3(0.25,0.35,0));
        altGhosts += renderhex(myUV, lensPosition*0.25, ghostScale * 0.5, vec3(1,0.5,0.5));
        altGhosts += renderhex(myUV, lensPosition*0.1, ghostScale * 1.6, vec3(1,1,1));
        altGhosts += renderhex(myUV, lensPosition*1.8, ghostScale * 2.0, vec3(0,0.5,0.75));
        altGhosts += renderhex(myUV, lensPosition*1.25, ghostScale * 0.8, vec3(1,1,0.5));
        altGhosts += renderhex(myUV, -lensPosition*1.25, ghostScale * 5.0, vec3(0.5,0.5,0.25));
        
        //Circular ghosts
        altGhosts += fpow(1.0 - abs(distance(lensPosition*0.8,myUV) - 0.7),0.985)*colorGain / 2100.;
        finalColor += altGhosts;
      }
      

      //Starburst                     
      if(starBurst){
        vTexCoord = myUV + 0.5;
        vec4 lensMod = getLensDirt(myUV);
        float tooBright = 1.0 - (clamp(0.5, 0.0, 0.5) * 2.0); 
        float tooDark = clamp(0.5 - 0.5, 0.0, 0.5) * 2.0;
        lensMod += mix(lensMod, pow(lensMod * 2.0, vec4(2.0)) * 0.5, tooBright);
        float lensStarRotationAngle = ((myUV.x + myUV.y)) * (1.0 / 6.0);
        vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * vTexCoord);
        lensMod += getLensStar(lensStarTexCoord) * 2.;
        
        finalColor += clamp((lensMod.rgb * getStartBurst().rgb ), 0.01, 1.0);
      }

      //Final composed output
      if(enabled){
        outputColor = vec4(mix(finalColor, vec3(.0), opacity) + inputColor.rgb, inputColor.a);
      } else {
        outputColor = vec4(inputColor);
      }
    }
  `
                };
                var fG = class extends Vi {
                    constructor({blendFunction: e, enabled: t, glareSize: n, lensPosition: i, screenRes: s, starPoints: a, flareSize: o, flareSpeed: c, flareShape: u, animated: f, anamorphic: m, colorGain: v, lensDirtTexture: y, haloScale: S, secondaryGhosts: A, aditionalStreaks: M, ghostScale: x, opacity: T, starBurst: D}) {
                        super("LensFlareEffect", hG.fragmentShader, {
                            blendFunction: e,
                            uniforms: new Map([["enabled", new ke(t)], ["glareSize", new ke(n)], ["lensPosition", new ke(i)], ["time", new ke(0)], ["screenRes", new ke(s)], ["starPoints", new ke(a)], ["flareSize", new ke(o)], ["flareSpeed", new ke(c)], ["flareShape", new ke(u)], ["animated", new ke(f)], ["anamorphic", new ke(m)], ["colorGain", new ke(v)], ["lensDirtTexture", new ke(y)], ["haloScale", new ke(S)], ["secondaryGhosts", new ke(A)], ["aditionalStreaks", new ke(M)], ["ghostScale", new ke(x)], ["starBurst", new ke(D)], ["opacity", new ke(T)]])
                        })
                    }
                    update(e, t, n) {
                        const i = this.uniforms.get("time");
                        i && (i.value += n)
                    }
                }
                ;
                const dG = Jr(fG)
                  , sW = ({smoothTime: e=.07, blendFunction: t=23, enabled: n=!0, glareSize: i=.2, lensPosition: s=new ae(-25,6,-60), screenRes: a=new Oe(0,0), starPoints: o=6, flareSize: c=.01, flareSpeed: u=.01, flareShape: f=.01, animated: m=!0, anamorphic: v=!1, colorGain: y=new ft(20,20,20), lensDirtTexture: S=null, haloScale: A=.5, secondaryGhosts: M=!0, aditionalStreaks: x=!0, ghostScale: T=0, opacity: D=1, starBurst: w=!1}) => {
                    const U = Ro( ({viewport: G}) => G)
                      , O = Ro( ({raycaster: G}) => G)
                      , {scene: L, camera: N} = (0,
                    We.useContext)(Sh)
                      , [z] = (0,
                    We.useState)( () => new Oe)
                      , [I] = (0,
                    We.useState)( () => new ae)
                      , B = (0,
                    We.useRef)(null);
                    return kf( (G, X) => {
                        if (!B?.current)
                            return;
                        const q = B.current.uniforms.get("lensPosition")
                          , Q = B.current.uniforms.get("opacity");
                        if (!q || !Q)
                            return;
                        let oe = 1;
                        if (I.copy(s).project(N),
                        I.z > 1)
                            return;
                        q.value.x = I.x,
                        q.value.y = I.y,
                        z.x = I.x,
                        z.y = I.y,
                        O.setFromCamera(z, N);
                        const k = O.intersectObjects(L.children, !0)
                          , {object: W} = k[0] || {};
                        W && (W.userData?.lensflare === "no-occlusion" ? oe = 0 : W instanceof oi && (W.material.uniforms?._transmission?.value > .2 || W.material._transmission && W.material._transmission > .2 ? oe = .2 : W.material.transparent && (oe = W.material.opacity))),
                        KD.damp(Q, "value", oe, e, X)
                    }
                    ),
                    (0,
                    We.useEffect)( () => {
                        if (!B?.current)
                            return;
                        const G = B.current.uniforms.get("screenRes");
                        G && (G.value.x = U.width,
                        G.value.y = U.height)
                    }
                    , [U]),
                    (0,
                    vt.jsx)(dG, {
                        ref: B,
                        blendFunction: t,
                        enabled: n,
                        glareSize: i,
                        lensPosition: s,
                        screenRes: a,
                        starPoints: o,
                        flareSize: c,
                        flareSpeed: u,
                        flareShape: f,
                        animated: m,
                        anamorphic: v,
                        colorGain: y,
                        lensDirtTexture: S,
                        haloScale: A,
                        secondaryGhosts: M,
                        aditionalStreaks: x,
                        ghostScale: T,
                        opacity: D,
                        starBurst: w
                    })
                }
                  , pG = Jr(aD, {
                    blendFunction: 0
                })
                  , aW = Jr(o5)
                  , mG = Jr(p5)
                  , rW = (0,
                We.forwardRef)(function({blendFunction: e=23}, t) {
                    const n = (0,
                    We.useMemo)( () => new c5(e), [e]);
                    return (0,
                    vt.jsx)("primitive", {
                        ref: t,
                        object: n,
                        dispose: null
                    })
                })
                  , oW = Jr(h5)
                  , lW = Jr(v5)
                  , cW = Jr(b5)
                  , uW = (0,
                We.forwardRef)(function({active: e=!0, ...t}, n) {
                    const i = Ro(f => f.invalidate)
                      , s = VS(t, "delay")
                      , a = VS(t, "duration")
                      , o = VS(t, "strength")
                      , c = VS(t, "chromaticAberrationOffset")
                      , u = (0,
                    We.useMemo)( () => new U5({
                        ...t,
                        delay: s,
                        duration: a,
                        strength: o,
                        chromaticAberrationOffset: c
                    }), [s, a, t, o, c]);
                    return (0,
                    We.useLayoutEffect)( () => {
                        u.mode = e ? t.mode || qf.SPORADIC : qf.DISABLED,
                        i()
                    }
                    , [e, u, i, t.mode]),
                    (0,
                    We.useEffect)( () => () => {
                        u.dispose?.()
                    }
                    , [u]),
                    (0,
                    vt.jsx)("primitive", {
                        ref: n,
                        object: u,
                        dispose: null
                    })
                })
                  , hW = (0,
                We.forwardRef)(function(e, t) {
                    const {camera: n} = (0,
                    We.useContext)(Sh)
                      , i = (0,
                    We.useMemo)( () => new I5(n,xh(e.sun),e), [n, e]);
                    return (0,
                    We.useLayoutEffect)( () => void (i.lightSource = xh(e.sun)), [i, e.sun]),
                    (0,
                    vt.jsx)("primitive", {
                        ref: t,
                        object: i,
                        dispose: null
                    })
                })
                  , fW = (0,
                We.forwardRef)(function({size: e, ...t}, n) {
                    const i = Ro(a => a.invalidate)
                      , s = (0,
                    We.useMemo)( () => new z5(t), [t]);
                    return (0,
                    We.useLayoutEffect)( () => {
                        e && s.setSize(e.width, e.height),
                        i()
                    }
                    , [s, e, i]),
                    (0,
                    vt.jsx)("primitive", {
                        ref: n,
                        object: s,
                        dispose: null
                    })
                })
                  , dW = Jr(H5)
                  , pW = Jr(k5, {
                    blendFunction: 5
                })
                  , mW = (0,
                We.forwardRef)(function({selection: e=[], selectionLayer: t=10, blendFunction: n, patternTexture: i, edgeStrength: s, pulseSpeed: a, visibleEdgeColor: o, hiddenEdgeColor: c, width: u, height: f, kernelSize: m, blur: v, xRay: y, ...S}, A) {
                    const M = Ro(U => U.invalidate)
                      , {scene: x, camera: T} = (0,
                    We.useContext)(Sh)
                      , D = (0,
                    We.useMemo)( () => new J5(x,T,{
                        blendFunction: n,
                        patternTexture: i,
                        edgeStrength: s,
                        pulseSpeed: a,
                        visibleEdgeColor: o,
                        hiddenEdgeColor: c,
                        width: u,
                        height: f,
                        kernelSize: m,
                        blur: v,
                        xRay: y,
                        ...S
                    }), [n, v, T, s, f, c, m, i, a, x, o, u, y])
                      , w = (0,
                    We.useContext)(JD);
                    return (0,
                    We.useEffect)( () => {
                        if (!w && e)
                            return D.selection.set(Array.isArray(e) ? e.map(xh) : [xh(e)]),
                            M(),
                            () => {
                                D.selection.clear(),
                                M()
                            }
                    }
                    , [D, e, w, M]),
                    (0,
                    We.useEffect)( () => {
                        D.selectionLayer = t,
                        M()
                    }
                    , [D, M, t]),
                    (0,
                    We.useRef)(void 0),
                    (0,
                    We.useEffect)( () => {
                        if (w && w.enabled && w.selected?.length)
                            return D.selection.set(w.selected),
                            M(),
                            () => {
                                D.selection.clear(),
                                M()
                            }
                    }
                    , [w, D.selection, M]),
                    (0,
                    We.useEffect)( () => () => {
                        D.dispose()
                    }
                    , [D]),
                    (0,
                    vt.jsx)("primitive", {
                        ref: A,
                        object: D
                    })
                })
                  , vW = (0,
                We.forwardRef)(function({granularity: e=5}, t) {
                    const n = (0,
                    We.useMemo)( () => new eH(e), [e]);
                    return (0,
                    vt.jsx)("primitive", {
                        ref: t,
                        object: n,
                        dispose: null
                    })
                })
                  , vG = Jr(nH, {
                    blendFunction: 24,
                    density: 1.25
                })
                  , gG = (e, t) => e.layers.enable(t.selection.layer)
                  , yG = (e, t) => e.layers.disable(t.selection.layer)
                  , gW = (0,
                We.forwardRef)(function({selection: e=[], selectionLayer: t=10, lights: n=[], inverted: i=!1, ignoreBackground: s=!1, luminanceThreshold: a, luminanceSmoothing: o, intensity: c, width: u, height: f, kernelSize: m, mipmapBlur: v, ...y}, S) {
                    n.length === 0 && console.warn("SelectiveBloom requires lights to work.");
                    const A = Ro(w => w.invalidate)
                      , {scene: M, camera: x} = (0,
                    We.useContext)(Sh)
                      , T = (0,
                    We.useMemo)( () => {
                        const w = new iH(M,x,{
                            blendFunction: 0,
                            luminanceThreshold: a,
                            luminanceSmoothing: o,
                            intensity: c,
                            width: u,
                            height: f,
                            kernelSize: m,
                            mipmapBlur: v,
                            ...y
                        });
                        return w.inverted = i,
                        w.ignoreBackground = s,
                        w
                    }
                    , [M, x, a, o, c, u, f, m, v, i, s, y])
                      , D = (0,
                    We.useContext)(JD);
                    return (0,
                    We.useEffect)( () => {
                        if (!D && e)
                            return T.selection.set(Array.isArray(e) ? e.map(xh) : [xh(e)]),
                            A(),
                            () => {
                                T.selection.clear(),
                                A()
                            }
                    }
                    , [T, e, D, A]),
                    (0,
                    We.useEffect)( () => {
                        T.selection.layer = t,
                        A()
                    }
                    , [T, A, t]),
                    (0,
                    We.useEffect)( () => {
                        if (n && n.length > 0)
                            return n.forEach(w => gG(xh(w), T)),
                            A(),
                            () => {
                                n.forEach(w => yG(xh(w), T)),
                                A()
                            }
                    }
                    , [T, A, n, t]),
                    (0,
                    We.useEffect)( () => {
                        if (D && D.enabled && D.selected?.length)
                            return T.selection.set(D.selected),
                            A(),
                            () => {
                                T.selection.clear(),
                                A()
                            }
                    }
                    , [D, T.selection, A]),
                    (0,
                    vt.jsx)("primitive", {
                        ref: S,
                        object: T,
                        dispose: null
                    })
                })
                  , yW = Jr(aH)
                  , _W = (0,
                We.forwardRef)(function(e, t) {
                    const {camera: n, normalPass: i, downSamplingPass: s, resolutionScale: a} = (0,
                    We.useContext)(Sh)
                      , o = (0,
                    We.useMemo)( () => i === null && s === null ? (console.error("Please enable the NormalPass in the EffectComposer in order to use SSAO."),
                    {}) : new AH(n,i && !s ? i.texture : null,{
                        blendFunction: 21,
                        samples: 30,
                        rings: 4,
                        distanceThreshold: 1,
                        distanceFalloff: 0,
                        rangeThreshold: .5,
                        rangeFalloff: .1,
                        luminanceInfluence: .9,
                        radius: 20,
                        bias: .5,
                        intensity: 1,
                        color: void 0,
                        normalDepthBuffer: s ? s.texture : null,
                        resolutionScale: a ?? 1,
                        depthAwareUpsampling: !0,
                        ...e
                    }), [n, s, i, a]);
                    return (0,
                    vt.jsx)("primitive", {
                        ref: t,
                        object: o,
                        dispose: null
                    })
                })
                  , SW = Jr(pH)
                  , xW = Jr(w5)
                  , AW = {
                    fragmentShader: `
    uniform int rampType;

    uniform vec2 rampStart;
    uniform vec2 rampEnd;

    uniform vec4 startColor;
    uniform vec4 endColor;

    uniform float rampBias;
    uniform float rampGain;

    uniform bool rampMask;
    uniform bool rampInvert;

    float getBias(float time, float bias) {
      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);
    }

    float getGain(float time, float gain) {
      if (time < 0.5)
        return getBias(time * 2.0, gain) / 2.0;
      else
        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;
    }

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
      vec2 centerPixel = uv * resolution;
      vec2 startPixel = rampStart * resolution;
      vec2 endPixel = rampEnd * resolution;

      float rampAlpha;

      if (rampType == 1) {
        vec2 fuv = centerPixel / resolution.y;
        vec2 suv = startPixel / resolution.y;
        vec2 euv = endPixel / resolution.y;

        float radius = length(suv - euv);
        float falloff = length(fuv - suv);
        rampAlpha = smoothstep(0.0, radius, falloff);
      } else {
        float radius = length(startPixel - endPixel);
        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));

        float fade = dot(centerPixel - startPixel, direction);
        if (rampType == 2) fade = abs(fade);

        rampAlpha = smoothstep(0.0, 1.0, fade / radius);
      }

      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));

      if (rampMask) {
        vec4 inputBuff = texture2D(inputBuffer, uv);
        outputColor = mix(inputBuff, inputColor, rampAlpha);
      } else {
        outputColor = mix(startColor, endColor, rampAlpha);
      }
    }
  `
                }
                  , LM = "15.1.22";
                var _G = un({
                    "node_modules/@babel/runtime/helpers/arrayWithHoles.js": ( (e, t) => {
                        function n(i) {
                            if (Array.isArray(i))
                                return i
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , SG = un({
                    "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js": ( (e, t) => {
                        function n(i, s) {
                            var a = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
                            if (a != null) {
                                var o, c, u, f, m = [], v = !0, y = !1;
                                try {
                                    if (u = (a = a.call(i)).next,
                                    s === 0) {
                                        if (Object(a) !== a)
                                            return;
                                        v = !1
                                    } else
                                        for (; !(v = (o = u.call(a)).done) && (m.push(o.value),
                                        m.length !== s); v = !0)
                                            ;
                                } catch (S) {
                                    y = !0,
                                    c = S
                                } finally {
                                    try {
                                        if (!v && a.return != null && (f = a.return(),
                                        Object(f) !== f))
                                            return
                                    } finally {
                                        if (y)
                                            throw c
                                    }
                                }
                                return m
                            }
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , xG = un({
                    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js": ( (e, t) => {
                        function n(i, s) {
                            (s == null || s > i.length) && (s = i.length);
                            for (var a = 0, o = Array(s); a < s; a++)
                                o[a] = i[a];
                            return o
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , AG = un({
                    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js": ( (e, t) => {
                        var n = xG();
                        function i(s, a) {
                            if (s) {
                                if (typeof s == "string")
                                    return n(s, a);
                                var o = {}.toString.call(s).slice(8, -1);
                                return o === "Object" && s.constructor && (o = s.constructor.name),
                                o === "Map" || o === "Set" ? Array.from(s) : o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? n(s, a) : void 0
                            }
                        }
                        t.exports = i,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , TG = un({
                    "node_modules/@babel/runtime/helpers/nonIterableRest.js": ( (e, t) => {
                        function n() {
                            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , MG = un({
                    "node_modules/@babel/runtime/helpers/slicedToArray.js": ( (e, t) => {
                        var n = _G()
                          , i = SG()
                          , s = AG()
                          , a = TG();
                        function o(c, u) {
                            return n(c) || i(c, u) || s(c, u) || a()
                        }
                        t.exports = o,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , bG = un({
                    "node_modules/@babel/runtime/helpers/classCallCheck.js": ( (e, t) => {
                        function n(i, s) {
                            if (!(i instanceof s))
                                throw new TypeError("Cannot call a class as a function")
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , tR = un({
                    "node_modules/@babel/runtime/helpers/typeof.js": ( (e, t) => {
                        function n(i) {
                            "@babel/helpers - typeof";
                            return t.exports = n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
                                return typeof s
                            }
                            : function(s) {
                                return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s
                            }
                            ,
                            t.exports.__esModule = !0,
                            t.exports.default = t.exports,
                            n(i)
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , EG = un({
                    "node_modules/@babel/runtime/helpers/toPrimitive.js": ( (e, t) => {
                        var n = tR().default;
                        function i(s, a) {
                            if (n(s) != "object" || !s)
                                return s;
                            var o = s[Symbol.toPrimitive];
                            if (o !== void 0) {
                                var c = o.call(s, a || "default");
                                if (n(c) != "object")
                                    return c;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }
                            return (a === "string" ? String : Number)(s)
                        }
                        t.exports = i,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , CG = un({
                    "node_modules/@babel/runtime/helpers/toPropertyKey.js": ( (e, t) => {
                        var n = tR().default
                          , i = EG();
                        function s(a) {
                            var o = i(a, "string");
                            return n(o) == "symbol" ? o : o + ""
                        }
                        t.exports = s,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , wG = un({
                    "node_modules/@babel/runtime/helpers/createClass.js": ( (e, t) => {
                        var n = CG();
                        function i(a, o) {
                            for (var c = 0; c < o.length; c++) {
                                var u = o[c];
                                u.enumerable = u.enumerable || !1,
                                u.configurable = !0,
                                "value"in u && (u.writable = !0),
                                Object.defineProperty(a, n(u.key), u)
                            }
                        }
                        function s(a, o, c) {
                            return o && i(a.prototype, o),
                            c && i(a, c),
                            Object.defineProperty(a, "prototype", {
                                writable: !1
                            }),
                            a
                        }
                        t.exports = s,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , nR = un({
                    "node_modules/automation-events/build/es5/bundle.js": ( (e, t) => {
                        (function(n, i) {
                            typeof e == "object" && typeof t < "u" ? i(e, MG(), bG(), wG()) : typeof define == "function" && define.amd ? define(["exports", "@babel/runtime/helpers/slicedToArray", "@babel/runtime/helpers/classCallCheck", "@babel/runtime/helpers/createClass"], i) : (n = typeof globalThis < "u" ? globalThis : n || self,
                            i(n.automationEvents = {}, n._slicedToArray, n._classCallCheck, n._createClass))
                        }
                        )(e, (function(n, i, s, a) {
                            var o = function(W, V, Z) {
                                return {
                                    endTime: V,
                                    insertTime: Z,
                                    type: "exponentialRampToValue",
                                    value: W
                                }
                            }
                              , c = function(W, V, Z) {
                                return {
                                    endTime: V,
                                    insertTime: Z,
                                    type: "linearRampToValue",
                                    value: W
                                }
                            }
                              , u = function(W, V) {
                                return {
                                    startTime: V,
                                    type: "setValue",
                                    value: W
                                }
                            }
                              , f = function(W, V, Z) {
                                return {
                                    duration: Z,
                                    startTime: V,
                                    type: "setValueCurve",
                                    values: W
                                }
                            }
                              , m = function(W, V, Z) {
                                var j = Z.startTime
                                  , ee = Z.target
                                  , H = Z.timeConstant;
                                return ee + (V - ee) * Math.exp((j - W) / H)
                            }
                              , v = function(W) {
                                return W.type === "exponentialRampToValue"
                            }
                              , y = function(W) {
                                return W.type === "linearRampToValue"
                            }
                              , S = function(W) {
                                return v(W) || y(W)
                            }
                              , A = function(W) {
                                return W.type === "setValue"
                            }
                              , M = function(W) {
                                return W.type === "setValueCurve"
                            }
                              , x = function(W, V, Z, j) {
                                var ee = W[V];
                                return ee === void 0 ? j : S(ee) || A(ee) ? ee.value : M(ee) ? ee.values[ee.values.length - 1] : m(Z, x(W, V - 1, ee.startTime, j), ee)
                            }
                              , T = function(W, V, Z, j, ee) {
                                return Z === void 0 ? [j.insertTime, ee] : S(Z) ? [Z.endTime, Z.value] : A(Z) ? [Z.startTime, Z.value] : M(Z) ? [Z.startTime + Z.duration, Z.values[Z.values.length - 1]] : [Z.startTime, x(W, V - 1, Z.startTime, ee)]
                            }
                              , D = function(W) {
                                return W.type === "cancelAndHold"
                            }
                              , w = function(W) {
                                return W.type === "cancelScheduledValues"
                            }
                              , U = function(W) {
                                return D(W) || w(W) ? W.cancelTime : v(W) || y(W) ? W.endTime : W.startTime
                            }
                              , O = function(W, V, Z, j) {
                                var ee = j.endTime
                                  , H = j.value;
                                return Z === H ? H : 0 < Z && 0 < H || Z < 0 && H < 0 ? Z * Math.pow(H / Z, (W - V) / (ee - V)) : 0
                            }
                              , L = function(W, V, Z, j) {
                                var ee = j.endTime
                                  , H = j.value;
                                return Z + (W - V) / (ee - V) * (H - Z)
                            }
                              , N = function(W, V) {
                                var Z = Math.floor(V)
                                  , j = Math.ceil(V);
                                return Z === j ? W[Z] : (1 - (V - Z)) * W[Z] + (1 - (j - V)) * W[j]
                            }
                              , z = function(W, V) {
                                var Z = V.duration
                                  , j = V.startTime
                                  , ee = V.values
                                  , H = (W - j) / Z * (ee.length - 1);
                                return N(ee, H)
                            }
                              , I = function(W) {
                                return W.type === "setTarget"
                            }
                              , B = (function() {
                                function k(W) {
                                    s(this, k),
                                    this._automationEvents = [],
                                    this._currenTime = 0,
                                    this._defaultValue = W
                                }
                                return a(k, [{
                                    key: Symbol.iterator,
                                    value: function() {
                                        return this._automationEvents[Symbol.iterator]()
                                    }
                                }, {
                                    key: "add",
                                    value: function(V) {
                                        var Z = U(V);
                                        if (D(V) || w(V)) {
                                            var j = this._automationEvents.findIndex(function(ge) {
                                                return w(V) && M(ge) ? ge.startTime + ge.duration >= Z : U(ge) >= Z
                                            })
                                              , ee = this._automationEvents[j];
                                            if (j !== -1 && (this._automationEvents = this._automationEvents.slice(0, j)),
                                            D(V)) {
                                                var H = this._automationEvents[this._automationEvents.length - 1];
                                                if (ee !== void 0 && S(ee)) {
                                                    if (H !== void 0 && I(H))
                                                        throw new Error("The internal list is malformed.");
                                                    var ie = H === void 0 ? ee.insertTime : M(H) ? H.startTime + H.duration : U(H)
                                                      , se = H === void 0 ? this._defaultValue : M(H) ? H.values[H.values.length - 1] : H.value
                                                      , K = v(ee) ? O(Z, ie, se, ee) : L(Z, ie, se, ee)
                                                      , le = v(ee) ? o(K, Z, this._currenTime) : c(K, Z, this._currenTime);
                                                    this._automationEvents.push(le)
                                                }
                                                if (H !== void 0 && I(H) && this._automationEvents.push(u(this.getValue(Z), Z)),
                                                H !== void 0 && M(H) && H.startTime + H.duration > Z) {
                                                    var ue = Z - H.startTime
                                                      , de = (H.values.length - 1) / H.duration
                                                      , qe = Math.max(2, 1 + Math.ceil(ue * de))
                                                      , ze = ue / (qe - 1) * de
                                                      , Ee = H.values.slice(0, qe);
                                                    if (ze < 1)
                                                        for (var re = 1; re < qe; re += 1) {
                                                            var Le = ze * re % 1;
                                                            Ee[re] = H.values[re - 1] * (1 - Le) + H.values[re] * Le
                                                        }
                                                    this._automationEvents[this._automationEvents.length - 1] = f(Ee, H.startTime, ue)
                                                }
                                            }
                                        } else {
                                            var he = this._automationEvents.findIndex(function(ge) {
                                                return U(ge) > Z
                                            })
                                              , ye = he === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[he - 1];
                                            if (ye !== void 0 && M(ye) && U(ye) + ye.duration > Z)
                                                return !1;
                                            var xe = v(V) ? o(V.value, V.endTime, this._currenTime) : y(V) ? c(V.value, Z, this._currenTime) : V;
                                            if (he === -1)
                                                this._automationEvents.push(xe);
                                            else {
                                                if (M(V) && Z + V.duration > U(this._automationEvents[he]))
                                                    return !1;
                                                this._automationEvents.splice(he, 0, xe)
                                            }
                                        }
                                        return !0
                                    }
                                }, {
                                    key: "flush",
                                    value: function(V) {
                                        var Z = this._automationEvents.findIndex(function(H) {
                                            return U(H) > V
                                        });
                                        if (Z > 1) {
                                            var j = this._automationEvents.slice(Z - 1)
                                              , ee = j[0];
                                            I(ee) && j.unshift(u(x(this._automationEvents, Z - 2, ee.startTime, this._defaultValue), ee.startTime)),
                                            this._automationEvents = j
                                        }
                                    }
                                }, {
                                    key: "getValue",
                                    value: function(V) {
                                        if (this._automationEvents.length === 0)
                                            return this._defaultValue;
                                        var Z = this._automationEvents.findIndex(function(Ee) {
                                            return U(Ee) > V
                                        })
                                          , j = this._automationEvents[Z]
                                          , ee = (Z === -1 ? this._automationEvents.length : Z) - 1
                                          , H = this._automationEvents[ee];
                                        if (H !== void 0 && I(H) && (j === void 0 || !S(j) || j.insertTime > V))
                                            return m(V, x(this._automationEvents, ee - 1, H.startTime, this._defaultValue), H);
                                        if (H !== void 0 && A(H) && (j === void 0 || !S(j)))
                                            return H.value;
                                        if (H !== void 0 && M(H) && (j === void 0 || !S(j) || H.startTime + H.duration > V))
                                            return V < H.startTime + H.duration ? z(V, H) : H.values[H.values.length - 1];
                                        if (H !== void 0 && S(H) && (j === void 0 || !S(j)))
                                            return H.value;
                                        if (j !== void 0 && v(j)) {
                                            var ie = T(this._automationEvents, ee, H, j, this._defaultValue)
                                              , se = i(ie, 2)
                                              , K = se[0]
                                              , le = se[1];
                                            return O(V, K, le, j)
                                        }
                                        if (j !== void 0 && y(j)) {
                                            var ue = T(this._automationEvents, ee, H, j, this._defaultValue)
                                              , de = i(ue, 2)
                                              , qe = de[0]
                                              , ze = de[1];
                                            return L(V, qe, ze, j)
                                        }
                                        return this._defaultValue
                                    }
                                }])
                            }
                            )()
                              , G = function(W) {
                                return {
                                    cancelTime: W,
                                    type: "cancelAndHold"
                                }
                            }
                              , X = function(W) {
                                return {
                                    cancelTime: W,
                                    type: "cancelScheduledValues"
                                }
                            }
                              , q = function(W, V) {
                                return {
                                    endTime: V,
                                    type: "exponentialRampToValue",
                                    value: W
                                }
                            }
                              , Q = function(W, V) {
                                return {
                                    endTime: V,
                                    type: "linearRampToValue",
                                    value: W
                                }
                            }
                              , oe = function(W, V, Z) {
                                return {
                                    startTime: V,
                                    target: W,
                                    timeConstant: Z,
                                    type: "setTarget"
                                }
                            };
                            n.AutomationEventList = B,
                            n.createCancelAndHoldAutomationEvent = G,
                            n.createCancelScheduledValuesAutomationEvent = X,
                            n.createExponentialRampToValueAutomationEvent = q,
                            n.createLinearRampToValueAutomationEvent = Q,
                            n.createSetTargetAutomationEvent = oe,
                            n.createSetValueAutomationEvent = u,
                            n.createSetValueCurveAutomationEvent = f
                        }
                        ))
                    }
                    )
                })
                  , DG = _r(nR());
                const RG = () => new DOMException("","AbortError")
                  , UG = e => (t, n, [i,s,a], o) => {
                    e(t[s], [n, i, a], c => c[0] === n && c[1] === i, o)
                }
                  , OG = e => (t, n, i) => {
                    const s = [];
                    for (let a = 0; a < i.numberOfInputs; a += 1)
                        s.push(new Set);
                    e.set(t, {
                        activeInputs: s,
                        outputs: new Set,
                        passiveInputs: new WeakMap,
                        renderer: n
                    })
                }
                  , NG = e => (t, n) => {
                    e.set(t, {
                        activeInputs: new Set,
                        passiveInputs: new WeakMap,
                        renderer: n
                    })
                }
                  , um = new WeakSet
                  , iR = new WeakMap
                  , IM = new WeakMap
                  , sR = new WeakMap
                  , PM = new WeakMap
                  , kS = new WeakMap
                  , aR = new WeakMap
                  , zM = new WeakMap
                  , FM = new WeakMap
                  , HM = new WeakMap
                  , rR = {
                    construct() {
                        return rR
                    }
                }
                  , BG = e => {
                    try {
                        new new Proxy(e,rR)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , oR = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/
                  , lR = (e, t) => {
                    const n = [];
                    let i = e.replace(/^[\s]+/, "")
                      , s = i.match(oR);
                    for (; s !== null; ) {
                        const a = s[1].slice(1, -1)
                          , o = s[0].replace(/([\s]+)?;?$/, "").replace(a, new URL(a,t).toString());
                        n.push(o),
                        i = i.slice(s[0].length).replace(/^[\s]+/, ""),
                        s = i.match(oR)
                    }
                    return [n.join(";"), i]
                }
                  , cR = e => {
                    if (e !== void 0 && !Array.isArray(e))
                        throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")
                }
                  , uR = e => {
                    if (!BG(e))
                        throw new TypeError("The given value for processorCtor should be a constructor.");
                    if (e.prototype === null || typeof e.prototype != "object")
                        throw new TypeError("The given value for processorCtor should have a prototype.")
                }
                  , LG = (e, t, n, i, s, a, o, c, u, f, m, v, y) => {
                    let S = 0;
                    return (A, M, x={
                        credentials: "omit"
                    }) => {
                        const T = m.get(A);
                        if (T !== void 0 && T.has(M))
                            return Promise.resolve();
                        const D = f.get(A);
                        if (D !== void 0) {
                            const O = D.get(M);
                            if (O !== void 0)
                                return O
                        }
                        const w = a(A)
                          , U = w.audioWorklet === void 0 ? s(M).then( ([O,L]) => {
                            const [N,z] = lR(O, L)
                              , I = `${N};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${z}
})})(window,'_AWGS')`;
                            return n(I)
                        }
                        ).then( () => {
                            const O = y._AWGS.pop();
                            if (O === void 0)
                                throw new SyntaxError;
                            i(w.currentTime, w.sampleRate, () => O(class {
                            }
                            , void 0, (L, N) => {
                                if (L.trim() === "")
                                    throw t();
                                const z = FM.get(w);
                                if (z !== void 0) {
                                    if (z.has(L))
                                        throw t();
                                    uR(N),
                                    cR(N.parameterDescriptors),
                                    z.set(L, N)
                                } else
                                    uR(N),
                                    cR(N.parameterDescriptors),
                                    FM.set(w, new Map([[L, N]]))
                            }
                            , w.sampleRate, void 0, void 0))
                        }
                        ) : Promise.all([s(M), Promise.resolve(e(v, v))]).then( ([[O,L],N]) => {
                            const z = S + 1;
                            S = z;
                            const [I,B] = lR(O, L)
                              , G = `${I};((AudioWorkletProcessor,registerProcessor)=>{${B}
})(${N ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${N ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${N ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${z}',class extends AudioWorkletProcessor{process(){return !1}})`
                              , X = new Blob([G],{
                                type: "application/javascript; charset=utf-8"
                            })
                              , q = URL.createObjectURL(X);
                            return w.audioWorklet.addModule(q, x).then( () => {
                                if (c(w))
                                    return w;
                                const Q = o(w);
                                return Q.audioWorklet.addModule(q, x).then( () => Q)
                            }
                            ).then(Q => {
                                if (u === null)
                                    throw new SyntaxError;
                                try {
                                    new u(Q,`__sac${z}`)
                                } catch {
                                    throw new SyntaxError
                                }
                            }
                            ).finally( () => URL.revokeObjectURL(q))
                        }
                        );
                        return D === void 0 ? f.set(A, new Map([[M, U]])) : D.set(M, U),
                        U.then( () => {
                            const O = m.get(A);
                            O === void 0 ? m.set(A, new Set([M])) : O.add(M)
                        }
                        ).finally( () => {
                            const O = f.get(A);
                            O !== void 0 && O.delete(M)
                        }
                        ),
                        U
                    }
                }
                  , pl = (e, t) => {
                    const n = e.get(t);
                    if (n === void 0)
                        throw new Error("A value with the given key could not be found.");
                    return n
                }
                  , XS = (e, t) => {
                    const n = Array.from(e).filter(t);
                    if (n.length > 1)
                        throw Error("More than one element was found.");
                    if (n.length === 0)
                        throw Error("No element was found.");
                    const [i] = n;
                    return e.delete(i),
                    i
                }
                  , hR = (e, t, n, i) => {
                    const s = pl(e, t)
                      , a = XS(s, o => o[0] === n && o[1] === i);
                    return s.size === 0 && e.delete(t),
                    a
                }
                  , o0 = e => pl(aR, e)
                  , hm = e => {
                    if (um.has(e))
                        throw new Error("The AudioNode is already stored.");
                    um.add(e),
                    o0(e).forEach(t => t(!0))
                }
                  , fR = e => "port"in e
                  , l0 = e => {
                    if (!um.has(e))
                        throw new Error("The AudioNode is not stored.");
                    um.delete(e),
                    o0(e).forEach(t => t(!1))
                }
                  , GM = (e, t) => {
                    !fR(e) && t.every(n => n.size === 0) && l0(e)
                }
                  , IG = (e, t, n, i, s, a, o, c, u, f, m, v, y) => {
                    const S = new WeakMap;
                    return (A, M, x, T, D) => {
                        const {activeInputs: w, passiveInputs: U} = a(M)
                          , {outputs: O} = a(A)
                          , L = c(A)
                          , N = z => {
                            const I = u(M)
                              , B = u(A);
                            if (z) {
                                const G = hR(U, A, x, T);
                                e(w, A, G, !1),
                                !D && !v(A) && n(B, I, x, T),
                                y(M) && hm(M)
                            } else {
                                const G = i(w, A, x, T);
                                t(U, T, G, !1),
                                !D && !v(A) && s(B, I, x, T);
                                const X = o(M);
                                if (X === 0)
                                    m(M) && GM(M, w);
                                else {
                                    const q = S.get(M);
                                    q !== void 0 && clearTimeout(q),
                                    S.set(M, setTimeout( () => {
                                        m(M) && GM(M, w)
                                    }
                                    , X * 1e3))
                                }
                            }
                        }
                        ;
                        return f(O, [M, x, T], z => z[0] === M && z[1] === x && z[2] === T, !0) ? (L.add(N),
                        m(A) ? e(w, A, [x, T, N], !0) : t(U, T, [A, x, N], !0),
                        !0) : !1
                    }
                }
                  , PG = e => (t, n, [i,s,a], o) => {
                    const c = t.get(i);
                    c === void 0 ? t.set(i, new Set([[s, n, a]])) : e(c, [s, n, a], u => u[0] === s && u[1] === n, o)
                }
                  , zG = e => (t, n) => {
                    const i = e(t, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    n.connect(i).connect(t.destination);
                    const s = () => {
                        n.removeEventListener("ended", s),
                        n.disconnect(i),
                        i.disconnect()
                    }
                    ;
                    n.addEventListener("ended", s)
                }
                  , FG = e => (t, n) => {
                    e(t).add(n)
                }
                  , HG = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    fftSize: 2048,
                    maxDecibels: -30,
                    minDecibels: -100,
                    smoothingTimeConstant: .8
                }
                  , GG = (e, t, n, i, s, a) => class extends e {
                    constructor(c, u) {
                        const f = s(c)
                          , m = {
                            ...HG,
                            ...u
                        }
                          , v = i(f, m)
                          , y = a(f) ? t() : null;
                        super(c, !1, v, y),
                        this._nativeAnalyserNode = v
                    }
                    get fftSize() {
                        return this._nativeAnalyserNode.fftSize
                    }
                    set fftSize(c) {
                        this._nativeAnalyserNode.fftSize = c
                    }
                    get frequencyBinCount() {
                        return this._nativeAnalyserNode.frequencyBinCount
                    }
                    get maxDecibels() {
                        return this._nativeAnalyserNode.maxDecibels
                    }
                    set maxDecibels(c) {
                        const u = this._nativeAnalyserNode.maxDecibels;
                        if (this._nativeAnalyserNode.maxDecibels = c,
                        !(c > this._nativeAnalyserNode.minDecibels))
                            throw this._nativeAnalyserNode.maxDecibels = u,
                            n()
                    }
                    get minDecibels() {
                        return this._nativeAnalyserNode.minDecibels
                    }
                    set minDecibels(c) {
                        const u = this._nativeAnalyserNode.minDecibels;
                        if (this._nativeAnalyserNode.minDecibels = c,
                        !(this._nativeAnalyserNode.maxDecibels > c))
                            throw this._nativeAnalyserNode.minDecibels = u,
                            n()
                    }
                    get smoothingTimeConstant() {
                        return this._nativeAnalyserNode.smoothingTimeConstant
                    }
                    set smoothingTimeConstant(c) {
                        this._nativeAnalyserNode.smoothingTimeConstant = c
                    }
                    getByteFrequencyData(c) {
                        this._nativeAnalyserNode.getByteFrequencyData(c)
                    }
                    getByteTimeDomainData(c) {
                        this._nativeAnalyserNode.getByteTimeDomainData(c)
                    }
                    getFloatFrequencyData(c) {
                        this._nativeAnalyserNode.getFloatFrequencyData(c)
                    }
                    getFloatTimeDomainData(c) {
                        this._nativeAnalyserNode.getFloatTimeDomainData(c)
                    }
                }
                  , Ca = (e, t) => e.context === t
                  , VG = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (a, o) => {
                        let c = t(a);
                        if (!Ca(c, o)) {
                            const u = {
                                channelCount: c.channelCount,
                                channelCountMode: c.channelCountMode,
                                channelInterpretation: c.channelInterpretation,
                                fftSize: c.fftSize,
                                maxDecibels: c.maxDecibels,
                                minDecibels: c.minDecibels,
                                smoothingTimeConstant: c.smoothingTimeConstant
                            };
                            c = e(o, u)
                        }
                        return i.set(o, c),
                        await n(a, o, c),
                        c
                    }
                    ;
                    return {
                        render(a, o) {
                            const c = i.get(o);
                            return c !== void 0 ? Promise.resolve(c) : s(a, o)
                        }
                    }
                }
                  , WS = e => {
                    try {
                        e.copyToChannel(new Float32Array(1), 0, -1)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , hc = () => new DOMException("","IndexSizeError")
                  , VM = e => {
                    e.getChannelData = (t => n => {
                        try {
                            return t.call(e, n)
                        } catch (i) {
                            throw i.code === 12 ? hc() : i
                        }
                    }
                    )(e.getChannelData)
                }
                  , kG = {
                    numberOfChannels: 1
                }
                  , XG = (e, t, n, i, s, a, o, c) => {
                    let u = null;
                    return class HU {
                        constructor(m) {
                            if (s === null)
                                throw new Error("Missing the native OfflineAudioContext constructor.");
                            const {length: v, numberOfChannels: y, sampleRate: S} = {
                                ...kG,
                                ...m
                            };
                            u === null && (u = new s(1,1,44100));
                            const A = i !== null && t(a, a) ? new i({
                                length: v,
                                numberOfChannels: y,
                                sampleRate: S
                            }) : u.createBuffer(y, v, S);
                            if (A.numberOfChannels === 0)
                                throw n();
                            return typeof A.copyFromChannel != "function" ? (o(A),
                            VM(A)) : t(WS, () => WS(A)) || c(A),
                            e.add(A),
                            A
                        }
                        static[Symbol.hasInstance](m) {
                            return m !== null && typeof m == "object" && Object.getPrototypeOf(m) === HU.prototype || e.has(m)
                        }
                    }
                }
                  , Mr = -34028234663852886e22
                  , rr = -Mr
                  , uu = e => um.has(e)
                  , WG = {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }
                  , YG = (e, t, n, i, s, a, o, c) => class extends e {
                    constructor(f, m) {
                        const v = a(f)
                          , y = {
                            ...WG,
                            ...m
                        }
                          , S = s(v, y)
                          , A = o(v)
                          , M = A ? t() : null;
                        super(f, !1, S, M),
                        this._audioBufferSourceNodeRenderer = M,
                        this._isBufferNullified = !1,
                        this._isBufferSet = y.buffer !== null,
                        this._nativeAudioBufferSourceNode = S,
                        this._onended = null,
                        this._playbackRate = n(this, A, S.playbackRate, rr, Mr)
                    }
                    get buffer() {
                        return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer
                    }
                    set buffer(f) {
                        if (this._nativeAudioBufferSourceNode.buffer = f,
                        f !== null) {
                            if (this._isBufferSet)
                                throw i();
                            this._isBufferSet = !0
                        }
                    }
                    get loop() {
                        return this._nativeAudioBufferSourceNode.loop
                    }
                    set loop(f) {
                        this._nativeAudioBufferSourceNode.loop = f
                    }
                    get loopEnd() {
                        return this._nativeAudioBufferSourceNode.loopEnd
                    }
                    set loopEnd(f) {
                        this._nativeAudioBufferSourceNode.loopEnd = f
                    }
                    get loopStart() {
                        return this._nativeAudioBufferSourceNode.loopStart
                    }
                    set loopStart(f) {
                        this._nativeAudioBufferSourceNode.loopStart = f
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(f) {
                        const m = typeof f == "function" ? c(this, f) : null;
                        this._nativeAudioBufferSourceNode.onended = m;
                        const v = this._nativeAudioBufferSourceNode.onended;
                        this._onended = v !== null && v === m ? f : v
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    start(f=0, m=0, v) {
                        if (this._nativeAudioBufferSourceNode.start(f, m, v),
                        this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = v === void 0 ? [f, m] : [f, m, v]),
                        this.context.state !== "closed") {
                            hm(this);
                            const y = () => {
                                this._nativeAudioBufferSourceNode.removeEventListener("ended", y),
                                uu(this) && l0(this)
                            }
                            ;
                            this._nativeAudioBufferSourceNode.addEventListener("ended", y)
                        }
                    }
                    stop(f=0) {
                        this._nativeAudioBufferSourceNode.stop(f),
                        this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = f)
                    }
                }
                  , qG = (e, t, n, i, s) => () => {
                    const a = new WeakMap;
                    let o = null
                      , c = null;
                    const u = async (f, m) => {
                        let v = n(f);
                        const y = Ca(v, m);
                        if (!y) {
                            const S = {
                                buffer: v.buffer,
                                channelCount: v.channelCount,
                                channelCountMode: v.channelCountMode,
                                channelInterpretation: v.channelInterpretation,
                                loop: v.loop,
                                loopEnd: v.loopEnd,
                                loopStart: v.loopStart,
                                playbackRate: v.playbackRate.value
                            };
                            v = t(m, S),
                            o !== null && v.start(...o),
                            c !== null && v.stop(c)
                        }
                        return a.set(m, v),
                        y ? await e(m, f.playbackRate, v.playbackRate) : await i(m, f.playbackRate, v.playbackRate),
                        await s(f, m, v),
                        v
                    }
                    ;
                    return {
                        set start(f) {
                            o = f
                        },
                        set stop(f) {
                            c = f
                        },
                        render(f, m) {
                            const v = a.get(m);
                            return v !== void 0 ? Promise.resolve(v) : u(f, m)
                        }
                    }
                }
                  , jG = e => "playbackRate"in e
                  , QG = e => "frequency"in e && "gain"in e
                  , ZG = e => "offset"in e
                  , KG = e => !("frequency"in e) && "gain"in e
                  , JG = e => "detune"in e && "frequency"in e && !("gain"in e)
                  , $G = e => "pan"in e
                  , or = e => pl(iR, e)
                  , c0 = e => pl(sR, e)
                  , kM = (e, t) => {
                    const {activeInputs: n} = or(e);
                    n.forEach(s => s.forEach( ([a]) => {
                        t.includes(e) || kM(a, [...t, e])
                    }
                    ));
                    const i = jG(e) ? [e.playbackRate] : fR(e) ? Array.from(e.parameters.values()) : QG(e) ? [e.Q, e.detune, e.frequency, e.gain] : ZG(e) ? [e.offset] : KG(e) ? [e.gain] : JG(e) ? [e.detune, e.frequency] : $G(e) ? [e.pan] : [];
                    for (const s of i) {
                        const a = c0(s);
                        a !== void 0 && a.activeInputs.forEach( ([o]) => kM(o, t))
                    }
                    uu(e) && l0(e)
                }
                  , YS = e => {
                    kM(e.destination, [])
                }
                  , dR = e => e === void 0 || typeof e == "number" || typeof e == "string" && (e === "balanced" || e === "interactive" || e === "playback")
                  , e6 = (e, t, n, i, s, a, o, c, u) => class extends e {
                    constructor(m={}) {
                        if (u === null)
                            throw new Error("Missing the native AudioContext constructor.");
                        let v;
                        try {
                            v = new u(m)
                        } catch (A) {
                            throw A.code === 12 && A.message === "sampleRate is not in range" ? n() : A
                        }
                        if (v === null)
                            throw i();
                        if (!dR(m.latencyHint))
                            throw new TypeError(`The provided value '${m.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                        if (m.sampleRate !== void 0 && v.sampleRate !== m.sampleRate)
                            throw n();
                        super(v, 2);
                        const {latencyHint: y} = m
                          , {sampleRate: S} = v;
                        if (this._baseLatency = typeof v.baseLatency == "number" ? v.baseLatency : y === "balanced" ? 512 / S : y === "interactive" || y === void 0 ? 256 / S : y === "playback" ? 1024 / S : Math.max(2, Math.min(128, Math.round(y * S / 128))) * 128 / S,
                        this._nativeAudioContext = v,
                        u.name === "webkitAudioContext" ? (this._nativeGainNode = v.createGain(),
                        this._nativeOscillatorNode = v.createOscillator(),
                        this._nativeGainNode.gain.value = 1e-37,
                        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(v.destination),
                        this._nativeOscillatorNode.start()) : (this._nativeGainNode = null,
                        this._nativeOscillatorNode = null),
                        this._state = null,
                        v.state === "running") {
                            this._state = "suspended";
                            const A = () => {
                                this._state === "suspended" && (this._state = null),
                                v.removeEventListener("statechange", A)
                            }
                            ;
                            v.addEventListener("statechange", A)
                        }
                    }
                    get baseLatency() {
                        return this._baseLatency
                    }
                    get state() {
                        return this._state !== null ? this._state : this._nativeAudioContext.state
                    }
                    close() {
                        return this.state === "closed" ? this._nativeAudioContext.close().then( () => {
                            throw t()
                        }
                        ) : (this._state === "suspended" && (this._state = null),
                        this._nativeAudioContext.close().then( () => {
                            this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(),
                            this._nativeGainNode.disconnect(),
                            this._nativeOscillatorNode.disconnect()),
                            YS(this)
                        }
                        ))
                    }
                    createMediaElementSource(m) {
                        return new s(this,{
                            mediaElement: m
                        })
                    }
                    createMediaStreamDestination() {
                        return new a(this)
                    }
                    createMediaStreamSource(m) {
                        return new o(this,{
                            mediaStream: m
                        })
                    }
                    createMediaStreamTrackSource(m) {
                        return new c(this,{
                            mediaStreamTrack: m
                        })
                    }
                    resume() {
                        return this._state === "suspended" ? new Promise( (m, v) => {
                            const y = () => {
                                this._nativeAudioContext.removeEventListener("statechange", y),
                                this._nativeAudioContext.state === "running" ? m() : this.resume().then(m, v)
                            }
                            ;
                            this._nativeAudioContext.addEventListener("statechange", y)
                        }
                        ) : this._nativeAudioContext.resume().catch(m => {
                            throw m === void 0 || m.code === 15 ? t() : m
                        }
                        )
                    }
                    suspend() {
                        return this._nativeAudioContext.suspend().catch(m => {
                            throw m === void 0 ? t() : m
                        }
                        )
                    }
                }
                  , t6 = (e, t, n, i, s, a, o, c) => class extends e {
                    constructor(f, m) {
                        const v = a(f)
                          , y = o(v)
                          , S = s(v, m, y)
                          , A = y ? t(c) : null;
                        super(f, !1, S, A),
                        this._isNodeOfNativeOfflineAudioContext = y,
                        this._nativeAudioDestinationNode = S
                    }
                    get channelCount() {
                        return this._nativeAudioDestinationNode.channelCount
                    }
                    set channelCount(f) {
                        if (this._isNodeOfNativeOfflineAudioContext)
                            throw i();
                        if (f > this._nativeAudioDestinationNode.maxChannelCount)
                            throw n();
                        this._nativeAudioDestinationNode.channelCount = f
                    }
                    get channelCountMode() {
                        return this._nativeAudioDestinationNode.channelCountMode
                    }
                    set channelCountMode(f) {
                        if (this._isNodeOfNativeOfflineAudioContext)
                            throw i();
                        this._nativeAudioDestinationNode.channelCountMode = f
                    }
                    get maxChannelCount() {
                        return this._nativeAudioDestinationNode.maxChannelCount
                    }
                }
                  , n6 = e => {
                    const t = new WeakMap
                      , n = async (i, s) => {
                        const a = s.destination;
                        return t.set(s, a),
                        await e(i, s, a),
                        a
                    }
                    ;
                    return {
                        render(i, s) {
                            const a = t.get(s);
                            return a !== void 0 ? Promise.resolve(a) : n(i, s)
                        }
                    }
                }
                  , i6 = (e, t, n, i, s, a, o, c) => (u, f) => {
                    const m = f.listener
                      , v = () => {
                        const O = new Float32Array(1)
                          , L = t(f, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: 9
                        })
                          , N = o(f);
                        let z = !1
                          , I = [0, 0, -1, 0, 1, 0]
                          , B = [0, 0, 0];
                        const G = () => {
                            if (z)
                                return;
                            z = !0;
                            const oe = i(f, 256, 9, 0);
                            oe.onaudioprocess = ({inputBuffer: k}) => {
                                const W = [a(k, O, 0), a(k, O, 1), a(k, O, 2), a(k, O, 3), a(k, O, 4), a(k, O, 5)];
                                W.some( (Z, j) => Z !== I[j]) && (m.setOrientation(...W),
                                I = W);
                                const V = [a(k, O, 6), a(k, O, 7), a(k, O, 8)];
                                V.some( (Z, j) => Z !== B[j]) && (m.setPosition(...V),
                                B = V)
                            }
                            ,
                            L.connect(oe)
                        }
                          , X = oe => k => {
                            k !== I[oe] && (I[oe] = k,
                            m.setOrientation(...I))
                        }
                          , q = oe => k => {
                            k !== B[oe] && (B[oe] = k,
                            m.setPosition(...B))
                        }
                          , Q = (oe, k, W) => {
                            const V = n(f, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: k
                            });
                            V.connect(L, 0, oe),
                            V.start(),
                            Object.defineProperty(V.offset, "defaultValue", {
                                get() {
                                    return k
                                }
                            });
                            const Z = e({
                                context: u
                            }, N, V.offset, rr, Mr);
                            return c(Z, "value", j => () => j.call(Z), j => ee => {
                                try {
                                    j.call(Z, ee)
                                } catch (H) {
                                    if (H.code !== 9)
                                        throw H
                                }
                                G(),
                                N && W(ee)
                            }
                            ),
                            Z.cancelAndHoldAtTime = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.cancelAndHoldAtTime),
                            Z.cancelScheduledValues = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.cancelScheduledValues),
                            Z.exponentialRampToValueAtTime = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.exponentialRampToValueAtTime),
                            Z.linearRampToValueAtTime = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.linearRampToValueAtTime),
                            Z.setTargetAtTime = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.setTargetAtTime),
                            Z.setValueAtTime = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.setValueAtTime),
                            Z.setValueCurveAtTime = (j => N ? () => {
                                throw s()
                            }
                            : (...ee) => {
                                const H = j.apply(Z, ee);
                                return G(),
                                H
                            }
                            )(Z.setValueCurveAtTime),
                            Z
                        }
                        ;
                        return {
                            forwardX: Q(0, 0, X(0)),
                            forwardY: Q(1, 0, X(1)),
                            forwardZ: Q(2, -1, X(2)),
                            positionX: Q(6, 0, q(0)),
                            positionY: Q(7, 0, q(1)),
                            positionZ: Q(8, 0, q(2)),
                            upX: Q(3, 0, X(3)),
                            upY: Q(4, 1, X(4)),
                            upZ: Q(5, 0, X(5))
                        }
                    }
                      , {forwardX: y, forwardY: S, forwardZ: A, positionX: M, positionY: x, positionZ: T, upX: D, upY: w, upZ: U} = m.forwardX === void 0 ? v() : m;
                    return {
                        get forwardX() {
                            return y
                        },
                        get forwardY() {
                            return S
                        },
                        get forwardZ() {
                            return A
                        },
                        get positionX() {
                            return M
                        },
                        get positionY() {
                            return x
                        },
                        get positionZ() {
                            return T
                        },
                        get upX() {
                            return D
                        },
                        get upY() {
                            return w
                        },
                        get upZ() {
                            return U
                        }
                    }
                }
                  , qS = e => "context"in e
                  , u0 = e => qS(e[0])
                  , Zf = (e, t, n, i) => {
                    for (const s of e)
                        if (n(s)) {
                            if (i)
                                return !1;
                            throw Error("The set contains at least one similar element.")
                        }
                    return e.add(t),
                    !0
                }
                  , pR = (e, t, [n,i], s) => {
                    Zf(e, [t, n, i], a => a[0] === t && a[1] === n, s)
                }
                  , mR = (e, [t,n,i], s) => {
                    const a = e.get(t);
                    a === void 0 ? e.set(t, new Set([[n, i]])) : Zf(a, [n, i], o => o[0] === n, s)
                }
                  , fm = e => "inputs"in e
                  , jS = (e, t, n, i) => {
                    if (fm(t)) {
                        const s = t.inputs[i];
                        return e.connect(s, n, 0),
                        [s, n, 0]
                    }
                    return e.connect(t, n, i),
                    [t, n, i]
                }
                  , vR = (e, t, n) => {
                    for (const i of e)
                        if (i[0] === t && i[1] === n)
                            return e.delete(i),
                            i;
                    return null
                }
                  , s6 = (e, t, n) => XS(e, i => i[0] === t && i[1] === n)
                  , gR = (e, t) => {
                    if (!o0(e).delete(t))
                        throw new Error("Missing the expected event listener.")
                }
                  , yR = (e, t, n) => {
                    const i = pl(e, t)
                      , s = XS(i, a => a[0] === n);
                    return i.size === 0 && e.delete(t),
                    s
                }
                  , QS = (e, t, n, i) => {
                    fm(t) ? e.disconnect(t.inputs[i], n, 0) : e.disconnect(t, n, i)
                }
                  , xi = e => pl(IM, e)
                  , h0 = e => pl(PM, e)
                  , Kf = e => zM.has(e)
                  , ZS = e => !um.has(e)
                  , _R = (e, t) => new Promise(n => {
                    if (t !== null)
                        n(!0);
                    else {
                        const i = e.createScriptProcessor(256, 1, 1)
                          , s = e.createGain()
                          , a = e.createBuffer(1, 2, 44100)
                          , o = a.getChannelData(0);
                        o[0] = 1,
                        o[1] = 1;
                        const c = e.createBufferSource();
                        c.buffer = a,
                        c.loop = !0,
                        c.connect(i).connect(e.destination),
                        c.connect(s),
                        c.disconnect(s),
                        i.onaudioprocess = u => {
                            const f = u.inputBuffer.getChannelData(0);
                            Array.prototype.some.call(f, m => m === 1) ? n(!0) : n(!1),
                            c.stop(),
                            i.onaudioprocess = null,
                            c.disconnect(i),
                            i.disconnect(e.destination)
                        }
                        ,
                        c.start()
                    }
                }
                )
                  , XM = (e, t) => {
                    const n = new Map;
                    for (const i of e)
                        for (const s of i) {
                            const a = n.get(s);
                            n.set(s, a === void 0 ? 1 : a + 1)
                        }
                    n.forEach( (i, s) => t(s, i))
                }
                  , KS = e => "context"in e
                  , a6 = e => {
                    const t = new Map;
                    e.connect = (n => (i, s=0, a=0) => {
                        const o = KS(i) ? n(i, s, a) : n(i, s)
                          , c = t.get(i);
                        return c === void 0 ? t.set(i, [{
                            input: a,
                            output: s
                        }]) : c.every(u => u.input !== a || u.output !== s) && c.push({
                            input: a,
                            output: s
                        }),
                        o
                    }
                    )(e.connect.bind(e)),
                    e.disconnect = (n => (i, s, a) => {
                        if (n.apply(e),
                        i === void 0)
                            t.clear();
                        else if (typeof i == "number")
                            for (const [o,c] of t) {
                                const u = c.filter(f => f.output !== i);
                                u.length === 0 ? t.delete(o) : t.set(o, u)
                            }
                        else if (t.has(i))
                            if (s === void 0)
                                t.delete(i);
                            else {
                                const o = t.get(i);
                                if (o !== void 0) {
                                    const c = o.filter(u => u.output !== s && (u.input !== a || a === void 0));
                                    c.length === 0 ? t.delete(i) : t.set(i, c)
                                }
                            }
                        for (const [o,c] of t)
                            c.forEach(u => {
                                KS(o) ? e.connect(o, u.output, u.input) : e.connect(o, u.output)
                            }
                            )
                    }
                    )(e.disconnect)
                }
                  , r6 = (e, t, n, i) => {
                    const {activeInputs: s, passiveInputs: a} = c0(t)
                      , {outputs: o} = or(e)
                      , c = o0(e)
                      , u = f => {
                        const m = xi(e)
                          , v = h0(t);
                        if (f) {
                            const y = yR(a, e, n);
                            pR(s, e, y, !1),
                            !i && !Kf(e) && m.connect(v, n)
                        } else {
                            const y = s6(s, e, n);
                            mR(a, y, !1),
                            !i && !Kf(e) && m.disconnect(v, n)
                        }
                    }
                    ;
                    return Zf(o, [t, n], f => f[0] === t && f[1] === n, !0) ? (c.add(u),
                    uu(e) ? pR(s, e, [n, u], !0) : mR(a, [e, n, u], !0),
                    !0) : !1
                }
                  , o6 = (e, t, n, i) => {
                    const {activeInputs: s, passiveInputs: a} = or(t)
                      , o = vR(s[i], e, n);
                    return o === null ? [hR(a, e, n, i)[2], !1] : [o[2], !0]
                }
                  , l6 = (e, t, n) => {
                    const {activeInputs: i, passiveInputs: s} = c0(t)
                      , a = vR(i, e, n);
                    return a === null ? [yR(s, e, n)[1], !1] : [a[2], !0]
                }
                  , WM = (e, t, n, i, s) => {
                    const [a,o] = o6(e, n, i, s);
                    if (a !== null && (gR(e, a),
                    o && !t && !Kf(e) && QS(xi(e), xi(n), i, s)),
                    uu(n)) {
                        const {activeInputs: c} = or(n);
                        GM(n, c)
                    }
                }
                  , YM = (e, t, n, i) => {
                    const [s,a] = l6(e, n, i);
                    s !== null && (gR(e, s),
                    a && !t && !Kf(e) && xi(e).disconnect(h0(n), i))
                }
                  , c6 = (e, t) => {
                    const n = or(e)
                      , i = [];
                    for (const s of n.outputs)
                        u0(s) ? WM(e, t, ...s) : YM(e, t, ...s),
                        i.push(s[0]);
                    return n.outputs.clear(),
                    i
                }
                  , u6 = (e, t, n) => {
                    const i = or(e)
                      , s = [];
                    for (const a of i.outputs)
                        a[1] === n && (u0(a) ? WM(e, t, ...a) : YM(e, t, ...a),
                        s.push(a[0]),
                        i.outputs.delete(a));
                    return s
                }
                  , h6 = (e, t, n, i, s) => {
                    const a = or(e);
                    return Array.from(a.outputs).filter(o => o[0] === n && (i === void 0 || o[1] === i) && (s === void 0 || o[2] === s)).map(o => (u0(o) ? WM(e, t, ...o) : YM(e, t, ...o),
                    a.outputs.delete(o),
                    o[0]))
                }
                  , f6 = (e, t, n, i, s, a, o, c, u, f, m, v, y, S, A, M) => class extends f {
                    constructor(T, D, w, U) {
                        super(w),
                        this._context = T,
                        this._nativeAudioNode = w;
                        const O = m(T);
                        v(O) && n(_R, () => _R(O, M)) !== !0 && a6(w),
                        IM.set(this, w),
                        aR.set(this, new Set),
                        T.state !== "closed" && D && hm(this),
                        e(this, U, w)
                    }
                    get channelCount() {
                        return this._nativeAudioNode.channelCount
                    }
                    set channelCount(T) {
                        this._nativeAudioNode.channelCount = T
                    }
                    get channelCountMode() {
                        return this._nativeAudioNode.channelCountMode
                    }
                    set channelCountMode(T) {
                        this._nativeAudioNode.channelCountMode = T
                    }
                    get channelInterpretation() {
                        return this._nativeAudioNode.channelInterpretation
                    }
                    set channelInterpretation(T) {
                        this._nativeAudioNode.channelInterpretation = T
                    }
                    get context() {
                        return this._context
                    }
                    get numberOfInputs() {
                        return this._nativeAudioNode.numberOfInputs
                    }
                    get numberOfOutputs() {
                        return this._nativeAudioNode.numberOfOutputs
                    }
                    connect(T, D=0, w=0) {
                        if (D < 0 || D >= this._nativeAudioNode.numberOfOutputs)
                            throw s();
                        const U = m(this._context)
                          , O = A(U);
                        if (y(T) || S(T))
                            throw a();
                        if (qS(T)) {
                            const N = xi(T);
                            try {
                                const z = jS(this._nativeAudioNode, N, D, w)
                                  , I = ZS(this);
                                (O || I) && this._nativeAudioNode.disconnect(...z),
                                this.context.state !== "closed" && !I && ZS(T) && hm(T)
                            } catch (z) {
                                throw z.code === 12 ? a() : z
                            }
                            if (t(this, T, D, w, O)) {
                                const z = u([this], T);
                                XM(z, i(O))
                            }
                            return T
                        }
                        const L = h0(T);
                        if (L.name === "playbackRate" && L.maxValue === 1024)
                            throw o();
                        try {
                            this._nativeAudioNode.connect(L, D),
                            (O || ZS(this)) && this._nativeAudioNode.disconnect(L, D)
                        } catch (N) {
                            throw N.code === 12 ? a() : N
                        }
                        if (r6(this, T, D, O)) {
                            const N = u([this], T);
                            XM(N, i(O))
                        }
                    }
                    disconnect(T, D, w) {
                        let U;
                        const O = m(this._context)
                          , L = A(O);
                        if (T === void 0)
                            U = c6(this, L);
                        else if (typeof T == "number") {
                            if (T < 0 || T >= this.numberOfOutputs)
                                throw s();
                            U = u6(this, L, T)
                        } else {
                            if (D !== void 0 && (D < 0 || D >= this.numberOfOutputs) || qS(T) && w !== void 0 && (w < 0 || w >= T.numberOfInputs))
                                throw s();
                            if (U = h6(this, L, T, D, w),
                            U.length === 0)
                                throw a()
                        }
                        for (const N of U) {
                            const z = u([this], N);
                            XM(z, c)
                        }
                    }
                }
                  , d6 = (e, t, n, i, s, a, o, c, u, f, m, v, y) => (S, A, M, x=null, T=null) => {
                    const D = M.value
                      , w = new DG.AutomationEventList(D)
                      , U = A ? i(w) : null
                      , O = {
                        get defaultValue() {
                            return D
                        },
                        get maxValue() {
                            return x === null ? M.maxValue : x
                        },
                        get minValue() {
                            return T === null ? M.minValue : T
                        },
                        get value() {
                            return M.value
                        },
                        set value(L) {
                            M.value = L,
                            O.setValueAtTime(L, S.context.currentTime)
                        },
                        cancelAndHoldAtTime(L) {
                            if (typeof M.cancelAndHoldAtTime == "function")
                                U === null && w.flush(S.context.currentTime),
                                w.add(s(L)),
                                M.cancelAndHoldAtTime(L);
                            else {
                                const N = Array.from(w).pop();
                                U === null && w.flush(S.context.currentTime),
                                w.add(s(L));
                                const z = Array.from(w).pop();
                                M.cancelScheduledValues(L),
                                N !== z && z !== void 0 && (z.type === "exponentialRampToValue" ? M.exponentialRampToValueAtTime(z.value, z.endTime) : z.type === "linearRampToValue" ? M.linearRampToValueAtTime(z.value, z.endTime) : z.type === "setValue" ? M.setValueAtTime(z.value, z.startTime) : z.type === "setValueCurve" && M.setValueCurveAtTime(z.values, z.startTime, z.duration))
                            }
                            return O
                        },
                        cancelScheduledValues(L) {
                            return U === null && w.flush(S.context.currentTime),
                            w.add(a(L)),
                            M.cancelScheduledValues(L),
                            O
                        },
                        exponentialRampToValueAtTime(L, N) {
                            if (L === 0)
                                throw new RangeError;
                            if (!Number.isFinite(N) || N < 0)
                                throw new RangeError;
                            const z = S.context.currentTime;
                            return U === null && w.flush(z),
                            Array.from(w).length === 0 && (w.add(f(D, z)),
                            M.setValueAtTime(D, z)),
                            w.add(o(L, N)),
                            M.exponentialRampToValueAtTime(L, N),
                            O
                        },
                        linearRampToValueAtTime(L, N) {
                            const z = S.context.currentTime;
                            return U === null && w.flush(z),
                            Array.from(w).length === 0 && (w.add(f(D, z)),
                            M.setValueAtTime(D, z)),
                            w.add(c(L, N)),
                            M.linearRampToValueAtTime(L, N),
                            O
                        },
                        setTargetAtTime(L, N, z) {
                            return U === null && w.flush(S.context.currentTime),
                            w.add(u(L, N, z)),
                            M.setTargetAtTime(L, N, z),
                            O
                        },
                        setValueAtTime(L, N) {
                            return U === null && w.flush(S.context.currentTime),
                            w.add(f(L, N)),
                            M.setValueAtTime(L, N),
                            O
                        },
                        setValueCurveAtTime(L, N, z) {
                            const I = L instanceof Float32Array ? L : new Float32Array(L);
                            if (v !== null && v.name === "webkitAudioContext") {
                                const B = N + z
                                  , G = S.context.sampleRate
                                  , X = Math.ceil(N * G)
                                  , q = Math.floor(B * G)
                                  , Q = q - X
                                  , oe = new Float32Array(Q);
                                for (let W = 0; W < Q; W += 1) {
                                    const V = (I.length - 1) / z * ((X + W) / G - N)
                                      , Z = Math.floor(V)
                                      , j = Math.ceil(V);
                                    oe[W] = Z === j ? I[Z] : (1 - (V - Z)) * I[Z] + (1 - (j - V)) * I[j]
                                }
                                U === null && w.flush(S.context.currentTime),
                                w.add(m(oe, N, z)),
                                M.setValueCurveAtTime(oe, N, z);
                                const k = q / G;
                                k < B && y(O, oe[oe.length - 1], k),
                                y(O, I[I.length - 1], B)
                            } else
                                U === null && w.flush(S.context.currentTime),
                                w.add(m(I, N, z)),
                                M.setValueCurveAtTime(I, N, z);
                            return O
                        }
                    };
                    return n.set(O, M),
                    t.set(O, S),
                    e(O, U),
                    O
                }
                  , p6 = e => ({
                    replay(t) {
                        for (const n of e)
                            if (n.type === "exponentialRampToValue") {
                                const {endTime: i, value: s} = n;
                                t.exponentialRampToValueAtTime(s, i)
                            } else if (n.type === "linearRampToValue") {
                                const {endTime: i, value: s} = n;
                                t.linearRampToValueAtTime(s, i)
                            } else if (n.type === "setTarget") {
                                const {startTime: i, target: s, timeConstant: a} = n;
                                t.setTargetAtTime(s, i, a)
                            } else if (n.type === "setValue") {
                                const {startTime: i, value: s} = n;
                                t.setValueAtTime(s, i)
                            } else if (n.type === "setValueCurve") {
                                const {duration: i, startTime: s, values: a} = n;
                                t.setValueCurveAtTime(a, s, i)
                            } else
                                throw new Error("Can't apply an unknown automation.")
                    }
                });
                var SR = class {
                    constructor(e) {
                        this._map = new Map(e)
                    }
                    get size() {
                        return this._map.size
                    }
                    entries() {
                        return this._map.entries()
                    }
                    forEach(e, t=null) {
                        return this._map.forEach( (n, i) => e.call(t, n, i, this))
                    }
                    get(e) {
                        return this._map.get(e)
                    }
                    has(e) {
                        return this._map.has(e)
                    }
                    keys() {
                        return this._map.keys()
                    }
                    values() {
                        return this._map.values()
                    }
                }
                ;
                const m6 = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: 1,
                    numberOfOutputs: 1,
                    parameterData: {},
                    processorOptions: {}
                }
                  , v6 = (e, t, n, i, s, a, o, c, u, f, m, v, y, S) => class extends t {
                    constructor(M, x, T) {
                        var D;
                        const w = c(M)
                          , U = u(w)
                          , O = m({
                            ...m6,
                            ...T
                        });
                        y(O);
                        const L = FM.get(w)
                          , N = L?.get(x)
                          , z = U || w.state !== "closed" ? w : (D = o(w)) !== null && D !== void 0 ? D : w
                          , I = s(z, U ? null : M.baseLatency, f, x, N, O)
                          , B = U ? i(x, O, N) : null;
                        super(M, !0, I, B);
                        const G = [];
                        I.parameters.forEach( (q, Q) => {
                            const oe = n(this, U, q);
                            G.push([Q, oe])
                        }
                        ),
                        this._nativeAudioWorkletNode = I,
                        this._onprocessorerror = null,
                        this._parameters = new SR(G),
                        U && e(w, this);
                        const {activeInputs: X} = a(this);
                        v(I, X)
                    }
                    get onprocessorerror() {
                        return this._onprocessorerror
                    }
                    set onprocessorerror(M) {
                        const x = typeof M == "function" ? S(this, M) : null;
                        this._nativeAudioWorkletNode.onprocessorerror = x;
                        const T = this._nativeAudioWorkletNode.onprocessorerror;
                        this._onprocessorerror = T !== null && T === x ? M : T
                    }
                    get parameters() {
                        return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters
                    }
                    get port() {
                        return this._nativeAudioWorkletNode.port
                    }
                }
                ;
                function JS(e, t, n, i, s) {
                    if (typeof e.copyFromChannel == "function")
                        t[n].byteLength === 0 && (t[n] = new Float32Array(128)),
                        e.copyFromChannel(t[n], i, s);
                    else {
                        const a = e.getChannelData(i);
                        if (t[n].byteLength === 0)
                            t[n] = a.slice(s, s + 128);
                        else {
                            const o = new Float32Array(a.buffer,s * Float32Array.BYTES_PER_ELEMENT,128);
                            t[n].set(o)
                        }
                    }
                }
                const xR = (e, t, n, i, s) => {
                    typeof e.copyToChannel == "function" ? t[n].byteLength !== 0 && e.copyToChannel(t[n], i, s) : t[n].byteLength !== 0 && e.getChannelData(i).set(t[n], s)
                }
                  , $S = (e, t) => {
                    const n = [];
                    for (let i = 0; i < e; i += 1) {
                        const s = []
                          , a = typeof t == "number" ? t : t[i];
                        for (let o = 0; o < a; o += 1)
                            s.push(new Float32Array(128));
                        n.push(s)
                    }
                    return n
                }
                  , g6 = (e, t) => {
                    const n = pl(HM, e)
                      , i = xi(t);
                    return pl(n, i)
                }
                  , y6 = async (e, t, n, i, s, a, o) => {
                    const c = t === null ? Math.ceil(e.context.length / 128) * 128 : t.length
                      , u = i.channelCount * i.numberOfInputs
                      , f = s.reduce( (x, T) => x + T, 0)
                      , m = f === 0 ? null : n.createBuffer(f, c, n.sampleRate);
                    if (a === void 0)
                        throw new Error("Missing the processor constructor.");
                    const v = or(e)
                      , y = await g6(n, e)
                      , S = $S(i.numberOfInputs, i.channelCount)
                      , A = $S(i.numberOfOutputs, s)
                      , M = Array.from(e.parameters.keys()).reduce( (x, T) => ({
                        ...x,
                        [T]: new Float32Array(128)
                    }), {});
                    for (let x = 0; x < c; x += 128) {
                        if (i.numberOfInputs > 0 && t !== null)
                            for (let T = 0; T < i.numberOfInputs; T += 1)
                                for (let D = 0; D < i.channelCount; D += 1)
                                    JS(t, S[T], D, D, x);
                        a.parameterDescriptors !== void 0 && t !== null && a.parameterDescriptors.forEach( ({name: T}, D) => {
                            JS(t, M, T, u + D, x)
                        }
                        );
                        for (let T = 0; T < i.numberOfInputs; T += 1)
                            for (let D = 0; D < s[T]; D += 1)
                                A[T][D].byteLength === 0 && (A[T][D] = new Float32Array(128));
                        try {
                            const T = S.map( (w, U) => v.activeInputs[U].size === 0 ? [] : w)
                              , D = o(x / n.sampleRate, n.sampleRate, () => y.process(T, A, M));
                            if (m !== null)
                                for (let w = 0, U = 0; w < i.numberOfOutputs; w += 1) {
                                    for (let O = 0; O < s[w]; O += 1)
                                        xR(m, A[w], O, U + O, x);
                                    U += s[w]
                                }
                            if (!D)
                                break
                        } catch (T) {
                            e.dispatchEvent(new ErrorEvent("processorerror",{
                                colno: T.colno,
                                filename: T.filename,
                                lineno: T.lineno,
                                message: T.message
                            }));
                            break
                        }
                    }
                    return m
                }
                  , _6 = (e, t, n, i, s, a, o, c, u, f, m, v, y, S, A, M) => (x, T, D) => {
                    const w = new WeakMap;
                    let U = null;
                    const O = async (L, N) => {
                        let z = m(L)
                          , I = null;
                        const B = Ca(z, N)
                          , G = Array.isArray(T.outputChannelCount) ? T.outputChannelCount : Array.from(T.outputChannelCount);
                        if (v === null) {
                            const X = G.reduce( (k, W) => k + W, 0)
                              , q = s(N, {
                                channelCount: Math.max(1, X),
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                numberOfOutputs: Math.max(1, X)
                            })
                              , Q = [];
                            for (let k = 0; k < L.numberOfOutputs; k += 1)
                                Q.push(i(N, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: G[k]
                                }));
                            const oe = o(N, {
                                channelCount: T.channelCount,
                                channelCountMode: T.channelCountMode,
                                channelInterpretation: T.channelInterpretation,
                                gain: 1
                            });
                            oe.connect = t.bind(null, Q),
                            oe.disconnect = u.bind(null, Q),
                            I = [q, Q, oe]
                        } else
                            B || (z = new v(N,x));
                        if (w.set(N, I === null ? z : I[2]),
                        I !== null) {
                            if (U === null) {
                                if (D === void 0)
                                    throw new Error("Missing the processor constructor.");
                                if (y === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const W = L.channelCount * L.numberOfInputs
                                  , V = D.parameterDescriptors === void 0 ? 0 : D.parameterDescriptors.length
                                  , Z = W + V;
                                U = y6(L, Z === 0 ? null : await (async () => {
                                    const ee = new y(Z,Math.ceil(L.context.length / 128) * 128,N.sampleRate)
                                      , H = []
                                      , ie = [];
                                    for (let le = 0; le < T.numberOfInputs; le += 1)
                                        H.push(o(ee, {
                                            channelCount: T.channelCount,
                                            channelCountMode: T.channelCountMode,
                                            channelInterpretation: T.channelInterpretation,
                                            gain: 1
                                        })),
                                        ie.push(s(ee, {
                                            channelCount: T.channelCount,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            numberOfOutputs: T.channelCount
                                        }));
                                    const se = await Promise.all(Array.from(L.parameters.values()).map(async le => {
                                        const ue = a(ee, {
                                            channelCount: 1,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            offset: le.value
                                        });
                                        return await S(ee, le, ue.offset),
                                        ue
                                    }
                                    ))
                                      , K = i(ee, {
                                        channelCount: 1,
                                        channelCountMode: "explicit",
                                        channelInterpretation: "speakers",
                                        numberOfInputs: Math.max(1, W + V)
                                    });
                                    for (let le = 0; le < T.numberOfInputs; le += 1) {
                                        H[le].connect(ie[le]);
                                        for (let ue = 0; ue < T.channelCount; ue += 1)
                                            ie[le].connect(K, ue, le * T.channelCount + ue)
                                    }
                                    for (const [le,ue] of se.entries())
                                        ue.connect(K, 0, W + le),
                                        ue.start(0);
                                    return K.connect(ee.destination),
                                    await Promise.all(H.map(le => A(L, ee, le))),
                                    M(ee)
                                }
                                )(), N, T, G, D, f)
                            }
                            const X = await U
                              , q = n(N, {
                                buffer: null,
                                channelCount: 2,
                                channelCountMode: "max",
                                channelInterpretation: "speakers",
                                loop: !1,
                                loopEnd: 0,
                                loopStart: 0,
                                playbackRate: 1
                            })
                              , [Q,oe,k] = I;
                            X !== null && (q.buffer = X,
                            q.start(0)),
                            q.connect(Q);
                            for (let W = 0, V = 0; W < L.numberOfOutputs; W += 1) {
                                const Z = oe[W];
                                for (let j = 0; j < G[W]; j += 1)
                                    Q.connect(Z, V + j, j);
                                V += G[W]
                            }
                            return k
                        }
                        if (B)
                            for (const [X,q] of L.parameters.entries())
                                await e(N, q, z.parameters.get(X));
                        else
                            for (const [X,q] of L.parameters.entries())
                                await S(N, q, z.parameters.get(X));
                        return await A(L, N, z),
                        z
                    }
                    ;
                    return {
                        render(L, N) {
                            c(N, L);
                            const z = w.get(N);
                            return z !== void 0 ? Promise.resolve(z) : O(L, N)
                        }
                    }
                }
                  , S6 = (e, t, n, i, s, a, o, c, u, f, m, v, y, S, A, M, x, T, D, w) => class extends A {
                    constructor(O, L) {
                        super(O, L),
                        this._nativeContext = O,
                        this._audioWorklet = e === void 0 ? void 0 : {
                            addModule: (N, z) => e(this, N, z)
                        }
                    }
                    get audioWorklet() {
                        return this._audioWorklet
                    }
                    createAnalyser() {
                        return new t(this)
                    }
                    createBiquadFilter() {
                        return new s(this)
                    }
                    createBuffer(O, L, N) {
                        return new n({
                            length: L,
                            numberOfChannels: O,
                            sampleRate: N
                        })
                    }
                    createBufferSource() {
                        return new i(this)
                    }
                    createChannelMerger(O=6) {
                        return new a(this,{
                            numberOfInputs: O
                        })
                    }
                    createChannelSplitter(O=6) {
                        return new o(this,{
                            numberOfOutputs: O
                        })
                    }
                    createConstantSource() {
                        return new c(this)
                    }
                    createConvolver() {
                        return new u(this)
                    }
                    createDelay(O=1) {
                        return new m(this,{
                            maxDelayTime: O
                        })
                    }
                    createDynamicsCompressor() {
                        return new v(this)
                    }
                    createGain() {
                        return new y(this)
                    }
                    createIIRFilter(O, L) {
                        return new S(this,{
                            feedback: L,
                            feedforward: O
                        })
                    }
                    createOscillator() {
                        return new M(this)
                    }
                    createPanner() {
                        return new x(this)
                    }
                    createPeriodicWave(O, L, N={
                        disableNormalization: !1
                    }) {
                        return new T(this,{
                            ...N,
                            imag: L,
                            real: O
                        })
                    }
                    createStereoPanner() {
                        return new D(this)
                    }
                    createWaveShaper() {
                        return new w(this)
                    }
                    decodeAudioData(O, L, N) {
                        return f(this._nativeContext, O).then(z => (typeof L == "function" && L(z),
                        z), z => {
                            throw typeof N == "function" && N(z),
                            z
                        }
                        )
                    }
                }
                  , x6 = {
                    Q: 1,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    detune: 0,
                    frequency: 350,
                    gain: 0,
                    type: "lowpass"
                }
                  , A6 = (e, t, n, i, s, a, o, c) => class extends e {
                    constructor(f, m) {
                        const v = a(f)
                          , y = {
                            ...x6,
                            ...m
                        }
                          , S = s(v, y)
                          , A = o(v)
                          , M = A ? n() : null;
                        super(f, !1, S, M),
                        this._Q = t(this, A, S.Q, rr, Mr),
                        this._detune = t(this, A, S.detune, 1200 * Math.log2(rr), -1200 * Math.log2(rr)),
                        this._frequency = t(this, A, S.frequency, f.sampleRate / 2, 0),
                        this._gain = t(this, A, S.gain, 40 * Math.log10(rr), Mr),
                        this._nativeBiquadFilterNode = S,
                        c(this, 1)
                    }
                    get detune() {
                        return this._detune
                    }
                    get frequency() {
                        return this._frequency
                    }
                    get gain() {
                        return this._gain
                    }
                    get Q() {
                        return this._Q
                    }
                    get type() {
                        return this._nativeBiquadFilterNode.type
                    }
                    set type(f) {
                        this._nativeBiquadFilterNode.type = f
                    }
                    getFrequencyResponse(f, m, v) {
                        try {
                            this._nativeBiquadFilterNode.getFrequencyResponse(f, m, v)
                        } catch (y) {
                            throw y.code === 11 ? i() : y
                        }
                        if (f.length !== m.length || m.length !== v.length)
                            throw i()
                    }
                }
                  , T6 = (e, t, n, i, s) => () => {
                    const a = new WeakMap
                      , o = async (c, u) => {
                        let f = n(c);
                        const m = Ca(f, u);
                        if (!m) {
                            const v = {
                                Q: f.Q.value,
                                channelCount: f.channelCount,
                                channelCountMode: f.channelCountMode,
                                channelInterpretation: f.channelInterpretation,
                                detune: f.detune.value,
                                frequency: f.frequency.value,
                                gain: f.gain.value,
                                type: f.type
                            };
                            f = t(u, v)
                        }
                        return a.set(u, f),
                        m ? (await e(u, c.Q, f.Q),
                        await e(u, c.detune, f.detune),
                        await e(u, c.frequency, f.frequency),
                        await e(u, c.gain, f.gain)) : (await i(u, c.Q, f.Q),
                        await i(u, c.detune, f.detune),
                        await i(u, c.frequency, f.frequency),
                        await i(u, c.gain, f.gain)),
                        await s(c, u, f),
                        f
                    }
                    ;
                    return {
                        render(c, u) {
                            const f = a.get(u);
                            return f !== void 0 ? Promise.resolve(f) : o(c, u)
                        }
                    }
                }
                  , M6 = (e, t) => (n, i) => {
                    const s = t.get(n);
                    if (s !== void 0)
                        return s;
                    const a = e.get(n);
                    if (a !== void 0)
                        return a;
                    try {
                        const o = i();
                        return o instanceof Promise ? (e.set(n, o),
                        o.catch( () => !1).then(c => (e.delete(n),
                        t.set(n, c),
                        c))) : (t.set(n, o),
                        o)
                    } catch {
                        return t.set(n, !1),
                        !1
                    }
                }
                  , b6 = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: 6
                }
                  , E6 = (e, t, n, i, s) => class extends e {
                    constructor(o, c) {
                        const u = i(o)
                          , f = {
                            ...b6,
                            ...c
                        }
                          , m = n(u, f)
                          , v = s(u) ? t() : null;
                        super(o, !1, m, v)
                    }
                }
                  , C6 = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (a, o) => {
                        let c = t(a);
                        if (!Ca(c, o)) {
                            const u = {
                                channelCount: c.channelCount,
                                channelCountMode: c.channelCountMode,
                                channelInterpretation: c.channelInterpretation,
                                numberOfInputs: c.numberOfInputs
                            };
                            c = e(o, u)
                        }
                        return i.set(o, c),
                        await n(a, o, c),
                        c
                    }
                    ;
                    return {
                        render(a, o) {
                            const c = i.get(o);
                            return c !== void 0 ? Promise.resolve(c) : s(a, o)
                        }
                    }
                }
                  , w6 = {
                    channelCount: 6,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    numberOfOutputs: 6
                }
                  , D6 = (e, t, n, i, s, a) => class extends e {
                    constructor(c, u) {
                        const f = i(c)
                          , m = a({
                            ...w6,
                            ...u
                        })
                          , v = n(f, m)
                          , y = s(f) ? t() : null;
                        super(c, !1, v, y)
                    }
                }
                  , R6 = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (a, o) => {
                        let c = t(a);
                        if (!Ca(c, o)) {
                            const u = {
                                channelCount: c.channelCount,
                                channelCountMode: c.channelCountMode,
                                channelInterpretation: c.channelInterpretation,
                                numberOfOutputs: c.numberOfOutputs
                            };
                            c = e(o, u)
                        }
                        return i.set(o, c),
                        await n(a, o, c),
                        c
                    }
                    ;
                    return {
                        render(a, o) {
                            const c = i.get(o);
                            return c !== void 0 ? Promise.resolve(c) : s(a, o)
                        }
                    }
                }
                  , U6 = e => (t, n, i) => e(n, t, i)
                  , O6 = e => (t, n, i=0, s=0) => {
                    const a = t[i];
                    if (a === void 0)
                        throw e();
                    return KS(n) ? a.connect(n, 0, s) : a.connect(n, 0)
                }
                  , N6 = e => (t, n) => {
                    const i = e(t, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    });
                    return i.buffer = t.createBuffer(1, 2, 44100),
                    i.loop = !0,
                    i.connect(n),
                    i.start(),
                    () => {
                        i.stop(),
                        i.disconnect(n)
                    }
                }
                  , B6 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    offset: 1
                }
                  , L6 = (e, t, n, i, s, a, o) => class extends e {
                    constructor(u, f) {
                        const m = s(u)
                          , v = {
                            ...B6,
                            ...f
                        }
                          , y = i(m, v)
                          , S = a(m)
                          , A = S ? n() : null;
                        super(u, !1, y, A),
                        this._constantSourceNodeRenderer = A,
                        this._nativeConstantSourceNode = y,
                        this._offset = t(this, S, y.offset, rr, Mr),
                        this._onended = null
                    }
                    get offset() {
                        return this._offset
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(u) {
                        const f = typeof u == "function" ? o(this, u) : null;
                        this._nativeConstantSourceNode.onended = f;
                        const m = this._nativeConstantSourceNode.onended;
                        this._onended = m !== null && m === f ? u : m
                    }
                    start(u=0) {
                        if (this._nativeConstantSourceNode.start(u),
                        this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = u),
                        this.context.state !== "closed") {
                            hm(this);
                            const f = () => {
                                this._nativeConstantSourceNode.removeEventListener("ended", f),
                                uu(this) && l0(this)
                            }
                            ;
                            this._nativeConstantSourceNode.addEventListener("ended", f)
                        }
                    }
                    stop(u=0) {
                        this._nativeConstantSourceNode.stop(u),
                        this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = u)
                    }
                }
                  , I6 = (e, t, n, i, s) => () => {
                    const a = new WeakMap;
                    let o = null
                      , c = null;
                    const u = async (f, m) => {
                        let v = n(f);
                        const y = Ca(v, m);
                        if (!y) {
                            const S = {
                                channelCount: v.channelCount,
                                channelCountMode: v.channelCountMode,
                                channelInterpretation: v.channelInterpretation,
                                offset: v.offset.value
                            };
                            v = t(m, S),
                            o !== null && v.start(o),
                            c !== null && v.stop(c)
                        }
                        return a.set(m, v),
                        y ? await e(m, f.offset, v.offset) : await i(m, f.offset, v.offset),
                        await s(f, m, v),
                        v
                    }
                    ;
                    return {
                        set start(f) {
                            o = f
                        },
                        set stop(f) {
                            c = f
                        },
                        render(f, m) {
                            const v = a.get(m);
                            return v !== void 0 ? Promise.resolve(v) : u(f, m)
                        }
                    }
                }
                  , P6 = e => t => (e[0] = t,
                e[0])
                  , z6 = {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    disableNormalization: !1
                }
                  , F6 = (e, t, n, i, s, a) => class extends e {
                    constructor(c, u) {
                        const f = i(c)
                          , m = {
                            ...z6,
                            ...u
                        }
                          , v = n(f, m)
                          , y = s(f) ? t() : null;
                        super(c, !1, v, y),
                        this._isBufferNullified = !1,
                        this._nativeConvolverNode = v,
                        m.buffer !== null && a(this, m.buffer.duration)
                    }
                    get buffer() {
                        return this._isBufferNullified ? null : this._nativeConvolverNode.buffer
                    }
                    set buffer(c) {
                        if (this._nativeConvolverNode.buffer = c,
                        c === null && this._nativeConvolverNode.buffer !== null) {
                            const u = this._nativeConvolverNode.context;
                            this._nativeConvolverNode.buffer = u.createBuffer(1, 1, u.sampleRate),
                            this._isBufferNullified = !0,
                            a(this, 0)
                        } else
                            this._isBufferNullified = !1,
                            a(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration)
                    }
                    get normalize() {
                        return this._nativeConvolverNode.normalize
                    }
                    set normalize(c) {
                        this._nativeConvolverNode.normalize = c
                    }
                }
                  , H6 = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (a, o) => {
                        let c = t(a);
                        if (!Ca(c, o)) {
                            const u = {
                                buffer: c.buffer,
                                channelCount: c.channelCount,
                                channelCountMode: c.channelCountMode,
                                channelInterpretation: c.channelInterpretation,
                                disableNormalization: !c.normalize
                            };
                            c = e(o, u)
                        }
                        return i.set(o, c),
                        fm(c) ? await n(a, o, c.inputs[0]) : await n(a, o, c),
                        c
                    }
                    ;
                    return {
                        render(a, o) {
                            const c = i.get(o);
                            return c !== void 0 ? Promise.resolve(c) : s(a, o)
                        }
                    }
                }
                  , G6 = (e, t) => (n, i, s) => {
                    if (t === null)
                        throw new Error("Missing the native OfflineAudioContext constructor.");
                    try {
                        return new t(n,i,s)
                    } catch (a) {
                        throw a.name === "SyntaxError" ? e() : a
                    }
                }
                  , V6 = () => new DOMException("","DataCloneError")
                  , AR = e => {
                    const {port1: t, port2: n} = new MessageChannel;
                    return new Promise(i => {
                        const s = () => {
                            n.onmessage = null,
                            t.close(),
                            n.close(),
                            i()
                        }
                        ;
                        n.onmessage = () => s();
                        try {
                            t.postMessage(e, [e])
                        } catch {} finally {
                            s()
                        }
                    }
                    )
                }
                  , k6 = (e, t, n, i, s, a, o, c, u, f, m) => (v, y) => {
                    const S = o(v) ? v : a(v);
                    if (s.has(y)) {
                        const A = n();
                        return Promise.reject(A)
                    }
                    try {
                        s.add(y)
                    } catch {}
                    return t(u, () => u(S)) ? S.decodeAudioData(y).then(A => (AR(y).catch( () => {}
                    ),
                    t(c, () => c(A)) || m(A),
                    e.add(A),
                    A)) : new Promise( (A, M) => {
                        const x = async () => {
                            try {
                                await AR(y)
                            } catch {}
                        }
                          , T = D => {
                            M(D),
                            x()
                        }
                        ;
                        try {
                            S.decodeAudioData(y, D => {
                                typeof D.copyFromChannel != "function" && (f(D),
                                VM(D)),
                                e.add(D),
                                x().then( () => A(D))
                            }
                            , D => {
                                T(D === null ? i() : D)
                            }
                            )
                        } catch (D) {
                            T(D)
                        }
                    }
                    )
                }
                  , X6 = (e, t, n, i, s, a, o, c) => (u, f) => {
                    const m = t.get(u);
                    if (m === void 0)
                        throw new Error("Missing the expected cycle count.");
                    const v = a(u.context)
                      , y = c(v);
                    if (m === f) {
                        if (t.delete(u),
                        !y && o(u)) {
                            const S = i(u)
                              , {outputs: A} = n(u);
                            for (const M of A)
                                if (u0(M)) {
                                    const x = i(M[0]);
                                    e(S, x, M[1], M[2])
                                } else {
                                    const x = s(M[0]);
                                    S.connect(x, M[1])
                                }
                        }
                    } else
                        t.set(u, m - f)
                }
                  , W6 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    delayTime: 0,
                    maxDelayTime: 1
                }
                  , Y6 = (e, t, n, i, s, a, o) => class extends e {
                    constructor(u, f) {
                        const m = s(u)
                          , v = {
                            ...W6,
                            ...f
                        }
                          , y = i(m, v)
                          , S = a(m)
                          , A = S ? n(v.maxDelayTime) : null;
                        super(u, !1, y, A),
                        this._delayTime = t(this, S, y.delayTime),
                        o(this, v.maxDelayTime)
                    }
                    get delayTime() {
                        return this._delayTime
                    }
                }
                  , q6 = (e, t, n, i, s) => a => {
                    const o = new WeakMap
                      , c = async (u, f) => {
                        let m = n(u);
                        const v = Ca(m, f);
                        if (!v) {
                            const y = {
                                channelCount: m.channelCount,
                                channelCountMode: m.channelCountMode,
                                channelInterpretation: m.channelInterpretation,
                                delayTime: m.delayTime.value,
                                maxDelayTime: a
                            };
                            m = t(f, y)
                        }
                        return o.set(f, m),
                        v ? await e(f, u.delayTime, m.delayTime) : await i(f, u.delayTime, m.delayTime),
                        await s(u, f, m),
                        m
                    }
                    ;
                    return {
                        render(u, f) {
                            const m = o.get(f);
                            return m !== void 0 ? Promise.resolve(m) : c(u, f)
                        }
                    }
                }
                  , j6 = e => (t, n, i, s) => e(t[s], a => a[0] === n && a[1] === i)
                  , Q6 = e => (t, n) => {
                    e(t).delete(n)
                }
                  , Z6 = e => "delayTime"in e
                  , K6 = (e, t, n) => function i(s, a) {
                    const o = qS(a) ? a : n(e, a);
                    if (Z6(o))
                        return [];
                    if (s[0] === o)
                        return [s];
                    if (s.includes(o))
                        return [];
                    const {outputs: c} = t(o);
                    return Array.from(c).map(u => i([...s, o], u[0])).reduce( (u, f) => u.concat(f), [])
                }
                  , ex = (e, t, n) => {
                    const i = t[n];
                    if (i === void 0)
                        throw e();
                    return i
                }
                  , J6 = e => (t, n=void 0, i=void 0, s=0) => n === void 0 ? t.forEach(a => a.disconnect()) : typeof n == "number" ? ex(e, t, n).disconnect() : KS(n) ? i === void 0 ? t.forEach(a => a.disconnect(n)) : s === void 0 ? ex(e, t, i).disconnect(n, 0) : ex(e, t, i).disconnect(n, 0, s) : i === void 0 ? t.forEach(a => a.disconnect(n)) : ex(e, t, i).disconnect(n, 0)
                  , $6 = {
                    attack: .003,
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    knee: 30,
                    ratio: 12,
                    release: .25,
                    threshold: -24
                }
                  , eV = (e, t, n, i, s, a, o, c) => class extends e {
                    constructor(f, m) {
                        const v = a(f)
                          , y = {
                            ...$6,
                            ...m
                        }
                          , S = i(v, y)
                          , A = o(v)
                          , M = A ? n() : null;
                        super(f, !1, S, M),
                        this._attack = t(this, A, S.attack),
                        this._knee = t(this, A, S.knee),
                        this._nativeDynamicsCompressorNode = S,
                        this._ratio = t(this, A, S.ratio),
                        this._release = t(this, A, S.release),
                        this._threshold = t(this, A, S.threshold),
                        c(this, .006)
                    }
                    get attack() {
                        return this._attack
                    }
                    get channelCount() {
                        return this._nativeDynamicsCompressorNode.channelCount
                    }
                    set channelCount(f) {
                        const m = this._nativeDynamicsCompressorNode.channelCount;
                        if (this._nativeDynamicsCompressorNode.channelCount = f,
                        f > 2)
                            throw this._nativeDynamicsCompressorNode.channelCount = m,
                            s()
                    }
                    get channelCountMode() {
                        return this._nativeDynamicsCompressorNode.channelCountMode
                    }
                    set channelCountMode(f) {
                        const m = this._nativeDynamicsCompressorNode.channelCountMode;
                        if (this._nativeDynamicsCompressorNode.channelCountMode = f,
                        f === "max")
                            throw this._nativeDynamicsCompressorNode.channelCountMode = m,
                            s()
                    }
                    get knee() {
                        return this._knee
                    }
                    get ratio() {
                        return this._ratio
                    }
                    get reduction() {
                        return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction
                    }
                    get release() {
                        return this._release
                    }
                    get threshold() {
                        return this._threshold
                    }
                }
                  , tV = (e, t, n, i, s) => () => {
                    const a = new WeakMap
                      , o = async (c, u) => {
                        let f = n(c);
                        const m = Ca(f, u);
                        if (!m) {
                            const v = {
                                attack: f.attack.value,
                                channelCount: f.channelCount,
                                channelCountMode: f.channelCountMode,
                                channelInterpretation: f.channelInterpretation,
                                knee: f.knee.value,
                                ratio: f.ratio.value,
                                release: f.release.value,
                                threshold: f.threshold.value
                            };
                            f = t(u, v)
                        }
                        return a.set(u, f),
                        m ? (await e(u, c.attack, f.attack),
                        await e(u, c.knee, f.knee),
                        await e(u, c.ratio, f.ratio),
                        await e(u, c.release, f.release),
                        await e(u, c.threshold, f.threshold)) : (await i(u, c.attack, f.attack),
                        await i(u, c.knee, f.knee),
                        await i(u, c.ratio, f.ratio),
                        await i(u, c.release, f.release),
                        await i(u, c.threshold, f.threshold)),
                        await s(c, u, f),
                        f
                    }
                    ;
                    return {
                        render(c, u) {
                            const f = a.get(u);
                            return f !== void 0 ? Promise.resolve(f) : o(c, u)
                        }
                    }
                }
                  , nV = () => new DOMException("","EncodingError")
                  , iV = e => t => new Promise( (n, i) => {
                    if (e === null) {
                        i(new SyntaxError);
                        return
                    }
                    const s = e.document.head;
                    if (s === null)
                        i(new SyntaxError);
                    else {
                        const a = e.document.createElement("script")
                          , o = new Blob([t],{
                            type: "application/javascript"
                        })
                          , c = URL.createObjectURL(o)
                          , u = e.onerror
                          , f = () => {
                            e.onerror = u,
                            URL.revokeObjectURL(c)
                        }
                        ;
                        e.onerror = (m, v, y, S, A) => {
                            if (v === c || v === e.location.href && y === 1 && S === 1)
                                return f(),
                                i(A),
                                !1;
                            if (u !== null)
                                return u(m, v, y, S, A)
                        }
                        ,
                        a.onerror = () => {
                            f(),
                            i(new SyntaxError)
                        }
                        ,
                        a.onload = () => {
                            f(),
                            n()
                        }
                        ,
                        a.src = c,
                        a.type = "module",
                        s.appendChild(a)
                    }
                }
                )
                  , sV = e => class {
                    constructor(n) {
                        this._nativeEventTarget = n,
                        this._listeners = new WeakMap
                    }
                    addEventListener(n, i, s) {
                        if (i !== null) {
                            let a = this._listeners.get(i);
                            a === void 0 && (a = e(this, i),
                            typeof i == "function" && this._listeners.set(i, a)),
                            this._nativeEventTarget.addEventListener(n, a, s)
                        }
                    }
                    dispatchEvent(n) {
                        return this._nativeEventTarget.dispatchEvent(n)
                    }
                    removeEventListener(n, i, s) {
                        const a = i === null ? void 0 : this._listeners.get(i);
                        this._nativeEventTarget.removeEventListener(n, a === void 0 ? null : a, s)
                    }
                }
                  , aV = e => (t, n, i) => {
                    Object.defineProperties(e, {
                        currentFrame: {
                            configurable: !0,
                            get() {
                                return Math.round(t * n)
                            }
                        },
                        currentTime: {
                            configurable: !0,
                            get() {
                                return t
                            }
                        }
                    });
                    try {
                        return i()
                    } finally {
                        e !== null && (delete e.currentFrame,
                        delete e.currentTime)
                    }
                }
                  , rV = e => async t => {
                    try {
                        const n = await fetch(t);
                        if (n.ok)
                            return [await n.text(), n.url]
                    } catch {}
                    throw e()
                }
                  , oV = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    gain: 1
                }
                  , lV = (e, t, n, i, s, a) => class extends e {
                    constructor(c, u) {
                        const f = s(c)
                          , m = {
                            ...oV,
                            ...u
                        }
                          , v = i(f, m)
                          , y = a(f)
                          , S = y ? n() : null;
                        super(c, !1, v, S),
                        this._gain = t(this, y, v.gain, rr, Mr)
                    }
                    get gain() {
                        return this._gain
                    }
                }
                  , cV = (e, t, n, i, s) => () => {
                    const a = new WeakMap
                      , o = async (c, u) => {
                        let f = n(c);
                        const m = Ca(f, u);
                        if (!m) {
                            const v = {
                                channelCount: f.channelCount,
                                channelCountMode: f.channelCountMode,
                                channelInterpretation: f.channelInterpretation,
                                gain: f.gain.value
                            };
                            f = t(u, v)
                        }
                        return a.set(u, f),
                        m ? await e(u, c.gain, f.gain) : await i(u, c.gain, f.gain),
                        await s(c, u, f),
                        f
                    }
                    ;
                    return {
                        render(c, u) {
                            const f = a.get(u);
                            return f !== void 0 ? Promise.resolve(f) : o(c, u)
                        }
                    }
                }
                  , uV = (e, t) => n => t(e, n)
                  , hV = e => t => {
                    const n = e(t);
                    if (n.renderer === null)
                        throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
                    return n.renderer
                }
                  , fV = e => t => {
                    var n;
                    return (n = e.get(t)) !== null && n !== void 0 ? n : 0
                }
                  , dV = e => t => {
                    const n = e(t);
                    if (n.renderer === null)
                        throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
                    return n.renderer
                }
                  , pV = e => t => e.get(t)
                  , vs = () => new DOMException("","InvalidStateError")
                  , mV = e => t => {
                    const n = e.get(t);
                    if (n === void 0)
                        throw vs();
                    return n
                }
                  , vV = (e, t) => n => {
                    let i = e.get(n);
                    if (i !== void 0)
                        return i;
                    if (t === null)
                        throw new Error("Missing the native OfflineAudioContext constructor.");
                    return i = new t(1,1,44100),
                    e.set(n, i),
                    i
                }
                  , gV = e => t => {
                    const n = e.get(t);
                    if (n === void 0)
                        throw new Error("The context has no set of AudioWorkletNodes.");
                    return n
                }
                  , tx = () => new DOMException("","InvalidAccessError")
                  , yV = e => {
                    e.getFrequencyResponse = (t => (n, i, s) => {
                        if (n.length !== i.length || i.length !== s.length)
                            throw tx();
                        return t.call(e, n, i, s)
                    }
                    )(e.getFrequencyResponse)
                }
                  , _V = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers"
                }
                  , SV = (e, t, n, i, s, a) => class extends e {
                    constructor(c, u) {
                        const f = i(c)
                          , m = s(f)
                          , v = {
                            ..._V,
                            ...u
                        }
                          , y = t(f, m ? null : c.baseLatency, v)
                          , S = m ? n(v.feedback, v.feedforward) : null;
                        super(c, !1, y, S),
                        yV(y),
                        this._nativeIIRFilterNode = y,
                        a(this, 1)
                    }
                    getFrequencyResponse(c, u, f) {
                        return this._nativeIIRFilterNode.getFrequencyResponse(c, u, f)
                    }
                }
                  , TR = (e, t, n, i, s, a, o, c, u, f, m) => {
                    const v = f.length;
                    let y = c;
                    for (let S = 0; S < v; S += 1) {
                        let A = n[0] * f[S];
                        for (let M = 1; M < s; M += 1) {
                            const x = y - M & u - 1;
                            A += n[M] * a[x],
                            A -= e[M] * o[x]
                        }
                        for (let M = s; M < i; M += 1)
                            A += n[M] * a[y - M & u - 1];
                        for (let M = s; M < t; M += 1)
                            A -= e[M] * o[y - M & u - 1];
                        a[y] = f[S],
                        o[y] = A,
                        y = y + 1 & u - 1,
                        m[S] = A
                    }
                    return y
                }
                  , xV = (e, t, n, i) => {
                    const s = n instanceof Float64Array ? n : new Float64Array(n)
                      , a = i instanceof Float64Array ? i : new Float64Array(i)
                      , o = s.length
                      , c = a.length
                      , u = Math.min(o, c);
                    if (s[0] !== 1) {
                        for (let A = 0; A < o; A += 1)
                            a[A] /= s[0];
                        for (let A = 1; A < c; A += 1)
                            s[A] /= s[0]
                    }
                    const f = 32
                      , m = new Float32Array(f)
                      , v = new Float32Array(f)
                      , y = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate)
                      , S = e.numberOfChannels;
                    for (let A = 0; A < S; A += 1) {
                        const M = e.getChannelData(A)
                          , x = y.getChannelData(A);
                        m.fill(0),
                        v.fill(0),
                        TR(s, o, a, c, u, m, v, 0, f, M, x)
                    }
                    return y
                }
                  , AV = (e, t, n, i, s) => (a, o) => {
                    const c = new WeakMap;
                    let u = null;
                    const f = async (m, v) => {
                        let y = null
                          , S = t(m);
                        const A = Ca(S, v);
                        if (v.createIIRFilter === void 0 ? y = e(v, {
                            buffer: null,
                            channelCount: 2,
                            channelCountMode: "max",
                            channelInterpretation: "speakers",
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            playbackRate: 1
                        }) : A || (S = v.createIIRFilter(o, a)),
                        c.set(v, y === null ? S : y),
                        y !== null) {
                            if (u === null) {
                                if (n === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const M = new n(m.context.destination.channelCount,m.context.length,v.sampleRate);
                                u = (async () => {
                                    await i(m, M, M.destination);
                                    const x = await s(M);
                                    return xV(x, v, a, o)
                                }
                                )()
                            }
                            return y.buffer = await u,
                            y.start(0),
                            y
                        }
                        return await i(m, v, S),
                        S
                    }
                    ;
                    return {
                        render(m, v) {
                            const y = c.get(v);
                            return y !== void 0 ? Promise.resolve(y) : f(m, v)
                        }
                    }
                }
                  , TV = (e, t, n, i, s, a) => o => (c, u) => {
                    const f = e.get(c);
                    if (f === void 0) {
                        if (!o && a(c)) {
                            const m = i(c)
                              , {outputs: v} = n(c);
                            for (const y of v)
                                if (u0(y)) {
                                    const S = i(y[0]);
                                    t(m, S, y[1], y[2])
                                } else {
                                    const S = s(y[0]);
                                    m.disconnect(S, y[1])
                                }
                        }
                        e.set(c, u)
                    } else
                        e.set(c, f + u)
                }
                  , MV = (e, t) => n => {
                    const i = e.get(n);
                    return t(i) || t(n)
                }
                  , bV = (e, t) => n => e.has(n) || t(n)
                  , EV = (e, t) => n => e.has(n) || t(n)
                  , CV = (e, t) => n => {
                    const i = e.get(n);
                    return t(i) || t(n)
                }
                  , wV = e => t => e !== null && t instanceof e
                  , DV = e => t => e !== null && typeof e.AudioNode == "function" && t instanceof e.AudioNode
                  , RV = e => t => e !== null && typeof e.AudioParam == "function" && t instanceof e.AudioParam
                  , UV = (e, t) => n => e(n) || t(n)
                  , OV = e => t => e !== null && t instanceof e
                  , NV = e => e !== null && e.isSecureContext
                  , BV = (e, t, n, i) => class extends e {
                    constructor(a, o) {
                        const c = n(a)
                          , u = t(c, o);
                        if (i(c))
                            throw TypeError();
                        super(a, !0, u, null),
                        this._nativeMediaElementAudioSourceNode = u
                    }
                    get mediaElement() {
                        return this._nativeMediaElementAudioSourceNode.mediaElement
                    }
                }
                  , LV = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers"
                }
                  , IV = (e, t, n, i) => class extends e {
                    constructor(a, o) {
                        const c = n(a);
                        if (i(c))
                            throw new TypeError;
                        const u = {
                            ...LV,
                            ...o
                        }
                          , f = t(c, u);
                        super(a, !1, f, null),
                        this._nativeMediaStreamAudioDestinationNode = f
                    }
                    get stream() {
                        return this._nativeMediaStreamAudioDestinationNode.stream
                    }
                }
                  , PV = (e, t, n, i) => class extends e {
                    constructor(a, o) {
                        const c = n(a)
                          , u = t(c, o);
                        if (i(c))
                            throw new TypeError;
                        super(a, !0, u, null),
                        this._nativeMediaStreamAudioSourceNode = u
                    }
                    get mediaStream() {
                        return this._nativeMediaStreamAudioSourceNode.mediaStream
                    }
                }
                  , zV = (e, t, n) => class extends e {
                    constructor(s, a) {
                        const o = n(s)
                          , c = t(o, a);
                        super(s, !0, c, null)
                    }
                }
                  , FV = (e, t, n, i, s) => class extends i {
                    constructor(o={}) {
                        if (s === null)
                            throw new Error("Missing the native AudioContext constructor.");
                        let c;
                        try {
                            c = new s(o)
                        } catch (m) {
                            throw m.code === 12 && m.message === "sampleRate is not in range" ? t() : m
                        }
                        if (c === null)
                            throw n();
                        if (!dR(o.latencyHint))
                            throw new TypeError(`The provided value '${o.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                        if (o.sampleRate !== void 0 && c.sampleRate !== o.sampleRate)
                            throw t();
                        super(c, 2);
                        const {latencyHint: u} = o
                          , {sampleRate: f} = c;
                        if (this._baseLatency = typeof c.baseLatency == "number" ? c.baseLatency : u === "balanced" ? 512 / f : u === "interactive" || u === void 0 ? 256 / f : u === "playback" ? 1024 / f : Math.max(2, Math.min(128, Math.round(u * f / 128))) * 128 / f,
                        this._nativeAudioContext = c,
                        s.name === "webkitAudioContext" ? (this._nativeGainNode = c.createGain(),
                        this._nativeOscillatorNode = c.createOscillator(),
                        this._nativeGainNode.gain.value = 1e-37,
                        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(c.destination),
                        this._nativeOscillatorNode.start()) : (this._nativeGainNode = null,
                        this._nativeOscillatorNode = null),
                        this._state = null,
                        c.state === "running") {
                            this._state = "suspended";
                            const m = () => {
                                this._state === "suspended" && (this._state = null),
                                c.removeEventListener("statechange", m)
                            }
                            ;
                            c.addEventListener("statechange", m)
                        }
                    }
                    get baseLatency() {
                        return this._baseLatency
                    }
                    get state() {
                        return this._state !== null ? this._state : this._nativeAudioContext.state
                    }
                    close() {
                        return this.state === "closed" ? this._nativeAudioContext.close().then( () => {
                            throw e()
                        }
                        ) : (this._state === "suspended" && (this._state = null),
                        this._nativeAudioContext.close().then( () => {
                            this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(),
                            this._nativeGainNode.disconnect(),
                            this._nativeOscillatorNode.disconnect()),
                            YS(this)
                        }
                        ))
                    }
                    resume() {
                        return this._state === "suspended" ? new Promise( (o, c) => {
                            const u = () => {
                                this._nativeAudioContext.removeEventListener("statechange", u),
                                this._nativeAudioContext.state === "running" ? o() : this.resume().then(o, c)
                            }
                            ;
                            this._nativeAudioContext.addEventListener("statechange", u)
                        }
                        ) : this._nativeAudioContext.resume().catch(o => {
                            throw o === void 0 || o.code === 15 ? e() : o
                        }
                        )
                    }
                    suspend() {
                        return this._nativeAudioContext.suspend().catch(o => {
                            throw o === void 0 ? e() : o
                        }
                        )
                    }
                }
                  , HV = (e, t, n, i, s, a) => class extends n {
                    constructor(c, u) {
                        super(c),
                        this._nativeContext = c,
                        kS.set(this, c),
                        i(c) && s.set(c, new Set),
                        this._destination = new e(this,u),
                        this._listener = t(this, c),
                        this._onstatechange = null
                    }
                    get currentTime() {
                        return this._nativeContext.currentTime
                    }
                    get destination() {
                        return this._destination
                    }
                    get listener() {
                        return this._listener
                    }
                    get onstatechange() {
                        return this._onstatechange
                    }
                    set onstatechange(c) {
                        const u = typeof c == "function" ? a(this, c) : null;
                        this._nativeContext.onstatechange = u;
                        const f = this._nativeContext.onstatechange;
                        this._onstatechange = f !== null && f === u ? c : f
                    }
                    get sampleRate() {
                        return this._nativeContext.sampleRate
                    }
                    get state() {
                        return this._nativeContext.state
                    }
                }
                  , Jf = e => {
                    const t = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
                    try {
                        const n = e.decodeAudioData(t.buffer, () => {}
                        );
                        return n === void 0 ? !1 : (n.catch( () => {}
                        ),
                        !0)
                    } catch {}
                    return !1
                }
                  , GV = {
                    numberOfChannels: 1
                }
                  , VV = (e, t, n, i, s) => class extends i {
                    constructor(o) {
                        const {length: c, numberOfChannels: u, sampleRate: f} = {
                            ...GV,
                            ...o
                        }
                          , m = n(u, c, f);
                        e(Jf, () => Jf(m)) || m.addEventListener("statechange", ( () => {
                            let v = 0;
                            const y = S => {
                                this._state === "running" && (v > 0 ? (m.removeEventListener("statechange", y),
                                S.stopImmediatePropagation(),
                                this._waitForThePromiseToSettle(S)) : v += 1)
                            }
                            ;
                            return y
                        }
                        )()),
                        super(m, u),
                        this._length = c,
                        this._nativeOfflineAudioContext = m,
                        this._state = null
                    }
                    get length() {
                        return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
                    }
                    get state() {
                        return this._state === null ? this._nativeOfflineAudioContext.state : this._state
                    }
                    startRendering() {
                        return this._state === "running" ? Promise.reject(t()) : (this._state = "running",
                        s(this.destination, this._nativeOfflineAudioContext).finally( () => {
                            this._state = null,
                            YS(this)
                        }
                        ))
                    }
                    _waitForThePromiseToSettle(o) {
                        this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(o) : setTimeout( () => this._waitForThePromiseToSettle(o))
                    }
                }
                  , kV = (e, t) => (n, i, s) => {
                    const a = new Set;
                    return n.connect = (o => (c, u=0, f=0) => {
                        const m = a.size === 0;
                        if (t(c))
                            return o.call(n, c, u, f),
                            e(a, [c, u, f], v => v[0] === c && v[1] === u && v[2] === f, !0),
                            m && i(),
                            c;
                        o.call(n, c, u),
                        e(a, [c, u], v => v[0] === c && v[1] === u, !0),
                        m && i()
                    }
                    )(n.connect),
                    n.disconnect = (o => (c, u, f) => {
                        const m = a.size > 0;
                        if (c === void 0)
                            o.apply(n),
                            a.clear();
                        else if (typeof c == "number") {
                            o.call(n, c);
                            for (const y of a)
                                y[1] === c && a.delete(y)
                        } else {
                            t(c) ? o.call(n, c, u, f) : o.call(n, c, u);
                            for (const y of a)
                                y[0] === c && (u === void 0 || y[1] === u) && (f === void 0 || y[2] === f) && a.delete(y)
                        }
                        const v = a.size === 0;
                        m && v && s()
                    }
                    )(n.disconnect),
                    n
                }
                  , Ui = (e, t, n) => {
                    const i = t[n];
                    i !== void 0 && i !== e[n] && (e[n] = i)
                }
                  , Ns = (e, t) => {
                    Ui(e, t, "channelCount"),
                    Ui(e, t, "channelCountMode"),
                    Ui(e, t, "channelInterpretation")
                }
                  , MR = e => typeof e.getFloatTimeDomainData == "function"
                  , XV = e => {
                    e.getFloatTimeDomainData = t => {
                        const n = new Uint8Array(t.length);
                        e.getByteTimeDomainData(n);
                        const i = Math.max(n.length, e.fftSize);
                        for (let s = 0; s < i; s += 1)
                            t[s] = (n[s] - 128) * .0078125;
                        return t
                    }
                }
                  , WV = (e, t) => (n, i) => {
                    const s = n.createAnalyser();
                    if (Ns(s, i),
                    !(i.maxDecibels > i.minDecibels))
                        throw t();
                    return Ui(s, i, "fftSize"),
                    Ui(s, i, "maxDecibels"),
                    Ui(s, i, "minDecibels"),
                    Ui(s, i, "smoothingTimeConstant"),
                    e(MR, () => MR(s)) || XV(s),
                    s
                }
                  , YV = e => e === null ? null : e.hasOwnProperty("AudioBuffer") ? e.AudioBuffer : null
                  , Ki = (e, t, n) => {
                    const i = t[n];
                    i !== void 0 && i !== e[n].value && (e[n].value = i)
                }
                  , qV = e => {
                    e.start = (t => {
                        let n = !1;
                        return (i=0, s=0, a) => {
                            if (n)
                                throw vs();
                            t.call(e, i, s, a),
                            n = !0
                        }
                    }
                    )(e.start)
                }
                  , qM = e => {
                    e.start = (t => (n=0, i=0, s) => {
                        if (typeof s == "number" && s < 0 || i < 0 || n < 0)
                            throw new RangeError("The parameters can't be negative.");
                        t.call(e, n, i, s)
                    }
                    )(e.start)
                }
                  , jM = e => {
                    e.stop = (t => (n=0) => {
                        if (n < 0)
                            throw new RangeError("The parameter can't be negative.");
                        t.call(e, n)
                    }
                    )(e.stop)
                }
                  , jV = (e, t, n, i, s, a, o, c, u, f, m) => (v, y) => {
                    const S = v.createBufferSource();
                    return Ns(S, y),
                    Ki(S, y, "playbackRate"),
                    Ui(S, y, "buffer"),
                    Ui(S, y, "loop"),
                    Ui(S, y, "loopEnd"),
                    Ui(S, y, "loopStart"),
                    t(n, () => n(v)) || qV(S),
                    t(i, () => i(v)) || u(S),
                    t(s, () => s(v)) || f(S, v),
                    t(a, () => a(v)) || qM(S),
                    t(o, () => o(v)) || m(S, v),
                    t(c, () => c(v)) || jM(S),
                    e(v, S),
                    S
                }
                  , QV = e => e === null ? null : e.hasOwnProperty("AudioContext") ? e.AudioContext : e.hasOwnProperty("webkitAudioContext") ? e.webkitAudioContext : null
                  , ZV = (e, t) => (n, i, s) => {
                    const a = n.destination;
                    if (a.channelCount !== i)
                        try {
                            a.channelCount = i
                        } catch {}
                    s && a.channelCountMode !== "explicit" && (a.channelCountMode = "explicit"),
                    a.maxChannelCount === 0 && Object.defineProperty(a, "maxChannelCount", {
                        value: i
                    });
                    const o = e(n, {
                        channelCount: i,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        gain: 1
                    });
                    return t(o, "channelCount", c => () => c.call(o), c => u => {
                        c.call(o, u);
                        try {
                            a.channelCount = u
                        } catch (f) {
                            if (u > a.maxChannelCount)
                                throw f
                        }
                    }
                    ),
                    t(o, "channelCountMode", c => () => c.call(o), c => u => {
                        c.call(o, u),
                        a.channelCountMode = u
                    }
                    ),
                    t(o, "channelInterpretation", c => () => c.call(o), c => u => {
                        c.call(o, u),
                        a.channelInterpretation = u
                    }
                    ),
                    Object.defineProperty(o, "maxChannelCount", {
                        get: () => a.maxChannelCount
                    }),
                    o.connect(a),
                    o
                }
                  , KV = e => e === null ? null : e.hasOwnProperty("AudioWorkletNode") ? e.AudioWorkletNode : null
                  , JV = e => {
                    const {port1: t} = new MessageChannel;
                    try {
                        t.postMessage(e)
                    } finally {
                        t.close()
                    }
                }
                  , $V = (e, t, n, i, s) => (a, o, c, u, f, m) => {
                    if (c !== null)
                        try {
                            const v = new c(a,u,m)
                              , y = new Map;
                            let S = null;
                            if (Object.defineProperties(v, {
                                channelCount: {
                                    get: () => m.channelCount,
                                    set: () => {
                                        throw e()
                                    }
                                },
                                channelCountMode: {
                                    get: () => "explicit",
                                    set: () => {
                                        throw e()
                                    }
                                },
                                onprocessorerror: {
                                    get: () => S,
                                    set: A => {
                                        typeof S == "function" && v.removeEventListener("processorerror", S),
                                        S = typeof A == "function" ? A : null,
                                        typeof S == "function" && v.addEventListener("processorerror", S)
                                    }
                                }
                            }),
                            v.addEventListener = (A => (...M) => {
                                if (M[0] === "processorerror") {
                                    const x = typeof M[1] == "function" ? M[1] : typeof M[1] == "object" && M[1] !== null && typeof M[1].handleEvent == "function" ? M[1].handleEvent : null;
                                    if (x !== null) {
                                        const T = y.get(M[1]);
                                        T !== void 0 ? M[1] = T : (M[1] = D => {
                                            D.type === "error" ? (Object.defineProperties(D, {
                                                type: {
                                                    value: "processorerror"
                                                }
                                            }),
                                            x(D)) : x(new ErrorEvent(M[0],{
                                                ...D
                                            }))
                                        }
                                        ,
                                        y.set(x, M[1]))
                                    }
                                }
                                return A.call(v, "error", M[1], M[2]),
                                A.call(v, ...M)
                            }
                            )(v.addEventListener),
                            v.removeEventListener = (A => (...M) => {
                                if (M[0] === "processorerror") {
                                    const x = y.get(M[1]);
                                    x !== void 0 && (y.delete(M[1]),
                                    M[1] = x)
                                }
                                return A.call(v, "error", M[1], M[2]),
                                A.call(v, M[0], M[1], M[2])
                            }
                            )(v.removeEventListener),
                            m.numberOfOutputs !== 0) {
                                const A = n(a, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "discrete",
                                    gain: 0
                                });
                                return v.connect(A).connect(a.destination),
                                s(v, () => A.disconnect(), () => A.connect(a.destination))
                            }
                            return v
                        } catch (v) {
                            throw v.code === 11 ? i() : v
                        }
                    if (f === void 0)
                        throw i();
                    return JV(m),
                    t(a, o, f, m)
                }
                  , bR = (e, t) => e === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(e * t)))))
                  , ek = e => new Promise( (t, n) => {
                    const {port1: i, port2: s} = new MessageChannel;
                    i.onmessage = ({data: a}) => {
                        i.close(),
                        s.close(),
                        t(a)
                    }
                    ,
                    i.onmessageerror = ({data: a}) => {
                        i.close(),
                        s.close(),
                        n(a)
                    }
                    ,
                    s.postMessage(e)
                }
                )
                  , tk = async (e, t) => {
                    const n = await ek(t);
                    return new e(n)
                }
                  , nk = (e, t, n, i) => {
                    let s = HM.get(e);
                    s === void 0 && (s = new WeakMap,
                    HM.set(e, s));
                    const a = tk(n, i);
                    return s.set(t, a),
                    a
                }
                  , ik = (e, t, n, i, s, a, o, c, u, f, m, v, y) => (S, A, M, x) => {
                    if (x.numberOfInputs === 0 && x.numberOfOutputs === 0)
                        throw u();
                    const T = Array.isArray(x.outputChannelCount) ? x.outputChannelCount : Array.from(x.outputChannelCount);
                    if (T.some(he => he < 1))
                        throw u();
                    if (T.length !== x.numberOfOutputs)
                        throw t();
                    if (x.channelCountMode !== "explicit")
                        throw u();
                    const D = x.channelCount * x.numberOfInputs
                      , w = T.reduce( (he, ye) => he + ye, 0)
                      , U = M.parameterDescriptors === void 0 ? 0 : M.parameterDescriptors.length;
                    if (D + U > 6 || w > 6)
                        throw u();
                    const O = new MessageChannel
                      , L = []
                      , N = [];
                    for (let he = 0; he < x.numberOfInputs; he += 1)
                        L.push(o(S, {
                            channelCount: x.channelCount,
                            channelCountMode: x.channelCountMode,
                            channelInterpretation: x.channelInterpretation,
                            gain: 1
                        })),
                        N.push(s(S, {
                            channelCount: x.channelCount,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: x.channelCount
                        }));
                    const z = [];
                    if (M.parameterDescriptors !== void 0)
                        for (const {defaultValue: he, maxValue: ye, minValue: xe, name: ge} of M.parameterDescriptors) {
                            const Te = a(S, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: x.parameterData[ge] !== void 0 ? x.parameterData[ge] : he === void 0 ? 0 : he
                            });
                            Object.defineProperties(Te.offset, {
                                defaultValue: {
                                    get: () => he === void 0 ? 0 : he
                                },
                                maxValue: {
                                    get: () => ye === void 0 ? rr : ye
                                },
                                minValue: {
                                    get: () => xe === void 0 ? Mr : xe
                                }
                            }),
                            z.push(Te)
                        }
                    const I = i(S, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "speakers",
                        numberOfInputs: Math.max(1, D + U)
                    })
                      , B = bR(A, S.sampleRate)
                      , G = c(S, B, D + U, Math.max(1, w))
                      , X = s(S, {
                        channelCount: Math.max(1, w),
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        numberOfOutputs: Math.max(1, w)
                    })
                      , q = [];
                    for (let he = 0; he < x.numberOfOutputs; he += 1)
                        q.push(i(S, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: T[he]
                        }));
                    for (let he = 0; he < x.numberOfInputs; he += 1) {
                        L[he].connect(N[he]);
                        for (let ye = 0; ye < x.channelCount; ye += 1)
                            N[he].connect(I, ye, he * x.channelCount + ye)
                    }
                    const Q = new SR(M.parameterDescriptors === void 0 ? [] : M.parameterDescriptors.map( ({name: he}, ye) => {
                        const xe = z[ye];
                        return xe.connect(I, 0, D + ye),
                        xe.start(0),
                        [he, xe.offset]
                    }
                    ));
                    I.connect(G);
                    let oe = x.channelInterpretation
                      , k = null;
                    const W = x.numberOfOutputs === 0 ? [G] : q
                      , V = {
                        get bufferSize() {
                            return B
                        },
                        get channelCount() {
                            return x.channelCount
                        },
                        set channelCount(he) {
                            throw n()
                        },
                        get channelCountMode() {
                            return x.channelCountMode
                        },
                        set channelCountMode(he) {
                            throw n()
                        },
                        get channelInterpretation() {
                            return oe
                        },
                        set channelInterpretation(he) {
                            for (const ye of L)
                                ye.channelInterpretation = he;
                            oe = he
                        },
                        get context() {
                            return G.context
                        },
                        get inputs() {
                            return L
                        },
                        get numberOfInputs() {
                            return x.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return x.numberOfOutputs
                        },
                        get onprocessorerror() {
                            return k
                        },
                        set onprocessorerror(he) {
                            typeof k == "function" && V.removeEventListener("processorerror", k),
                            k = typeof he == "function" ? he : null,
                            typeof k == "function" && V.addEventListener("processorerror", k)
                        },
                        get parameters() {
                            return Q
                        },
                        get port() {
                            return O.port2
                        },
                        addEventListener(...he) {
                            return G.addEventListener(he[0], he[1], he[2])
                        },
                        connect: e.bind(null, W),
                        disconnect: f.bind(null, W),
                        dispatchEvent(...he) {
                            return G.dispatchEvent(he[0])
                        },
                        removeEventListener(...he) {
                            return G.removeEventListener(he[0], he[1], he[2])
                        }
                    }
                      , Z = new Map;
                    O.port1.addEventListener = (he => (...ye) => {
                        if (ye[0] === "message") {
                            const xe = typeof ye[1] == "function" ? ye[1] : typeof ye[1] == "object" && ye[1] !== null && typeof ye[1].handleEvent == "function" ? ye[1].handleEvent : null;
                            if (xe !== null) {
                                const ge = Z.get(ye[1]);
                                ge !== void 0 ? ye[1] = ge : (ye[1] = Te => {
                                    m(S.currentTime, S.sampleRate, () => xe(Te))
                                }
                                ,
                                Z.set(xe, ye[1]))
                            }
                        }
                        return he.call(O.port1, ye[0], ye[1], ye[2])
                    }
                    )(O.port1.addEventListener),
                    O.port1.removeEventListener = (he => (...ye) => {
                        if (ye[0] === "message") {
                            const xe = Z.get(ye[1]);
                            xe !== void 0 && (Z.delete(ye[1]),
                            ye[1] = xe)
                        }
                        return he.call(O.port1, ye[0], ye[1], ye[2])
                    }
                    )(O.port1.removeEventListener);
                    let j = null;
                    Object.defineProperty(O.port1, "onmessage", {
                        get: () => j,
                        set: he => {
                            typeof j == "function" && O.port1.removeEventListener("message", j),
                            j = typeof he == "function" ? he : null,
                            typeof j == "function" && (O.port1.addEventListener("message", j),
                            O.port1.start())
                        }
                    }),
                    M.prototype.port = O.port1;
                    let ee = null;
                    nk(S, V, M, x).then(he => ee = he);
                    const H = $S(x.numberOfInputs, x.channelCount)
                      , ie = $S(x.numberOfOutputs, T)
                      , se = M.parameterDescriptors === void 0 ? [] : M.parameterDescriptors.reduce( (he, {name: ye}) => ({
                        ...he,
                        [ye]: new Float32Array(128)
                    }), {});
                    let K = !0;
                    const le = () => {
                        x.numberOfOutputs > 0 && G.disconnect(X);
                        for (let he = 0, ye = 0; he < x.numberOfOutputs; he += 1) {
                            const xe = q[he];
                            for (let ge = 0; ge < T[he]; ge += 1)
                                X.disconnect(xe, ye + ge, ge);
                            ye += T[he]
                        }
                    }
                      , ue = new Map;
                    G.onaudioprocess = ({inputBuffer: he, outputBuffer: ye}) => {
                        if (ee !== null) {
                            const xe = v(V);
                            for (let ge = 0; ge < B; ge += 128) {
                                for (let Te = 0; Te < x.numberOfInputs; Te += 1)
                                    for (let Ae = 0; Ae < x.channelCount; Ae += 1)
                                        JS(he, H[Te], Ae, Ae, ge);
                                M.parameterDescriptors !== void 0 && M.parameterDescriptors.forEach( ({name: Te}, Ae) => {
                                    JS(he, se, Te, D + Ae, ge)
                                }
                                );
                                for (let Te = 0; Te < x.numberOfInputs; Te += 1)
                                    for (let Ae = 0; Ae < T[Te]; Ae += 1)
                                        ie[Te][Ae].byteLength === 0 && (ie[Te][Ae] = new Float32Array(128));
                                try {
                                    const Te = H.map( (Ae, we) => {
                                        if (xe[we].size > 0)
                                            return ue.set(we, B / 128),
                                            Ae;
                                        const it = ue.get(we);
                                        return it === void 0 ? [] : (Ae.every(je => je.every($ => $ === 0)) && (it === 1 ? ue.delete(we) : ue.set(we, it - 1)),
                                        Ae)
                                    }
                                    );
                                    K = m(S.currentTime + ge / S.sampleRate, S.sampleRate, () => ee.process(Te, ie, se));
                                    for (let Ae = 0, we = 0; Ae < x.numberOfOutputs; Ae += 1) {
                                        for (let it = 0; it < T[Ae]; it += 1)
                                            xR(ye, ie[Ae], it, we + it, ge);
                                        we += T[Ae]
                                    }
                                } catch (Te) {
                                    K = !1,
                                    V.dispatchEvent(new ErrorEvent("processorerror",{
                                        colno: Te.colno,
                                        filename: Te.filename,
                                        lineno: Te.lineno,
                                        message: Te.message
                                    }))
                                }
                                if (!K) {
                                    for (let Te = 0; Te < x.numberOfInputs; Te += 1) {
                                        L[Te].disconnect(N[Te]);
                                        for (let Ae = 0; Ae < x.channelCount; Ae += 1)
                                            N[ge].disconnect(I, Ae, Te * x.channelCount + Ae)
                                    }
                                    if (M.parameterDescriptors !== void 0) {
                                        const Te = M.parameterDescriptors.length;
                                        for (let Ae = 0; Ae < Te; Ae += 1) {
                                            const we = z[Ae];
                                            we.disconnect(I, 0, D + Ae),
                                            we.stop()
                                        }
                                    }
                                    I.disconnect(G),
                                    G.onaudioprocess = null,
                                    de ? le() : Ee();
                                    break
                                }
                            }
                        }
                    }
                    ;
                    let de = !1;
                    const qe = o(S, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    })
                      , ze = () => G.connect(qe).connect(S.destination)
                      , Ee = () => {
                        G.disconnect(qe),
                        qe.disconnect()
                    }
                      , re = () => {
                        if (K) {
                            Ee(),
                            x.numberOfOutputs > 0 && G.connect(X);
                            for (let he = 0, ye = 0; he < x.numberOfOutputs; he += 1) {
                                const xe = q[he];
                                for (let ge = 0; ge < T[he]; ge += 1)
                                    X.connect(xe, ye + ge, ge);
                                ye += T[he]
                            }
                        }
                        de = !0
                    }
                      , Le = () => {
                        K && (ze(),
                        le()),
                        de = !1
                    }
                    ;
                    return ze(),
                    y(V, re, Le)
                }
                  , ER = (e, t) => {
                    const n = e.createBiquadFilter();
                    return Ns(n, t),
                    Ki(n, t, "Q"),
                    Ki(n, t, "detune"),
                    Ki(n, t, "frequency"),
                    Ki(n, t, "gain"),
                    Ui(n, t, "type"),
                    n
                }
                  , sk = (e, t) => (n, i) => {
                    const s = n.createChannelMerger(i.numberOfInputs);
                    return e !== null && e.name === "webkitAudioContext" && t(n, s),
                    Ns(s, i),
                    s
                }
                  , ak = e => {
                    const t = e.numberOfOutputs;
                    Object.defineProperty(e, "channelCount", {
                        get: () => t,
                        set: n => {
                            if (n !== t)
                                throw vs()
                        }
                    }),
                    Object.defineProperty(e, "channelCountMode", {
                        get: () => "explicit",
                        set: n => {
                            if (n !== "explicit")
                                throw vs()
                        }
                    }),
                    Object.defineProperty(e, "channelInterpretation", {
                        get: () => "discrete",
                        set: n => {
                            if (n !== "discrete")
                                throw vs()
                        }
                    })
                }
                  , f0 = (e, t) => {
                    const n = e.createChannelSplitter(t.numberOfOutputs);
                    return Ns(n, t),
                    ak(n),
                    n
                }
                  , rk = (e, t, n, i, s) => (a, o) => {
                    if (a.createConstantSource === void 0)
                        return n(a, o);
                    const c = a.createConstantSource();
                    return Ns(c, o),
                    Ki(c, o, "offset"),
                    t(i, () => i(a)) || qM(c),
                    t(s, () => s(a)) || jM(c),
                    e(a, c),
                    c
                }
                  , dm = (e, t) => (e.connect = t.connect.bind(t),
                e.disconnect = t.disconnect.bind(t),
                e)
                  , ok = (e, t, n, i) => (s, {offset: a, ...o}) => {
                    const c = s.createBuffer(1, 2, 44100)
                      , u = t(s, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    })
                      , f = n(s, {
                        ...o,
                        gain: a
                    })
                      , m = c.getChannelData(0);
                    m[0] = 1,
                    m[1] = 1,
                    u.buffer = c,
                    u.loop = !0;
                    const v = {
                        get bufferSize() {},
                        get channelCount() {
                            return f.channelCount
                        },
                        set channelCount(A) {
                            f.channelCount = A
                        },
                        get channelCountMode() {
                            return f.channelCountMode
                        },
                        set channelCountMode(A) {
                            f.channelCountMode = A
                        },
                        get channelInterpretation() {
                            return f.channelInterpretation
                        },
                        set channelInterpretation(A) {
                            f.channelInterpretation = A
                        },
                        get context() {
                            return f.context
                        },
                        get inputs() {
                            return []
                        },
                        get numberOfInputs() {
                            return u.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return f.numberOfOutputs
                        },
                        get offset() {
                            return f.gain
                        },
                        get onended() {
                            return u.onended
                        },
                        set onended(A) {
                            u.onended = A
                        },
                        addEventListener(...A) {
                            return u.addEventListener(A[0], A[1], A[2])
                        },
                        dispatchEvent(...A) {
                            return u.dispatchEvent(A[0])
                        },
                        removeEventListener(...A) {
                            return u.removeEventListener(A[0], A[1], A[2])
                        },
                        start(A=0) {
                            u.start.call(u, A)
                        },
                        stop(A=0) {
                            u.stop.call(u, A)
                        }
                    }
                      , y = () => u.connect(f)
                      , S = () => u.disconnect(f);
                    return e(s, u),
                    i(dm(v, f), y, S)
                }
                  , lk = (e, t) => (n, i) => {
                    const s = n.createConvolver();
                    if (Ns(s, i),
                    i.disableNormalization === s.normalize && (s.normalize = !i.disableNormalization),
                    Ui(s, i, "buffer"),
                    i.channelCount > 2 || (t(s, "channelCount", a => () => a.call(s), a => o => {
                        if (o > 2)
                            throw e();
                        return a.call(s, o)
                    }
                    ),
                    i.channelCountMode === "max"))
                        throw e();
                    return t(s, "channelCountMode", a => () => a.call(s), a => o => {
                        if (o === "max")
                            throw e();
                        return a.call(s, o)
                    }
                    ),
                    s
                }
                  , CR = (e, t) => {
                    const n = e.createDelay(t.maxDelayTime);
                    return Ns(n, t),
                    Ki(n, t, "delayTime"),
                    n
                }
                  , ck = e => (t, n) => {
                    const i = t.createDynamicsCompressor();
                    if (Ns(i, n),
                    n.channelCount > 2 || n.channelCountMode === "max")
                        throw e();
                    return Ki(i, n, "attack"),
                    Ki(i, n, "knee"),
                    Ki(i, n, "ratio"),
                    Ki(i, n, "release"),
                    Ki(i, n, "threshold"),
                    i
                }
                  , br = (e, t) => {
                    const n = e.createGain();
                    return Ns(n, t),
                    Ki(n, t, "gain"),
                    n
                }
                  , uk = e => (t, n, i) => {
                    if (t.createIIRFilter === void 0)
                        return e(t, n, i);
                    const s = t.createIIRFilter(i.feedforward, i.feedback);
                    return Ns(s, i),
                    s
                }
                ;
                function hk(e, t) {
                    const n = t[0] * t[0] + t[1] * t[1];
                    return [(e[0] * t[0] + e[1] * t[1]) / n, (e[1] * t[0] - e[0] * t[1]) / n]
                }
                function fk(e, t) {
                    return [e[0] * t[0] - e[1] * t[1], e[0] * t[1] + e[1] * t[0]]
                }
                function wR(e, t) {
                    let n = [0, 0];
                    for (let i = e.length - 1; i >= 0; i -= 1)
                        n = fk(n, t),
                        n[0] += e[i];
                    return n
                }
                const dk = (e, t, n, i) => (s, a, {channelCount: o, channelCountMode: c, channelInterpretation: u, feedback: f, feedforward: m}) => {
                    const v = bR(a, s.sampleRate)
                      , y = f instanceof Float64Array ? f : new Float64Array(f)
                      , S = m instanceof Float64Array ? m : new Float64Array(m)
                      , A = y.length
                      , M = S.length
                      , x = Math.min(A, M);
                    if (A === 0 || A > 20)
                        throw i();
                    if (y[0] === 0)
                        throw t();
                    if (M === 0 || M > 20)
                        throw i();
                    if (S[0] === 0)
                        throw t();
                    if (y[0] !== 1) {
                        for (let N = 0; N < M; N += 1)
                            S[N] /= y[0];
                        for (let N = 1; N < A; N += 1)
                            y[N] /= y[0]
                    }
                    const T = n(s, v, o, o);
                    T.channelCount = o,
                    T.channelCountMode = c,
                    T.channelInterpretation = u;
                    const D = 32
                      , w = []
                      , U = []
                      , O = [];
                    for (let N = 0; N < o; N += 1) {
                        w.push(0);
                        const z = new Float32Array(D)
                          , I = new Float32Array(D);
                        z.fill(0),
                        I.fill(0),
                        U.push(z),
                        O.push(I)
                    }
                    T.onaudioprocess = N => {
                        const z = N.inputBuffer
                          , I = N.outputBuffer
                          , B = z.numberOfChannels;
                        for (let G = 0; G < B; G += 1) {
                            const X = z.getChannelData(G)
                              , q = I.getChannelData(G);
                            w[G] = TR(y, A, S, M, x, U[G], O[G], w[G], D, X, q)
                        }
                    }
                    ;
                    const L = s.sampleRate / 2;
                    return dm({
                        get bufferSize() {
                            return v
                        },
                        get channelCount() {
                            return T.channelCount
                        },
                        set channelCount(N) {
                            T.channelCount = N
                        },
                        get channelCountMode() {
                            return T.channelCountMode
                        },
                        set channelCountMode(N) {
                            T.channelCountMode = N
                        },
                        get channelInterpretation() {
                            return T.channelInterpretation
                        },
                        set channelInterpretation(N) {
                            T.channelInterpretation = N
                        },
                        get context() {
                            return T.context
                        },
                        get inputs() {
                            return [T]
                        },
                        get numberOfInputs() {
                            return T.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return T.numberOfOutputs
                        },
                        addEventListener(...N) {
                            return T.addEventListener(N[0], N[1], N[2])
                        },
                        dispatchEvent(...N) {
                            return T.dispatchEvent(N[0])
                        },
                        getFrequencyResponse(N, z, I) {
                            if (N.length !== z.length || z.length !== I.length)
                                throw e();
                            const B = N.length;
                            for (let G = 0; G < B; G += 1) {
                                const X = -Math.PI * (N[G] / L)
                                  , q = [Math.cos(X), Math.sin(X)]
                                  , Q = wR(S, q)
                                  , oe = wR(y, q)
                                  , k = hk(Q, oe);
                                z[G] = Math.sqrt(k[0] * k[0] + k[1] * k[1]),
                                I[G] = Math.atan2(k[1], k[0])
                            }
                        },
                        removeEventListener(...N) {
                            return T.removeEventListener(N[0], N[1], N[2])
                        }
                    }, T)
                }
                  , pk = (e, t) => e.createMediaElementSource(t.mediaElement)
                  , mk = (e, t) => {
                    const n = e.createMediaStreamDestination();
                    return Ns(n, t),
                    n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", {
                        get: () => 0
                    }),
                    n
                }
                  , vk = (e, {mediaStream: t}) => {
                    const n = t.getAudioTracks();
                    n.sort( (a, o) => a.id < o.id ? -1 : a.id > o.id ? 1 : 0);
                    const i = n.slice(0, 1)
                      , s = e.createMediaStreamSource(new MediaStream(i));
                    return Object.defineProperty(s, "mediaStream", {
                        value: t
                    }),
                    s
                }
                  , gk = (e, t) => (n, {mediaStreamTrack: i}) => {
                    if (typeof n.createMediaStreamTrackSource == "function")
                        return n.createMediaStreamTrackSource(i);
                    const s = new MediaStream([i])
                      , a = n.createMediaStreamSource(s);
                    if (i.kind !== "audio")
                        throw e();
                    if (t(n))
                        throw new TypeError;
                    return a
                }
                  , yk = e => e === null ? null : e.hasOwnProperty("OfflineAudioContext") ? e.OfflineAudioContext : e.hasOwnProperty("webkitOfflineAudioContext") ? e.webkitOfflineAudioContext : null
                  , _k = (e, t, n, i, s, a) => (o, c) => {
                    const u = o.createOscillator();
                    return Ns(u, c),
                    Ki(u, c, "detune"),
                    Ki(u, c, "frequency"),
                    c.periodicWave !== void 0 ? u.setPeriodicWave(c.periodicWave) : Ui(u, c, "type"),
                    t(n, () => n(o)) || qM(u),
                    t(i, () => i(o)) || a(u, o),
                    t(s, () => s(o)) || jM(u),
                    e(o, u),
                    u
                }
                  , Sk = e => (t, n) => {
                    const i = t.createPanner();
                    return i.orientationX === void 0 ? e(t, n) : (Ns(i, n),
                    Ki(i, n, "orientationX"),
                    Ki(i, n, "orientationY"),
                    Ki(i, n, "orientationZ"),
                    Ki(i, n, "positionX"),
                    Ki(i, n, "positionY"),
                    Ki(i, n, "positionZ"),
                    Ui(i, n, "coneInnerAngle"),
                    Ui(i, n, "coneOuterAngle"),
                    Ui(i, n, "coneOuterGain"),
                    Ui(i, n, "distanceModel"),
                    Ui(i, n, "maxDistance"),
                    Ui(i, n, "panningModel"),
                    Ui(i, n, "refDistance"),
                    Ui(i, n, "rolloffFactor"),
                    i)
                }
                  , xk = (e, t, n, i, s, a, o, c, u, f) => (m, {coneInnerAngle: v, coneOuterAngle: y, coneOuterGain: S, distanceModel: A, maxDistance: M, orientationX: x, orientationY: T, orientationZ: D, panningModel: w, positionX: U, positionY: O, positionZ: L, refDistance: N, rolloffFactor: z, ...I}) => {
                    const B = m.createPanner();
                    if (I.channelCount > 2 || I.channelCountMode === "max")
                        throw o();
                    Ns(B, I);
                    const G = {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete"
                    }
                      , X = n(m, {
                        ...G,
                        channelInterpretation: "speakers",
                        numberOfInputs: 6
                    })
                      , q = i(m, {
                        ...I,
                        gain: 1
                    })
                      , Q = i(m, {
                        ...G,
                        gain: 1
                    })
                      , oe = i(m, {
                        ...G,
                        gain: 0
                    })
                      , k = i(m, {
                        ...G,
                        gain: 0
                    })
                      , W = i(m, {
                        ...G,
                        gain: 0
                    })
                      , V = i(m, {
                        ...G,
                        gain: 0
                    })
                      , Z = i(m, {
                        ...G,
                        gain: 0
                    })
                      , j = s(m, 256, 6, 1)
                      , ee = a(m, {
                        ...G,
                        curve: new Float32Array([1, 1]),
                        oversample: "none"
                    });
                    let H = [x, T, D]
                      , ie = [U, O, L];
                    const se = new Float32Array(1);
                    j.onaudioprocess = ({inputBuffer: de}) => {
                        const qe = [u(de, se, 0), u(de, se, 1), u(de, se, 2)];
                        qe.some( (Ee, re) => Ee !== H[re]) && (B.setOrientation(...qe),
                        H = qe);
                        const ze = [u(de, se, 3), u(de, se, 4), u(de, se, 5)];
                        ze.some( (Ee, re) => Ee !== ie[re]) && (B.setPosition(...ze),
                        ie = ze)
                    }
                    ,
                    Object.defineProperty(oe.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(k.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(W.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(V.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(Z.gain, "defaultValue", {
                        get: () => 0
                    });
                    const K = {
                        get bufferSize() {},
                        get channelCount() {
                            return B.channelCount
                        },
                        set channelCount(de) {
                            if (de > 2)
                                throw o();
                            q.channelCount = de,
                            B.channelCount = de
                        },
                        get channelCountMode() {
                            return B.channelCountMode
                        },
                        set channelCountMode(de) {
                            if (de === "max")
                                throw o();
                            q.channelCountMode = de,
                            B.channelCountMode = de
                        },
                        get channelInterpretation() {
                            return B.channelInterpretation
                        },
                        set channelInterpretation(de) {
                            q.channelInterpretation = de,
                            B.channelInterpretation = de
                        },
                        get coneInnerAngle() {
                            return B.coneInnerAngle
                        },
                        set coneInnerAngle(de) {
                            B.coneInnerAngle = de
                        },
                        get coneOuterAngle() {
                            return B.coneOuterAngle
                        },
                        set coneOuterAngle(de) {
                            B.coneOuterAngle = de
                        },
                        get coneOuterGain() {
                            return B.coneOuterGain
                        },
                        set coneOuterGain(de) {
                            if (de < 0 || de > 1)
                                throw t();
                            B.coneOuterGain = de
                        },
                        get context() {
                            return B.context
                        },
                        get distanceModel() {
                            return B.distanceModel
                        },
                        set distanceModel(de) {
                            B.distanceModel = de
                        },
                        get inputs() {
                            return [q]
                        },
                        get maxDistance() {
                            return B.maxDistance
                        },
                        set maxDistance(de) {
                            if (de < 0)
                                throw new RangeError;
                            B.maxDistance = de
                        },
                        get numberOfInputs() {
                            return B.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return B.numberOfOutputs
                        },
                        get orientationX() {
                            return Q.gain
                        },
                        get orientationY() {
                            return oe.gain
                        },
                        get orientationZ() {
                            return k.gain
                        },
                        get panningModel() {
                            return B.panningModel
                        },
                        set panningModel(de) {
                            B.panningModel = de
                        },
                        get positionX() {
                            return W.gain
                        },
                        get positionY() {
                            return V.gain
                        },
                        get positionZ() {
                            return Z.gain
                        },
                        get refDistance() {
                            return B.refDistance
                        },
                        set refDistance(de) {
                            if (de < 0)
                                throw new RangeError;
                            B.refDistance = de
                        },
                        get rolloffFactor() {
                            return B.rolloffFactor
                        },
                        set rolloffFactor(de) {
                            if (de < 0)
                                throw new RangeError;
                            B.rolloffFactor = de
                        },
                        addEventListener(...de) {
                            return q.addEventListener(de[0], de[1], de[2])
                        },
                        dispatchEvent(...de) {
                            return q.dispatchEvent(de[0])
                        },
                        removeEventListener(...de) {
                            return q.removeEventListener(de[0], de[1], de[2])
                        }
                    };
                    v !== K.coneInnerAngle && (K.coneInnerAngle = v),
                    y !== K.coneOuterAngle && (K.coneOuterAngle = y),
                    S !== K.coneOuterGain && (K.coneOuterGain = S),
                    A !== K.distanceModel && (K.distanceModel = A),
                    M !== K.maxDistance && (K.maxDistance = M),
                    x !== K.orientationX.value && (K.orientationX.value = x),
                    T !== K.orientationY.value && (K.orientationY.value = T),
                    D !== K.orientationZ.value && (K.orientationZ.value = D),
                    w !== K.panningModel && (K.panningModel = w),
                    U !== K.positionX.value && (K.positionX.value = U),
                    O !== K.positionY.value && (K.positionY.value = O),
                    L !== K.positionZ.value && (K.positionZ.value = L),
                    N !== K.refDistance && (K.refDistance = N),
                    z !== K.rolloffFactor && (K.rolloffFactor = z),
                    (H[0] !== 1 || H[1] !== 0 || H[2] !== 0) && B.setOrientation(...H),
                    (ie[0] !== 0 || ie[1] !== 0 || ie[2] !== 0) && B.setPosition(...ie);
                    const le = () => {
                        q.connect(B),
                        e(q, ee, 0, 0),
                        ee.connect(Q).connect(X, 0, 0),
                        ee.connect(oe).connect(X, 0, 1),
                        ee.connect(k).connect(X, 0, 2),
                        ee.connect(W).connect(X, 0, 3),
                        ee.connect(V).connect(X, 0, 4),
                        ee.connect(Z).connect(X, 0, 5),
                        X.connect(j).connect(m.destination)
                    }
                      , ue = () => {
                        q.disconnect(B),
                        c(q, ee, 0, 0),
                        ee.disconnect(Q),
                        Q.disconnect(X),
                        ee.disconnect(oe),
                        oe.disconnect(X),
                        ee.disconnect(k),
                        k.disconnect(X),
                        ee.disconnect(W),
                        W.disconnect(X),
                        ee.disconnect(V),
                        V.disconnect(X),
                        ee.disconnect(Z),
                        Z.disconnect(X),
                        X.disconnect(j),
                        j.disconnect(m.destination)
                    }
                    ;
                    return f(dm(K, B), le, ue)
                }
                  , Ak = e => (t, {disableNormalization: n, imag: i, real: s}) => {
                    const a = i instanceof Float32Array ? i : new Float32Array(i)
                      , o = s instanceof Float32Array ? s : new Float32Array(s)
                      , c = t.createPeriodicWave(o, a, {
                        disableNormalization: n
                    });
                    if (Array.from(i).length < 2)
                        throw e();
                    return c
                }
                  , d0 = (e, t, n, i) => e.createScriptProcessor(t, n, i)
                  , Tk = (e, t) => (n, i) => {
                    const s = i.channelCountMode;
                    if (s === "clamped-max")
                        throw t();
                    if (n.createStereoPanner === void 0)
                        return e(n, i);
                    const a = n.createStereoPanner();
                    return Ns(a, i),
                    Ki(a, i, "pan"),
                    Object.defineProperty(a, "channelCountMode", {
                        get: () => s,
                        set: o => {
                            if (o !== s)
                                throw t()
                        }
                    }),
                    a
                }
                  , Mk = (e, t, n, i, s, a) => {
                    const c = new Float32Array([1, 1])
                      , u = Math.PI / 2
                      , f = {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete"
                    }
                      , m = {
                        ...f,
                        oversample: "none"
                    }
                      , v = (A, M, x, T) => {
                        const D = new Float32Array(16385)
                          , w = new Float32Array(16385);
                        for (let I = 0; I < 16385; I += 1) {
                            const B = I / 16384 * u;
                            D[I] = Math.cos(B),
                            w[I] = Math.sin(B)
                        }
                        const U = n(A, {
                            ...f,
                            gain: 0
                        })
                          , O = i(A, {
                            ...m,
                            curve: D
                        })
                          , L = i(A, {
                            ...m,
                            curve: c
                        })
                          , N = n(A, {
                            ...f,
                            gain: 0
                        })
                          , z = i(A, {
                            ...m,
                            curve: w
                        });
                        return {
                            connectGraph() {
                                M.connect(U),
                                M.connect(L.inputs === void 0 ? L : L.inputs[0]),
                                M.connect(N),
                                L.connect(x),
                                x.connect(O.inputs === void 0 ? O : O.inputs[0]),
                                x.connect(z.inputs === void 0 ? z : z.inputs[0]),
                                O.connect(U.gain),
                                z.connect(N.gain),
                                U.connect(T, 0, 0),
                                N.connect(T, 0, 1)
                            },
                            disconnectGraph() {
                                M.disconnect(U),
                                M.disconnect(L.inputs === void 0 ? L : L.inputs[0]),
                                M.disconnect(N),
                                L.disconnect(x),
                                x.disconnect(O.inputs === void 0 ? O : O.inputs[0]),
                                x.disconnect(z.inputs === void 0 ? z : z.inputs[0]),
                                O.disconnect(U.gain),
                                z.disconnect(N.gain),
                                U.disconnect(T, 0, 0),
                                N.disconnect(T, 0, 1)
                            }
                        }
                    }
                      , y = (A, M, x, T) => {
                        const D = new Float32Array(16385)
                          , w = new Float32Array(16385)
                          , U = new Float32Array(16385)
                          , O = new Float32Array(16385)
                          , L = Math.floor(16385 / 2);
                        for (let W = 0; W < 16385; W += 1)
                            if (W > L) {
                                const V = (W - L) / (16384 - L) * u;
                                D[W] = Math.cos(V),
                                w[W] = Math.sin(V),
                                U[W] = 0,
                                O[W] = 1
                            } else {
                                const V = W / (16384 - L) * u;
                                D[W] = 1,
                                w[W] = 0,
                                U[W] = Math.cos(V),
                                O[W] = Math.sin(V)
                            }
                        const N = t(A, {
                            channelCount: 2,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: 2
                        })
                          , z = n(A, {
                            ...f,
                            gain: 0
                        })
                          , I = i(A, {
                            ...m,
                            curve: D
                        })
                          , B = n(A, {
                            ...f,
                            gain: 0
                        })
                          , G = i(A, {
                            ...m,
                            curve: w
                        })
                          , X = i(A, {
                            ...m,
                            curve: c
                        })
                          , q = n(A, {
                            ...f,
                            gain: 0
                        })
                          , Q = i(A, {
                            ...m,
                            curve: U
                        })
                          , oe = n(A, {
                            ...f,
                            gain: 0
                        })
                          , k = i(A, {
                            ...m,
                            curve: O
                        });
                        return {
                            connectGraph() {
                                M.connect(N),
                                M.connect(X.inputs === void 0 ? X : X.inputs[0]),
                                N.connect(z, 0),
                                N.connect(B, 0),
                                N.connect(q, 1),
                                N.connect(oe, 1),
                                X.connect(x),
                                x.connect(I.inputs === void 0 ? I : I.inputs[0]),
                                x.connect(G.inputs === void 0 ? G : G.inputs[0]),
                                x.connect(Q.inputs === void 0 ? Q : Q.inputs[0]),
                                x.connect(k.inputs === void 0 ? k : k.inputs[0]),
                                I.connect(z.gain),
                                G.connect(B.gain),
                                Q.connect(q.gain),
                                k.connect(oe.gain),
                                z.connect(T, 0, 0),
                                q.connect(T, 0, 0),
                                B.connect(T, 0, 1),
                                oe.connect(T, 0, 1)
                            },
                            disconnectGraph() {
                                M.disconnect(N),
                                M.disconnect(X.inputs === void 0 ? X : X.inputs[0]),
                                N.disconnect(z, 0),
                                N.disconnect(B, 0),
                                N.disconnect(q, 1),
                                N.disconnect(oe, 1),
                                X.disconnect(x),
                                x.disconnect(I.inputs === void 0 ? I : I.inputs[0]),
                                x.disconnect(G.inputs === void 0 ? G : G.inputs[0]),
                                x.disconnect(Q.inputs === void 0 ? Q : Q.inputs[0]),
                                x.disconnect(k.inputs === void 0 ? k : k.inputs[0]),
                                I.disconnect(z.gain),
                                G.disconnect(B.gain),
                                Q.disconnect(q.gain),
                                k.disconnect(oe.gain),
                                z.disconnect(T, 0, 0),
                                q.disconnect(T, 0, 0),
                                B.disconnect(T, 0, 1),
                                oe.disconnect(T, 0, 1)
                            }
                        }
                    }
                      , S = (A, M, x, T, D) => {
                        if (M === 1)
                            return v(A, x, T, D);
                        if (M === 2)
                            return y(A, x, T, D);
                        throw s()
                    }
                    ;
                    return (A, {channelCount: M, channelCountMode: x, pan: T, ...D}) => {
                        if (x === "max")
                            throw s();
                        const w = e(A, {
                            ...D,
                            channelCount: 1,
                            channelCountMode: x,
                            numberOfInputs: 2
                        })
                          , U = n(A, {
                            ...D,
                            channelCount: M,
                            channelCountMode: x,
                            gain: 1
                        })
                          , O = n(A, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            gain: T
                        });
                        let {connectGraph: L, disconnectGraph: N} = S(A, M, U, O, w);
                        Object.defineProperty(O.gain, "defaultValue", {
                            get: () => 0
                        }),
                        Object.defineProperty(O.gain, "maxValue", {
                            get: () => 1
                        }),
                        Object.defineProperty(O.gain, "minValue", {
                            get: () => -1
                        });
                        const z = {
                            get bufferSize() {},
                            get channelCount() {
                                return U.channelCount
                            },
                            set channelCount(X) {
                                U.channelCount !== X && (I && N(),
                                {connectGraph: L, disconnectGraph: N} = S(A, X, U, O, w),
                                I && L()),
                                U.channelCount = X
                            },
                            get channelCountMode() {
                                return U.channelCountMode
                            },
                            set channelCountMode(X) {
                                if (X === "clamped-max" || X === "max")
                                    throw s();
                                U.channelCountMode = X
                            },
                            get channelInterpretation() {
                                return U.channelInterpretation
                            },
                            set channelInterpretation(X) {
                                U.channelInterpretation = X
                            },
                            get context() {
                                return U.context
                            },
                            get inputs() {
                                return [U]
                            },
                            get numberOfInputs() {
                                return U.numberOfInputs
                            },
                            get numberOfOutputs() {
                                return U.numberOfOutputs
                            },
                            get pan() {
                                return O.gain
                            },
                            addEventListener(...X) {
                                return U.addEventListener(X[0], X[1], X[2])
                            },
                            dispatchEvent(...X) {
                                return U.dispatchEvent(X[0])
                            },
                            removeEventListener(...X) {
                                return U.removeEventListener(X[0], X[1], X[2])
                            }
                        };
                        let I = !1;
                        const B = () => {
                            L(),
                            I = !0
                        }
                          , G = () => {
                            N(),
                            I = !1
                        }
                        ;
                        return a(dm(z, w), B, G)
                    }
                }
                  , bk = (e, t, n, i, s, a, o) => (c, u) => {
                    const f = c.createWaveShaper();
                    if (a !== null && a.name === "webkitAudioContext" && c.createGain().gain.automationRate === void 0)
                        return n(c, u);
                    Ns(f, u);
                    const m = u.curve === null || u.curve instanceof Float32Array ? u.curve : new Float32Array(u.curve);
                    if (m !== null && m.length < 2)
                        throw t();
                    Ui(f, {
                        curve: m
                    }, "curve"),
                    Ui(f, u, "oversample");
                    let v = null
                      , y = !1;
                    return o(f, "curve", M => () => M.call(f), M => x => (M.call(f, x),
                    y && (i(x) && v === null ? v = e(c, f) : !i(x) && v !== null && (v(),
                    v = null)),
                    x)),
                    s(f, () => {
                        y = !0,
                        i(f.curve) && (v = e(c, f))
                    }
                    , () => {
                        y = !1,
                        v !== null && (v(),
                        v = null)
                    }
                    )
                }
                  , Ek = (e, t, n, i, s) => (a, {curve: o, oversample: c, ...u}) => {
                    const f = a.createWaveShaper()
                      , m = a.createWaveShaper();
                    Ns(f, u),
                    Ns(m, u);
                    const v = n(a, {
                        ...u,
                        gain: 1
                    })
                      , y = n(a, {
                        ...u,
                        gain: -1
                    })
                      , S = n(a, {
                        ...u,
                        gain: 1
                    })
                      , A = n(a, {
                        ...u,
                        gain: -1
                    });
                    let M = null
                      , x = !1
                      , T = null;
                    const D = {
                        get bufferSize() {},
                        get channelCount() {
                            return f.channelCount
                        },
                        set channelCount(O) {
                            v.channelCount = O,
                            y.channelCount = O,
                            f.channelCount = O,
                            S.channelCount = O,
                            m.channelCount = O,
                            A.channelCount = O
                        },
                        get channelCountMode() {
                            return f.channelCountMode
                        },
                        set channelCountMode(O) {
                            v.channelCountMode = O,
                            y.channelCountMode = O,
                            f.channelCountMode = O,
                            S.channelCountMode = O,
                            m.channelCountMode = O,
                            A.channelCountMode = O
                        },
                        get channelInterpretation() {
                            return f.channelInterpretation
                        },
                        set channelInterpretation(O) {
                            v.channelInterpretation = O,
                            y.channelInterpretation = O,
                            f.channelInterpretation = O,
                            S.channelInterpretation = O,
                            m.channelInterpretation = O,
                            A.channelInterpretation = O
                        },
                        get context() {
                            return f.context
                        },
                        get curve() {
                            return T
                        },
                        set curve(O) {
                            if (O !== null && O.length < 2)
                                throw t();
                            if (O === null)
                                f.curve = O,
                                m.curve = O;
                            else {
                                const L = O.length
                                  , N = new Float32Array(L + 2 - L % 2)
                                  , z = new Float32Array(L + 2 - L % 2);
                                N[0] = O[0],
                                z[0] = -O[L - 1];
                                const I = Math.ceil((L + 1) / 2)
                                  , B = (L + 1) / 2 - 1;
                                for (let G = 1; G < I; G += 1) {
                                    const X = G / I * B
                                      , q = Math.floor(X)
                                      , Q = Math.ceil(X);
                                    N[G] = q === Q ? O[q] : (1 - (X - q)) * O[q] + (1 - (Q - X)) * O[Q],
                                    z[G] = q === Q ? -O[L - 1 - q] : -((1 - (X - q)) * O[L - 1 - q]) - (1 - (Q - X)) * O[L - 1 - Q]
                                }
                                N[I] = L % 2 === 1 ? O[I - 1] : (O[I - 2] + O[I - 1]) / 2,
                                f.curve = N,
                                m.curve = z
                            }
                            T = O,
                            x && (i(T) && M === null ? M = e(a, v) : M !== null && (M(),
                            M = null))
                        },
                        get inputs() {
                            return [v]
                        },
                        get numberOfInputs() {
                            return f.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return f.numberOfOutputs
                        },
                        get oversample() {
                            return f.oversample
                        },
                        set oversample(O) {
                            f.oversample = O,
                            m.oversample = O
                        },
                        addEventListener(...O) {
                            return v.addEventListener(O[0], O[1], O[2])
                        },
                        dispatchEvent(...O) {
                            return v.dispatchEvent(O[0])
                        },
                        removeEventListener(...O) {
                            return v.removeEventListener(O[0], O[1], O[2])
                        }
                    };
                    o !== null && (D.curve = o instanceof Float32Array ? o : new Float32Array(o)),
                    c !== D.oversample && (D.oversample = c);
                    const w = () => {
                        v.connect(f).connect(S),
                        v.connect(y).connect(m).connect(A).connect(S),
                        x = !0,
                        i(T) && (M = e(a, v))
                    }
                      , U = () => {
                        v.disconnect(f),
                        f.disconnect(S),
                        v.disconnect(y),
                        y.disconnect(m),
                        m.disconnect(A),
                        A.disconnect(S),
                        x = !1,
                        M !== null && (M(),
                        M = null)
                    }
                    ;
                    return s(dm(D, S), w, U)
                }
                  , wa = () => new DOMException("","NotSupportedError")
                  , Ck = {
                    numberOfChannels: 1
                }
                  , wk = (e, t, n, i, s) => class extends e {
                    constructor(o, c, u) {
                        let f;
                        if (typeof o == "number" && c !== void 0 && u !== void 0)
                            f = {
                                length: c,
                                numberOfChannels: o,
                                sampleRate: u
                            };
                        else if (typeof o == "object")
                            f = o;
                        else
                            throw new Error("The given parameters are not valid.");
                        const {length: m, numberOfChannels: v, sampleRate: y} = {
                            ...Ck,
                            ...f
                        }
                          , S = i(v, m, y);
                        t(Jf, () => Jf(S)) || S.addEventListener("statechange", ( () => {
                            let A = 0;
                            const M = x => {
                                this._state === "running" && (A > 0 ? (S.removeEventListener("statechange", M),
                                x.stopImmediatePropagation(),
                                this._waitForThePromiseToSettle(x)) : A += 1)
                            }
                            ;
                            return M
                        }
                        )()),
                        super(S, v),
                        this._length = m,
                        this._nativeOfflineAudioContext = S,
                        this._state = null
                    }
                    get length() {
                        return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
                    }
                    get state() {
                        return this._state === null ? this._nativeOfflineAudioContext.state : this._state
                    }
                    startRendering() {
                        return this._state === "running" ? Promise.reject(n()) : (this._state = "running",
                        s(this.destination, this._nativeOfflineAudioContext).finally( () => {
                            this._state = null,
                            YS(this)
                        }
                        ))
                    }
                    _waitForThePromiseToSettle(o) {
                        this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(o) : setTimeout( () => this._waitForThePromiseToSettle(o))
                    }
                }
                  , Dk = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    detune: 0,
                    frequency: 440,
                    periodicWave: void 0,
                    type: "sine"
                }
                  , Rk = (e, t, n, i, s, a, o) => class extends e {
                    constructor(u, f) {
                        const m = s(u)
                          , v = {
                            ...Dk,
                            ...f
                        }
                          , y = n(m, v)
                          , S = a(m)
                          , A = S ? i() : null
                          , M = u.sampleRate / 2;
                        super(u, !1, y, A),
                        this._detune = t(this, S, y.detune, 153600, -153600),
                        this._frequency = t(this, S, y.frequency, M, -M),
                        this._nativeOscillatorNode = y,
                        this._onended = null,
                        this._oscillatorNodeRenderer = A,
                        this._oscillatorNodeRenderer !== null && v.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = v.periodicWave)
                    }
                    get detune() {
                        return this._detune
                    }
                    get frequency() {
                        return this._frequency
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(u) {
                        const f = typeof u == "function" ? o(this, u) : null;
                        this._nativeOscillatorNode.onended = f;
                        const m = this._nativeOscillatorNode.onended;
                        this._onended = m !== null && m === f ? u : m
                    }
                    get type() {
                        return this._nativeOscillatorNode.type
                    }
                    set type(u) {
                        this._nativeOscillatorNode.type = u,
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null)
                    }
                    setPeriodicWave(u) {
                        this._nativeOscillatorNode.setPeriodicWave(u),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = u)
                    }
                    start(u=0) {
                        if (this._nativeOscillatorNode.start(u),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = u),
                        this.context.state !== "closed") {
                            hm(this);
                            const f = () => {
                                this._nativeOscillatorNode.removeEventListener("ended", f),
                                uu(this) && l0(this)
                            }
                            ;
                            this._nativeOscillatorNode.addEventListener("ended", f)
                        }
                    }
                    stop(u=0) {
                        this._nativeOscillatorNode.stop(u),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = u)
                    }
                }
                  , Uk = (e, t, n, i, s) => () => {
                    const a = new WeakMap;
                    let o = null
                      , c = null
                      , u = null;
                    const f = async (m, v) => {
                        let y = n(m);
                        const S = Ca(y, v);
                        if (!S) {
                            const A = {
                                channelCount: y.channelCount,
                                channelCountMode: y.channelCountMode,
                                channelInterpretation: y.channelInterpretation,
                                detune: y.detune.value,
                                frequency: y.frequency.value,
                                periodicWave: o === null ? void 0 : o,
                                type: y.type
                            };
                            y = t(v, A),
                            c !== null && y.start(c),
                            u !== null && y.stop(u)
                        }
                        return a.set(v, y),
                        S ? (await e(v, m.detune, y.detune),
                        await e(v, m.frequency, y.frequency)) : (await i(v, m.detune, y.detune),
                        await i(v, m.frequency, y.frequency)),
                        await s(m, v, y),
                        y
                    }
                    ;
                    return {
                        set periodicWave(m) {
                            o = m
                        },
                        set start(m) {
                            c = m
                        },
                        set stop(m) {
                            u = m
                        },
                        render(m, v) {
                            const y = a.get(v);
                            return y !== void 0 ? Promise.resolve(y) : f(m, v)
                        }
                    }
                }
                  , Ok = {
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    coneInnerAngle: 360,
                    coneOuterAngle: 360,
                    coneOuterGain: 0,
                    distanceModel: "inverse",
                    maxDistance: 1e4,
                    orientationX: 1,
                    orientationY: 0,
                    orientationZ: 0,
                    panningModel: "equalpower",
                    positionX: 0,
                    positionY: 0,
                    positionZ: 0,
                    refDistance: 1,
                    rolloffFactor: 1
                }
                  , Nk = (e, t, n, i, s, a, o) => class extends e {
                    constructor(u, f) {
                        const m = s(u)
                          , v = {
                            ...Ok,
                            ...f
                        }
                          , y = n(m, v)
                          , S = a(m)
                          , A = S ? i() : null;
                        super(u, !1, y, A),
                        this._nativePannerNode = y,
                        this._orientationX = t(this, S, y.orientationX, rr, Mr),
                        this._orientationY = t(this, S, y.orientationY, rr, Mr),
                        this._orientationZ = t(this, S, y.orientationZ, rr, Mr),
                        this._positionX = t(this, S, y.positionX, rr, Mr),
                        this._positionY = t(this, S, y.positionY, rr, Mr),
                        this._positionZ = t(this, S, y.positionZ, rr, Mr),
                        o(this, 1)
                    }
                    get coneInnerAngle() {
                        return this._nativePannerNode.coneInnerAngle
                    }
                    set coneInnerAngle(u) {
                        this._nativePannerNode.coneInnerAngle = u
                    }
                    get coneOuterAngle() {
                        return this._nativePannerNode.coneOuterAngle
                    }
                    set coneOuterAngle(u) {
                        this._nativePannerNode.coneOuterAngle = u
                    }
                    get coneOuterGain() {
                        return this._nativePannerNode.coneOuterGain
                    }
                    set coneOuterGain(u) {
                        this._nativePannerNode.coneOuterGain = u
                    }
                    get distanceModel() {
                        return this._nativePannerNode.distanceModel
                    }
                    set distanceModel(u) {
                        this._nativePannerNode.distanceModel = u
                    }
                    get maxDistance() {
                        return this._nativePannerNode.maxDistance
                    }
                    set maxDistance(u) {
                        this._nativePannerNode.maxDistance = u
                    }
                    get orientationX() {
                        return this._orientationX
                    }
                    get orientationY() {
                        return this._orientationY
                    }
                    get orientationZ() {
                        return this._orientationZ
                    }
                    get panningModel() {
                        return this._nativePannerNode.panningModel
                    }
                    set panningModel(u) {
                        this._nativePannerNode.panningModel = u
                    }
                    get positionX() {
                        return this._positionX
                    }
                    get positionY() {
                        return this._positionY
                    }
                    get positionZ() {
                        return this._positionZ
                    }
                    get refDistance() {
                        return this._nativePannerNode.refDistance
                    }
                    set refDistance(u) {
                        this._nativePannerNode.refDistance = u
                    }
                    get rolloffFactor() {
                        return this._nativePannerNode.rolloffFactor
                    }
                    set rolloffFactor(u) {
                        this._nativePannerNode.rolloffFactor = u
                    }
                }
                  , Bk = (e, t, n, i, s, a, o, c, u, f) => () => {
                    const m = new WeakMap;
                    let v = null;
                    const y = async (S, A) => {
                        let M = null
                          , x = a(S);
                        const T = {
                            channelCount: x.channelCount,
                            channelCountMode: x.channelCountMode,
                            channelInterpretation: x.channelInterpretation
                        }
                          , D = {
                            ...T,
                            coneInnerAngle: x.coneInnerAngle,
                            coneOuterAngle: x.coneOuterAngle,
                            coneOuterGain: x.coneOuterGain,
                            distanceModel: x.distanceModel,
                            maxDistance: x.maxDistance,
                            panningModel: x.panningModel,
                            refDistance: x.refDistance,
                            rolloffFactor: x.rolloffFactor
                        }
                          , w = Ca(x, A);
                        if ("bufferSize"in x)
                            M = i(A, {
                                ...T,
                                gain: 1
                            });
                        else if (!w) {
                            const U = {
                                ...D,
                                orientationX: x.orientationX.value,
                                orientationY: x.orientationY.value,
                                orientationZ: x.orientationZ.value,
                                positionX: x.positionX.value,
                                positionY: x.positionY.value,
                                positionZ: x.positionZ.value
                            };
                            x = s(A, U)
                        }
                        if (m.set(A, M === null ? x : M),
                        M !== null) {
                            if (v === null) {
                                if (o === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const G = new o(6,S.context.length,A.sampleRate)
                                  , X = t(G, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: 6
                                });
                                X.connect(G.destination),
                                v = (async () => {
                                    const q = await Promise.all([S.orientationX, S.orientationY, S.orientationZ, S.positionX, S.positionY, S.positionZ].map(async (Q, oe) => {
                                        const k = n(G, {
                                            channelCount: 1,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            offset: oe === 0 ? 1 : 0
                                        });
                                        return await c(G, Q, k.offset),
                                        k
                                    }
                                    ));
                                    for (let Q = 0; Q < 6; Q += 1)
                                        q[Q].connect(X, 0, Q),
                                        q[Q].start(0);
                                    return f(G)
                                }
                                )()
                            }
                            const U = await v
                              , O = i(A, {
                                ...T,
                                gain: 1
                            });
                            await u(S, A, O);
                            const L = [];
                            for (let G = 0; G < U.numberOfChannels; G += 1)
                                L.push(U.getChannelData(G));
                            let N = [L[0][0], L[1][0], L[2][0]]
                              , z = [L[3][0], L[4][0], L[5][0]]
                              , I = i(A, {
                                ...T,
                                gain: 1
                            })
                              , B = s(A, {
                                ...D,
                                orientationX: N[0],
                                orientationY: N[1],
                                orientationZ: N[2],
                                positionX: z[0],
                                positionY: z[1],
                                positionZ: z[2]
                            });
                            O.connect(I).connect(B.inputs[0]),
                            B.connect(M);
                            for (let G = 128; G < U.length; G += 128) {
                                const X = [L[0][G], L[1][G], L[2][G]]
                                  , q = [L[3][G], L[4][G], L[5][G]];
                                if (X.some( (Q, oe) => Q !== N[oe]) || q.some( (Q, oe) => Q !== z[oe])) {
                                    N = X,
                                    z = q;
                                    const Q = G / A.sampleRate;
                                    I.gain.setValueAtTime(0, Q),
                                    I = i(A, {
                                        ...T,
                                        gain: 0
                                    }),
                                    B = s(A, {
                                        ...D,
                                        orientationX: N[0],
                                        orientationY: N[1],
                                        orientationZ: N[2],
                                        positionX: z[0],
                                        positionY: z[1],
                                        positionZ: z[2]
                                    }),
                                    I.gain.setValueAtTime(1, Q),
                                    O.connect(I).connect(B.inputs[0]),
                                    B.connect(M)
                                }
                            }
                            return M
                        }
                        return w ? (await e(A, S.orientationX, x.orientationX),
                        await e(A, S.orientationY, x.orientationY),
                        await e(A, S.orientationZ, x.orientationZ),
                        await e(A, S.positionX, x.positionX),
                        await e(A, S.positionY, x.positionY),
                        await e(A, S.positionZ, x.positionZ)) : (await c(A, S.orientationX, x.orientationX),
                        await c(A, S.orientationY, x.orientationY),
                        await c(A, S.orientationZ, x.orientationZ),
                        await c(A, S.positionX, x.positionX),
                        await c(A, S.positionY, x.positionY),
                        await c(A, S.positionZ, x.positionZ)),
                        fm(x) ? await u(S, A, x.inputs[0]) : await u(S, A, x),
                        x
                    }
                    ;
                    return {
                        render(S, A) {
                            const M = m.get(A);
                            return M !== void 0 ? Promise.resolve(M) : y(S, A)
                        }
                    }
                }
                  , Lk = {
                    disableNormalization: !1
                }
                  , Ik = (e, t, n, i) => class GU {
                    constructor(a, o) {
                        const c = t(a)
                          , u = i({
                            ...Lk,
                            ...o
                        })
                          , f = e(c, u);
                        return n.add(f),
                        f
                    }
                    static[Symbol.hasInstance](a) {
                        return a !== null && typeof a == "object" && Object.getPrototypeOf(a) === GU.prototype || n.has(a)
                    }
                }
                  , Pk = (e, t) => (n, i, s) => (e(i).replay(s),
                t(i, n, s))
                  , zk = (e, t, n) => async (i, s, a) => {
                    const o = e(i);
                    await Promise.all(o.activeInputs.map( (c, u) => Array.from(c).map(async ([f,m]) => {
                        const v = await t(f).render(f, s)
                          , y = i.context.destination;
                        !n(f) && (i !== y || !n(i)) && v.connect(a, m, u)
                    }
                    )).reduce( (c, u) => [...c, ...u], []))
                }
                  , Fk = (e, t, n) => async (i, s, a) => {
                    const o = t(i);
                    await Promise.all(Array.from(o.activeInputs).map(async ([c,u]) => {
                        const f = await e(c).render(c, s);
                        n(c) || f.connect(a, u)
                    }
                    ))
                }
                  , Hk = (e, t, n, i) => s => e(Jf, () => Jf(s)) ? Promise.resolve(e(i, i)).then(a => {
                    if (!a) {
                        const o = n(s, 512, 0, 1);
                        s.oncomplete = () => {
                            o.onaudioprocess = null,
                            o.disconnect()
                        }
                        ,
                        o.onaudioprocess = () => s.currentTime,
                        o.connect(s.destination)
                    }
                    return s.startRendering()
                }
                ) : new Promise(a => {
                    const o = t(s, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    s.oncomplete = c => {
                        o.disconnect(),
                        a(c.renderedBuffer)
                    }
                    ,
                    o.connect(s.destination),
                    s.startRendering()
                }
                )
                  , Gk = e => (t, n) => {
                    e.set(t, n)
                }
                  , Vk = e => (t, n) => e.set(t, n)
                  , kk = (e, t, n, i, s, a, o, c) => (u, f) => n(u).render(u, f).then( () => Promise.all(Array.from(i(f)).map(m => n(m).render(m, f)))).then( () => s(f)).then(m => (typeof m.copyFromChannel != "function" ? (o(m),
                VM(m)) : t(a, () => a(m)) || c(m),
                e.add(m),
                m))
                  , Xk = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    pan: 0
                }
                  , Wk = (e, t, n, i, s, a) => class extends e {
                    constructor(c, u) {
                        const f = s(c)
                          , m = {
                            ...Xk,
                            ...u
                        }
                          , v = n(f, m)
                          , y = a(f)
                          , S = y ? i() : null;
                        super(c, !1, v, S),
                        this._pan = t(this, y, v.pan)
                    }
                    get pan() {
                        return this._pan
                    }
                }
                  , Yk = (e, t, n, i, s) => () => {
                    const a = new WeakMap
                      , o = async (c, u) => {
                        let f = n(c);
                        const m = Ca(f, u);
                        if (!m) {
                            const v = {
                                channelCount: f.channelCount,
                                channelCountMode: f.channelCountMode,
                                channelInterpretation: f.channelInterpretation,
                                pan: f.pan.value
                            };
                            f = t(u, v)
                        }
                        return a.set(u, f),
                        m ? await e(u, c.pan, f.pan) : await i(u, c.pan, f.pan),
                        fm(f) ? await s(c, u, f.inputs[0]) : await s(c, u, f),
                        f
                    }
                    ;
                    return {
                        render(c, u) {
                            const f = a.get(u);
                            return f !== void 0 ? Promise.resolve(f) : o(c, u)
                        }
                    }
                }
                  , qk = e => () => {
                    if (e === null)
                        return !1;
                    try {
                        new e({
                            length: 1,
                            sampleRate: 44100
                        })
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , jk = (e, t) => async () => {
                    if (e === null)
                        return !0;
                    if (t === null)
                        return !1;
                    const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{
                        type: "application/javascript; charset=utf-8"
                    })
                      , i = new t(1,128,44100)
                      , s = URL.createObjectURL(n);
                    let a = !1
                      , o = !1;
                    try {
                        await i.audioWorklet.addModule(s);
                        const c = new e(i,"a",{
                            numberOfOutputs: 0
                        })
                          , u = i.createOscillator();
                        c.port.onmessage = () => a = !0,
                        c.onprocessorerror = () => o = !0,
                        u.connect(c),
                        u.start(0),
                        await i.startRendering(),
                        await new Promise(f => setTimeout(f))
                    } catch {} finally {
                        URL.revokeObjectURL(s)
                    }
                    return a && !o
                }
                  , Qk = (e, t) => () => {
                    if (t === null)
                        return Promise.resolve(!1);
                    const n = new t(1,1,44100)
                      , i = e(n, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    return new Promise(s => {
                        n.oncomplete = () => {
                            i.disconnect(),
                            s(n.currentTime !== 0)
                        }
                        ,
                        n.startRendering()
                    }
                    )
                }
                  , DR = () => new DOMException("","UnknownError")
                  , Zk = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    curve: null,
                    oversample: "none"
                }
                  , Kk = (e, t, n, i, s, a, o) => class extends e {
                    constructor(u, f) {
                        const m = s(u)
                          , v = {
                            ...Zk,
                            ...f
                        }
                          , y = n(m, v)
                          , S = a(m) ? i() : null;
                        super(u, !0, y, S),
                        this._isCurveNullified = !1,
                        this._nativeWaveShaperNode = y,
                        o(this, 1)
                    }
                    get curve() {
                        return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve
                    }
                    set curve(u) {
                        if (u === null)
                            this._isCurveNullified = !0,
                            this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
                        else {
                            if (u.length < 2)
                                throw t();
                            this._isCurveNullified = !1,
                            this._nativeWaveShaperNode.curve = u
                        }
                    }
                    get oversample() {
                        return this._nativeWaveShaperNode.oversample
                    }
                    set oversample(u) {
                        this._nativeWaveShaperNode.oversample = u
                    }
                }
                  , Jk = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (a, o) => {
                        let c = t(a);
                        if (!Ca(c, o)) {
                            const u = {
                                channelCount: c.channelCount,
                                channelCountMode: c.channelCountMode,
                                channelInterpretation: c.channelInterpretation,
                                curve: c.curve,
                                oversample: c.oversample
                            };
                            c = e(o, u)
                        }
                        return i.set(o, c),
                        fm(c) ? await n(a, o, c.inputs[0]) : await n(a, o, c),
                        c
                    }
                    ;
                    return {
                        render(a, o) {
                            const c = i.get(o);
                            return c !== void 0 ? Promise.resolve(c) : s(a, o)
                        }
                    }
                }
                  , $k = () => typeof window > "u" ? null : window
                  , e8 = (e, t) => n => {
                    n.copyFromChannel = (i, s, a=0) => {
                        const o = e(a)
                          , c = e(s);
                        if (c >= n.numberOfChannels)
                            throw t();
                        const u = n.length
                          , f = n.getChannelData(c)
                          , m = i.length;
                        for (let v = o < 0 ? -o : 0; v + o < u && v < m; v += 1)
                            i[v] = f[v + o]
                    }
                    ,
                    n.copyToChannel = (i, s, a=0) => {
                        const o = e(a)
                          , c = e(s);
                        if (c >= n.numberOfChannels)
                            throw t();
                        const u = n.length
                          , f = n.getChannelData(c)
                          , m = i.length;
                        for (let v = o < 0 ? -o : 0; v + o < u && v < m; v += 1)
                            f[v + o] = i[v]
                    }
                }
                  , t8 = e => t => {
                    t.copyFromChannel = (n => (i, s, a=0) => {
                        const o = e(a)
                          , c = e(s);
                        if (o < t.length)
                            return n.call(t, i, c, o)
                    }
                    )(t.copyFromChannel),
                    t.copyToChannel = (n => (i, s, a=0) => {
                        const o = e(a)
                          , c = e(s);
                        if (o < t.length)
                            return n.call(t, i, c, o)
                    }
                    )(t.copyToChannel)
                }
                  , n8 = e => (t, n) => {
                    const i = n.createBuffer(1, 1, 44100);
                    t.buffer === null && (t.buffer = i),
                    e(t, "buffer", s => () => {
                        const a = s.call(t);
                        return a === i ? null : a
                    }
                    , s => a => s.call(t, a === null ? i : a))
                }
                  , i8 = (e, t) => (n, i) => {
                    i.channelCount = 1,
                    i.channelCountMode = "explicit",
                    Object.defineProperty(i, "channelCount", {
                        get: () => 1,
                        set: () => {
                            throw e()
                        }
                    }),
                    Object.defineProperty(i, "channelCountMode", {
                        get: () => "explicit",
                        set: () => {
                            throw e()
                        }
                    });
                    const s = n.createBufferSource();
                    t(i, () => {
                        const c = i.numberOfInputs;
                        for (let u = 0; u < c; u += 1)
                            s.connect(i, 0, u)
                    }
                    , () => s.disconnect(i))
                }
                  , RR = (e, t, n) => e.copyFromChannel === void 0 ? e.getChannelData(n)[0] : (e.copyFromChannel(t, n),
                t[0])
                  , UR = e => {
                    if (e === null)
                        return !1;
                    const t = e.length;
                    return t % 2 !== 0 ? e[Math.floor(t / 2)] !== 0 : e[t / 2 - 1] + e[t / 2] !== 0
                }
                  , p0 = (e, t, n, i) => {
                    let s = e;
                    for (; !s.hasOwnProperty(t); )
                        s = Object.getPrototypeOf(s);
                    const {get: a, set: o} = Object.getOwnPropertyDescriptor(s, t);
                    Object.defineProperty(e, t, {
                        get: n(a),
                        set: i(o)
                    })
                }
                  , s8 = e => ({
                    ...e,
                    outputChannelCount: e.outputChannelCount !== void 0 ? e.outputChannelCount : e.numberOfInputs === 1 && e.numberOfOutputs === 1 ? [e.channelCount] : Array.from({
                        length: e.numberOfOutputs
                    }, () => 1)
                })
                  , a8 = e => ({
                    ...e,
                    channelCount: e.numberOfOutputs
                })
                  , r8 = e => {
                    const {imag: t, real: n} = e;
                    return t === void 0 ? n === void 0 ? {
                        ...e,
                        imag: [0, 0],
                        real: [0, 0]
                    } : {
                        ...e,
                        imag: Array.from(n, () => 0),
                        real: n
                    } : n === void 0 ? {
                        ...e,
                        imag: t,
                        real: Array.from(t, () => 0)
                    } : {
                        ...e,
                        imag: t,
                        real: n
                    }
                }
                  , OR = (e, t, n) => {
                    try {
                        e.setValueAtTime(t, n)
                    } catch (i) {
                        if (i.code !== 9)
                            throw i;
                        OR(e, t, n + 1e-7)
                    }
                }
                  , o8 = e => {
                    const t = e.createBufferSource();
                    t.start();
                    try {
                        t.start()
                    } catch {
                        return !0
                    }
                    return !1
                }
                  , l8 = e => {
                    const t = e.createBufferSource();
                    t.buffer = e.createBuffer(1, 1, 44100);
                    try {
                        t.start(0, 1)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , c8 = e => {
                    const t = e.createBufferSource();
                    t.start();
                    try {
                        t.stop()
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , QM = e => {
                    const t = e.createOscillator();
                    try {
                        t.start(-1)
                    } catch (n) {
                        return n instanceof RangeError
                    }
                    return !1
                }
                  , NR = e => {
                    const t = e.createBuffer(1, 1, 44100)
                      , n = e.createBufferSource();
                    n.buffer = t,
                    n.start(),
                    n.stop();
                    try {
                        return n.stop(),
                        !0
                    } catch {
                        return !1
                    }
                }
                  , ZM = e => {
                    const t = e.createOscillator();
                    try {
                        t.stop(-1)
                    } catch (n) {
                        return n instanceof RangeError
                    }
                    return !1
                }
                  , u8 = e => {
                    const {port1: t, port2: n} = new MessageChannel;
                    try {
                        t.postMessage(e)
                    } finally {
                        t.close(),
                        n.close()
                    }
                }
                  , h8 = e => {
                    e.start = (t => (n=0, i=0, s) => {
                        const a = e.buffer
                          , o = a === null ? i : Math.min(a.duration, i);
                        a !== null && o > a.duration - .5 / e.context.sampleRate ? t.call(e, n, 0, 0) : t.call(e, n, o, s)
                    }
                    )(e.start)
                }
                  , BR = (e, t) => {
                    const n = t.createGain();
                    e.connect(n);
                    const i = (s => () => {
                        s.call(e, n),
                        e.removeEventListener("ended", i)
                    }
                    )(e.disconnect);
                    e.addEventListener("ended", i),
                    dm(e, n),
                    e.stop = (s => {
                        let a = !1;
                        return (o=0) => {
                            if (a)
                                try {
                                    s.call(e, o)
                                } catch {
                                    n.gain.setValueAtTime(0, o)
                                }
                            else
                                s.call(e, o),
                                a = !0
                        }
                    }
                    )(e.stop)
                }
                  , pm = (e, t) => n => {
                    const i = {
                        value: e
                    };
                    return Object.defineProperties(n, {
                        currentTarget: i,
                        target: i
                    }),
                    typeof t == "function" ? t.call(e, n) : t.handleEvent.call(e, n)
                }
                ;
                var $f = _r(nR());
                const f8 = UG(Zf)
                  , d8 = PG(Zf)
                  , p8 = j6(XS)
                  , LR = new WeakMap
                  , m8 = fV(LR)
                  , Oo = M6(new Map, new WeakMap)
                  , fc = $k()
                  , IR = WV(Oo, hc)
                  , KM = hV(or)
                  , aa = zk(or, KM, Kf)
                  , v8 = VG(IR, xi, aa)
                  , yi = mV(kS)
                  , hu = yk(fc)
                  , li = OV(hu)
                  , PR = new WeakMap
                  , zR = sV(pm)
                  , mm = QV(fc)
                  , JM = wV(mm)
                  , $M = DV(fc)
                  , FR = RV(fc)
                  , m0 = KV(fc)
                  , os = f6(OG(iR), IG(f8, d8, jS, p8, QS, or, m8, o0, xi, Zf, uu, Kf, ZS), Oo, TV(zM, QS, or, xi, h0, uu), hc, tx, wa, X6(jS, zM, or, xi, h0, yi, uu, li), K6(PR, or, pl), zR, yi, JM, $M, FR, li, m0)
                  , g8 = GG(os, v8, hc, IR, yi, li)
                  , eb = new WeakSet
                  , HR = YV(fc)
                  , GR = P6(new Uint32Array(1))
                  , tb = e8(GR, hc)
                  , nb = t8(GR)
                  , VR = XG(eb, Oo, wa, HR, hu, qk(HR), tb, nb)
                  , nx = zG(br)
                  , kR = Fk(KM, c0, Kf)
                  , dc = U6(kR)
                  , vm = jV(nx, Oo, o8, l8, c8, QM, NR, ZM, h8, n8(p0), BR)
                  , pc = Pk(dV(c0), kR)
                  , y8 = qG(dc, vm, xi, pc, aa)
                  , ml = d6(NG(sR), PR, PM, p6, $f.createCancelAndHoldAutomationEvent, $f.createCancelScheduledValuesAutomationEvent, $f.createExponentialRampToValueAutomationEvent, $f.createLinearRampToValueAutomationEvent, $f.createSetTargetAutomationEvent, $f.createSetValueAutomationEvent, $f.createSetValueCurveAutomationEvent, mm, OR)
                  , _8 = YG(os, y8, ml, vs, vm, yi, li, pm)
                  , S8 = t6(os, n6, hc, vs, ZV(br, p0), yi, li, aa)
                  , x8 = T6(dc, ER, xi, pc, aa)
                  , ed = Vk(LR)
                  , A8 = A6(os, ml, x8, tx, ER, yi, li, ed)
                  , Ah = kV(Zf, $M)
                  , T8 = i8(vs, Ah)
                  , Th = sk(mm, T8)
                  , M8 = C6(Th, xi, aa)
                  , b8 = E6(os, M8, Th, yi, li)
                  , E8 = R6(f0, xi, aa)
                  , C8 = D6(os, E8, f0, yi, li, a8)
                  , w8 = ok(nx, vm, br, Ah)
                  , gm = rk(nx, Oo, w8, QM, ZM)
                  , D8 = I6(dc, gm, xi, pc, aa)
                  , R8 = L6(os, ml, D8, gm, yi, li, pm)
                  , XR = lk(wa, p0)
                  , U8 = H6(XR, xi, aa)
                  , O8 = F6(os, U8, XR, yi, li, ed)
                  , N8 = q6(dc, CR, xi, pc, aa)
                  , B8 = Y6(os, ml, N8, CR, yi, li, ed)
                  , WR = ck(wa)
                  , L8 = tV(dc, WR, xi, pc, aa)
                  , I8 = eV(os, ml, L8, WR, wa, yi, li, ed)
                  , P8 = cV(dc, br, xi, pc, aa)
                  , z8 = lV(os, ml, P8, br, yi, li)
                  , F8 = dk(tx, vs, d0, wa)
                  , ix = Hk(Oo, br, d0, Qk(br, hu))
                  , H8 = AV(vm, xi, hu, aa, ix)
                  , G8 = uk(F8)
                  , V8 = SV(os, G8, H8, yi, li, ed)
                  , k8 = i6(ml, Th, gm, d0, wa, RR, li, p0)
                  , YR = new WeakMap
                  , ib = HV(S8, k8, zR, li, YR, pm)
                  , qR = _k(nx, Oo, QM, NR, ZM, BR)
                  , X8 = Uk(dc, qR, xi, pc, aa)
                  , W8 = Rk(os, ml, qR, X8, yi, li, pm)
                  , jR = N6(vm)
                  , Y8 = Ek(jR, vs, br, UR, Ah)
                  , sx = bk(jR, vs, Y8, UR, Ah, mm, p0)
                  , q8 = xk(jS, vs, Th, br, d0, sx, wa, QS, RR, Ah)
                  , QR = Sk(q8)
                  , j8 = Bk(dc, Th, gm, br, QR, xi, hu, pc, aa, ix)
                  , Q8 = Nk(os, ml, QR, j8, yi, li, ed)
                  , Z8 = Ak(hc)
                  , K8 = Ik(Z8, yi, new WeakSet, r8)
                  , J8 = Mk(Th, f0, br, sx, wa, Ah)
                  , ZR = Tk(J8, wa)
                  , $8 = Yk(dc, ZR, xi, pc, aa)
                  , e7 = Wk(os, ml, ZR, $8, yi, li)
                  , t7 = Jk(sx, xi, aa)
                  , n7 = Kk(os, vs, sx, t7, yi, li, ed)
                  , KR = NV(fc)
                  , sb = aV(fc)
                  , JR = new WeakMap
                  , i7 = vV(JR, hu)
                  , s7 = KR ? LG(Oo, wa, iV(fc), sb, rV(RG), yi, i7, li, m0, new WeakMap, new WeakMap, jk(m0, hu), fc) : void 0
                  , a7 = UV(JM, li)
                  , r7 = k6(eb, Oo, V6, nV, new WeakSet, yi, a7, WS, Jf, tb, nb)
                  , $R = S6(s7, g8, VR, _8, A8, b8, C8, R8, O8, r7, B8, I8, z8, V8, ib, W8, Q8, K8, e7, n7)
                  , o7 = BV(os, pk, yi, li)
                  , l7 = IV(os, mk, yi, li)
                  , c7 = PV(os, vk, yi, li)
                  , u7 = gk(vs, li)
                  , h7 = zV(os, u7, yi)
                  , f7 = e6($R, vs, wa, DR, o7, l7, c7, h7, mm)
                  , ab = gV(YR)
                  , d7 = FG(ab)
                  , e3 = O6(hc)
                  , p7 = Q6(ab)
                  , t3 = J6(hc)
                  , n3 = new WeakMap
                  , m7 = uV(n3, pl)
                  , v7 = ik(e3, hc, vs, Th, f0, gm, br, d0, wa, t3, sb, m7, Ah)
                  , g7 = $V(vs, v7, br, wa, Ah)
                  , y7 = _6(dc, e3, vm, Th, f0, gm, br, p7, t3, sb, xi, m0, hu, pc, aa, ix)
                  , _7 = pV(JR)
                  , S7 = Gk(n3)
                  , i3 = KR ? v6(d7, os, ml, y7, g7, or, _7, yi, li, m0, s8, S7, u8, pm) : void 0
                  , $W = FV(vs, wa, DR, ib, mm)
                  , s3 = G6(wa, hu)
                  , a3 = kk(eb, Oo, KM, ab, ix, WS, tb, nb)
                  , eY = VV(Oo, vs, s3, ib, a3)
                  , x7 = wk($R, Oo, vs, s3, a3)
                  , A7 = MV(kS, JM)
                  , T7 = bV(IM, $M)
                  , M7 = EV(PM, FR)
                  , b7 = CV(kS, li);
                function No(e) {
                    return e === void 0
                }
                function Tn(e) {
                    return e !== void 0
                }
                function E7(e) {
                    return typeof e == "function"
                }
                function td(e) {
                    return typeof e == "number"
                }
                function nd(e) {
                    return Object.prototype.toString.call(e) === "[object Object]" && e.constructor === Object
                }
                function C7(e) {
                    return typeof e == "boolean"
                }
                function vl(e) {
                    return Array.isArray(e)
                }
                function fu(e) {
                    return typeof e == "string"
                }
                function ax(e) {
                    return fu(e) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(e)
                }
                function fn(e, t) {
                    if (!e)
                        throw new Error(t)
                }
                function Mh(e, t, n=1 / 0) {
                    if (!(t <= e && e <= n))
                        throw new RangeError(`Value must be within [${t}, ${n}], got: ${e}`)
                }
                function r3(e) {
                    !e.isOffline && e.state !== "running" && rb('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')
                }
                let o3 = !1
                  , l3 = !1;
                function c3(e) {
                    o3 = e
                }
                function w7(e) {
                    No(e) && o3 && !l3 && (l3 = !0,
                    rb("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"))
                }
                let u3 = console;
                function D7(...e) {
                    u3.log(...e)
                }
                function rb(...e) {
                    u3.warn(...e)
                }
                function R7(e) {
                    return new f7(e)
                }
                function U7(e, t, n) {
                    return new x7(e,t,n)
                }
                const $r = typeof self == "object" ? self : null
                  , O7 = $r && ($r.hasOwnProperty("AudioContext") || $r.hasOwnProperty("webkitAudioContext"));
                function N7(e, t, n) {
                    return fn(Tn(i3), "AudioWorkletNode only works in a secure context (https or localhost)"),
                    new (e instanceof $r?.BaseAudioContext ? $r?.AudioWorkletNode : i3)(e,t,n)
                }
                function gl(e, t, n, i) {
                    var s = arguments.length, a = s < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, n) : i, o;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        a = Reflect.decorate(e, t, n, i);
                    else
                        for (var c = e.length - 1; c >= 0; c--)
                            (o = e[c]) && (a = (s < 3 ? o(a) : s > 3 ? o(t, n, a) : o(t, n)) || a);
                    return s > 3 && a && Object.defineProperty(t, n, a),
                    a
                }
                function gs(e, t, n, i) {
                    function s(a) {
                        return a instanceof n ? a : new n(function(o) {
                            o(a)
                        }
                        )
                    }
                    return new (n || (n = Promise))(function(a, o) {
                        function c(m) {
                            try {
                                f(i.next(m))
                            } catch (v) {
                                o(v)
                            }
                        }
                        function u(m) {
                            try {
                                f(i.throw(m))
                            } catch (v) {
                                o(v)
                            }
                        }
                        function f(m) {
                            m.done ? a(m.value) : s(m.value).then(c, u)
                        }
                        f((i = i.apply(e, t || [])).next())
                    }
                    )
                }
                var B7 = class {
                    constructor(e, t, n, i) {
                        this._callback = e,
                        this._type = t,
                        this._minimumUpdateInterval = Math.max(128 / (i || 44100), .001),
                        this.updateInterval = n,
                        this._createClock()
                    }
                    _createWorker() {
                        const e = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`],{
                            type: "text/javascript"
                        })
                          , t = URL.createObjectURL(e)
                          , n = new Worker(t);
                        n.onmessage = this._callback.bind(this),
                        this._worker = n
                    }
                    _createTimeout() {
                        this._timeout = setTimeout( () => {
                            this._createTimeout(),
                            this._callback()
                        }
                        , this._updateInterval * 1e3)
                    }
                    _createClock() {
                        if (this._type === "worker")
                            try {
                                this._createWorker()
                            } catch {
                                this._type = "timeout",
                                this._createClock()
                            }
                        else
                            this._type === "timeout" && this._createTimeout()
                    }
                    _disposeClock() {
                        this._timeout && clearTimeout(this._timeout),
                        this._worker && (this._worker.terminate(),
                        this._worker.onmessage = null)
                    }
                    get updateInterval() {
                        return this._updateInterval
                    }
                    set updateInterval(e) {
                        var t;
                        this._updateInterval = Math.max(e, this._minimumUpdateInterval),
                        this._type === "worker" && ((t = this._worker) === null || t === void 0 || t.postMessage(this._updateInterval * 1e3))
                    }
                    get type() {
                        return this._type
                    }
                    set type(e) {
                        this._disposeClock(),
                        this._type = e,
                        this._createClock()
                    }
                    dispose() {
                        this._disposeClock()
                    }
                }
                ;
                function id(e) {
                    return M7(e)
                }
                function bh(e) {
                    return T7(e)
                }
                function rx(e) {
                    return b7(e)
                }
                function ym(e) {
                    return A7(e)
                }
                function L7(e) {
                    return e instanceof VR
                }
                function I7(e, t) {
                    return e === "value" || id(t) || bh(t) || L7(t)
                }
                function _m(e, ...t) {
                    if (!t.length)
                        return e;
                    const n = t.shift();
                    if (nd(e) && nd(n))
                        for (const i in n)
                            I7(i, n[i]) ? e[i] = n[i] : nd(n[i]) ? (e[i] || Object.assign(e, {
                                [i]: {}
                            }),
                            _m(e[i], n[i])) : Object.assign(e, {
                                [i]: n[i]
                            });
                    return _m(e, ...t)
                }
                function P7(e, t) {
                    return e.length === t.length && e.every( (n, i) => t[i] === n)
                }
                function ln(e, t, n=[], i) {
                    const s = {}
                      , a = Array.from(t);
                    if (nd(a[0]) && i && !Reflect.has(a[0], i) && (Object.keys(a[0]).some(o => Reflect.has(e, o)) || (_m(s, {
                        [i]: a[0]
                    }),
                    n.splice(n.indexOf(i), 1),
                    a.shift())),
                    a.length === 1 && nd(a[0]))
                        _m(s, a[0]);
                    else
                        for (let o = 0; o < n.length; o++)
                            Tn(a[o]) && (s[n[o]] = a[o]);
                    return _m(e, s)
                }
                function z7(e) {
                    return e.constructor.getDefaults()
                }
                function Sm(e, t) {
                    return No(e) ? t : e
                }
                function h3(e, t) {
                    return t.forEach(n => {
                        Reflect.has(e, n) && delete e[n]
                    }
                    ),
                    e
                }
                var du = class {
                    constructor() {
                        this.debug = !1,
                        this._wasDisposed = !1
                    }
                    static getDefaults() {
                        return {}
                    }
                    log(...e) {
                        (this.debug || $r && this.toString() === $r.TONE_DEBUG_CLASS) && D7(this, ...e)
                    }
                    dispose() {
                        return this._wasDisposed = !0,
                        this
                    }
                    get disposed() {
                        return this._wasDisposed
                    }
                    toString() {
                        return this.name
                    }
                }
                ;
                du.version = LM;
                const ob = 1e-6;
                function xm(e, t) {
                    return e > t + ob
                }
                function lb(e, t) {
                    return xm(e, t) || yl(e, t)
                }
                function ox(e, t) {
                    return e + ob < t
                }
                function yl(e, t) {
                    return Math.abs(e - t) < ob
                }
                function F7(e, t, n) {
                    return Math.max(Math.min(e, n), t)
                }
                var mc = class VU extends du {
                    constructor() {
                        super(),
                        this.name = "Timeline",
                        this._timeline = [];
                        const t = ln(VU.getDefaults(), arguments, ["memory"]);
                        this.memory = t.memory,
                        this.increasing = t.increasing
                    }
                    static getDefaults() {
                        return {
                            memory: 1 / 0,
                            increasing: !1
                        }
                    }
                    get length() {
                        return this._timeline.length
                    }
                    add(t) {
                        if (fn(Reflect.has(t, "time"), "Timeline: events must have a time attribute"),
                        t.time = t.time.valueOf(),
                        this.increasing && this.length) {
                            const n = this._timeline[this.length - 1];
                            fn(lb(t.time, n.time), "The time must be greater than or equal to the last scheduled time"),
                            this._timeline.push(t)
                        } else {
                            const n = this._search(t.time);
                            this._timeline.splice(n + 1, 0, t)
                        }
                        if (this.length > this.memory) {
                            const n = this.length - this.memory;
                            this._timeline.splice(0, n)
                        }
                        return this
                    }
                    remove(t) {
                        const n = this._timeline.indexOf(t);
                        return n !== -1 && this._timeline.splice(n, 1),
                        this
                    }
                    get(t, n="time") {
                        const i = this._search(t, n);
                        return i !== -1 ? this._timeline[i] : null
                    }
                    peek() {
                        return this._timeline[0]
                    }
                    shift() {
                        return this._timeline.shift()
                    }
                    getAfter(t, n="time") {
                        const i = this._search(t, n);
                        return i + 1 < this._timeline.length ? this._timeline[i + 1] : null
                    }
                    getBefore(t) {
                        const n = this._timeline.length;
                        if (n > 0 && this._timeline[n - 1].time < t)
                            return this._timeline[n - 1];
                        const i = this._search(t);
                        return i - 1 >= 0 ? this._timeline[i - 1] : null
                    }
                    cancel(t) {
                        if (this._timeline.length > 1) {
                            let n = this._search(t);
                            if (n >= 0)
                                if (yl(this._timeline[n].time, t)) {
                                    for (let i = n; i >= 0 && yl(this._timeline[i].time, t); i--)
                                        n = i;
                                    this._timeline = this._timeline.slice(0, n)
                                } else
                                    this._timeline = this._timeline.slice(0, n + 1);
                            else
                                this._timeline = []
                        } else
                            this._timeline.length === 1 && lb(this._timeline[0].time, t) && (this._timeline = []);
                        return this
                    }
                    cancelBefore(t) {
                        const n = this._search(t);
                        return n >= 0 && (this._timeline = this._timeline.slice(n + 1)),
                        this
                    }
                    previousEvent(t) {
                        const n = this._timeline.indexOf(t);
                        return n > 0 ? this._timeline[n - 1] : null
                    }
                    _search(t, n="time") {
                        if (this._timeline.length === 0)
                            return -1;
                        let i = 0;
                        const s = this._timeline.length;
                        let a = s;
                        if (s > 0 && this._timeline[s - 1][n] <= t)
                            return s - 1;
                        for (; i < a; ) {
                            let o = Math.floor(i + (a - i) / 2);
                            const c = this._timeline[o]
                              , u = this._timeline[o + 1];
                            if (yl(c[n], t)) {
                                for (let f = o; f < this._timeline.length; f++) {
                                    const m = this._timeline[f];
                                    if (yl(m[n], t))
                                        o = f;
                                    else
                                        break
                                }
                                return o
                            } else {
                                if (ox(c[n], t) && xm(u[n], t))
                                    return o;
                                xm(c[n], t) ? a = o : i = o + 1
                            }
                        }
                        return -1
                    }
                    _iterate(t, n=0, i=this._timeline.length - 1) {
                        this._timeline.slice(n, i + 1).forEach(t)
                    }
                    forEach(t) {
                        return this._iterate(t),
                        this
                    }
                    forEachBefore(t, n) {
                        const i = this._search(t);
                        return i !== -1 && this._iterate(n, 0, i),
                        this
                    }
                    forEachAfter(t, n) {
                        const i = this._search(t);
                        return this._iterate(n, i + 1),
                        this
                    }
                    forEachBetween(t, n, i) {
                        let s = this._search(t)
                          , a = this._search(n);
                        return s !== -1 && a !== -1 ? (this._timeline[s].time !== t && (s += 1),
                        this._timeline[a].time === n && (a -= 1),
                        this._iterate(i, s, a)) : s === -1 && this._iterate(i, 0, a),
                        this
                    }
                    forEachFrom(t, n) {
                        let i = this._search(t);
                        for (; i >= 0 && this._timeline[i].time >= t; )
                            i--;
                        return this._iterate(n, i + 1),
                        this
                    }
                    forEachAtTime(t, n) {
                        const i = this._search(t);
                        if (i !== -1 && yl(this._timeline[i].time, t)) {
                            let s = i;
                            for (let a = i; a >= 0 && yl(this._timeline[a].time, t); a--)
                                s = a;
                            this._iterate(a => {
                                n(a)
                            }
                            , s, i)
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._timeline = [],
                        this
                    }
                }
                ;
                const f3 = [];
                function lx(e) {
                    f3.push(e)
                }
                function H7(e) {
                    f3.forEach(t => t(e))
                }
                const d3 = [];
                function cx(e) {
                    d3.push(e)
                }
                function G7(e) {
                    d3.forEach(t => t(e))
                }
                var cb = class kU extends du {
                    constructor() {
                        super(...arguments),
                        this.name = "Emitter"
                    }
                    on(t, n) {
                        return t.split(/\W+/).forEach(i => {
                            No(this._events) && (this._events = {}),
                            this._events.hasOwnProperty(i) || (this._events[i] = []),
                            this._events[i].push(n)
                        }
                        ),
                        this
                    }
                    once(t, n) {
                        const i = (...s) => {
                            n(...s),
                            this.off(t, i)
                        }
                        ;
                        return this.on(t, i),
                        this
                    }
                    off(t, n) {
                        return t.split(/\W+/).forEach(i => {
                            if (No(this._events) && (this._events = {}),
                            this._events.hasOwnProperty(i))
                                if (No(n))
                                    this._events[i] = [];
                                else {
                                    const s = this._events[i];
                                    for (let a = s.length - 1; a >= 0; a--)
                                        s[a] === n && s.splice(a, 1)
                                }
                        }
                        ),
                        this
                    }
                    emit(t, ...n) {
                        if (this._events && this._events.hasOwnProperty(t)) {
                            const i = this._events[t].slice(0);
                            for (let s = 0, a = i.length; s < a; s++)
                                i[s].apply(this, n)
                        }
                        return this
                    }
                    static mixin(t) {
                        ["on", "once", "off", "emit"].forEach(n => {
                            const i = Object.getOwnPropertyDescriptor(kU.prototype, n);
                            Object.defineProperty(t.prototype, n, i)
                        }
                        )
                    }
                    dispose() {
                        return super.dispose(),
                        this._events = void 0,
                        this
                    }
                }
                  , p3 = class extends cb {
                    constructor() {
                        super(...arguments),
                        this.isOffline = !1
                    }
                    toJSON() {
                        return {}
                    }
                }
                  , ub = class XU extends p3 {
                    constructor() {
                        var t, n;
                        super(),
                        this.name = "Context",
                        this._constants = new Map,
                        this._timeouts = new mc,
                        this._timeoutIds = 0,
                        this._initialized = !1,
                        this._closeStarted = !1,
                        this.isOffline = !1,
                        this._workletPromise = null;
                        const i = ln(XU.getDefaults(), arguments, ["context"]);
                        i.context ? (this._context = i.context,
                        this._latencyHint = ((t = arguments[0]) === null || t === void 0 ? void 0 : t.latencyHint) || "") : (this._context = R7({
                            latencyHint: i.latencyHint
                        }),
                        this._latencyHint = i.latencyHint),
                        this._ticker = new B7(this.emit.bind(this, "tick"),i.clockSource,i.updateInterval,this._context.sampleRate),
                        this.on("tick", this._timeoutLoop.bind(this)),
                        this._context.onstatechange = () => {
                            this.emit("statechange", this.state)
                        }
                        ,
                        this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = i.lookAhead
                    }
                    static getDefaults() {
                        return {
                            clockSource: "worker",
                            latencyHint: "interactive",
                            lookAhead: .1,
                            updateInterval: .05
                        }
                    }
                    initialize() {
                        return this._initialized || (H7(this),
                        this._initialized = !0),
                        this
                    }
                    createAnalyser() {
                        return this._context.createAnalyser()
                    }
                    createOscillator() {
                        return this._context.createOscillator()
                    }
                    createBufferSource() {
                        return this._context.createBufferSource()
                    }
                    createBiquadFilter() {
                        return this._context.createBiquadFilter()
                    }
                    createBuffer(t, n, i) {
                        return this._context.createBuffer(t, n, i)
                    }
                    createChannelMerger(t) {
                        return this._context.createChannelMerger(t)
                    }
                    createChannelSplitter(t) {
                        return this._context.createChannelSplitter(t)
                    }
                    createConstantSource() {
                        return this._context.createConstantSource()
                    }
                    createConvolver() {
                        return this._context.createConvolver()
                    }
                    createDelay(t) {
                        return this._context.createDelay(t)
                    }
                    createDynamicsCompressor() {
                        return this._context.createDynamicsCompressor()
                    }
                    createGain() {
                        return this._context.createGain()
                    }
                    createIIRFilter(t, n) {
                        return this._context.createIIRFilter(t, n)
                    }
                    createPanner() {
                        return this._context.createPanner()
                    }
                    createPeriodicWave(t, n, i) {
                        return this._context.createPeriodicWave(t, n, i)
                    }
                    createStereoPanner() {
                        return this._context.createStereoPanner()
                    }
                    createWaveShaper() {
                        return this._context.createWaveShaper()
                    }
                    createMediaStreamSource(t) {
                        return fn(ym(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaStreamSource(t)
                    }
                    createMediaElementSource(t) {
                        return fn(ym(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaElementSource(t)
                    }
                    createMediaStreamDestination() {
                        return fn(ym(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaStreamDestination()
                    }
                    decodeAudioData(t) {
                        return this._context.decodeAudioData(t)
                    }
                    get currentTime() {
                        return this._context.currentTime
                    }
                    get state() {
                        return this._context.state
                    }
                    get sampleRate() {
                        return this._context.sampleRate
                    }
                    get listener() {
                        return this.initialize(),
                        this._listener
                    }
                    set listener(t) {
                        fn(!this._initialized, "The listener cannot be set after initialization."),
                        this._listener = t
                    }
                    get transport() {
                        return this.initialize(),
                        this._transport
                    }
                    set transport(t) {
                        fn(!this._initialized, "The transport cannot be set after initialization."),
                        this._transport = t
                    }
                    get draw() {
                        return this.initialize(),
                        this._draw
                    }
                    set draw(t) {
                        fn(!this._initialized, "Draw cannot be set after initialization."),
                        this._draw = t
                    }
                    get destination() {
                        return this.initialize(),
                        this._destination
                    }
                    set destination(t) {
                        fn(!this._initialized, "The destination cannot be set after initialization."),
                        this._destination = t
                    }
                    createAudioWorkletNode(t, n) {
                        return N7(this.rawContext, t, n)
                    }
                    addAudioWorkletModule(t) {
                        return gs(this, void 0, void 0, function*() {
                            fn(Tn(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"),
                            this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)),
                            yield this._workletPromise
                        })
                    }
                    workletsAreReady() {
                        return gs(this, void 0, void 0, function*() {
                            (yield this._workletPromise) ? this._workletPromise : Promise.resolve()
                        })
                    }
                    get updateInterval() {
                        return this._ticker.updateInterval
                    }
                    set updateInterval(t) {
                        this._ticker.updateInterval = t
                    }
                    get clockSource() {
                        return this._ticker.type
                    }
                    set clockSource(t) {
                        this._ticker.type = t
                    }
                    get lookAhead() {
                        return this._lookAhead
                    }
                    set lookAhead(t) {
                        this._lookAhead = t,
                        this.updateInterval = t ? t / 2 : .01
                    }
                    get latencyHint() {
                        return this._latencyHint
                    }
                    get rawContext() {
                        return this._context
                    }
                    now() {
                        return this._context.currentTime + this._lookAhead
                    }
                    immediate() {
                        return this._context.currentTime
                    }
                    resume() {
                        return ym(this._context) ? this._context.resume() : Promise.resolve()
                    }
                    close() {
                        return gs(this, void 0, void 0, function*() {
                            ym(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0,
                            yield this._context.close()),
                            this._initialized && G7(this)
                        })
                    }
                    getConstant(t) {
                        if (this._constants.has(t))
                            return this._constants.get(t);
                        {
                            const n = this._context.createBuffer(1, 128, this._context.sampleRate)
                              , i = n.getChannelData(0);
                            for (let a = 0; a < i.length; a++)
                                i[a] = t;
                            const s = this._context.createBufferSource();
                            return s.channelCount = 1,
                            s.channelCountMode = "explicit",
                            s.buffer = n,
                            s.loop = !0,
                            s.start(0),
                            this._constants.set(t, s),
                            s
                        }
                    }
                    dispose() {
                        return super.dispose(),
                        this._ticker.dispose(),
                        this._timeouts.dispose(),
                        Object.keys(this._constants).map(t => this._constants[t].disconnect()),
                        this.close(),
                        this
                    }
                    _timeoutLoop() {
                        const t = this.now();
                        this._timeouts.forEachBefore(t, n => {
                            n.callback(),
                            this._timeouts.remove(n)
                        }
                        )
                    }
                    setTimeout(t, n) {
                        this._timeoutIds++;
                        const i = this.now();
                        return this._timeouts.add({
                            callback: t,
                            id: this._timeoutIds,
                            time: i + n
                        }),
                        this._timeoutIds
                    }
                    clearTimeout(t) {
                        return this._timeouts.forEach(n => {
                            n.id === t && this._timeouts.remove(n)
                        }
                        ),
                        this
                    }
                    clearInterval(t) {
                        return this.clearTimeout(t)
                    }
                    setInterval(t, n) {
                        const i = ++this._timeoutIds
                          , s = () => {
                            const a = this.now();
                            this._timeouts.add({
                                callback: () => {
                                    t(),
                                    s()
                                }
                                ,
                                id: i,
                                time: a + n
                            })
                        }
                        ;
                        return s(),
                        i
                    }
                }
                  , V7 = class extends p3 {
                    constructor() {
                        super(...arguments),
                        this.lookAhead = 0,
                        this.latencyHint = 0,
                        this.isOffline = !1
                    }
                    createAnalyser() {
                        return {}
                    }
                    createOscillator() {
                        return {}
                    }
                    createBufferSource() {
                        return {}
                    }
                    createBiquadFilter() {
                        return {}
                    }
                    createBuffer(e, t, n) {
                        return {}
                    }
                    createChannelMerger(e) {
                        return {}
                    }
                    createChannelSplitter(e) {
                        return {}
                    }
                    createConstantSource() {
                        return {}
                    }
                    createConvolver() {
                        return {}
                    }
                    createDelay(e) {
                        return {}
                    }
                    createDynamicsCompressor() {
                        return {}
                    }
                    createGain() {
                        return {}
                    }
                    createIIRFilter(e, t) {
                        return {}
                    }
                    createPanner() {
                        return {}
                    }
                    createPeriodicWave(e, t, n) {
                        return {}
                    }
                    createStereoPanner() {
                        return {}
                    }
                    createWaveShaper() {
                        return {}
                    }
                    createMediaStreamSource(e) {
                        return {}
                    }
                    createMediaElementSource(e) {
                        return {}
                    }
                    createMediaStreamDestination() {
                        return {}
                    }
                    decodeAudioData(e) {
                        return Promise.resolve({})
                    }
                    createAudioWorkletNode(e, t) {
                        return {}
                    }
                    get rawContext() {
                        return {}
                    }
                    addAudioWorkletModule(e) {
                        return gs(this, void 0, void 0, function*() {
                            return Promise.resolve()
                        })
                    }
                    resume() {
                        return Promise.resolve()
                    }
                    setTimeout(e, t) {
                        return 0
                    }
                    clearTimeout(e) {
                        return this
                    }
                    setInterval(e, t) {
                        return 0
                    }
                    clearInterval(e) {
                        return this
                    }
                    getConstant(e) {
                        return {}
                    }
                    get currentTime() {
                        return 0
                    }
                    get state() {
                        return {}
                    }
                    get sampleRate() {
                        return 0
                    }
                    get listener() {
                        return {}
                    }
                    get transport() {
                        return {}
                    }
                    get draw() {
                        return {}
                    }
                    set draw(e) {}
                    get destination() {
                        return {}
                    }
                    set destination(e) {}
                    now() {
                        return 0
                    }
                    immediate() {
                        return 0
                    }
                }
                ;
                function Ji(e, t) {
                    vl(t) ? t.forEach(n => Ji(e, n)) : Object.defineProperty(e, t, {
                        enumerable: !0,
                        writable: !1
                    })
                }
                function m3(e, t) {
                    vl(t) ? t.forEach(n => m3(e, n)) : Object.defineProperty(e, t, {
                        writable: !0
                    })
                }
                const ci = () => {}
                ;
                var Eh = class Ra extends du {
                    constructor() {
                        super(),
                        this.name = "ToneAudioBuffer",
                        this.onload = ci;
                        const t = ln(Ra.getDefaults(), arguments, ["url", "onload", "onerror"]);
                        this.reverse = t.reverse,
                        this.onload = t.onload,
                        fu(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url)
                    }
                    static getDefaults() {
                        return {
                            onerror: ci,
                            onload: ci,
                            reverse: !1
                        }
                    }
                    get sampleRate() {
                        return this._buffer ? this._buffer.sampleRate : _l().sampleRate
                    }
                    set(t) {
                        return t instanceof Ra ? t.loaded ? this._buffer = t.get() : t.onload = () => {
                            this.set(t),
                            this.onload(this)
                        }
                        : this._buffer = t,
                        this._reversed && this._reverse(),
                        this
                    }
                    get() {
                        return this._buffer
                    }
                    load(t) {
                        return gs(this, void 0, void 0, function*() {
                            const n = Ra.load(t).then(i => {
                                this.set(i),
                                this.onload(this)
                            }
                            );
                            Ra.downloads.push(n);
                            try {
                                yield n
                            } finally {
                                const i = Ra.downloads.indexOf(n);
                                Ra.downloads.splice(i, 1)
                            }
                            return this
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffer = void 0,
                        this
                    }
                    fromArray(t) {
                        const n = vl(t) && t[0].length > 0
                          , i = n ? t.length : 1
                          , s = n ? t[0].length : t.length
                          , a = _l()
                          , o = a.createBuffer(i, s, a.sampleRate)
                          , c = !n && i === 1 ? [t] : t;
                        for (let u = 0; u < i; u++)
                            o.copyToChannel(c[u], u);
                        return this._buffer = o,
                        this
                    }
                    toMono(t) {
                        if (td(t))
                            this.fromArray(this.toArray(t));
                        else {
                            let n = new Float32Array(this.length);
                            const i = this.numberOfChannels;
                            for (let s = 0; s < i; s++) {
                                const a = this.toArray(s);
                                for (let o = 0; o < a.length; o++)
                                    n[o] += a[o]
                            }
                            n = n.map(s => s / i),
                            this.fromArray(n)
                        }
                        return this
                    }
                    toArray(t) {
                        if (td(t))
                            return this.getChannelData(t);
                        if (this.numberOfChannels === 1)
                            return this.toArray(0);
                        {
                            const n = [];
                            for (let i = 0; i < this.numberOfChannels; i++)
                                n[i] = this.getChannelData(i);
                            return n
                        }
                    }
                    getChannelData(t) {
                        return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0)
                    }
                    slice(t, n=this.duration) {
                        fn(this.loaded, "Buffer is not loaded");
                        const i = Math.floor(t * this.sampleRate)
                          , s = Math.floor(n * this.sampleRate);
                        fn(i < s, "The start time must be less than the end time");
                        const a = s - i
                          , o = _l().createBuffer(this.numberOfChannels, a, this.sampleRate);
                        for (let c = 0; c < this.numberOfChannels; c++)
                            o.copyToChannel(this.getChannelData(c).subarray(i, s), c);
                        return new Ra(o)
                    }
                    _reverse() {
                        if (this.loaded)
                            for (let t = 0; t < this.numberOfChannels; t++)
                                this.getChannelData(t).reverse();
                        return this
                    }
                    get loaded() {
                        return this.length > 0
                    }
                    get duration() {
                        return this._buffer ? this._buffer.duration : 0
                    }
                    get length() {
                        return this._buffer ? this._buffer.length : 0
                    }
                    get numberOfChannels() {
                        return this._buffer ? this._buffer.numberOfChannels : 0
                    }
                    get reverse() {
                        return this._reversed
                    }
                    set reverse(t) {
                        this._reversed !== t && (this._reversed = t,
                        this._reverse())
                    }
                    static fromArray(t) {
                        return new Ra().fromArray(t)
                    }
                    static fromUrl(t) {
                        return gs(this, void 0, void 0, function*() {
                            return yield new Ra().load(t)
                        })
                    }
                    static load(t) {
                        return gs(this, void 0, void 0, function*() {
                            const n = Ra.baseUrl === "" || Ra.baseUrl.endsWith("/") ? Ra.baseUrl : Ra.baseUrl + "/"
                              , i = yield fetch(n + t);
                            if (!i.ok)
                                throw new Error(`could not load url: ${t}`);
                            const s = yield i.arrayBuffer();
                            return yield _l().decodeAudioData(s)
                        })
                    }
                    static supportsType(t) {
                        const n = t.split(".")
                          , i = n[n.length - 1];
                        return document.createElement("audio").canPlayType("audio/" + i) !== ""
                    }
                    static loaded() {
                        return gs(this, void 0, void 0, function*() {
                            for (yield Promise.resolve(); Ra.downloads.length; )
                                yield Ra.downloads[0]
                        })
                    }
                }
                ;
                Eh.baseUrl = "",
                Eh.downloads = [];
                var hb = class extends ub {
                    constructor() {
                        super({
                            clockSource: "offline",
                            context: rx(arguments[0]) ? arguments[0] : U7(arguments[0], arguments[1] * arguments[2], arguments[2]),
                            lookAhead: 0,
                            updateInterval: rx(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
                        }),
                        this.name = "OfflineContext",
                        this._currentTime = 0,
                        this.isOffline = !0,
                        this._duration = rx(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1]
                    }
                    now() {
                        return this._currentTime
                    }
                    get currentTime() {
                        return this._currentTime
                    }
                    _renderClock(e) {
                        return gs(this, void 0, void 0, function*() {
                            let t = 0;
                            for (; this._duration - this._currentTime >= 0; ) {
                                this.emit("tick"),
                                this._currentTime += 128 / this.sampleRate,
                                t++;
                                const n = Math.floor(this.sampleRate / 128);
                                e && t % n === 0 && (yield new Promise(i => setTimeout(i, 1)))
                            }
                        })
                    }
                    render() {
                        return gs(this, arguments, void 0, function*(e=!0) {
                            yield this.workletsAreReady(),
                            yield this._renderClock(e);
                            const t = yield this._context.startRendering();
                            return new Eh(t)
                        })
                    }
                    close() {
                        return Promise.resolve()
                    }
                }
                ;
                const v3 = new V7;
                let sd = v3;
                function _l() {
                    return sd === v3 && O7 && k7(new ub),
                    sd
                }
                function k7(e, t=!1) {
                    t && sd.dispose(),
                    ym(e) ? sd = new ub(e) : rx(e) ? sd = new hb(e) : sd = e
                }
                function X7() {
                    return sd.resume()
                }
                if ($r && !$r.TONE_SILENCE_LOGGING) {
                    let e = "v";
                    LM === "dev" && (e = "");
                    const t = ` * Tone.js ${e}${LM} * `;
                    console.log(`%c${t}`, "background: #000; color: #fff")
                }
                function W7(e) {
                    return Math.pow(10, e / 20)
                }
                function Y7(e) {
                    return 20 * (Math.log(e) / Math.LN10)
                }
                function g3(e) {
                    return Math.pow(2, e / 12)
                }
                let ux = 440;
                function q7() {
                    return ux
                }
                function j7(e) {
                    ux = e
                }
                function fb(e) {
                    return Math.round(y3(e))
                }
                function y3(e) {
                    return 69 + 12 * Math.log2(e / ux)
                }
                function Q7(e) {
                    return ux * Math.pow(2, (e - 69) / 12)
                }
                var Z7 = class WU extends du {
                    constructor(t, n, i) {
                        super(),
                        this.defaultUnits = "s",
                        this._val = n,
                        this._units = i,
                        this.context = t,
                        this._expressions = this._getExpressions()
                    }
                    _getExpressions() {
                        return {
                            hz: {
                                method: t => this._frequencyToUnits(parseFloat(t)),
                                regexp: /^(\d+(?:\.\d+)?)hz$/i
                            },
                            i: {
                                method: t => this._ticksToUnits(parseInt(t, 10)),
                                regexp: /^(\d+)i$/i
                            },
                            m: {
                                method: t => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
                                regexp: /^(\d+)m$/i
                            },
                            n: {
                                method: (t, n) => {
                                    const i = parseInt(t, 10)
                                      , s = n === "." ? 1.5 : 1;
                                    return i === 1 ? this._beatsToUnits(this._getTimeSignature()) * s : this._beatsToUnits(4 / i) * s
                                }
                                ,
                                regexp: /^(\d+)n(\.?)$/i
                            },
                            number: {
                                method: t => this._expressions[this.defaultUnits].method.call(this, t),
                                regexp: /^(\d+(?:\.\d+)?)$/
                            },
                            s: {
                                method: t => this._secondsToUnits(parseFloat(t)),
                                regexp: /^(\d+(?:\.\d+)?)s$/
                            },
                            samples: {
                                method: t => parseInt(t, 10) / this.context.sampleRate,
                                regexp: /^(\d+)samples$/
                            },
                            t: {
                                method: t => {
                                    const n = parseInt(t, 10);
                                    return this._beatsToUnits(8 / (Math.floor(n) * 3))
                                }
                                ,
                                regexp: /^(\d+)t$/i
                            },
                            tr: {
                                method: (t, n, i) => {
                                    let s = 0;
                                    return t && t !== "0" && (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))),
                                    n && n !== "0" && (s += this._beatsToUnits(parseFloat(n))),
                                    i && i !== "0" && (s += this._beatsToUnits(parseFloat(i) / 4)),
                                    s
                                }
                                ,
                                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
                            }
                        }
                    }
                    valueOf() {
                        if (this._val instanceof WU && this.fromType(this._val),
                        No(this._val))
                            return this._noArg();
                        if (fu(this._val) && No(this._units)) {
                            for (const t in this._expressions)
                                if (this._expressions[t].regexp.test(this._val.trim())) {
                                    this._units = t;
                                    break
                                }
                        } else if (nd(this._val)) {
                            let t = 0;
                            for (const n in this._val)
                                if (Tn(this._val[n])) {
                                    const i = this._val[n]
                                      , s = new this.constructor(this.context,n).valueOf() * i;
                                    t += s
                                }
                            return t
                        }
                        if (Tn(this._units)) {
                            const t = this._expressions[this._units]
                              , n = this._val.toString().trim().match(t.regexp);
                            return n ? t.method.apply(this, n.slice(1)) : t.method.call(this, this._val)
                        } else
                            return fu(this._val) ? parseFloat(this._val) : this._val
                    }
                    _frequencyToUnits(t) {
                        return 1 / t
                    }
                    _beatsToUnits(t) {
                        return 60 / this._getBpm() * t
                    }
                    _secondsToUnits(t) {
                        return t
                    }
                    _ticksToUnits(t) {
                        return t * this._beatsToUnits(1) / this._getPPQ()
                    }
                    _noArg() {
                        return this._now()
                    }
                    _getBpm() {
                        return this.context.transport.bpm.value
                    }
                    _getTimeSignature() {
                        return this.context.transport.timeSignature
                    }
                    _getPPQ() {
                        return this.context.transport.PPQ
                    }
                    fromType(t) {
                        switch (this._units = void 0,
                        this.defaultUnits) {
                        case "s":
                            this._val = t.toSeconds();
                            break;
                        case "i":
                            this._val = t.toTicks();
                            break;
                        case "hz":
                            this._val = t.toFrequency();
                            break;
                        case "midi":
                            this._val = t.toMidi();
                            break
                        }
                        return this
                    }
                    toFrequency() {
                        return 1 / this.toSeconds()
                    }
                    toSamples() {
                        return this.toSeconds() * this.context.sampleRate
                    }
                    toMilliseconds() {
                        return this.toSeconds() * 1e3
                    }
                }
                  , ad = class Mx extends Z7 {
                    constructor() {
                        super(...arguments),
                        this.name = "TimeClass"
                    }
                    _getExpressions() {
                        return Object.assign(super._getExpressions(), {
                            now: {
                                method: t => this._now() + new this.constructor(this.context,t).valueOf(),
                                regexp: /^\+(.+)/
                            },
                            quantize: {
                                method: t => {
                                    const n = new Mx(this.context,t).valueOf();
                                    return this._secondsToUnits(this.context.transport.nextSubdivision(n))
                                }
                                ,
                                regexp: /^@(.+)/
                            }
                        })
                    }
                    quantize(t, n=1) {
                        const i = new this.constructor(this.context,t).valueOf()
                          , s = this.valueOf()
                          , a = Math.round(s / i) * i - s;
                        return s + a * n
                    }
                    toNotation() {
                        const t = this.toSeconds()
                          , n = ["1m"];
                        for (let a = 1; a < 9; a++) {
                            const o = Math.pow(2, a);
                            n.push(o + "n."),
                            n.push(o + "n"),
                            n.push(o + "t")
                        }
                        n.push("0");
                        let i = n[0]
                          , s = new Mx(this.context,n[0]).toSeconds();
                        return n.forEach(a => {
                            const o = new Mx(this.context,a).toSeconds();
                            Math.abs(o - t) < Math.abs(s - t) && (i = a,
                            s = o)
                        }
                        ),
                        i
                    }
                    toBarsBeatsSixteenths() {
                        const t = this._beatsToUnits(1);
                        let n = this.valueOf() / t;
                        n = parseFloat(n.toFixed(4));
                        const i = Math.floor(n / this._getTimeSignature());
                        let s = n % 1 * 4;
                        n = Math.floor(n) % this._getTimeSignature();
                        const a = s.toString();
                        return a.length > 3 && (s = parseFloat(parseFloat(a).toFixed(3))),
                        [i, n, s].join(":")
                    }
                    toTicks() {
                        const t = this._beatsToUnits(1);
                        return this.valueOf() / t * this._getPPQ()
                    }
                    toSeconds() {
                        return this.valueOf()
                    }
                    toMidi() {
                        return fb(this.toFrequency())
                    }
                    _now() {
                        return this.context.now()
                    }
                }
                  , rd = class x0 extends ad {
                    constructor() {
                        super(...arguments),
                        this.name = "Frequency",
                        this.defaultUnits = "hz"
                    }
                    static get A4() {
                        return q7()
                    }
                    static set A4(t) {
                        j7(t)
                    }
                    _getExpressions() {
                        return Object.assign({}, super._getExpressions(), {
                            midi: {
                                regexp: /^(\d+(?:\.\d+)?midi)/,
                                method(t) {
                                    return this.defaultUnits === "midi" ? t : x0.mtof(t)
                                }
                            },
                            note: {
                                regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
                                method(t, n) {
                                    const i = K7[t.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
                                    return this.defaultUnits === "midi" ? i : x0.mtof(i)
                                }
                            },
                            tr: {
                                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                                method(t, n, i) {
                                    let s = 1;
                                    return t && t !== "0" && (s *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))),
                                    n && n !== "0" && (s *= this._beatsToUnits(parseFloat(n))),
                                    i && i !== "0" && (s *= this._beatsToUnits(parseFloat(i) / 4)),
                                    s
                                }
                            }
                        })
                    }
                    transpose(t) {
                        return new x0(this.context,this.valueOf() * g3(t))
                    }
                    harmonize(t) {
                        return t.map(n => this.transpose(n))
                    }
                    toMidi() {
                        return fb(this.valueOf())
                    }
                    toNote() {
                        const t = this.toFrequency()
                          , n = Math.log2(t / x0.A4);
                        let i = Math.round(12 * n) + 57;
                        const s = Math.floor(i / 12);
                        return s < 0 && (i += -12 * s),
                        J7[i % 12] + s.toString()
                    }
                    toSeconds() {
                        return 1 / super.toSeconds()
                    }
                    toTicks() {
                        const t = this._beatsToUnits(1)
                          , n = this.valueOf() / t;
                        return Math.floor(n * this._getPPQ())
                    }
                    _noArg() {
                        return 0
                    }
                    _frequencyToUnits(t) {
                        return t
                    }
                    _ticksToUnits(t) {
                        return 1 / (t * 60 / (this._getBpm() * this._getPPQ()))
                    }
                    _beatsToUnits(t) {
                        return 1 / super._beatsToUnits(t)
                    }
                    _secondsToUnits(t) {
                        return 1 / t
                    }
                    static mtof(t) {
                        return Q7(t)
                    }
                    static ftom(t) {
                        return fb(t)
                    }
                }
                ;
                const K7 = {
                    cbbb: -3,
                    cbb: -2,
                    cb: -1,
                    c: 0,
                    "c#": 1,
                    cx: 2,
                    "c##": 2,
                    "c###": 3,
                    "cx#": 3,
                    "c#x": 3,
                    dbbb: -1,
                    dbb: 0,
                    db: 1,
                    d: 2,
                    "d#": 3,
                    dx: 4,
                    "d##": 4,
                    "d###": 5,
                    "dx#": 5,
                    "d#x": 5,
                    ebbb: 1,
                    ebb: 2,
                    eb: 3,
                    e: 4,
                    "e#": 5,
                    ex: 6,
                    "e##": 6,
                    "e###": 7,
                    "ex#": 7,
                    "e#x": 7,
                    fbbb: 2,
                    fbb: 3,
                    fb: 4,
                    f: 5,
                    "f#": 6,
                    fx: 7,
                    "f##": 7,
                    "f###": 8,
                    "fx#": 8,
                    "f#x": 8,
                    gbbb: 4,
                    gbb: 5,
                    gb: 6,
                    g: 7,
                    "g#": 8,
                    gx: 9,
                    "g##": 9,
                    "g###": 10,
                    "gx#": 10,
                    "g#x": 10,
                    abbb: 6,
                    abb: 7,
                    ab: 8,
                    a: 9,
                    "a#": 10,
                    ax: 11,
                    "a##": 11,
                    "a###": 12,
                    "ax#": 12,
                    "a#x": 12,
                    bbbb: 8,
                    bbb: 9,
                    bb: 10,
                    b: 11,
                    "b#": 12,
                    bx: 13,
                    "b##": 13,
                    "b###": 14,
                    "bx#": 14,
                    "b#x": 14
                }
                  , J7 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
                var v0 = class extends ad {
                    constructor() {
                        super(...arguments),
                        this.name = "TransportTime"
                    }
                    _now() {
                        return this.context.transport.seconds
                    }
                }
                  , vc = class bx extends du {
                    constructor() {
                        super();
                        const t = ln(bx.getDefaults(), arguments, ["context"]);
                        this.defaultContext ? this.context = this.defaultContext : this.context = t.context
                    }
                    static getDefaults() {
                        return {
                            context: _l()
                        }
                    }
                    now() {
                        return this.context.currentTime + this.context.lookAhead
                    }
                    immediate() {
                        return this.context.currentTime
                    }
                    get sampleTime() {
                        return 1 / this.context.sampleRate
                    }
                    get blockTime() {
                        return 128 / this.context.sampleRate
                    }
                    toSeconds(t) {
                        return w7(t),
                        new ad(this.context,t).toSeconds()
                    }
                    toFrequency(t) {
                        return new rd(this.context,t).toFrequency()
                    }
                    toTicks(t) {
                        return new v0(this.context,t).toTicks()
                    }
                    _getPartialProperties(t) {
                        const n = this.get();
                        return Object.keys(n).forEach(i => {
                            No(t[i]) && delete n[i]
                        }
                        ),
                        n
                    }
                    get() {
                        const t = z7(this);
                        return Object.keys(t).forEach(n => {
                            if (Reflect.has(this, n)) {
                                const i = this[n];
                                Tn(i) && Tn(i.value) && Tn(i.setValueAtTime) ? t[n] = i.value : i instanceof bx ? t[n] = i._getPartialProperties(t[n]) : vl(i) || td(i) || fu(i) || C7(i) ? t[n] = i : delete t[n]
                            }
                        }
                        ),
                        t
                    }
                    set(t) {
                        return Object.keys(t).forEach(n => {
                            Reflect.has(this, n) && Tn(this[n]) && (this[n] && Tn(this[n].value) && Tn(this[n].setValueAtTime) ? this[n].value !== t[n] && (this[n].value = t[n]) : this[n]instanceof bx ? this[n].set(t[n]) : this[n] = t[n])
                        }
                        ),
                        this
                    }
                }
                  , db = class extends mc {
                    constructor(e="stopped") {
                        super(),
                        this.name = "StateTimeline",
                        this._initial = e,
                        this.setStateAtTime(this._initial, 0)
                    }
                    getValueAtTime(e) {
                        const t = this.get(e);
                        return t !== null ? t.state : this._initial
                    }
                    setStateAtTime(e, t, n) {
                        return Mh(t, 0),
                        this.add(Object.assign({}, n, {
                            state: e,
                            time: t
                        })),
                        this
                    }
                    getLastState(e, t) {
                        const n = this._search(t);
                        for (let i = n; i >= 0; i--) {
                            const s = this._timeline[i];
                            if (s.state === e)
                                return s
                        }
                    }
                    getNextState(e, t) {
                        const n = this._search(t);
                        if (n !== -1)
                            for (let i = n; i < this._timeline.length; i++) {
                                const s = this._timeline[i];
                                if (s.state === e)
                                    return s
                            }
                    }
                }
                  , ys = class Ob extends vc {
                    constructor() {
                        const t = ln(Ob.getDefaults(), arguments, ["param", "units", "convert"]);
                        for (super(t),
                        this.name = "Param",
                        this.overridden = !1,
                        this._minOutput = 1e-7,
                        fn(Tn(t.param) && (id(t.param) || t.param instanceof Ob), "param must be an AudioParam"); !id(t.param); )
                            t.param = t.param._param;
                        this._swappable = Tn(t.swappable) ? t.swappable : !1,
                        this._swappable ? (this.input = this.context.createGain(),
                        this._param = t.param,
                        this.input.connect(this._param)) : this._param = this.input = t.param,
                        this._events = new mc(1e3),
                        this._initialValue = this._param.defaultValue,
                        this.units = t.units,
                        this.convert = t.convert,
                        this._minValue = t.minValue,
                        this._maxValue = t.maxValue,
                        Tn(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(vc.getDefaults(), {
                            convert: !0,
                            units: "number"
                        })
                    }
                    get value() {
                        const t = this.now();
                        return this.getValueAtTime(t)
                    }
                    set value(t) {
                        this.cancelScheduledValues(this.now()),
                        this.setValueAtTime(t, this.now())
                    }
                    get minValue() {
                        return Tn(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue
                    }
                    get maxValue() {
                        return Tn(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue
                    }
                    _is(t, n) {
                        return this.units === n
                    }
                    _assertRange(t) {
                        return Tn(this.maxValue) && Tn(this.minValue) && Mh(t, this._fromType(this.minValue), this._fromType(this.maxValue)),
                        t
                    }
                    _fromType(t) {
                        return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? W7(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t
                    }
                    _toType(t) {
                        return this.convert && this.units === "decibels" ? Y7(t) : t
                    }
                    setValueAtTime(t, n) {
                        const i = this.toSeconds(n)
                          , s = this._fromType(t);
                        return fn(isFinite(s) && isFinite(i), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._assertRange(s),
                        this.log(this.units, "setValueAtTime", t, i),
                        this._events.add({
                            time: i,
                            type: "setValueAtTime",
                            value: s
                        }),
                        this._param.setValueAtTime(s, i),
                        this
                    }
                    getValueAtTime(t) {
                        const n = Math.max(this.toSeconds(t), 0)
                          , i = this._events.getAfter(n)
                          , s = this._events.get(n);
                        let a = this._initialValue;
                        if (s === null)
                            a = this._initialValue;
                        else if (s.type === "setTargetAtTime" && (i === null || i.type === "setValueAtTime")) {
                            const o = this._events.getBefore(s.time);
                            let c;
                            o === null ? c = this._initialValue : c = o.value,
                            s.type === "setTargetAtTime" && (a = this._exponentialApproach(s.time, c, s.value, s.constant, n))
                        } else if (i === null)
                            a = s.value;
                        else if (i.type === "linearRampToValueAtTime" || i.type === "exponentialRampToValueAtTime") {
                            let o = s.value;
                            if (s.type === "setTargetAtTime") {
                                const c = this._events.getBefore(s.time);
                                c === null ? o = this._initialValue : o = c.value
                            }
                            i.type === "linearRampToValueAtTime" ? a = this._linearInterpolate(s.time, o, i.time, i.value, n) : a = this._exponentialInterpolate(s.time, o, i.time, i.value, n)
                        } else
                            a = s.value;
                        return this._toType(a)
                    }
                    setRampPoint(t) {
                        t = this.toSeconds(t);
                        let n = this.getValueAtTime(t);
                        return this.cancelAndHoldAtTime(t),
                        this._fromType(n) === 0 && (n = this._toType(this._minOutput)),
                        this.setValueAtTime(n, t),
                        this
                    }
                    linearRampToValueAtTime(t, n) {
                        const i = this._fromType(t)
                          , s = this.toSeconds(n);
                        return fn(isFinite(i) && isFinite(s), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._assertRange(i),
                        this._events.add({
                            time: s,
                            type: "linearRampToValueAtTime",
                            value: i
                        }),
                        this.log(this.units, "linearRampToValueAtTime", t, s),
                        this._param.linearRampToValueAtTime(i, s),
                        this
                    }
                    exponentialRampToValueAtTime(t, n) {
                        let i = this._fromType(t);
                        i = yl(i, 0) ? this._minOutput : i,
                        this._assertRange(i);
                        const s = this.toSeconds(n);
                        return fn(isFinite(i) && isFinite(s), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._events.add({
                            time: s,
                            type: "exponentialRampToValueAtTime",
                            value: i
                        }),
                        this.log(this.units, "exponentialRampToValueAtTime", t, s),
                        this._param.exponentialRampToValueAtTime(i, s),
                        this
                    }
                    exponentialRampTo(t, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.exponentialRampToValueAtTime(t, i + this.toSeconds(n)),
                        this
                    }
                    linearRampTo(t, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.linearRampToValueAtTime(t, i + this.toSeconds(n)),
                        this
                    }
                    targetRampTo(t, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.exponentialApproachValueAtTime(t, i, n),
                        this
                    }
                    exponentialApproachValueAtTime(t, n, i) {
                        n = this.toSeconds(n),
                        i = this.toSeconds(i);
                        const s = Math.log(i + 1) / Math.log(200);
                        return this.setTargetAtTime(t, n, s),
                        this.cancelAndHoldAtTime(n + i * .9),
                        this.linearRampToValueAtTime(t, n + i),
                        this
                    }
                    setTargetAtTime(t, n, i) {
                        const s = this._fromType(t);
                        fn(isFinite(i) && i > 0, "timeConstant must be a number greater than 0");
                        const a = this.toSeconds(n);
                        return this._assertRange(s),
                        fn(isFinite(s) && isFinite(a), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._events.add({
                            constant: i,
                            time: a,
                            type: "setTargetAtTime",
                            value: s
                        }),
                        this.log(this.units, "setTargetAtTime", t, a, i),
                        this._param.setTargetAtTime(s, a, i),
                        this
                    }
                    setValueCurveAtTime(t, n, i, s=1) {
                        i = this.toSeconds(i),
                        n = this.toSeconds(n);
                        const a = this._fromType(t[0]) * s;
                        this.setValueAtTime(this._toType(a), n);
                        const o = i / (t.length - 1);
                        for (let c = 1; c < t.length; c++) {
                            const u = this._fromType(t[c]) * s;
                            this.linearRampToValueAtTime(this._toType(u), n + c * o)
                        }
                        return this
                    }
                    cancelScheduledValues(t) {
                        const n = this.toSeconds(t);
                        return fn(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`),
                        this._events.cancel(n),
                        this._param.cancelScheduledValues(n),
                        this.log(this.units, "cancelScheduledValues", n),
                        this
                    }
                    cancelAndHoldAtTime(t) {
                        const n = this.toSeconds(t)
                          , i = this._fromType(this.getValueAtTime(n));
                        fn(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`),
                        this.log(this.units, "cancelAndHoldAtTime", n, "value=" + i);
                        const s = this._events.get(n)
                          , a = this._events.getAfter(n);
                        return s && yl(s.time, n) ? a ? (this._param.cancelScheduledValues(a.time),
                        this._events.cancel(a.time)) : (this._param.cancelAndHoldAtTime(n),
                        this._events.cancel(n + this.sampleTime)) : a && (this._param.cancelScheduledValues(a.time),
                        this._events.cancel(a.time),
                        a.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(i), n) : a.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(i), n)),
                        this._events.add({
                            time: n,
                            type: "setValueAtTime",
                            value: i
                        }),
                        this._param.setValueAtTime(i, n),
                        this
                    }
                    rampTo(t, n=.1, i) {
                        return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(t, n, i) : this.linearRampTo(t, n, i),
                        this
                    }
                    apply(t) {
                        const n = this.context.currentTime;
                        t.setValueAtTime(this.getValueAtTime(n), n);
                        const i = this._events.get(n);
                        if (i && i.type === "setTargetAtTime") {
                            const s = this._events.getAfter(i.time)
                              , a = s ? s.time : n + 2
                              , o = (a - n) / 10;
                            for (let c = n; c < a; c += o)
                                t.linearRampToValueAtTime(this.getValueAtTime(c), c)
                        }
                        return this._events.forEachAfter(this.context.currentTime, s => {
                            s.type === "cancelScheduledValues" ? t.cancelScheduledValues(s.time) : s.type === "setTargetAtTime" ? t.setTargetAtTime(s.value, s.time, s.constant) : t[s.type](s.value, s.time)
                        }
                        ),
                        this
                    }
                    setParam(t) {
                        fn(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
                        const n = this.input;
                        return n.disconnect(this._param),
                        this.apply(t),
                        this._param = t,
                        n.connect(this._param),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._events.dispose(),
                        this
                    }
                    get defaultValue() {
                        return this._toType(this._param.defaultValue)
                    }
                    _exponentialApproach(t, n, i, s, a) {
                        return i + (n - i) * Math.exp(-(a - t) / s)
                    }
                    _linearInterpolate(t, n, i, s, a) {
                        return n + (s - n) * ((a - t) / (i - t))
                    }
                    _exponentialInterpolate(t, n, i, s, a) {
                        return n * Math.pow(s / n, (a - t) / (i - t))
                    }
                }
                  , In = class Ex extends vc {
                    constructor() {
                        super(...arguments),
                        this._internalChannels = []
                    }
                    get numberOfInputs() {
                        return Tn(this.input) ? id(this.input) || this.input instanceof ys ? 1 : this.input.numberOfInputs : 0
                    }
                    get numberOfOutputs() {
                        return Tn(this.output) ? this.output.numberOfOutputs : 0
                    }
                    _isAudioNode(t) {
                        return Tn(t) && (t instanceof Ex || bh(t))
                    }
                    _getInternalNodes() {
                        const t = this._internalChannels.slice(0);
                        return this._isAudioNode(this.input) && t.push(this.input),
                        this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output),
                        t
                    }
                    _setChannelProperties(t) {
                        this._getInternalNodes().forEach(n => {
                            n.channelCount = t.channelCount,
                            n.channelCountMode = t.channelCountMode,
                            n.channelInterpretation = t.channelInterpretation
                        }
                        )
                    }
                    _getChannelProperties() {
                        const t = this._getInternalNodes();
                        fn(t.length > 0, "ToneAudioNode does not have any internal nodes");
                        const n = t[0];
                        return {
                            channelCount: n.channelCount,
                            channelCountMode: n.channelCountMode,
                            channelInterpretation: n.channelInterpretation
                        }
                    }
                    get channelCount() {
                        return this._getChannelProperties().channelCount
                    }
                    set channelCount(t) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelCount: t
                        }))
                    }
                    get channelCountMode() {
                        return this._getChannelProperties().channelCountMode
                    }
                    set channelCountMode(t) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelCountMode: t
                        }))
                    }
                    get channelInterpretation() {
                        return this._getChannelProperties().channelInterpretation
                    }
                    set channelInterpretation(t) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelInterpretation: t
                        }))
                    }
                    connect(t, n=0, i=0) {
                        return Am(this, t, n, i),
                        this
                    }
                    toDestination() {
                        return this.connect(this.context.destination),
                        this
                    }
                    toMaster() {
                        return rb("toMaster() has been renamed toDestination()"),
                        this.toDestination()
                    }
                    disconnect(t, n=0, i=0) {
                        return $7(this, t, n, i),
                        this
                    }
                    chain(...t) {
                        return pb(this, ...t),
                        this
                    }
                    fan(...t) {
                        return t.forEach(n => this.connect(n)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        Tn(this.input) && (this.input instanceof Ex ? this.input.dispose() : bh(this.input) && this.input.disconnect()),
                        Tn(this.output) && (this.output instanceof Ex ? this.output.dispose() : bh(this.output) && this.output.disconnect()),
                        this._internalChannels = [],
                        this
                    }
                }
                ;
                function pb(...e) {
                    const t = e.shift();
                    e.reduce( (n, i) => (n instanceof In ? n.connect(i) : bh(n) && Am(n, i),
                    i), t)
                }
                function Am(e, t, n=0, i=0) {
                    for (fn(Tn(e), "Cannot connect from undefined node"),
                    fn(Tn(t), "Cannot connect to undefined node"),
                    (t instanceof In || bh(t)) && fn(t.numberOfInputs > 0, "Cannot connect to node with no inputs"),
                    fn(e.numberOfOutputs > 0, "Cannot connect from node with no outputs"); t instanceof In || t instanceof ys; )
                        Tn(t.input) && (t = t.input);
                    for (; e instanceof In; )
                        Tn(e.output) && (e = e.output);
                    id(t) ? e.connect(t, n) : e.connect(t, n, i)
                }
                function $7(e, t, n=0, i=0) {
                    if (Tn(t))
                        for (; t instanceof In; )
                            t = t.input;
                    for (; !bh(e); )
                        Tn(e.output) && (e = e.output);
                    id(t) ? e.disconnect(t, n) : bh(t) ? e.disconnect(t, n, i) : e.disconnect()
                }
                var Er = class YU extends In {
                    constructor() {
                        const t = ln(YU.getDefaults(), arguments, ["gain", "units"]);
                        super(t),
                        this.name = "Gain",
                        this._gainNode = this.context.createGain(),
                        this.input = this._gainNode,
                        this.output = this._gainNode,
                        this.gain = new ys({
                            context: this.context,
                            convert: t.convert,
                            param: this._gainNode.gain,
                            units: t.units,
                            value: t.gain,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        }),
                        Ji(this, "gain")
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            convert: !0,
                            gain: 1,
                            units: "gain"
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.disconnect(),
                        this.gain.dispose(),
                        this
                    }
                }
                  , Tm = class extends In {
                    constructor(e) {
                        super(e),
                        this.onended = ci,
                        this._startTime = -1,
                        this._stopTime = -1,
                        this._timeout = -1,
                        this.output = new Er({
                            context: this.context,
                            gain: 0
                        }),
                        this._gainNode = this.output,
                        this.getStateAtTime = function(t) {
                            const n = this.toSeconds(t);
                            return this._startTime !== -1 && n >= this._startTime && (this._stopTime === -1 || n <= this._stopTime) ? "started" : "stopped"
                        }
                        ,
                        this._fadeIn = e.fadeIn,
                        this._fadeOut = e.fadeOut,
                        this._curve = e.curve,
                        this.onended = e.onended
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            curve: "linear",
                            fadeIn: 0,
                            fadeOut: 0,
                            onended: ci
                        })
                    }
                    _startGain(e, t=1) {
                        fn(this._startTime === -1, "Source cannot be started more than once");
                        const n = this.toSeconds(this._fadeIn);
                        return this._startTime = e + n,
                        this._startTime = Math.max(this._startTime, this.context.currentTime),
                        n > 0 ? (this._gainNode.gain.setValueAtTime(0, e),
                        this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(t, e + n) : this._gainNode.gain.exponentialApproachValueAtTime(t, e, n)) : this._gainNode.gain.setValueAtTime(t, e),
                        this
                    }
                    stop(e) {
                        return this.log("stop", e),
                        this._stopGain(this.toSeconds(e)),
                        this
                    }
                    _stopGain(e) {
                        fn(this._startTime !== -1, "'start' must be called before 'stop'"),
                        this.cancelStop();
                        const t = this.toSeconds(this._fadeOut);
                        return this._stopTime = this.toSeconds(e) + t,
                        this._stopTime = Math.max(this._stopTime, this.now()),
                        t > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, t, e) : this._gainNode.gain.targetRampTo(0, t, e) : (this._gainNode.gain.cancelAndHoldAtTime(e),
                        this._gainNode.gain.setValueAtTime(0, e)),
                        this.context.clearTimeout(this._timeout),
                        this._timeout = this.context.setTimeout( () => {
                            const n = this._curve === "exponential" ? t * 2 : 0;
                            this._stopSource(this.now() + n),
                            this._onended()
                        }
                        , this._stopTime - this.context.currentTime),
                        this
                    }
                    _onended() {
                        if (this.onended !== ci && (this.onended(this),
                        this.onended = ci,
                        !this.context.isOffline)) {
                            const e = () => this.dispose();
                            typeof requestIdleCallback < "u" ? requestIdleCallback(e) : setTimeout(e, 10)
                        }
                    }
                    get state() {
                        return this.getStateAtTime(this.now())
                    }
                    cancelStop() {
                        return this.log("cancelStop"),
                        fn(this._startTime !== -1, "Source is not started"),
                        this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime),
                        this.context.clearTimeout(this._timeout),
                        this._stopTime = -1,
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.dispose(),
                        this.onended = ci,
                        this
                    }
                }
                  , e9 = class qU extends Tm {
                    constructor() {
                        const t = ln(qU.getDefaults(), arguments, ["offset"]);
                        super(t),
                        this.name = "ToneConstantSource",
                        this._source = this.context.createConstantSource(),
                        Am(this._source, this._gainNode),
                        this.offset = new ys({
                            context: this.context,
                            convert: t.convert,
                            param: this._source.offset,
                            units: t.units,
                            value: t.offset,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        })
                    }
                    static getDefaults() {
                        return Object.assign(Tm.getDefaults(), {
                            convert: !0,
                            offset: 1,
                            units: "number"
                        })
                    }
                    start(t) {
                        const n = this.toSeconds(t);
                        return this.log("start", n),
                        this._startGain(n),
                        this._source.start(n),
                        this
                    }
                    _stopSource(t) {
                        this._source.stop(t)
                    }
                    dispose() {
                        return super.dispose(),
                        this.state === "started" && this.stop(),
                        this._source.disconnect(),
                        this.offset.dispose(),
                        this
                    }
                }
                  , Da = class jU extends In {
                    constructor() {
                        const t = ln(jU.getDefaults(), arguments, ["value", "units"]);
                        super(t),
                        this.name = "Signal",
                        this.override = !0,
                        this.output = this._constantSource = new e9({
                            context: this.context,
                            convert: t.convert,
                            offset: t.value,
                            units: t.units,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        }),
                        this._constantSource.start(0),
                        this.input = this._param = this._constantSource.offset
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            convert: !0,
                            units: "number",
                            value: 0
                        })
                    }
                    connect(t, n=0, i=0) {
                        return mb(this, t, n, i),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._param.dispose(),
                        this._constantSource.dispose(),
                        this
                    }
                    setValueAtTime(t, n) {
                        return this._param.setValueAtTime(t, n),
                        this
                    }
                    getValueAtTime(t) {
                        return this._param.getValueAtTime(t)
                    }
                    setRampPoint(t) {
                        return this._param.setRampPoint(t),
                        this
                    }
                    linearRampToValueAtTime(t, n) {
                        return this._param.linearRampToValueAtTime(t, n),
                        this
                    }
                    exponentialRampToValueAtTime(t, n) {
                        return this._param.exponentialRampToValueAtTime(t, n),
                        this
                    }
                    exponentialRampTo(t, n, i) {
                        return this._param.exponentialRampTo(t, n, i),
                        this
                    }
                    linearRampTo(t, n, i) {
                        return this._param.linearRampTo(t, n, i),
                        this
                    }
                    targetRampTo(t, n, i) {
                        return this._param.targetRampTo(t, n, i),
                        this
                    }
                    exponentialApproachValueAtTime(t, n, i) {
                        return this._param.exponentialApproachValueAtTime(t, n, i),
                        this
                    }
                    setTargetAtTime(t, n, i) {
                        return this._param.setTargetAtTime(t, n, i),
                        this
                    }
                    setValueCurveAtTime(t, n, i, s) {
                        return this._param.setValueCurveAtTime(t, n, i, s),
                        this
                    }
                    cancelScheduledValues(t) {
                        return this._param.cancelScheduledValues(t),
                        this
                    }
                    cancelAndHoldAtTime(t) {
                        return this._param.cancelAndHoldAtTime(t),
                        this
                    }
                    rampTo(t, n, i) {
                        return this._param.rampTo(t, n, i),
                        this
                    }
                    get value() {
                        return this._param.value
                    }
                    set value(t) {
                        this._param.value = t
                    }
                    get convert() {
                        return this._param.convert
                    }
                    set convert(t) {
                        this._param.convert = t
                    }
                    get units() {
                        return this._param.units
                    }
                    get overridden() {
                        return this._param.overridden
                    }
                    set overridden(t) {
                        this._param.overridden = t
                    }
                    get maxValue() {
                        return this._param.maxValue
                    }
                    get minValue() {
                        return this._param.minValue
                    }
                    apply(t) {
                        return this._param.apply(t),
                        this
                    }
                }
                ;
                function mb(e, t, n, i) {
                    (t instanceof ys || id(t) || t instanceof Da && t.override) && (t.cancelScheduledValues(0),
                    t.setValueAtTime(0, 0),
                    t instanceof Da && (t.overridden = !0)),
                    Am(e, t, n, i)
                }
                var t9 = class QU extends ys {
                    constructor() {
                        const t = ln(QU.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "TickParam",
                        this._events = new mc(1 / 0),
                        this._multiplier = 1,
                        this._multiplier = t.multiplier,
                        this._events.cancel(0),
                        this._events.add({
                            ticks: 0,
                            time: 0,
                            type: "setValueAtTime",
                            value: this._fromType(t.value)
                        }),
                        this.setValueAtTime(t.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(ys.getDefaults(), {
                            multiplier: 1,
                            units: "hertz",
                            value: 1
                        })
                    }
                    setTargetAtTime(t, n, i) {
                        n = this.toSeconds(n),
                        this.setRampPoint(n);
                        const s = this._fromType(t)
                          , a = this._events.get(n)
                          , o = Math.round(Math.max(1 / i, 1));
                        for (let c = 0; c <= o; c++) {
                            const u = i * c + n
                              , f = this._exponentialApproach(a.time, a.value, s, i, u);
                            this.linearRampToValueAtTime(this._toType(f), u)
                        }
                        return this
                    }
                    setValueAtTime(t, n) {
                        const i = this.toSeconds(n);
                        super.setValueAtTime(t, n);
                        const s = this._events.get(i)
                          , a = this._events.previousEvent(s)
                          , o = this._getTicksUntilEvent(a, i);
                        return s.ticks = Math.max(o, 0),
                        this
                    }
                    linearRampToValueAtTime(t, n) {
                        const i = this.toSeconds(n);
                        super.linearRampToValueAtTime(t, n);
                        const s = this._events.get(i)
                          , a = this._events.previousEvent(s)
                          , o = this._getTicksUntilEvent(a, i);
                        return s.ticks = Math.max(o, 0),
                        this
                    }
                    exponentialRampToValueAtTime(t, n) {
                        n = this.toSeconds(n);
                        const i = this._fromType(t)
                          , s = this._events.get(n)
                          , a = Math.round(Math.max((n - s.time) * 10, 1))
                          , o = (n - s.time) / a;
                        for (let c = 0; c <= a; c++) {
                            const u = o * c + s.time
                              , f = this._exponentialInterpolate(s.time, s.value, n, i, u);
                            this.linearRampToValueAtTime(this._toType(f), u)
                        }
                        return this
                    }
                    _getTicksUntilEvent(t, n) {
                        if (t === null)
                            t = {
                                ticks: 0,
                                time: 0,
                                type: "setValueAtTime",
                                value: 0
                            };
                        else if (No(t.ticks)) {
                            const o = this._events.previousEvent(t);
                            t.ticks = this._getTicksUntilEvent(o, t.time)
                        }
                        const i = this._fromType(this.getValueAtTime(t.time));
                        let s = this._fromType(this.getValueAtTime(n));
                        const a = this._events.get(n);
                        return a && a.time === n && a.type === "setValueAtTime" && (s = this._fromType(this.getValueAtTime(n - this.sampleTime))),
                        .5 * (n - t.time) * (i + s) + t.ticks
                    }
                    getTicksAtTime(t) {
                        const n = this.toSeconds(t)
                          , i = this._events.get(n);
                        return Math.max(this._getTicksUntilEvent(i, n), 0)
                    }
                    getDurationOfTicks(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.getTicksAtTime(n);
                        return this.getTimeOfTick(s + t) - i
                    }
                    getTimeOfTick(t) {
                        const n = this._events.get(t, "ticks")
                          , i = this._events.getAfter(t, "ticks");
                        if (n && n.ticks === t)
                            return n.time;
                        if (n && i && i.type === "linearRampToValueAtTime" && n.value !== i.value) {
                            const s = this._fromType(this.getValueAtTime(n.time))
                              , a = (this._fromType(this.getValueAtTime(i.time)) - s) / (i.time - n.time)
                              , o = Math.sqrt(Math.pow(s, 2) - 2 * a * (n.ticks - t))
                              , c = (-s + o) / a
                              , u = (-s - o) / a;
                            return (c > 0 ? c : u) + n.time
                        } else
                            return n ? n.value === 0 ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue
                    }
                    ticksToTime(t, n) {
                        return this.getDurationOfTicks(t, n)
                    }
                    timeToTicks(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.toSeconds(t)
                          , a = this.getTicksAtTime(i);
                        return this.getTicksAtTime(i + s) - a
                    }
                    _fromType(t) {
                        return this.units === "bpm" && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t)
                    }
                    _toType(t) {
                        return this.units === "bpm" && this.multiplier ? t / this.multiplier * 60 : super._toType(t)
                    }
                    get multiplier() {
                        return this._multiplier
                    }
                    set multiplier(t) {
                        const n = this.value;
                        this._multiplier = t,
                        this.cancelScheduledValues(0),
                        this.setValueAtTime(n, 0)
                    }
                }
                  , n9 = class ZU extends Da {
                    constructor() {
                        const t = ln(ZU.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "TickSignal",
                        this.input = this._param = new t9({
                            context: this.context,
                            convert: t.convert,
                            multiplier: t.multiplier,
                            param: this._constantSource.offset,
                            units: t.units,
                            value: t.value
                        })
                    }
                    static getDefaults() {
                        return Object.assign(Da.getDefaults(), {
                            multiplier: 1,
                            units: "hertz",
                            value: 1
                        })
                    }
                    ticksToTime(t, n) {
                        return this._param.ticksToTime(t, n)
                    }
                    timeToTicks(t, n) {
                        return this._param.timeToTicks(t, n)
                    }
                    getTimeOfTick(t) {
                        return this._param.getTimeOfTick(t)
                    }
                    getDurationOfTicks(t, n) {
                        return this._param.getDurationOfTicks(t, n)
                    }
                    getTicksAtTime(t) {
                        return this._param.getTicksAtTime(t)
                    }
                    get multiplier() {
                        return this._param.multiplier
                    }
                    set multiplier(t) {
                        this._param.multiplier = t
                    }
                    dispose() {
                        return super.dispose(),
                        this._param.dispose(),
                        this
                    }
                }
                  , i9 = class KU extends vc {
                    constructor() {
                        const t = ln(KU.getDefaults(), arguments, ["frequency"]);
                        super(t),
                        this.name = "TickSource",
                        this._state = new db,
                        this._tickOffset = new mc,
                        this._ticksAtTime = new mc,
                        this._secondsAtTime = new mc,
                        this.frequency = new n9({
                            context: this.context,
                            units: t.units,
                            value: t.frequency
                        }),
                        Ji(this, "frequency"),
                        this._state.setStateAtTime("stopped", 0),
                        this.setTicksAtTime(0, 0)
                    }
                    static getDefaults() {
                        return Object.assign({
                            frequency: 1,
                            units: "hertz"
                        }, vc.getDefaults())
                    }
                    get state() {
                        return this.getStateAtTime(this.now())
                    }
                    start(t, n) {
                        const i = this.toSeconds(t);
                        return this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i),
                        Tn(n) && this.setTicksAtTime(n, i),
                        this._ticksAtTime.cancel(i),
                        this._secondsAtTime.cancel(i)),
                        this
                    }
                    stop(t) {
                        const n = this.toSeconds(t);
                        if (this._state.getValueAtTime(n) === "stopped") {
                            const i = this._state.get(n);
                            i && i.time > 0 && (this._tickOffset.cancel(i.time),
                            this._state.cancel(i.time))
                        }
                        return this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this.setTicksAtTime(0, n),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n),
                        this
                    }
                    pause(t) {
                        const n = this.toSeconds(t);
                        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n)),
                        this
                    }
                    cancel(t) {
                        return t = this.toSeconds(t),
                        this._state.cancel(t),
                        this._tickOffset.cancel(t),
                        this._ticksAtTime.cancel(t),
                        this._secondsAtTime.cancel(t),
                        this
                    }
                    getTicksAtTime(t) {
                        const n = this.toSeconds(t)
                          , i = this._state.getLastState("stopped", n)
                          , s = this._ticksAtTime.get(n)
                          , a = {
                            state: "paused",
                            time: n
                        };
                        this._state.add(a);
                        let o = s || i
                          , c = s ? s.ticks : 0
                          , u = null;
                        return this._state.forEachBetween(o.time, n + this.sampleTime, f => {
                            let m = o.time;
                            const v = this._tickOffset.get(f.time);
                            v && v.time >= o.time && (c = v.ticks,
                            m = v.time),
                            o.state === "started" && f.state !== "started" && (c += this.frequency.getTicksAtTime(f.time) - this.frequency.getTicksAtTime(m),
                            f.time !== a.time && (u = {
                                state: f.state,
                                time: f.time,
                                ticks: c
                            })),
                            o = f
                        }
                        ),
                        this._state.remove(a),
                        u && this._ticksAtTime.add(u),
                        c
                    }
                    get ticks() {
                        return this.getTicksAtTime(this.now())
                    }
                    set ticks(t) {
                        this.setTicksAtTime(t, this.now())
                    }
                    get seconds() {
                        return this.getSecondsAtTime(this.now())
                    }
                    set seconds(t) {
                        const n = this.now()
                          , i = this.frequency.timeToTicks(t, n);
                        this.setTicksAtTime(i, n)
                    }
                    getSecondsAtTime(t) {
                        t = this.toSeconds(t);
                        const n = this._state.getLastState("stopped", t)
                          , i = {
                            state: "paused",
                            time: t
                        };
                        this._state.add(i);
                        const s = this._secondsAtTime.get(t);
                        let a = s || n
                          , o = s ? s.seconds : 0
                          , c = null;
                        return this._state.forEachBetween(a.time, t + this.sampleTime, u => {
                            let f = a.time;
                            const m = this._tickOffset.get(u.time);
                            m && m.time >= a.time && (o = m.seconds,
                            f = m.time),
                            a.state === "started" && u.state !== "started" && (o += u.time - f,
                            u.time !== i.time && (c = {
                                state: u.state,
                                time: u.time,
                                seconds: o
                            })),
                            a = u
                        }
                        ),
                        this._state.remove(i),
                        c && this._secondsAtTime.add(c),
                        o
                    }
                    setTicksAtTime(t, n) {
                        return n = this.toSeconds(n),
                        this._tickOffset.cancel(n),
                        this._tickOffset.add({
                            seconds: this.frequency.getDurationOfTicks(t, n),
                            ticks: t,
                            time: n
                        }),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n),
                        this
                    }
                    getStateAtTime(t) {
                        return t = this.toSeconds(t),
                        this._state.getValueAtTime(t)
                    }
                    getTimeOfTick(t, n=this.now()) {
                        const i = this._tickOffset.get(n)
                          , s = this._state.get(n)
                          , a = Math.max(i.time, s.time)
                          , o = this.frequency.getTicksAtTime(a) + t - i.ticks;
                        return this.frequency.getTimeOfTick(o)
                    }
                    forEachTickBetween(t, n, i) {
                        let s = this._state.get(t);
                        this._state.forEachBetween(t, n, o => {
                            s && s.state === "started" && o.state !== "started" && this.forEachTickBetween(Math.max(s.time, t), o.time - this.sampleTime, i),
                            s = o
                        }
                        );
                        let a = null;
                        if (s && s.state === "started") {
                            const o = Math.max(s.time, t)
                              , c = this.frequency.getTicksAtTime(o)
                              , u = this.frequency.getTicksAtTime(s.time)
                              , f = c - u;
                            let m = Math.ceil(f) - f;
                            m = yl(m, 1) ? 0 : m;
                            let v = this.frequency.getTimeOfTick(c + m);
                            for (; v < n; ) {
                                try {
                                    i(v, Math.round(this.getTicksAtTime(v)))
                                } catch (y) {
                                    a = y;
                                    break
                                }
                                v += this.frequency.getDurationOfTicks(1, v)
                            }
                        }
                        if (a)
                            throw a;
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._state.dispose(),
                        this._tickOffset.dispose(),
                        this._ticksAtTime.dispose(),
                        this._secondsAtTime.dispose(),
                        this.frequency.dispose(),
                        this
                    }
                }
                  , _3 = class JU extends vc {
                    constructor() {
                        const t = ln(JU.getDefaults(), arguments, ["callback", "frequency"]);
                        super(t),
                        this.name = "Clock",
                        this.callback = ci,
                        this._lastUpdate = 0,
                        this._state = new db("stopped"),
                        this._boundLoop = this._loop.bind(this),
                        this.callback = t.callback,
                        this._tickSource = new i9({
                            context: this.context,
                            frequency: t.frequency,
                            units: t.units
                        }),
                        this._lastUpdate = 0,
                        this.frequency = this._tickSource.frequency,
                        Ji(this, "frequency"),
                        this._state.setStateAtTime("stopped", 0),
                        this.context.on("tick", this._boundLoop)
                    }
                    static getDefaults() {
                        return Object.assign(vc.getDefaults(), {
                            callback: ci,
                            frequency: 1,
                            units: "hertz"
                        })
                    }
                    get state() {
                        return this._state.getValueAtTime(this.now())
                    }
                    start(t, n) {
                        r3(this.context);
                        const i = this.toSeconds(t);
                        return this.log("start", i),
                        this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i),
                        this._tickSource.start(i, n),
                        i < this._lastUpdate && this.emit("start", i, n)),
                        this
                    }
                    stop(t) {
                        const n = this.toSeconds(t);
                        return this.log("stop", n),
                        this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this._tickSource.stop(n),
                        n < this._lastUpdate && this.emit("stop", n),
                        this
                    }
                    pause(t) {
                        const n = this.toSeconds(t);
                        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n),
                        this._tickSource.pause(n),
                        n < this._lastUpdate && this.emit("pause", n)),
                        this
                    }
                    get ticks() {
                        return Math.ceil(this.getTicksAtTime(this.now()))
                    }
                    set ticks(t) {
                        this._tickSource.ticks = t
                    }
                    get seconds() {
                        return this._tickSource.seconds
                    }
                    set seconds(t) {
                        this._tickSource.seconds = t
                    }
                    getSecondsAtTime(t) {
                        return this._tickSource.getSecondsAtTime(t)
                    }
                    setTicksAtTime(t, n) {
                        return this._tickSource.setTicksAtTime(t, n),
                        this
                    }
                    getTimeOfTick(t, n=this.now()) {
                        return this._tickSource.getTimeOfTick(t, n)
                    }
                    getTicksAtTime(t) {
                        return this._tickSource.getTicksAtTime(t)
                    }
                    nextTickTime(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.getTicksAtTime(i);
                        return this._tickSource.getTimeOfTick(s + t, i)
                    }
                    _loop() {
                        const t = this._lastUpdate
                          , n = this.now();
                        this._lastUpdate = n,
                        this.log("loop", t, n),
                        t !== n && (this._state.forEachBetween(t, n, i => {
                            switch (i.state) {
                            case "started":
                                const s = this._tickSource.getTicksAtTime(i.time);
                                this.emit("start", i.time, s);
                                break;
                            case "stopped":
                                i.time !== 0 && this.emit("stop", i.time);
                                break;
                            case "paused":
                                this.emit("pause", i.time);
                                break
                            }
                        }
                        ),
                        this._tickSource.forEachTickBetween(t, n, (i, s) => {
                            this.callback(i, s)
                        }
                        ))
                    }
                    getStateAtTime(t) {
                        const n = this.toSeconds(t);
                        return this._state.getValueAtTime(n)
                    }
                    dispose() {
                        return super.dispose(),
                        this.context.off("tick", this._boundLoop),
                        this._tickSource.dispose(),
                        this._state.dispose(),
                        this
                    }
                }
                ;
                cb.mixin(_3);
                var hx = class $U extends In {
                    constructor() {
                        const t = ln($U.getDefaults(), arguments, ["volume"]);
                        super(t),
                        this.name = "Volume",
                        this.input = this.output = new Er({
                            context: this.context,
                            gain: t.volume,
                            units: "decibels"
                        }),
                        this.volume = this.output.gain,
                        Ji(this, "volume"),
                        this._unmutedVolume = t.volume,
                        this.mute = t.mute
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            mute: !1,
                            volume: 0
                        })
                    }
                    get mute() {
                        return this.volume.value === -1 / 0
                    }
                    set mute(t) {
                        !this.mute && t ? (this._unmutedVolume = this.volume.value,
                        this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume)
                    }
                    dispose() {
                        return super.dispose(),
                        this.input.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                  , s9 = class eO extends In {
                    constructor() {
                        const t = ln(eO.getDefaults(), arguments);
                        super(t),
                        this.name = "Destination",
                        this.input = new hx({
                            context: this.context
                        }),
                        this.output = new Er({
                            context: this.context
                        }),
                        this.volume = this.input.volume,
                        pb(this.input, this.output, this.context.rawContext.destination),
                        this.mute = t.mute,
                        this._internalChannels = [this.input, this.context.rawContext.destination, this.output]
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            mute: !1,
                            volume: 0
                        })
                    }
                    get mute() {
                        return this.input.mute
                    }
                    set mute(t) {
                        this.input.mute = t
                    }
                    chain(...t) {
                        return this.input.disconnect(),
                        t.unshift(this.input),
                        t.push(this.output),
                        pb(...t),
                        this
                    }
                    get maxChannelCount() {
                        return this.context.rawContext.destination.maxChannelCount
                    }
                    dispose() {
                        return super.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                ;
                lx(e => {
                    e.destination = new s9({
                        context: e
                    })
                }
                ),
                cx(e => {
                    e.destination.dispose()
                }
                );
                var a9 = class extends In {
                    constructor() {
                        super(...arguments),
                        this.name = "Listener",
                        this.positionX = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.positionX
                        }),
                        this.positionY = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.positionY
                        }),
                        this.positionZ = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.positionZ
                        }),
                        this.forwardX = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardX
                        }),
                        this.forwardY = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardY
                        }),
                        this.forwardZ = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardZ
                        }),
                        this.upX = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.upX
                        }),
                        this.upY = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.upY
                        }),
                        this.upZ = new ys({
                            context: this.context,
                            param: this.context.rawContext.listener.upZ
                        })
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            positionX: 0,
                            positionY: 0,
                            positionZ: 0,
                            forwardX: 0,
                            forwardY: 0,
                            forwardZ: -1,
                            upX: 0,
                            upY: 1,
                            upZ: 0
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.positionX.dispose(),
                        this.positionY.dispose(),
                        this.positionZ.dispose(),
                        this.forwardX.dispose(),
                        this.forwardY.dispose(),
                        this.forwardZ.dispose(),
                        this.upX.dispose(),
                        this.upY.dispose(),
                        this.upZ.dispose(),
                        this
                    }
                }
                ;
                lx(e => {
                    e.listener = new a9({
                        context: e
                    })
                }
                ),
                cx(e => {
                    e.listener.dispose()
                }
                );
                var r9 = class tO extends du {
                    constructor() {
                        super(),
                        this.name = "ToneAudioBuffers",
                        this._buffers = new Map,
                        this._loadingCount = 0;
                        const t = ln(tO.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
                        this.baseUrl = t.baseUrl,
                        Object.keys(t.urls).forEach(n => {
                            this._loadingCount++;
                            const i = t.urls[n];
                            this.add(n, i, this._bufferLoaded.bind(this, t.onload), t.onerror)
                        }
                        )
                    }
                    static getDefaults() {
                        return {
                            baseUrl: "",
                            onerror: ci,
                            onload: ci,
                            urls: {}
                        }
                    }
                    has(t) {
                        return this._buffers.has(t.toString())
                    }
                    get(t) {
                        return fn(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`),
                        this._buffers.get(t.toString())
                    }
                    _bufferLoaded(t) {
                        this._loadingCount--,
                        this._loadingCount === 0 && t && t()
                    }
                    get loaded() {
                        return Array.from(this._buffers).every( ([t,n]) => n.loaded)
                    }
                    add(t, n, i=ci, s=ci) {
                        return fu(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""),
                        this._buffers.set(t.toString(), new Eh(this.baseUrl + n,i,s))) : this._buffers.set(t.toString(), new Eh(n,i,s)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffers.forEach(t => t.dispose()),
                        this._buffers.clear(),
                        this
                    }
                }
                  , Mm = class extends v0 {
                    constructor() {
                        super(...arguments),
                        this.name = "Ticks",
                        this.defaultUnits = "i"
                    }
                    _now() {
                        return this.context.transport.ticks
                    }
                    _beatsToUnits(e) {
                        return this._getPPQ() * e
                    }
                    _secondsToUnits(e) {
                        return Math.floor(e / (60 / this._getBpm()) * this._getPPQ())
                    }
                    _ticksToUnits(e) {
                        return e
                    }
                    toTicks() {
                        return this.valueOf()
                    }
                    toSeconds() {
                        return this.valueOf() / this._getPPQ() * (60 / this._getBpm())
                    }
                }
                  , o9 = class extends vc {
                    constructor() {
                        super(...arguments),
                        this.name = "Draw",
                        this.expiration = .25,
                        this.anticipation = .008,
                        this._events = new mc,
                        this._boundDrawLoop = this._drawLoop.bind(this),
                        this._animationFrame = -1
                    }
                    schedule(e, t) {
                        return this._events.add({
                            callback: e,
                            time: this.toSeconds(t)
                        }),
                        this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)),
                        this
                    }
                    cancel(e) {
                        return this._events.cancel(this.toSeconds(e)),
                        this
                    }
                    _drawLoop() {
                        const e = this.context.currentTime;
                        this._events.forEachBefore(e + this.anticipation, t => {
                            e - t.time <= this.expiration && t.callback(),
                            this._events.remove(t)
                        }
                        ),
                        this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop))
                    }
                    dispose() {
                        return super.dispose(),
                        this._events.dispose(),
                        cancelAnimationFrame(this._animationFrame),
                        this
                    }
                }
                ;
                lx(e => {
                    e.draw = new o9({
                        context: e
                    })
                }
                ),
                cx(e => {
                    e.draw.dispose()
                }
                );
                var l9 = class extends du {
                    constructor() {
                        super(...arguments),
                        this.name = "IntervalTimeline",
                        this._root = null,
                        this._length = 0
                    }
                    add(e) {
                        fn(Tn(e.time), "Events must have a time property"),
                        fn(Tn(e.duration), "Events must have a duration parameter"),
                        e.time = e.time.valueOf();
                        let t = new c9(e.time,e.time + e.duration,e);
                        for (this._root === null ? this._root = t : this._root.insert(t),
                        this._length++; t !== null; )
                            t.updateHeight(),
                            t.updateMax(),
                            this._rebalance(t),
                            t = t.parent;
                        return this
                    }
                    remove(e) {
                        if (this._root !== null) {
                            const t = [];
                            this._root.search(e.time, t);
                            for (const n of t)
                                if (n.event === e) {
                                    this._removeNode(n),
                                    this._length--;
                                    break
                                }
                        }
                        return this
                    }
                    get length() {
                        return this._length
                    }
                    cancel(e) {
                        return this.forEachFrom(e, t => this.remove(t)),
                        this
                    }
                    _setRoot(e) {
                        this._root = e,
                        this._root !== null && (this._root.parent = null)
                    }
                    _replaceNodeInParent(e, t) {
                        e.parent !== null ? (e.isLeftChild() ? e.parent.left = t : e.parent.right = t,
                        this._rebalance(e.parent)) : this._setRoot(t)
                    }
                    _removeNode(e) {
                        if (e.left === null && e.right === null)
                            this._replaceNodeInParent(e, null);
                        else if (e.right === null)
                            this._replaceNodeInParent(e, e.left);
                        else if (e.left === null)
                            this._replaceNodeInParent(e, e.right);
                        else {
                            const t = e.getBalance();
                            let n, i = null;
                            if (t > 0)
                                if (e.left.right === null)
                                    n = e.left,
                                    n.right = e.right,
                                    i = n;
                                else {
                                    for (n = e.left.right; n.right !== null; )
                                        n = n.right;
                                    n.parent && (n.parent.right = n.left,
                                    i = n.parent,
                                    n.left = e.left,
                                    n.right = e.right)
                                }
                            else if (e.right.left === null)
                                n = e.right,
                                n.left = e.left,
                                i = n;
                            else {
                                for (n = e.right.left; n.left !== null; )
                                    n = n.left;
                                n.parent && (n.parent.left = n.right,
                                i = n.parent,
                                n.left = e.left,
                                n.right = e.right)
                            }
                            e.parent !== null ? e.isLeftChild() ? e.parent.left = n : e.parent.right = n : this._setRoot(n),
                            i && this._rebalance(i)
                        }
                        e.dispose()
                    }
                    _rotateLeft(e) {
                        const t = e.parent
                          , n = e.isLeftChild()
                          , i = e.right;
                        i && (e.right = i.left,
                        i.left = e),
                        t !== null ? n ? t.left = i : t.right = i : this._setRoot(i)
                    }
                    _rotateRight(e) {
                        const t = e.parent
                          , n = e.isLeftChild()
                          , i = e.left;
                        i && (e.left = i.right,
                        i.right = e),
                        t !== null ? n ? t.left = i : t.right = i : this._setRoot(i)
                    }
                    _rebalance(e) {
                        const t = e.getBalance();
                        t > 1 && e.left ? e.left.getBalance() < 0 ? this._rotateLeft(e.left) : this._rotateRight(e) : t < -1 && e.right && (e.right.getBalance() > 0 ? this._rotateRight(e.right) : this._rotateLeft(e))
                    }
                    get(e) {
                        if (this._root !== null) {
                            const t = [];
                            if (this._root.search(e, t),
                            t.length > 0) {
                                let n = t[0];
                                for (let i = 1; i < t.length; i++)
                                    t[i].low > n.low && (n = t[i]);
                                return n.event
                            }
                        }
                        return null
                    }
                    forEach(e) {
                        if (this._root !== null) {
                            const t = [];
                            this._root.traverse(n => t.push(n)),
                            t.forEach(n => {
                                n.event && e(n.event)
                            }
                            )
                        }
                        return this
                    }
                    forEachAtTime(e, t) {
                        if (this._root !== null) {
                            const n = [];
                            this._root.search(e, n),
                            n.forEach(i => {
                                i.event && t(i.event)
                            }
                            )
                        }
                        return this
                    }
                    forEachFrom(e, t) {
                        if (this._root !== null) {
                            const n = [];
                            this._root.searchAfter(e, n),
                            n.forEach(i => {
                                i.event && t(i.event)
                            }
                            )
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._root !== null && this._root.traverse(e => e.dispose()),
                        this._root = null,
                        this
                    }
                }
                  , c9 = class {
                    constructor(e, t, n) {
                        this._left = null,
                        this._right = null,
                        this.parent = null,
                        this.height = 0,
                        this.event = n,
                        this.low = e,
                        this.high = t,
                        this.max = this.high
                    }
                    insert(e) {
                        e.low <= this.low ? this.left === null ? this.left = e : this.left.insert(e) : this.right === null ? this.right = e : this.right.insert(e)
                    }
                    search(e, t) {
                        e > this.max || (this.left !== null && this.left.search(e, t),
                        this.low <= e && this.high > e && t.push(this),
                        !(this.low > e) && this.right !== null && this.right.search(e, t))
                    }
                    searchAfter(e, t) {
                        this.low >= e && (t.push(this),
                        this.left !== null && this.left.searchAfter(e, t)),
                        this.right !== null && this.right.searchAfter(e, t)
                    }
                    traverse(e) {
                        e(this),
                        this.left !== null && this.left.traverse(e),
                        this.right !== null && this.right.traverse(e)
                    }
                    updateHeight() {
                        this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0
                    }
                    updateMax() {
                        this.max = this.high,
                        this.left !== null && (this.max = Math.max(this.max, this.left.max)),
                        this.right !== null && (this.max = Math.max(this.max, this.right.max))
                    }
                    getBalance() {
                        let e = 0;
                        return this.left !== null && this.right !== null ? e = this.left.height - this.right.height : this.left !== null ? e = this.left.height + 1 : this.right !== null && (e = -(this.right.height + 1)),
                        e
                    }
                    isLeftChild() {
                        return this.parent !== null && this.parent.left === this
                    }
                    get left() {
                        return this._left
                    }
                    set left(e) {
                        this._left = e,
                        e !== null && (e.parent = this),
                        this.updateHeight(),
                        this.updateMax()
                    }
                    get right() {
                        return this._right
                    }
                    set right(e) {
                        this._right = e,
                        e !== null && (e.parent = this),
                        this.updateHeight(),
                        this.updateMax()
                    }
                    dispose() {
                        this.parent = null,
                        this._left = null,
                        this._right = null,
                        this.event = null
                    }
                }
                  , u9 = class extends du {
                    constructor(e) {
                        super(),
                        this.name = "TimelineValue",
                        this._timeline = new mc({
                            memory: 10
                        }),
                        this._initialValue = e
                    }
                    set(e, t) {
                        return this._timeline.add({
                            value: e,
                            time: t
                        }),
                        this
                    }
                    get(e) {
                        const t = this._timeline.get(e);
                        return t ? t.value : this._initialValue
                    }
                }
                  , fx = class nO extends In {
                    constructor() {
                        super(ln(nO.getDefaults(), arguments, ["context"]))
                    }
                    connect(t, n=0, i=0) {
                        return mb(this, t, n, i),
                        this
                    }
                }
                  , vb = class iO extends fx {
                    constructor() {
                        const t = ln(iO.getDefaults(), arguments, ["mapping", "length"]);
                        super(t),
                        this.name = "WaveShaper",
                        this._shaper = this.context.createWaveShaper(),
                        this.input = this._shaper,
                        this.output = this._shaper,
                        vl(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : E7(t.mapping) && this.setMap(t.mapping, t.length)
                    }
                    static getDefaults() {
                        return Object.assign(Da.getDefaults(), {
                            length: 1024
                        })
                    }
                    setMap(t, n=1024) {
                        const i = new Float32Array(n);
                        for (let s = 0, a = n; s < a; s++) {
                            const o = s / (a - 1) * 2 - 1;
                            i[s] = t(o, s)
                        }
                        return this.curve = i,
                        this
                    }
                    get curve() {
                        return this._shaper.curve
                    }
                    set curve(t) {
                        this._shaper.curve = t
                    }
                    get oversample() {
                        return this._shaper.oversample
                    }
                    set oversample(t) {
                        const n = ["none", "2x", "4x"].some(i => i.includes(t));
                        fn(n, "oversampling must be either 'none', '2x', or '4x'"),
                        this._shaper.oversample = t
                    }
                    dispose() {
                        return super.dispose(),
                        this._shaper.disconnect(),
                        this
                    }
                }
                  , h9 = class sO extends fx {
                    constructor() {
                        const t = ln(sO.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "Pow",
                        this._exponentScaler = this.input = this.output = new vb({
                            context: this.context,
                            mapping: this._expFunc(t.value),
                            length: 8192
                        }),
                        this._exponent = t.value
                    }
                    static getDefaults() {
                        return Object.assign(fx.getDefaults(), {
                            value: 1
                        })
                    }
                    _expFunc(t) {
                        return n => Math.pow(Math.abs(n), t)
                    }
                    get value() {
                        return this._exponent
                    }
                    set value(t) {
                        this._exponent = t,
                        this._exponentScaler.setMap(this._expFunc(this._exponent))
                    }
                    dispose() {
                        return super.dispose(),
                        this._exponentScaler.dispose(),
                        this
                    }
                }
                  , g0 = class Nb {
                    constructor(t, n) {
                        this.id = Nb._eventId++,
                        this._remainderTime = 0;
                        const i = Object.assign(Nb.getDefaults(), n);
                        this.transport = t,
                        this.callback = i.callback,
                        this._once = i.once,
                        this.time = Math.floor(i.time),
                        this._remainderTime = i.time - this.time
                    }
                    static getDefaults() {
                        return {
                            callback: ci,
                            once: !1,
                            time: 0
                        }
                    }
                    get floatTime() {
                        return this.time + this._remainderTime
                    }
                    invoke(t) {
                        if (this.callback) {
                            const n = this.transport.bpm.getDurationOfTicks(1, t);
                            this.callback(t + this._remainderTime * n),
                            this._once && this.transport.clear(this.id)
                        }
                    }
                    dispose() {
                        return this.callback = void 0,
                        this
                    }
                }
                ;
                g0._eventId = 0;
                var f9 = class aO extends g0 {
                    constructor(t, n) {
                        super(t, n),
                        this._currentId = -1,
                        this._nextId = -1,
                        this._nextTick = this.time,
                        this._boundRestart = this._restart.bind(this);
                        const i = Object.assign(aO.getDefaults(), n);
                        this.duration = i.duration,
                        this._interval = i.interval,
                        this._nextTick = i.time,
                        this.transport.on("start", this._boundRestart),
                        this.transport.on("loopStart", this._boundRestart),
                        this.transport.on("ticks", this._boundRestart),
                        this.context = this.transport.context,
                        this._restart()
                    }
                    static getDefaults() {
                        return Object.assign({}, g0.getDefaults(), {
                            duration: 1 / 0,
                            interval: 1,
                            once: !1
                        })
                    }
                    invoke(t) {
                        this._createEvents(t),
                        super.invoke(t)
                    }
                    _createEvent() {
                        return ox(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new Mm(this.context,this._nextTick).toSeconds()) : -1
                    }
                    _createEvents(t) {
                        ox(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval,
                        this._currentId = this._nextId,
                        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Mm(this.context,this._nextTick).toSeconds()))
                    }
                    _restart(t) {
                        this.transport.clear(this._currentId),
                        this.transport.clear(this._nextId),
                        this._nextTick = this.floatTime;
                        const n = this.transport.getTicksAtTime(t);
                        xm(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval),
                        this._currentId = this._createEvent(),
                        this._nextTick += this._interval,
                        this._nextId = this._createEvent()
                    }
                    dispose() {
                        return super.dispose(),
                        this.transport.clear(this._currentId),
                        this.transport.clear(this._nextId),
                        this.transport.off("start", this._boundRestart),
                        this.transport.off("loopStart", this._boundRestart),
                        this.transport.off("ticks", this._boundRestart),
                        this
                    }
                }
                  , S3 = class rO extends vc {
                    constructor() {
                        const t = ln(rO.getDefaults(), arguments);
                        super(t),
                        this.name = "Transport",
                        this._loop = new u9(!1),
                        this._loopStart = 0,
                        this._loopEnd = 0,
                        this._scheduledEvents = {},
                        this._timeline = new mc,
                        this._repeatedEvents = new l9,
                        this._syncedSignals = [],
                        this._swingAmount = 0,
                        this._ppq = t.ppq,
                        this._clock = new _3({
                            callback: this._processTick.bind(this),
                            context: this.context,
                            frequency: 0,
                            units: "bpm"
                        }),
                        this._bindClockEvents(),
                        this.bpm = this._clock.frequency,
                        this._clock.frequency.multiplier = t.ppq,
                        this.bpm.setValueAtTime(t.bpm, 0),
                        Ji(this, "bpm"),
                        this._timeSignature = t.timeSignature,
                        this._swingTicks = t.ppq / 2
                    }
                    static getDefaults() {
                        return Object.assign(vc.getDefaults(), {
                            bpm: 120,
                            loopEnd: "4m",
                            loopStart: 0,
                            ppq: 192,
                            swing: 0,
                            swingSubdivision: "8n",
                            timeSignature: 4
                        })
                    }
                    _processTick(t, n) {
                        if (this._loop.get(t) && n >= this._loopEnd && (this.emit("loopEnd", t),
                        this._clock.setTicksAtTime(this._loopStart, t),
                        n = this._loopStart,
                        this.emit("loopStart", t, this._clock.getSecondsAtTime(t)),
                        this.emit("loop", t)),
                        this._swingAmount > 0 && n % this._ppq !== 0 && n % (this._swingTicks * 2) !== 0) {
                            const i = n % (this._swingTicks * 2) / (this._swingTicks * 2)
                              , s = Math.sin(i * Math.PI) * this._swingAmount;
                            t += new Mm(this.context,this._swingTicks * 2 / 3).toSeconds() * s
                        }
                        c3(!0),
                        this._timeline.forEachAtTime(n, i => i.invoke(t)),
                        c3(!1)
                    }
                    schedule(t, n) {
                        const i = new g0(this,{
                            callback: t,
                            time: new v0(this.context,n).toTicks()
                        });
                        return this._addEvent(i, this._timeline)
                    }
                    scheduleRepeat(t, n, i, s=1 / 0) {
                        const a = new f9(this,{
                            callback: t,
                            duration: new ad(this.context,s).toTicks(),
                            interval: new ad(this.context,n).toTicks(),
                            time: new v0(this.context,i).toTicks()
                        });
                        return this._addEvent(a, this._repeatedEvents)
                    }
                    scheduleOnce(t, n) {
                        const i = new g0(this,{
                            callback: t,
                            once: !0,
                            time: new v0(this.context,n).toTicks()
                        });
                        return this._addEvent(i, this._timeline)
                    }
                    clear(t) {
                        if (this._scheduledEvents.hasOwnProperty(t)) {
                            const n = this._scheduledEvents[t.toString()];
                            n.timeline.remove(n.event),
                            n.event.dispose(),
                            delete this._scheduledEvents[t.toString()]
                        }
                        return this
                    }
                    _addEvent(t, n) {
                        return this._scheduledEvents[t.id.toString()] = {
                            event: t,
                            timeline: n
                        },
                        n.add(t),
                        t.id
                    }
                    cancel(t=0) {
                        const n = this.toTicks(t);
                        return this._timeline.forEachFrom(n, i => this.clear(i.id)),
                        this._repeatedEvents.forEachFrom(n, i => this.clear(i.id)),
                        this
                    }
                    _bindClockEvents() {
                        this._clock.on("start", (t, n) => {
                            n = new Mm(this.context,n).toSeconds(),
                            this.emit("start", t, n)
                        }
                        ),
                        this._clock.on("stop", t => {
                            this.emit("stop", t)
                        }
                        ),
                        this._clock.on("pause", t => {
                            this.emit("pause", t)
                        }
                        )
                    }
                    get state() {
                        return this._clock.getStateAtTime(this.now())
                    }
                    start(t, n) {
                        this.context.resume();
                        let i;
                        return Tn(n) && (i = this.toTicks(n)),
                        this._clock.start(t, i),
                        this
                    }
                    stop(t) {
                        return this._clock.stop(t),
                        this
                    }
                    pause(t) {
                        return this._clock.pause(t),
                        this
                    }
                    toggle(t) {
                        return t = this.toSeconds(t),
                        this._clock.getStateAtTime(t) !== "started" ? this.start(t) : this.stop(t),
                        this
                    }
                    get timeSignature() {
                        return this._timeSignature
                    }
                    set timeSignature(t) {
                        vl(t) && (t = t[0] / t[1] * 4),
                        this._timeSignature = t
                    }
                    get loopStart() {
                        return new ad(this.context,this._loopStart,"i").toSeconds()
                    }
                    set loopStart(t) {
                        this._loopStart = this.toTicks(t)
                    }
                    get loopEnd() {
                        return new ad(this.context,this._loopEnd,"i").toSeconds()
                    }
                    set loopEnd(t) {
                        this._loopEnd = this.toTicks(t)
                    }
                    get loop() {
                        return this._loop.get(this.now())
                    }
                    set loop(t) {
                        this._loop.set(t, this.now())
                    }
                    setLoopPoints(t, n) {
                        return this.loopStart = t,
                        this.loopEnd = n,
                        this
                    }
                    get swing() {
                        return this._swingAmount
                    }
                    set swing(t) {
                        this._swingAmount = t
                    }
                    get swingSubdivision() {
                        return new Mm(this.context,this._swingTicks).toNotation()
                    }
                    set swingSubdivision(t) {
                        this._swingTicks = this.toTicks(t)
                    }
                    get position() {
                        const t = this.now()
                          , n = this._clock.getTicksAtTime(t);
                        return new Mm(this.context,n).toBarsBeatsSixteenths()
                    }
                    set position(t) {
                        this.ticks = this.toTicks(t)
                    }
                    get seconds() {
                        return this._clock.seconds
                    }
                    set seconds(t) {
                        const n = this.now();
                        this.ticks = this._clock.frequency.timeToTicks(t, n)
                    }
                    get progress() {
                        if (this.loop) {
                            const t = this.now();
                            return (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart)
                        } else
                            return 0
                    }
                    get ticks() {
                        return this._clock.ticks
                    }
                    set ticks(t) {
                        if (this._clock.ticks !== t) {
                            const n = this.now();
                            if (this.state === "started") {
                                const i = this._clock.getTicksAtTime(n)
                                  , s = this._clock.frequency.getDurationOfTicks(Math.ceil(i) - i, n)
                                  , a = n + s;
                                this.emit("stop", a),
                                this._clock.setTicksAtTime(t, a),
                                this.emit("start", a, this._clock.getSecondsAtTime(a))
                            } else
                                this.emit("ticks", n),
                                this._clock.setTicksAtTime(t, n)
                        }
                    }
                    getTicksAtTime(t) {
                        return this._clock.getTicksAtTime(t)
                    }
                    getSecondsAtTime(t) {
                        return this._clock.getSecondsAtTime(t)
                    }
                    get PPQ() {
                        return this._clock.frequency.multiplier
                    }
                    set PPQ(t) {
                        this._clock.frequency.multiplier = t
                    }
                    nextSubdivision(t) {
                        if (t = this.toTicks(t),
                        this.state !== "started")
                            return 0;
                        {
                            const n = this.now()
                              , i = this.getTicksAtTime(n)
                              , s = t - i % t;
                            return this._clock.nextTickTime(s, n)
                        }
                    }
                    syncSignal(t, n) {
                        const i = this.now();
                        let s = this.bpm
                          , a = 1 / (60 / s.getValueAtTime(i) / this.PPQ)
                          , o = [];
                        if (t.units === "time") {
                            const u = .015625 / a
                              , f = new Er(u)
                              , m = new h9(-1)
                              , v = new Er(u);
                            s.chain(f, m, v),
                            s = v,
                            a = 1 / a,
                            o = [f, m, v]
                        }
                        n || (t.getValueAtTime(i) !== 0 ? n = t.getValueAtTime(i) / a : n = 0);
                        const c = new Er(n);
                        return s.connect(c),
                        c.connect(t._param),
                        o.push(c),
                        this._syncedSignals.push({
                            initial: t.value,
                            nodes: o,
                            signal: t
                        }),
                        t.value = 0,
                        this
                    }
                    unsyncSignal(t) {
                        for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
                            const i = this._syncedSignals[n];
                            i.signal === t && (i.nodes.forEach(s => s.dispose()),
                            i.signal.value = i.initial,
                            this._syncedSignals.splice(n, 1))
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._clock.dispose(),
                        m3(this, "bpm"),
                        this._timeline.dispose(),
                        this._repeatedEvents.dispose(),
                        this
                    }
                }
                ;
                cb.mixin(S3),
                lx(e => {
                    e.transport = new S3({
                        context: e
                    })
                }
                ),
                cx(e => {
                    e.transport.dispose()
                }
                );
                var eo = class extends In {
                    constructor(e) {
                        super(e),
                        this.input = void 0,
                        this._state = new db("stopped"),
                        this._synced = !1,
                        this._scheduled = [],
                        this._syncedStart = ci,
                        this._syncedStop = ci,
                        this._state.memory = 100,
                        this._state.increasing = !0,
                        this._volume = this.output = new hx({
                            context: this.context,
                            mute: e.mute,
                            volume: e.volume
                        }),
                        this.volume = this._volume.volume,
                        Ji(this, "volume"),
                        this.onstop = e.onstop
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            mute: !1,
                            onstop: ci,
                            volume: 0
                        })
                    }
                    get state() {
                        return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now())
                    }
                    get mute() {
                        return this._volume.mute
                    }
                    set mute(e) {
                        this._volume.mute = e
                    }
                    _clampToCurrentTime(e) {
                        return this._synced ? e : Math.max(e, this.context.currentTime)
                    }
                    start(e, t, n) {
                        let i = No(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
                        if (i = this._clampToCurrentTime(i),
                        !this._synced && this._state.getValueAtTime(i) === "started")
                            fn(xm(i, this._state.get(i).time), "Start time must be strictly greater than previous start time"),
                            this._state.cancel(i),
                            this._state.setStateAtTime("started", i),
                            this.log("restart", i),
                            this.restart(i, t, n);
                        else if (this.log("start", i),
                        this._state.setStateAtTime("started", i),
                        this._synced) {
                            const s = this._state.get(i);
                            s && (s.offset = this.toSeconds(Sm(t, 0)),
                            s.duration = n ? this.toSeconds(n) : void 0);
                            const a = this.context.transport.schedule(o => {
                                this._start(o, t, n)
                            }
                            , i);
                            this._scheduled.push(a),
                            this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > i && this._syncedStart(this.now(), this.context.transport.seconds)
                        } else
                            r3(this.context),
                            this._start(i, t, n);
                        return this
                    }
                    stop(e) {
                        let t = No(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
                        if (t = this._clampToCurrentTime(t),
                        this._state.getValueAtTime(t) === "started" || Tn(this._state.getNextState("started", t))) {
                            if (this.log("stop", t),
                            !this._synced)
                                this._stop(t);
                            else {
                                const n = this.context.transport.schedule(this._stop.bind(this), t);
                                this._scheduled.push(n)
                            }
                            this._state.cancel(t),
                            this._state.setStateAtTime("stopped", t)
                        }
                        return this
                    }
                    restart(e, t, n) {
                        return e = this.toSeconds(e),
                        this._state.getValueAtTime(e) === "started" && (this._state.cancel(e),
                        this._restart(e, t, n)),
                        this
                    }
                    sync() {
                        return this._synced || (this._synced = !0,
                        this._syncedStart = (e, t) => {
                            if (xm(t, 0)) {
                                const n = this._state.get(t);
                                if (n && n.state === "started" && n.time !== t) {
                                    const i = t - this.toSeconds(n.time);
                                    let s;
                                    n.duration && (s = this.toSeconds(n.duration) - i),
                                    this._start(e, this.toSeconds(n.offset) + i, s)
                                }
                            }
                        }
                        ,
                        this._syncedStop = e => {
                            const t = this.context.transport.getSecondsAtTime(Math.max(e - this.sampleTime, 0));
                            this._state.getValueAtTime(t) === "started" && this._stop(e)
                        }
                        ,
                        this.context.transport.on("start", this._syncedStart),
                        this.context.transport.on("loopStart", this._syncedStart),
                        this.context.transport.on("stop", this._syncedStop),
                        this.context.transport.on("pause", this._syncedStop),
                        this.context.transport.on("loopEnd", this._syncedStop)),
                        this
                    }
                    unsync() {
                        return this._synced && (this.context.transport.off("stop", this._syncedStop),
                        this.context.transport.off("pause", this._syncedStop),
                        this.context.transport.off("loopEnd", this._syncedStop),
                        this.context.transport.off("start", this._syncedStart),
                        this.context.transport.off("loopStart", this._syncedStart)),
                        this._synced = !1,
                        this._scheduled.forEach(e => this.context.transport.clear(e)),
                        this._scheduled = [],
                        this._state.cancel(0),
                        this._stop(0),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this.onstop = ci,
                        this.unsync(),
                        this._volume.dispose(),
                        this._state.dispose(),
                        this
                    }
                }
                  , x3 = class oO extends Tm {
                    constructor() {
                        const t = ln(oO.getDefaults(), arguments, ["url", "onload"]);
                        super(t),
                        this.name = "ToneBufferSource",
                        this._source = this.context.createBufferSource(),
                        this._internalChannels = [this._source],
                        this._sourceStarted = !1,
                        this._sourceStopped = !1,
                        Am(this._source, this._gainNode),
                        this._source.onended = () => this._stopSource(),
                        this.playbackRate = new ys({
                            context: this.context,
                            param: this._source.playbackRate,
                            units: "positive",
                            value: t.playbackRate
                        }),
                        this.loop = t.loop,
                        this.loopStart = t.loopStart,
                        this.loopEnd = t.loopEnd,
                        this._buffer = new Eh(t.url,t.onload,t.onerror),
                        this._internalChannels.push(this._source)
                    }
                    static getDefaults() {
                        return Object.assign(Tm.getDefaults(), {
                            url: new Eh,
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            onload: ci,
                            onerror: ci,
                            playbackRate: 1
                        })
                    }
                    get fadeIn() {
                        return this._fadeIn
                    }
                    set fadeIn(t) {
                        this._fadeIn = t
                    }
                    get fadeOut() {
                        return this._fadeOut
                    }
                    set fadeOut(t) {
                        this._fadeOut = t
                    }
                    get curve() {
                        return this._curve
                    }
                    set curve(t) {
                        this._curve = t
                    }
                    start(t, n, i, s=1) {
                        fn(this.buffer.loaded, "buffer is either not set or not loaded");
                        const a = this.toSeconds(t);
                        this._startGain(a, s),
                        this.loop ? n = Sm(n, this.loopStart) : n = Sm(n, 0);
                        let o = Math.max(this.toSeconds(n), 0);
                        if (this.loop) {
                            const c = this.toSeconds(this.loopEnd) || this.buffer.duration
                              , u = this.toSeconds(this.loopStart)
                              , f = c - u;
                            lb(o, c) && (o = (o - u) % f + u),
                            yl(o, this.buffer.duration) && (o = 0)
                        }
                        if (this._source.buffer = this.buffer.get(),
                        this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration,
                        ox(o, this.buffer.duration) && (this._sourceStarted = !0,
                        this._source.start(a, o)),
                        Tn(i)) {
                            let c = this.toSeconds(i);
                            c = Math.max(c, 0),
                            this.stop(a + c)
                        }
                        return this
                    }
                    _stopSource(t) {
                        !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0,
                        this._source.stop(this.toSeconds(t)),
                        this._onended())
                    }
                    get loopStart() {
                        return this._source.loopStart
                    }
                    set loopStart(t) {
                        this._source.loopStart = this.toSeconds(t)
                    }
                    get loopEnd() {
                        return this._source.loopEnd
                    }
                    set loopEnd(t) {
                        this._source.loopEnd = this.toSeconds(t)
                    }
                    get buffer() {
                        return this._buffer
                    }
                    set buffer(t) {
                        this._buffer.set(t)
                    }
                    get loop() {
                        return this._source.loop
                    }
                    set loop(t) {
                        this._source.loop = t,
                        this._sourceStarted && this.cancelStop()
                    }
                    dispose() {
                        return super.dispose(),
                        this._source.onended = null,
                        this._source.disconnect(),
                        this._buffer.dispose(),
                        this.playbackRate.dispose(),
                        this
                    }
                }
                ;
                const tY = 44100 * 5;
                function od(e, t) {
                    return gs(this, void 0, void 0, function*() {
                        const n = t / e.context.sampleRate
                          , i = new hb(1,n,e.context.sampleRate);
                        return new e.constructor(Object.assign(e.get(), {
                            frequency: 2 / n,
                            detune: 0,
                            context: i
                        })).toDestination().start(0),
                        (yield i.render()).getChannelData(0)
                    })
                }
                var d9 = class lO extends Tm {
                    constructor() {
                        const t = ln(lO.getDefaults(), arguments, ["frequency", "type"]);
                        super(t),
                        this.name = "ToneOscillatorNode",
                        this._oscillator = this.context.createOscillator(),
                        this._internalChannels = [this._oscillator],
                        Am(this._oscillator, this._gainNode),
                        this.type = t.type,
                        this.frequency = new ys({
                            context: this.context,
                            param: this._oscillator.frequency,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this.detune = new ys({
                            context: this.context,
                            param: this._oscillator.detune,
                            units: "cents",
                            value: t.detune
                        }),
                        Ji(this, ["frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(Tm.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            type: "sine"
                        })
                    }
                    start(t) {
                        const n = this.toSeconds(t);
                        return this.log("start", n),
                        this._startGain(n),
                        this._oscillator.start(n),
                        this
                    }
                    _stopSource(t) {
                        this._oscillator.stop(t)
                    }
                    setPeriodicWave(t) {
                        return this._oscillator.setPeriodicWave(t),
                        this
                    }
                    get type() {
                        return this._oscillator.type
                    }
                    set type(t) {
                        this._oscillator.type = t
                    }
                    dispose() {
                        return super.dispose(),
                        this.state === "started" && this.stop(),
                        this._oscillator.disconnect(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this
                    }
                }
                  , to = class hd extends eo {
                    constructor() {
                        const t = ln(hd.getDefaults(), arguments, ["frequency", "type"]);
                        super(t),
                        this.name = "Oscillator",
                        this._oscillator = null,
                        this.frequency = new Da({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        Ji(this, "frequency"),
                        this.detune = new Da({
                            context: this.context,
                            units: "cents",
                            value: t.detune
                        }),
                        Ji(this, "detune"),
                        this._partials = t.partials,
                        this._partialCount = t.partialCount,
                        this._type = t.type,
                        t.partialCount && t.type !== "custom" && (this._type = this.baseType + t.partialCount.toString()),
                        this.phase = t.phase
                    }
                    static getDefaults() {
                        return Object.assign(eo.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            partialCount: 0,
                            partials: [],
                            phase: 0,
                            type: "sine"
                        })
                    }
                    _start(t) {
                        const n = this.toSeconds(t);
                        this._oscillator = new d9({
                            context: this.context,
                            onended: () => this.onstop(this)
                        }),
                        this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type,
                        this._oscillator.connect(this.output),
                        this.frequency.connect(this._oscillator.frequency),
                        this.detune.connect(this._oscillator.detune),
                        this._oscillator.start(n)
                    }
                    _stop(t) {
                        const n = this.toSeconds(t);
                        this._oscillator && this._oscillator.stop(n)
                    }
                    _restart(t) {
                        const n = this.toSeconds(t);
                        return this.log("restart", n),
                        this._oscillator && this._oscillator.cancelStop(),
                        this._state.cancel(n),
                        this
                    }
                    syncFrequency() {
                        return this.context.transport.syncSignal(this.frequency),
                        this
                    }
                    unsyncFrequency() {
                        return this.context.transport.unsyncSignal(this.frequency),
                        this
                    }
                    _getCachedPeriodicWave() {
                        if (this._type === "custom")
                            return hd._periodicWaveCache.find(t => t.phase === this._phase && P7(t.partials, this._partials));
                        {
                            const t = hd._periodicWaveCache.find(n => n.type === this._type && n.phase === this._phase);
                            return this._partialCount = t ? t.partialCount : this._partialCount,
                            t
                        }
                    }
                    get type() {
                        return this._type
                    }
                    set type(t) {
                        this._type = t;
                        const n = ["sine", "square", "sawtooth", "triangle"].indexOf(t) !== -1;
                        if (this._phase === 0 && n)
                            this._wave = void 0,
                            this._partialCount = 0,
                            this._oscillator !== null && (this._oscillator.type = t);
                        else {
                            const i = this._getCachedPeriodicWave();
                            if (Tn(i)) {
                                const {partials: s, wave: a} = i;
                                this._wave = a,
                                this._partials = s,
                                this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave)
                            } else {
                                const [s,a] = this._getRealImaginary(t, this._phase);
                                this._wave = this.context.createPeriodicWave(s, a),
                                this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave),
                                hd._periodicWaveCache.push({
                                    imag: a,
                                    partialCount: this._partialCount,
                                    partials: this._partials,
                                    phase: this._phase,
                                    real: s,
                                    type: this._type,
                                    wave: this._wave
                                }),
                                hd._periodicWaveCache.length > 100 && hd._periodicWaveCache.shift()
                            }
                        }
                    }
                    get baseType() {
                        return this._type.replace(this.partialCount.toString(), "")
                    }
                    set baseType(t) {
                        this.partialCount && this._type !== "custom" && t !== "custom" ? this.type = t + this.partialCount : this.type = t
                    }
                    get partialCount() {
                        return this._partialCount
                    }
                    set partialCount(t) {
                        Mh(t, 0);
                        let n = this._type;
                        const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
                        if (i && (n = i[1]),
                        this._type !== "custom")
                            t === 0 ? this.type = n : this.type = n + t.toString();
                        else {
                            const s = new Float32Array(t);
                            this._partials.forEach( (a, o) => s[o] = a),
                            this._partials = Array.from(s),
                            this.type = this._type
                        }
                    }
                    _getRealImaginary(t, n) {
                        let i = 2048;
                        const s = new Float32Array(i)
                          , a = new Float32Array(i);
                        let o = 1;
                        if (t === "custom") {
                            if (o = this._partials.length + 1,
                            this._partialCount = this._partials.length,
                            i = o,
                            this._partials.length === 0)
                                return [s, a]
                        } else {
                            const c = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
                            c ? (o = parseInt(c[2], 10) + 1,
                            this._partialCount = parseInt(c[2], 10),
                            t = c[1],
                            o = Math.max(o, 2),
                            i = o) : this._partialCount = 0,
                            this._partials = []
                        }
                        for (let c = 1; c < i; ++c) {
                            const u = 2 / (c * Math.PI);
                            let f;
                            switch (t) {
                            case "sine":
                                f = c <= o ? 1 : 0,
                                this._partials[c - 1] = f;
                                break;
                            case "square":
                                f = c & 1 ? 2 * u : 0,
                                this._partials[c - 1] = f;
                                break;
                            case "sawtooth":
                                f = u * (c & 1 ? 1 : -1),
                                this._partials[c - 1] = f;
                                break;
                            case "triangle":
                                c & 1 ? f = 2 * (u * u) * (c - 1 >> 1 & 1 ? -1 : 1) : f = 0,
                                this._partials[c - 1] = f;
                                break;
                            case "custom":
                                f = this._partials[c - 1];
                                break;
                            default:
                                throw new TypeError("Oscillator: invalid type: " + t)
                            }
                            f !== 0 ? (s[c] = -f * Math.sin(n * c),
                            a[c] = f * Math.cos(n * c)) : (s[c] = 0,
                            a[c] = 0)
                        }
                        return [s, a]
                    }
                    _inverseFFT(t, n, i) {
                        let s = 0;
                        const a = t.length;
                        for (let o = 0; o < a; o++)
                            s += t[o] * Math.cos(o * i) + n[o] * Math.sin(o * i);
                        return s
                    }
                    getInitialValue() {
                        const [t,n] = this._getRealImaginary(this._type, 0);
                        let i = 0;
                        const s = Math.PI * 2
                          , a = 32;
                        for (let o = 0; o < a; o++)
                            i = Math.max(this._inverseFFT(t, n, o / a * s), i);
                        return F7(-this._inverseFFT(t, n, this._phase) / i, -1, 1)
                    }
                    get partials() {
                        return this._partials.slice(0, this.partialCount)
                    }
                    set partials(t) {
                        this._partials = t,
                        this._partialCount = this._partials.length,
                        t.length && (this.type = "custom")
                    }
                    get phase() {
                        return this._phase * (180 / Math.PI)
                    }
                    set phase(t) {
                        this._phase = t * Math.PI / 180,
                        this.type = this._type
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._oscillator !== null && this._oscillator.dispose(),
                        this._wave = void 0,
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this
                    }
                }
                ;
                to._periodicWaveCache = [];
                var p9 = class extends fx {
                    constructor() {
                        super(...arguments),
                        this.name = "AudioToGain",
                        this._norm = new vb({
                            context: this.context,
                            mapping: e => (e + 1) / 2
                        }),
                        this.input = this._norm,
                        this.output = this._norm
                    }
                    dispose() {
                        return super.dispose(),
                        this._norm.dispose(),
                        this
                    }
                }
                  , dx = class cO extends Da {
                    constructor() {
                        const t = ln(cO.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "Multiply",
                        this.override = !1,
                        this._mult = this.input = this.output = new Er({
                            context: this.context,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        }),
                        this.factor = this._param = this._mult.gain,
                        this.factor.setValueAtTime(t.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(Da.getDefaults(), {
                            value: 0
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._mult.dispose(),
                        this
                    }
                }
                  , A3 = class uO extends eo {
                    constructor() {
                        const t = ln(uO.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
                        super(t),
                        this.name = "AMOscillator",
                        this._modulationScale = new p9({
                            context: this.context
                        }),
                        this._modulationNode = new Er({
                            context: this.context
                        }),
                        this._carrier = new to({
                            context: this.context,
                            detune: t.detune,
                            frequency: t.frequency,
                            onstop: () => this.onstop(this),
                            phase: t.phase,
                            type: t.type
                        }),
                        this.frequency = this._carrier.frequency,
                        this.detune = this._carrier.detune,
                        this._modulator = new to({
                            context: this.context,
                            phase: t.phase,
                            type: t.modulationType
                        }),
                        this.harmonicity = new dx({
                            context: this.context,
                            units: "positive",
                            value: t.harmonicity
                        }),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this._modulator.chain(this._modulationScale, this._modulationNode.gain),
                        this._carrier.chain(this._modulationNode, this.output),
                        Ji(this, ["frequency", "detune", "harmonicity"])
                    }
                    static getDefaults() {
                        return Object.assign(to.getDefaults(), {
                            harmonicity: 1,
                            modulationType: "square"
                        })
                    }
                    _start(t) {
                        this._modulator.start(t),
                        this._carrier.start(t)
                    }
                    _stop(t) {
                        this._modulator.stop(t),
                        this._carrier.stop(t)
                    }
                    _restart(t) {
                        this._modulator.restart(t),
                        this._carrier.restart(t)
                    }
                    get type() {
                        return this._carrier.type
                    }
                    set type(t) {
                        this._carrier.type = t
                    }
                    get baseType() {
                        return this._carrier.baseType
                    }
                    set baseType(t) {
                        this._carrier.baseType = t
                    }
                    get partialCount() {
                        return this._carrier.partialCount
                    }
                    set partialCount(t) {
                        this._carrier.partialCount = t
                    }
                    get modulationType() {
                        return this._modulator.type
                    }
                    set modulationType(t) {
                        this._modulator.type = t
                    }
                    get phase() {
                        return this._carrier.phase
                    }
                    set phase(t) {
                        this._carrier.phase = t,
                        this._modulator.phase = t
                    }
                    get partials() {
                        return this._carrier.partials
                    }
                    set partials(t) {
                        this._carrier.partials = t
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this.harmonicity.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this._modulationNode.dispose(),
                        this._modulationScale.dispose(),
                        this
                    }
                }
                  , T3 = class hO extends eo {
                    constructor() {
                        const t = ln(hO.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
                        super(t),
                        this.name = "FMOscillator",
                        this._modulationNode = new Er({
                            context: this.context,
                            gain: 0
                        }),
                        this._carrier = new to({
                            context: this.context,
                            detune: t.detune,
                            frequency: 0,
                            onstop: () => this.onstop(this),
                            phase: t.phase,
                            type: t.type
                        }),
                        this.detune = this._carrier.detune,
                        this.frequency = new Da({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this._modulator = new to({
                            context: this.context,
                            phase: t.phase,
                            type: t.modulationType
                        }),
                        this.harmonicity = new dx({
                            context: this.context,
                            units: "positive",
                            value: t.harmonicity
                        }),
                        this.modulationIndex = new dx({
                            context: this.context,
                            units: "positive",
                            value: t.modulationIndex
                        }),
                        this.frequency.connect(this._carrier.frequency),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this.frequency.chain(this.modulationIndex, this._modulationNode),
                        this._modulator.connect(this._modulationNode.gain),
                        this._modulationNode.connect(this._carrier.frequency),
                        this._carrier.connect(this.output),
                        this.detune.connect(this._modulator.detune),
                        Ji(this, ["modulationIndex", "frequency", "detune", "harmonicity"])
                    }
                    static getDefaults() {
                        return Object.assign(to.getDefaults(), {
                            harmonicity: 1,
                            modulationIndex: 2,
                            modulationType: "square"
                        })
                    }
                    _start(t) {
                        this._modulator.start(t),
                        this._carrier.start(t)
                    }
                    _stop(t) {
                        this._modulator.stop(t),
                        this._carrier.stop(t)
                    }
                    _restart(t) {
                        return this._modulator.restart(t),
                        this._carrier.restart(t),
                        this
                    }
                    get type() {
                        return this._carrier.type
                    }
                    set type(t) {
                        this._carrier.type = t
                    }
                    get baseType() {
                        return this._carrier.baseType
                    }
                    set baseType(t) {
                        this._carrier.baseType = t
                    }
                    get partialCount() {
                        return this._carrier.partialCount
                    }
                    set partialCount(t) {
                        this._carrier.partialCount = t
                    }
                    get modulationType() {
                        return this._modulator.type
                    }
                    set modulationType(t) {
                        this._modulator.type = t
                    }
                    get phase() {
                        return this._carrier.phase
                    }
                    set phase(t) {
                        this._carrier.phase = t,
                        this._modulator.phase = t
                    }
                    get partials() {
                        return this._carrier.partials
                    }
                    set partials(t) {
                        this._carrier.partials = t
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.harmonicity.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this._modulationNode.dispose(),
                        this.modulationIndex.dispose(),
                        this
                    }
                }
                  , gb = class fO extends eo {
                    constructor() {
                        const t = ln(fO.getDefaults(), arguments, ["frequency", "width"]);
                        super(t),
                        this.name = "PulseOscillator",
                        this._widthGate = new Er({
                            context: this.context,
                            gain: 0
                        }),
                        this._thresh = new vb({
                            context: this.context,
                            mapping: n => n <= 0 ? -1 : 1
                        }),
                        this.width = new Da({
                            context: this.context,
                            units: "audioRange",
                            value: t.width
                        }),
                        this._triangle = new to({
                            context: this.context,
                            detune: t.detune,
                            frequency: t.frequency,
                            onstop: () => this.onstop(this),
                            phase: t.phase,
                            type: "triangle"
                        }),
                        this.frequency = this._triangle.frequency,
                        this.detune = this._triangle.detune,
                        this._triangle.chain(this._thresh, this.output),
                        this.width.chain(this._widthGate, this._thresh),
                        Ji(this, ["width", "frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(eo.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            phase: 0,
                            type: "pulse",
                            width: .2
                        })
                    }
                    _start(t) {
                        t = this.toSeconds(t),
                        this._triangle.start(t),
                        this._widthGate.gain.setValueAtTime(1, t)
                    }
                    _stop(t) {
                        t = this.toSeconds(t),
                        this._triangle.stop(t),
                        this._widthGate.gain.cancelScheduledValues(t),
                        this._widthGate.gain.setValueAtTime(0, t)
                    }
                    _restart(t) {
                        this._triangle.restart(t),
                        this._widthGate.gain.cancelScheduledValues(t),
                        this._widthGate.gain.setValueAtTime(1, t)
                    }
                    get phase() {
                        return this._triangle.phase
                    }
                    set phase(t) {
                        this._triangle.phase = t
                    }
                    get type() {
                        return "pulse"
                    }
                    get baseType() {
                        return "pulse"
                    }
                    get partials() {
                        return []
                    }
                    get partialCount() {
                        return 0
                    }
                    set carrierType(t) {
                        this._triangle.type = t
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._triangle.dispose(),
                        this.width.dispose(),
                        this._widthGate.dispose(),
                        this._thresh.dispose(),
                        this
                    }
                }
                  , M3 = class dO extends eo {
                    constructor() {
                        const t = ln(dO.getDefaults(), arguments, ["frequency", "type", "spread"]);
                        super(t),
                        this.name = "FatOscillator",
                        this._oscillators = [],
                        this.frequency = new Da({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this.detune = new Da({
                            context: this.context,
                            units: "cents",
                            value: t.detune
                        }),
                        this._spread = t.spread,
                        this._type = t.type,
                        this._phase = t.phase,
                        this._partials = t.partials,
                        this._partialCount = t.partialCount,
                        this.count = t.count,
                        Ji(this, ["frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(to.getDefaults(), {
                            count: 3,
                            spread: 20,
                            type: "sawtooth"
                        })
                    }
                    _start(t) {
                        t = this.toSeconds(t),
                        this._forEach(n => n.start(t))
                    }
                    _stop(t) {
                        t = this.toSeconds(t),
                        this._forEach(n => n.stop(t))
                    }
                    _restart(t) {
                        this._forEach(n => n.restart(t))
                    }
                    _forEach(t) {
                        for (let n = 0; n < this._oscillators.length; n++)
                            t(this._oscillators[n], n)
                    }
                    get type() {
                        return this._type
                    }
                    set type(t) {
                        this._type = t,
                        this._forEach(n => n.type = t)
                    }
                    get spread() {
                        return this._spread
                    }
                    set spread(t) {
                        if (this._spread = t,
                        this._oscillators.length > 1) {
                            const n = -t / 2
                              , i = t / (this._oscillators.length - 1);
                            this._forEach( (s, a) => s.detune.value = n + i * a)
                        }
                    }
                    get count() {
                        return this._oscillators.length
                    }
                    set count(t) {
                        if (Mh(t, 1),
                        this._oscillators.length !== t) {
                            this._forEach(n => n.dispose()),
                            this._oscillators = [];
                            for (let n = 0; n < t; n++) {
                                const i = new to({
                                    context: this.context,
                                    volume: -6 - t * 1.1,
                                    type: this._type,
                                    phase: this._phase + n / t * 360,
                                    partialCount: this._partialCount,
                                    onstop: n === 0 ? () => this.onstop(this) : ci
                                });
                                this.type === "custom" && (i.partials = this._partials),
                                this.frequency.connect(i.frequency),
                                this.detune.connect(i.detune),
                                i.detune.overridden = !1,
                                i.connect(this.output),
                                this._oscillators[n] = i
                            }
                            this.spread = this._spread,
                            this.state === "started" && this._forEach(n => n.start())
                        }
                    }
                    get phase() {
                        return this._phase
                    }
                    set phase(t) {
                        this._phase = t,
                        this._forEach( (n, i) => n.phase = this._phase + i / this.count * 360)
                    }
                    get baseType() {
                        return this._oscillators[0].baseType
                    }
                    set baseType(t) {
                        this._forEach(n => n.baseType = t),
                        this._type = this._oscillators[0].type
                    }
                    get partials() {
                        return this._oscillators[0].partials
                    }
                    set partials(t) {
                        this._partials = t,
                        this._partialCount = this._partials.length,
                        t.length && (this._type = "custom",
                        this._forEach(n => n.partials = t))
                    }
                    get partialCount() {
                        return this._oscillators[0].partialCount
                    }
                    set partialCount(t) {
                        this._partialCount = t,
                        this._forEach(n => n.partialCount = t),
                        this._type = this._oscillators[0].type
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this._forEach(t => t.dispose()),
                        this
                    }
                }
                  , b3 = class pO extends eo {
                    constructor() {
                        const t = ln(pO.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
                        super(t),
                        this.name = "PWMOscillator",
                        this.sourceType = "pwm",
                        this._scale = new dx({
                            context: this.context,
                            value: 2
                        }),
                        this._pulse = new gb({
                            context: this.context,
                            frequency: t.modulationFrequency
                        }),
                        this._pulse.carrierType = "sine",
                        this.modulationFrequency = this._pulse.frequency,
                        this._modulator = new to({
                            context: this.context,
                            detune: t.detune,
                            frequency: t.frequency,
                            onstop: () => this.onstop(this),
                            phase: t.phase
                        }),
                        this.frequency = this._modulator.frequency,
                        this.detune = this._modulator.detune,
                        this._modulator.chain(this._scale, this._pulse.width),
                        this._pulse.connect(this.output),
                        Ji(this, ["modulationFrequency", "frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(eo.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            modulationFrequency: .4,
                            phase: 0,
                            type: "pwm"
                        })
                    }
                    _start(t) {
                        t = this.toSeconds(t),
                        this._modulator.start(t),
                        this._pulse.start(t)
                    }
                    _stop(t) {
                        t = this.toSeconds(t),
                        this._modulator.stop(t),
                        this._pulse.stop(t)
                    }
                    _restart(t) {
                        this._modulator.restart(t),
                        this._pulse.restart(t)
                    }
                    get type() {
                        return "pwm"
                    }
                    get baseType() {
                        return "pwm"
                    }
                    get partials() {
                        return []
                    }
                    get partialCount() {
                        return 0
                    }
                    get phase() {
                        return this._modulator.phase
                    }
                    set phase(t) {
                        this._modulator.phase = t
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._pulse.dispose(),
                        this._scale.dispose(),
                        this._modulator.dispose(),
                        this
                    }
                }
                ;
                const E3 = {
                    am: A3,
                    fat: M3,
                    fm: T3,
                    oscillator: to,
                    pulse: gb,
                    pwm: b3
                };
                var C3 = class mO extends eo {
                    constructor() {
                        const t = ln(mO.getDefaults(), arguments, ["frequency", "type"]);
                        super(t),
                        this.name = "OmniOscillator",
                        this.frequency = new Da({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this.detune = new Da({
                            context: this.context,
                            units: "cents",
                            value: t.detune
                        }),
                        Ji(this, ["frequency", "detune"]),
                        this.set(t)
                    }
                    static getDefaults() {
                        return Object.assign(to.getDefaults(), T3.getDefaults(), A3.getDefaults(), M3.getDefaults(), gb.getDefaults(), b3.getDefaults())
                    }
                    _start(t) {
                        this._oscillator.start(t)
                    }
                    _stop(t) {
                        this._oscillator.stop(t)
                    }
                    _restart(t) {
                        return this._oscillator.restart(t),
                        this
                    }
                    get type() {
                        let t = "";
                        return ["am", "fm", "fat"].some(n => this._sourceType === n) && (t = this._sourceType),
                        t + this._oscillator.type
                    }
                    set type(t) {
                        t.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t.substr(2)) : t.substr(0, 2) === "am" ? (this._createNewOscillator("am"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t.substr(2)) : t.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t.substr(3)) : t === "pwm" ? (this._createNewOscillator("pwm"),
                        this._oscillator = this._oscillator) : t === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t)
                    }
                    get partials() {
                        return this._oscillator.partials
                    }
                    set partials(t) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = t)
                    }
                    get partialCount() {
                        return this._oscillator.partialCount
                    }
                    set partialCount(t) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = t)
                    }
                    set(t) {
                        return Reflect.has(t, "type") && t.type && (this.type = t.type),
                        super.set(t),
                        this
                    }
                    _createNewOscillator(t) {
                        if (t !== this._sourceType) {
                            this._sourceType = t;
                            const n = E3[t]
                              , i = this.now();
                            if (this._oscillator) {
                                const s = this._oscillator;
                                s.stop(i),
                                this.context.setTimeout( () => s.dispose(), this.blockTime)
                            }
                            this._oscillator = new n({
                                context: this.context
                            }),
                            this.frequency.connect(this._oscillator.frequency),
                            this.detune.connect(this._oscillator.detune),
                            this._oscillator.connect(this.output),
                            this._oscillator.onstop = () => this.onstop(this),
                            this.state === "started" && this._oscillator.start(i)
                        }
                    }
                    get phase() {
                        return this._oscillator.phase
                    }
                    set phase(t) {
                        this._oscillator.phase = t
                    }
                    get sourceType() {
                        return this._sourceType
                    }
                    set sourceType(t) {
                        let n = "sine";
                        this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type),
                        t === "fm" ? this.type = "fm" + n : t === "am" ? this.type = "am" + n : t === "fat" ? this.type = "fat" + n : t === "oscillator" ? this.type = n : t === "pulse" ? this.type = "pulse" : t === "pwm" && (this.type = "pwm")
                    }
                    _getOscType(t, n) {
                        return t instanceof E3[n]
                    }
                    get baseType() {
                        return this._oscillator.baseType
                    }
                    set baseType(t) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && t !== "pulse" && t !== "pwm" && (this._oscillator.baseType = t)
                    }
                    get width() {
                        if (this._getOscType(this._oscillator, "pulse"))
                            return this._oscillator.width
                    }
                    get count() {
                        if (this._getOscType(this._oscillator, "fat"))
                            return this._oscillator.count
                    }
                    set count(t) {
                        this._getOscType(this._oscillator, "fat") && td(t) && (this._oscillator.count = t)
                    }
                    get spread() {
                        if (this._getOscType(this._oscillator, "fat"))
                            return this._oscillator.spread
                    }
                    set spread(t) {
                        this._getOscType(this._oscillator, "fat") && td(t) && (this._oscillator.spread = t)
                    }
                    get modulationType() {
                        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
                            return this._oscillator.modulationType
                    }
                    set modulationType(t) {
                        (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && fu(t) && (this._oscillator.modulationType = t)
                    }
                    get modulationIndex() {
                        if (this._getOscType(this._oscillator, "fm"))
                            return this._oscillator.modulationIndex
                    }
                    get harmonicity() {
                        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
                            return this._oscillator.harmonicity
                    }
                    get modulationFrequency() {
                        if (this._getOscType(this._oscillator, "pwm"))
                            return this._oscillator.modulationFrequency
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            return od(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.detune.dispose(),
                        this.frequency.dispose(),
                        this._oscillator.dispose(),
                        this
                    }
                }
                ;
                function w3(e, t=1 / 0) {
                    const n = new WeakMap;
                    return function(i, s) {
                        Reflect.defineProperty(i, s, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return n.get(this)
                            },
                            set: function(a) {
                                Mh(a, e, t),
                                n.set(this, a)
                            }
                        })
                    }
                }
                function pu(e, t=1 / 0) {
                    const n = new WeakMap;
                    return function(i, s) {
                        Reflect.defineProperty(i, s, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return n.get(this)
                            },
                            set: function(a) {
                                Mh(this.toSeconds(a), e, t),
                                n.set(this, a)
                            }
                        })
                    }
                }
                var yb = class vO extends eo {
                    constructor() {
                        const t = ln(vO.getDefaults(), arguments, ["url", "onload"]);
                        super(t),
                        this.name = "Player",
                        this._activeSources = new Set,
                        this._buffer = new Eh({
                            onload: this._onload.bind(this, t.onload),
                            onerror: t.onerror,
                            reverse: t.reverse,
                            url: t.url
                        }),
                        this.autostart = t.autostart,
                        this._loop = t.loop,
                        this._loopStart = t.loopStart,
                        this._loopEnd = t.loopEnd,
                        this._playbackRate = t.playbackRate,
                        this.fadeIn = t.fadeIn,
                        this.fadeOut = t.fadeOut
                    }
                    static getDefaults() {
                        return Object.assign(eo.getDefaults(), {
                            autostart: !1,
                            fadeIn: 0,
                            fadeOut: 0,
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            onload: ci,
                            onerror: ci,
                            playbackRate: 1,
                            reverse: !1
                        })
                    }
                    load(t) {
                        return gs(this, void 0, void 0, function*() {
                            return yield this._buffer.load(t),
                            this._onload(),
                            this
                        })
                    }
                    _onload(t=ci) {
                        t(),
                        this.autostart && this.start()
                    }
                    _onSourceEnd(t) {
                        this.onstop(this),
                        this._activeSources.delete(t),
                        this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()),
                        this._state.setStateAtTime("stopped", this.now()))
                    }
                    start(t, n, i) {
                        return super.start(t, n, i),
                        this
                    }
                    _start(t, n, i) {
                        this._loop ? n = Sm(n, this._loopStart) : n = Sm(n, 0);
                        const s = this.toSeconds(n)
                          , a = i;
                        i = Sm(i, Math.max(this._buffer.duration - s, 0));
                        let o = this.toSeconds(i);
                        o = o / this._playbackRate,
                        t = this.toSeconds(t);
                        const c = new x3({
                            url: this._buffer,
                            context: this.context,
                            fadeIn: this.fadeIn,
                            fadeOut: this.fadeOut,
                            loop: this._loop,
                            loopEnd: this._loopEnd,
                            loopStart: this._loopStart,
                            onended: this._onSourceEnd.bind(this),
                            playbackRate: this._playbackRate
                        }).connect(this.output);
                        !this._loop && !this._synced && (this._state.cancel(t + o),
                        this._state.setStateAtTime("stopped", t + o, {
                            implicitEnd: !0
                        })),
                        this._activeSources.add(c),
                        this._loop && No(a) ? c.start(t, s) : c.start(t, s, o - this.toSeconds(this.fadeOut))
                    }
                    _stop(t) {
                        const n = this.toSeconds(t);
                        this._activeSources.forEach(i => i.stop(n))
                    }
                    restart(t, n, i) {
                        return super.restart(t, n, i),
                        this
                    }
                    _restart(t, n, i) {
                        var s;
                        (s = [...this._activeSources].pop()) === null || s === void 0 || s.stop(t),
                        this._start(t, n, i)
                    }
                    seek(t, n) {
                        const i = this.toSeconds(n);
                        if (this._state.getValueAtTime(i) === "started") {
                            const s = this.toSeconds(t);
                            this._stop(i),
                            this._start(i, s)
                        }
                        return this
                    }
                    setLoopPoints(t, n) {
                        return this.loopStart = t,
                        this.loopEnd = n,
                        this
                    }
                    get loopStart() {
                        return this._loopStart
                    }
                    set loopStart(t) {
                        this._loopStart = t,
                        this.buffer.loaded && Mh(this.toSeconds(t), 0, this.buffer.duration),
                        this._activeSources.forEach(n => {
                            n.loopStart = t
                        }
                        )
                    }
                    get loopEnd() {
                        return this._loopEnd
                    }
                    set loopEnd(t) {
                        this._loopEnd = t,
                        this.buffer.loaded && Mh(this.toSeconds(t), 0, this.buffer.duration),
                        this._activeSources.forEach(n => {
                            n.loopEnd = t
                        }
                        )
                    }
                    get buffer() {
                        return this._buffer
                    }
                    set buffer(t) {
                        this._buffer.set(t)
                    }
                    get loop() {
                        return this._loop
                    }
                    set loop(t) {
                        if (this._loop !== t && (this._loop = t,
                        this._activeSources.forEach(n => {
                            n.loop = t
                        }
                        ),
                        t)) {
                            const n = this._state.getNextState("stopped", this.now());
                            n && this._state.cancel(n.time)
                        }
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(t) {
                        this._playbackRate = t;
                        const n = this.now()
                          , i = this._state.getNextState("stopped", n);
                        i && i.implicitEnd && (this._state.cancel(i.time),
                        this._activeSources.forEach(s => s.cancelStop())),
                        this._activeSources.forEach(s => {
                            s.playbackRate.setValueAtTime(t, n)
                        }
                        )
                    }
                    get reverse() {
                        return this._buffer.reverse
                    }
                    set reverse(t) {
                        this._buffer.reverse = t
                    }
                    get loaded() {
                        return this._buffer.loaded
                    }
                    dispose() {
                        return super.dispose(),
                        this._activeSources.forEach(t => t.dispose()),
                        this._activeSources.clear(),
                        this._buffer.dispose(),
                        this
                    }
                }
                ;
                gl([pu(0)], yb.prototype, "fadeIn", void 0),
                gl([pu(0)], yb.prototype, "fadeOut", void 0);
                var bm = class gO extends In {
                    constructor() {
                        const t = ln(gO.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
                        super(t),
                        this.name = "Envelope",
                        this._sig = new Da({
                            context: this.context,
                            value: 0
                        }),
                        this.output = this._sig,
                        this.input = void 0,
                        this.attack = t.attack,
                        this.decay = t.decay,
                        this.sustain = t.sustain,
                        this.release = t.release,
                        this.attackCurve = t.attackCurve,
                        this.releaseCurve = t.releaseCurve,
                        this.decayCurve = t.decayCurve
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            attack: .01,
                            attackCurve: "linear",
                            decay: .1,
                            decayCurve: "exponential",
                            release: 1,
                            releaseCurve: "exponential",
                            sustain: .5
                        })
                    }
                    get value() {
                        return this.getValueAtTime(this.now())
                    }
                    _getCurve(t, n) {
                        if (fu(t))
                            return t;
                        {
                            let i;
                            for (i in px)
                                if (px[i][n] === t)
                                    return i;
                            return t
                        }
                    }
                    _setCurve(t, n, i) {
                        if (fu(i) && Reflect.has(px, i)) {
                            const s = px[i];
                            nd(s) ? t !== "_decayCurve" && (this[t] = s[n]) : this[t] = s
                        } else if (vl(i) && t !== "_decayCurve")
                            this[t] = i;
                        else
                            throw new Error("Envelope: invalid curve: " + i)
                    }
                    get attackCurve() {
                        return this._getCurve(this._attackCurve, "In")
                    }
                    set attackCurve(t) {
                        this._setCurve("_attackCurve", "In", t)
                    }
                    get releaseCurve() {
                        return this._getCurve(this._releaseCurve, "Out")
                    }
                    set releaseCurve(t) {
                        this._setCurve("_releaseCurve", "Out", t)
                    }
                    get decayCurve() {
                        return this._getCurve(this._decayCurve, "Out")
                    }
                    set decayCurve(t) {
                        this._setCurve("_decayCurve", "Out", t)
                    }
                    triggerAttack(t, n=1) {
                        this.log("triggerAttack", t, n),
                        t = this.toSeconds(t);
                        let i = this.toSeconds(this.attack);
                        const s = this.toSeconds(this.decay)
                          , a = this.getValueAtTime(t);
                        if (a > 0) {
                            const o = 1 / i;
                            i = (1 - a) / o
                        }
                        if (i < this.sampleTime)
                            this._sig.cancelScheduledValues(t),
                            this._sig.setValueAtTime(n, t);
                        else if (this._attackCurve === "linear")
                            this._sig.linearRampTo(n, i, t);
                        else if (this._attackCurve === "exponential")
                            this._sig.targetRampTo(n, i, t);
                        else {
                            this._sig.cancelAndHoldAtTime(t);
                            let o = this._attackCurve;
                            for (let c = 1; c < o.length; c++)
                                if (o[c - 1] <= a && a <= o[c]) {
                                    o = this._attackCurve.slice(c),
                                    o[0] = a;
                                    break
                                }
                            this._sig.setValueCurveAtTime(o, t, i, n)
                        }
                        if (s && this.sustain < 1) {
                            const o = n * this.sustain
                              , c = t + i;
                            this.log("decay", c),
                            this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(o, s + c) : this._sig.exponentialApproachValueAtTime(o, c, s)
                        }
                        return this
                    }
                    triggerRelease(t) {
                        this.log("triggerRelease", t),
                        t = this.toSeconds(t);
                        const n = this.getValueAtTime(t);
                        if (n > 0) {
                            const i = this.toSeconds(this.release);
                            i < this.sampleTime ? this._sig.setValueAtTime(0, t) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, i, t) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, i, t) : (fn(vl(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"),
                            this._sig.cancelAndHoldAtTime(t),
                            this._sig.setValueCurveAtTime(this._releaseCurve, t, i, n))
                        }
                        return this
                    }
                    getValueAtTime(t) {
                        return this._sig.getValueAtTime(t)
                    }
                    triggerAttackRelease(t, n, i=1) {
                        return n = this.toSeconds(n),
                        this.triggerAttack(n, i),
                        this.triggerRelease(n + this.toSeconds(t)),
                        this
                    }
                    cancel(t) {
                        return this._sig.cancelScheduledValues(this.toSeconds(t)),
                        this
                    }
                    connect(t, n=0, i=0) {
                        return mb(this, t, n, i),
                        this
                    }
                    asArray() {
                        return gs(this, arguments, void 0, function*(t=1024) {
                            const n = t / this.context.sampleRate
                              , i = new hb(1,n,this.context.sampleRate)
                              , s = this.toSeconds(this.attack) + this.toSeconds(this.decay)
                              , a = s + this.toSeconds(this.release)
                              , o = a * .1
                              , c = a + o
                              , u = new this.constructor(Object.assign(this.get(), {
                                attack: n * this.toSeconds(this.attack) / c,
                                decay: n * this.toSeconds(this.decay) / c,
                                release: n * this.toSeconds(this.release) / c,
                                context: i
                            }));
                            return u._sig.toDestination(),
                            u.triggerAttackRelease(n * (s + o) / c, 0),
                            (yield i.render()).getChannelData(0)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._sig.dispose(),
                        this
                    }
                }
                ;
                gl([pu(0)], bm.prototype, "attack", void 0),
                gl([pu(0)], bm.prototype, "decay", void 0),
                gl([w3(0, 1)], bm.prototype, "sustain", void 0),
                gl([pu(0)], bm.prototype, "release", void 0);
                const px = ( () => {
                    let t, n;
                    const i = [];
                    for (t = 0; t < 128; t++)
                        i[t] = Math.sin(t / 127 * (Math.PI / 2));
                    const s = []
                      , a = 6.4;
                    for (t = 0; t < 127; t++)
                        n = t / 127,
                        s[t] = (Math.sin(n * (Math.PI * 2) * a - Math.PI / 2) + 1) / 10 + n * .83;
                    s[127] = 1;
                    const o = []
                      , c = 5;
                    for (t = 0; t < 128; t++)
                        o[t] = Math.ceil(t / 127 * c) / c;
                    const u = [];
                    for (t = 0; t < 128; t++)
                        n = t / 127,
                        u[t] = .5 * (1 - Math.cos(Math.PI * n));
                    const f = [];
                    for (t = 0; t < 128; t++) {
                        n = t / 127;
                        const y = Math.pow(n, 3) * 4 + .2
                          , S = Math.cos(y * Math.PI * 2 * n);
                        f[t] = Math.abs(S * (1 - n))
                    }
                    function m(y) {
                        const S = new Array(y.length);
                        for (let A = 0; A < y.length; A++)
                            S[A] = 1 - y[A];
                        return S
                    }
                    function v(y) {
                        return y.slice(0).reverse()
                    }
                    return {
                        bounce: {
                            In: m(f),
                            Out: f
                        },
                        cosine: {
                            In: i,
                            Out: v(i)
                        },
                        exponential: "exponential",
                        linear: "linear",
                        ripple: {
                            In: s,
                            Out: m(s)
                        },
                        sine: {
                            In: u,
                            Out: m(u)
                        },
                        step: {
                            In: o,
                            Out: m(o)
                        }
                    }
                }
                )();
                var mx = class yO extends In {
                    constructor() {
                        const t = ln(yO.getDefaults(), arguments);
                        super(t),
                        this._scheduledEvents = [],
                        this._synced = !1,
                        this._original_triggerAttack = this.triggerAttack,
                        this._original_triggerRelease = this.triggerRelease,
                        this._syncedRelease = n => this._original_triggerRelease(n),
                        this._volume = this.output = new hx({
                            context: this.context,
                            volume: t.volume
                        }),
                        this.volume = this._volume.volume,
                        Ji(this, "volume")
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            volume: 0
                        })
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 0),
                        this.context.transport.on("stop", this._syncedRelease),
                        this.context.transport.on("pause", this._syncedRelease),
                        this.context.transport.on("loopEnd", this._syncedRelease)),
                        this
                    }
                    _syncState() {
                        let t = !1;
                        return this._synced || (this._synced = !0,
                        t = !0),
                        t
                    }
                    _syncMethod(t, n) {
                        const i = this["_original_" + t] = this[t];
                        this[t] = (...s) => {
                            const a = s[n]
                              , o = this.context.transport.schedule(c => {
                                s[n] = c,
                                i.apply(this, s)
                            }
                            , a);
                            this._scheduledEvents.push(o)
                        }
                    }
                    unsync() {
                        return this._scheduledEvents.forEach(t => this.context.transport.clear(t)),
                        this._scheduledEvents = [],
                        this._synced && (this._synced = !1,
                        this.triggerAttack = this._original_triggerAttack,
                        this.triggerRelease = this._original_triggerRelease,
                        this.context.transport.off("stop", this._syncedRelease),
                        this.context.transport.off("pause", this._syncedRelease),
                        this.context.transport.off("loopEnd", this._syncedRelease)),
                        this
                    }
                    triggerAttackRelease(t, n, i, s) {
                        const a = this.toSeconds(i)
                          , o = this.toSeconds(n);
                        return this.triggerAttack(t, a, s),
                        this.triggerRelease(a + o),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._volume.dispose(),
                        this.unsync(),
                        this._scheduledEvents = [],
                        this
                    }
                }
                  , vx = class _O extends mx {
                    constructor() {
                        const t = ln(_O.getDefaults(), arguments);
                        super(t),
                        this.portamento = t.portamento,
                        this.onsilence = t.onsilence
                    }
                    static getDefaults() {
                        return Object.assign(mx.getDefaults(), {
                            detune: 0,
                            onsilence: ci,
                            portamento: 0
                        })
                    }
                    triggerAttack(t, n, i=1) {
                        this.log("triggerAttack", t, n, i);
                        const s = this.toSeconds(n);
                        return this._triggerEnvelopeAttack(s, i),
                        this.setNote(t, s),
                        this
                    }
                    triggerRelease(t) {
                        this.log("triggerRelease", t);
                        const n = this.toSeconds(t);
                        return this._triggerEnvelopeRelease(n),
                        this
                    }
                    setNote(t, n) {
                        const i = this.toSeconds(n)
                          , s = t instanceof rd ? t.toFrequency() : t;
                        if (this.portamento > 0 && this.getLevelAtTime(i) > .05) {
                            const a = this.toSeconds(this.portamento);
                            this.frequency.exponentialRampTo(s, a, i)
                        } else
                            this.frequency.setValueAtTime(s, i);
                        return this
                    }
                }
                ;
                gl([pu(0)], vx.prototype, "portamento", void 0);
                var m9 = class SO extends bm {
                    constructor() {
                        super(ln(SO.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])),
                        this.name = "AmplitudeEnvelope",
                        this._gainNode = new Er({
                            context: this.context,
                            gain: 0
                        }),
                        this.output = this._gainNode,
                        this.input = this._gainNode,
                        this._sig.connect(this._gainNode.gain),
                        this.output = this._gainNode,
                        this.input = this._gainNode
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.dispose(),
                        this
                    }
                }
                  , D3 = class xO extends vx {
                    constructor() {
                        const t = ln(xO.getDefaults(), arguments);
                        super(t),
                        this.name = "Synth",
                        this.oscillator = new C3(Object.assign({
                            context: this.context,
                            detune: t.detune,
                            onstop: () => this.onsilence(this)
                        }, t.oscillator)),
                        this.frequency = this.oscillator.frequency,
                        this.detune = this.oscillator.detune,
                        this.envelope = new m9(Object.assign({
                            context: this.context
                        }, t.envelope)),
                        this.oscillator.chain(this.envelope, this.output),
                        Ji(this, ["oscillator", "frequency", "detune", "envelope"])
                    }
                    static getDefaults() {
                        return Object.assign(vx.getDefaults(), {
                            envelope: Object.assign(h3(bm.getDefaults(), Object.keys(In.getDefaults())), {
                                attack: .005,
                                decay: .1,
                                release: 1,
                                sustain: .3
                            }),
                            oscillator: Object.assign(h3(C3.getDefaults(), [...Object.keys(eo.getDefaults()), "frequency", "detune"]), {
                                type: "triangle"
                            })
                        })
                    }
                    _triggerEnvelopeAttack(t, n) {
                        if (this.envelope.triggerAttack(t, n),
                        this.oscillator.start(t),
                        this.envelope.sustain === 0) {
                            const i = this.toSeconds(this.envelope.attack)
                              , s = this.toSeconds(this.envelope.decay);
                            this.oscillator.stop(t + i + s)
                        }
                    }
                    _triggerEnvelopeRelease(t) {
                        this.envelope.triggerRelease(t),
                        this.oscillator.stop(t + this.toSeconds(this.envelope.release))
                    }
                    getLevelAtTime(t) {
                        return t = this.toSeconds(t),
                        this.envelope.getValueAtTime(t)
                    }
                    dispose() {
                        return super.dispose(),
                        this.oscillator.dispose(),
                        this.envelope.dispose(),
                        this
                    }
                }
                  , R3 = class AO extends D3 {
                    constructor() {
                        const t = ln(AO.getDefaults(), arguments);
                        super(t),
                        this.name = "MembraneSynth",
                        this.portamento = 0,
                        this.pitchDecay = t.pitchDecay,
                        this.octaves = t.octaves,
                        Ji(this, ["oscillator", "envelope"])
                    }
                    static getDefaults() {
                        return _m(vx.getDefaults(), D3.getDefaults(), {
                            envelope: {
                                attack: .001,
                                attackCurve: "exponential",
                                decay: .4,
                                release: 1.4,
                                sustain: .01
                            },
                            octaves: 10,
                            oscillator: {
                                type: "sine"
                            },
                            pitchDecay: .05
                        })
                    }
                    setNote(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.toFrequency(t instanceof rd ? t.toFrequency() : t)
                          , a = s * this.octaves;
                        return this.oscillator.frequency.setValueAtTime(a, i),
                        this.oscillator.frequency.exponentialRampToValueAtTime(s, i + this.toSeconds(this.pitchDecay)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this
                    }
                }
                ;
                gl([w3(0)], R3.prototype, "octaves", void 0),
                gl([pu(0)], R3.prototype, "pitchDecay", void 0);
                const U3 = new Set;
                function _b(e) {
                    U3.add(e)
                }
                function O3(e, t) {
                    const n = `registerProcessor("${e}", ${t})`;
                    U3.add(n)
                }
                _b(`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`);
                const v9 = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
                _b(v9),
                _b(`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`);
                const g9 = "feedback-comb-filter";
                O3(g9, `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`);
                var N3 = class TO extends mx {
                    constructor() {
                        const t = ln(TO.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
                        super(t),
                        this.name = "Sampler",
                        this._activeSources = new Map;
                        const n = {};
                        Object.keys(t.urls).forEach(i => {
                            const s = parseInt(i, 10);
                            if (fn(ax(i) || td(s) && isFinite(s), `url key is neither a note or midi pitch: ${i}`),
                            ax(i)) {
                                const a = new rd(this.context,i).toMidi();
                                n[a] = t.urls[i]
                            } else
                                td(s) && isFinite(s) && (n[s] = t.urls[s])
                        }
                        ),
                        this._buffers = new r9({
                            urls: n,
                            onload: t.onload,
                            baseUrl: t.baseUrl,
                            onerror: t.onerror
                        }),
                        this.attack = t.attack,
                        this.release = t.release,
                        this.curve = t.curve,
                        this._buffers.loaded && Promise.resolve().then(t.onload)
                    }
                    static getDefaults() {
                        return Object.assign(mx.getDefaults(), {
                            attack: 0,
                            baseUrl: "",
                            curve: "exponential",
                            onload: ci,
                            onerror: ci,
                            release: .1,
                            urls: {}
                        })
                    }
                    _findClosest(t) {
                        let i = 0;
                        for (; i < 96; ) {
                            if (this._buffers.has(t + i))
                                return -i;
                            if (this._buffers.has(t - i))
                                return i;
                            i++
                        }
                        throw new Error(`No available buffers for note: ${t}`)
                    }
                    triggerAttack(t, n, i=1) {
                        return this.log("triggerAttack", t, n, i),
                        Array.isArray(t) || (t = [t]),
                        t.forEach(s => {
                            const a = y3(new rd(this.context,s).toFrequency())
                              , o = Math.round(a)
                              , c = a - o
                              , u = this._findClosest(o)
                              , f = o - u
                              , m = this._buffers.get(f)
                              , v = g3(u + c)
                              , y = new x3({
                                url: m,
                                context: this.context,
                                curve: this.curve,
                                fadeIn: this.attack,
                                fadeOut: this.release,
                                playbackRate: v
                            }).connect(this.output);
                            y.start(n, 0, m.duration / v, i),
                            vl(this._activeSources.get(o)) || this._activeSources.set(o, []),
                            this._activeSources.get(o).push(y),
                            y.onended = () => {
                                if (this._activeSources && this._activeSources.has(o)) {
                                    const S = this._activeSources.get(o)
                                      , A = S.indexOf(y);
                                    A !== -1 && S.splice(A, 1)
                                }
                            }
                        }
                        ),
                        this
                    }
                    triggerRelease(t, n) {
                        return this.log("triggerRelease", t, n),
                        Array.isArray(t) || (t = [t]),
                        t.forEach(i => {
                            const s = new rd(this.context,i).toMidi();
                            if (this._activeSources.has(s) && this._activeSources.get(s).length) {
                                const a = this._activeSources.get(s);
                                n = this.toSeconds(n),
                                a.forEach(o => {
                                    o.stop(n)
                                }
                                ),
                                this._activeSources.set(s, [])
                            }
                        }
                        ),
                        this
                    }
                    releaseAll(t) {
                        const n = this.toSeconds(t);
                        return this._activeSources.forEach(i => {
                            for (; i.length; )
                                i.shift().stop(n)
                        }
                        ),
                        this
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 1)),
                        this
                    }
                    triggerAttackRelease(t, n, i, s=1) {
                        const a = this.toSeconds(i);
                        return this.triggerAttack(t, a, s),
                        vl(n) ? (fn(vl(t), "notes must be an array when duration is array"),
                        t.forEach( (o, c) => {
                            const u = n[Math.min(c, n.length - 1)];
                            this.triggerRelease(o, a + this.toSeconds(u))
                        }
                        )) : this.triggerRelease(t, a + this.toSeconds(n)),
                        this
                    }
                    add(t, n, i) {
                        if (fn(ax(t) || isFinite(t), `note must be a pitch or midi: ${t}`),
                        ax(t)) {
                            const s = new rd(this.context,t).toMidi();
                            this._buffers.add(s, n, i)
                        } else
                            this._buffers.add(t, n, i);
                        return this
                    }
                    get loaded() {
                        return this._buffers.loaded
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffers.dispose(),
                        this._activeSources.forEach(t => {
                            t.forEach(n => n.dispose())
                        }
                        ),
                        this._activeSources.clear(),
                        this
                    }
                }
                ;
                gl([pu(0)], N3.prototype, "attack", void 0),
                gl([pu(0)], N3.prototype, "release", void 0);
                var y9 = class MO extends In {
                    constructor() {
                        const t = ln(MO.getDefaults(), arguments, ["pan"]);
                        super(t),
                        this.name = "Panner",
                        this._panner = this.context.createStereoPanner(),
                        this.input = this._panner,
                        this.output = this._panner,
                        this.pan = new ys({
                            context: this.context,
                            param: this._panner.pan,
                            value: t.pan,
                            minValue: -1,
                            maxValue: 1
                        }),
                        this._panner.channelCount = t.channelCount,
                        this._panner.channelCountMode = "explicit",
                        Ji(this, "pan")
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            pan: 0,
                            channelCount: 1
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._panner.disconnect(),
                        this.pan.dispose(),
                        this
                    }
                }
                ;
                const _9 = "bit-crusher"
                  , S9 = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
                O3(_9, S9);
                const nY = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100]
                  , iY = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];
                var Sb = class oa extends In {
                    constructor() {
                        const t = ln(oa.getDefaults(), arguments, ["solo"]);
                        super(t),
                        this.name = "Solo",
                        this.input = this.output = new Er({
                            context: this.context
                        }),
                        oa._allSolos.has(this.context) || oa._allSolos.set(this.context, new Set),
                        oa._allSolos.get(this.context).add(this),
                        this.solo = t.solo
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            solo: !1
                        })
                    }
                    get solo() {
                        return this._isSoloed()
                    }
                    set solo(t) {
                        t ? this._addSolo() : this._removeSolo(),
                        oa._allSolos.get(this.context).forEach(n => n._updateSolo())
                    }
                    get muted() {
                        return this.input.gain.value === 0
                    }
                    _addSolo() {
                        oa._soloed.has(this.context) || oa._soloed.set(this.context, new Set),
                        oa._soloed.get(this.context).add(this)
                    }
                    _removeSolo() {
                        oa._soloed.has(this.context) && oa._soloed.get(this.context).delete(this)
                    }
                    _isSoloed() {
                        return oa._soloed.has(this.context) && oa._soloed.get(this.context).has(this)
                    }
                    _noSolos() {
                        return !oa._soloed.has(this.context) || oa._soloed.has(this.context) && oa._soloed.get(this.context).size === 0
                    }
                    _updateSolo() {
                        this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0
                    }
                    dispose() {
                        return super.dispose(),
                        oa._allSolos.get(this.context).delete(this),
                        this._removeSolo(),
                        this
                    }
                }
                ;
                Sb._allSolos = new Map,
                Sb._soloed = new Map;
                var x9 = class bO extends In {
                    constructor() {
                        const t = ln(bO.getDefaults(), arguments, ["pan", "volume"]);
                        super(t),
                        this.name = "PanVol",
                        this._panner = this.input = new y9({
                            context: this.context,
                            pan: t.pan,
                            channelCount: t.channelCount
                        }),
                        this.pan = this._panner.pan,
                        this._volume = this.output = new hx({
                            context: this.context,
                            volume: t.volume
                        }),
                        this.volume = this._volume.volume,
                        this._panner.connect(this._volume),
                        this.mute = t.mute,
                        Ji(this, ["pan", "volume"])
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            mute: !1,
                            pan: 0,
                            volume: 0,
                            channelCount: 1
                        })
                    }
                    get mute() {
                        return this._volume.mute
                    }
                    set mute(t) {
                        this._volume.mute = t
                    }
                    dispose() {
                        return super.dispose(),
                        this._panner.dispose(),
                        this.pan.dispose(),
                        this._volume.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                  , A9 = class A0 extends In {
                    constructor() {
                        const t = ln(A0.getDefaults(), arguments, ["volume", "pan"]);
                        super(t),
                        this.name = "Channel",
                        this._solo = this.input = new Sb({
                            solo: t.solo,
                            context: this.context
                        }),
                        this._panVol = this.output = new x9({
                            context: this.context,
                            pan: t.pan,
                            volume: t.volume,
                            mute: t.mute,
                            channelCount: t.channelCount
                        }),
                        this.pan = this._panVol.pan,
                        this.volume = this._panVol.volume,
                        this._solo.connect(this._panVol),
                        Ji(this, ["pan", "volume"])
                    }
                    static getDefaults() {
                        return Object.assign(In.getDefaults(), {
                            pan: 0,
                            volume: 0,
                            mute: !1,
                            solo: !1,
                            channelCount: 1
                        })
                    }
                    get solo() {
                        return this._solo.solo
                    }
                    set solo(t) {
                        this._solo.solo = t
                    }
                    get muted() {
                        return this._solo.muted || this.mute
                    }
                    get mute() {
                        return this._panVol.mute
                    }
                    set mute(t) {
                        this._panVol.mute = t
                    }
                    _getBus(t) {
                        return A0.buses.has(t) || A0.buses.set(t, new Er({
                            context: this.context
                        })),
                        A0.buses.get(t)
                    }
                    send(t, n=0) {
                        const i = this._getBus(t)
                          , s = new Er({
                            context: this.context,
                            units: "decibels",
                            gain: n
                        });
                        return this.connect(s),
                        s.connect(i),
                        s
                    }
                    receive(t) {
                        return this._getBus(t).connect(this),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._panVol.dispose(),
                        this.pan.dispose(),
                        this.volume.dispose(),
                        this._solo.dispose(),
                        this
                    }
                }
                ;
                A9.buses = new Map;
                const B3 = _l().transport
                  , sY = _l().destination
                  , aY = _l().destination
                  , rY = _l().listener
                  , oY = _l().draw
                  , lY = _l();
                function T9() {
                    var e = Object.create(null);
                    function t(s, a) {
                        var o = s.id
                          , c = s.name
                          , u = s.dependencies;
                        u === void 0 && (u = []);
                        var f = s.init;
                        f === void 0 && (f = function() {}
                        );
                        var m = s.getTransferables;
                        if (m === void 0 && (m = null),
                        !e[o])
                            try {
                                u = u.map(function(y) {
                                    return y && y.isWorkerModule && (t(y, function(S) {
                                        if (S instanceof Error)
                                            throw S
                                    }),
                                    y = e[y.id].value),
                                    y
                                }),
                                f = i("<" + c + ">.init", f),
                                m && (m = i("<" + c + ">.getTransferables", m));
                                var v = null;
                                typeof f == "function" ? v = f.apply(void 0, u) : console.error("worker module init function failed to rehydrate"),
                                e[o] = {
                                    id: o,
                                    value: v,
                                    getTransferables: m
                                },
                                a(v)
                            } catch (y) {
                                y && y.noLog || console.error(y),
                                a(y)
                            }
                    }
                    function n(s, a) {
                        var o, c = s.id, u = s.args;
                        (!e[c] || typeof e[c].value != "function") && a(new Error("Worker module " + c + ": not found or its 'init' did not return a function"));
                        try {
                            var f = (o = e[c]).value.apply(o, u);
                            f && typeof f.then == "function" ? f.then(m, function(v) {
                                return a(v instanceof Error ? v : new Error("" + v))
                            }) : m(f)
                        } catch (v) {
                            a(v)
                        }
                        function m(v) {
                            try {
                                var y = e[c].getTransferables && e[c].getTransferables(v);
                                (!y || !Array.isArray(y) || !y.length) && (y = void 0),
                                a(v, y)
                            } catch (S) {
                                console.error(S),
                                a(S)
                            }
                        }
                    }
                    function i(s, a) {
                        var o = void 0;
                        self.troikaDefine = function(u) {
                            return o = u
                        }
                        ;
                        var c = URL.createObjectURL(new Blob(["/** " + s.replace(/\*/g, "") + ` **/

troikaDefine(
` + a + `
)`],{
                            type: "application/javascript"
                        }));
                        try {
                            importScripts(c)
                        } catch (u) {
                            console.error(u)
                        }
                        return URL.revokeObjectURL(c),
                        delete self.troikaDefine,
                        o
                    }
                    self.addEventListener("message", function(s) {
                        var a = s.data
                          , o = a.messageId
                          , c = a.action
                          , u = a.data;
                        try {
                            c === "registerModule" && t(u, function(f) {
                                f instanceof Error ? postMessage({
                                    messageId: o,
                                    success: !1,
                                    error: f.message
                                }) : postMessage({
                                    messageId: o,
                                    success: !0,
                                    result: {
                                        isCallable: typeof f == "function"
                                    }
                                })
                            }),
                            c === "callModule" && n(u, function(f, m) {
                                f instanceof Error ? postMessage({
                                    messageId: o,
                                    success: !1,
                                    error: f.message
                                }) : postMessage({
                                    messageId: o,
                                    success: !0,
                                    result: f
                                }, m || void 0)
                            })
                        } catch (f) {
                            postMessage({
                                messageId: o,
                                success: !1,
                                error: f.stack
                            })
                        }
                    })
                }
                function M9(e) {
                    var t = function() {
                        for (var n = [], i = arguments.length; i--; )
                            n[i] = arguments[i];
                        return t._getInitResult().then(function(s) {
                            if (typeof s == "function")
                                return s.apply(void 0, n);
                            throw new Error("Worker module function was called but `init` did not return a callable function")
                        })
                    };
                    return t._getInitResult = function() {
                        var n = e.dependencies
                          , i = e.init;
                        n = Array.isArray(n) ? n.map(function(a) {
                            return a && (a = a.onMainThread || a,
                            a._getInitResult && (a = a._getInitResult())),
                            a
                        }) : [];
                        var s = Promise.all(n).then(function(a) {
                            return i.apply(null, a)
                        });
                        return t._getInitResult = function() {
                            return s
                        }
                        ,
                        s
                    }
                    ,
                    t
                }
                var L3 = function() {
                    var e = !1;
                    if (typeof window < "u" && typeof window.document < "u")
                        try {
                            new Worker(URL.createObjectURL(new Blob([""],{
                                type: "application/javascript"
                            }))).terminate(),
                            e = !0
                        } catch (t) {
                            console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]")
                        }
                    return L3 = function() {
                        return e
                    }
                    ,
                    e
                }
                  , b9 = 0
                  , E9 = 0
                  , xb = !1
                  , y0 = Object.create(null)
                  , _0 = Object.create(null)
                  , Ab = Object.create(null);
                function Em(e) {
                    if ((!e || typeof e.init != "function") && !xb)
                        throw new Error("requires `options.init` function");
                    var t = e.dependencies
                      , n = e.init
                      , i = e.getTransferables
                      , s = e.workerId
                      , a = M9(e);
                    s == null && (s = "#default");
                    var o = "workerModule" + ++b9
                      , c = e.name || o
                      , u = null;
                    t = t && t.map(function(m) {
                        return typeof m == "function" && !m.workerModuleData && (xb = !0,
                        m = Em({
                            workerId: s,
                            name: "<" + c + "> function dependency: " + m.name,
                            init: `function(){return (
` + gx(m) + `
)}`
                        }),
                        xb = !1),
                        m && m.workerModuleData && (m = m.workerModuleData),
                        m
                    });
                    function f() {
                        for (var m = [], v = arguments.length; v--; )
                            m[v] = arguments[v];
                        if (!L3())
                            return a.apply(void 0, m);
                        if (!u) {
                            u = I3(s, "registerModule", f.workerModuleData);
                            var y = function() {
                                u = null,
                                _0[s].delete(y)
                            };
                            (_0[s] || (_0[s] = new Set)).add(y)
                        }
                        return u.then(function(S) {
                            if (S.isCallable)
                                return I3(s, "callModule", {
                                    id: o,
                                    args: m
                                });
                            throw new Error("Worker module function was called but `init` did not return a callable function")
                        })
                    }
                    return f.workerModuleData = {
                        isWorkerModule: !0,
                        id: o,
                        name: c,
                        dependencies: t,
                        init: gx(n),
                        getTransferables: i && gx(i)
                    },
                    f.onMainThread = a,
                    f
                }
                function C9(e) {
                    _0[e] && _0[e].forEach(function(t) {
                        t()
                    }),
                    y0[e] && (y0[e].terminate(),
                    delete y0[e])
                }
                function gx(e) {
                    var t = e.toString();
                    return !/^function/.test(t) && /^\w+\s*\(/.test(t) && (t = "function " + t),
                    t
                }
                function w9(e) {
                    var t = y0[e];
                    if (!t) {
                        var n = gx(T9);
                        t = y0[e] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + e.replace(/\*/g, "") + ` **/

;(` + n + ")()"],{
                            type: "application/javascript"
                        }))),
                        t.onmessage = function(i) {
                            var s = i.data
                              , a = s.messageId
                              , o = Ab[a];
                            if (!o)
                                throw new Error("WorkerModule response with empty or unknown messageId");
                            delete Ab[a],
                            o(s)
                        }
                    }
                    return t
                }
                function I3(e, t, n) {
                    return new Promise(function(i, s) {
                        var a = ++E9;
                        Ab[a] = function(o) {
                            o.success ? i(o.result) : s(new Error("Error in worker " + t + " call: " + o.error))
                        }
                        ,
                        w9(e).postMessage({
                            messageId: a,
                            action: t,
                            data: n
                        })
                    }
                    )
                }
                function P3() {
                    return (function(e) {
                        function t(V, Z, j, ee, H, ie, se, K) {
                            var le = 1 - se;
                            K.x = le * le * V + 2 * le * se * j + se * se * H,
                            K.y = le * le * Z + 2 * le * se * ee + se * se * ie
                        }
                        function n(V, Z, j, ee, H, ie, se, K, le, ue) {
                            var de = 1 - le;
                            ue.x = de * de * de * V + 3 * de * de * le * j + 3 * de * le * le * H + le * le * le * se,
                            ue.y = de * de * de * Z + 3 * de * de * le * ee + 3 * de * le * le * ie + le * le * le * K
                        }
                        function i(V, Z) {
                            for (var j = /([MLQCZ])([^MLQCZ]*)/g, ee, H, ie, se, K; ee = j.exec(V); ) {
                                var le = ee[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(ue) {
                                    return parseFloat(ue)
                                });
                                switch (ee[1]) {
                                case "M":
                                    se = H = le[0],
                                    K = ie = le[1];
                                    break;
                                case "L":
                                    (le[0] !== se || le[1] !== K) && Z("L", se, K, se = le[0], K = le[1]);
                                    break;
                                case "Q":
                                    Z("Q", se, K, se = le[2], K = le[3], le[0], le[1]);
                                    break;
                                case "C":
                                    Z("C", se, K, se = le[4], K = le[5], le[0], le[1], le[2], le[3]);
                                    break;
                                case "Z":
                                    (se !== H || K !== ie) && Z("L", se, K, H, ie);
                                    break
                                }
                            }
                        }
                        function s(V, Z, j) {
                            j === void 0 && (j = 16);
                            var ee = {
                                x: 0,
                                y: 0
                            };
                            i(V, function(H, ie, se, K, le, ue, de, qe, ze) {
                                switch (H) {
                                case "L":
                                    Z(ie, se, K, le);
                                    break;
                                case "Q":
                                    for (var Ee = ie, re = se, Le = 1; Le < j; Le++)
                                        t(ie, se, ue, de, K, le, Le / (j - 1), ee),
                                        Z(Ee, re, ee.x, ee.y),
                                        Ee = ee.x,
                                        re = ee.y;
                                    break;
                                case "C":
                                    for (var he = ie, ye = se, xe = 1; xe < j; xe++)
                                        n(ie, se, ue, de, qe, ze, K, le, xe / (j - 1), ee),
                                        Z(he, ye, ee.x, ee.y),
                                        he = ee.x,
                                        ye = ee.y;
                                    break
                                }
                            })
                        }
                        var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}"
                          , o = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}"
                          , c = new WeakMap
                          , u = {
                            premultipliedAlpha: !1,
                            preserveDrawingBuffer: !0,
                            antialias: !1,
                            depth: !1
                        };
                        function f(V, Z) {
                            var j = V.getContext ? V.getContext("webgl", u) : V
                              , ee = c.get(j);
                            if (!ee) {
                                let he = function(we) {
                                    var it = ie[we];
                                    if (!it && (it = ie[we] = j.getExtension(we),
                                    !it))
                                        throw new Error(we + " not supported");
                                    return it
                                }
                                  , ye = function(we, it) {
                                    var je = j.createShader(it);
                                    return j.shaderSource(je, we),
                                    j.compileShader(je),
                                    je
                                }
                                  , xe = function(we, it, je, $) {
                                    if (!se[we]) {
                                        var Y = {}
                                          , pe = {}
                                          , He = j.createProgram();
                                        j.attachShader(He, ye(it, j.VERTEX_SHADER)),
                                        j.attachShader(He, ye(je, j.FRAGMENT_SHADER)),
                                        j.linkProgram(He),
                                        se[we] = {
                                            program: He,
                                            transaction: function(De) {
                                                j.useProgram(He),
                                                De({
                                                    setUniform: function($e, ct) {
                                                        for (var gt = [], Ie = arguments.length - 2; Ie-- > 0; )
                                                            gt[Ie] = arguments[Ie + 2];
                                                        var Je = pe[ct] || (pe[ct] = j.getUniformLocation(He, ct));
                                                        j["uniform" + $e].apply(j, [Je].concat(gt))
                                                    },
                                                    setAttribute: function($e, ct, gt, Ie, Je) {
                                                        var Ze = Y[$e];
                                                        Ze || (Ze = Y[$e] = {
                                                            buf: j.createBuffer(),
                                                            loc: j.getAttribLocation(He, $e),
                                                            data: null
                                                        }),
                                                        j.bindBuffer(j.ARRAY_BUFFER, Ze.buf),
                                                        j.vertexAttribPointer(Ze.loc, ct, j.FLOAT, !1, 0, 0),
                                                        j.enableVertexAttribArray(Ze.loc),
                                                        H ? j.vertexAttribDivisor(Ze.loc, Ie) : he("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Ze.loc, Ie),
                                                        Je !== Ze.data && (j.bufferData(j.ARRAY_BUFFER, Je, gt),
                                                        Ze.data = Je)
                                                    }
                                                })
                                            }
                                        }
                                    }
                                    se[we].transaction($)
                                }
                                  , ge = function(we, it) {
                                    le++;
                                    try {
                                        j.activeTexture(j.TEXTURE0 + le);
                                        var je = K[we];
                                        je || (je = K[we] = j.createTexture(),
                                        j.bindTexture(j.TEXTURE_2D, je),
                                        j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MIN_FILTER, j.NEAREST),
                                        j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MAG_FILTER, j.NEAREST)),
                                        j.bindTexture(j.TEXTURE_2D, je),
                                        it(je, le)
                                    } finally {
                                        le--
                                    }
                                }
                                  , Te = function(we, it, je) {
                                    var $ = j.createFramebuffer();
                                    ue.push($),
                                    j.bindFramebuffer(j.FRAMEBUFFER, $),
                                    j.activeTexture(j.TEXTURE0 + it),
                                    j.bindTexture(j.TEXTURE_2D, we),
                                    j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, we, 0);
                                    try {
                                        je($)
                                    } finally {
                                        j.deleteFramebuffer($),
                                        j.bindFramebuffer(j.FRAMEBUFFER, ue[--ue.length - 1] || null)
                                    }
                                }
                                  , Ae = function() {
                                    ie = {},
                                    se = {},
                                    K = {},
                                    le = -1,
                                    ue.length = 0
                                };
                                var de = he
                                  , qe = ye
                                  , ze = xe
                                  , Ee = ge
                                  , re = Te
                                  , Le = Ae
                                  , H = typeof WebGL2RenderingContext < "u" && j instanceof WebGL2RenderingContext
                                  , ie = {}
                                  , se = {}
                                  , K = {}
                                  , le = -1
                                  , ue = [];
                                j.canvas.addEventListener("webglcontextlost", function(we) {
                                    Ae(),
                                    we.preventDefault()
                                }, !1),
                                c.set(j, ee = {
                                    gl: j,
                                    isWebGL2: H,
                                    getExtension: he,
                                    withProgram: xe,
                                    withTexture: ge,
                                    withTextureFramebuffer: Te,
                                    handleContextLoss: Ae
                                })
                            }
                            Z(ee)
                        }
                        function m(V, Z, j, ee, H, ie, se, K) {
                            se === void 0 && (se = 15),
                            K === void 0 && (K = null),
                            f(V, function(le) {
                                var ue = le.gl
                                  , de = le.withProgram
                                  , qe = le.withTexture;
                                qe("copy", function(ze, Ee) {
                                    ue.texImage2D(ue.TEXTURE_2D, 0, ue.RGBA, H, ie, 0, ue.RGBA, ue.UNSIGNED_BYTE, Z),
                                    de("copy", a, o, function(re) {
                                        var Le = re.setUniform
                                          , he = re.setAttribute;
                                        he("aUV", 2, ue.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])),
                                        Le("1i", "image", Ee),
                                        ue.bindFramebuffer(ue.FRAMEBUFFER, K || null),
                                        ue.disable(ue.BLEND),
                                        ue.colorMask(se & 8, se & 4, se & 2, se & 1),
                                        ue.viewport(j, ee, H, ie),
                                        ue.scissor(j, ee, H, ie),
                                        ue.drawArrays(ue.TRIANGLES, 0, 3)
                                    })
                                })
                            })
                        }
                        function v(V, Z, j) {
                            var ee = V.width
                              , H = V.height;
                            f(V, function(ie) {
                                var se = ie.gl
                                  , K = new Uint8Array(ee * H * 4);
                                se.readPixels(0, 0, ee, H, se.RGBA, se.UNSIGNED_BYTE, K),
                                V.width = Z,
                                V.height = j,
                                m(se, K, 0, 0, ee, H)
                            })
                        }
                        var y = Object.freeze({
                            __proto__: null,
                            withWebGLContext: f,
                            renderImageData: m,
                            resizeWebGLCanvasWithoutClearing: v
                        });
                        function S(V, Z, j, ee, H, ie) {
                            ie === void 0 && (ie = 1);
                            var se = new Uint8Array(V * Z)
                              , K = ee[2] - ee[0]
                              , le = ee[3] - ee[1]
                              , ue = [];
                            s(j, function(he, ye, xe, ge) {
                                ue.push({
                                    x1: he,
                                    y1: ye,
                                    x2: xe,
                                    y2: ge,
                                    minX: Math.min(he, xe),
                                    minY: Math.min(ye, ge),
                                    maxX: Math.max(he, xe),
                                    maxY: Math.max(ye, ge)
                                })
                            }),
                            ue.sort(function(he, ye) {
                                return he.maxX - ye.maxX
                            });
                            for (var de = 0; de < V; de++)
                                for (var qe = 0; qe < Z; qe++) {
                                    var ze = re(ee[0] + K * (de + .5) / V, ee[1] + le * (qe + .5) / Z)
                                      , Ee = Math.pow(1 - Math.abs(ze) / H, ie) / 2;
                                    ze < 0 && (Ee = 1 - Ee),
                                    Ee = Math.max(0, Math.min(255, Math.round(Ee * 255))),
                                    se[qe * V + de] = Ee
                                }
                            return se;
                            function re(he, ye) {
                                for (var xe = 1 / 0, ge = 1 / 0, Te = ue.length; Te--; ) {
                                    var Ae = ue[Te];
                                    if (Ae.maxX + ge <= he)
                                        break;
                                    if (he + ge > Ae.minX && ye - ge < Ae.maxY && ye + ge > Ae.minY) {
                                        var we = x(he, ye, Ae.x1, Ae.y1, Ae.x2, Ae.y2);
                                        we < xe && (xe = we,
                                        ge = Math.sqrt(xe))
                                    }
                                }
                                return Le(he, ye) && (ge = -ge),
                                ge
                            }
                            function Le(he, ye) {
                                for (var xe = 0, ge = ue.length; ge--; ) {
                                    var Te = ue[ge];
                                    if (Te.maxX <= he)
                                        break;
                                    Te.y1 > ye != Te.y2 > ye && he < (Te.x2 - Te.x1) * (ye - Te.y1) / (Te.y2 - Te.y1) + Te.x1 && (xe += Te.y1 < Te.y2 ? 1 : -1)
                                }
                                return xe !== 0
                            }
                        }
                        function A(V, Z, j, ee, H, ie, se, K, le, ue) {
                            ie === void 0 && (ie = 1),
                            K === void 0 && (K = 0),
                            le === void 0 && (le = 0),
                            ue === void 0 && (ue = 0),
                            M(V, Z, j, ee, H, ie, se, null, K, le, ue)
                        }
                        function M(V, Z, j, ee, H, ie, se, K, le, ue, de) {
                            ie === void 0 && (ie = 1),
                            le === void 0 && (le = 0),
                            ue === void 0 && (ue = 0),
                            de === void 0 && (de = 0);
                            for (var qe = S(V, Z, j, ee, H, ie), ze = new Uint8Array(qe.length * 4), Ee = 0; Ee < qe.length; Ee++)
                                ze[Ee * 4 + de] = qe[Ee];
                            m(se, ze, le, ue, V, Z, 1 << 3 - de, K)
                        }
                        function x(V, Z, j, ee, H, ie) {
                            var se = H - j
                              , K = ie - ee
                              , le = se * se + K * K
                              , ue = le ? Math.max(0, Math.min(1, ((V - j) * se + (Z - ee) * K) / le)) : 0
                              , de = V - (j + ue * se)
                              , qe = Z - (ee + ue * K);
                            return de * de + qe * qe
                        }
                        var T = Object.freeze({
                            __proto__: null,
                            generate: S,
                            generateIntoCanvas: A,
                            generateIntoFramebuffer: M
                        })
                          , D = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}"
                          , w = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}"
                          , U = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}"
                          , O = new Float32Array([0, 0, 2, 0, 0, 2])
                          , L = null
                          , N = !1
                          , z = {}
                          , I = new WeakMap;
                        function B(V) {
                            if (!N && !Q(V))
                                throw new Error("WebGL generation not supported")
                        }
                        function G(V, Z, j, ee, H, ie, se) {
                            if (ie === void 0 && (ie = 1),
                            se === void 0 && (se = null),
                            !se && (se = L,
                            !se)) {
                                var K = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1,1) : typeof document < "u" ? document.createElement("canvas") : null;
                                if (!K)
                                    throw new Error("OffscreenCanvas or DOM canvas not supported");
                                se = L = K.getContext("webgl", {
                                    depth: !1
                                })
                            }
                            B(se);
                            var le = new Uint8Array(V * Z * 4);
                            f(se, function(ze) {
                                var Ee = ze.gl
                                  , re = ze.withTexture
                                  , Le = ze.withTextureFramebuffer;
                                re("readable", function(he, ye) {
                                    Ee.texImage2D(Ee.TEXTURE_2D, 0, Ee.RGBA, V, Z, 0, Ee.RGBA, Ee.UNSIGNED_BYTE, null),
                                    Le(he, ye, function(xe) {
                                        q(V, Z, j, ee, H, ie, Ee, xe, 0, 0, 0),
                                        Ee.readPixels(0, 0, V, Z, Ee.RGBA, Ee.UNSIGNED_BYTE, le)
                                    })
                                })
                            });
                            for (var ue = new Uint8Array(V * Z), de = 0, qe = 0; de < le.length; de += 4)
                                ue[qe++] = le[de];
                            return ue
                        }
                        function X(V, Z, j, ee, H, ie, se, K, le, ue) {
                            ie === void 0 && (ie = 1),
                            K === void 0 && (K = 0),
                            le === void 0 && (le = 0),
                            ue === void 0 && (ue = 0),
                            q(V, Z, j, ee, H, ie, se, null, K, le, ue)
                        }
                        function q(V, Z, j, ee, H, ie, se, K, le, ue, de) {
                            ie === void 0 && (ie = 1),
                            le === void 0 && (le = 0),
                            ue === void 0 && (ue = 0),
                            de === void 0 && (de = 0),
                            B(se);
                            var qe = [];
                            s(j, function(ze, Ee, re, Le) {
                                qe.push(ze, Ee, re, Le)
                            }),
                            qe = new Float32Array(qe),
                            f(se, function(ze) {
                                var Ee = ze.gl
                                  , re = ze.isWebGL2
                                  , Le = ze.getExtension
                                  , he = ze.withProgram
                                  , ye = ze.withTexture
                                  , xe = ze.withTextureFramebuffer
                                  , ge = ze.handleContextLoss;
                                if (ye("rawDistances", function(Te, Ae) {
                                    (V !== Te._lastWidth || Z !== Te._lastHeight) && Ee.texImage2D(Ee.TEXTURE_2D, 0, Ee.RGBA, Te._lastWidth = V, Te._lastHeight = Z, 0, Ee.RGBA, Ee.UNSIGNED_BYTE, null),
                                    he("main", D, w, function(we) {
                                        var it = we.setAttribute
                                          , je = we.setUniform
                                          , $ = !re && Le("ANGLE_instanced_arrays")
                                          , Y = !re && Le("EXT_blend_minmax");
                                        it("aUV", 2, Ee.STATIC_DRAW, 0, O),
                                        it("aLineSegment", 4, Ee.DYNAMIC_DRAW, 1, qe),
                                        je.apply(void 0, ["4f", "uGlyphBounds"].concat(ee)),
                                        je("1f", "uMaxDistance", H),
                                        je("1f", "uExponent", ie),
                                        xe(Te, Ae, function(pe) {
                                            Ee.enable(Ee.BLEND),
                                            Ee.colorMask(!0, !0, !0, !0),
                                            Ee.viewport(0, 0, V, Z),
                                            Ee.scissor(0, 0, V, Z),
                                            Ee.blendFunc(Ee.ONE, Ee.ONE),
                                            Ee.blendEquationSeparate(Ee.FUNC_ADD, re ? Ee.MAX : Y.MAX_EXT),
                                            Ee.clear(Ee.COLOR_BUFFER_BIT),
                                            re ? Ee.drawArraysInstanced(Ee.TRIANGLES, 0, 3, qe.length / 4) : $.drawArraysInstancedANGLE(Ee.TRIANGLES, 0, 3, qe.length / 4)
                                        })
                                    }),
                                    he("post", a, U, function(we) {
                                        we.setAttribute("aUV", 2, Ee.STATIC_DRAW, 0, O),
                                        we.setUniform("1i", "tex", Ae),
                                        Ee.bindFramebuffer(Ee.FRAMEBUFFER, K),
                                        Ee.disable(Ee.BLEND),
                                        Ee.colorMask(de === 0, de === 1, de === 2, de === 3),
                                        Ee.viewport(le, ue, V, Z),
                                        Ee.scissor(le, ue, V, Z),
                                        Ee.drawArrays(Ee.TRIANGLES, 0, 3)
                                    })
                                }),
                                Ee.isContextLost())
                                    throw ge(),
                                    new Error("webgl context lost")
                            })
                        }
                        function Q(V) {
                            var Z = !V || V === L ? z : V.canvas || V
                              , j = I.get(Z);
                            if (j === void 0) {
                                N = !0;
                                var ee = null;
                                try {
                                    var H = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97]
                                      , ie = G(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, V);
                                    j = ie && H.length === ie.length && ie.every(function(se, K) {
                                        return se === H[K]
                                    }),
                                    j || (ee = "bad trial run results",
                                    console.info(H, ie))
                                } catch (se) {
                                    j = !1,
                                    ee = se.message
                                }
                                ee && console.warn("WebGL SDF generation not supported:", ee),
                                N = !1,
                                I.set(Z, j)
                            }
                            return j
                        }
                        var oe = Object.freeze({
                            __proto__: null,
                            generate: G,
                            generateIntoCanvas: X,
                            generateIntoFramebuffer: q,
                            isSupported: Q
                        });
                        function k(V, Z, j, ee, H, ie) {
                            H === void 0 && (H = Math.max(ee[2] - ee[0], ee[3] - ee[1]) / 2),
                            ie === void 0 && (ie = 1);
                            try {
                                return G.apply(oe, arguments)
                            } catch (se) {
                                return console.info("WebGL SDF generation failed, falling back to JS", se),
                                S.apply(T, arguments)
                            }
                        }
                        function W(V, Z, j, ee, H, ie, se, K, le, ue) {
                            H === void 0 && (H = Math.max(ee[2] - ee[0], ee[3] - ee[1]) / 2),
                            ie === void 0 && (ie = 1),
                            K === void 0 && (K = 0),
                            le === void 0 && (le = 0),
                            ue === void 0 && (ue = 0);
                            try {
                                return X.apply(oe, arguments)
                            } catch (de) {
                                return console.info("WebGL SDF generation failed, falling back to JS", de),
                                A.apply(T, arguments)
                            }
                        }
                        return e.forEachPathCommand = i,
                        e.generate = k,
                        e.generateIntoCanvas = W,
                        e.javascript = T,
                        e.pathToLineSegments = s,
                        e.webgl = oe,
                        e.webglUtils = y,
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e
                    }
                    )({})
                }
                function D9() {
                    return (function(e) {
                        var t = {
                            R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
                            EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
                            ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
                            ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
                            AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
                            CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
                            B: "a,3,f+2,2v,690",
                            S: "9,2,k",
                            WS: "c,k,4f4,1vk+a,u,1j,335",
                            ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
                            BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
                            NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
                            AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
                            LRO: "6ct",
                            RLO: "6cu",
                            LRE: "6cq",
                            RLE: "6cr",
                            PDF: "6cs",
                            LRI: "6ee",
                            RLI: "6ef",
                            FSI: "6eg",
                            PDI: "6eh"
                        }
                          , n = {}
                          , i = {};
                        n.L = 1,
                        i[1] = "L",
                        Object.keys(t).forEach(function(ge, Te) {
                            n[ge] = 1 << Te + 1,
                            i[n[ge]] = ge
                        }),
                        Object.freeze(n);
                        var s = n.LRI | n.RLI | n.FSI
                          , a = n.L | n.R | n.AL
                          , o = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI
                          , c = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF
                          , u = n.S | n.WS | n.B | s | n.PDI | c
                          , f = null;
                        function m() {
                            if (!f) {
                                f = new Map;
                                var ge = function(Ae) {
                                    if (t.hasOwnProperty(Ae)) {
                                        var we = 0;
                                        t[Ae].split(",").forEach(function(it) {
                                            var je = it.split("+")
                                              , $ = je[0]
                                              , Y = je[1];
                                            $ = parseInt($, 36),
                                            Y = Y ? parseInt(Y, 36) : 0,
                                            f.set(we += $, n[Ae]);
                                            for (var pe = 0; pe < Y; pe++)
                                                f.set(++we, n[Ae])
                                        })
                                    }
                                };
                                for (var Te in t)
                                    ge(Te)
                            }
                        }
                        function v(ge) {
                            return m(),
                            f.get(ge.codePointAt(0)) || n.L
                        }
                        function y(ge) {
                            return i[v(ge)]
                        }
                        var S = {
                            pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
                            canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
                        };
                        function A(ge, Te) {
                            var Ae = 36, we = 0, it = new Map, je = Te && new Map, $;
                            return ge.split(",").forEach(function Y(pe) {
                                if (pe.indexOf("+") !== -1)
                                    for (var He = +pe; He--; )
                                        Y($);
                                else {
                                    $ = pe;
                                    var Re = pe.split(">")
                                      , De = Re[0]
                                      , rt = Re[1];
                                    De = String.fromCodePoint(we += parseInt(De, Ae)),
                                    rt = String.fromCodePoint(we += parseInt(rt, Ae)),
                                    it.set(De, rt),
                                    Te && je.set(rt, De)
                                }
                            }),
                            {
                                map: it,
                                reverseMap: je
                            }
                        }
                        var M, x, T;
                        function D() {
                            if (!M) {
                                var ge = A(S.pairs, !0)
                                  , Te = ge.map
                                  , Ae = ge.reverseMap;
                                M = Te,
                                x = Ae,
                                T = A(S.canonical, !1).map
                            }
                        }
                        function w(ge) {
                            return D(),
                            M.get(ge) || null
                        }
                        function U(ge) {
                            return D(),
                            x.get(ge) || null
                        }
                        function O(ge) {
                            return D(),
                            T.get(ge) || null
                        }
                        var L = n.L
                          , N = n.R
                          , z = n.EN
                          , I = n.ES
                          , B = n.ET
                          , G = n.AN
                          , X = n.CS
                          , q = n.B
                          , Q = n.S
                          , oe = n.ON
                          , k = n.BN
                          , W = n.NSM
                          , V = n.AL
                          , Z = n.LRO
                          , j = n.RLO
                          , ee = n.LRE
                          , H = n.RLE
                          , ie = n.PDF
                          , se = n.LRI
                          , K = n.RLI
                          , le = n.FSI
                          , ue = n.PDI;
                        function de(ge, Te) {
                            for (var Ae = 125, we = new Uint32Array(ge.length), it = 0; it < ge.length; it++)
                                we[it] = v(ge[it]);
                            var je = new Map;
                            function $(xs, Is) {
                                var As = we[xs];
                                we[xs] = Is,
                                je.set(As, je.get(As) - 1),
                                As & o && je.set(o, je.get(o) - 1),
                                je.set(Is, (je.get(Is) || 0) + 1),
                                Is & o && je.set(o, (je.get(o) || 0) + 1)
                            }
                            for (var Y = new Uint8Array(ge.length), pe = new Map, He = [], Re = null, De = 0; De < ge.length; De++)
                                Re || He.push(Re = {
                                    start: De,
                                    end: ge.length - 1,
                                    level: Te === "rtl" ? 1 : Te === "ltr" ? 0 : Yi(De, !1)
                                }),
                                we[De] & q && (Re.end = De,
                                Re = null);
                            for (var rt = H | ee | j | Z | s | ue | ie | q, $e = function(xs) {
                                return xs + (xs & 1 ? 1 : 2)
                            }, ct = function(xs) {
                                return xs + (xs & 1 ? 2 : 1)
                            }, gt = 0; gt < He.length; gt++) {
                                Re = He[gt];
                                var Ie = [{
                                    _level: Re.level,
                                    _override: 0,
                                    _isolate: 0
                                }]
                                  , Je = void 0
                                  , Ze = 0
                                  , ht = 0
                                  , lt = 0;
                                je.clear();
                                for (var At = Re.start; At <= Re.end; At++) {
                                    var fe = we[At];
                                    if (Je = Ie[Ie.length - 1],
                                    je.set(fe, (je.get(fe) || 0) + 1),
                                    fe & o && je.set(o, (je.get(o) || 0) + 1),
                                    fe & rt)
                                        if (fe & (H | ee)) {
                                            Y[At] = Je._level;
                                            var ot = (fe === H ? ct : $e)(Je._level);
                                            ot <= Ae && !Ze && !ht ? Ie.push({
                                                _level: ot,
                                                _override: 0,
                                                _isolate: 0
                                            }) : Ze || ht++
                                        } else if (fe & (j | Z)) {
                                            Y[At] = Je._level;
                                            var tt = (fe === j ? ct : $e)(Je._level);
                                            tt <= Ae && !Ze && !ht ? Ie.push({
                                                _level: tt,
                                                _override: fe & j ? N : L,
                                                _isolate: 0
                                            }) : Ze || ht++
                                        } else if (fe & s) {
                                            fe & le && (fe = Yi(At + 1, !0) === 1 ? K : se),
                                            Y[At] = Je._level,
                                            Je._override && $(At, Je._override);
                                            var xt = (fe === K ? ct : $e)(Je._level);
                                            xt <= Ae && Ze === 0 && ht === 0 ? (lt++,
                                            Ie.push({
                                                _level: xt,
                                                _override: 0,
                                                _isolate: 1,
                                                _isolInitIndex: At
                                            })) : Ze++
                                        } else if (fe & ue) {
                                            if (Ze > 0)
                                                Ze--;
                                            else if (lt > 0) {
                                                for (ht = 0; !Ie[Ie.length - 1]._isolate; )
                                                    Ie.pop();
                                                var Qe = Ie[Ie.length - 1]._isolInitIndex;
                                                Qe != null && (pe.set(Qe, At),
                                                pe.set(At, Qe)),
                                                Ie.pop(),
                                                lt--
                                            }
                                            Je = Ie[Ie.length - 1],
                                            Y[At] = Je._level,
                                            Je._override && $(At, Je._override)
                                        } else
                                            fe & ie ? (Ze === 0 && (ht > 0 ? ht-- : !Je._isolate && Ie.length > 1 && (Ie.pop(),
                                            Je = Ie[Ie.length - 1])),
                                            Y[At] = Je._level) : fe & q && (Y[At] = Re.level);
                                    else
                                        Y[At] = Je._level,
                                        Je._override && fe !== k && $(At, Je._override)
                                }
                                for (var Ne = [], dt = null, _t = Re.start; _t <= Re.end; _t++) {
                                    var Ct = we[_t];
                                    if (!(Ct & c)) {
                                        var Ot = Y[_t]
                                          , Mn = Ct & s
                                          , Un = Ct === ue;
                                        dt && Ot === dt._level ? (dt._end = _t,
                                        dt._endsWithIsolInit = Mn) : Ne.push(dt = {
                                            _start: _t,
                                            _end: _t,
                                            _level: Ot,
                                            _startsWithPDI: Un,
                                            _endsWithIsolInit: Mn
                                        })
                                    }
                                }
                                for (var On = [], ki = 0; ki < Ne.length; ki++) {
                                    var Bs = Ne[ki];
                                    if (!Bs._startsWithPDI || Bs._startsWithPDI && !pe.has(Bs._start)) {
                                        for (var Ls = [dt = Bs], Ai = void 0; dt && dt._endsWithIsolInit && (Ai = pe.get(dt._end)) != null; )
                                            for (var _s = ki + 1; _s < Ne.length; _s++)
                                                if (Ne[_s]._start === Ai) {
                                                    Ls.push(dt = Ne[_s]);
                                                    break
                                                }
                                        for (var ei = [], ti = 0; ti < Ls.length; ti++)
                                            for (var Oi = Ls[ti], Qt = Oi._start; Qt <= Oi._end; Qt++)
                                                ei.push(Qt);
                                        for (var Xi = Y[ei[0]], lr = Re.level, Cr = ei[0] - 1; Cr >= 0; Cr--)
                                            if (!(we[Cr] & c)) {
                                                lr = Y[Cr];
                                                break
                                            }
                                        var Sl = ei[ei.length - 1]
                                          , Ch = Y[Sl]
                                          , te = Re.level;
                                        if (!(we[Sl] & s)) {
                                            for (var Se = Sl + 1; Se <= Re.end; Se++)
                                                if (!(we[Se] & c)) {
                                                    te = Y[Se];
                                                    break
                                                }
                                        }
                                        On.push({
                                            _seqIndices: ei,
                                            _sosType: Math.max(lr, Xi) % 2 ? N : L,
                                            _eosType: Math.max(te, Ch) % 2 ? N : L
                                        })
                                    }
                                }
                                for (var Ge = 0; Ge < On.length; Ge++) {
                                    var Ue = On[Ge]
                                      , ce = Ue._seqIndices
                                      , at = Ue._sosType
                                      , yt = Ue._eosType
                                      , pt = Y[ce[0]] & 1 ? N : L;
                                    if (je.get(W))
                                        for (var St = 0; St < ce.length; St++) {
                                            var Lt = ce[St];
                                            if (we[Lt] & W) {
                                                for (var Ut = at, Dt = St - 1; Dt >= 0; Dt--)
                                                    if (!(we[ce[Dt]] & c)) {
                                                        Ut = we[ce[Dt]];
                                                        break
                                                    }
                                                $(Lt, Ut & (s | ue) ? oe : Ut)
                                            }
                                        }
                                    if (je.get(z))
                                        for (var Kt = 0; Kt < ce.length; Kt++) {
                                            var bn = ce[Kt];
                                            if (we[bn] & z)
                                                for (var _n = Kt - 1; _n >= -1; _n--) {
                                                    var Wn = _n === -1 ? at : we[ce[_n]];
                                                    if (Wn & a) {
                                                        Wn === V && $(bn, G);
                                                        break
                                                    }
                                                }
                                        }
                                    if (je.get(V))
                                        for (var dn = 0; dn < ce.length; dn++) {
                                            var Et = ce[dn];
                                            we[Et] & V && $(Et, N)
                                        }
                                    if (je.get(I) || je.get(X))
                                        for (var vn = 1; vn < ce.length - 1; vn++) {
                                            var Ht = ce[vn];
                                            if (we[Ht] & (I | X)) {
                                                for (var Ni = 0, Ua = 0, Ti = vn - 1; Ti >= 0 && (Ni = we[ce[Ti]],
                                                !!(Ni & c)); Ti--)
                                                    ;
                                                for (var Oa = vn + 1; Oa < ce.length && (Ua = we[ce[Oa]],
                                                !!(Ua & c)); Oa++)
                                                    ;
                                                Ni === Ua && (we[Ht] === I ? Ni === z : Ni & (z | G)) && $(Ht, Ni)
                                            }
                                        }
                                    if (je.get(z))
                                        for (var Jt = 0; Jt < ce.length; Jt++) {
                                            var Ss = ce[Jt];
                                            if (we[Ss] & z) {
                                                for (var Nn = Jt - 1; Nn >= 0 && we[ce[Nn]] & (B | c); Nn--)
                                                    $(ce[Nn], z);
                                                for (Jt++; Jt < ce.length && we[ce[Jt]] & (B | c | z); Jt++)
                                                    we[ce[Jt]] !== z && $(ce[Jt], z)
                                            }
                                        }
                                    if (je.get(B) || je.get(I) || je.get(X))
                                        for (var qn = 0; qn < ce.length; qn++) {
                                            var ls = ce[qn];
                                            if (we[ls] & (B | I | X)) {
                                                $(ls, oe);
                                                for (var Na = qn - 1; Na >= 0 && we[ce[Na]] & c; Na--)
                                                    $(ce[Na], oe);
                                                for (var $i = qn + 1; $i < ce.length && we[ce[$i]] & c; $i++)
                                                    $(ce[$i], oe)
                                            }
                                        }
                                    if (je.get(z))
                                        for (var yc = 0, no = at; yc < ce.length; yc++) {
                                            var io = ce[yc]
                                              , xl = we[io];
                                            xl & z ? no === L && $(io, L) : xl & a && (no = xl)
                                        }
                                    if (je.get(o)) {
                                        for (var wr = N | z | G, mu = wr | L, so = [], Bo = [], Lo = 0; Lo < ce.length; Lo++)
                                            if (we[ce[Lo]] & o) {
                                                var Dr = ge[ce[Lo]]
                                                  , Ba = void 0;
                                                if (w(Dr) !== null)
                                                    if (Bo.length < 63)
                                                        Bo.push({
                                                            char: Dr,
                                                            seqIndex: Lo
                                                        });
                                                    else
                                                        break;
                                                else if ((Ba = U(Dr)) !== null)
                                                    for (var Rr = Bo.length - 1; Rr >= 0; Rr--) {
                                                        var Al = Bo[Rr].char;
                                                        if (Al === Ba || Al === U(O(Dr)) || w(O(Al)) === Dr) {
                                                            so.push([Bo[Rr].seqIndex, Lo]),
                                                            Bo.length = Rr;
                                                            break
                                                        }
                                                    }
                                            }
                                        so.sort(function(xs, Is) {
                                            return xs[0] - Is[0]
                                        });
                                        for (var Ur = 0; Ur < so.length; Ur++) {
                                            for (var Or = so[Ur], Tl = Or[0], Ml = Or[1], vu = !1, es = 0, la = Tl + 1; la < Ml; la++) {
                                                var _c = ce[la];
                                                if (we[_c] & mu) {
                                                    vu = !0;
                                                    var bl = we[_c] & wr ? N : L;
                                                    if (bl === pt) {
                                                        es = bl;
                                                        break
                                                    }
                                                }
                                            }
                                            if (vu && !es) {
                                                es = at;
                                                for (var cr = Tl - 1; cr >= 0; cr--) {
                                                    var Sc = ce[cr];
                                                    if (we[Sc] & mu) {
                                                        var Nr = we[Sc] & wr ? N : L;
                                                        Nr !== pt ? es = Nr : es = pt;
                                                        break
                                                    }
                                                }
                                            }
                                            if (es) {
                                                if (we[ce[Tl]] = we[ce[Ml]] = es,
                                                es !== pt) {
                                                    for (var ao = Tl + 1; ao < ce.length; ao++)
                                                        if (!(we[ce[ao]] & c)) {
                                                            v(ge[ce[ao]]) & W && (we[ce[ao]] = es);
                                                            break
                                                        }
                                                }
                                                if (es !== pt) {
                                                    for (var La = Ml + 1; La < ce.length; La++)
                                                        if (!(we[ce[La]] & c)) {
                                                            v(ge[ce[La]]) & W && (we[ce[La]] = es);
                                                            break
                                                        }
                                                }
                                            }
                                        }
                                        for (var ca = 0; ca < ce.length; ca++)
                                            if (we[ce[ca]] & o) {
                                                for (var gu = ca, Wi = ca, ur = at, Br = ca - 1; Br >= 0; Br--)
                                                    if (we[ce[Br]] & c)
                                                        gu = Br;
                                                    else {
                                                        ur = we[ce[Br]] & wr ? N : L;
                                                        break
                                                    }
                                                for (var ua = yt, ro = ca + 1; ro < ce.length; ro++)
                                                    if (we[ce[ro]] & (o | c))
                                                        Wi = ro;
                                                    else {
                                                        ua = we[ce[ro]] & wr ? N : L;
                                                        break
                                                    }
                                                for (var El = gu; El <= Wi; El++)
                                                    we[ce[El]] = ur === ua ? ur : pt;
                                                ca = Wi
                                            }
                                    }
                                }
                                for (var ts = Re.start; ts <= Re.end; ts++) {
                                    var Cl = Y[ts]
                                      , oo = we[ts];
                                    if (Cl & 1 ? oo & (L | z | G) && Y[ts]++ : oo & N ? Y[ts]++ : oo & (G | z) && (Y[ts] += 2),
                                    oo & c && (Y[ts] = ts === 0 ? Re.level : Y[ts - 1]),
                                    ts === Re.end || v(ge[ts]) & (Q | q))
                                        for (var xc = ts; xc >= 0 && v(ge[xc]) & u; xc--)
                                            Y[xc] = Re.level
                                }
                            }
                            return {
                                levels: Y,
                                paragraphs: He
                            };
                            function Yi(xs, Is) {
                                for (var As = xs; As < ge.length; As++) {
                                    var Lr = we[As];
                                    if (Lr & (N | V))
                                        return 1;
                                    if (Lr & (q | L) || Is && Lr === ue)
                                        return 0;
                                    if (Lr & s) {
                                        var wl = fd(As);
                                        As = wl === -1 ? ge.length : wl
                                    }
                                }
                                return 0
                            }
                            function fd(xs) {
                                for (var Is = 1, As = xs + 1; As < ge.length; As++) {
                                    var Lr = we[As];
                                    if (Lr & q)
                                        break;
                                    if (Lr & ue) {
                                        if (--Is === 0)
                                            return As
                                    } else
                                        Lr & s && Is++
                                }
                                return -1
                            }
                        }
                        var qe = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", ze;
                        function Ee() {
                            if (!ze) {
                                var ge = A(qe, !0)
                                  , Te = ge.map;
                                ge.reverseMap.forEach(function(Ae, we) {
                                    Te.set(we, Ae)
                                }),
                                ze = Te
                            }
                        }
                        function re(ge) {
                            return Ee(),
                            ze.get(ge) || null
                        }
                        function Le(ge, Te, Ae, we) {
                            var it = ge.length;
                            Ae = Math.max(0, Ae == null ? 0 : +Ae),
                            we = Math.min(it - 1, we == null ? it - 1 : +we);
                            for (var je = new Map, $ = Ae; $ <= we; $++)
                                if (Te[$] & 1) {
                                    var Y = re(ge[$]);
                                    Y !== null && je.set($, Y)
                                }
                            return je
                        }
                        function he(ge, Te, Ae, we) {
                            var it = ge.length;
                            Ae = Math.max(0, Ae == null ? 0 : +Ae),
                            we = Math.min(it - 1, we == null ? it - 1 : +we);
                            var je = [];
                            return Te.paragraphs.forEach(function($) {
                                var Y = Math.max(Ae, $.start)
                                  , pe = Math.min(we, $.end);
                                if (Y < pe) {
                                    for (var He = Te.levels.slice(Y, pe + 1), Re = pe; Re >= Y && v(ge[Re]) & u; Re--)
                                        He[Re] = $.level;
                                    for (var De = $.level, rt = 1 / 0, $e = 0; $e < He.length; $e++) {
                                        var ct = He[$e];
                                        ct > De && (De = ct),
                                        ct < rt && (rt = ct | 1)
                                    }
                                    for (var gt = De; gt >= rt; gt--)
                                        for (var Ie = 0; Ie < He.length; Ie++)
                                            if (He[Ie] >= gt) {
                                                for (var Je = Ie; Ie + 1 < He.length && He[Ie + 1] >= gt; )
                                                    Ie++;
                                                Ie > Je && je.push([Je + Y, Ie + Y])
                                            }
                                }
                            }),
                            je
                        }
                        function ye(ge, Te, Ae, we) {
                            var it = xe(ge, Te, Ae, we)
                              , je = [].concat(ge);
                            return it.forEach(function($, Y) {
                                je[Y] = (Te.levels[$] & 1 ? re(ge[$]) : null) || ge[$]
                            }),
                            je.join("")
                        }
                        function xe(ge, Te, Ae, we) {
                            for (var it = he(ge, Te, Ae, we), je = [], $ = 0; $ < ge.length; $++)
                                je[$] = $;
                            return it.forEach(function(Y) {
                                for (var pe = Y[0], He = Y[1], Re = je.slice(pe, He + 1), De = Re.length; De--; )
                                    je[He - De] = Re[De]
                            }),
                            je
                        }
                        return e.closingToOpeningBracket = U,
                        e.getBidiCharType = v,
                        e.getBidiCharTypeName = y,
                        e.getCanonicalBracket = O,
                        e.getEmbeddingLevels = de,
                        e.getMirroredCharacter = re,
                        e.getMirroredCharactersMap = Le,
                        e.getReorderSegments = he,
                        e.getReorderedIndices = xe,
                        e.getReorderedString = ye,
                        e.openingToClosingBracket = w,
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e
                    }
                    )({})
                }
                var R9 = D9;
                const z3 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
                function Tb(e) {
                    const t = /^[ \t]*#include +<([\w\d./]+)>/gm;
                    function n(i, s) {
                        let a = an[s];
                        return a ? Tb(a) : i
                    }
                    return e.replace(t, n)
                }
                const ra = [];
                for (let e = 0; e < 256; e++)
                    ra[e] = (e < 16 ? "0" : "") + e.toString(16);
                function U9() {
                    const e = Math.random() * 4294967295 | 0
                      , t = Math.random() * 4294967295 | 0
                      , n = Math.random() * 4294967295 | 0
                      , i = Math.random() * 4294967295 | 0;
                    return (ra[e & 255] + ra[e >> 8 & 255] + ra[e >> 16 & 255] + ra[e >> 24 & 255] + "-" + ra[t & 255] + ra[t >> 8 & 255] + "-" + ra[t >> 16 & 15 | 64] + ra[t >> 24 & 255] + "-" + ra[n & 63 | 128] + ra[n >> 8 & 255] + "-" + ra[n >> 16 & 255] + ra[n >> 24 & 255] + ra[i & 255] + ra[i >> 8 & 255] + ra[i >> 16 & 255] + ra[i >> 24 & 255]).toUpperCase()
                }
                const ld = Object.assign || function() {
                    let e = arguments[0];
                    for (let t = 1, n = arguments.length; t < n; t++) {
                        let i = arguments[t];
                        if (i)
                            for (let s in i)
                                Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s])
                    }
                    return e
                }
                  , O9 = Date.now()
                  , F3 = new WeakMap
                  , H3 = new Map;
                let N9 = 1e10;
                function Mb(e, t) {
                    const n = P9(t);
                    let i = F3.get(e);
                    if (i || F3.set(e, i = Object.create(null)),
                    i[n])
                        return new i[n];
                    const s = `_onBeforeCompile${n}`
                      , a = function(f, m) {
                        e.onBeforeCompile.call(this, f, m);
                        const v = this.customProgramCacheKey() + "|" + f.vertexShader + "|" + f.fragmentShader;
                        let y = H3[v];
                        y || (y = H3[v] = B9(this, f, t, n)),
                        f.vertexShader = y.vertexShader,
                        f.fragmentShader = y.fragmentShader,
                        ld(f.uniforms, this.uniforms),
                        t.timeUniform && (f.uniforms[t.timeUniform] = {
                            get value() {
                                return Date.now() - O9
                            }
                        }),
                        this[s] && this[s](f)
                    }
                      , o = function() {
                        return c(t.chained ? e : e.clone())
                    }
                      , c = function(f) {
                        const m = Object.create(f, u);
                        return Object.defineProperty(m, "baseMaterial", {
                            value: e
                        }),
                        Object.defineProperty(m, "id", {
                            value: N9++
                        }),
                        m.uuid = U9(),
                        m.uniforms = ld({}, f.uniforms, t.uniforms),
                        m.defines = ld({}, f.defines, t.defines),
                        m.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = "",
                        m.extensions = ld({}, f.extensions, t.extensions),
                        m._listeners = void 0,
                        m
                    }
                      , u = {
                        constructor: {
                            value: o
                        },
                        isDerivedMaterial: {
                            value: !0
                        },
                        type: {
                            get: () => e.type,
                            set: f => {
                                e.type = f
                            }
                        },
                        isDerivedFrom: {
                            writable: !0,
                            configurable: !0,
                            value: function(f) {
                                const m = this.baseMaterial;
                                return f === m || m.isDerivedMaterial && m.isDerivedFrom(f) || !1
                            }
                        },
                        customProgramCacheKey: {
                            writable: !0,
                            configurable: !0,
                            value: function() {
                                return e.customProgramCacheKey() + "|" + n
                            }
                        },
                        onBeforeCompile: {
                            get() {
                                return a
                            },
                            set(f) {
                                this[s] = f
                            }
                        },
                        copy: {
                            writable: !0,
                            configurable: !0,
                            value: function(f) {
                                return e.copy.call(this, f),
                                !e.isShaderMaterial && !e.isDerivedMaterial && (ld(this.extensions, f.extensions),
                                ld(this.defines, f.defines),
                                ld(this.uniforms, JA.clone(f.uniforms))),
                                this
                            }
                        },
                        clone: {
                            writable: !0,
                            configurable: !0,
                            value: function() {
                                const f = new e.constructor;
                                return c(f).copy(this)
                            }
                        },
                        getDepthMaterial: {
                            writable: !0,
                            configurable: !0,
                            value: function() {
                                let f = this._depthMaterial;
                                return f || (f = this._depthMaterial = Mb(e.isDerivedMaterial ? e.getDepthMaterial() : new Fg({
                                    depthPacking: Eo
                                }), t),
                                f.defines.IS_DEPTH_MATERIAL = "",
                                f.uniforms = this.uniforms),
                                f
                            }
                        },
                        getDistanceMaterial: {
                            writable: !0,
                            configurable: !0,
                            value: function() {
                                let f = this._distanceMaterial;
                                return f || (f = this._distanceMaterial = Mb(e.isDerivedMaterial ? e.getDistanceMaterial() : new pS, t),
                                f.defines.IS_DISTANCE_MATERIAL = "",
                                f.uniforms = this.uniforms),
                                f
                            }
                        },
                        dispose: {
                            writable: !0,
                            configurable: !0,
                            value() {
                                const {_depthMaterial: f, _distanceMaterial: m} = this;
                                f && f.dispose(),
                                m && m.dispose(),
                                e.dispose.call(this)
                            }
                        }
                    };
                    return i[n] = o,
                    new o
                }
                function B9(e, {vertexShader: t, fragmentShader: n}, i, s) {
                    let {vertexDefs: a, vertexMainIntro: o, vertexMainOutro: c, vertexTransform: u, fragmentDefs: f, fragmentMainIntro: m, fragmentMainOutro: v, fragmentColorTransform: y, customRewriter: S, timeUniform: A} = i;
                    if (a = a || "",
                    o = o || "",
                    c = c || "",
                    f = f || "",
                    m = m || "",
                    v = v || "",
                    (u || S) && (t = Tb(t)),
                    (y || S) && (n = n.replace(/^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm, `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`),
                    n = Tb(n)),
                    S) {
                        let M = S({
                            vertexShader: t,
                            fragmentShader: n
                        });
                        t = M.vertexShader,
                        n = M.fragmentShader
                    }
                    if (y) {
                        let M = [];
                        n = n.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, x => (M.push(x),
                        "")),
                        v = `${y}
${M.join(`
`)}
${v}`
                    }
                    if (A) {
                        const M = `
uniform float ${A};
`;
                        a = M + a,
                        f = M + f
                    }
                    return u && (t = `vec3 troika_position_${s};
vec3 troika_normal_${s};
vec2 troika_uv_${s};
${t}
`,
                    a = `${a}
void troikaVertexTransform${s}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${u}
}
`,
                    o = `
troika_position_${s} = vec3(position);
troika_normal_${s} = vec3(normal);
troika_uv_${s} = vec2(uv);
troikaVertexTransform${s}(troika_position_${s}, troika_normal_${s}, troika_uv_${s});
${o}
`,
                    t = t.replace(/\b(position|normal|uv)\b/g, (M, x, T, D) => /\battribute\s+vec[23]\s+$/.test(D.substr(0, T)) ? x : `troika_${x}_${s}`),
                    e.map && e.map.channel > 0 || (t = t.replace(/\bMAP_UV\b/g, `troika_uv_${s}`))),
                    t = G3(t, s, a, o, c),
                    n = G3(n, s, f, m, v),
                    {
                        vertexShader: t,
                        fragmentShader: n
                    }
                }
                function G3(e, t, n, i, s) {
                    return (i || s || n) && (e = e.replace(z3, `
${n}
void troikaOrigMain${t}() {`),
                    e += `
void main() {
  ${i}
  troikaOrigMain${t}();
  ${s}
}`),
                    e
                }
                function L9(e, t) {
                    return e === "uniforms" ? void 0 : typeof t == "function" ? t.toString() : t
                }
                let I9 = 0;
                const V3 = new Map;
                function P9(e) {
                    const t = JSON.stringify(e, L9);
                    let n = V3.get(t);
                    return n == null && V3.set(t, n = ++I9),
                    n
                }
                function z9() {
                    return typeof window > "u" && (self.window = self),
                    (function(e) {
                        var t = {
                            parse: function(s) {
                                var a = t._bin
                                  , o = new Uint8Array(s);
                                if (a.readASCII(o, 0, 4) == "ttcf") {
                                    var c = 4;
                                    a.readUshort(o, c),
                                    c += 2,
                                    a.readUshort(o, c),
                                    c += 2;
                                    var u = a.readUint(o, c);
                                    c += 4;
                                    for (var f = [], m = 0; m < u; m++) {
                                        var v = a.readUint(o, c);
                                        c += 4,
                                        f.push(t._readFont(o, v))
                                    }
                                    return f
                                }
                                return [t._readFont(o, 0)]
                            },
                            _readFont: function(s, a) {
                                var o = t._bin
                                  , c = a;
                                o.readFixed(s, a),
                                a += 4;
                                var u = o.readUshort(s, a);
                                a += 2,
                                o.readUshort(s, a),
                                a += 2,
                                o.readUshort(s, a),
                                a += 2,
                                o.readUshort(s, a),
                                a += 2;
                                for (var f = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], m = {
                                    _data: s,
                                    _offset: c
                                }, v = {}, y = 0; y < u; y++) {
                                    var S = o.readASCII(s, a, 4);
                                    a += 4,
                                    o.readUint(s, a),
                                    a += 4;
                                    var A = o.readUint(s, a);
                                    a += 4;
                                    var M = o.readUint(s, a);
                                    a += 4,
                                    v[S] = {
                                        offset: A,
                                        length: M
                                    }
                                }
                                for (y = 0; y < f.length; y++) {
                                    var x = f[y];
                                    v[x] && (m[x.trim()] = t[x.trim()].parse(s, v[x].offset, v[x].length, m))
                                }
                                return m
                            },
                            _tabOffset: function(s, a, o) {
                                for (var c = t._bin, u = c.readUshort(s, o + 4), f = o + 12, m = 0; m < u; m++) {
                                    var v = c.readASCII(s, f, 4);
                                    f += 4,
                                    c.readUint(s, f),
                                    f += 4;
                                    var y = c.readUint(s, f);
                                    if (f += 4,
                                    c.readUint(s, f),
                                    f += 4,
                                    v == a)
                                        return y
                                }
                                return 0
                            }
                        };
                        t._bin = {
                            readFixed: function(s, a) {
                                return (s[a] << 8 | s[a + 1]) + (s[a + 2] << 8 | s[a + 3]) / 65540
                            },
                            readF2dot14: function(s, a) {
                                return t._bin.readShort(s, a) / 16384
                            },
                            readInt: function(s, a) {
                                return t._bin._view(s).getInt32(a)
                            },
                            readInt8: function(s, a) {
                                return t._bin._view(s).getInt8(a)
                            },
                            readShort: function(s, a) {
                                return t._bin._view(s).getInt16(a)
                            },
                            readUshort: function(s, a) {
                                return t._bin._view(s).getUint16(a)
                            },
                            readUshorts: function(s, a, o) {
                                for (var c = [], u = 0; u < o; u++)
                                    c.push(t._bin.readUshort(s, a + 2 * u));
                                return c
                            },
                            readUint: function(s, a) {
                                return t._bin._view(s).getUint32(a)
                            },
                            readUint64: function(s, a) {
                                return 4294967296 * t._bin.readUint(s, a) + t._bin.readUint(s, a + 4)
                            },
                            readASCII: function(s, a, o) {
                                for (var c = "", u = 0; u < o; u++)
                                    c += String.fromCharCode(s[a + u]);
                                return c
                            },
                            readUnicode: function(s, a, o) {
                                for (var c = "", u = 0; u < o; u++) {
                                    var f = s[a++] << 8 | s[a++];
                                    c += String.fromCharCode(f)
                                }
                                return c
                            },
                            _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder : null,
                            readUTF8: function(s, a, o) {
                                var c = t._bin._tdec;
                                return c && a == 0 && o == s.length ? c.decode(s) : t._bin.readASCII(s, a, o)
                            },
                            readBytes: function(s, a, o) {
                                for (var c = [], u = 0; u < o; u++)
                                    c.push(s[a + u]);
                                return c
                            },
                            readASCIIArray: function(s, a, o) {
                                for (var c = [], u = 0; u < o; u++)
                                    c.push(String.fromCharCode(s[a + u]));
                                return c
                            },
                            _view: function(s) {
                                return s._dataView || (s._dataView = s.buffer ? new DataView(s.buffer,s.byteOffset,s.byteLength) : new DataView(new Uint8Array(s).buffer))
                            }
                        },
                        t._lctf = {},
                        t._lctf.parse = function(s, a, o, c, u) {
                            var f = t._bin
                              , m = {}
                              , v = a;
                            f.readFixed(s, a),
                            a += 4;
                            var y = f.readUshort(s, a);
                            a += 2;
                            var S = f.readUshort(s, a);
                            a += 2;
                            var A = f.readUshort(s, a);
                            return a += 2,
                            m.scriptList = t._lctf.readScriptList(s, v + y),
                            m.featureList = t._lctf.readFeatureList(s, v + S),
                            m.lookupList = t._lctf.readLookupList(s, v + A, u),
                            m
                        }
                        ,
                        t._lctf.readLookupList = function(s, a, o) {
                            var c = t._bin
                              , u = a
                              , f = []
                              , m = c.readUshort(s, a);
                            a += 2;
                            for (var v = 0; v < m; v++) {
                                var y = c.readUshort(s, a);
                                a += 2;
                                var S = t._lctf.readLookupTable(s, u + y, o);
                                f.push(S)
                            }
                            return f
                        }
                        ,
                        t._lctf.readLookupTable = function(s, a, o) {
                            var c = t._bin
                              , u = a
                              , f = {
                                tabs: []
                            };
                            f.ltype = c.readUshort(s, a),
                            a += 2,
                            f.flag = c.readUshort(s, a),
                            a += 2;
                            var m = c.readUshort(s, a);
                            a += 2;
                            for (var v = f.ltype, y = 0; y < m; y++) {
                                var S = c.readUshort(s, a);
                                a += 2;
                                var A = o(s, v, u + S, f);
                                f.tabs.push(A)
                            }
                            return f
                        }
                        ,
                        t._lctf.numOfOnes = function(s) {
                            for (var a = 0, o = 0; o < 32; o++)
                                (s >>> o & 1) != 0 && a++;
                            return a
                        }
                        ,
                        t._lctf.readClassDef = function(s, a) {
                            var o = t._bin
                              , c = []
                              , u = o.readUshort(s, a);
                            if (a += 2,
                            u == 1) {
                                var f = o.readUshort(s, a);
                                a += 2;
                                var m = o.readUshort(s, a);
                                a += 2;
                                for (var v = 0; v < m; v++)
                                    c.push(f + v),
                                    c.push(f + v),
                                    c.push(o.readUshort(s, a)),
                                    a += 2
                            }
                            if (u == 2) {
                                var y = o.readUshort(s, a);
                                for (a += 2,
                                v = 0; v < y; v++)
                                    c.push(o.readUshort(s, a)),
                                    a += 2,
                                    c.push(o.readUshort(s, a)),
                                    a += 2,
                                    c.push(o.readUshort(s, a)),
                                    a += 2
                            }
                            return c
                        }
                        ,
                        t._lctf.getInterval = function(s, a) {
                            for (var o = 0; o < s.length; o += 3) {
                                var c = s[o]
                                  , u = s[o + 1];
                                if (s[o + 2],
                                c <= a && a <= u)
                                    return o
                            }
                            return -1
                        }
                        ,
                        t._lctf.readCoverage = function(s, a) {
                            var o = t._bin
                              , c = {};
                            c.fmt = o.readUshort(s, a),
                            a += 2;
                            var u = o.readUshort(s, a);
                            return a += 2,
                            c.fmt == 1 && (c.tab = o.readUshorts(s, a, u)),
                            c.fmt == 2 && (c.tab = o.readUshorts(s, a, 3 * u)),
                            c
                        }
                        ,
                        t._lctf.coverageIndex = function(s, a) {
                            var o = s.tab;
                            if (s.fmt == 1)
                                return o.indexOf(a);
                            if (s.fmt == 2) {
                                var c = t._lctf.getInterval(o, a);
                                if (c != -1)
                                    return o[c + 2] + (a - o[c])
                            }
                            return -1
                        }
                        ,
                        t._lctf.readFeatureList = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = []
                              , f = o.readUshort(s, a);
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = o.readASCII(s, a, 4);
                                a += 4;
                                var y = o.readUshort(s, a);
                                a += 2;
                                var S = t._lctf.readFeatureTable(s, c + y);
                                S.tag = v.trim(),
                                u.push(S)
                            }
                            return u
                        }
                        ,
                        t._lctf.readFeatureTable = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = {}
                              , f = o.readUshort(s, a);
                            a += 2,
                            f > 0 && (u.featureParams = c + f);
                            var m = o.readUshort(s, a);
                            a += 2,
                            u.tab = [];
                            for (var v = 0; v < m; v++)
                                u.tab.push(o.readUshort(s, a + 2 * v));
                            return u
                        }
                        ,
                        t._lctf.readScriptList = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = {}
                              , f = o.readUshort(s, a);
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = o.readASCII(s, a, 4);
                                a += 4;
                                var y = o.readUshort(s, a);
                                a += 2,
                                u[v.trim()] = t._lctf.readScriptTable(s, c + y)
                            }
                            return u
                        }
                        ,
                        t._lctf.readScriptTable = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = {}
                              , f = o.readUshort(s, a);
                            a += 2,
                            f > 0 && (u.default = t._lctf.readLangSysTable(s, c + f));
                            var m = o.readUshort(s, a);
                            a += 2;
                            for (var v = 0; v < m; v++) {
                                var y = o.readASCII(s, a, 4);
                                a += 4;
                                var S = o.readUshort(s, a);
                                a += 2,
                                u[y.trim()] = t._lctf.readLangSysTable(s, c + S)
                            }
                            return u
                        }
                        ,
                        t._lctf.readLangSysTable = function(s, a) {
                            var o = t._bin
                              , c = {};
                            o.readUshort(s, a),
                            a += 2,
                            c.reqFeature = o.readUshort(s, a),
                            a += 2;
                            var u = o.readUshort(s, a);
                            return a += 2,
                            c.features = o.readUshorts(s, a, u),
                            c
                        }
                        ,
                        t.CFF = {},
                        t.CFF.parse = function(s, a, o) {
                            var c = t._bin;
                            (s = new Uint8Array(s.buffer,a,o))[a = 0],
                            s[++a],
                            s[++a],
                            s[++a],
                            a++;
                            var u = [];
                            a = t.CFF.readIndex(s, a, u);
                            for (var f = [], m = 0; m < u.length - 1; m++)
                                f.push(c.readASCII(s, a + u[m], u[m + 1] - u[m]));
                            a += u[u.length - 1];
                            var v = [];
                            a = t.CFF.readIndex(s, a, v);
                            var y = [];
                            for (m = 0; m < v.length - 1; m++)
                                y.push(t.CFF.readDict(s, a + v[m], a + v[m + 1]));
                            a += v[v.length - 1];
                            var S = y[0]
                              , A = [];
                            a = t.CFF.readIndex(s, a, A);
                            var M = [];
                            for (m = 0; m < A.length - 1; m++)
                                M.push(c.readASCII(s, a + A[m], A[m + 1] - A[m]));
                            if (a += A[A.length - 1],
                            t.CFF.readSubrs(s, a, S),
                            S.CharStrings) {
                                a = S.CharStrings,
                                A = [],
                                a = t.CFF.readIndex(s, a, A);
                                var x = [];
                                for (m = 0; m < A.length - 1; m++)
                                    x.push(c.readBytes(s, a + A[m], A[m + 1] - A[m]));
                                S.CharStrings = x
                            }
                            if (S.ROS) {
                                a = S.FDArray;
                                var T = [];
                                for (a = t.CFF.readIndex(s, a, T),
                                S.FDArray = [],
                                m = 0; m < T.length - 1; m++) {
                                    var D = t.CFF.readDict(s, a + T[m], a + T[m + 1]);
                                    t.CFF._readFDict(s, D, M),
                                    S.FDArray.push(D)
                                }
                                a += T[T.length - 1],
                                a = S.FDSelect,
                                S.FDSelect = [];
                                var w = s[a];
                                if (a++,
                                w != 3)
                                    throw w;
                                var U = c.readUshort(s, a);
                                for (a += 2,
                                m = 0; m < U + 1; m++)
                                    S.FDSelect.push(c.readUshort(s, a), s[a + 2]),
                                    a += 3
                            }
                            return S.Encoding && (S.Encoding = t.CFF.readEncoding(s, S.Encoding, S.CharStrings.length)),
                            S.charset && (S.charset = t.CFF.readCharset(s, S.charset, S.CharStrings.length)),
                            t.CFF._readFDict(s, S, M),
                            S
                        }
                        ,
                        t.CFF._readFDict = function(s, a, o) {
                            var c;
                            for (var u in a.Private && (c = a.Private[1],
                            a.Private = t.CFF.readDict(s, c, c + a.Private[0]),
                            a.Private.Subrs && t.CFF.readSubrs(s, c + a.Private.Subrs, a.Private)),
                            a)
                                ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(u) != -1 && (a[u] = o[a[u] - 426 + 35])
                        }
                        ,
                        t.CFF.readSubrs = function(s, a, o) {
                            var c = t._bin
                              , u = [];
                            a = t.CFF.readIndex(s, a, u);
                            var f, m = u.length;
                            f = m < 1240 ? 107 : m < 33900 ? 1131 : 32768,
                            o.Bias = f,
                            o.Subrs = [];
                            for (var v = 0; v < u.length - 1; v++)
                                o.Subrs.push(c.readBytes(s, a + u[v], u[v + 1] - u[v]))
                        }
                        ,
                        t.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0],
                        t.CFF.glyphByUnicode = function(s, a) {
                            for (var o = 0; o < s.charset.length; o++)
                                if (s.charset[o] == a)
                                    return o;
                            return -1
                        }
                        ,
                        t.CFF.glyphBySE = function(s, a) {
                            return a < 0 || a > 255 ? -1 : t.CFF.glyphByUnicode(s, t.CFF.tableSE[a])
                        }
                        ,
                        t.CFF.readEncoding = function(s, a, o) {
                            t._bin;
                            var c = [".notdef"]
                              , u = s[a];
                            if (a++,
                            u != 0)
                                throw "error: unknown encoding format: " + u;
                            var f = s[a];
                            a++;
                            for (var m = 0; m < f; m++)
                                c.push(s[a + m]);
                            return c
                        }
                        ,
                        t.CFF.readCharset = function(s, a, o) {
                            var c = t._bin
                              , u = [".notdef"]
                              , f = s[a];
                            if (a++,
                            f == 0)
                                for (var m = 0; m < o; m++) {
                                    var v = c.readUshort(s, a);
                                    a += 2,
                                    u.push(v)
                                }
                            else {
                                if (f != 1 && f != 2)
                                    throw "error: format: " + f;
                                for (; u.length < o; ) {
                                    v = c.readUshort(s, a),
                                    a += 2;
                                    var y = 0;
                                    for (f == 1 ? (y = s[a],
                                    a++) : (y = c.readUshort(s, a),
                                    a += 2),
                                    m = 0; m <= y; m++)
                                        u.push(v),
                                        v++
                                }
                            }
                            return u
                        }
                        ,
                        t.CFF.readIndex = function(s, a, o) {
                            var c = t._bin
                              , u = c.readUshort(s, a) + 1
                              , f = s[a += 2];
                            if (a++,
                            f == 1)
                                for (var m = 0; m < u; m++)
                                    o.push(s[a + m]);
                            else if (f == 2)
                                for (m = 0; m < u; m++)
                                    o.push(c.readUshort(s, a + 2 * m));
                            else if (f == 3)
                                for (m = 0; m < u; m++)
                                    o.push(16777215 & c.readUint(s, a + 3 * m - 1));
                            else if (u != 1)
                                throw "unsupported offset size: " + f + ", count: " + u;
                            return (a += u * f) - 1
                        }
                        ,
                        t.CFF.getCharString = function(s, a, o) {
                            var c = t._bin
                              , u = s[a]
                              , f = s[a + 1];
                            s[a + 2],
                            s[a + 3],
                            s[a + 4];
                            var m = 1
                              , v = null
                              , y = null;
                            u <= 20 && (v = u,
                            m = 1),
                            u == 12 && (v = 100 * u + f,
                            m = 2),
                            21 <= u && u <= 27 && (v = u,
                            m = 1),
                            u == 28 && (y = c.readShort(s, a + 1),
                            m = 3),
                            29 <= u && u <= 31 && (v = u,
                            m = 1),
                            32 <= u && u <= 246 && (y = u - 139,
                            m = 1),
                            247 <= u && u <= 250 && (y = 256 * (u - 247) + f + 108,
                            m = 2),
                            251 <= u && u <= 254 && (y = 256 * -(u - 251) - f - 108,
                            m = 2),
                            u == 255 && (y = c.readInt(s, a + 1) / 65535,
                            m = 5),
                            o.val = y ?? "o" + v,
                            o.size = m
                        }
                        ,
                        t.CFF.readCharString = function(s, a, o) {
                            for (var c = a + o, u = t._bin, f = []; a < c; ) {
                                var m = s[a]
                                  , v = s[a + 1];
                                s[a + 2],
                                s[a + 3],
                                s[a + 4];
                                var y = 1
                                  , S = null
                                  , A = null;
                                m <= 20 && (S = m,
                                y = 1),
                                m == 12 && (S = 100 * m + v,
                                y = 2),
                                m != 19 && m != 20 || (S = m,
                                y = 2),
                                21 <= m && m <= 27 && (S = m,
                                y = 1),
                                m == 28 && (A = u.readShort(s, a + 1),
                                y = 3),
                                29 <= m && m <= 31 && (S = m,
                                y = 1),
                                32 <= m && m <= 246 && (A = m - 139,
                                y = 1),
                                247 <= m && m <= 250 && (A = 256 * (m - 247) + v + 108,
                                y = 2),
                                251 <= m && m <= 254 && (A = 256 * -(m - 251) - v - 108,
                                y = 2),
                                m == 255 && (A = u.readInt(s, a + 1) / 65535,
                                y = 5),
                                f.push(A ?? "o" + S),
                                a += y
                            }
                            return f
                        }
                        ,
                        t.CFF.readDict = function(s, a, o) {
                            for (var c = t._bin, u = {}, f = []; a < o; ) {
                                var m = s[a]
                                  , v = s[a + 1];
                                s[a + 2],
                                s[a + 3],
                                s[a + 4];
                                var y = 1
                                  , S = null
                                  , A = null;
                                if (m == 28 && (A = c.readShort(s, a + 1),
                                y = 3),
                                m == 29 && (A = c.readInt(s, a + 1),
                                y = 5),
                                32 <= m && m <= 246 && (A = m - 139,
                                y = 1),
                                247 <= m && m <= 250 && (A = 256 * (m - 247) + v + 108,
                                y = 2),
                                251 <= m && m <= 254 && (A = 256 * -(m - 251) - v - 108,
                                y = 2),
                                m == 255)
                                    throw A = c.readInt(s, a + 1) / 65535,
                                    y = 5,
                                    "unknown number";
                                if (m == 30) {
                                    var M = [];
                                    for (y = 1; ; ) {
                                        var x = s[a + y];
                                        y++;
                                        var T = x >> 4
                                          , D = 15 & x;
                                        if (T != 15 && M.push(T),
                                        D != 15 && M.push(D),
                                        D == 15)
                                            break
                                    }
                                    for (var w = "", U = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], O = 0; O < M.length; O++)
                                        w += U[M[O]];
                                    A = parseFloat(w)
                                }
                                m <= 21 && (S = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][m],
                                y = 1,
                                m == 12 && (S = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][v],
                                y = 2)),
                                S != null ? (u[S] = f.length == 1 ? f[0] : f,
                                f = []) : f.push(A),
                                a += y
                            }
                            return u
                        }
                        ,
                        t.cmap = {},
                        t.cmap.parse = function(s, a, o) {
                            s = new Uint8Array(s.buffer,a,o),
                            a = 0;
                            var c = t._bin
                              , u = {};
                            c.readUshort(s, a),
                            a += 2;
                            var f = c.readUshort(s, a);
                            a += 2;
                            var m = [];
                            u.tables = [];
                            for (var v = 0; v < f; v++) {
                                var y = c.readUshort(s, a);
                                a += 2;
                                var S = c.readUshort(s, a);
                                a += 2;
                                var A = c.readUint(s, a);
                                a += 4;
                                var M = "p" + y + "e" + S
                                  , x = m.indexOf(A);
                                if (x == -1) {
                                    var T;
                                    x = u.tables.length,
                                    m.push(A);
                                    var D = c.readUshort(s, A);
                                    D == 0 ? T = t.cmap.parse0(s, A) : D == 4 ? T = t.cmap.parse4(s, A) : D == 6 ? T = t.cmap.parse6(s, A) : D == 12 ? T = t.cmap.parse12(s, A) : console.debug("unknown format: " + D, y, S, A),
                                    u.tables.push(T)
                                }
                                if (u[M] != null)
                                    throw "multiple tables for one platform+encoding";
                                u[M] = x
                            }
                            return u
                        }
                        ,
                        t.cmap.parse0 = function(s, a) {
                            var o = t._bin
                              , c = {};
                            c.format = o.readUshort(s, a),
                            a += 2;
                            var u = o.readUshort(s, a);
                            a += 2,
                            o.readUshort(s, a),
                            a += 2,
                            c.map = [];
                            for (var f = 0; f < u - 6; f++)
                                c.map.push(s[a + f]);
                            return c
                        }
                        ,
                        t.cmap.parse4 = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = {};
                            u.format = o.readUshort(s, a),
                            a += 2;
                            var f = o.readUshort(s, a);
                            a += 2,
                            o.readUshort(s, a),
                            a += 2;
                            var m = o.readUshort(s, a);
                            a += 2;
                            var v = m / 2;
                            u.searchRange = o.readUshort(s, a),
                            a += 2,
                            u.entrySelector = o.readUshort(s, a),
                            a += 2,
                            u.rangeShift = o.readUshort(s, a),
                            a += 2,
                            u.endCount = o.readUshorts(s, a, v),
                            a += 2 * v,
                            a += 2,
                            u.startCount = o.readUshorts(s, a, v),
                            a += 2 * v,
                            u.idDelta = [];
                            for (var y = 0; y < v; y++)
                                u.idDelta.push(o.readShort(s, a)),
                                a += 2;
                            for (u.idRangeOffset = o.readUshorts(s, a, v),
                            a += 2 * v,
                            u.glyphIdArray = []; a < c + f; )
                                u.glyphIdArray.push(o.readUshort(s, a)),
                                a += 2;
                            return u
                        }
                        ,
                        t.cmap.parse6 = function(s, a) {
                            var o = t._bin
                              , c = {};
                            c.format = o.readUshort(s, a),
                            a += 2,
                            o.readUshort(s, a),
                            a += 2,
                            o.readUshort(s, a),
                            a += 2,
                            c.firstCode = o.readUshort(s, a),
                            a += 2;
                            var u = o.readUshort(s, a);
                            a += 2,
                            c.glyphIdArray = [];
                            for (var f = 0; f < u; f++)
                                c.glyphIdArray.push(o.readUshort(s, a)),
                                a += 2;
                            return c
                        }
                        ,
                        t.cmap.parse12 = function(s, a) {
                            var o = t._bin
                              , c = {};
                            c.format = o.readUshort(s, a),
                            a += 2,
                            a += 2,
                            o.readUint(s, a),
                            a += 4,
                            o.readUint(s, a),
                            a += 4;
                            var u = o.readUint(s, a);
                            a += 4,
                            c.groups = [];
                            for (var f = 0; f < u; f++) {
                                var m = a + 12 * f
                                  , v = o.readUint(s, m + 0)
                                  , y = o.readUint(s, m + 4)
                                  , S = o.readUint(s, m + 8);
                                c.groups.push([v, y, S])
                            }
                            return c
                        }
                        ,
                        t.glyf = {},
                        t.glyf.parse = function(s, a, o, c) {
                            for (var u = [], f = 0; f < c.maxp.numGlyphs; f++)
                                u.push(null);
                            return u
                        }
                        ,
                        t.glyf._parseGlyf = function(s, a) {
                            var o = t._bin
                              , c = s._data
                              , u = t._tabOffset(c, "glyf", s._offset) + s.loca[a];
                            if (s.loca[a] == s.loca[a + 1])
                                return null;
                            var f = {};
                            if (f.noc = o.readShort(c, u),
                            u += 2,
                            f.xMin = o.readShort(c, u),
                            u += 2,
                            f.yMin = o.readShort(c, u),
                            u += 2,
                            f.xMax = o.readShort(c, u),
                            u += 2,
                            f.yMax = o.readShort(c, u),
                            u += 2,
                            f.xMin >= f.xMax || f.yMin >= f.yMax)
                                return null;
                            if (f.noc > 0) {
                                f.endPts = [];
                                for (var m = 0; m < f.noc; m++)
                                    f.endPts.push(o.readUshort(c, u)),
                                    u += 2;
                                var v = o.readUshort(c, u);
                                if (u += 2,
                                c.length - u < v)
                                    return null;
                                f.instructions = o.readBytes(c, u, v),
                                u += v;
                                var y = f.endPts[f.noc - 1] + 1;
                                for (f.flags = [],
                                m = 0; m < y; m++) {
                                    var S = c[u];
                                    if (u++,
                                    f.flags.push(S),
                                    (8 & S) != 0) {
                                        var A = c[u];
                                        u++;
                                        for (var M = 0; M < A; M++)
                                            f.flags.push(S),
                                            m++
                                    }
                                }
                                for (f.xs = [],
                                m = 0; m < y; m++) {
                                    var x = (2 & f.flags[m]) != 0
                                      , T = (16 & f.flags[m]) != 0;
                                    x ? (f.xs.push(T ? c[u] : -c[u]),
                                    u++) : T ? f.xs.push(0) : (f.xs.push(o.readShort(c, u)),
                                    u += 2)
                                }
                                for (f.ys = [],
                                m = 0; m < y; m++)
                                    x = (4 & f.flags[m]) != 0,
                                    T = (32 & f.flags[m]) != 0,
                                    x ? (f.ys.push(T ? c[u] : -c[u]),
                                    u++) : T ? f.ys.push(0) : (f.ys.push(o.readShort(c, u)),
                                    u += 2);
                                var D = 0
                                  , w = 0;
                                for (m = 0; m < y; m++)
                                    D += f.xs[m],
                                    w += f.ys[m],
                                    f.xs[m] = D,
                                    f.ys[m] = w
                            } else {
                                var U;
                                f.parts = [];
                                do {
                                    U = o.readUshort(c, u),
                                    u += 2;
                                    var O = {
                                        m: {
                                            a: 1,
                                            b: 0,
                                            c: 0,
                                            d: 1,
                                            tx: 0,
                                            ty: 0
                                        },
                                        p1: -1,
                                        p2: -1
                                    };
                                    if (f.parts.push(O),
                                    O.glyphIndex = o.readUshort(c, u),
                                    u += 2,
                                    1 & U) {
                                        var L = o.readShort(c, u);
                                        u += 2;
                                        var N = o.readShort(c, u);
                                        u += 2
                                    } else
                                        L = o.readInt8(c, u),
                                        u++,
                                        N = o.readInt8(c, u),
                                        u++;
                                    2 & U ? (O.m.tx = L,
                                    O.m.ty = N) : (O.p1 = L,
                                    O.p2 = N),
                                    8 & U ? (O.m.a = O.m.d = o.readF2dot14(c, u),
                                    u += 2) : 64 & U ? (O.m.a = o.readF2dot14(c, u),
                                    u += 2,
                                    O.m.d = o.readF2dot14(c, u),
                                    u += 2) : 128 & U && (O.m.a = o.readF2dot14(c, u),
                                    u += 2,
                                    O.m.b = o.readF2dot14(c, u),
                                    u += 2,
                                    O.m.c = o.readF2dot14(c, u),
                                    u += 2,
                                    O.m.d = o.readF2dot14(c, u),
                                    u += 2)
                                } while (32 & U);
                                if (256 & U) {
                                    var z = o.readUshort(c, u);
                                    for (u += 2,
                                    f.instr = [],
                                    m = 0; m < z; m++)
                                        f.instr.push(c[u]),
                                        u++
                                }
                            }
                            return f
                        }
                        ,
                        t.GDEF = {},
                        t.GDEF.parse = function(s, a, o, c) {
                            var u = a;
                            a += 4;
                            var f = t._bin.readUshort(s, a);
                            return {
                                glyphClassDef: f === 0 ? null : t._lctf.readClassDef(s, u + f)
                            }
                        }
                        ,
                        t.GPOS = {},
                        t.GPOS.parse = function(s, a, o, c) {
                            return t._lctf.parse(s, a, o, c, t.GPOS.subt)
                        }
                        ,
                        t.GPOS.subt = function(s, a, o, c) {
                            var u = t._bin
                              , f = o
                              , m = {};
                            if (m.fmt = u.readUshort(s, o),
                            o += 2,
                            a == 1 || a == 2 || a == 3 || a == 7 || a == 8 && m.fmt <= 2) {
                                var v = u.readUshort(s, o);
                                o += 2,
                                m.coverage = t._lctf.readCoverage(s, v + f)
                            }
                            if (a == 1 && m.fmt == 1) {
                                var y = u.readUshort(s, o);
                                o += 2,
                                y != 0 && (m.pos = t.GPOS.readValueRecord(s, o, y))
                            } else if (a == 2 && m.fmt >= 1 && m.fmt <= 2) {
                                y = u.readUshort(s, o),
                                o += 2;
                                var S = u.readUshort(s, o);
                                o += 2;
                                var A = t._lctf.numOfOnes(y)
                                  , M = t._lctf.numOfOnes(S);
                                if (m.fmt == 1) {
                                    m.pairsets = [];
                                    var x = u.readUshort(s, o);
                                    o += 2;
                                    for (var T = 0; T < x; T++) {
                                        var D = f + u.readUshort(s, o);
                                        o += 2;
                                        var w = u.readUshort(s, D);
                                        D += 2;
                                        for (var U = [], O = 0; O < w; O++) {
                                            var L = u.readUshort(s, D);
                                            D += 2,
                                            y != 0 && (X = t.GPOS.readValueRecord(s, D, y),
                                            D += 2 * A),
                                            S != 0 && (q = t.GPOS.readValueRecord(s, D, S),
                                            D += 2 * M),
                                            U.push({
                                                gid2: L,
                                                val1: X,
                                                val2: q
                                            })
                                        }
                                        m.pairsets.push(U)
                                    }
                                }
                                if (m.fmt == 2) {
                                    var N = u.readUshort(s, o);
                                    o += 2;
                                    var z = u.readUshort(s, o);
                                    o += 2;
                                    var I = u.readUshort(s, o);
                                    o += 2;
                                    var B = u.readUshort(s, o);
                                    for (o += 2,
                                    m.classDef1 = t._lctf.readClassDef(s, f + N),
                                    m.classDef2 = t._lctf.readClassDef(s, f + z),
                                    m.matrix = [],
                                    T = 0; T < I; T++) {
                                        var G = [];
                                        for (O = 0; O < B; O++) {
                                            var X = null
                                              , q = null;
                                            y != 0 && (X = t.GPOS.readValueRecord(s, o, y),
                                            o += 2 * A),
                                            S != 0 && (q = t.GPOS.readValueRecord(s, o, S),
                                            o += 2 * M),
                                            G.push({
                                                val1: X,
                                                val2: q
                                            })
                                        }
                                        m.matrix.push(G)
                                    }
                                }
                            } else if (a == 4 && m.fmt == 1)
                                m.markCoverage = t._lctf.readCoverage(s, u.readUshort(s, o) + f),
                                m.baseCoverage = t._lctf.readCoverage(s, u.readUshort(s, o + 2) + f),
                                m.markClassCount = u.readUshort(s, o + 4),
                                m.markArray = t.GPOS.readMarkArray(s, u.readUshort(s, o + 6) + f),
                                m.baseArray = t.GPOS.readBaseArray(s, u.readUshort(s, o + 8) + f, m.markClassCount);
                            else if (a == 6 && m.fmt == 1)
                                m.mark1Coverage = t._lctf.readCoverage(s, u.readUshort(s, o) + f),
                                m.mark2Coverage = t._lctf.readCoverage(s, u.readUshort(s, o + 2) + f),
                                m.markClassCount = u.readUshort(s, o + 4),
                                m.mark1Array = t.GPOS.readMarkArray(s, u.readUshort(s, o + 6) + f),
                                m.mark2Array = t.GPOS.readBaseArray(s, u.readUshort(s, o + 8) + f, m.markClassCount);
                            else {
                                if (a == 9 && m.fmt == 1) {
                                    var Q = u.readUshort(s, o);
                                    o += 2;
                                    var oe = u.readUint(s, o);
                                    if (o += 4,
                                    c.ltype == 9)
                                        c.ltype = Q;
                                    else if (c.ltype != Q)
                                        throw "invalid extension substitution";
                                    return t.GPOS.subt(s, c.ltype, f + oe)
                                }
                                console.debug("unsupported GPOS table LookupType", a, "format", m.fmt)
                            }
                            return m
                        }
                        ,
                        t.GPOS.readValueRecord = function(s, a, o) {
                            var c = t._bin
                              , u = [];
                            return u.push(1 & o ? c.readShort(s, a) : 0),
                            a += 1 & o ? 2 : 0,
                            u.push(2 & o ? c.readShort(s, a) : 0),
                            a += 2 & o ? 2 : 0,
                            u.push(4 & o ? c.readShort(s, a) : 0),
                            a += 4 & o ? 2 : 0,
                            u.push(8 & o ? c.readShort(s, a) : 0),
                            a += 8 & o ? 2 : 0,
                            u
                        }
                        ,
                        t.GPOS.readBaseArray = function(s, a, o) {
                            var c = t._bin
                              , u = []
                              , f = a
                              , m = c.readUshort(s, a);
                            a += 2;
                            for (var v = 0; v < m; v++) {
                                for (var y = [], S = 0; S < o; S++)
                                    y.push(t.GPOS.readAnchorRecord(s, f + c.readUshort(s, a))),
                                    a += 2;
                                u.push(y)
                            }
                            return u
                        }
                        ,
                        t.GPOS.readMarkArray = function(s, a) {
                            var o = t._bin
                              , c = []
                              , u = a
                              , f = o.readUshort(s, a);
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = t.GPOS.readAnchorRecord(s, o.readUshort(s, a + 2) + u);
                                v.markClass = o.readUshort(s, a),
                                c.push(v),
                                a += 4
                            }
                            return c
                        }
                        ,
                        t.GPOS.readAnchorRecord = function(s, a) {
                            var o = t._bin
                              , c = {};
                            return c.fmt = o.readUshort(s, a),
                            c.x = o.readShort(s, a + 2),
                            c.y = o.readShort(s, a + 4),
                            c
                        }
                        ,
                        t.GSUB = {},
                        t.GSUB.parse = function(s, a, o, c) {
                            return t._lctf.parse(s, a, o, c, t.GSUB.subt)
                        }
                        ,
                        t.GSUB.subt = function(s, a, o, c) {
                            var u = t._bin
                              , f = o
                              , m = {};
                            if (m.fmt = u.readUshort(s, o),
                            o += 2,
                            a != 1 && a != 2 && a != 4 && a != 5 && a != 6)
                                return null;
                            if (a == 1 || a == 2 || a == 4 || a == 5 && m.fmt <= 2 || a == 6 && m.fmt <= 2) {
                                var v = u.readUshort(s, o);
                                o += 2,
                                m.coverage = t._lctf.readCoverage(s, f + v)
                            }
                            if (a == 1 && m.fmt >= 1 && m.fmt <= 2) {
                                if (m.fmt == 1)
                                    m.delta = u.readShort(s, o),
                                    o += 2;
                                else if (m.fmt == 2) {
                                    var y = u.readUshort(s, o);
                                    o += 2,
                                    m.newg = u.readUshorts(s, o, y),
                                    o += 2 * m.newg.length
                                }
                            } else if (a == 2 && m.fmt == 1) {
                                y = u.readUshort(s, o),
                                o += 2,
                                m.seqs = [];
                                for (var S = 0; S < y; S++) {
                                    var A = u.readUshort(s, o) + f;
                                    o += 2;
                                    var M = u.readUshort(s, A);
                                    m.seqs.push(u.readUshorts(s, A + 2, M))
                                }
                            } else if (a == 4)
                                for (m.vals = [],
                                y = u.readUshort(s, o),
                                o += 2,
                                S = 0; S < y; S++) {
                                    var x = u.readUshort(s, o);
                                    o += 2,
                                    m.vals.push(t.GSUB.readLigatureSet(s, f + x))
                                }
                            else if (a == 5 && m.fmt == 2) {
                                if (m.fmt == 2) {
                                    var T = u.readUshort(s, o);
                                    o += 2,
                                    m.cDef = t._lctf.readClassDef(s, f + T),
                                    m.scset = [];
                                    var D = u.readUshort(s, o);
                                    for (o += 2,
                                    S = 0; S < D; S++) {
                                        var w = u.readUshort(s, o);
                                        o += 2,
                                        m.scset.push(w == 0 ? null : t.GSUB.readSubClassSet(s, f + w))
                                    }
                                }
                            } else if (a == 6 && m.fmt == 3) {
                                if (m.fmt == 3) {
                                    for (S = 0; S < 3; S++) {
                                        y = u.readUshort(s, o),
                                        o += 2;
                                        for (var U = [], O = 0; O < y; O++)
                                            U.push(t._lctf.readCoverage(s, f + u.readUshort(s, o + 2 * O)));
                                        o += 2 * y,
                                        S == 0 && (m.backCvg = U),
                                        S == 1 && (m.inptCvg = U),
                                        S == 2 && (m.ahedCvg = U)
                                    }
                                    y = u.readUshort(s, o),
                                    o += 2,
                                    m.lookupRec = t.GSUB.readSubstLookupRecords(s, o, y)
                                }
                            } else {
                                if (a == 7 && m.fmt == 1) {
                                    var L = u.readUshort(s, o);
                                    o += 2;
                                    var N = u.readUint(s, o);
                                    if (o += 4,
                                    c.ltype == 9)
                                        c.ltype = L;
                                    else if (c.ltype != L)
                                        throw "invalid extension substitution";
                                    return t.GSUB.subt(s, c.ltype, f + N)
                                }
                                console.debug("unsupported GSUB table LookupType", a, "format", m.fmt)
                            }
                            return m
                        }
                        ,
                        t.GSUB.readSubClassSet = function(s, a) {
                            var o = t._bin.readUshort
                              , c = a
                              , u = []
                              , f = o(s, a);
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = o(s, a);
                                a += 2,
                                u.push(t.GSUB.readSubClassRule(s, c + v))
                            }
                            return u
                        }
                        ,
                        t.GSUB.readSubClassRule = function(s, a) {
                            var o = t._bin.readUshort
                              , c = {}
                              , u = o(s, a)
                              , f = o(s, a += 2);
                            a += 2,
                            c.input = [];
                            for (var m = 0; m < u - 1; m++)
                                c.input.push(o(s, a)),
                                a += 2;
                            return c.substLookupRecords = t.GSUB.readSubstLookupRecords(s, a, f),
                            c
                        }
                        ,
                        t.GSUB.readSubstLookupRecords = function(s, a, o) {
                            for (var c = t._bin.readUshort, u = [], f = 0; f < o; f++)
                                u.push(c(s, a), c(s, a + 2)),
                                a += 4;
                            return u
                        }
                        ,
                        t.GSUB.readChainSubClassSet = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = []
                              , f = o.readUshort(s, a);
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = o.readUshort(s, a);
                                a += 2,
                                u.push(t.GSUB.readChainSubClassRule(s, c + v))
                            }
                            return u
                        }
                        ,
                        t.GSUB.readChainSubClassRule = function(s, a) {
                            for (var o = t._bin, c = {}, u = ["backtrack", "input", "lookahead"], f = 0; f < u.length; f++) {
                                var m = o.readUshort(s, a);
                                a += 2,
                                f == 1 && m--,
                                c[u[f]] = o.readUshorts(s, a, m),
                                a += 2 * c[u[f]].length
                            }
                            return m = o.readUshort(s, a),
                            a += 2,
                            c.subst = o.readUshorts(s, a, 2 * m),
                            a += 2 * c.subst.length,
                            c
                        }
                        ,
                        t.GSUB.readLigatureSet = function(s, a) {
                            var o = t._bin
                              , c = a
                              , u = []
                              , f = o.readUshort(s, a);
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = o.readUshort(s, a);
                                a += 2,
                                u.push(t.GSUB.readLigature(s, c + v))
                            }
                            return u
                        }
                        ,
                        t.GSUB.readLigature = function(s, a) {
                            var o = t._bin
                              , c = {
                                chain: []
                            };
                            c.nglyph = o.readUshort(s, a),
                            a += 2;
                            var u = o.readUshort(s, a);
                            a += 2;
                            for (var f = 0; f < u - 1; f++)
                                c.chain.push(o.readUshort(s, a)),
                                a += 2;
                            return c
                        }
                        ,
                        t.head = {},
                        t.head.parse = function(s, a, o) {
                            var c = t._bin
                              , u = {};
                            return c.readFixed(s, a),
                            a += 4,
                            u.fontRevision = c.readFixed(s, a),
                            a += 4,
                            c.readUint(s, a),
                            a += 4,
                            c.readUint(s, a),
                            a += 4,
                            u.flags = c.readUshort(s, a),
                            a += 2,
                            u.unitsPerEm = c.readUshort(s, a),
                            a += 2,
                            u.created = c.readUint64(s, a),
                            a += 8,
                            u.modified = c.readUint64(s, a),
                            a += 8,
                            u.xMin = c.readShort(s, a),
                            a += 2,
                            u.yMin = c.readShort(s, a),
                            a += 2,
                            u.xMax = c.readShort(s, a),
                            a += 2,
                            u.yMax = c.readShort(s, a),
                            a += 2,
                            u.macStyle = c.readUshort(s, a),
                            a += 2,
                            u.lowestRecPPEM = c.readUshort(s, a),
                            a += 2,
                            u.fontDirectionHint = c.readShort(s, a),
                            a += 2,
                            u.indexToLocFormat = c.readShort(s, a),
                            a += 2,
                            u.glyphDataFormat = c.readShort(s, a),
                            a += 2,
                            u
                        }
                        ,
                        t.hhea = {},
                        t.hhea.parse = function(s, a, o) {
                            var c = t._bin
                              , u = {};
                            return c.readFixed(s, a),
                            a += 4,
                            u.ascender = c.readShort(s, a),
                            a += 2,
                            u.descender = c.readShort(s, a),
                            a += 2,
                            u.lineGap = c.readShort(s, a),
                            a += 2,
                            u.advanceWidthMax = c.readUshort(s, a),
                            a += 2,
                            u.minLeftSideBearing = c.readShort(s, a),
                            a += 2,
                            u.minRightSideBearing = c.readShort(s, a),
                            a += 2,
                            u.xMaxExtent = c.readShort(s, a),
                            a += 2,
                            u.caretSlopeRise = c.readShort(s, a),
                            a += 2,
                            u.caretSlopeRun = c.readShort(s, a),
                            a += 2,
                            u.caretOffset = c.readShort(s, a),
                            a += 2,
                            a += 8,
                            u.metricDataFormat = c.readShort(s, a),
                            a += 2,
                            u.numberOfHMetrics = c.readUshort(s, a),
                            a += 2,
                            u
                        }
                        ,
                        t.hmtx = {},
                        t.hmtx.parse = function(s, a, o, c) {
                            for (var u = t._bin, f = {
                                aWidth: [],
                                lsBearing: []
                            }, m = 0, v = 0, y = 0; y < c.maxp.numGlyphs; y++)
                                y < c.hhea.numberOfHMetrics && (m = u.readUshort(s, a),
                                a += 2,
                                v = u.readShort(s, a),
                                a += 2),
                                f.aWidth.push(m),
                                f.lsBearing.push(v);
                            return f
                        }
                        ,
                        t.kern = {},
                        t.kern.parse = function(s, a, o, c) {
                            var u = t._bin
                              , f = u.readUshort(s, a);
                            if (a += 2,
                            f == 1)
                                return t.kern.parseV1(s, a - 2, o, c);
                            var m = u.readUshort(s, a);
                            a += 2;
                            for (var v = {
                                glyph1: [],
                                rval: []
                            }, y = 0; y < m; y++) {
                                a += 2,
                                o = u.readUshort(s, a),
                                a += 2;
                                var S = u.readUshort(s, a);
                                a += 2;
                                var A = S >>> 8;
                                if ((A &= 15) != 0)
                                    throw "unknown kern table format: " + A;
                                a = t.kern.readFormat0(s, a, v)
                            }
                            return v
                        }
                        ,
                        t.kern.parseV1 = function(s, a, o, c) {
                            var u = t._bin;
                            u.readFixed(s, a),
                            a += 4;
                            var f = u.readUint(s, a);
                            a += 4;
                            for (var m = {
                                glyph1: [],
                                rval: []
                            }, v = 0; v < f; v++) {
                                u.readUint(s, a),
                                a += 4;
                                var y = u.readUshort(s, a);
                                a += 2,
                                u.readUshort(s, a),
                                a += 2;
                                var S = y >>> 8;
                                if ((S &= 15) != 0)
                                    throw "unknown kern table format: " + S;
                                a = t.kern.readFormat0(s, a, m)
                            }
                            return m
                        }
                        ,
                        t.kern.readFormat0 = function(s, a, o) {
                            var c = t._bin
                              , u = -1
                              , f = c.readUshort(s, a);
                            a += 2,
                            c.readUshort(s, a),
                            a += 2,
                            c.readUshort(s, a),
                            a += 2,
                            c.readUshort(s, a),
                            a += 2;
                            for (var m = 0; m < f; m++) {
                                var v = c.readUshort(s, a);
                                a += 2;
                                var y = c.readUshort(s, a);
                                a += 2;
                                var S = c.readShort(s, a);
                                a += 2,
                                v != u && (o.glyph1.push(v),
                                o.rval.push({
                                    glyph2: [],
                                    vals: []
                                }));
                                var A = o.rval[o.rval.length - 1];
                                A.glyph2.push(y),
                                A.vals.push(S),
                                u = v
                            }
                            return a
                        }
                        ,
                        t.loca = {},
                        t.loca.parse = function(s, a, o, c) {
                            var u = t._bin
                              , f = []
                              , m = c.head.indexToLocFormat
                              , v = c.maxp.numGlyphs + 1;
                            if (m == 0)
                                for (var y = 0; y < v; y++)
                                    f.push(u.readUshort(s, a + (y << 1)) << 1);
                            if (m == 1)
                                for (y = 0; y < v; y++)
                                    f.push(u.readUint(s, a + (y << 2)));
                            return f
                        }
                        ,
                        t.maxp = {},
                        t.maxp.parse = function(s, a, o) {
                            var c = t._bin
                              , u = {}
                              , f = c.readUint(s, a);
                            return a += 4,
                            u.numGlyphs = c.readUshort(s, a),
                            a += 2,
                            f == 65536 && (u.maxPoints = c.readUshort(s, a),
                            a += 2,
                            u.maxContours = c.readUshort(s, a),
                            a += 2,
                            u.maxCompositePoints = c.readUshort(s, a),
                            a += 2,
                            u.maxCompositeContours = c.readUshort(s, a),
                            a += 2,
                            u.maxZones = c.readUshort(s, a),
                            a += 2,
                            u.maxTwilightPoints = c.readUshort(s, a),
                            a += 2,
                            u.maxStorage = c.readUshort(s, a),
                            a += 2,
                            u.maxFunctionDefs = c.readUshort(s, a),
                            a += 2,
                            u.maxInstructionDefs = c.readUshort(s, a),
                            a += 2,
                            u.maxStackElements = c.readUshort(s, a),
                            a += 2,
                            u.maxSizeOfInstructions = c.readUshort(s, a),
                            a += 2,
                            u.maxComponentElements = c.readUshort(s, a),
                            a += 2,
                            u.maxComponentDepth = c.readUshort(s, a),
                            a += 2),
                            u
                        }
                        ,
                        t.name = {},
                        t.name.parse = function(s, a, o) {
                            var c = t._bin
                              , u = {};
                            c.readUshort(s, a),
                            a += 2;
                            var f = c.readUshort(s, a);
                            a += 2,
                            c.readUshort(s, a);
                            for (var m, v = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], y = a += 2, S = 0; S < f; S++) {
                                var A = c.readUshort(s, a);
                                a += 2;
                                var M = c.readUshort(s, a);
                                a += 2;
                                var x = c.readUshort(s, a);
                                a += 2;
                                var T = c.readUshort(s, a);
                                a += 2;
                                var D = c.readUshort(s, a);
                                a += 2;
                                var w = c.readUshort(s, a);
                                a += 2;
                                var U, O = v[T], L = y + 12 * f + w;
                                if (A == 0)
                                    U = c.readUnicode(s, L, D / 2);
                                else if (A == 3 && M == 0)
                                    U = c.readUnicode(s, L, D / 2);
                                else if (M == 0)
                                    U = c.readASCII(s, L, D);
                                else if (M == 1)
                                    U = c.readUnicode(s, L, D / 2);
                                else if (M == 3)
                                    U = c.readUnicode(s, L, D / 2);
                                else {
                                    if (A != 1)
                                        throw "unknown encoding " + M + ", platformID: " + A;
                                    U = c.readASCII(s, L, D),
                                    console.debug("reading unknown MAC encoding " + M + " as ASCII")
                                }
                                var N = "p" + A + "," + x.toString(16);
                                u[N] ?? (u[N] = {}),
                                u[N][O !== void 0 ? O : T] = U,
                                u[N]._lang = x
                            }
                            for (var z in u)
                                if (u[z].postScriptName != null && u[z]._lang == 1033)
                                    return u[z];
                            for (var z in u)
                                if (u[z].postScriptName != null && u[z]._lang == 0)
                                    return u[z];
                            for (var z in u)
                                if (u[z].postScriptName != null && u[z]._lang == 3084)
                                    return u[z];
                            for (var z in u)
                                if (u[z].postScriptName != null)
                                    return u[z];
                            for (var z in u) {
                                m = z;
                                break
                            }
                            return console.debug("returning name table with languageID " + u[m]._lang),
                            u[m]
                        }
                        ,
                        t["OS/2"] = {},
                        t["OS/2"].parse = function(s, a, o) {
                            var c = t._bin.readUshort(s, a);
                            a += 2;
                            var u = {};
                            if (c == 0)
                                t["OS/2"].version0(s, a, u);
                            else if (c == 1)
                                t["OS/2"].version1(s, a, u);
                            else if (c == 2 || c == 3 || c == 4)
                                t["OS/2"].version2(s, a, u);
                            else {
                                if (c != 5)
                                    throw "unknown OS/2 table version: " + c;
                                t["OS/2"].version5(s, a, u)
                            }
                            return u
                        }
                        ,
                        t["OS/2"].version0 = function(s, a, o) {
                            var c = t._bin;
                            return o.xAvgCharWidth = c.readShort(s, a),
                            a += 2,
                            o.usWeightClass = c.readUshort(s, a),
                            a += 2,
                            o.usWidthClass = c.readUshort(s, a),
                            a += 2,
                            o.fsType = c.readUshort(s, a),
                            a += 2,
                            o.ySubscriptXSize = c.readShort(s, a),
                            a += 2,
                            o.ySubscriptYSize = c.readShort(s, a),
                            a += 2,
                            o.ySubscriptXOffset = c.readShort(s, a),
                            a += 2,
                            o.ySubscriptYOffset = c.readShort(s, a),
                            a += 2,
                            o.ySuperscriptXSize = c.readShort(s, a),
                            a += 2,
                            o.ySuperscriptYSize = c.readShort(s, a),
                            a += 2,
                            o.ySuperscriptXOffset = c.readShort(s, a),
                            a += 2,
                            o.ySuperscriptYOffset = c.readShort(s, a),
                            a += 2,
                            o.yStrikeoutSize = c.readShort(s, a),
                            a += 2,
                            o.yStrikeoutPosition = c.readShort(s, a),
                            a += 2,
                            o.sFamilyClass = c.readShort(s, a),
                            a += 2,
                            o.panose = c.readBytes(s, a, 10),
                            a += 10,
                            o.ulUnicodeRange1 = c.readUint(s, a),
                            a += 4,
                            o.ulUnicodeRange2 = c.readUint(s, a),
                            a += 4,
                            o.ulUnicodeRange3 = c.readUint(s, a),
                            a += 4,
                            o.ulUnicodeRange4 = c.readUint(s, a),
                            a += 4,
                            o.achVendID = [c.readInt8(s, a), c.readInt8(s, a + 1), c.readInt8(s, a + 2), c.readInt8(s, a + 3)],
                            a += 4,
                            o.fsSelection = c.readUshort(s, a),
                            a += 2,
                            o.usFirstCharIndex = c.readUshort(s, a),
                            a += 2,
                            o.usLastCharIndex = c.readUshort(s, a),
                            a += 2,
                            o.sTypoAscender = c.readShort(s, a),
                            a += 2,
                            o.sTypoDescender = c.readShort(s, a),
                            a += 2,
                            o.sTypoLineGap = c.readShort(s, a),
                            a += 2,
                            o.usWinAscent = c.readUshort(s, a),
                            a += 2,
                            o.usWinDescent = c.readUshort(s, a),
                            a += 2
                        }
                        ,
                        t["OS/2"].version1 = function(s, a, o) {
                            var c = t._bin;
                            return a = t["OS/2"].version0(s, a, o),
                            o.ulCodePageRange1 = c.readUint(s, a),
                            a += 4,
                            o.ulCodePageRange2 = c.readUint(s, a),
                            a += 4
                        }
                        ,
                        t["OS/2"].version2 = function(s, a, o) {
                            var c = t._bin;
                            return a = t["OS/2"].version1(s, a, o),
                            o.sxHeight = c.readShort(s, a),
                            a += 2,
                            o.sCapHeight = c.readShort(s, a),
                            a += 2,
                            o.usDefault = c.readUshort(s, a),
                            a += 2,
                            o.usBreak = c.readUshort(s, a),
                            a += 2,
                            o.usMaxContext = c.readUshort(s, a),
                            a += 2
                        }
                        ,
                        t["OS/2"].version5 = function(s, a, o) {
                            var c = t._bin;
                            return a = t["OS/2"].version2(s, a, o),
                            o.usLowerOpticalPointSize = c.readUshort(s, a),
                            a += 2,
                            o.usUpperOpticalPointSize = c.readUshort(s, a),
                            a += 2
                        }
                        ,
                        t.post = {},
                        t.post.parse = function(s, a, o) {
                            var c = t._bin
                              , u = {};
                            return u.version = c.readFixed(s, a),
                            a += 4,
                            u.italicAngle = c.readFixed(s, a),
                            a += 4,
                            u.underlinePosition = c.readShort(s, a),
                            a += 2,
                            u.underlineThickness = c.readShort(s, a),
                            a += 2,
                            u
                        }
                        ,
                        t ??= {},
                        t.U ??= {},
                        t.U.codeToGlyph = function(s, a) {
                            var o = s.cmap
                              , c = -1;
                            if (o.p0e4 != null ? c = o.p0e4 : o.p3e1 != null ? c = o.p3e1 : o.p1e0 != null ? c = o.p1e0 : o.p0e3 != null && (c = o.p0e3),
                            c == -1)
                                throw "no familiar platform and encoding!";
                            var u = o.tables[c];
                            if (u.format == 0)
                                return a >= u.map.length ? 0 : u.map[a];
                            if (u.format == 4) {
                                for (var f = -1, m = 0; m < u.endCount.length; m++)
                                    if (a <= u.endCount[m]) {
                                        f = m;
                                        break
                                    }
                                return f == -1 || u.startCount[f] > a ? 0 : 65535 & (u.idRangeOffset[f] != 0 ? u.glyphIdArray[a - u.startCount[f] + (u.idRangeOffset[f] >> 1) - (u.idRangeOffset.length - f)] : a + u.idDelta[f])
                            }
                            if (u.format == 12) {
                                if (a > u.groups[u.groups.length - 1][1])
                                    return 0;
                                for (m = 0; m < u.groups.length; m++) {
                                    var v = u.groups[m];
                                    if (v[0] <= a && a <= v[1])
                                        return v[2] + (a - v[0])
                                }
                                return 0
                            }
                            throw "unknown cmap table format " + u.format
                        }
                        ,
                        t.U.glyphToPath = function(s, a) {
                            var o = {
                                cmds: [],
                                crds: []
                            };
                            if (s.SVG && s.SVG.entries[a]) {
                                var c = s.SVG.entries[a];
                                return c == null ? o : (typeof c == "string" && (c = t.SVG.toPath(c),
                                s.SVG.entries[a] = c),
                                c)
                            }
                            if (s.CFF) {
                                var u = {
                                    x: 0,
                                    y: 0,
                                    stack: [],
                                    nStems: 0,
                                    haveWidth: !1,
                                    width: s.CFF.Private ? s.CFF.Private.defaultWidthX : 0,
                                    open: !1
                                }
                                  , f = s.CFF
                                  , m = s.CFF.Private;
                                if (f.ROS) {
                                    for (var v = 0; f.FDSelect[v + 2] <= a; )
                                        v += 2;
                                    m = f.FDArray[f.FDSelect[v + 1]].Private
                                }
                                t.U._drawCFF(s.CFF.CharStrings[a], u, f, m, o)
                            } else
                                s.glyf && t.U._drawGlyf(a, s, o);
                            return o
                        }
                        ,
                        t.U._drawGlyf = function(s, a, o) {
                            var c = a.glyf[s];
                            c ??= a.glyf[s] = t.glyf._parseGlyf(a, s),
                            c != null && (c.noc > -1 ? t.U._simpleGlyph(c, o) : t.U._compoGlyph(c, a, o))
                        }
                        ,
                        t.U._simpleGlyph = function(s, a) {
                            for (var o = 0; o < s.noc; o++) {
                                for (var c = o == 0 ? 0 : s.endPts[o - 1] + 1, u = s.endPts[o], f = c; f <= u; f++) {
                                    var m = f == c ? u : f - 1
                                      , v = f == u ? c : f + 1
                                      , y = 1 & s.flags[f]
                                      , S = 1 & s.flags[m]
                                      , A = 1 & s.flags[v]
                                      , M = s.xs[f]
                                      , x = s.ys[f];
                                    if (f == c)
                                        if (y) {
                                            if (!S) {
                                                t.U.P.moveTo(a, M, x);
                                                continue
                                            }
                                            t.U.P.moveTo(a, s.xs[m], s.ys[m])
                                        } else
                                            S ? t.U.P.moveTo(a, s.xs[m], s.ys[m]) : t.U.P.moveTo(a, (s.xs[m] + M) / 2, (s.ys[m] + x) / 2);
                                    y ? S && t.U.P.lineTo(a, M, x) : A ? t.U.P.qcurveTo(a, M, x, s.xs[v], s.ys[v]) : t.U.P.qcurveTo(a, M, x, (M + s.xs[v]) / 2, (x + s.ys[v]) / 2)
                                }
                                t.U.P.closePath(a)
                            }
                        }
                        ,
                        t.U._compoGlyph = function(s, a, o) {
                            for (var c = 0; c < s.parts.length; c++) {
                                var u = {
                                    cmds: [],
                                    crds: []
                                }
                                  , f = s.parts[c];
                                t.U._drawGlyf(f.glyphIndex, a, u);
                                for (var m = f.m, v = 0; v < u.crds.length; v += 2) {
                                    var y = u.crds[v]
                                      , S = u.crds[v + 1];
                                    o.crds.push(y * m.a + S * m.b + m.tx),
                                    o.crds.push(y * m.c + S * m.d + m.ty)
                                }
                                for (v = 0; v < u.cmds.length; v++)
                                    o.cmds.push(u.cmds[v])
                            }
                        }
                        ,
                        t.U._getGlyphClass = function(s, a) {
                            var o = t._lctf.getInterval(a, s);
                            return o == -1 ? 0 : a[o + 2]
                        }
                        ,
                        t.U._applySubs = function(s, a, o, c) {
                            for (var u = s.length - a - 1, f = 0; f < o.tabs.length; f++)
                                if (o.tabs[f] != null) {
                                    var m, v = o.tabs[f];
                                    if (!v.coverage || (m = t._lctf.coverageIndex(v.coverage, s[a])) != -1) {
                                        if (o.ltype == 1)
                                            s[a],
                                            v.fmt == 1 ? s[a] = s[a] + v.delta : s[a] = v.newg[m];
                                        else if (o.ltype == 4)
                                            for (var y = v.vals[m], S = 0; S < y.length; S++) {
                                                var A = y[S]
                                                  , M = A.chain.length;
                                                if (!(M > u)) {
                                                    for (var x = !0, T = 0, D = 0; D < M; D++) {
                                                        for (; s[a + T + (1 + D)] == -1; )
                                                            T++;
                                                        A.chain[D] != s[a + T + (1 + D)] && (x = !1)
                                                    }
                                                    if (x) {
                                                        for (s[a] = A.nglyph,
                                                        D = 0; D < M + T; D++)
                                                            s[a + D + 1] = -1;
                                                        break
                                                    }
                                                }
                                            }
                                        else if (o.ltype == 5 && v.fmt == 2)
                                            for (var w = t._lctf.getInterval(v.cDef, s[a]), U = v.cDef[w + 2], O = v.scset[U], L = 0; L < O.length; L++) {
                                                var N = O[L]
                                                  , z = N.input;
                                                if (!(z.length > u)) {
                                                    for (x = !0,
                                                    D = 0; D < z.length; D++) {
                                                        var I = t._lctf.getInterval(v.cDef, s[a + 1 + D]);
                                                        if (w == -1 && v.cDef[I + 2] != z[D]) {
                                                            x = !1;
                                                            break
                                                        }
                                                    }
                                                    if (x) {
                                                        var B = N.substLookupRecords;
                                                        for (S = 0; S < B.length; S += 2)
                                                            B[S],
                                                            B[S + 1]
                                                    }
                                                }
                                            }
                                        else if (o.ltype == 6 && v.fmt == 3) {
                                            if (!t.U._glsCovered(s, v.backCvg, a - v.backCvg.length) || !t.U._glsCovered(s, v.inptCvg, a) || !t.U._glsCovered(s, v.ahedCvg, a + v.inptCvg.length))
                                                continue;
                                            var G = v.lookupRec;
                                            for (L = 0; L < G.length; L += 2) {
                                                w = G[L];
                                                var X = c[G[L + 1]];
                                                t.U._applySubs(s, a + w, X, c)
                                            }
                                        }
                                    }
                                }
                        }
                        ,
                        t.U._glsCovered = function(s, a, o) {
                            for (var c = 0; c < a.length; c++)
                                if (t._lctf.coverageIndex(a[c], s[o + c]) == -1)
                                    return !1;
                            return !0
                        }
                        ,
                        t.U.glyphsToPath = function(s, a, o) {
                            for (var c = {
                                cmds: [],
                                crds: []
                            }, u = 0, f = 0; f < a.length; f++) {
                                var m = a[f];
                                if (m != -1) {
                                    for (var v = f < a.length - 1 && a[f + 1] != -1 ? a[f + 1] : 0, y = t.U.glyphToPath(s, m), S = 0; S < y.crds.length; S += 2)
                                        c.crds.push(y.crds[S] + u),
                                        c.crds.push(y.crds[S + 1]);
                                    for (o && c.cmds.push(o),
                                    S = 0; S < y.cmds.length; S++)
                                        c.cmds.push(y.cmds[S]);
                                    o && c.cmds.push("X"),
                                    u += s.hmtx.aWidth[m],
                                    f < a.length - 1 && (u += t.U.getPairAdjustment(s, m, v))
                                }
                            }
                            return c
                        }
                        ,
                        t.U.P = {},
                        t.U.P.moveTo = function(s, a, o) {
                            s.cmds.push("M"),
                            s.crds.push(a, o)
                        }
                        ,
                        t.U.P.lineTo = function(s, a, o) {
                            s.cmds.push("L"),
                            s.crds.push(a, o)
                        }
                        ,
                        t.U.P.curveTo = function(s, a, o, c, u, f, m) {
                            s.cmds.push("C"),
                            s.crds.push(a, o, c, u, f, m)
                        }
                        ,
                        t.U.P.qcurveTo = function(s, a, o, c, u) {
                            s.cmds.push("Q"),
                            s.crds.push(a, o, c, u)
                        }
                        ,
                        t.U.P.closePath = function(s) {
                            s.cmds.push("Z")
                        }
                        ,
                        t.U._drawCFF = function(s, a, o, c, u) {
                            for (var f = a.stack, m = a.nStems, v = a.haveWidth, y = a.width, S = a.open, A = 0, M = a.x, x = a.y, T = 0, D = 0, w = 0, U = 0, O = 0, L = 0, N = 0, z = 0, I = 0, B = 0, G = {
                                val: 0,
                                size: 0
                            }; A < s.length; ) {
                                t.CFF.getCharString(s, A, G);
                                var X = G.val;
                                if (A += G.size,
                                X == "o1" || X == "o18")
                                    f.length % 2 != 0 && !v && (y = f.shift() + c.nominalWidthX),
                                    m += f.length >> 1,
                                    f.length = 0,
                                    v = !0;
                                else if (X == "o3" || X == "o23")
                                    f.length % 2 != 0 && !v && (y = f.shift() + c.nominalWidthX),
                                    m += f.length >> 1,
                                    f.length = 0,
                                    v = !0;
                                else if (X == "o4")
                                    f.length > 1 && !v && (y = f.shift() + c.nominalWidthX,
                                    v = !0),
                                    S && t.U.P.closePath(u),
                                    x += f.pop(),
                                    t.U.P.moveTo(u, M, x),
                                    S = !0;
                                else if (X == "o5")
                                    for (; f.length > 0; )
                                        M += f.shift(),
                                        x += f.shift(),
                                        t.U.P.lineTo(u, M, x);
                                else if (X == "o6" || X == "o7")
                                    for (var q = f.length, Q = X == "o6", oe = 0; oe < q; oe++) {
                                        var k = f.shift();
                                        Q ? M += k : x += k,
                                        Q = !Q,
                                        t.U.P.lineTo(u, M, x)
                                    }
                                else if (X == "o8" || X == "o24") {
                                    q = f.length;
                                    for (var W = 0; W + 6 <= q; )
                                        T = M + f.shift(),
                                        D = x + f.shift(),
                                        w = T + f.shift(),
                                        U = D + f.shift(),
                                        M = w + f.shift(),
                                        x = U + f.shift(),
                                        t.U.P.curveTo(u, T, D, w, U, M, x),
                                        W += 6;
                                    X == "o24" && (M += f.shift(),
                                    x += f.shift(),
                                    t.U.P.lineTo(u, M, x))
                                } else {
                                    if (X == "o11")
                                        break;
                                    if (X == "o1234" || X == "o1235" || X == "o1236" || X == "o1237")
                                        X == "o1234" && (D = x,
                                        w = (T = M + f.shift()) + f.shift(),
                                        B = U = D + f.shift(),
                                        L = U,
                                        z = x,
                                        M = (N = (O = (I = w + f.shift()) + f.shift()) + f.shift()) + f.shift(),
                                        t.U.P.curveTo(u, T, D, w, U, I, B),
                                        t.U.P.curveTo(u, O, L, N, z, M, x)),
                                        X == "o1235" && (T = M + f.shift(),
                                        D = x + f.shift(),
                                        w = T + f.shift(),
                                        U = D + f.shift(),
                                        I = w + f.shift(),
                                        B = U + f.shift(),
                                        O = I + f.shift(),
                                        L = B + f.shift(),
                                        N = O + f.shift(),
                                        z = L + f.shift(),
                                        M = N + f.shift(),
                                        x = z + f.shift(),
                                        f.shift(),
                                        t.U.P.curveTo(u, T, D, w, U, I, B),
                                        t.U.P.curveTo(u, O, L, N, z, M, x)),
                                        X == "o1236" && (T = M + f.shift(),
                                        D = x + f.shift(),
                                        w = T + f.shift(),
                                        B = U = D + f.shift(),
                                        L = U,
                                        N = (O = (I = w + f.shift()) + f.shift()) + f.shift(),
                                        z = L + f.shift(),
                                        M = N + f.shift(),
                                        t.U.P.curveTo(u, T, D, w, U, I, B),
                                        t.U.P.curveTo(u, O, L, N, z, M, x)),
                                        X == "o1237" && (T = M + f.shift(),
                                        D = x + f.shift(),
                                        w = T + f.shift(),
                                        U = D + f.shift(),
                                        I = w + f.shift(),
                                        B = U + f.shift(),
                                        O = I + f.shift(),
                                        L = B + f.shift(),
                                        N = O + f.shift(),
                                        z = L + f.shift(),
                                        Math.abs(N - M) > Math.abs(z - x) ? M = N + f.shift() : x = z + f.shift(),
                                        t.U.P.curveTo(u, T, D, w, U, I, B),
                                        t.U.P.curveTo(u, O, L, N, z, M, x));
                                    else if (X == "o14") {
                                        if (f.length > 0 && !v && (y = f.shift() + o.nominalWidthX,
                                        v = !0),
                                        f.length == 4) {
                                            var V = f.shift()
                                              , Z = f.shift()
                                              , j = f.shift()
                                              , ee = f.shift()
                                              , H = t.CFF.glyphBySE(o, j)
                                              , ie = t.CFF.glyphBySE(o, ee);
                                            t.U._drawCFF(o.CharStrings[H], a, o, c, u),
                                            a.x = V,
                                            a.y = Z,
                                            t.U._drawCFF(o.CharStrings[ie], a, o, c, u)
                                        }
                                        S && (t.U.P.closePath(u),
                                        S = !1)
                                    } else if (X == "o19" || X == "o20")
                                        f.length % 2 != 0 && !v && (y = f.shift() + c.nominalWidthX),
                                        m += f.length >> 1,
                                        f.length = 0,
                                        v = !0,
                                        A += m + 7 >> 3;
                                    else if (X == "o21")
                                        f.length > 2 && !v && (y = f.shift() + c.nominalWidthX,
                                        v = !0),
                                        x += f.pop(),
                                        M += f.pop(),
                                        S && t.U.P.closePath(u),
                                        t.U.P.moveTo(u, M, x),
                                        S = !0;
                                    else if (X == "o22")
                                        f.length > 1 && !v && (y = f.shift() + c.nominalWidthX,
                                        v = !0),
                                        M += f.pop(),
                                        S && t.U.P.closePath(u),
                                        t.U.P.moveTo(u, M, x),
                                        S = !0;
                                    else if (X == "o25") {
                                        for (; f.length > 6; )
                                            M += f.shift(),
                                            x += f.shift(),
                                            t.U.P.lineTo(u, M, x);
                                        T = M + f.shift(),
                                        D = x + f.shift(),
                                        w = T + f.shift(),
                                        U = D + f.shift(),
                                        M = w + f.shift(),
                                        x = U + f.shift(),
                                        t.U.P.curveTo(u, T, D, w, U, M, x)
                                    } else if (X == "o26")
                                        for (f.length % 2 && (M += f.shift()); f.length > 0; )
                                            T = M,
                                            D = x + f.shift(),
                                            M = w = T + f.shift(),
                                            x = (U = D + f.shift()) + f.shift(),
                                            t.U.P.curveTo(u, T, D, w, U, M, x);
                                    else if (X == "o27")
                                        for (f.length % 2 && (x += f.shift()); f.length > 0; )
                                            D = x,
                                            w = (T = M + f.shift()) + f.shift(),
                                            U = D + f.shift(),
                                            M = w + f.shift(),
                                            x = U,
                                            t.U.P.curveTo(u, T, D, w, U, M, x);
                                    else if (X == "o10" || X == "o29") {
                                        var se = X == "o10" ? c : o;
                                        if (f.length == 0)
                                            console.debug("error: empty stack");
                                        else {
                                            var K = f.pop()
                                              , le = se.Subrs[K + se.Bias];
                                            a.x = M,
                                            a.y = x,
                                            a.nStems = m,
                                            a.haveWidth = v,
                                            a.width = y,
                                            a.open = S,
                                            t.U._drawCFF(le, a, o, c, u),
                                            M = a.x,
                                            x = a.y,
                                            m = a.nStems,
                                            v = a.haveWidth,
                                            y = a.width,
                                            S = a.open
                                        }
                                    } else if (X == "o30" || X == "o31") {
                                        var ue = f.length
                                          , de = (W = 0,
                                        X == "o31");
                                        for (W += ue - (q = -3 & ue); W < q; )
                                            de ? (D = x,
                                            w = (T = M + f.shift()) + f.shift(),
                                            x = (U = D + f.shift()) + f.shift(),
                                            q - W == 5 ? (M = w + f.shift(),
                                            W++) : M = w,
                                            de = !1) : (T = M,
                                            D = x + f.shift(),
                                            w = T + f.shift(),
                                            U = D + f.shift(),
                                            M = w + f.shift(),
                                            q - W == 5 ? (x = U + f.shift(),
                                            W++) : x = U,
                                            de = !0),
                                            t.U.P.curveTo(u, T, D, w, U, M, x),
                                            W += 4
                                    } else {
                                        if ((X + "").charAt(0) == "o")
                                            throw console.debug("Unknown operation: " + X, s),
                                            X;
                                        f.push(X)
                                    }
                                }
                            }
                            a.x = M,
                            a.y = x,
                            a.nStems = m,
                            a.haveWidth = v,
                            a.width = y,
                            a.open = S
                        }
                        ;
                        var n = t
                          , i = {
                            Typr: n
                        };
                        return e.Typr = n,
                        e.default = i,
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e
                    }
                    )({}).Typr
                }
                function F9() {
                    return (function(e) {
                        var t = Uint8Array
                          , n = Uint16Array
                          , i = Uint32Array
                          , s = new t([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
                          , a = new t([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
                          , o = new t([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
                          , c = function(X, q) {
                            for (var Q = new n(31), oe = 0; oe < 31; ++oe)
                                Q[oe] = q += 1 << X[oe - 1];
                            var k = new i(Q[30]);
                            for (oe = 1; oe < 30; ++oe)
                                for (var W = Q[oe]; W < Q[oe + 1]; ++W)
                                    k[W] = W - Q[oe] << 5 | oe;
                            return [Q, k]
                        }
                          , u = c(s, 2)
                          , f = u[0]
                          , m = u[1];
                        f[28] = 258,
                        m[258] = 28;
                        for (var v = c(a, 0)[0], y = new n(32768), S = 0; S < 32768; ++S) {
                            var A = (43690 & S) >>> 1 | (21845 & S) << 1;
                            A = (61680 & (A = (52428 & A) >>> 2 | (13107 & A) << 2)) >>> 4 | (3855 & A) << 4,
                            y[S] = ((65280 & A) >>> 8 | (255 & A) << 8) >>> 1
                        }
                        var M = function(X, q, Q) {
                            for (var oe = X.length, k = 0, W = new n(q); k < oe; ++k)
                                ++W[X[k] - 1];
                            var V, Z = new n(q);
                            for (k = 0; k < q; ++k)
                                Z[k] = Z[k - 1] + W[k - 1] << 1;
                            if (Q) {
                                V = new n(1 << q);
                                var j = 15 - q;
                                for (k = 0; k < oe; ++k)
                                    if (X[k])
                                        for (var ee = k << 4 | X[k], H = q - X[k], ie = Z[X[k] - 1]++ << H, se = ie | (1 << H) - 1; ie <= se; ++ie)
                                            V[y[ie] >>> j] = ee
                            } else
                                for (V = new n(oe),
                                k = 0; k < oe; ++k)
                                    X[k] && (V[k] = y[Z[X[k] - 1]++] >>> 15 - X[k]);
                            return V
                        }
                          , x = new t(288);
                        for (S = 0; S < 144; ++S)
                            x[S] = 8;
                        for (S = 144; S < 256; ++S)
                            x[S] = 9;
                        for (S = 256; S < 280; ++S)
                            x[S] = 7;
                        for (S = 280; S < 288; ++S)
                            x[S] = 8;
                        var T = new t(32);
                        for (S = 0; S < 32; ++S)
                            T[S] = 5;
                        var D = M(x, 9, 1)
                          , w = M(T, 5, 1)
                          , U = function(X) {
                            for (var q = X[0], Q = 1; Q < X.length; ++Q)
                                X[Q] > q && (q = X[Q]);
                            return q
                        }
                          , O = function(X, q, Q) {
                            var oe = q / 8 | 0;
                            return (X[oe] | X[oe + 1] << 8) >> (7 & q) & Q
                        }
                          , L = function(X, q) {
                            var Q = q / 8 | 0;
                            return (X[Q] | X[Q + 1] << 8 | X[Q + 2] << 16) >> (7 & q)
                        }
                          , N = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
                          , z = function(X, q, Q) {
                            var oe = new Error(q || N[X]);
                            if (oe.code = X,
                            Error.captureStackTrace && Error.captureStackTrace(oe, z),
                            !Q)
                                throw oe;
                            return oe
                        }
                          , I = function(X, q, Q) {
                            var oe = X.length;
                            if (!oe || Q && !Q.l && oe < 5)
                                return q || new t(0);
                            var k = !q || Q
                              , W = !Q || Q.i;
                            Q || (Q = {}),
                            q || (q = new t(3 * oe));
                            var V, Z = function(Ze) {
                                var ht = q.length;
                                if (Ze > ht) {
                                    var lt = new t(Math.max(2 * ht, Ze));
                                    lt.set(q),
                                    q = lt
                                }
                            }, j = Q.f || 0, ee = Q.p || 0, H = Q.b || 0, ie = Q.l, se = Q.d, K = Q.m, le = Q.n, ue = 8 * oe;
                            do {
                                if (!ie) {
                                    Q.f = j = O(X, ee, 1);
                                    var de = O(X, ee + 1, 3);
                                    if (ee += 3,
                                    !de) {
                                        var qe = X[(we = ((V = ee) / 8 | 0) + (7 & V && 1) + 4) - 4] | X[we - 3] << 8
                                          , ze = we + qe;
                                        if (ze > oe) {
                                            W && z(0);
                                            break
                                        }
                                        k && Z(H + qe),
                                        q.set(X.subarray(we, ze), H),
                                        Q.b = H += qe,
                                        Q.p = ee = 8 * ze;
                                        continue
                                    }
                                    if (de == 1)
                                        ie = D,
                                        se = w,
                                        K = 9,
                                        le = 5;
                                    else if (de == 2) {
                                        var Ee = O(X, ee, 31) + 257
                                          , re = O(X, ee + 10, 15) + 4
                                          , Le = Ee + O(X, ee + 5, 31) + 1;
                                        ee += 14;
                                        for (var he = new t(Le), ye = new t(19), xe = 0; xe < re; ++xe)
                                            ye[o[xe]] = O(X, ee + 3 * xe, 7);
                                        ee += 3 * re;
                                        var ge = U(ye)
                                          , Te = (1 << ge) - 1
                                          , Ae = M(ye, ge, 1);
                                        for (xe = 0; xe < Le; ) {
                                            var we, it = Ae[O(X, ee, Te)];
                                            if (ee += 15 & it,
                                            (we = it >>> 4) < 16)
                                                he[xe++] = we;
                                            else {
                                                var je = 0
                                                  , $ = 0;
                                                for (we == 16 ? ($ = 3 + O(X, ee, 3),
                                                ee += 2,
                                                je = he[xe - 1]) : we == 17 ? ($ = 3 + O(X, ee, 7),
                                                ee += 3) : we == 18 && ($ = 11 + O(X, ee, 127),
                                                ee += 7); $--; )
                                                    he[xe++] = je
                                            }
                                        }
                                        var Y = he.subarray(0, Ee)
                                          , pe = he.subarray(Ee);
                                        K = U(Y),
                                        le = U(pe),
                                        ie = M(Y, K, 1),
                                        se = M(pe, le, 1)
                                    } else
                                        z(1);
                                    if (ee > ue) {
                                        W && z(0);
                                        break
                                    }
                                }
                                k && Z(H + 131072);
                                for (var He = (1 << K) - 1, Re = (1 << le) - 1, De = ee; ; De = ee) {
                                    var rt = (je = ie[L(X, ee) & He]) >>> 4;
                                    if ((ee += 15 & je) > ue) {
                                        W && z(0);
                                        break
                                    }
                                    if (je || z(2),
                                    rt < 256)
                                        q[H++] = rt;
                                    else {
                                        if (rt == 256) {
                                            De = ee,
                                            ie = null;
                                            break
                                        }
                                        var $e = rt - 254;
                                        if (rt > 264) {
                                            var ct = s[xe = rt - 257];
                                            $e = O(X, ee, (1 << ct) - 1) + f[xe],
                                            ee += ct
                                        }
                                        var gt = se[L(X, ee) & Re]
                                          , Ie = gt >>> 4;
                                        if (gt || z(3),
                                        ee += 15 & gt,
                                        pe = v[Ie],
                                        Ie > 3 && (ct = a[Ie],
                                        pe += L(X, ee) & (1 << ct) - 1,
                                        ee += ct),
                                        ee > ue) {
                                            W && z(0);
                                            break
                                        }
                                        k && Z(H + 131072);
                                        for (var Je = H + $e; H < Je; H += 4)
                                            q[H] = q[H - pe],
                                            q[H + 1] = q[H + 1 - pe],
                                            q[H + 2] = q[H + 2 - pe],
                                            q[H + 3] = q[H + 3 - pe];
                                        H = Je
                                    }
                                }
                                Q.l = ie,
                                Q.p = De,
                                Q.b = H,
                                ie && (j = 1,
                                Q.m = K,
                                Q.d = se,
                                Q.n = le)
                            } while (!j);
                            return H == q.length ? q : (function(Ze, ht, lt) {
                                (ht == null || ht < 0) && (ht = 0),
                                (lt == null || lt > Ze.length) && (lt = Ze.length);
                                var At = new (Ze instanceof n ? n : Ze instanceof i ? i : t)(lt - ht);
                                return At.set(Ze.subarray(ht, lt)),
                                At
                            }
                            )(q, 0, H)
                        }
                          , B = new t(0)
                          , G = typeof TextDecoder < "u" && new TextDecoder;
                        try {
                            G.decode(B, {
                                stream: !0
                            })
                        } catch {}
                        return e.convert_streams = function(X) {
                            var q = new DataView(X)
                              , Q = 0;
                            function oe() {
                                var Ee = q.getUint16(Q);
                                return Q += 2,
                                Ee
                            }
                            function k() {
                                var Ee = q.getUint32(Q);
                                return Q += 4,
                                Ee
                            }
                            function W(Ee) {
                                qe.setUint16(ze, Ee),
                                ze += 2
                            }
                            function V(Ee) {
                                qe.setUint32(ze, Ee),
                                ze += 4
                            }
                            for (var Z = {
                                signature: k(),
                                flavor: k(),
                                length: k(),
                                numTables: oe(),
                                reserved: oe(),
                                totalSfntSize: k(),
                                majorVersion: oe(),
                                minorVersion: oe(),
                                metaOffset: k(),
                                metaLength: k(),
                                metaOrigLength: k(),
                                privOffset: k(),
                                privLength: k()
                            }, j = 0; Math.pow(2, j) <= Z.numTables; )
                                j++;
                            j--;
                            for (var ee = 16 * Math.pow(2, j), H = 16 * Z.numTables - ee, ie = 12, se = [], K = 0; K < Z.numTables; K++)
                                se.push({
                                    tag: k(),
                                    offset: k(),
                                    compLength: k(),
                                    origLength: k(),
                                    origChecksum: k()
                                }),
                                ie += 16;
                            var le, ue = new Uint8Array(12 + 16 * se.length + se.reduce((function(Ee, re) {
                                return Ee + re.origLength + 4
                            }
                            ), 0)), de = ue.buffer, qe = new DataView(de), ze = 0;
                            return V(Z.flavor),
                            W(Z.numTables),
                            W(ee),
                            W(j),
                            W(H),
                            se.forEach((function(Ee) {
                                V(Ee.tag),
                                V(Ee.origChecksum),
                                V(ie),
                                V(Ee.origLength),
                                Ee.outOffset = ie,
                                (ie += Ee.origLength) % 4 != 0 && (ie += 4 - ie % 4)
                            }
                            )),
                            se.forEach((function(Ee) {
                                var re, Le = X.slice(Ee.offset, Ee.offset + Ee.compLength);
                                if (Ee.compLength != Ee.origLength) {
                                    var he = new Uint8Array(Ee.origLength);
                                    re = new Uint8Array(Le,2),
                                    I(re, he)
                                } else
                                    he = new Uint8Array(Le);
                                ue.set(he, Ee.outOffset);
                                var ye = 0;
                                (ie = Ee.outOffset + Ee.origLength) % 4 != 0 && (ye = 4 - ie % 4),
                                ue.set(new Uint8Array(ye).buffer, Ee.outOffset + Ee.origLength),
                                le = ie + ye
                            }
                            )),
                            de.slice(0, le)
                        }
                        ,
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e
                    }
                    )({}).convert_streams
                }
                function H9(e, t) {
                    const n = {
                        M: 2,
                        L: 2,
                        Q: 4,
                        C: 6,
                        Z: 0
                    }
                      , i = {
                        C: "18g,ca,368,1kz",
                        D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
                        R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
                        L: "x9u,jff,a,fd,jv",
                        T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"
                    }
                      , s = 1
                      , a = 2
                      , o = 4
                      , c = 8
                      , u = 16
                      , f = 32;
                    let m;
                    function v(N) {
                        if (!m) {
                            const z = {
                                R: a,
                                L: s,
                                D: o,
                                C: u,
                                U: f,
                                T: c
                            };
                            m = new Map;
                            for (let I in i) {
                                let B = 0;
                                i[I].split(",").forEach(G => {
                                    let[X,q] = G.split("+");
                                    X = parseInt(X, 36),
                                    q = q ? parseInt(q, 36) : 0,
                                    m.set(B += X, z[I]);
                                    for (let Q = q; Q--; )
                                        m.set(++B, z[I])
                                }
                                )
                            }
                        }
                        return m.get(N) || f
                    }
                    const y = 1
                      , S = 2
                      , A = 3
                      , M = 4
                      , x = [null, "isol", "init", "fina", "medi"];
                    function T(N) {
                        const z = new Uint8Array(N.length);
                        let I = f
                          , B = y
                          , G = -1;
                        for (let X = 0; X < N.length; X++) {
                            const q = N.codePointAt(X);
                            let Q = v(q) | 0
                              , oe = y;
                            Q & c || (I & (o | 17) ? Q & (o | 18) ? (oe = A,
                            (B === y || B === A) && z[G]++) : Q & (s | f) && (B === S || B === M) && z[G]-- : I & (a | f) && (B === S || B === M) && z[G]--,
                            B = z[X] = oe,
                            I = Q,
                            G = X,
                            q > 65535 && X++)
                        }
                        return z
                    }
                    function D(N, z) {
                        const I = [];
                        for (let G = 0; G < z.length; G++) {
                            const X = z.codePointAt(G);
                            X > 65535 && G++,
                            I.push(e.U.codeToGlyph(N, X))
                        }
                        const B = N.GSUB;
                        if (B) {
                            const {lookupList: G, featureList: X} = B;
                            let q;
                            const Q = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/
                              , oe = [];
                            X.forEach(k => {
                                if (Q.test(k.tag))
                                    for (let W = 0; W < k.tab.length; W++) {
                                        if (oe[k.tab[W]])
                                            continue;
                                        oe[k.tab[W]] = !0;
                                        const V = G[k.tab[W]]
                                          , Z = /^(isol|init|fina|medi)$/.test(k.tag);
                                        Z && !q && (q = T(z));
                                        for (let j = 0; j < I.length; j++)
                                            (!q || !Z || x[q[j]] === k.tag) && e.U._applySubs(I, j, V, G)
                                    }
                            }
                            )
                        }
                        return I
                    }
                    function w(N, z) {
                        const I = new Int16Array(z.length * 3);
                        let B = 0;
                        for (; B < z.length; B++) {
                            const Q = z[B];
                            if (Q === -1)
                                continue;
                            I[B * 3 + 2] = N.hmtx.aWidth[Q];
                            const oe = N.GPOS;
                            if (oe) {
                                const k = oe.lookupList;
                                for (let W = 0; W < k.length; W++) {
                                    const V = k[W];
                                    for (let Z = 0; Z < V.tabs.length; Z++) {
                                        const j = V.tabs[Z];
                                        if (V.ltype === 1) {
                                            if (e._lctf.coverageIndex(j.coverage, Q) !== -1 && j.pos) {
                                                q(j.pos, B);
                                                break
                                            }
                                        } else if (V.ltype === 2) {
                                            let ee = null
                                              , H = G();
                                            if (H !== -1) {
                                                const ie = e._lctf.coverageIndex(j.coverage, z[H]);
                                                if (ie !== -1) {
                                                    if (j.fmt === 1) {
                                                        const se = j.pairsets[ie];
                                                        for (let K = 0; K < se.length; K++)
                                                            se[K].gid2 === Q && (ee = se[K])
                                                    } else if (j.fmt === 2) {
                                                        const se = e.U._getGlyphClass(z[H], j.classDef1)
                                                          , K = e.U._getGlyphClass(Q, j.classDef2);
                                                        ee = j.matrix[se][K]
                                                    }
                                                    if (ee) {
                                                        ee.val1 && q(ee.val1, H),
                                                        ee.val2 && q(ee.val2, B);
                                                        break
                                                    }
                                                }
                                            }
                                        } else if (V.ltype === 4) {
                                            const ee = e._lctf.coverageIndex(j.markCoverage, Q);
                                            if (ee !== -1) {
                                                const H = G(X)
                                                  , ie = H === -1 ? -1 : e._lctf.coverageIndex(j.baseCoverage, z[H]);
                                                if (ie !== -1) {
                                                    const se = j.markArray[ee]
                                                      , K = j.baseArray[ie][se.markClass];
                                                    I[B * 3] = K.x - se.x + I[H * 3] - I[H * 3 + 2],
                                                    I[B * 3 + 1] = K.y - se.y + I[H * 3 + 1];
                                                    break
                                                }
                                            }
                                        } else if (V.ltype === 6) {
                                            const ee = e._lctf.coverageIndex(j.mark1Coverage, Q);
                                            if (ee !== -1) {
                                                const H = G();
                                                if (H !== -1) {
                                                    const ie = z[H];
                                                    if (U(N, ie) === 3) {
                                                        const se = e._lctf.coverageIndex(j.mark2Coverage, ie);
                                                        if (se !== -1) {
                                                            const K = j.mark1Array[ee]
                                                              , le = j.mark2Array[se][K.markClass];
                                                            I[B * 3] = le.x - K.x + I[H * 3] - I[H * 3 + 2],
                                                            I[B * 3 + 1] = le.y - K.y + I[H * 3 + 1];
                                                            break
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else if (N.kern && !N.cff) {
                                const k = G();
                                if (k !== -1) {
                                    const W = N.kern.glyph1.indexOf(z[k]);
                                    if (W !== -1) {
                                        const V = N.kern.rval[W].glyph2.indexOf(Q);
                                        V !== -1 && (I[k * 3 + 2] += N.kern.rval[W].vals[V])
                                    }
                                }
                            }
                        }
                        return I;
                        function G(Q) {
                            for (let oe = B - 1; oe >= 0; oe--)
                                if (z[oe] !== -1 && (!Q || Q(z[oe])))
                                    return oe;
                            return -1
                        }
                        function X(Q) {
                            return U(N, Q) === 1
                        }
                        function q(Q, oe) {
                            for (let k = 0; k < 3; k++)
                                I[oe * 3 + k] += Q[k] || 0
                        }
                    }
                    function U(N, z) {
                        const I = N.GDEF && N.GDEF.glyphClassDef;
                        return I ? e.U._getGlyphClass(z, I) : 0
                    }
                    function O(...N) {
                        for (let z = 0; z < N.length; z++)
                            if (typeof N[z] == "number")
                                return N[z]
                    }
                    function L(N) {
                        const z = Object.create(null)
                          , I = N["OS/2"]
                          , B = N.hhea
                          , G = N.head.unitsPerEm
                          , X = O(I && I.sTypoAscender, B && B.ascender, G)
                          , q = {
                            unitsPerEm: G,
                            ascender: X,
                            descender: O(I && I.sTypoDescender, B && B.descender, 0),
                            capHeight: O(I && I.sCapHeight, X),
                            xHeight: O(I && I.sxHeight, X),
                            lineGap: O(I && I.sTypoLineGap, B && B.lineGap),
                            supportsCodePoint(Q) {
                                return e.U.codeToGlyph(N, Q) > 0
                            },
                            forEachGlyph(Q, oe, k, W) {
                                let V = 0;
                                const Z = 1 / q.unitsPerEm * oe
                                  , j = D(N, Q);
                                let ee = 0;
                                const H = w(N, j);
                                return j.forEach( (ie, se) => {
                                    if (ie !== -1) {
                                        let K = z[ie];
                                        if (!K) {
                                            const {cmds: le, crds: ue} = e.U.glyphToPath(N, ie);
                                            let de = ""
                                              , qe = 0;
                                            for (let he = 0, ye = le.length; he < ye; he++) {
                                                const xe = n[le[he]];
                                                de += le[he];
                                                for (let ge = 1; ge <= xe; ge++)
                                                    de += (ge > 1 ? "," : "") + ue[qe++]
                                            }
                                            let ze, Ee, re, Le;
                                            if (ue.length) {
                                                ze = Ee = 1 / 0,
                                                re = Le = -1 / 0;
                                                for (let he = 0, ye = ue.length; he < ye; he += 2) {
                                                    let xe = ue[he]
                                                      , ge = ue[he + 1];
                                                    xe < ze && (ze = xe),
                                                    ge < Ee && (Ee = ge),
                                                    xe > re && (re = xe),
                                                    ge > Le && (Le = ge)
                                                }
                                            } else
                                                ze = re = Ee = Le = 0;
                                            K = z[ie] = {
                                                index: ie,
                                                advanceWidth: N.hmtx.aWidth[ie],
                                                xMin: ze,
                                                yMin: Ee,
                                                xMax: re,
                                                yMax: Le,
                                                path: de
                                            }
                                        }
                                        W.call(null, K, V + H[se * 3] * Z, H[se * 3 + 1] * Z, ee),
                                        V += H[se * 3 + 2] * Z,
                                        k && (V += k * oe)
                                    }
                                    ee += Q.codePointAt(ee) > 65535 ? 2 : 1
                                }
                                ),
                                V
                            }
                        };
                        return q
                    }
                    return function(z) {
                        const I = new Uint8Array(z,0,4)
                          , B = e._bin.readASCII(I, 0, 4);
                        if (B === "wOFF")
                            z = t(z);
                        else if (B === "wOF2")
                            throw new Error("woff2 fonts not supported");
                        return L(e.parse(z)[0])
                    }
                }
                const G9 = Em({
                    name: "Typr Font Parser",
                    dependencies: [z9, F9, H9],
                    init(e, t, n) {
                        const i = e()
                          , s = t();
                        return n(i, s)
                    }
                });
                function V9() {
                    return (function(e) {
                        var t = function() {
                            this.buckets = new Map
                        };
                        t.prototype.add = function(w) {
                            var U = w >> 5;
                            this.buckets.set(U, (this.buckets.get(U) || 0) | 1 << (31 & w))
                        }
                        ,
                        t.prototype.has = function(w) {
                            var U = this.buckets.get(w >> 5);
                            return U !== void 0 && (U & 1 << (31 & w)) != 0
                        }
                        ,
                        t.prototype.serialize = function() {
                            var w = [];
                            return this.buckets.forEach((function(U, O) {
                                w.push((+O).toString(36) + ":" + U.toString(36))
                            }
                            )),
                            w.join(",")
                        }
                        ,
                        t.prototype.deserialize = function(w) {
                            var U = this;
                            this.buckets.clear(),
                            w.split(",").forEach((function(O) {
                                var L = O.split(":");
                                U.buckets.set(parseInt(L[0], 36), parseInt(L[1], 36))
                            }
                            ))
                        }
                        ;
                        var n = Math.pow(2, 8)
                          , i = n - 1
                          , s = ~i;
                        function a(w) {
                            var U = (function(L) {
                                return L & s
                            }
                            )(w).toString(16)
                              , O = (function(L) {
                                return (L & s) + n - 1
                            }
                            )(w).toString(16);
                            return "codepoint-index/plane" + (w >> 16) + "/" + U + "-" + O + ".json"
                        }
                        function o(w, U) {
                            var O = w & i
                              , L = U.codePointAt(O / 6 | 0);
                            return ((L = (L || 48) - 48) & 1 << O % 6) != 0
                        }
                        function c(w, U) {
                            var O;
                            (O = w,
                            O.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map((function(L) {
                                return L.split("-").map((function(N) {
                                    return parseInt(N.trim(), 16)
                                }
                                ))
                            }
                            ))).forEach((function(L) {
                                var N = L[0]
                                  , z = L[1];
                                z === void 0 && (z = N),
                                U(N, z)
                            }
                            ))
                        }
                        function u(w, U) {
                            c(w, (function(O, L) {
                                for (var N = O; N <= L; N++)
                                    U(N)
                            }
                            ))
                        }
                        var f = {}
                          , m = {}
                          , v = new WeakMap
                          , y = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
                        function S(w) {
                            var U = v.get(w);
                            return U || (U = new t,
                            u(w.ranges, (function(O) {
                                return U.add(O)
                            }
                            )),
                            v.set(w, U)),
                            U
                        }
                        var A, M = new Map;
                        function x(w, U, O) {
                            return w[U] ? U : w[O] ? O : (function(L) {
                                for (var N in L)
                                    return N
                            }
                            )(w)
                        }
                        function T(w, U) {
                            var O = U;
                            if (!w.includes(O)) {
                                O = 1 / 0;
                                for (var L = 0; L < w.length; L++)
                                    Math.abs(w[L] - U) < Math.abs(O - U) && (O = w[L])
                            }
                            return O
                        }
                        function D(w) {
                            return A || (A = new Set,
                            u("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", (function(U) {
                                A.add(U)
                            }
                            ))),
                            A.has(w)
                        }
                        return e.CodePointSet = t,
                        e.clearCache = function() {
                            f = {},
                            m = {}
                        }
                        ,
                        e.getFontsForString = function(w, U) {
                            U === void 0 && (U = {});
                            var O, L = U.lang;
                            L === void 0 && (L = /\p{Script=Hangul}/u.test(O = w) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(O) ? "ja" : "en");
                            var N = U.category;
                            N === void 0 && (N = "sans-serif");
                            var z = U.style;
                            z === void 0 && (z = "normal");
                            var I = U.weight;
                            I === void 0 && (I = 400);
                            var B = (U.dataUrl || y).replace(/\/$/g, "")
                              , G = new Map
                              , X = new Uint8Array(w.length)
                              , q = {}
                              , Q = {}
                              , oe = new Array(w.length)
                              , k = new Map
                              , W = !1;
                            function V(ee) {
                                var H = M.get(ee);
                                return H || (H = fetch(B + "/" + ee).then((function(ie) {
                                    if (!ie.ok)
                                        throw new Error(ie.statusText);
                                    return ie.json().then((function(se) {
                                        if (!Array.isArray(se) || se[0] !== 1)
                                            throw new Error("Incorrect schema version; need 1, got " + se[0]);
                                        return se[1]
                                    }
                                    ))
                                }
                                )).catch((function(ie) {
                                    if (B !== y)
                                        return W || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + B + '", trying default CDN. ' + ie.message),
                                        W = !0),
                                        B = y,
                                        M.delete(ee),
                                        V(ee);
                                    throw ie
                                }
                                )),
                                M.set(ee, H)),
                                H
                            }
                            for (var Z = function(ee) {
                                var H = w.codePointAt(ee)
                                  , ie = a(H);
                                oe[ee] = ie,
                                f[ie] || k.has(ie) || k.set(ie, V(ie).then((function(se) {
                                    f[ie] = se
                                }
                                ))),
                                H > 65535 && (ee++,
                                j = ee)
                            }, j = 0; j < w.length; j++)
                                Z(j);
                            return Promise.all(k.values()).then((function() {
                                k.clear();
                                for (var ee = function(ie) {
                                    var se = w.codePointAt(ie)
                                      , K = null
                                      , le = f[oe[ie]]
                                      , ue = void 0;
                                    for (var de in le) {
                                        var qe = Q[de];
                                        if (qe === void 0 && (qe = Q[de] = new RegExp(de).test(L || "en")),
                                        qe) {
                                            for (var ze in ue = de,
                                            le[de])
                                                if (o(se, le[de][ze])) {
                                                    K = ze;
                                                    break
                                                }
                                            break
                                        }
                                    }
                                    if (!K) {
                                        e: for (var Ee in le)
                                            if (Ee !== ue) {
                                                for (var re in le[Ee])
                                                    if (o(se, le[Ee][re])) {
                                                        K = re;
                                                        break e
                                                    }
                                            }
                                    }
                                    K || (console.debug("No font coverage for U+" + se.toString(16)),
                                    K = "latin"),
                                    oe[ie] = K,
                                    m[K] || k.has(K) || k.set(K, V("font-meta/" + K + ".json").then((function(Le) {
                                        m[K] = Le
                                    }
                                    ))),
                                    se > 65535 && (ie++,
                                    H = ie)
                                }, H = 0; H < w.length; H++)
                                    ee(H);
                                return Promise.all(k.values())
                            }
                            )).then((function() {
                                for (var ee, H = null, ie = 0; ie < w.length; ie++) {
                                    var se = w.codePointAt(ie);
                                    if (H && (D(se) || S(H).has(se)))
                                        X[ie] = X[ie - 1];
                                    else {
                                        H = m[oe[ie]];
                                        var K = q[H.id];
                                        if (!K) {
                                            var le = H.typeforms
                                              , ue = x(le, N, "sans-serif")
                                              , de = x(le[ue], z, "normal")
                                              , qe = T((ee = le[ue]) === null || ee === void 0 ? void 0 : ee[de], I);
                                            K = q[H.id] = B + "/font-files/" + H.id + "/" + ue + "." + de + "." + qe + ".woff"
                                        }
                                        var ze = G.get(K);
                                        ze ?? (ze = G.size,
                                        G.set(K, ze)),
                                        X[ie] = ze
                                    }
                                    se > 65535 && (ie++,
                                    X[ie] = X[ie - 1])
                                }
                                return {
                                    fontUrls: Array.from(G.keys()),
                                    chars: X
                                }
                            }
                            ))
                        }
                        ,
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e
                    }
                    )({})
                }
                function k9(e, t) {
                    const n = Object.create(null)
                      , i = Object.create(null);
                    function s(o, c) {
                        const u = f => {
                            console.error(`Failure loading font ${o}`, f)
                        }
                        ;
                        try {
                            const f = new XMLHttpRequest;
                            f.open("get", o, !0),
                            f.responseType = "arraybuffer",
                            f.onload = function() {
                                if (f.status >= 400)
                                    u(new Error(f.statusText));
                                else if (f.status > 0)
                                    try {
                                        const m = e(f.response);
                                        m.src = o,
                                        c(m)
                                    } catch (m) {
                                        u(m)
                                    }
                            }
                            ,
                            f.onerror = u,
                            f.send()
                        } catch (f) {
                            u(f)
                        }
                    }
                    function a(o, c) {
                        let u = n[o];
                        u ? c(u) : i[o] ? i[o].push(c) : (i[o] = [c],
                        s(o, f => {
                            f.src = o,
                            n[o] = f,
                            i[o].forEach(m => m(f)),
                            delete i[o]
                        }
                        ))
                    }
                    return function(o, c, {lang: u, fonts: f=[], style: m="normal", weight: v="normal", unicodeFontsURL: y}={}) {
                        const S = new Uint8Array(o.length)
                          , A = [];
                        o.length || D();
                        const M = new Map
                          , x = [];
                        if (m !== "italic" && (m = "normal"),
                        typeof v != "number" && (v = v === "bold" ? 700 : 400),
                        f && !Array.isArray(f) && (f = [f]),
                        f = f.slice().filter(U => !U.lang || U.lang.test(u)).reverse(),
                        f.length) {
                            let N = 0;
                            (function z(I=0) {
                                for (let B = I, G = o.length; B < G; B++) {
                                    const X = o.codePointAt(B);
                                    if (N === 1 && A[S[B - 1]].supportsCodePoint(X) || B > 0 && /\s/.test(o[B]))
                                        S[B] = S[B - 1],
                                        N === 2 && (x[x.length - 1][1] = B);
                                    else
                                        for (let q = S[B], Q = f.length; q <= Q; q++)
                                            if (q === Q) {
                                                const oe = N === 2 ? x[x.length - 1] : x[x.length] = [B, B];
                                                oe[1] = B,
                                                N = 2
                                            } else {
                                                S[B] = q;
                                                const {src: oe, unicodeRange: k} = f[q];
                                                if (!k || w(X, k)) {
                                                    const W = n[oe];
                                                    if (!W) {
                                                        a(oe, () => {
                                                            z(B)
                                                        }
                                                        );
                                                        return
                                                    }
                                                    if (W.supportsCodePoint(X)) {
                                                        let V = M.get(W);
                                                        typeof V != "number" && (V = A.length,
                                                        A.push(W),
                                                        M.set(W, V)),
                                                        S[B] = V,
                                                        N = 1;
                                                        break
                                                    }
                                                }
                                            }
                                    X > 65535 && B + 1 < G && (S[B + 1] = S[B],
                                    B++,
                                    N === 2 && (x[x.length - 1][1] = B))
                                }
                                T()
                            }
                            )()
                        } else
                            x.push([0, o.length - 1]),
                            T();
                        function T() {
                            if (x.length) {
                                const U = x.map(O => o.substring(O[0], O[1] + 1)).join(`
`);
                                t.getFontsForString(U, {
                                    lang: u || void 0,
                                    style: m,
                                    weight: v,
                                    dataUrl: y
                                }).then( ({fontUrls: O, chars: L}) => {
                                    const N = A.length;
                                    let z = 0;
                                    x.forEach(B => {
                                        for (let G = 0, X = B[1] - B[0]; G <= X; G++)
                                            S[B[0] + G] = L[z++] + N;
                                        z++
                                    }
                                    );
                                    let I = 0;
                                    O.forEach( (B, G) => {
                                        a(B, X => {
                                            A[G + N] = X,
                                            ++I === O.length && D()
                                        }
                                        )
                                    }
                                    )
                                }
                                )
                            } else
                                D()
                        }
                        function D() {
                            c({
                                chars: S,
                                fonts: A
                            })
                        }
                        function w(U, O) {
                            for (let L = 0; L < O.length; L++) {
                                const [N,z=N] = O[L];
                                if (N <= U && U <= z)
                                    return !0
                            }
                            return !1
                        }
                    }
                }
                const X9 = Em({
                    name: "FontResolver",
                    dependencies: [k9, G9, V9],
                    init(e, t, n) {
                        return e(t, n())
                    }
                });
                function W9(e, t) {
                    const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/
                      , s = "[^\\S\\u00A0]"
                      , a = new RegExp(`${s}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
                    function o({text: A, lang: M, fonts: x, style: T, weight: D, preResolvedFonts: w, unicodeFontsURL: U}, O) {
                        const L = ({chars: N, fonts: z}) => {
                            let I, B;
                            const G = [];
                            for (let X = 0; X < N.length; X++)
                                N[X] !== B ? (B = N[X],
                                G.push(I = {
                                    start: X,
                                    end: X,
                                    fontObj: z[N[X]]
                                })) : I.end = X;
                            O(G)
                        }
                        ;
                        w ? L(w) : e(A, L, {
                            lang: M,
                            fonts: x,
                            style: T,
                            weight: D,
                            unicodeFontsURL: U
                        })
                    }
                    function c({text: A="", font: M, lang: x, sdfGlyphSize: T=64, fontSize: D=400, fontWeight: w=1, fontStyle: U="normal", letterSpacing: O=0, lineHeight: L="normal", maxWidth: N=1 / 0, direction: z, textAlign: I="left", textIndent: B=0, whiteSpace: G="normal", overflowWrap: X="normal", anchorX: q=0, anchorY: Q=0, metricsOnly: oe=!1, unicodeFontsURL: k, preResolvedFonts: W=null, includeCaretPositions: V=!1, chunkedBoundsSize: Z=8192, colorRanges: j=null}, ee) {
                        const H = v()
                          , ie = {
                            fontLoad: 0,
                            typesetting: 0
                        };
                        A.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
                        A = A.replace(/\r\n/g, `
`).replace(/\r/g, `
`)),
                        D = +D,
                        O = +O,
                        N = +N,
                        L = L || "normal",
                        B = +B,
                        o({
                            text: A,
                            lang: x,
                            style: U,
                            weight: w,
                            fonts: typeof M == "string" ? [{
                                src: M
                            }] : M,
                            unicodeFontsURL: k,
                            preResolvedFonts: W
                        }, se => {
                            ie.fontLoad = v() - H;
                            const K = isFinite(N);
                            let le = null
                              , ue = null
                              , de = null
                              , qe = null
                              , ze = null
                              , Ee = null
                              , re = null
                              , Le = null
                              , he = 0
                              , ye = 0
                              , xe = G !== "nowrap";
                            const ge = new Map
                              , Te = v();
                            let Ae = B
                              , we = 0
                              , it = new y;
                            const je = [it];
                            se.forEach(Re => {
                                const {fontObj: De} = Re
                                  , {ascender: rt, descender: $e, unitsPerEm: ct, lineGap: gt, capHeight: Ie, xHeight: Je} = De;
                                let Ze = ge.get(De);
                                if (!Ze) {
                                    const ot = D / ct
                                      , tt = L === "normal" ? (rt - $e + gt) * ot : L * D
                                      , xt = (tt - (rt - $e) * ot) / 2
                                      , Qe = Math.min(tt, (rt - $e) * ot)
                                      , Ne = (rt + $e) / 2 * ot + Qe / 2;
                                    Ze = {
                                        index: ge.size,
                                        src: De.src,
                                        fontObj: De,
                                        fontSizeMult: ot,
                                        unitsPerEm: ct,
                                        ascender: rt * ot,
                                        descender: $e * ot,
                                        capHeight: Ie * ot,
                                        xHeight: Je * ot,
                                        lineHeight: tt,
                                        baseline: -xt - rt * ot,
                                        caretTop: Ne,
                                        caretBottom: Ne - Qe
                                    },
                                    ge.set(De, Ze)
                                }
                                const {fontSizeMult: ht} = Ze
                                  , lt = A.slice(Re.start, Re.end + 1);
                                let At, fe;
                                De.forEachGlyph(lt, D, O, (ot, tt, xt, Qe) => {
                                    tt += we,
                                    Qe += Re.start,
                                    At = tt,
                                    fe = ot;
                                    const Ne = A.charAt(Qe)
                                      , dt = ot.advanceWidth * ht
                                      , _t = it.count;
                                    let Ct;
                                    if ("isEmpty"in ot || (ot.isWhitespace = !!Ne && new RegExp(s).test(Ne),
                                    ot.canBreakAfter = !!Ne && a.test(Ne),
                                    ot.isEmpty = ot.xMin === ot.xMax || ot.yMin === ot.yMax || i.test(Ne)),
                                    !ot.isWhitespace && !ot.isEmpty && ye++,
                                    xe && K && !ot.isWhitespace && tt + dt + Ae > N && _t) {
                                        if (it.glyphAt(_t - 1).glyphObj.canBreakAfter)
                                            Ct = new y,
                                            Ae = -tt;
                                        else
                                            for (let Mn = _t; Mn--; )
                                                if (Mn === 0 && X === "break-word") {
                                                    Ct = new y,
                                                    Ae = -tt;
                                                    break
                                                } else if (it.glyphAt(Mn).glyphObj.canBreakAfter) {
                                                    Ct = it.splitAt(Mn + 1);
                                                    const Un = Ct.glyphAt(0).x;
                                                    Ae -= Un;
                                                    for (let On = Ct.count; On--; )
                                                        Ct.glyphAt(On).x -= Un;
                                                    break
                                                }
                                        Ct && (it.isSoftWrapped = !0,
                                        it = Ct,
                                        je.push(it),
                                        he = N)
                                    }
                                    let Ot = it.glyphAt(it.count);
                                    Ot.glyphObj = ot,
                                    Ot.x = tt + Ae,
                                    Ot.y = xt,
                                    Ot.width = dt,
                                    Ot.charIndex = Qe,
                                    Ot.fontData = Ze,
                                    Ne === `
` && (it = new y,
                                    je.push(it),
                                    Ae = -(tt + dt + O * D) + B)
                                }
                                ),
                                we = At + fe.advanceWidth * ht + O * D
                            }
                            );
                            let $ = 0;
                            je.forEach(Re => {
                                let De = !0;
                                for (let rt = Re.count; rt--; ) {
                                    const $e = Re.glyphAt(rt);
                                    De && !$e.glyphObj.isWhitespace && (Re.width = $e.x + $e.width,
                                    Re.width > he && (he = Re.width),
                                    De = !1);
                                    let {lineHeight: ct, capHeight: gt, xHeight: Ie, baseline: Je} = $e.fontData;
                                    ct > Re.lineHeight && (Re.lineHeight = ct);
                                    const Ze = Je - Re.baseline;
                                    Ze < 0 && (Re.baseline += Ze,
                                    Re.cap += Ze,
                                    Re.ex += Ze),
                                    Re.cap = Math.max(Re.cap, Re.baseline + gt),
                                    Re.ex = Math.max(Re.ex, Re.baseline + Ie)
                                }
                                Re.baseline -= $,
                                Re.cap -= $,
                                Re.ex -= $,
                                $ += Re.lineHeight
                            }
                            );
                            let Y = 0
                              , pe = 0;
                            if (q && (typeof q == "number" ? Y = -q : typeof q == "string" && (Y = -he * (q === "left" ? 0 : q === "center" ? .5 : q === "right" ? 1 : f(q)))),
                            Q && (typeof Q == "number" ? pe = -Q : typeof Q == "string" && (pe = Q === "top" ? 0 : Q === "top-baseline" ? -je[0].baseline : Q === "top-cap" ? -je[0].cap : Q === "top-ex" ? -je[0].ex : Q === "middle" ? $ / 2 : Q === "bottom" ? $ : Q === "bottom-baseline" ? -je[je.length - 1].baseline : f(Q) * $)),
                            !oe) {
                                const Re = t.getEmbeddingLevels(A, z);
                                le = new Uint16Array(ye),
                                ue = new Uint8Array(ye),
                                de = new Float32Array(ye * 2),
                                qe = {},
                                re = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                Le = [],
                                V && (Ee = new Float32Array(A.length * 4)),
                                j && (ze = new Uint8Array(ye * 3));
                                let De = 0, rt = -1, $e = -1, ct, gt;
                                if (je.forEach( (Ie, Je) => {
                                    let {count: Ze, width: ht} = Ie;
                                    if (Ze > 0) {
                                        let lt = 0;
                                        for (let Qe = Ze; Qe-- && Ie.glyphAt(Qe).glyphObj.isWhitespace; )
                                            lt++;
                                        let At = 0
                                          , fe = 0;
                                        if (I === "center")
                                            At = (he - ht) / 2;
                                        else if (I === "right")
                                            At = he - ht;
                                        else if (I === "justify" && Ie.isSoftWrapped) {
                                            let Qe = 0;
                                            for (let Ne = Ze - lt; Ne--; )
                                                Ie.glyphAt(Ne).glyphObj.isWhitespace && Qe++;
                                            fe = (he - ht) / Qe
                                        }
                                        if (fe || At) {
                                            let Qe = 0;
                                            for (let Ne = 0; Ne < Ze; Ne++) {
                                                let dt = Ie.glyphAt(Ne);
                                                const _t = dt.glyphObj;
                                                dt.x += At + Qe,
                                                fe !== 0 && _t.isWhitespace && Ne < Ze - lt && (Qe += fe,
                                                dt.width += fe)
                                            }
                                        }
                                        const ot = t.getReorderSegments(A, Re, Ie.glyphAt(0).charIndex, Ie.glyphAt(Ie.count - 1).charIndex);
                                        for (let Qe = 0; Qe < ot.length; Qe++) {
                                            const [Ne,dt] = ot[Qe];
                                            let _t = 1 / 0
                                              , Ct = -1 / 0;
                                            for (let Ot = 0; Ot < Ze; Ot++)
                                                if (Ie.glyphAt(Ot).charIndex >= Ne) {
                                                    let Mn = Ot
                                                      , Un = Ot;
                                                    for (; Un < Ze; Un++) {
                                                        let On = Ie.glyphAt(Un);
                                                        if (On.charIndex > dt)
                                                            break;
                                                        Un < Ze - lt && (_t = Math.min(_t, On.x),
                                                        Ct = Math.max(Ct, On.x + On.width))
                                                    }
                                                    for (let On = Mn; On < Un; On++) {
                                                        const ki = Ie.glyphAt(On);
                                                        ki.x = Ct - (ki.x + ki.width - _t)
                                                    }
                                                    break
                                                }
                                        }
                                        let tt;
                                        const xt = Qe => tt = Qe;
                                        for (let Qe = 0; Qe < Ze; Qe++) {
                                            const Ne = Ie.glyphAt(Qe);
                                            tt = Ne.glyphObj;
                                            const dt = tt.index
                                              , _t = Re.levels[Ne.charIndex] & 1;
                                            if (_t) {
                                                const Ct = t.getMirroredCharacter(A[Ne.charIndex]);
                                                Ct && Ne.fontData.fontObj.forEachGlyph(Ct, 0, 0, xt)
                                            }
                                            if (V) {
                                                const {charIndex: Ct, fontData: Ot} = Ne
                                                  , Mn = Ne.x + Y
                                                  , Un = Ne.x + Ne.width + Y;
                                                Ee[Ct * 4] = _t ? Un : Mn,
                                                Ee[Ct * 4 + 1] = _t ? Mn : Un,
                                                Ee[Ct * 4 + 2] = Ie.baseline + Ot.caretBottom + pe,
                                                Ee[Ct * 4 + 3] = Ie.baseline + Ot.caretTop + pe;
                                                const On = Ct - rt;
                                                On > 1 && m(Ee, rt, On),
                                                rt = Ct
                                            }
                                            if (j) {
                                                const {charIndex: Ct} = Ne;
                                                for (; Ct > $e; )
                                                    $e++,
                                                    j.hasOwnProperty($e) && (gt = j[$e])
                                            }
                                            if (!tt.isWhitespace && !tt.isEmpty) {
                                                const Ct = De++
                                                  , {fontSizeMult: Ot, src: Mn, index: Un} = Ne.fontData
                                                  , On = qe[Mn] || (qe[Mn] = {});
                                                On[dt] || (On[dt] = {
                                                    path: tt.path,
                                                    pathBounds: [tt.xMin, tt.yMin, tt.xMax, tt.yMax]
                                                });
                                                const ki = Ne.x + Y
                                                  , Bs = Ne.y + Ie.baseline + pe;
                                                de[Ct * 2] = ki,
                                                de[Ct * 2 + 1] = Bs;
                                                const Ls = ki + tt.xMin * Ot
                                                  , Ai = Bs + tt.yMin * Ot
                                                  , _s = ki + tt.xMax * Ot
                                                  , ei = Bs + tt.yMax * Ot;
                                                Ls < re[0] && (re[0] = Ls),
                                                Ai < re[1] && (re[1] = Ai),
                                                _s > re[2] && (re[2] = _s),
                                                ei > re[3] && (re[3] = ei),
                                                Ct % Z === 0 && (ct = {
                                                    start: Ct,
                                                    end: Ct,
                                                    rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                                },
                                                Le.push(ct)),
                                                ct.end++;
                                                const ti = ct.rect;
                                                if (Ls < ti[0] && (ti[0] = Ls),
                                                Ai < ti[1] && (ti[1] = Ai),
                                                _s > ti[2] && (ti[2] = _s),
                                                ei > ti[3] && (ti[3] = ei),
                                                le[Ct] = dt,
                                                ue[Ct] = Un,
                                                j) {
                                                    const Oi = Ct * 3;
                                                    ze[Oi] = gt >> 16 & 255,
                                                    ze[Oi + 1] = gt >> 8 & 255,
                                                    ze[Oi + 2] = gt & 255
                                                }
                                            }
                                        }
                                    }
                                }
                                ),
                                Ee) {
                                    const Ie = A.length - rt;
                                    Ie > 1 && m(Ee, rt, Ie)
                                }
                            }
                            const He = [];
                            ge.forEach( ({index: Re, src: De, unitsPerEm: rt, ascender: $e, descender: ct, lineHeight: gt, capHeight: Ie, xHeight: Je}) => {
                                He[Re] = {
                                    src: De,
                                    unitsPerEm: rt,
                                    ascender: $e,
                                    descender: ct,
                                    lineHeight: gt,
                                    capHeight: Ie,
                                    xHeight: Je
                                }
                            }
                            ),
                            ie.typesetting = v() - Te,
                            ee({
                                glyphIds: le,
                                glyphFontIndices: ue,
                                glyphPositions: de,
                                glyphData: qe,
                                fontData: He,
                                caretPositions: Ee,
                                glyphColors: ze,
                                chunkedBounds: Le,
                                fontSize: D,
                                topBaseline: pe + je[0].baseline,
                                blockBounds: [Y, pe - $, Y + he, pe],
                                visibleBounds: re,
                                timings: ie
                            })
                        }
                        )
                    }
                    function u(A, M) {
                        c({
                            ...A,
                            metricsOnly: !0
                        }, x => {
                            const [T,D,w,U] = x.blockBounds;
                            M({
                                width: w - T,
                                height: U - D
                            })
                        }
                        )
                    }
                    function f(A) {
                        let M = A.match(/^([\d.]+)%$/)
                          , x = M ? parseFloat(M[1]) : NaN;
                        return isNaN(x) ? 0 : x / 100
                    }
                    function m(A, M, x) {
                        const T = A[M * 4]
                          , D = A[M * 4 + 1]
                          , w = A[M * 4 + 2]
                          , U = A[M * 4 + 3]
                          , O = (D - T) / x;
                        for (let L = 0; L < x; L++) {
                            const N = (M + L) * 4;
                            A[N] = T + O * L,
                            A[N + 1] = T + O * (L + 1),
                            A[N + 2] = w,
                            A[N + 3] = U
                        }
                    }
                    function v() {
                        return (self.performance || Date).now()
                    }
                    function y() {
                        this.data = []
                    }
                    const S = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
                    return y.prototype = {
                        width: 0,
                        lineHeight: 0,
                        baseline: 0,
                        cap: 0,
                        ex: 0,
                        isSoftWrapped: !1,
                        get count() {
                            return Math.ceil(this.data.length / S.length)
                        },
                        glyphAt(A) {
                            let M = y.flyweight;
                            return M.data = this.data,
                            M.index = A,
                            M
                        },
                        splitAt(A) {
                            let M = new y;
                            return M.data = this.data.splice(A * S.length),
                            M
                        }
                    },
                    y.flyweight = S.reduce( (A, M, x, T) => (Object.defineProperty(A, M, {
                        get() {
                            return this.data[this.index * S.length + x]
                        },
                        set(D) {
                            this.data[this.index * S.length + x] = D
                        }
                    }),
                    A), {
                        data: null,
                        index: 0
                    }),
                    {
                        typeset: c,
                        measure: u
                    }
                }
                const cd = () => (self.performance || Date).now()
                  , yx = P3();
                let k3;
                function Y9(e, t, n, i, s, a, o, c, u, f, m=!0) {
                    return m ? j9(e, t, n, i, s, a, o, c, u, f).then(null, v => (k3 || (console.warn("WebGL SDF generation failed, falling back to JS", v),
                    k3 = !0),
                    Y3(e, t, n, i, s, a, o, c, u, f))) : Y3(e, t, n, i, s, a, o, c, u, f)
                }
                const _x = []
                  , q9 = 5;
                let bb = 0;
                function X3() {
                    const e = cd();
                    for (; _x.length && cd() - e < q9; )
                        _x.shift()();
                    bb = _x.length ? setTimeout(X3, 0) : 0
                }
                const j9 = (...e) => new Promise( (t, n) => {
                    _x.push( () => {
                        const i = cd();
                        try {
                            yx.webgl.generateIntoCanvas(...e),
                            t({
                                timing: cd() - i
                            })
                        } catch (s) {
                            n(s)
                        }
                    }
                    ),
                    bb || (bb = setTimeout(X3, 0))
                }
                )
                  , Q9 = 4
                  , Z9 = 2e3
                  , W3 = {};
                let K9 = 0;
                function Y3(e, t, n, i, s, a, o, c, u, f) {
                    const m = "TroikaTextSDFGenerator_JS_" + K9++ % Q9;
                    let v = W3[m];
                    return v || (v = W3[m] = {
                        workerModule: Em({
                            name: m,
                            workerId: m,
                            dependencies: [P3, cd],
                            init(y, S) {
                                const A = y().javascript.generate;
                                return function(...M) {
                                    const x = S();
                                    return {
                                        textureData: A(...M),
                                        timing: S() - x
                                    }
                                }
                            },
                            getTransferables(y) {
                                return [y.textureData.buffer]
                            }
                        }),
                        requests: 0,
                        idleTimer: null
                    }),
                    v.requests++,
                    clearTimeout(v.idleTimer),
                    v.workerModule(e, t, n, i, s, a).then( ({textureData: y, timing: S}) => {
                        const A = cd()
                          , M = new Uint8Array(y.length * 4);
                        for (let x = 0; x < y.length; x++)
                            M[x * 4 + f] = y[x];
                        return yx.webglUtils.renderImageData(o, M, c, u, e, t, 1 << 3 - f),
                        S += cd() - A,
                        --v.requests === 0 && (v.idleTimer = setTimeout( () => {
                            C9(m)
                        }
                        , Z9)),
                        {
                            timing: S
                        }
                    }
                    )
                }
                function J9(e) {
                    e._warm || (yx.webgl.isSupported(e),
                    e._warm = !0)
                }
                const $9 = yx.webglUtils.resizeWebGLCanvasWithoutClearing
                  , ud = {
                    defaultFontURL: null,
                    unicodeFontsURL: null,
                    sdfGlyphSize: 64,
                    sdfMargin: 1 / 16,
                    sdfExponent: 9,
                    textureWidth: 2048,
                    useWorker: !0
                }
                  , eX = new ft;
                let tX = !1;
                function Cm() {
                    return (self.performance || Date).now()
                }
                const q3 = Object.create(null);
                function nX(e, t) {
                    tX = !0,
                    e = sX({}, e);
                    const n = Cm()
                      , {defaultFontURL: i} = ud
                      , s = [];
                    if (i && s.push({
                        label: "default",
                        src: Q3(i)
                    }),
                    e.font && s.push({
                        label: "user",
                        src: Q3(e.font)
                    }),
                    e.font = s,
                    e.text = "" + e.text,
                    e.sdfGlyphSize = e.sdfGlyphSize || ud.sdfGlyphSize,
                    e.unicodeFontsURL = e.unicodeFontsURL || ud.unicodeFontsURL,
                    e.colorRanges != null) {
                        let y = {};
                        for (let S in e.colorRanges)
                            if (e.colorRanges.hasOwnProperty(S)) {
                                let A = e.colorRanges[S];
                                typeof A != "number" && (A = eX.set(A).getHex()),
                                y[S] = A
                            }
                        e.colorRanges = y
                    }
                    Object.freeze(e);
                    const {textureWidth: a, sdfExponent: o} = ud
                      , {sdfGlyphSize: c} = e
                      , u = a / c * 4;
                    let f = q3[c];
                    if (!f) {
                        const y = document.createElement("canvas");
                        y.width = a,
                        y.height = c * 256 / u,
                        f = q3[c] = {
                            glyphCount: 0,
                            sdfGlyphSize: c,
                            sdfCanvas: y,
                            sdfTexture: new Fi(y,void 0,void 0,void 0,mi,mi),
                            contextLost: !1,
                            glyphsByFont: new Map
                        },
                        f.sdfTexture.generateMipmaps = !1,
                        iX(f)
                    }
                    const {sdfTexture: m, sdfCanvas: v} = f;
                    (ud.useWorker ? K3 : rX)(e).then(y => {
                        const {glyphIds: S, glyphFontIndices: A, fontData: M, glyphPositions: x, fontSize: T, timings: D} = y
                          , w = []
                          , U = new Float32Array(S.length * 4);
                        let O = 0
                          , L = 0;
                        const N = Cm()
                          , z = M.map(q => {
                            let Q = f.glyphsByFont.get(q.src);
                            return Q || f.glyphsByFont.set(q.src, Q = new Map),
                            Q
                        }
                        );
                        S.forEach( (q, Q) => {
                            const oe = A[Q]
                              , {src: k, unitsPerEm: W} = M[oe];
                            let V = z[oe].get(q);
                            if (!V) {
                                const {path: ie, pathBounds: se} = y.glyphData[k][q]
                                  , K = Math.max(se[2] - se[0], se[3] - se[1]) / c * (ud.sdfMargin * c + .5)
                                  , le = f.glyphCount++
                                  , ue = [se[0] - K, se[1] - K, se[2] + K, se[3] + K];
                                z[oe].set(q, V = {
                                    path: ie,
                                    atlasIndex: le,
                                    sdfViewBox: ue
                                }),
                                w.push(V)
                            }
                            const {sdfViewBox: Z} = V
                              , j = x[L++]
                              , ee = x[L++]
                              , H = T / W;
                            U[O++] = j + Z[0] * H,
                            U[O++] = ee + Z[1] * H,
                            U[O++] = j + Z[2] * H,
                            U[O++] = ee + Z[3] * H,
                            S[Q] = V.atlasIndex
                        }
                        ),
                        D.quads = (D.quads || 0) + (Cm() - N);
                        const I = Cm();
                        D.sdf = {};
                        const B = v.height
                          , G = Math.ceil(f.glyphCount / u)
                          , X = Math.pow(2, Math.ceil(Math.log2(G * c)));
                        X > B && (console.info(`Increasing SDF texture size ${B}->${X}`),
                        $9(v, a, X),
                        m.dispose()),
                        Promise.all(w.map(q => j3(q, f, e.gpuAccelerateSDF).then( ({timing: Q}) => {
                            D.sdf[q.atlasIndex] = Q
                        }
                        ))).then( () => {
                            w.length && !f.contextLost && (Z3(f),
                            m.needsUpdate = !0),
                            D.sdfTotal = Cm() - I,
                            D.total = Cm() - n,
                            t(Object.freeze({
                                parameters: e,
                                sdfTexture: m,
                                sdfGlyphSize: c,
                                sdfExponent: o,
                                glyphBounds: U,
                                glyphAtlasIndices: S,
                                glyphColors: y.glyphColors,
                                caretPositions: y.caretPositions,
                                chunkedBounds: y.chunkedBounds,
                                ascender: y.ascender,
                                descender: y.descender,
                                lineHeight: y.lineHeight,
                                capHeight: y.capHeight,
                                xHeight: y.xHeight,
                                topBaseline: y.topBaseline,
                                blockBounds: y.blockBounds,
                                visibleBounds: y.visibleBounds,
                                timings: y.timings
                            }))
                        }
                        )
                    }
                    ),
                    Promise.resolve().then( () => {
                        f.contextLost || J9(v)
                    }
                    )
                }
                function j3({path: e, atlasIndex: t, sdfViewBox: n}, {sdfGlyphSize: i, sdfCanvas: s, contextLost: a}, o) {
                    if (a)
                        return Promise.resolve({
                            timing: -1
                        });
                    const {textureWidth: c, sdfExponent: u} = ud
                      , f = Math.max(n[2] - n[0], n[3] - n[1])
                      , m = Math.floor(t / 4)
                      , v = m % (c / i) * i
                      , y = Math.floor(m / (c / i)) * i
                      , S = t % 4;
                    return Y9(i, i, e, n, f, u, s, v, y, S, o)
                }
                function iX(e) {
                    const t = e.sdfCanvas;
                    t.addEventListener("webglcontextlost", n => {
                        console.log("Context Lost", n),
                        n.preventDefault(),
                        e.contextLost = !0
                    }
                    ),
                    t.addEventListener("webglcontextrestored", n => {
                        console.log("Context Restored", n),
                        e.contextLost = !1;
                        const i = [];
                        e.glyphsByFont.forEach(s => {
                            s.forEach(a => {
                                i.push(j3(a, e, !0))
                            }
                            )
                        }
                        ),
                        Promise.all(i).then( () => {
                            Z3(e),
                            e.sdfTexture.needsUpdate = !0
                        }
                        )
                    }
                    )
                }
                function sX(e, t) {
                    for (let n in t)
                        t.hasOwnProperty(n) && (e[n] = t[n]);
                    return e
                }
                let Sx;
                function Q3(e) {
                    return Sx || (Sx = typeof document > "u" ? {} : document.createElement("a")),
                    Sx.href = e,
                    Sx.href
                }
                function Z3(e) {
                    if (typeof createImageBitmap != "function") {
                        console.info("Safari<15: applying SDF canvas workaround");
                        const {sdfCanvas: t, sdfTexture: n} = e
                          , {width: i, height: s} = t
                          , a = e.sdfCanvas.getContext("webgl");
                        let o = n.image.data;
                        (!o || o.length !== i * s * 4) && (o = new Uint8Array(i * s * 4),
                        n.image = {
                            width: i,
                            height: s,
                            data: o
                        },
                        n.flipY = !1,
                        n.isDataTexture = !0),
                        a.readPixels(0, 0, i, s, a.RGBA, a.UNSIGNED_BYTE, o)
                    }
                }
                const aX = Em({
                    name: "Typesetter",
                    dependencies: [W9, X9, R9],
                    init(e, t, n) {
                        return e(t, n())
                    }
                })
                  , K3 = Em({
                    name: "Typesetter",
                    dependencies: [aX],
                    init(e) {
                        return function(t) {
                            return new Promise(n => {
                                e.typeset(t, n)
                            }
                            )
                        }
                    },
                    getTransferables(e) {
                        const t = [];
                        for (let n in e)
                            e[n] && e[n].buffer && t.push(e[n].buffer);
                        return t
                    }
                })
                  , rX = K3.onMainThread
                  , J3 = {};
                function oX(e) {
                    let t = J3[e];
                    return t || (t = J3[e] = new wf(1,1,e,e).translate(.5, .5, 0)),
                    t
                }
                const lX = "aTroikaGlyphBounds"
                  , $3 = "aTroikaGlyphIndex"
                  , cX = "aTroikaGlyphColor";
                var uX = class extends IT {
                    constructor() {
                        super(),
                        this.detail = 1,
                        this.curveRadius = 0,
                        this.groups = [{
                            start: 0,
                            count: 1 / 0,
                            materialIndex: 0
                        }, {
                            start: 0,
                            count: 1 / 0,
                            materialIndex: 1
                        }],
                        this.boundingSphere = new Ys,
                        this.boundingBox = new Ws
                    }
                    computeBoundingSphere() {}
                    computeBoundingBox() {}
                    set detail(e) {
                        if (e !== this._detail) {
                            this._detail = e,
                            (typeof e != "number" || e < 1) && (e = 1);
                            let t = oX(e);
                            ["position", "normal", "uv"].forEach(n => {
                                this.attributes[n] = t.attributes[n].clone()
                            }
                            ),
                            this.setIndex(t.getIndex().clone())
                        }
                    }
                    get detail() {
                        return this._detail
                    }
                    set curveRadius(e) {
                        e !== this._curveRadius && (this._curveRadius = e,
                        this._updateBounds())
                    }
                    get curveRadius() {
                        return this._curveRadius
                    }
                    updateGlyphs(e, t, n, i, s) {
                        this.updateAttributeData(lX, e, 4),
                        this.updateAttributeData($3, t, 1),
                        this.updateAttributeData(cX, s, 3),
                        this._blockBounds = n,
                        this._chunkedBounds = i,
                        this.instanceCount = t.length,
                        this._updateBounds()
                    }
                    _updateBounds() {
                        const e = this._blockBounds;
                        if (e) {
                            const {curveRadius: t, boundingBox: n} = this;
                            if (t) {
                                const {PI: i, floor: s, min: a, max: o, sin: c, cos: u} = Math
                                  , f = i / 2
                                  , m = i * 2
                                  , v = Math.abs(t)
                                  , y = e[0] / v
                                  , S = e[2] / v
                                  , A = s((y + f) / m) !== s((S + f) / m) ? -v : a(c(y) * v, c(S) * v)
                                  , M = s((y - f) / m) !== s((S - f) / m) ? v : o(c(y) * v, c(S) * v)
                                  , x = s((y + i) / m) !== s((S + i) / m) ? v * 2 : o(v - u(y) * v, v - u(S) * v);
                                n.min.set(A, e[1], t < 0 ? -x : 0),
                                n.max.set(M, e[3], t < 0 ? 0 : x)
                            } else
                                n.min.set(e[0], e[1], 0),
                                n.max.set(e[2], e[3], 0);
                            n.getBoundingSphere(this.boundingSphere)
                        }
                    }
                    applyClipRect(e) {
                        let t = this.getAttribute($3).count
                          , n = this._chunkedBounds;
                        if (n)
                            for (let i = n.length; i--; ) {
                                t = n[i].end;
                                let s = n[i].rect;
                                if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x)
                                    break
                            }
                        this.instanceCount = t
                    }
                    updateAttributeData(e, t, n) {
                        const i = this.getAttribute(e);
                        t ? i && i.array.length === t.length ? (i.array.set(t),
                        i.needsUpdate = !0) : (this.setAttribute(e, new Af(t,n)),
                        delete this._maxInstanceCount,
                        this.dispose()) : i && this.deleteAttribute(e)
                    }
                }
                ;
                const hX = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`
                  , fX = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`
                  , dX = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`
                  , pX = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
                function mX(e) {
                    const t = Mb(e, {
                        chained: !0,
                        extensions: {
                            derivatives: !0
                        },
                        uniforms: {
                            uTroikaSDFTexture: {
                                value: null
                            },
                            uTroikaSDFTextureSize: {
                                value: new Oe
                            },
                            uTroikaSDFGlyphSize: {
                                value: 0
                            },
                            uTroikaSDFExponent: {
                                value: 0
                            },
                            uTroikaTotalBounds: {
                                value: new hn(0,0,0,0)
                            },
                            uTroikaClipRect: {
                                value: new hn(0,0,0,0)
                            },
                            uTroikaEdgeOffset: {
                                value: 0
                            },
                            uTroikaFillOpacity: {
                                value: 1
                            },
                            uTroikaPositionOffset: {
                                value: new Oe
                            },
                            uTroikaCurveRadius: {
                                value: 0
                            },
                            uTroikaBlurRadius: {
                                value: 0
                            },
                            uTroikaStrokeWidth: {
                                value: 0
                            },
                            uTroikaStrokeColor: {
                                value: new ft
                            },
                            uTroikaStrokeOpacity: {
                                value: 1
                            },
                            uTroikaOrient: {
                                value: new nn
                            },
                            uTroikaUseGlyphColors: {
                                value: !0
                            },
                            uTroikaSDFDebug: {
                                value: !1
                            }
                        },
                        vertexDefs: hX,
                        vertexTransform: fX,
                        fragmentDefs: dX,
                        fragmentColorTransform: pX,
                        customRewriter({vertexShader: n, fragmentShader: i}) {
                            let s = /\buniform\s+vec3\s+diffuse\b/;
                            return s.test(i) && (i = i.replace(s, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"),
                            s.test(n) || (n = n.replace(z3, `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))),
                            {
                                vertexShader: n,
                                fragmentShader: i
                            }
                        }
                    });
                    return t.transparent = !0,
                    t.forceSinglePass = !0,
                    Object.defineProperties(t, {
                        isTroikaTextMaterial: {
                            value: !0
                        },
                        shadowSide: {
                            get() {
                                return this.side
                            },
                            set() {}
                        }
                    }),
                    t
                }
                const Eb = new nu({
                    color: 16777215,
                    side: $a,
                    transparent: !0
                })
                  , eU = 8421504
                  , tU = new Xt
                  , xx = new ae
                  , Cb = new ae
                  , S0 = []
                  , vX = new ae
                  , wb = "+x+y";
                function nU(e) {
                    return Array.isArray(e) ? e[0] : e
                }
                let iU = () => {
                    const e = new oi(new wf(1,1),Eb);
                    return iU = () => e,
                    e
                }
                  , sU = () => {
                    const e = new oi(new wf(1,1,32,1),Eb);
                    return sU = () => e,
                    e
                }
                ;
                const gX = {
                    type: "syncstart"
                }
                  , yX = {
                    type: "synccomplete"
                }
                  , aU = ["font", "fontSize", "fontStyle", "fontWeight", "lang", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"]
                  , _X = aU.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
                var Db = class extends oi {
                    constructor() {
                        const e = new uX;
                        super(e, null),
                        this.text = "",
                        this.anchorX = 0,
                        this.anchorY = 0,
                        this.curveRadius = 0,
                        this.direction = "auto",
                        this.font = null,
                        this.unicodeFontsURL = null,
                        this.fontSize = .1,
                        this.fontWeight = "normal",
                        this.fontStyle = "normal",
                        this.lang = null,
                        this.letterSpacing = 0,
                        this.lineHeight = "normal",
                        this.maxWidth = 1 / 0,
                        this.overflowWrap = "normal",
                        this.textAlign = "left",
                        this.textIndent = 0,
                        this.whiteSpace = "normal",
                        this.material = null,
                        this.color = null,
                        this.colorRanges = null,
                        this.outlineWidth = 0,
                        this.outlineColor = 0,
                        this.outlineOpacity = 1,
                        this.outlineBlur = 0,
                        this.outlineOffsetX = 0,
                        this.outlineOffsetY = 0,
                        this.strokeWidth = 0,
                        this.strokeColor = eU,
                        this.strokeOpacity = 1,
                        this.fillOpacity = 1,
                        this.depthOffset = 0,
                        this.clipRect = null,
                        this.orientation = wb,
                        this.glyphGeometryDetail = 1,
                        this.sdfGlyphSize = null,
                        this.gpuAccelerateSDF = !0,
                        this.debugSDF = !1
                    }
                    sync(e) {
                        this._needsSync && (this._needsSync = !1,
                        this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0,
                        this.dispatchEvent(gX),
                        nX({
                            text: this.text,
                            font: this.font,
                            lang: this.lang,
                            fontSize: this.fontSize || .1,
                            fontWeight: this.fontWeight || "normal",
                            fontStyle: this.fontStyle || "normal",
                            letterSpacing: this.letterSpacing || 0,
                            lineHeight: this.lineHeight || "normal",
                            maxWidth: this.maxWidth,
                            direction: this.direction || "auto",
                            textAlign: this.textAlign,
                            textIndent: this.textIndent,
                            whiteSpace: this.whiteSpace,
                            overflowWrap: this.overflowWrap,
                            anchorX: this.anchorX,
                            anchorY: this.anchorY,
                            colorRanges: this.colorRanges,
                            includeCaretPositions: !0,
                            sdfGlyphSize: this.sdfGlyphSize,
                            gpuAccelerateSDF: this.gpuAccelerateSDF,
                            unicodeFontsURL: this.unicodeFontsURL
                        }, t => {
                            this._isSyncing = !1,
                            this._textRenderInfo = t,
                            this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors);
                            const n = this._queuedSyncs;
                            n && (this._queuedSyncs = null,
                            this._needsSync = !0,
                            this.sync( () => {
                                n.forEach(i => i && i())
                            }
                            )),
                            this.dispatchEvent(yX),
                            e && e()
                        }
                        )))
                    }
                    onBeforeRender(e, t, n, i, s, a) {
                        this.sync(),
                        s.isTroikaTextMaterial && this._prepareForRender(s)
                    }
                    dispose() {
                        this.geometry.dispose()
                    }
                    get textRenderInfo() {
                        return this._textRenderInfo || null
                    }
                    createDerivedMaterial(e) {
                        return mX(e)
                    }
                    get material() {
                        let e = this._derivedMaterial;
                        const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Eb.clone());
                        if ((!e || !e.isDerivedFrom(t)) && (e = this._derivedMaterial = this.createDerivedMaterial(t),
                        t.addEventListener("dispose", function n() {
                            t.removeEventListener("dispose", n),
                            e.dispose()
                        })),
                        this.hasOutline()) {
                            let n = e._outlineMtl;
                            return n || (n = e._outlineMtl = Object.create(e, {
                                id: {
                                    value: e.id + .1
                                }
                            }),
                            n.isTextOutlineMaterial = !0,
                            n.depthWrite = !1,
                            n.map = null,
                            e.addEventListener("dispose", function i() {
                                e.removeEventListener("dispose", i),
                                n.dispose()
                            })),
                            [n, e]
                        } else
                            return e
                    }
                    set material(e) {
                        e && e.isTroikaTextMaterial ? (this._derivedMaterial = e,
                        this._baseMaterial = e.baseMaterial) : this._baseMaterial = e
                    }
                    hasOutline() {
                        return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY)
                    }
                    get glyphGeometryDetail() {
                        return this.geometry.detail
                    }
                    set glyphGeometryDetail(e) {
                        this.geometry.detail = e
                    }
                    get curveRadius() {
                        return this.geometry.curveRadius
                    }
                    set curveRadius(e) {
                        this.geometry.curveRadius = e
                    }
                    get customDepthMaterial() {
                        return nU(this.material).getDepthMaterial()
                    }
                    set customDepthMaterial(e) {}
                    get customDistanceMaterial() {
                        return nU(this.material).getDistanceMaterial()
                    }
                    set customDistanceMaterial(e) {}
                    _prepareForRender(e) {
                        const t = e.isTextOutlineMaterial
                          , n = e.uniforms
                          , i = this.textRenderInfo;
                        if (i) {
                            const {sdfTexture: o, blockBounds: c} = i;
                            n.uTroikaSDFTexture.value = o,
                            n.uTroikaSDFTextureSize.value.set(o.image.width, o.image.height),
                            n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize,
                            n.uTroikaSDFExponent.value = i.sdfExponent,
                            n.uTroikaTotalBounds.value.fromArray(c),
                            n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
                            let u = 0, f = 0, m = 0, v, y, S, A = 0, M = 0;
                            if (t) {
                                let {outlineWidth: T, outlineOffsetX: D, outlineOffsetY: w, outlineBlur: U, outlineOpacity: O} = this;
                                u = this._parsePercent(T) || 0,
                                f = Math.max(0, this._parsePercent(U) || 0),
                                v = O,
                                A = this._parsePercent(D) || 0,
                                M = this._parsePercent(w) || 0
                            } else
                                m = Math.max(0, this._parsePercent(this.strokeWidth) || 0),
                                m && (S = this.strokeColor,
                                n.uTroikaStrokeColor.value.set(S ?? eU),
                                y = this.strokeOpacity,
                                y == null && (y = 1)),
                                v = this.fillOpacity;
                            n.uTroikaEdgeOffset.value = u,
                            n.uTroikaPositionOffset.value.set(A, M),
                            n.uTroikaBlurRadius.value = f,
                            n.uTroikaStrokeWidth.value = m,
                            n.uTroikaStrokeOpacity.value = y,
                            n.uTroikaFillOpacity.value = v ?? 1,
                            n.uTroikaCurveRadius.value = this.curveRadius || 0;
                            let x = this.clipRect;
                            if (x && Array.isArray(x) && x.length === 4)
                                n.uTroikaClipRect.value.fromArray(x);
                            else {
                                const T = (this.fontSize || .1) * 100;
                                n.uTroikaClipRect.value.set(c[0] - T, c[1] - T, c[2] + T, c[3] + T)
                            }
                            this.geometry.applyClipRect(n.uTroikaClipRect.value)
                        }
                        n.uTroikaSDFDebug.value = !!this.debugSDF,
                        e.polygonOffset = !!this.depthOffset,
                        e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
                        const s = t ? this.outlineColor || 0 : this.color;
                        if (s == null)
                            delete e.color;
                        else {
                            const o = e.hasOwnProperty("color") ? e.color : e.color = new ft;
                            (s !== o._input || typeof s == "object") && o.set(o._input = s)
                        }
                        let a = this.orientation || wb;
                        if (a !== e._orientation) {
                            let o = n.uTroikaOrient.value;
                            a = a.replace(/[^-+xyz]/g, "");
                            let c = a !== wb && a.match(/^([-+])([xyz])([-+])([xyz])$/);
                            if (c) {
                                let[,u,f,m,v] = c;
                                xx.set(0, 0, 0)[f] = u === "-" ? 1 : -1,
                                Cb.set(0, 0, 0)[v] = m === "-" ? -1 : 1,
                                tU.lookAt(vX, xx.cross(Cb), Cb),
                                o.setFromMatrix4(tU)
                            } else
                                o.identity();
                            e._orientation = a
                        }
                    }
                    _parsePercent(e) {
                        if (typeof e == "string") {
                            let t = e.match(/^(-?[\d.]+)%$/)
                              , n = t ? parseFloat(t[1]) : NaN;
                            e = (isNaN(n) ? 0 : n / 100) * this.fontSize
                        }
                        return e
                    }
                    localPositionToTextCoords(e, t=new Oe) {
                        t.copy(e);
                        const n = this.curveRadius;
                        return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)),
                        t
                    }
                    worldPositionToTextCoords(e, t=new Oe) {
                        return xx.copy(e),
                        this.localPositionToTextCoords(this.worldToLocal(xx), t)
                    }
                    raycast(e, t) {
                        const {textRenderInfo: n, curveRadius: i} = this;
                        if (n) {
                            const s = n.blockBounds
                              , a = i ? sU() : iU()
                              , o = a.geometry
                              , {position: c, uv: u} = o.attributes;
                            for (let f = 0; f < u.count; f++) {
                                let m = s[0] + u.getX(f) * (s[2] - s[0]);
                                const v = s[1] + u.getY(f) * (s[3] - s[1]);
                                let y = 0;
                                i && (y = i - Math.cos(m / i) * i,
                                m = Math.sin(m / i) * i),
                                c.setXYZ(f, m, v, y)
                            }
                            o.boundingSphere = this.geometry.boundingSphere,
                            o.boundingBox = this.geometry.boundingBox,
                            a.matrixWorld = this.matrixWorld,
                            a.material.side = this.material.side,
                            S0.length = 0,
                            a.raycast(e, S0);
                            for (let f = 0; f < S0.length; f++)
                                S0[f].object = this,
                                t.push(S0[f])
                        }
                    }
                    copy(e) {
                        const t = this.geometry;
                        return super.copy(e),
                        this.geometry = t,
                        _X.forEach(n => {
                            this[n] = e[n]
                        }
                        ),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                aU.forEach(e => {
                    const t = "_private_" + e;
                    Object.defineProperty(Db.prototype, e, {
                        get() {
                            return this[t]
                        },
                        set(n) {
                            n !== this[t] && (this[t] = n,
                            this._needsSync = !0)
                        }
                    })
                }
                );
                const cY = new Ws
                  , uY = new ft
                  , SX = "https://content.gizmo.party/cabf3a19-fe65-4c9f-9665-3b6d922f4da2.wav";
                hM({
                    Text: Db
                });
                const gc = Ly.gizmoRuntime.tweaks({
                    bgColor1: {
                        index: 0,
                        name: "Sky Top",
                        type: "color",
                        value: "#000000"
                    },
                    bgColor2: {
                        index: 1,
                        name: "Sky Bottom",
                        type: "color",
                        value: "#311021"
                    },
                    sunColor1: {
                        index: 2,
                        name: "Sun Top",
                        type: "color",
                        value: "#A8C40D"
                    },
                    sunColor2: {
                        index: 3,
                        name: "Sun Bottom",
                        type: "color",
                        value: "#FF4E4E"
                    },
                    roadColor: {
                        index: 4,
                        name: "Road Color",
                        type: "color",
                        value: "#080808"
                    },
                    lineColor: {
                        index: 5,
                        name: "Grid Line Color",
                        type: "color",
                        value: "#F646A6"
                    },
                    cityColor: {
                        index: 6,
                        name: "City Color",
                        type: "color",
                        value: "#000000"
                    },
                    carColor: {
                        index: 7,
                        name: "Car Color",
                        type: "color",
                        value: "#009DE4"
                    },
                    bloomStrength: {
                        index: 8,
                        name: "Bloom",
                        type: "slider",
                        value: 1.5,
                        min: 0,
                        max: 5,
                        step: .1
                    },
                    swayIntensity: {
                        index: 9,
                        name: "Sway",
                        type: "slider",
                        value: .02,
                        min: 0,
                        max: .1,
                        step: .005
                    }
                })
                  , xX = ({color: e, lineColor: t, sunColor1: n, sunColor2: i}) => {
                    const s = (0,
                    We.useRef)(null);
                    kf( ({clock: o}) => {
                        s.current && (s.current.uniforms.time.value = o.getElapsedTime())
                    }
                    );
                    const a = (0,
                    We.useMemo)( () => new kn({
                        uniforms: {
                            time: {
                                value: 0
                            },
                            roadColor: {
                                value: new ft(e)
                            },
                            lineColor: {
                                value: new ft(t)
                            },
                            sunColor1: {
                                value: new ft(n)
                            },
                            sunColor2: {
                                value: new ft(i)
                            }
                        },
                        vertexShader: `
      varying vec2 vUv;
      varying vec3 vWorldPosition;
      void main() {
        vUv = uv;
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
                        fragmentShader: `
      uniform float time;
      uniform vec3 roadColor;
      uniform vec3 lineColor;
      uniform vec3 sunColor1;
      uniform vec3 sunColor2;
      varying vec2 vUv;
      varying vec3 vWorldPosition;

      void main() {
        float speed = -time * 0.5;
        vec2 uv = vUv;
        uv.y = fract(uv.y * 10.0 + speed);

        float verticalLines = step(0.95, uv.y);
        float horizontalLines = step(0.95, fract(vUv.x * 10.0));

        float grid = 1.0 - max(verticalLines, horizontalLines);

        vec3 baseColor = mix(lineColor, roadColor, grid);
        
        // --- Reflection Simulation (Wet Surface) ---
        // 1. Calculate reflection intensity (Fresnel approximation)
        // Road is at Y=0. Z distance is a proxy for grazing angle (horizon)
        float zDist = clamp(abs(vWorldPosition.z) / 100.0, 0.0, 1.0);
        float fresnel = pow(zDist, 3.0); 
        
        // 2. Simulate reflection of the sun/sky gradient
        // Mix sun colors based on Z distance (simulating vertical position in reflection)
        vec3 sunReflection = mix(sunColor2, sunColor1, zDist);
        
        // 3. Mix base color with reflection
        // Use a high mix factor for the road surface (where grid is 1.0)
        float reflectionMix = fresnel * 0.8;
        vec3 finalColor = mix(baseColor, sunReflection, reflectionMix);
        
        // 4. Ensure grid lines are still visible and bright
        // Re-apply line color on top of the reflection
        vec3 reflectedGrid = mix(finalColor, lineColor, 1.0 - grid);
        
        gl_FragColor = vec4(reflectedGrid, 1.0);
      }
    `
                    }), [e, t, n, i]);
                    return (0,
                    vt.jsxs)("mesh", {
                        rotation: [-Math.PI / 2, 0, 0],
                        position: [0, 0, 0],
                        children: [(0,
                        vt.jsx)("planeGeometry", {
                            args: [50, 200, 1, 1]
                        }), (0,
                        vt.jsx)("primitive", {
                            object: a,
                            ref: s
                        })]
                    })
                }
                  , AX = ({color: e, swayIntensity: t}) => {
                    const n = (0,
                    We.useRef)(null)
                      , i = (0,
                    We.useRef)(null)
                      , s = (0,
                    We.useRef)(null)
                      , a = (0,
                    We.useRef)(null)
                      , {camera: o, scene: c} = Ro()
                      , u = (0,
                    We.useRef)(0)
                      , f = (0,
                    We.useRef)(0)
                      , m = (0,
                    We.useRef)(0)
                      , v = (0,
                    We.useRef)(!0);
                    return (0,
                    We.useMemo)( () => new au(new ae(0,1,0),0), []),
                    kf( ({clock: y, pointer: S}) => {
                        if (!n.current)
                            return;
                        u.current = S.x * 15,
                        f.current += (u.current - f.current) * .05;
                        const A = 3.5
                          , M = 15
                          , x = M - A / 2
                          , T = -M + A / 2
                          , D = -.8;
                        let w = f.current
                          , U = (u.current - f.current) * .05;
                        w > x ? (w = x,
                        U *= D,
                        Ly.gizmoRuntime.performHaptic("medium")) : w < T && (w = T,
                        U *= D,
                        Ly.gizmoRuntime.performHaptic("medium")),
                        f.current = w + U,
                        n.current.position.x = f.current;
                        const O = (u.current - f.current) * .1;
                        i.current && (i.current.rotation.y = -O * .5),
                        s.current && (s.current.rotation.y = O),
                        a.current && (a.current.rotation.y = O);
                        const L = n.current.position
                          , N = .1
                          , z = 0;
                        L.y - N <= z ? (m.current = 0,
                        L.y = z + N,
                        v.current = !0) : v.current = !1,
                        v.current || (m.current -= .02),
                        L.y += m.current;
                        const I = y.getElapsedTime()
                          , B = Math.sin(I * 2) * t
                          , G = v.current ? Math.cos(I * 3) * t * .5 : 0;
                        o.position.set(f.current + B, 3 + G, 10),
                        o.lookAt(f.current, 1, -10)
                    }
                    ),
                    (0,
                    vt.jsxs)("group", {
                        ref: n,
                        position: [0, .5, 0],
                        children: [(0,
                        vt.jsxs)("group", {
                            ref: i,
                            children: [(0,
                            vt.jsxs)("mesh", {
                                position: [0, .5, 0],
                                children: [(0,
                                vt.jsx)("boxGeometry", {
                                    args: [3.5, 1, 6]
                                }), (0,
                                vt.jsx)("meshStandardMaterial", {
                                    color: e,
                                    metalness: .8,
                                    roughness: .2,
                                    emissive: e,
                                    emissiveIntensity: .5
                                })]
                            }), (0,
                            vt.jsxs)("mesh", {
                                position: [0, 1.2, .5],
                                children: [(0,
                                vt.jsx)("boxGeometry", {
                                    args: [3, .8, 3]
                                }), (0,
                                vt.jsx)("meshStandardMaterial", {
                                    color: "#111111",
                                    metalness: .9,
                                    roughness: .1
                                })]
                            })]
                        }), (0,
                        vt.jsxs)("mesh", {
                            position: [0, .5, -3.05],
                            children: [(0,
                            vt.jsx)("boxGeometry", {
                                args: [2.5, .5, .1]
                            }), (0,
                            vt.jsx)("meshStandardMaterial", {
                                color: "#FF0000",
                                emissive: "#FF0000",
                                emissiveIntensity: 2
                            })]
                        }), (0,
                        vt.jsx)("group", {
                            position: [-1.5, .1, -2.5]
                        }), (0,
                        vt.jsx)("group", {
                            position: [1.5, .1, -2.5]
                        }), (0,
                        vt.jsx)("group", {
                            position: [-1.5, .1, 2.5]
                        }), (0,
                        vt.jsx)("group", {
                            position: [1.5, .1, 2.5]
                        })]
                    })
                }
                  , TX = ({color: e, songDuration: t}) => {
                    const n = (0,
                    We.useRef)(null)
                      , i = 10;
                    kf( ({clock: a}) => {
                        n.current && (n.current.position.z = a.getElapsedTime() * i)
                    }
                    );
                    const s = (0,
                    We.useMemo)( () => {
                        const a = new su
                          , o = 15
                          , c = t * i
                          , u = 5 * i
                          , f = c - u;
                        let m = 0;
                        for (; m < c; ) {
                            let v, y;
                            m < f ? (v = 1.5,
                            y = v + (Math.random() - .5) * .5) : (v = .75,
                            y = v + (Math.random() - .5) * .25),
                            y = Math.max(.5, y);
                            const S = Math.random() * 40 + 15
                              , A = Math.random() * 4 + 3
                              , M = Math.random() * 4 + 3
                              , x = (Math.random() > .5 ? 1 : -1) * (o + Math.random() * 40)
                              , T = -m
                              , D = new su
                              , w = new oi(new dh(A,S,M),new Yp({
                                color: "#1a0033",
                                metalness: .9,
                                roughness: .1,
                                transparent: !0,
                                opacity: 1,
                                emissive: "#2c004f",
                                emissiveIntensity: .2
                            }));
                            w.position.y = S / 2,
                            D.add(w);
                            const U = Math.floor(S / 2);
                            for (let L = 0; L < U; L++) {
                                const N = new oi(new dh(A + .1,.05,.05),new Yp({
                                    color: "#53B5F9",
                                    emissive: "#53B5F9",
                                    emissiveIntensity: 1.5,
                                    transparent: !0,
                                    opacity: 1
                                }));
                                N.position.set(0, L / U * S, M / 2 + .02),
                                D.add(N)
                            }
                            const O = Math.floor(Math.random() * 15 + 5);
                            for (let L = 0; L < O; L++) {
                                const N = new oi(new dh(.3,.4,.05),new Yp({
                                    color: "#ffdd46",
                                    emissive: "#ffdd46",
                                    emissiveIntensity: 3,
                                    transparent: !0,
                                    opacity: Math.random() * .5 + .5
                                }));
                                N.position.set((Math.random() - .5) * (A - .5), Math.random() * S, M / 2 + .03),
                                D.add(N)
                            }
                            D.position.set(x, 0, T),
                            a.add(D),
                            m += y
                        }
                        return a
                    }
                    , [e, t]);
                    return (0,
                    vt.jsx)("primitive", {
                        object: s,
                        ref: n
                    })
                }
                  , MX = ({color: e}) => {
                    const t = (0,
                    We.useRef)(null)
                      , n = 15;
                    kf( ({clock: s}) => {
                        t.current && (t.current.position.z = s.getElapsedTime() * 10 % 40)
                    }
                    );
                    const i = (0,
                    We.useMemo)( () => {
                        const a = new su;
                        for (let o = 0; o < 40; o++) {
                            const c = Math.random() > .5 ? 1 : -1
                              , u = new Db;
                            u.text = "\u{1F334}",
                            u.fontSize = 20,
                            u.color = e,
                            u.anchorX = "center",
                            u.anchorY = "bottom",
                            u.sync();
                            const f = n + 2 + Math.random() * 5;
                            u.position.set(c * f, 0, o * -10 + 100);
                            const m = 1.2 + Math.random() * .6;
                            u.scale.set(m, m, m),
                            a.add(u)
                        }
                        return a
                    }
                    , [e]);
                    return (0,
                    vt.jsx)("primitive", {
                        object: i,
                        ref: t
                    })
                }
                  , bX = ({count: e=5e3}) => {
                    const t = (0,
                    We.useMemo)( () => {
                        const n = [];
                        for (let i = 0; i < e; i++)
                            n.push((Math.random() - .5) * 200, Math.random() * 100, (Math.random() - .5) * 200);
                        return new Float32Array(n)
                    }
                    , [e]);
                    return (0,
                    vt.jsxs)("points", {
                        children: [(0,
                        vt.jsx)("bufferGeometry", {
                            children: (0,
                            vt.jsx)("bufferAttribute", {
                                attach: "attributes-position",
                                array: t,
                                count: t.length / 3,
                                itemSize: 3
                            })
                        }), (0,
                        vt.jsx)("pointsMaterial", {
                            size: .1,
                            color: "#ffffff"
                        })]
                    })
                }
                  , EX = ({color1: e, color2: t}) => {
                    const n = (0,
                    We.useRef)(null)
                      , i = (0,
                    We.useMemo)( () => new kn({
                        uniforms: {
                            color1: {
                                value: new ft(e)
                            },
                            color2: {
                                value: new ft(t)
                            }
                        },
                        vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
                        fragmentShader: `
      uniform vec3 color1;
      uniform vec3 color2;
      varying vec2 vUv;

      void main() {
        float dist = distance(vUv, vec2(0.5, 0.5));
        if (dist > 0.5) {
          discard;
        }
        
        vec3 color = mix(color1, color2, vUv.y);
        
        float lines = step(0.05, fract(vUv.y * 20.0));
        
        gl_FragColor = vec4(color * lines, 1.0);
      }
    `,
                        transparent: !0
                    }), [e, t]);
                    return (0,
                    vt.jsxs)("mesh", {
                        position: [0, 15, -90],
                        scale: [80, 80, 1],
                        children: [(0,
                        vt.jsx)("planeGeometry", {
                            args: [1, 1]
                        }), (0,
                        vt.jsx)("primitive", {
                            object: i,
                            ref: n
                        })]
                    })
                }
                  , CX = ({topColor: e, bottomColor: t}) => {
                    const {scene: n} = Ro();
                    return (0,
                    We.useEffect)( () => {
                        const i = document.createElement("canvas");
                        i.width = 2,
                        i.height = 256;
                        const s = i.getContext("2d");
                        if (!s)
                            return;
                        const a = s.createLinearGradient(0, 0, 0, 256);
                        a.addColorStop(0, e),
                        a.addColorStop(1, t),
                        s.fillStyle = a,
                        s.fillRect(0, 0, 2, 256);
                        const o = new Sw(i);
                        return o.mapping = fp,
                        n.background = o,
                        () => {
                            o.dispose()
                        }
                    }
                    , [n, e, t]),
                    null
                }
                ;
                function wX() {
                    const [e,t] = (0,
                    We.useState)(!1)
                      , [n,i] = (0,
                    We.useState)(0)
                      , s = gc.bgColor1.useState()
                      , a = gc.bgColor2.useState()
                      , o = gc.sunColor1.useState()
                      , c = gc.sunColor2.useState()
                      , u = gc.roadColor.useState()
                      , f = gc.lineColor.useState()
                      , m = gc.cityColor.useState()
                      , v = gc.carColor.useState()
                      , y = gc.bloomStrength.useState()
                      , S = gc.swayIntensity.useState()
                      , A = async () => {
                        if (!e) {
                            await X7();
                            const M = new yb({
                                url: SX,
                                loop: !1,
                                autostart: !0,
                                onload: () => {
                                    i(M.buffer.duration),
                                    B3.scheduleOnce( () => {
                                        window.location.reload()
                                    }
                                    , M.buffer.duration)
                                },
                                onerror: () => {
                                    console.warn("Audio failed to load, using default duration"),
                                    i(180)
                                }
                            }).toDestination();
                            B3.start(),
                            t(!0),
                            i(180),
                            Ly.gizmoRuntime.performHaptic("light")
                        }
                    }
                    ;
                    return (0,
                    vt.jsxs)("div", {
                        className: "w-screen h-screen",
                        onTouchStart: A,
                        children: [(0,
                        vt.jsx)(NF, {
                            gl: {
                                antialias: !1
                            },
                            camera: {
                                position: [0, 3, 10],
                                fov: 75
                            },
                            children: (0,
                            vt.jsxs)(We.Suspense, {
                                fallback: null,
                                children: [(0,
                                vt.jsx)(CX, {
                                    topColor: s,
                                    bottomColor: a
                                }), (0,
                                vt.jsx)("ambientLight", {
                                    intensity: .2
                                }), (0,
                                vt.jsx)("directionalLight", {
                                    color: c,
                                    position: [0, 10, -20],
                                    intensity: 1.5
                                }), (0,
                                vt.jsx)("directionalLight", {
                                    color: a,
                                    position: [0, 5, 10],
                                    intensity: 1
                                }), (0,
                                vt.jsx)(bX, {}), (0,
                                vt.jsx)(EX, {
                                    color1: o,
                                    color2: c
                                }), (0,
                                vt.jsx)(xX, {
                                    color: u,
                                    lineColor: f,
                                    sunColor1: o,
                                    sunColor2: c
                                }), e && (0,
                                vt.jsx)(AX, {
                                    color: v,
                                    swayIntensity: S
                                }), n > 0 && (0,
                                vt.jsx)(TX, {
                                    color: m,
                                    songDuration: n
                                }), (0,
                                vt.jsx)(MX, {
                                    color: "#000000"
                                }), (0,
                                vt.jsxs)(lG, {
                                    children: [(0,
                                    vt.jsx)(pG, {
                                        luminanceThreshold: .1,
                                        luminanceSmoothing: .9,
                                        height: 400,
                                        intensity: y
                                    }), (0,
                                    vt.jsx)(mG, {
                                        blendFunction: Wt.NORMAL,
                                        offset: new Oe(.001,.001)
                                    }), (0,
                                    vt.jsx)(vG, {
                                        blendFunction: Wt.OVERLAY,
                                        density: 1.25
                                    })]
                                })]
                            })
                        }), !e && (0,
                        vt.jsx)("div", {
                            className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 z-10",
                            children: (0,
                            vt.jsx)("div", {
                                className: "text-white text-2xl font-mono animate-pulse",
                                children: "TAP TO DRIVE"
                            })
                        }), e && (0,
                        vt.jsx)("div", {
                            className: "absolute bottom-0 left-0 right-0 p-2 text-center text-white text-sm font-mono bg-black bg-opacity-70 z-10",
                            children: "NOW PLAYING: Home \u2014 Resonance"
                        })]
                    })
                }
                var DX = _r(wE());
                window.React = We.default,
                window.gizmoRuntime = DX.gizmoRuntime;
                var RX = class extends We.Component {
                    render() {
                        return (0,
                        vt.jsx)(wX, {})
                    }
                }
                ;
                IN.createRoot(document.getElementById("application")).render((0,
                vt.jsx)(RX, {}));

                //# sourceMappingURL=app.js.map
            </script>
        </div>
    </body>
</html>
