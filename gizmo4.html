<!DOCTYPE html>
<html lang="en">
    <head>
        <script>
            !function(e, t, n, o) {
                "use strict";
                var i, r, c = !1, u = {};
                function s(e, t, n, o, i) {
                    o = o || 0,
                    i = i || 0,
                    this.identifier = t,
                    this.target = e,
                    this.clientX = n.clientX + o,
                    this.clientY = n.clientY + i,
                    this.screenX = n.screenX + o,
                    this.screenY = n.screenY + i,
                    this.pageX = n.pageX + o,
                    this.pageY = n.pageY + i
                }
                function a() {
                    var e = [];
                    return e.item = function(e) {
                        return this[e] || null
                    }
                    ,
                    e.identifiedTouch = function(e) {
                        return this[e + 1] || null
                    }
                    ,
                    e
                }
                function d(e) {
                    e.preventDefault(),
                    e.stopPropagation()
                }
                function h(e) {
                    return function(t) {
                        d(t),
                        1 === t.which && (("mousedown" == t.type || !r || r && !r.dispatchEvent) && (r = t.target),
                        c && !t.shiftKey && (l("touchend", t),
                        c = !1),
                        l(e, t),
                        !c && t.shiftKey && (c = !0,
                        i = {
                            pageX: t.pageX,
                            pageY: t.pageY,
                            clientX: t.clientX,
                            clientY: t.clientY,
                            screenX: t.screenX,
                            screenY: t.screenY
                        },
                        l("touchstart", t)),
                        "mouseup" == t.type && (i = null,
                        c = !1,
                        r = null))
                    }
                }
                function l(e, n) {
                    var o = t.createEvent("Event");
                    o.initEvent(e, !0, !0),
                    o.altKey = n.altKey,
                    o.ctrlKey = n.ctrlKey,
                    o.metaKey = n.metaKey,
                    o.shiftKey = n.shiftKey,
                    o.touches = p(n, e),
                    o.targetTouches = p(n, e),
                    o.changedTouches = function(e, t) {
                        var n = f(e);
                        !c || "mouseup" == e.type || "touchstart" != t && "touchend" != t || n.splice(0, 1);
                        return n
                    }(n, e),
                    r.dispatchEvent(o)
                }
                function f(e) {
                    var t = new a;
                    if (c) {
                        var n = m.multiTouchOffset
                          , o = i.pageX - e.pageX
                          , u = i.pageY - e.pageY;
                        t.push(new s(r,1,i,-1 * o - n,-1 * u + n)),
                        t.push(new s(r,2,i,o + n,u - n))
                    } else
                        t.push(new s(r,1,e,0,0));
                    return t
                }
                function p(e, t) {
                    if ("mouseup" == e.type)
                        return new a;
                    var n = f(e);
                    return c && "mouseup" != e.type && "touchend" == t && n.splice(1, 1),
                    n
                }
                function v(e) {
                    var n, o, i, r;
                    for (o = 0; o < e.touches.length; o++)
                        for (var c in n = e.touches[o],
                        (i = u[n.identifier]) || (i = u[n.identifier] = t.createElement("div"),
                        t.body.appendChild(i)),
                        r = m.template(n))
                            i.style[c] = r[c];
                    if ("touchend" == e.type || "touchcancel" == e.type)
                        for (o = 0; o < e.changedTouches.length; o++)
                            n = e.changedTouches[o],
                            (i = u[n.identifier]) && (i.parentNode.removeChild(i),
                            delete u[n.identifier])
                }
                function m() {
                    "ontouchstart"in e || e.Modernizr && e.Modernizr.touch || (navigator.msMaxTouchPoints || navigator.maxTouchPoints) > 2 || (!function() {
                        for (var n = [e, t.documentElement], i = ["ontouchstart", "ontouchmove", "ontouchcancel", "ontouchend"], r = 0; r < n.length; r++)
                            for (var c = 0; c < i.length; c++)
                                n[r] && n[r][i[c]] == o && (n[r][i[c]] = null)
                    }(),
                    e.addEventListener("mousedown", h("touchstart"), !0),
                    e.addEventListener("mousemove", h("touchmove"), !0),
                    e.addEventListener("mouseup", h("touchend"), !0),
                    e.addEventListener("mouseenter", d, !0),
                    e.addEventListener("mouseleave", d, !0),
                    e.addEventListener("mouseout", d, !0),
                    e.addEventListener("mouseover", d, !0),
                    e.addEventListener("touchstart", v, !1),
                    e.addEventListener("touchmove", v, !1),
                    e.addEventListener("touchend", v, !1),
                    e.addEventListener("touchcancel", v, !1))
                }
                t.createTouch || (t.createTouch = function(t, n, i, r, c, u, a, d, h) {
                    return d != o && h != o || (d = r - e.pageXOffset,
                    h = c - e.pageYOffset),
                    new s(n,i,{
                        pageX: r,
                        pageY: c,
                        screenX: u,
                        screenY: a,
                        clientX: d,
                        clientY: h
                    })
                }
                ),
                t.createTouchList || (t.createTouchList = function() {
                    for (var e = new a, t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    return e.length = arguments.length,
                    e
                }
                ),
                m.multiTouchOffset = 75,
                m.template = function(e) {
                    var t = "translate(" + (e.clientX - 15) + "px, " + (e.clientY - 15) + "px)";
                    return {
                        position: "fixed",
                        left: 0,
                        top: 0,
                        background: "#fff",
                        border: "solid 1px #999",
                        opacity: .6,
                        borderRadius: "100%",
                        height: "30px",
                        width: "30px",
                        padding: 0,
                        margin: 0,
                        display: "block",
                        overflow: "hidden",
                        pointerEvents: "none",
                        webkitUserSelect: "none",
                        mozUserSelect: "none",
                        userSelect: "none",
                        webkitTransform: t,
                        mozTransform: t,
                        transform: t
                    }
                }
                ,
                "function" == typeof define && define.amd ? define((function() {
                    return m
                }
                )) : "undefined" != typeof module && module.exports ? module.exports = m : e.TouchEmulator = m
            }(window, document);
            TouchEmulator();
        </script>
        <meta charset="utf-8">
        <meta content="width=device-width,minimum-scale=1.0" name="viewport">
        <title>Gizmo</title>
        <style>
            *,:after,:before {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            ::backdrop {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            /*
! tailwindcss v3.4.19 | MIT License | https://tailwindcss.com
*/
            *,:after,:before {
                border: 0 solid #e5e7eb;
                box-sizing: border-box
            }

            :after,:before {
                --tw-content: ""
            }

            :host,html {
                line-height: 1.5;
                -webkit-text-size-adjust: 100%;
                font-family: ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;
                font-feature-settings: normal;
                font-variation-settings: normal;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
                -webkit-tap-highlight-color: transparent
            }

            body {
                line-height: inherit;
                margin: 0
            }

            hr {
                border-top-width: 1px;
                color: inherit;
                height: 0
            }

            abbr:where([title]) {
                -webkit-text-decoration: underline dotted;
                text-decoration: underline dotted
            }

            h1,h2,h3,h4,h5,h6 {
                font-size: inherit;
                font-weight: inherit
            }

            a {
                color: inherit;
                text-decoration: inherit
            }

            b,strong {
                font-weight: bolder
            }

            code,kbd,pre,samp {
                font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;
                font-feature-settings: normal;
                font-size: 1em;
                font-variation-settings: normal
            }

            small {
                font-size: 80%
            }

            sub,sup {
                font-size: 75%;
                line-height: 0;
                position: relative;
                vertical-align: baseline
            }

            sub {
                bottom: -.25em
            }

            sup {
                top: -.5em
            }

            table {
                border-collapse: collapse;
                border-color: inherit;
                text-indent: 0
            }

            button,input,optgroup,select,textarea {
                color: inherit;
                font-family: inherit;
                font-feature-settings: inherit;
                font-size: 100%;
                font-variation-settings: inherit;
                font-weight: inherit;
                letter-spacing: inherit;
                line-height: inherit;
                margin: 0;
                padding: 0
            }

            button,select {
                text-transform: none
            }

            button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]) {
                -webkit-appearance: button;
                background-color: transparent;
                background-image: none
            }

            :-moz-focusring {
                outline: auto
            }

            :-moz-ui-invalid {
                box-shadow: none
            }

            progress {
                vertical-align: baseline
            }

            ::-webkit-inner-spin-button,::-webkit-outer-spin-button {
                height: auto
            }

            [type=search] {
                -webkit-appearance: textfield;
                outline-offset: -2px
            }

            ::-webkit-search-decoration {
                -webkit-appearance: none
            }

            ::-webkit-file-upload-button {
                -webkit-appearance: button;
                font: inherit
            }

            summary {
                display: list-item
            }

            blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre {
                margin: 0
            }

            fieldset {
                margin: 0
            }

            fieldset,legend {
                padding: 0
            }

            menu,ol,ul {
                list-style: none;
                margin: 0;
                padding: 0
            }

            dialog {
                padding: 0
            }

            textarea {
                resize: vertical
            }

            input::-moz-placeholder,textarea::-moz-placeholder {
                color: #9ca3af;
                opacity: 1
            }

            input::placeholder,textarea::placeholder {
                color: #9ca3af;
                opacity: 1
            }

            [role=button],button {
                cursor: pointer
            }

            :disabled {
                cursor: default
            }

            audio,canvas,embed,iframe,img,object,svg,video {
                display: block;
                vertical-align: middle
            }

            img,video {
                height: auto;
                max-width: 100%
            }

            [hidden]:where(:not([hidden=until-found])) {
                display: none
            }

            .pointer-events-none {
                pointer-events: none
            }

            .absolute {
                position: absolute
            }

            .relative {
                position: relative
            }

            .left-0 {
                left: 0
            }

            .top-10 {
                top: 2.5rem
            }

            .z-10 {
                z-index: 10
            }

            .h-screen {
                height: 100vh
            }

            .w-full {
                width: 100%
            }

            .w-screen {
                width: 100vw
            }

            .overflow-hidden {
                overflow: hidden
            }

            .text-center {
                text-align: center
            }

            .transition-opacity {
                transition-duration: .15s;
                transition-property: opacity;
                transition-timing-function: cubic-bezier(.4,0,.2,1)
            }

            .duration-500 {
                transition-duration: .5s
            }

            * {
                -webkit-user-select: none;
                -moz-user-select: none;
                user-select: none
            }

            img {
                pointer-events: none;
                -webkit-touch-callout: none
            }

            /*# sourceMappingURL=app.css.map */
        </style>
        <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' blob: data: *.gizmo.party *.content.gizmo.party; media-src 'self' data: *.gizmo.party *.content.gizmo.party; connect-src 'self' blob: *.gizmo.party *.content.gizmo.party; script-src 'self' blob: 'unsafe-eval' 'unsafe-inline' runtime.gizmo.party; style-src 'self' 'unsafe-inline'; worker-src 'self' blob:; font-src 'self' data:; object-src 'none'; base-uri 'none'; upgrade-insecure-requests; block-all-mixed-content">
    </head>
    <body>
        <div id="application">
            <script type="module">
                var TN = Object.create
                  , L_ = Object.defineProperty
                  , AN = Object.getOwnPropertyDescriptor
                  , EN = Object.getOwnPropertyNames
                  , CN = Object.getPrototypeOf
                  , wN = Object.prototype.hasOwnProperty
                  , ln = (t, e) => () => (e || t((e = {
                    exports: {}
                }).exports, e),
                e.exports)
                  , RN = (t, e) => {
                    let n = {};
                    for (var i in t)
                        L_(n, i, {
                            get: t[i],
                            enumerable: !0
                        });
                    return e && L_(n, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    n
                }
                  , NN = (t, e, n, i) => {
                    if (e && typeof e == "object" || typeof e == "function")
                        for (var a = EN(e), o = 0, u = a.length, f; o < u; o++)
                            f = a[o],
                            !wN.call(t, f) && f !== n && L_(t, f, {
                                get: (d => e[d]).bind(null, f),
                                enumerable: !(i = AN(e, f)) || i.enumerable
                            });
                    return t
                }
                  , tg = (t, e, n) => (n = t != null ? TN(CN(t)) : {},
                NN(e || !t || !t.__esModule ? L_(n, "default", {
                    value: t,
                    enumerable: !0
                }) : n, t))
                  , ux = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Cancellable = void 0,
                    t.setTimeoutCancellable = n;
                    var e = class {
                        callback;
                        _cancelled = !1;
                        constructor(i) {
                            this.callback = i
                        }
                        cancel = () => {
                            if (this._cancelled)
                                return;
                            this._cancelled = !0;
                            const i = this.callback;
                            this.callback = void 0,
                            i?.()
                        }
                        ;
                        get isCancelled() {
                            return this._cancelled
                        }
                    }
                    ;
                    t.Cancellable = e;
                    function n(i, a) {
                        const o = setTimeout(i, a);
                        return new e( () => {
                            clearTimeout(o)
                        }
                        )
                    }
                }
                ))
                  , s1 = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.EventEmitterEvent = t.EventEmitter = void 0;
                    var e = class extends EventTarget {
                        emit(i, a) {
                            this.dispatchEvent(new n(i,a))
                        }
                    }
                    ;
                    t.EventEmitter = e;
                    var n = class extends Event {
                        payload;
                        constructor(i, a) {
                            super(i),
                            this.payload = a
                        }
                    }
                    ;
                    t.EventEmitterEvent = n
                }
                ))
                  , DN = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ReceiveChannel = void 0;
                    const e = ux()
                      , n = s1();
                    var i = class {
                        emitter = new n.EventEmitter;
                        emit(a) {
                            this.emitter.emit(a.endpoint, a.payload)
                        }
                        subscribe(a, o) {
                            const u = f => {
                                const d = f.payload;
                                o(d)
                            }
                            ;
                            return this.emitter.addEventListener(a, u),
                            new e.Cancellable( () => {
                                this.emitter.removeEventListener(a, u)
                            }
                            )
                        }
                        once(a, o) {
                            const u = this.subscribe(a, f => {
                                u.cancel(),
                                o(f)
                            }
                            );
                            return u
                        }
                    }
                    ;
                    t.ReceiveChannel = i
                }
                ))
                  , a1 = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.PassthroughSubject = void 0;
                    const e = ux()
                      , n = s1();
                    var i = class {
                        emitter = new n.EventEmitter;
                        send(a) {
                            this.emitter.emit("value", a)
                        }
                        subscribe(a) {
                            const o = u => {
                                const f = u.payload;
                                a(f)
                            }
                            ;
                            return this.emitter.addEventListener("value", o),
                            new e.Cancellable( () => {
                                this.emitter.removeEventListener("value", o)
                            }
                            )
                        }
                    }
                    ;
                    t.PassthroughSubject = i
                }
                ))
                  , r1 = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.colorToHexString = e,
                    t.colorFromString = n;
                    function e(g) {
                        return g.a === 1 ? `#${o(g).toString(16).padStart(6, "0").toUpperCase()}` : `#${u(g).toString(16).padStart(8, "0").toUpperCase()}`
                    }
                    function n(g) {
                        if (g) {
                            if (g.startsWith("rgb(") || g.startsWith("rgba("))
                                return f(g);
                            if (g.startsWith("#") && (g = g.slice(1)),
                            g.length === 6)
                                return i(parseInt(g, 16));
                            if (g.length === 8)
                                return a(parseInt(g, 16))
                        }
                    }
                    function i(g) {
                        return g >>>= 0,
                        {
                            r: (g & 16711680) >>> 16,
                            g: (g & 65280) >>> 8,
                            b: g & 255,
                            a: 1
                        }
                    }
                    function a(g) {
                        return g >>>= 0,
                        {
                            r: (g & 4278190080) >>> 24,
                            g: (g & 16711680) >>> 16,
                            b: (g & 65280) >>> 8,
                            a: (g & 255) / 255
                        }
                    }
                    function o(g) {
                        let v = (g.r & 255) << 16;
                        return v = v | (g.g & 255) << 8,
                        v = v | g.b & 255,
                        v >>> 0
                    }
                    function u(g) {
                        let v = (g.r & 255) << 24;
                        return v = v | (g.g & 255) << 16,
                        v = v | (g.b & 255) << 8,
                        v = v | g.a * 255 & 255,
                        v >>> 0
                    }
                    function f(g) {
                        if (g) {
                            if (g.startsWith("rgb(") && g.endsWith(")")) {
                                const v = g.substring(4, g.length - 1).split(", ");
                                return p(+(v[0] ?? 0), +(v[1] ?? 0), +(v[2] ?? 0), 1)
                            }
                            if (g.startsWith("rgba(") && g.endsWith(")")) {
                                const v = g.substring(5, g.length - 1).split(", ");
                                return p(+(v[0] ?? 0), +(v[1] ?? 0), +(v[2] ?? 0), +(v[3] ?? 1))
                            }
                        }
                    }
                    function d(g, v, y) {
                        return Math.max(Math.min(g, y), v)
                    }
                    function p(g, v, y, S) {
                        return {
                            r: d(g, 0, 255),
                            g: d(v, 0, 255),
                            b: d(y, 0, 255),
                            a: d(S, 0, 1)
                        }
                    }
                }
                ))
                  , ON = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.processConfig = n;
                    const e = r1();
                    function n(v) {
                        const y = {};
                        for (const [S,E] of Object.entries(v))
                            try {
                                y[S] = i(S, E)
                            } catch (w) {
                                console.error("Error validating tweaks config:", w)
                            }
                        return y
                    }
                    function i(v, y) {
                        switch (p(y, v, "name", "string"),
                        p(y, v, "index", "number"),
                        p(y, v, "group", "string"),
                        y.type) {
                        case "slider":
                            return a(v, y);
                        case "toggle":
                            return o(v, y);
                        case "color":
                            return u(v, y);
                        case "text":
                            return f(v, y);
                        default:
                            throw new Error(`Invalid config type: ${y.type}`)
                        }
                    }
                    function a(v, y) {
                        if (d(y, v, "value", "number"),
                        d(y, v, "min", "number"),
                        d(y, v, "max", "number"),
                        d(y, v, "step", "number"),
                        y.min >= y.max)
                            throw new Error(`Invalid slider config for "${v}", expected min (${y.min}) < max (${y.max})`);
                        if (y.step <= 0)
                            throw new Error(`Invalid slider config for "${v}", expected step (${y.step}) > 0`);
                        if (y.value < y.min)
                            throw new Error(`Invalid slider config for "${v}", expected value (${y.value}) >= min (${y.min})`);
                        if (y.value > y.max)
                            throw new Error(`Invalid slider config for "${v}", expected value (${y.value}) <= max (${y.max})`);
                        return y
                    }
                    function o(v, y) {
                        return d(y, v, "value", "boolean"),
                        y
                    }
                    function u(v, y) {
                        d(y, v, "value", "string");
                        const S = (0,
                        e.colorFromString)(y.value);
                        if (!S)
                            throw new Error(`Tweaks config has incorrect color value for ${v}, got ${y.value} but expected color hex, rgb(), rgba()`);
                        return {
                            ...y,
                            value: (0,
                            e.colorToHexString)(S)
                        }
                    }
                    function f(v, y) {
                        return d(y, v, "value", "string"),
                        d(y, v, "group", "string"),
                        y
                    }
                    function d(v, y, S, E) {
                        const w = v[S];
                        if (typeof w !== E)
                            throw new g(y,S,E,w)
                    }
                    function p(v, y, S, E) {
                        const w = v[S];
                        if (w !== void 0 && typeof w !== E)
                            throw new g(y,S,E,w)
                    }
                    var g = class extends Error {
                        constructor(v, y, S, E) {
                            super(`Tweaks config has incorrect value type for ${v} ${y}, expected ${S} got ${typeof E}`)
                        }
                    }
                }
                ))
                  , UN = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.createTweaks = a;
                    const e = a1()
                      , n = r1()
                      , i = ON();
                    function a(d, p) {
                        const g = (0,
                        i.processConfig)(d)
                          , v = new o(p,g)
                          , y = {};
                        for (const S of Object.keys(d))
                            y[S] = {
                                useState: () => v.useState(S)
                            };
                        return [y, g]
                    }
                    var o = class {
                        observable;
                        values;
                        subject = new e.PassthroughSubject;
                        constructor(d, p) {
                            this.observable = d,
                            this.values = u(p),
                            this.observable.subscribe(g => {
                                for (const [v,y] of Object.entries(g.values)) {
                                    const S = p[v];
                                    if (S === void 0)
                                        return;
                                    const E = f(S, y);
                                    if (E === void 0)
                                        return;
                                    this.values[v] !== E && (this.values[v] = E,
                                    this.subject.send(v))
                                }
                            }
                            )
                        }
                        getValue(d) {
                            const p = this.values[d];
                            if (p === void 0)
                                throw new Error(`Tweak key not found in values: ${d}`);
                            return p
                        }
                        useState(d) {
                            const p = window.React;
                            if (!p || !p.useReducer || !p.useEffect)
                                return console.warn("React not found on window"),
                                this.getValue(d);
                            const [g,v] = p.useReducer( () => this.getValue(d), this.getValue(d));
                            return p.useEffect( () => {
                                const y = this.subject.subscribe(S => {
                                    S === d && v()
                                }
                                );
                                return () => {
                                    y.cancel()
                                }
                            }
                            ),
                            g
                        }
                    }
                    ;
                    function u(d) {
                        const p = {};
                        for (const g of Object.entries(d))
                            p[g[0]] = g[1].value;
                        return p
                    }
                    function f(d, p) {
                        switch (d.type) {
                        case "slider":
                            {
                                const g = parseFloat(p);
                                return isNaN(g) ? void 0 : g
                            }
                        case "toggle":
                            return p === "true";
                        case "color":
                            {
                                const g = (0,
                                n.colorFromString)(p);
                                return g ? (0,
                                n.colorToHexString)(g) : void 0
                            }
                        case "text":
                            return p
                        }
                    }
                }
                ))
                  , o1 = ln((t => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.gizmoRuntime = void 0;
                    const e = DN()
                      , n = UN()
                      , i = ux()
                      , a = a1();
                    var o = class {
                        receiveChannel = new e.ReceiveChannel;
                        seq = 0;
                        tweaksListener = void 0;
                        tweaksInstance = void 0;
                        tweaksDidWarn = !1;
                        tweaks(u) {
                            if (this.tweaksInstance)
                                return this.tweaksDidWarn || (this.tweaksDidWarn = !0,
                                console.warn("tweaks() is expected to only be called once, returning previous value")),
                                this.tweaksInstance;
                            const f = new a.PassthroughSubject
                              , [d,p] = (0,
                            n.createTweaks)(u, f);
                            return this.tweaksInstance = d,
                            this.tweaksListener?.cancel(),
                            this.tweaksListener = this.addTweaksListener(p, g => {
                                f.send(g)
                            }
                            ),
                            d
                        }
                        receiveMessage(u) {
                            return this.receiveChannel.emit(u),
                            Promise.resolve()
                        }
                        performHaptic(u) {
                            typeof u == "object" && "style"in u && typeof u.style == "string" && (u = u.style),
                            window.webkit?.messageHandlers?.hapticHandler?.postMessage(this.makeMessage({
                                kind: "impact",
                                style: u
                            }))
                        }
                        generateText(u) {
                            const f = window.webkit?.messageHandlers?.textGenerationHandler;
                            return f ? this.performHandlerRequest(f, {
                                prompt: u.prompt,
                                imageData: u.imageData
                            }, 3e4) : Promise.reject(new Error("Not available"))
                        }
                        generateImage(u) {
                            const f = window.webkit?.messageHandlers?.imageGenerationHandler;
                            return f ? this.performHandlerRequest(f, {
                                prompt: u.prompt,
                                imageData: u.imageData,
                                targetAspectRatio: u.targetAspectRatio
                            }, 3e4) : Promise.reject(new Error("Not available"))
                        }
                        addShakeListener(u) {
                            const f = window.webkit?.messageHandlers?.deviceMotionHandler;
                            if (!f)
                                return console.warn("Shake handler not available"),
                                () => {}
                                ;
                            const d = this.createSubscription(f, {
                                type: "shake"
                            }, () => {
                                u()
                            }
                            );
                            return () => {
                                d.cancel()
                            }
                        }
                        addMotionListener(u) {
                            const f = window.webkit?.messageHandlers?.deviceMotionHandler;
                            if (!f)
                                return console.warn("Motion handler not available"),
                                () => {}
                                ;
                            const d = this.createSubscription(f, {
                                type: "motion"
                            }, p => {
                                p.motion && u(p.motion)
                            }
                            );
                            return () => {
                                d.cancel()
                            }
                        }
                        addTweaksListener(u, f) {
                            const d = window.webkit?.messageHandlers?.tweaksHandler;
                            return d ? this.createSubscription(d, {
                                type: "initialize",
                                config: JSON.stringify(u)
                            }, p => {
                                f(p)
                            }
                            ) : new i.Cancellable(void 0)
                        }
                        createSubscription(u, f, d) {
                            const p = this.makeSubscriptionMessage(f)
                              , g = this.receiveChannel.subscribe(p.endpoint, v => {
                                if (v.error !== void 0) {
                                    console.error(`Subscription error: ${v.error}`);
                                    return
                                }
                                d(v)
                            }
                            );
                            return u.postMessage(p),
                            new i.Cancellable( () => {
                                g.cancel(),
                                u.postMessage({
                                    endpoint: p.endpoint,
                                    payload: "unsubscribe"
                                })
                            }
                            )
                        }
                        performHandlerRequest(u, f, d) {
                            return new Promise( (p, g) => {
                                const v = this.makeMessage(f)
                                  , y = this.receiveChannel.once(v.endpoint, E => {
                                    S.cancel(),
                                    E.error !== void 0 ? g(new Error(`Error: ${E.error}`)) : p(E)
                                }
                                )
                                  , S = (0,
                                i.setTimeoutCancellable)( () => {
                                    y.cancel(),
                                    g(new Error("Request timed out"))
                                }
                                , d);
                                u.postMessage(v)
                            }
                            )
                        }
                        makeMessage(u) {
                            return {
                                endpoint: (this.seq++).toString(),
                                payload: u
                            }
                        }
                        makeSubscriptionMessage(u) {
                            return {
                                endpoint: (this.seq++).toString(),
                                payload: {
                                    subscribe: u
                                }
                            }
                        }
                    }
                    ;
                    t.gizmoRuntime = new o
                }
                ));
                var LN = ln((t => {
                    var e = Symbol.for("react.transitional.element")
                      , n = Symbol.for("react.portal")
                      , i = Symbol.for("react.fragment")
                      , a = Symbol.for("react.strict_mode")
                      , o = Symbol.for("react.profiler")
                      , u = Symbol.for("react.consumer")
                      , f = Symbol.for("react.context")
                      , d = Symbol.for("react.forward_ref")
                      , p = Symbol.for("react.suspense")
                      , g = Symbol.for("react.memo")
                      , v = Symbol.for("react.lazy")
                      , y = Symbol.for("react.activity")
                      , S = Symbol.iterator;
                    function E(k) {
                        return k === null || typeof k != "object" ? null : (k = S && k[S] || k["@@iterator"],
                        typeof k == "function" ? k : null)
                    }
                    var w = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    }
                      , A = Object.assign
                      , T = {};
                    function R(k, pe, Ae) {
                        this.props = k,
                        this.context = pe,
                        this.refs = T,
                        this.updater = Ae || w
                    }
                    R.prototype.isReactComponent = {},
                    R.prototype.setState = function(k, pe) {
                        if (typeof k != "object" && typeof k != "function" && k != null)
                            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
                        this.updater.enqueueSetState(this, k, pe, "setState")
                    }
                    ,
                    R.prototype.forceUpdate = function(k) {
                        this.updater.enqueueForceUpdate(this, k, "forceUpdate")
                    }
                    ;
                    function N() {}
                    N.prototype = R.prototype;
                    function D(k, pe, Ae) {
                        this.props = k,
                        this.context = pe,
                        this.refs = T,
                        this.updater = Ae || w
                    }
                    var U = D.prototype = new N;
                    U.constructor = D,
                    A(U, R.prototype),
                    U.isPureReactComponent = !0;
                    var z = Array.isArray;
                    function I() {}
                    var V = {
                        H: null,
                        A: null,
                        T: null,
                        S: null
                    }
                      , B = Object.prototype.hasOwnProperty;
                    function P(k, pe, Ae) {
                        var ie = Ae.ref;
                        return {
                            $$typeof: e,
                            type: k,
                            key: pe,
                            ref: ie !== void 0 ? ie : null,
                            props: Ae
                        }
                    }
                    function G(k, pe) {
                        return P(k.type, pe, k.props)
                    }
                    function K(k) {
                        return typeof k == "object" && k !== null && k.$$typeof === e
                    }
                    function ee(k) {
                        var pe = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + k.replace(/[=:]/g, function(Ae) {
                            return pe[Ae]
                        })
                    }
                    var te = /\/+/g;
                    function oe(k, pe) {
                        return typeof k == "object" && k !== null && k.key != null ? ee("" + k.key) : pe.toString(36)
                    }
                    function q(k) {
                        switch (k.status) {
                        case "fulfilled":
                            return k.value;
                        case "rejected":
                            throw k.reason;
                        default:
                            switch (typeof k.status == "string" ? k.then(I, I) : (k.status = "pending",
                            k.then(function(pe) {
                                k.status === "pending" && (k.status = "fulfilled",
                                k.value = pe)
                            }, function(pe) {
                                k.status === "pending" && (k.status = "rejected",
                                k.reason = pe)
                            })),
                            k.status) {
                            case "fulfilled":
                                return k.value;
                            case "rejected":
                                throw k.reason
                            }
                        }
                        throw k
                    }
                    function F(k, pe, Ae, ie, Me) {
                        var we = typeof k;
                        (we === "undefined" || we === "boolean") && (k = null);
                        var Te = !1;
                        if (k === null)
                            Te = !0;
                        else
                            switch (we) {
                            case "bigint":
                            case "string":
                            case "number":
                                Te = !0;
                                break;
                            case "object":
                                switch (k.$$typeof) {
                                case e:
                                case n:
                                    Te = !0;
                                    break;
                                case v:
                                    return Te = k._init,
                                    F(Te(k._payload), pe, Ae, ie, Me)
                                }
                            }
                        if (Te)
                            return Me = Me(k),
                            Te = ie === "" ? "." + oe(k, 0) : ie,
                            z(Me) ? (Ae = "",
                            Te != null && (Ae = Te.replace(te, "$&/") + "/"),
                            F(Me, pe, Ae, "", function(Ct) {
                                return Ct
                            })) : Me != null && (K(Me) && (Me = G(Me, Ae + (Me.key == null || k && k.key === Me.key ? "" : ("" + Me.key).replace(te, "$&/") + "/") + Te)),
                            pe.push(Me)),
                            1;
                        Te = 0;
                        var Je = ie === "" ? "." : ie + ":";
                        if (z(k))
                            for (var Ze = 0; Ze < k.length; Ze++)
                                ie = k[Ze],
                                we = Je + oe(ie, Ze),
                                Te += F(ie, pe, Ae, we, Me);
                        else if (Ze = E(k),
                        typeof Ze == "function")
                            for (k = Ze.call(k),
                            Ze = 0; !(ie = k.next()).done; )
                                ie = ie.value,
                                we = Je + oe(ie, Ze++),
                                Te += F(ie, pe, Ae, we, Me);
                        else if (we === "object") {
                            if (typeof k.then == "function")
                                return F(q(k), pe, Ae, ie, Me);
                            throw pe = String(k),
                            Error("Objects are not valid as a React child (found: " + (pe === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : pe) + "). If you meant to render a collection of children, use an array instead.")
                        }
                        return Te
                    }
                    function X(k, pe, Ae) {
                        if (k == null)
                            return k;
                        var ie = []
                          , Me = 0;
                        return F(k, ie, "", "", function(we) {
                            return pe.call(Ae, we, Me++)
                        }),
                        ie
                    }
                    function $(k) {
                        if (k._status === -1) {
                            var pe = k._result;
                            pe = pe(),
                            pe.then(function(Ae) {
                                (k._status === 0 || k._status === -1) && (k._status = 1,
                                k._result = Ae)
                            }, function(Ae) {
                                (k._status === 0 || k._status === -1) && (k._status = 2,
                                k._result = Ae)
                            }),
                            k._status === -1 && (k._status = 0,
                            k._result = pe)
                        }
                        if (k._status === 1)
                            return k._result.default;
                        throw k._result
                    }
                    var ne = typeof reportError == "function" ? reportError : function(k) {
                        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                            var pe = new window.ErrorEvent("error",{
                                bubbles: !0,
                                cancelable: !0,
                                message: typeof k == "object" && k !== null && typeof k.message == "string" ? String(k.message) : String(k),
                                error: k
                            });
                            if (!window.dispatchEvent(pe))
                                return
                        } else if (typeof process == "object" && typeof process.emit == "function") {
                            process.emit("uncaughtException", k);
                            return
                        }
                        console.error(k)
                    }
                      , ce = {
                        map: X,
                        forEach: function(k, pe, Ae) {
                            X(k, function() {
                                pe.apply(this, arguments)
                            }, Ae)
                        },
                        count: function(k) {
                            var pe = 0;
                            return X(k, function() {
                                pe++
                            }),
                            pe
                        },
                        toArray: function(k) {
                            return X(k, function(pe) {
                                return pe
                            }) || []
                        },
                        only: function(k) {
                            if (!K(k))
                                throw Error("React.Children.only expected to receive a single React element child.");
                            return k
                        }
                    };
                    t.Activity = y,
                    t.Children = ce,
                    t.Component = R,
                    t.Fragment = i,
                    t.Profiler = o,
                    t.PureComponent = D,
                    t.StrictMode = a,
                    t.Suspense = p,
                    t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = V,
                    t.__COMPILER_RUNTIME = {
                        __proto__: null,
                        c: function(k) {
                            return V.H.useMemoCache(k)
                        }
                    },
                    t.cache = function(k) {
                        return function() {
                            return k.apply(null, arguments)
                        }
                    }
                    ,
                    t.cacheSignal = function() {
                        return null
                    }
                    ,
                    t.cloneElement = function(k, pe, Ae) {
                        if (k == null)
                            throw Error("The argument must be a React element, but you passed " + k + ".");
                        var ie = A({}, k.props)
                          , Me = k.key;
                        if (pe != null)
                            for (we in pe.key !== void 0 && (Me = "" + pe.key),
                            pe)
                                !B.call(pe, we) || we === "key" || we === "__self" || we === "__source" || we === "ref" && pe.ref === void 0 || (ie[we] = pe[we]);
                        var we = arguments.length - 2;
                        if (we === 1)
                            ie.children = Ae;
                        else if (1 < we) {
                            for (var Te = Array(we), Je = 0; Je < we; Je++)
                                Te[Je] = arguments[Je + 2];
                            ie.children = Te
                        }
                        return P(k.type, Me, ie)
                    }
                    ,
                    t.createContext = function(k) {
                        return k = {
                            $$typeof: f,
                            _currentValue: k,
                            _currentValue2: k,
                            _threadCount: 0,
                            Provider: null,
                            Consumer: null
                        },
                        k.Provider = k,
                        k.Consumer = {
                            $$typeof: u,
                            _context: k
                        },
                        k
                    }
                    ,
                    t.createElement = function(k, pe, Ae) {
                        var ie, Me = {}, we = null;
                        if (pe != null)
                            for (ie in pe.key !== void 0 && (we = "" + pe.key),
                            pe)
                                B.call(pe, ie) && ie !== "key" && ie !== "__self" && ie !== "__source" && (Me[ie] = pe[ie]);
                        var Te = arguments.length - 2;
                        if (Te === 1)
                            Me.children = Ae;
                        else if (1 < Te) {
                            for (var Je = Array(Te), Ze = 0; Ze < Te; Ze++)
                                Je[Ze] = arguments[Ze + 2];
                            Me.children = Je
                        }
                        if (k && k.defaultProps)
                            for (ie in Te = k.defaultProps,
                            Te)
                                Me[ie] === void 0 && (Me[ie] = Te[ie]);
                        return P(k, we, Me)
                    }
                    ,
                    t.createRef = function() {
                        return {
                            current: null
                        }
                    }
                    ,
                    t.forwardRef = function(k) {
                        return {
                            $$typeof: d,
                            render: k
                        }
                    }
                    ,
                    t.isValidElement = K,
                    t.lazy = function(k) {
                        return {
                            $$typeof: v,
                            _payload: {
                                _status: -1,
                                _result: k
                            },
                            _init: $
                        }
                    }
                    ,
                    t.memo = function(k, pe) {
                        return {
                            $$typeof: g,
                            type: k,
                            compare: pe === void 0 ? null : pe
                        }
                    }
                    ,
                    t.startTransition = function(k) {
                        var pe = V.T
                          , Ae = {};
                        V.T = Ae;
                        try {
                            var ie = k()
                              , Me = V.S;
                            Me !== null && Me(Ae, ie),
                            typeof ie == "object" && ie !== null && typeof ie.then == "function" && ie.then(I, ne)
                        } catch (we) {
                            ne(we)
                        } finally {
                            pe !== null && Ae.types !== null && (pe.types = Ae.types),
                            V.T = pe
                        }
                    }
                    ,
                    t.unstable_useCacheRefresh = function() {
                        return V.H.useCacheRefresh()
                    }
                    ,
                    t.use = function(k) {
                        return V.H.use(k)
                    }
                    ,
                    t.useActionState = function(k, pe, Ae) {
                        return V.H.useActionState(k, pe, Ae)
                    }
                    ,
                    t.useCallback = function(k, pe) {
                        return V.H.useCallback(k, pe)
                    }
                    ,
                    t.useContext = function(k) {
                        return V.H.useContext(k)
                    }
                    ,
                    t.useDebugValue = function() {}
                    ,
                    t.useDeferredValue = function(k, pe) {
                        return V.H.useDeferredValue(k, pe)
                    }
                    ,
                    t.useEffect = function(k, pe) {
                        return V.H.useEffect(k, pe)
                    }
                    ,
                    t.useEffectEvent = function(k) {
                        return V.H.useEffectEvent(k)
                    }
                    ,
                    t.useId = function() {
                        return V.H.useId()
                    }
                    ,
                    t.useImperativeHandle = function(k, pe, Ae) {
                        return V.H.useImperativeHandle(k, pe, Ae)
                    }
                    ,
                    t.useInsertionEffect = function(k, pe) {
                        return V.H.useInsertionEffect(k, pe)
                    }
                    ,
                    t.useLayoutEffect = function(k, pe) {
                        return V.H.useLayoutEffect(k, pe)
                    }
                    ,
                    t.useMemo = function(k, pe) {
                        return V.H.useMemo(k, pe)
                    }
                    ,
                    t.useOptimistic = function(k, pe) {
                        return V.H.useOptimistic(k, pe)
                    }
                    ,
                    t.useReducer = function(k, pe, Ae) {
                        return V.H.useReducer(k, pe, Ae)
                    }
                    ,
                    t.useRef = function(k) {
                        return V.H.useRef(k)
                    }
                    ,
                    t.useState = function(k) {
                        return V.H.useState(k)
                    }
                    ,
                    t.useSyncExternalStore = function(k, pe, Ae) {
                        return V.H.useSyncExternalStore(k, pe, Ae)
                    }
                    ,
                    t.useTransition = function() {
                        return V.H.useTransition()
                    }
                    ,
                    t.version = "19.2.3"
                }
                ))
                  , Sd = ln(( (t, e) => {
                    e.exports = LN()
                }
                ));
                var IN = ln((t => {
                    function e(q, F) {
                        var X = q.length;
                        q.push(F);
                        e: for (; 0 < X; ) {
                            var $ = X - 1 >>> 1
                              , ne = q[$];
                            if (0 < a(ne, F))
                                q[$] = F,
                                q[X] = ne,
                                X = $;
                            else
                                break e
                        }
                    }
                    function n(q) {
                        return q.length === 0 ? null : q[0]
                    }
                    function i(q) {
                        if (q.length === 0)
                            return null;
                        var F = q[0]
                          , X = q.pop();
                        if (X !== F) {
                            q[0] = X;
                            e: for (var $ = 0, ne = q.length, ce = ne >>> 1; $ < ce; ) {
                                var k = 2 * ($ + 1) - 1
                                  , pe = q[k]
                                  , Ae = k + 1
                                  , ie = q[Ae];
                                if (0 > a(pe, X))
                                    Ae < ne && 0 > a(ie, pe) ? (q[$] = ie,
                                    q[Ae] = X,
                                    $ = Ae) : (q[$] = pe,
                                    q[k] = X,
                                    $ = k);
                                else if (Ae < ne && 0 > a(ie, X))
                                    q[$] = ie,
                                    q[Ae] = X,
                                    $ = Ae;
                                else
                                    break e
                            }
                        }
                        return F
                    }
                    function a(q, F) {
                        var X = q.sortIndex - F.sortIndex;
                        return X !== 0 ? X : q.id - F.id
                    }
                    if (t.unstable_now = void 0,
                    typeof performance == "object" && typeof performance.now == "function") {
                        var o = performance;
                        t.unstable_now = function() {
                            return o.now()
                        }
                    } else {
                        var u = Date
                          , f = u.now();
                        t.unstable_now = function() {
                            return u.now() - f
                        }
                    }
                    var d = []
                      , p = []
                      , g = 1
                      , v = null
                      , y = 3
                      , S = !1
                      , E = !1
                      , w = !1
                      , A = !1
                      , T = typeof setTimeout == "function" ? setTimeout : null
                      , R = typeof clearTimeout == "function" ? clearTimeout : null
                      , N = typeof setImmediate < "u" ? setImmediate : null;
                    function D(q) {
                        for (var F = n(p); F !== null; ) {
                            if (F.callback === null)
                                i(p);
                            else if (F.startTime <= q)
                                i(p),
                                F.sortIndex = F.expirationTime,
                                e(d, F);
                            else
                                break;
                            F = n(p)
                        }
                    }
                    function U(q) {
                        if (w = !1,
                        D(q),
                        !E)
                            if (n(d) !== null)
                                E = !0,
                                z || (z = !0,
                                K());
                            else {
                                var F = n(p);
                                F !== null && oe(U, F.startTime - q)
                            }
                    }
                    var z = !1
                      , I = -1
                      , V = 5
                      , B = -1;
                    function P() {
                        return A ? !0 : !(t.unstable_now() - B < V)
                    }
                    function G() {
                        if (A = !1,
                        z) {
                            var q = t.unstable_now();
                            B = q;
                            var F = !0;
                            try {
                                e: {
                                    E = !1,
                                    w && (w = !1,
                                    R(I),
                                    I = -1),
                                    S = !0;
                                    var X = y;
                                    try {
                                        t: {
                                            for (D(q),
                                            v = n(d); v !== null && !(v.expirationTime > q && P()); ) {
                                                var $ = v.callback;
                                                if (typeof $ == "function") {
                                                    v.callback = null,
                                                    y = v.priorityLevel;
                                                    var ne = $(v.expirationTime <= q);
                                                    if (q = t.unstable_now(),
                                                    typeof ne == "function") {
                                                        v.callback = ne,
                                                        D(q),
                                                        F = !0;
                                                        break t
                                                    }
                                                    v === n(d) && i(d),
                                                    D(q)
                                                } else
                                                    i(d);
                                                v = n(d)
                                            }
                                            if (v !== null)
                                                F = !0;
                                            else {
                                                var ce = n(p);
                                                ce !== null && oe(U, ce.startTime - q),
                                                F = !1
                                            }
                                        }
                                        break e
                                    } finally {
                                        v = null,
                                        y = X,
                                        S = !1
                                    }
                                    F = void 0
                                }
                            } finally {
                                F ? K() : z = !1
                            }
                        }
                    }
                    var K;
                    if (typeof N == "function")
                        K = function() {
                            N(G)
                        }
                        ;
                    else if (typeof MessageChannel < "u") {
                        var ee = new MessageChannel
                          , te = ee.port2;
                        ee.port1.onmessage = G,
                        K = function() {
                            te.postMessage(null)
                        }
                    } else
                        K = function() {
                            T(G, 0)
                        }
                        ;
                    function oe(q, F) {
                        I = T(function() {
                            q(t.unstable_now())
                        }, F)
                    }
                    t.unstable_IdlePriority = 5,
                    t.unstable_ImmediatePriority = 1,
                    t.unstable_LowPriority = 4,
                    t.unstable_NormalPriority = 3,
                    t.unstable_Profiling = null,
                    t.unstable_UserBlockingPriority = 2,
                    t.unstable_cancelCallback = function(q) {
                        q.callback = null
                    }
                    ,
                    t.unstable_forceFrameRate = function(q) {
                        0 > q || 125 < q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : V = 0 < q ? Math.floor(1e3 / q) : 5
                    }
                    ,
                    t.unstable_getCurrentPriorityLevel = function() {
                        return y
                    }
                    ,
                    t.unstable_next = function(q) {
                        switch (y) {
                        case 1:
                        case 2:
                        case 3:
                            var F = 3;
                            break;
                        default:
                            F = y
                        }
                        var X = y;
                        y = F;
                        try {
                            return q()
                        } finally {
                            y = X
                        }
                    }
                    ,
                    t.unstable_requestPaint = function() {
                        A = !0
                    }
                    ,
                    t.unstable_runWithPriority = function(q, F) {
                        switch (q) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            q = 3
                        }
                        var X = y;
                        y = q;
                        try {
                            return F()
                        } finally {
                            y = X
                        }
                    }
                    ,
                    t.unstable_scheduleCallback = function(q, F, X) {
                        var $ = t.unstable_now();
                        switch (typeof X == "object" && X !== null ? (X = X.delay,
                        X = typeof X == "number" && 0 < X ? $ + X : $) : X = $,
                        q) {
                        case 1:
                            var ne = -1;
                            break;
                        case 2:
                            ne = 250;
                            break;
                        case 5:
                            ne = 1073741823;
                            break;
                        case 4:
                            ne = 1e4;
                            break;
                        default:
                            ne = 5e3
                        }
                        return ne = X + ne,
                        q = {
                            id: g++,
                            callback: F,
                            priorityLevel: q,
                            startTime: X,
                            expirationTime: ne,
                            sortIndex: -1
                        },
                        X > $ ? (q.sortIndex = X,
                        e(p, q),
                        n(d) === null && q === n(p) && (w ? (R(I),
                        I = -1) : w = !0,
                        oe(U, X - $))) : (q.sortIndex = ne,
                        e(d, q),
                        E || S || (E = !0,
                        z || (z = !0,
                        K()))),
                        q
                    }
                    ,
                    t.unstable_shouldYield = P,
                    t.unstable_wrapCallback = function(q) {
                        var F = y;
                        return function() {
                            var X = y;
                            y = F;
                            try {
                                return q.apply(this, arguments)
                            } finally {
                                y = X
                            }
                        }
                    }
                }
                ))
                  , zN = ln(( (t, e) => {
                    e.exports = IN()
                }
                ));
                var BN = ln((t => {
                    var e = Sd();
                    function n(p) {
                        var g = "https://react.dev/errors/" + p;
                        if (1 < arguments.length) {
                            g += "?args[]=" + encodeURIComponent(arguments[1]);
                            for (var v = 2; v < arguments.length; v++)
                                g += "&args[]=" + encodeURIComponent(arguments[v])
                        }
                        return "Minified React error #" + p + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                    }
                    function i() {}
                    var a = {
                        d: {
                            f: i,
                            r: function() {
                                throw Error(n(522))
                            },
                            D: i,
                            C: i,
                            L: i,
                            m: i,
                            X: i,
                            S: i,
                            M: i
                        },
                        p: 0,
                        findDOMNode: null
                    }
                      , o = Symbol.for("react.portal");
                    function u(p, g, v) {
                        var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                        return {
                            $$typeof: o,
                            key: y == null ? null : "" + y,
                            children: p,
                            containerInfo: g,
                            implementation: v
                        }
                    }
                    var f = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
                    function d(p, g) {
                        if (p === "font")
                            return "";
                        if (typeof g == "string")
                            return g === "use-credentials" ? g : ""
                    }
                    t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = a,
                    t.createPortal = function(p, g) {
                        var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
                        if (!g || g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11)
                            throw Error(n(299));
                        return u(p, g, null, v)
                    }
                    ,
                    t.flushSync = function(p) {
                        var g = f.T
                          , v = a.p;
                        try {
                            if (f.T = null,
                            a.p = 2,
                            p)
                                return p()
                        } finally {
                            f.T = g,
                            a.p = v,
                            a.d.f()
                        }
                    }
                    ,
                    t.preconnect = function(p, g) {
                        typeof p == "string" && (g ? (g = g.crossOrigin,
                        g = typeof g == "string" ? g === "use-credentials" ? g : "" : void 0) : g = null,
                        a.d.C(p, g))
                    }
                    ,
                    t.prefetchDNS = function(p) {
                        typeof p == "string" && a.d.D(p)
                    }
                    ,
                    t.preinit = function(p, g) {
                        if (typeof p == "string" && g && typeof g.as == "string") {
                            var v = g.as
                              , y = d(v, g.crossOrigin)
                              , S = typeof g.integrity == "string" ? g.integrity : void 0
                              , E = typeof g.fetchPriority == "string" ? g.fetchPriority : void 0;
                            v === "style" ? a.d.S(p, typeof g.precedence == "string" ? g.precedence : void 0, {
                                crossOrigin: y,
                                integrity: S,
                                fetchPriority: E
                            }) : v === "script" && a.d.X(p, {
                                crossOrigin: y,
                                integrity: S,
                                fetchPriority: E,
                                nonce: typeof g.nonce == "string" ? g.nonce : void 0
                            })
                        }
                    }
                    ,
                    t.preinitModule = function(p, g) {
                        if (typeof p == "string")
                            if (typeof g == "object" && g !== null) {
                                if (g.as == null || g.as === "script") {
                                    var v = d(g.as, g.crossOrigin);
                                    a.d.M(p, {
                                        crossOrigin: v,
                                        integrity: typeof g.integrity == "string" ? g.integrity : void 0,
                                        nonce: typeof g.nonce == "string" ? g.nonce : void 0
                                    })
                                }
                            } else
                                g ?? a.d.M(p)
                    }
                    ,
                    t.preload = function(p, g) {
                        if (typeof p == "string" && typeof g == "object" && g !== null && typeof g.as == "string") {
                            var v = g.as
                              , y = d(v, g.crossOrigin);
                            a.d.L(p, v, {
                                crossOrigin: y,
                                integrity: typeof g.integrity == "string" ? g.integrity : void 0,
                                nonce: typeof g.nonce == "string" ? g.nonce : void 0,
                                type: typeof g.type == "string" ? g.type : void 0,
                                fetchPriority: typeof g.fetchPriority == "string" ? g.fetchPriority : void 0,
                                referrerPolicy: typeof g.referrerPolicy == "string" ? g.referrerPolicy : void 0,
                                imageSrcSet: typeof g.imageSrcSet == "string" ? g.imageSrcSet : void 0,
                                imageSizes: typeof g.imageSizes == "string" ? g.imageSizes : void 0,
                                media: typeof g.media == "string" ? g.media : void 0
                            })
                        }
                    }
                    ,
                    t.preloadModule = function(p, g) {
                        if (typeof p == "string")
                            if (g) {
                                var v = d(g.as, g.crossOrigin);
                                a.d.m(p, {
                                    as: typeof g.as == "string" && g.as !== "script" ? g.as : void 0,
                                    crossOrigin: v,
                                    integrity: typeof g.integrity == "string" ? g.integrity : void 0
                                })
                            } else
                                a.d.m(p)
                    }
                    ,
                    t.requestFormReset = function(p) {
                        a.d.r(p)
                    }
                    ,
                    t.unstable_batchedUpdates = function(p, g) {
                        return p(g)
                    }
                    ,
                    t.useFormState = function(p, g, v) {
                        return f.H.useFormState(p, g, v)
                    }
                    ,
                    t.useFormStatus = function() {
                        return f.H.useHostTransitionStatus()
                    }
                    ,
                    t.version = "19.2.3"
                }
                ))
                  , PN = ln(( (t, e) => {
                    function n() {
                        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                            try {
                                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                            } catch (i) {
                                console.error(i)
                            }
                    }
                    n(),
                    e.exports = BN()
                }
                ));
                var VN = ln((t => {
                    var e = zN()
                      , n = Sd()
                      , i = PN();
                    function a(s) {
                        var r = "https://react.dev/errors/" + s;
                        if (1 < arguments.length) {
                            r += "?args[]=" + encodeURIComponent(arguments[1]);
                            for (var h = 2; h < arguments.length; h++)
                                r += "&args[]=" + encodeURIComponent(arguments[h])
                        }
                        return "Minified React error #" + s + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                    }
                    function o(s) {
                        return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11)
                    }
                    function u(s) {
                        var r = s
                          , h = s;
                        if (s.alternate)
                            for (; r.return; )
                                r = r.return;
                        else {
                            s = r;
                            do
                                r = s,
                                (r.flags & 4098) !== 0 && (h = r.return),
                                s = r.return;
                            while (s)
                        }
                        return r.tag === 3 ? h : null
                    }
                    function f(s) {
                        if (s.tag === 13) {
                            var r = s.memoizedState;
                            if (r === null && (s = s.alternate,
                            s !== null && (r = s.memoizedState)),
                            r !== null)
                                return r.dehydrated
                        }
                        return null
                    }
                    function d(s) {
                        if (s.tag === 31) {
                            var r = s.memoizedState;
                            if (r === null && (s = s.alternate,
                            s !== null && (r = s.memoizedState)),
                            r !== null)
                                return r.dehydrated
                        }
                        return null
                    }
                    function p(s) {
                        if (u(s) !== s)
                            throw Error(a(188))
                    }
                    function g(s) {
                        var r = s.alternate;
                        if (!r) {
                            if (r = u(s),
                            r === null)
                                throw Error(a(188));
                            return r !== s ? null : s
                        }
                        for (var h = s, m = r; ; ) {
                            var x = h.return;
                            if (x === null)
                                break;
                            var b = x.alternate;
                            if (b === null) {
                                if (m = x.return,
                                m !== null) {
                                    h = m;
                                    continue
                                }
                                break
                            }
                            if (x.child === b.child) {
                                for (b = x.child; b; ) {
                                    if (b === h)
                                        return p(x),
                                        s;
                                    if (b === m)
                                        return p(x),
                                        r;
                                    b = b.sibling
                                }
                                throw Error(a(188))
                            }
                            if (h.return !== m.return)
                                h = x,
                                m = b;
                            else {
                                for (var L = !1, W = x.child; W; ) {
                                    if (W === h) {
                                        L = !0,
                                        h = x,
                                        m = b;
                                        break
                                    }
                                    if (W === m) {
                                        L = !0,
                                        m = x,
                                        h = b;
                                        break
                                    }
                                    W = W.sibling
                                }
                                if (!L) {
                                    for (W = b.child; W; ) {
                                        if (W === h) {
                                            L = !0,
                                            h = b,
                                            m = x;
                                            break
                                        }
                                        if (W === m) {
                                            L = !0,
                                            m = b,
                                            h = x;
                                            break
                                        }
                                        W = W.sibling
                                    }
                                    if (!L)
                                        throw Error(a(189))
                                }
                            }
                            if (h.alternate !== m)
                                throw Error(a(190))
                        }
                        if (h.tag !== 3)
                            throw Error(a(188));
                        return h.stateNode.current === h ? s : r
                    }
                    function v(s) {
                        var r = s.tag;
                        if (r === 5 || r === 26 || r === 27 || r === 6)
                            return s;
                        for (s = s.child; s !== null; ) {
                            if (r = v(s),
                            r !== null)
                                return r;
                            s = s.sibling
                        }
                        return null
                    }
                    var y = Object.assign
                      , S = Symbol.for("react.element")
                      , E = Symbol.for("react.transitional.element")
                      , w = Symbol.for("react.portal")
                      , A = Symbol.for("react.fragment")
                      , T = Symbol.for("react.strict_mode")
                      , R = Symbol.for("react.profiler")
                      , N = Symbol.for("react.consumer")
                      , D = Symbol.for("react.context")
                      , U = Symbol.for("react.forward_ref")
                      , z = Symbol.for("react.suspense")
                      , I = Symbol.for("react.suspense_list")
                      , V = Symbol.for("react.memo")
                      , B = Symbol.for("react.lazy")
                      , P = Symbol.for("react.activity")
                      , G = Symbol.for("react.memo_cache_sentinel")
                      , K = Symbol.iterator;
                    function ee(s) {
                        return s === null || typeof s != "object" ? null : (s = K && s[K] || s["@@iterator"],
                        typeof s == "function" ? s : null)
                    }
                    var te = Symbol.for("react.client.reference");
                    function oe(s) {
                        if (s == null)
                            return null;
                        if (typeof s == "function")
                            return s.$$typeof === te ? null : s.displayName || s.name || null;
                        if (typeof s == "string")
                            return s;
                        switch (s) {
                        case A:
                            return "Fragment";
                        case R:
                            return "Profiler";
                        case T:
                            return "StrictMode";
                        case z:
                            return "Suspense";
                        case I:
                            return "SuspenseList";
                        case P:
                            return "Activity"
                        }
                        if (typeof s == "object")
                            switch (s.$$typeof) {
                            case w:
                                return "Portal";
                            case D:
                                return s.displayName || "Context";
                            case N:
                                return (s._context.displayName || "Context") + ".Consumer";
                            case U:
                                var r = s.render;
                                return s = s.displayName,
                                s || (s = r.displayName || r.name || "",
                                s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"),
                                s;
                            case V:
                                return r = s.displayName || null,
                                r !== null ? r : oe(s.type) || "Memo";
                            case B:
                                r = s._payload,
                                s = s._init;
                                try {
                                    return oe(s(r))
                                } catch {}
                            }
                        return null
                    }
                    var q = Array.isArray
                      , F = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                      , X = i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                      , $ = {
                        pending: !1,
                        data: null,
                        method: null,
                        action: null
                    }
                      , ne = []
                      , ce = -1;
                    function k(s) {
                        return {
                            current: s
                        }
                    }
                    function pe(s) {
                        0 > ce || (s.current = ne[ce],
                        ne[ce] = null,
                        ce--)
                    }
                    function Ae(s, r) {
                        ce++,
                        ne[ce] = s.current,
                        s.current = r
                    }
                    var ie = k(null)
                      , Me = k(null)
                      , we = k(null)
                      , Te = k(null);
                    function Je(s, r) {
                        switch (Ae(we, r),
                        Ae(Me, s),
                        Ae(ie, null),
                        r.nodeType) {
                        case 9:
                        case 11:
                            s = (s = r.documentElement) && (s = s.namespaceURI) ? NT(s) : 0;
                            break;
                        default:
                            if (s = r.tagName,
                            r = r.namespaceURI)
                                r = NT(r),
                                s = DT(r, s);
                            else
                                switch (s) {
                                case "svg":
                                    s = 1;
                                    break;
                                case "math":
                                    s = 2;
                                    break;
                                default:
                                    s = 0
                                }
                        }
                        pe(ie),
                        Ae(ie, s)
                    }
                    function Ze() {
                        pe(ie),
                        pe(Me),
                        pe(we)
                    }
                    function Ct(s) {
                        s.memoizedState !== null && Ae(Te, s);
                        var r = ie.current
                          , h = DT(r, s.type);
                        r !== h && (Ae(Me, s),
                        Ae(ie, h))
                    }
                    function bt(s) {
                        Me.current === s && (pe(ie),
                        pe(Me)),
                        Te.current === s && (pe(Te),
                        Km._currentValue = $)
                    }
                    var Ue, ve;
                    function Ce(s) {
                        if (Ue === void 0)
                            try {
                                throw Error()
                            } catch (h) {
                                var r = h.stack.trim().match(/\n( *(at )?)/);
                                Ue = r && r[1] || "",
                                ve = -1 < h.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < h.stack.indexOf("@") ? "@unknown:0:0" : ""
                            }
                        return `
` + Ue + s + ve
                    }
                    var qe = !1;
                    function Q(s, r) {
                        if (!s || qe)
                            return "";
                        qe = !0;
                        var h = Error.prepareStackTrace;
                        Error.prepareStackTrace = void 0;
                        try {
                            var m = {
                                DetermineComponentFrameRoot: function() {
                                    try {
                                        if (r) {
                                            var Fe = function() {
                                                throw Error()
                                            };
                                            if (Object.defineProperty(Fe.prototype, "props", {
                                                set: function() {
                                                    throw Error()
                                                }
                                            }),
                                            typeof Reflect == "object" && Reflect.construct) {
                                                try {
                                                    Reflect.construct(Fe, [])
                                                } catch (Ne) {
                                                    var Ee = Ne
                                                }
                                                Reflect.construct(s, [], Fe)
                                            } else {
                                                try {
                                                    Fe.call()
                                                } catch (Ne) {
                                                    Ee = Ne
                                                }
                                                s.call(Fe.prototype)
                                            }
                                        } else {
                                            try {
                                                throw Error()
                                            } catch (Ne) {
                                                Ee = Ne
                                            }
                                            (Fe = s()) && typeof Fe.catch == "function" && Fe.catch(function() {})
                                        }
                                    } catch (Ne) {
                                        if (Ne && Ee && typeof Ne.stack == "string")
                                            return [Ne.stack, Ee.stack]
                                    }
                                    return [null, null]
                                }
                            };
                            m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                            var x = Object.getOwnPropertyDescriptor(m.DetermineComponentFrameRoot, "name");
                            x && x.configurable && Object.defineProperty(m.DetermineComponentFrameRoot, "name", {
                                value: "DetermineComponentFrameRoot"
                            });
                            var b = m.DetermineComponentFrameRoot()
                              , L = b[0]
                              , W = b[1];
                            if (L && W) {
                                var ae = L.split(`
`)
                                  , be = W.split(`
`);
                                for (x = m = 0; m < ae.length && !ae[m].includes("DetermineComponentFrameRoot"); )
                                    m++;
                                for (; x < be.length && !be[x].includes("DetermineComponentFrameRoot"); )
                                    x++;
                                if (m === ae.length || x === be.length)
                                    for (m = ae.length - 1,
                                    x = be.length - 1; 1 <= m && 0 <= x && ae[m] !== be[x]; )
                                        x--;
                                for (; 1 <= m && 0 <= x; m--,
                                x--)
                                    if (ae[m] !== be[x]) {
                                        if (m !== 1 || x !== 1)
                                            do
                                                if (m--,
                                                x--,
                                                0 > x || ae[m] !== be[x]) {
                                                    var ze = `
` + ae[m].replace(" at new ", " at ");
                                                    return s.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", s.displayName)),
                                                    ze
                                                }
                                            while (1 <= m && 0 <= x);
                                        break
                                    }
                            }
                        } finally {
                            qe = !1,
                            Error.prepareStackTrace = h
                        }
                        return (h = s ? s.displayName || s.name : "") ? Ce(h) : ""
                    }
                    function Ke(s, r) {
                        switch (s.tag) {
                        case 26:
                        case 27:
                        case 5:
                            return Ce(s.type);
                        case 16:
                            return Ce("Lazy");
                        case 13:
                            return s.child !== r && r !== null ? Ce("Suspense Fallback") : Ce("Suspense");
                        case 19:
                            return Ce("SuspenseList");
                        case 0:
                        case 15:
                            return Q(s.type, !1);
                        case 11:
                            return Q(s.type.render, !1);
                        case 1:
                            return Q(s.type, !0);
                        case 31:
                            return Ce("Activity");
                        default:
                            return ""
                        }
                    }
                    function Ve(s) {
                        try {
                            var r = ""
                              , h = null;
                            do
                                r += Ke(s, h),
                                h = s,
                                s = s.return;
                            while (s);
                            return r
                        } catch (m) {
                            return `
Error generating stack: ` + m.message + `
` + m.stack
                        }
                    }
                    var ft = Object.prototype.hasOwnProperty
                      , ke = e.unstable_scheduleCallback
                      , Nt = e.unstable_cancelCallback
                      , Z = e.unstable_shouldYield
                      , H = e.unstable_requestPaint
                      , he = e.unstable_now
                      , Le = e.unstable_getCurrentPriorityLevel
                      , He = e.unstable_ImmediatePriority
                      , Oe = e.unstable_UserBlockingPriority
                      , pt = e.unstable_NormalPriority
                      , et = e.unstable_LowPriority
                      , xt = e.unstable_IdlePriority
                      , Dt = e.log
                      , je = e.unstable_setDisableYieldValue
                      , Xe = null
                      , nt = null;
                    function ot(s) {
                        if (typeof Dt == "function" && je(s),
                        nt && typeof nt.setStrictMode == "function")
                            try {
                                nt.setStrictMode(Xe, s)
                            } catch {}
                    }
                    var tt = Math.clz32 ? Math.clz32 : it
                      , Gt = Math.log
                      , le = Math.LN2;
                    function it(s) {
                        return s >>>= 0,
                        s === 0 ? 32 : 31 - (Gt(s) / le | 0) | 0
                    }
                    var Qe = 256
                      , dt = 262144
                      , We = 4194304;
                    function De(s) {
                        var r = s & 42;
                        if (r !== 0)
                            return r;
                        switch (s & -s) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                            return 64;
                        case 128:
                            return 128;
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                            return s & 261888;
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return s & 3932160;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            return s & 62914560;
                        case 67108864:
                            return 67108864;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 0;
                        default:
                            return s
                        }
                    }
                    function mt(s, r, h) {
                        var m = s.pendingLanes;
                        if (m === 0)
                            return 0;
                        var x = 0
                          , b = s.suspendedLanes
                          , L = s.pingedLanes;
                        s = s.warmLanes;
                        var W = m & 134217727;
                        return W !== 0 ? (m = W & ~b,
                        m !== 0 ? x = De(m) : (L &= W,
                        L !== 0 ? x = De(L) : h || (h = W & ~s,
                        h !== 0 && (x = De(h))))) : (W = m & ~b,
                        W !== 0 ? x = De(W) : L !== 0 ? x = De(L) : h || (h = m & ~s,
                        h !== 0 && (x = De(h)))),
                        x === 0 ? 0 : r !== 0 && r !== x && (r & b) === 0 && (b = x & -x,
                        h = r & -r,
                        b >= h || b === 32 && (h & 4194048) !== 0) ? r : x
                    }
                    function Tt(s, r) {
                        return (s.pendingLanes & ~(s.suspendedLanes & ~s.pingedLanes) & r) === 0
                    }
                    function si(s, r) {
                        switch (s) {
                        case 1:
                        case 2:
                        case 4:
                        case 8:
                        case 64:
                            return r + 250;
                        case 16:
                        case 32:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return r + 5e3;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            return -1;
                        case 67108864:
                        case 134217728:
                        case 268435456:
                        case 536870912:
                        case 1073741824:
                            return -1;
                        default:
                            return -1
                        }
                    }
                    function pn() {
                        var s = We;
                        return We <<= 1,
                        (We & 62914560) === 0 && (We = 4194304),
                        s
                    }
                    function cs(s) {
                        for (var r = [], h = 0; 31 > h; h++)
                            r.push(s);
                        return r
                    }
                    function ys(s, r) {
                        s.pendingLanes |= r,
                        r !== 268435456 && (s.suspendedLanes = 0,
                        s.pingedLanes = 0,
                        s.warmLanes = 0)
                    }
                    function Tu(s, r, h, m, x, b) {
                        var L = s.pendingLanes;
                        s.pendingLanes = h,
                        s.suspendedLanes = 0,
                        s.pingedLanes = 0,
                        s.warmLanes = 0,
                        s.expiredLanes &= h,
                        s.entangledLanes &= h,
                        s.errorRecoveryDisabledLanes &= h,
                        s.shellSuspendCounter = 0;
                        var W = s.entanglements
                          , ae = s.expirationTimes
                          , be = s.hiddenUpdates;
                        for (h = L & ~h; 0 < h; ) {
                            var ze = 31 - tt(h)
                              , Fe = 1 << ze;
                            W[ze] = 0,
                            ae[ze] = -1;
                            var Ee = be[ze];
                            if (Ee !== null)
                                for (be[ze] = null,
                                ze = 0; ze < Ee.length; ze++) {
                                    var Ne = Ee[ze];
                                    Ne !== null && (Ne.lane &= -536870913)
                                }
                            h &= ~Fe
                        }
                        m !== 0 && xl(s, m, 0),
                        b !== 0 && x === 0 && s.tag !== 0 && (s.suspendedLanes |= b & ~(L & ~r))
                    }
                    function xl(s, r, h) {
                        s.pendingLanes |= r,
                        s.suspendedLanes &= ~r;
                        var m = 31 - tt(r);
                        s.entangledLanes |= r,
                        s.entanglements[m] = s.entanglements[m] | 1073741824 | h & 261930
                    }
                    function vc(s, r) {
                        var h = s.entangledLanes |= r;
                        for (s = s.entanglements; h; ) {
                            var m = 31 - tt(h)
                              , x = 1 << m;
                            x & r | s[m] & r && (s[m] |= r),
                            h &= ~x
                        }
                    }
                    function Ml(s, r) {
                        var h = r & -r;
                        return h = (h & 42) !== 0 ? 1 : ba(h),
                        (h & (s.suspendedLanes | r)) !== 0 ? 0 : h
                    }
                    function ba(s) {
                        switch (s) {
                        case 2:
                            s = 1;
                            break;
                        case 8:
                            s = 4;
                            break;
                        case 32:
                            s = 16;
                            break;
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            s = 128;
                            break;
                        case 268435456:
                            s = 134217728;
                            break;
                        default:
                            s = 0
                        }
                        return s
                    }
                    function Ta(s) {
                        return s &= -s,
                        2 < s ? 8 < s ? (s & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                    }
                    function Ks() {
                        var s = X.p;
                        return s !== 0 ? s : (s = window.event,
                        s === void 0 ? 32 : JT(s.type))
                    }
                    function Js(s, r) {
                        var h = X.p;
                        try {
                            return X.p = s,
                            r()
                        } finally {
                            X.p = h
                        }
                    }
                    var Rs = Math.random().toString(36).slice(2)
                      , Zt = "__reactFiber$" + Rs
                      , Oi = "__reactProps$" + Rs
                      , Aa = "__reactContainer$" + Rs
                      , bl = "__reactEvents$" + Rs
                      , Au = "__reactListeners$" + Rs
                      , Op = "__reactHandles$" + Rs
                      , _c = "__reactResources$" + Rs
                      , Gr = "__reactMarker$" + Rs;
                    function Tl(s) {
                        delete s[Zt],
                        delete s[Oi],
                        delete s[bl],
                        delete s[Au],
                        delete s[Op]
                    }
                    function yi(s) {
                        var r = s[Zt];
                        if (r)
                            return r;
                        for (var h = s.parentNode; h; ) {
                            if (r = h[Aa] || h[Zt]) {
                                if (h = r.alternate,
                                r.child !== null || h !== null && h.child !== null)
                                    for (s = PT(s); s !== null; ) {
                                        if (h = s[Zt])
                                            return h;
                                        s = PT(s)
                                    }
                                return r
                            }
                            s = h,
                            h = s.parentNode
                        }
                        return null
                    }
                    function Fn(s) {
                        if (s = s[Zt] || s[Aa]) {
                            var r = s.tag;
                            if (r === 5 || r === 6 || r === 13 || r === 31 || r === 26 || r === 27 || r === 3)
                                return s
                        }
                        return null
                    }
                    function Y(s) {
                        var r = s.tag;
                        if (r === 5 || r === 26 || r === 27 || r === 6)
                            return s.stateNode;
                        throw Error(a(33))
                    }
                    function ue(s) {
                        var r = s[_c];
                        return r || (r = s[_c] = {
                            hoistableStyles: new Map,
                            hoistableScripts: new Map
                        }),
                        r
                    }
                    function _e(s) {
                        s[Gr] = !0
                    }
                    var Se = new Set
                      , me = {};
                    function Ye(s, r) {
                        st(s, r),
                        st(s + "Capture", r)
                    }
                    function st(s, r) {
                        for (me[s] = r,
                        s = 0; s < r.length; s++)
                            Se.add(r[s])
                    }
                    var vt = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
                      , ht = {}
                      , It = {};
                    function Vt(s) {
                        return ft.call(It, s) ? !0 : ft.call(ht, s) ? !1 : vt.test(s) ? It[s] = !0 : (ht[s] = !0,
                        !1)
                    }
                    function wt(s, r, h) {
                        if (Vt(r))
                            if (h === null)
                                s.removeAttribute(r);
                            else {
                                switch (typeof h) {
                                case "undefined":
                                case "function":
                                case "symbol":
                                    s.removeAttribute(r);
                                    return;
                                case "boolean":
                                    var m = r.toLowerCase().slice(0, 5);
                                    if (m !== "data-" && m !== "aria-") {
                                        s.removeAttribute(r);
                                        return
                                    }
                                }
                                s.setAttribute(r, "" + h)
                            }
                    }
                    function tn(s, r, h) {
                        if (h === null)
                            s.removeAttribute(r);
                        else {
                            switch (typeof h) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                                s.removeAttribute(r);
                                return
                            }
                            s.setAttribute(r, "" + h)
                        }
                    }
                    function rn(s, r, h, m) {
                        if (m === null)
                            s.removeAttribute(h);
                        else {
                            switch (typeof m) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                                s.removeAttribute(h);
                                return
                            }
                            s.setAttributeNS(r, h, "" + m)
                        }
                    }
                    function cn(s) {
                        switch (typeof s) {
                        case "bigint":
                        case "boolean":
                        case "number":
                        case "string":
                        case "undefined":
                            return s;
                        case "object":
                            return s;
                        default:
                            return ""
                        }
                    }
                    function $n(s) {
                        var r = s.type;
                        return (s = s.nodeName) && s.toLowerCase() === "input" && (r === "checkbox" || r === "radio")
                    }
                    function vn(s, r, h) {
                        var m = Object.getOwnPropertyDescriptor(s.constructor.prototype, r);
                        if (!s.hasOwnProperty(r) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
                            var x = m.get
                              , b = m.set;
                            return Object.defineProperty(s, r, {
                                configurable: !0,
                                get: function() {
                                    return x.call(this)
                                },
                                set: function(L) {
                                    h = "" + L,
                                    b.call(this, L)
                                }
                            }),
                            Object.defineProperty(s, r, {
                                enumerable: m.enumerable
                            }),
                            {
                                getValue: function() {
                                    return h
                                },
                                setValue: function(L) {
                                    h = "" + L
                                },
                                stopTracking: function() {
                                    s._valueTracker = null,
                                    delete s[r]
                                }
                            }
                        }
                    }
                    function At(s) {
                        if (!s._valueTracker) {
                            var r = $n(s) ? "checked" : "value";
                            s._valueTracker = vn(s, r, "" + s[r])
                        }
                    }
                    function Hn(s) {
                        if (!s)
                            return !1;
                        var r = s._valueTracker;
                        if (!r)
                            return !0;
                        var h = r.getValue()
                          , m = "";
                        return s && (m = $n(s) ? s.checked ? "true" : "false" : s.value),
                        s = m,
                        s !== h ? (r.setValue(s),
                        !0) : !1
                    }
                    function un(s) {
                        if (s = s || (typeof document < "u" ? document : void 0),
                        typeof s > "u")
                            return null;
                        try {
                            return s.activeElement || s.body
                        } catch {
                            return s.body
                        }
                    }
                    var Ns = /[\n"\\]/g;
                    function Ti(s) {
                        return s.replace(Ns, function(r) {
                            return "\\" + r.charCodeAt(0).toString(16) + " "
                        })
                    }
                    function qi(s, r, h, m, x, b, L, W) {
                        s.name = "",
                        L != null && typeof L != "function" && typeof L != "symbol" && typeof L != "boolean" ? s.type = L : s.removeAttribute("type"),
                        r != null ? L === "number" ? (r === 0 && s.value === "" || s.value != r) && (s.value = "" + cn(r)) : s.value !== "" + cn(r) && (s.value = "" + cn(r)) : L !== "submit" && L !== "reset" || s.removeAttribute("value"),
                        r != null ? wn(s, L, cn(r)) : h != null ? wn(s, L, cn(h)) : m != null && s.removeAttribute("value"),
                        x == null && b != null && (s.defaultChecked = !!b),
                        x != null && (s.checked = x && typeof x != "function" && typeof x != "symbol"),
                        W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" ? s.name = "" + cn(W) : s.removeAttribute("name")
                    }
                    function kr(s, r, h, m, x, b, L, W) {
                        if (b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" && (s.type = b),
                        r != null || h != null) {
                            if (!(b !== "submit" && b !== "reset" || r != null)) {
                                At(s);
                                return
                            }
                            h = h != null ? "" + cn(h) : "",
                            r = r != null ? "" + cn(r) : h,
                            W || r === s.value || (s.value = r),
                            s.defaultValue = r
                        }
                        m = m ?? x,
                        m = typeof m != "function" && typeof m != "symbol" && !!m,
                        s.checked = W ? s.checked : !!m,
                        s.defaultChecked = !!m,
                        L != null && typeof L != "function" && typeof L != "symbol" && typeof L != "boolean" && (s.name = L),
                        At(s)
                    }
                    function wn(s, r, h) {
                        r === "number" && un(s.ownerDocument) === s || s.defaultValue === "" + h || (s.defaultValue = "" + h)
                    }
                    function Si(s, r, h, m) {
                        if (s = s.options,
                        r) {
                            r = {};
                            for (var x = 0; x < h.length; x++)
                                r["$" + h[x]] = !0;
                            for (h = 0; h < s.length; h++)
                                x = r.hasOwnProperty("$" + s[h].value),
                                s[h].selected !== x && (s[h].selected = x),
                                x && m && (s[h].defaultSelected = !0)
                        } else {
                            for (h = "" + cn(h),
                            r = null,
                            x = 0; x < s.length; x++) {
                                if (s[x].value === h) {
                                    s[x].selected = !0,
                                    m && (s[x].defaultSelected = !0);
                                    return
                                }
                                r !== null || s[x].disabled || (r = s[x])
                            }
                            r !== null && (r.selected = !0)
                        }
                    }
                    function us(s, r, h) {
                        if (r != null && (r = "" + cn(r),
                        r !== s.value && (s.value = r),
                        h == null)) {
                            s.defaultValue !== r && (s.defaultValue = r);
                            return
                        }
                        s.defaultValue = h != null ? "" + cn(h) : ""
                    }
                    function ei(s, r, h, m) {
                        if (r == null) {
                            if (m != null) {
                                if (h != null)
                                    throw Error(a(92));
                                if (q(m)) {
                                    if (1 < m.length)
                                        throw Error(a(93));
                                    m = m[0]
                                }
                                h = m
                            }
                            h ??= "",
                            r = h
                        }
                        h = cn(r),
                        s.defaultValue = h,
                        m = s.textContent,
                        m === h && m !== "" && m !== null && (s.value = m),
                        At(s)
                    }
                    function Ui(s, r) {
                        if (r) {
                            var h = s.firstChild;
                            if (h && h === s.lastChild && h.nodeType === 3) {
                                h.nodeValue = r;
                                return
                            }
                        }
                        s.textContent = r
                    }
                    var wo = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
                    function $s(s, r, h) {
                        var m = r.indexOf("--") === 0;
                        h == null || typeof h == "boolean" || h === "" ? m ? s.setProperty(r, "") : r === "float" ? s.cssFloat = "" : s[r] = "" : m ? s.setProperty(r, h) : typeof h != "number" || h === 0 || wo.has(r) ? r === "float" ? s.cssFloat = h : s[r] = ("" + h).trim() : s[r] = h + "px"
                    }
                    function Up(s, r, h) {
                        if (r != null && typeof r != "object")
                            throw Error(a(62));
                        if (s = s.style,
                        h != null) {
                            for (var m in h)
                                !h.hasOwnProperty(m) || r != null && r.hasOwnProperty(m) || (m.indexOf("--") === 0 ? s.setProperty(m, "") : m === "float" ? s.cssFloat = "" : s[m] = "");
                            for (var x in r)
                                m = r[x],
                                r.hasOwnProperty(x) && h[x] !== m && $s(s, x, m)
                        } else
                            for (var b in r)
                                r.hasOwnProperty(b) && $s(s, b, r[b])
                    }
                    function Eu(s) {
                        if (s.indexOf("-") === -1)
                            return !1;
                        switch (s) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                        }
                    }
                    var mv = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
                      , gv = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
                    function Cu(s) {
                        return gv.test("" + s) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : s
                    }
                    function ur() {}
                    var wu = null;
                    function lf(s) {
                        return s = s.target || s.srcElement || window,
                        s.correspondingUseElement && (s = s.correspondingUseElement),
                        s.nodeType === 3 ? s.parentNode : s
                    }
                    var Al = null
                      , Ro = null;
                    function Lp(s) {
                        var r = Fn(s);
                        if (r && (s = r.stateNode)) {
                            var h = s[Oi] || null;
                            e: switch (s = r.stateNode,
                            r.type) {
                            case "input":
                                if (qi(s, h.value, h.defaultValue, h.defaultValue, h.checked, h.defaultChecked, h.type, h.name),
                                r = h.name,
                                h.type === "radio" && r != null) {
                                    for (h = s; h.parentNode; )
                                        h = h.parentNode;
                                    for (h = h.querySelectorAll('input[name="' + Ti("" + r) + '"][type="radio"]'),
                                    r = 0; r < h.length; r++) {
                                        var m = h[r];
                                        if (m !== s && m.form === s.form) {
                                            var x = m[Oi] || null;
                                            if (!x)
                                                throw Error(a(90));
                                            qi(m, x.value, x.defaultValue, x.defaultValue, x.checked, x.defaultChecked, x.type, x.name)
                                        }
                                    }
                                    for (r = 0; r < h.length; r++)
                                        m = h[r],
                                        m.form === s.form && Hn(m)
                                }
                                break e;
                            case "textarea":
                                us(s, h.value, h.defaultValue);
                                break e;
                            case "select":
                                r = h.value,
                                r != null && Si(s, !!h.multiple, r, !1)
                            }
                        }
                    }
                    var cf = !1;
                    function Ip(s, r, h) {
                        if (cf)
                            return s(r, h);
                        cf = !0;
                        try {
                            return s(r)
                        } finally {
                            if (cf = !1,
                            (Al !== null || Ro !== null) && (el(),
                            Al && (r = Al,
                            s = Ro,
                            Ro = Al = null,
                            Lp(r),
                            s)))
                                for (r = 0; r < s.length; r++)
                                    Lp(s[r])
                        }
                    }
                    function El(s, r) {
                        var h = s.stateNode;
                        if (h === null)
                            return null;
                        var m = h[Oi] || null;
                        if (m === null)
                            return null;
                        h = m[r];
                        e: switch (r) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (m = !m.disabled) || (s = s.type,
                            m = !(s === "button" || s === "input" || s === "select" || s === "textarea")),
                            s = !m;
                            break e;
                        default:
                            s = !1
                        }
                        if (s)
                            return null;
                        if (h && typeof h != "function")
                            throw Error(a(231, r, typeof h));
                        return h
                    }
                    var hr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
                      , uf = !1;
                    if (hr)
                        try {
                            var Ru = {};
                            Object.defineProperty(Ru, "passive", {
                                get: function() {
                                    uf = !0
                                }
                            }),
                            window.addEventListener("test", Ru, Ru),
                            window.removeEventListener("test", Ru, Ru)
                        } catch {
                            uf = !1
                        }
                    var No = null
                      , hf = null
                      , Do = null;
                    function ff() {
                        if (Do)
                            return Do;
                        var s, r = hf, h = r.length, m, x = "value"in No ? No.value : No.textContent, b = x.length;
                        for (s = 0; s < h && r[s] === x[s]; s++)
                            ;
                        var L = h - s;
                        for (m = 1; m <= L && r[h - m] === x[b - m]; m++)
                            ;
                        return Do = x.slice(s, 1 < m ? 1 - m : void 0)
                    }
                    function Cl(s) {
                        var r = s.keyCode;
                        return "charCode"in s ? (s = s.charCode,
                        s === 0 && r === 13 && (s = 13)) : s = r,
                        s === 10 && (s = 13),
                        32 <= s || s === 13 ? s : 0
                    }
                    function Nu() {
                        return !0
                    }
                    function zp() {
                        return !1
                    }
                    function hs(s) {
                        function r(h, m, x, b, L) {
                            this._reactName = h,
                            this._targetInst = x,
                            this.type = m,
                            this.nativeEvent = b,
                            this.target = L,
                            this.currentTarget = null;
                            for (var W in s)
                                s.hasOwnProperty(W) && (h = s[W],
                                this[W] = h ? h(b) : b[W]);
                            return this.isDefaultPrevented = (b.defaultPrevented != null ? b.defaultPrevented : b.returnValue === !1) ? Nu : zp,
                            this.isPropagationStopped = zp,
                            this
                        }
                        return y(r.prototype, {
                            preventDefault: function() {
                                this.defaultPrevented = !0;
                                var h = this.nativeEvent;
                                h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1),
                                this.isDefaultPrevented = Nu)
                            },
                            stopPropagation: function() {
                                var h = this.nativeEvent;
                                h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0),
                                this.isPropagationStopped = Nu)
                            },
                            persist: function() {},
                            isPersistent: Nu
                        }),
                        r
                    }
                    var Oo = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(s) {
                            return s.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    }, Du = hs(Oo), ka = y({}, Oo, {
                        view: 0,
                        detail: 0
                    }), df = hs(ka), pf, Ou, yc, Uu = y({}, ka, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: gf,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(s) {
                            return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget
                        },
                        movementX: function(s) {
                            return "movementX"in s ? s.movementX : (s !== yc && (yc && s.type === "mousemove" ? (pf = s.screenX - yc.screenX,
                            Ou = s.screenY - yc.screenY) : Ou = pf = 0,
                            yc = s),
                            pf)
                        },
                        movementY: function(s) {
                            return "movementY"in s ? s.movementY : Ou
                        }
                    }), vv = hs(Uu), ts = hs(y({}, Uu, {
                        dataTransfer: 0
                    })), mf = hs(y({}, ka, {
                        relatedTarget: 0
                    })), _v = hs(y({}, Oo, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })), yv = hs(y({}, Oo, {
                        clipboardData: function(s) {
                            return "clipboardData"in s ? s.clipboardData : window.clipboardData
                        }
                    })), Bp = hs(y({}, Oo, {
                        data: 0
                    })), Sv = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    }, Lu = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    }, Pp = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };
                    function xv(s) {
                        var r = this.nativeEvent;
                        return r.getModifierState ? r.getModifierState(s) : (s = Pp[s]) ? !!r[s] : !1
                    }
                    function gf() {
                        return xv
                    }
                    var Mv = hs(y({}, ka, {
                        key: function(s) {
                            if (s.key) {
                                var r = Sv[s.key] || s.key;
                                if (r !== "Unidentified")
                                    return r
                            }
                            return s.type === "keypress" ? (s = Cl(s),
                            s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Lu[s.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: gf,
                        charCode: function(s) {
                            return s.type === "keypress" ? Cl(s) : 0
                        },
                        keyCode: function(s) {
                            return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
                        },
                        which: function(s) {
                            return s.type === "keypress" ? Cl(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
                        }
                    }))
                      , vf = hs(y({}, Uu, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    }))
                      , Vp = hs(y({}, ka, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: gf
                    }))
                      , bv = hs(y({}, Oo, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    }))
                      , Fp = hs(y({}, Uu, {
                        deltaX: function(s) {
                            return "deltaX"in s ? s.deltaX : "wheelDeltaX"in s ? -s.wheelDeltaX : 0
                        },
                        deltaY: function(s) {
                            return "deltaY"in s ? s.deltaY : "wheelDeltaY"in s ? -s.wheelDeltaY : "wheelDelta"in s ? -s.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    }))
                      , Hp = hs(y({}, Oo, {
                        newState: 0,
                        oldState: 0
                    }))
                      , Gp = [9, 13, 27, 32]
                      , _f = hr && "CompositionEvent"in window
                      , wl = null;
                    hr && "documentMode"in document && (wl = document.documentMode);
                    var Tv = hr && "TextEvent"in window && !wl
                      , fr = hr && (!_f || wl && 8 < wl && 11 >= wl)
                      , yf = " "
                      , Av = !1;
                    function kp(s, r) {
                        switch (s) {
                        case "keyup":
                            return Gp.indexOf(r.keyCode) !== -1;
                        case "keydown":
                            return r.keyCode !== 229;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    function qr(s) {
                        return s = s.detail,
                        typeof s == "object" && "data"in s ? s.data : null
                    }
                    var Ds = !1;
                    function qp(s, r) {
                        switch (s) {
                        case "compositionend":
                            return qr(r);
                        case "keypress":
                            return r.which !== 32 ? null : (Av = !0,
                            yf);
                        case "textInput":
                            return s = r.data,
                            s === yf && Av ? null : s;
                        default:
                            return null
                        }
                    }
                    function Xp(s, r) {
                        if (Ds)
                            return s === "compositionend" || !_f && kp(s, r) ? (s = ff(),
                            Do = hf = No = null,
                            Ds = !1,
                            s) : null;
                        switch (s) {
                        case "paste":
                            return null;
                        case "keypress":
                            if (!(r.ctrlKey || r.altKey || r.metaKey) || r.ctrlKey && r.altKey) {
                                if (r.char && 1 < r.char.length)
                                    return r.char;
                                if (r.which)
                                    return String.fromCharCode(r.which)
                            }
                            return null;
                        case "compositionend":
                            return fr && r.locale !== "ko" ? null : r.data;
                        default:
                            return null
                        }
                    }
                    var Iu = {
                        color: !0,
                        date: !0,
                        datetime: !0,
                        "datetime-local": !0,
                        email: !0,
                        month: !0,
                        number: !0,
                        password: !0,
                        range: !0,
                        search: !0,
                        tel: !0,
                        text: !0,
                        time: !0,
                        url: !0,
                        week: !0
                    };
                    function zu(s) {
                        var r = s && s.nodeName && s.nodeName.toLowerCase();
                        return r === "input" ? !!Iu[s.type] : r === "textarea"
                    }
                    function Uo(s, r, h, m) {
                        Al ? Ro ? Ro.push(m) : Ro = [m] : Al = m,
                        r = S_(r, "onChange"),
                        0 < r.length && (h = new Du("onChange","change",null,h,m),
                        s.push({
                            event: h,
                            listeners: r
                        }))
                    }
                    var Ai = null
                      , Lo = null;
                    function Ev(s) {
                        bT(s, 0)
                    }
                    function Sc(s) {
                        if (Hn(Y(s)))
                            return s
                    }
                    function xc(s, r) {
                        if (s === "change")
                            return r
                    }
                    var Sf = !1;
                    if (hr) {
                        var Mc;
                        if (hr) {
                            var xf = "oninput"in document;
                            if (!xf) {
                                var Os = document.createElement("div");
                                Os.setAttribute("oninput", "return;"),
                                xf = typeof Os.oninput == "function"
                            }
                            Mc = xf
                        } else
                            Mc = !1;
                        Sf = Mc && (!document.documentMode || 9 < document.documentMode)
                    }
                    function Wp() {
                        Ai && (Ai.detachEvent("onpropertychange", Mf),
                        Lo = Ai = null)
                    }
                    function Mf(s) {
                        if (s.propertyName === "value" && Sc(Lo)) {
                            var r = [];
                            Uo(r, Lo, s, lf(s)),
                            Ip(Ev, r)
                        }
                    }
                    function Cv(s, r, h) {
                        s === "focusin" ? (Wp(),
                        Ai = r,
                        Lo = h,
                        Ai.attachEvent("onpropertychange", Mf)) : s === "focusout" && Wp()
                    }
                    function wv(s) {
                        if (s === "selectionchange" || s === "keyup" || s === "keydown")
                            return Sc(Lo)
                    }
                    function Yp(s, r) {
                        if (s === "click")
                            return Sc(r)
                    }
                    function jp(s, r) {
                        if (s === "input" || s === "change")
                            return Sc(r)
                    }
                    function Rv(s, r) {
                        return s === r && (s !== 0 || 1 / s === 1 / r) || s !== s && r !== r
                    }
                    var fs = typeof Object.is == "function" ? Object.is : Rv;
                    function Xr(s, r) {
                        if (fs(s, r))
                            return !0;
                        if (typeof s != "object" || s === null || typeof r != "object" || r === null)
                            return !1;
                        var h = Object.keys(s)
                          , m = Object.keys(r);
                        if (h.length !== m.length)
                            return !1;
                        for (m = 0; m < h.length; m++) {
                            var x = h[m];
                            if (!ft.call(r, x) || !fs(s[x], r[x]))
                                return !1
                        }
                        return !0
                    }
                    function ai(s) {
                        for (; s && s.firstChild; )
                            s = s.firstChild;
                        return s
                    }
                    function Nv(s, r) {
                        var h = ai(s);
                        s = 0;
                        for (var m; h; ) {
                            if (h.nodeType === 3) {
                                if (m = s + h.textContent.length,
                                s <= r && m >= r)
                                    return {
                                        node: h,
                                        offset: r - s
                                    };
                                s = m
                            }
                            e: {
                                for (; h; ) {
                                    if (h.nextSibling) {
                                        h = h.nextSibling;
                                        break e
                                    }
                                    h = h.parentNode
                                }
                                h = void 0
                            }
                            h = ai(h)
                        }
                    }
                    function Dv(s, r) {
                        return s && r ? s === r ? !0 : s && s.nodeType === 3 ? !1 : r && r.nodeType === 3 ? Dv(s, r.parentNode) : "contains"in s ? s.contains(r) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(r) & 16) : !1 : !1
                    }
                    function Zp(s) {
                        s = s != null && s.ownerDocument != null && s.ownerDocument.defaultView != null ? s.ownerDocument.defaultView : window;
                        for (var r = un(s.document); r instanceof s.HTMLIFrameElement; ) {
                            try {
                                var h = typeof r.contentWindow.location.href == "string"
                            } catch {
                                h = !1
                            }
                            if (h)
                                s = r.contentWindow;
                            else
                                break;
                            r = un(s.document)
                        }
                        return r
                    }
                    function Rl(s) {
                        var r = s && s.nodeName && s.nodeName.toLowerCase();
                        return r && (r === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || r === "textarea" || s.contentEditable === "true")
                    }
                    var Io = hr && "documentMode"in document && 11 >= document.documentMode
                      , Nl = null
                      , bf = null
                      , qa = null
                      , Ss = !1;
                    function Qp(s, r, h) {
                        var m = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument;
                        Ss || Nl == null || Nl !== un(m) || (m = Nl,
                        "selectionStart"in m && Rl(m) ? m = {
                            start: m.selectionStart,
                            end: m.selectionEnd
                        } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(),
                        m = {
                            anchorNode: m.anchorNode,
                            anchorOffset: m.anchorOffset,
                            focusNode: m.focusNode,
                            focusOffset: m.focusOffset
                        }),
                        qa && Xr(qa, m) || (qa = m,
                        m = S_(bf, "onSelect"),
                        0 < m.length && (r = new Du("onSelect","select",null,r,h),
                        s.push({
                            event: r,
                            listeners: m
                        }),
                        r.target = Nl)))
                    }
                    function zo(s, r) {
                        var h = {};
                        return h[s.toLowerCase()] = r.toLowerCase(),
                        h["Webkit" + s] = "webkit" + r,
                        h["Moz" + s] = "moz" + r,
                        h
                    }
                    var Dl = {
                        animationend: zo("Animation", "AnimationEnd"),
                        animationiteration: zo("Animation", "AnimationIteration"),
                        animationstart: zo("Animation", "AnimationStart"),
                        transitionrun: zo("Transition", "TransitionRun"),
                        transitionstart: zo("Transition", "TransitionStart"),
                        transitioncancel: zo("Transition", "TransitionCancel"),
                        transitionend: zo("Transition", "TransitionEnd")
                    }
                      , Bu = {}
                      , Tf = {};
                    hr && (Tf = document.createElement("div").style,
                    "AnimationEvent"in window || (delete Dl.animationend.animation,
                    delete Dl.animationiteration.animation,
                    delete Dl.animationstart.animation),
                    "TransitionEvent"in window || delete Dl.transitionend.transition);
                    function dr(s) {
                        if (Bu[s])
                            return Bu[s];
                        if (!Dl[s])
                            return s;
                        var r = Dl[s], h;
                        for (h in r)
                            if (r.hasOwnProperty(h) && h in Tf)
                                return Bu[s] = r[h];
                        return s
                    }
                    var Kp = dr("animationend")
                      , Ov = dr("animationiteration")
                      , Jp = dr("animationstart")
                      , Uv = dr("transitionrun")
                      , Xa = dr("transitionstart")
                      , $p = dr("transitioncancel")
                      , em = dr("transitionend")
                      , Lv = new Map
                      , Pu = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
                    Pu.push("scrollEnd");
                    function ri(s, r) {
                        Lv.set(s, r),
                        Ye(r, [s])
                    }
                    var Vu = typeof reportError == "function" ? reportError : function(s) {
                        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                            var r = new window.ErrorEvent("error",{
                                bubbles: !0,
                                cancelable: !0,
                                message: typeof s == "object" && s !== null && typeof s.message == "string" ? String(s.message) : String(s),
                                error: s
                            });
                            if (!window.dispatchEvent(r))
                                return
                        } else if (typeof process == "object" && typeof process.emit == "function") {
                            process.emit("uncaughtException", s);
                            return
                        }
                        console.error(s)
                    }
                      , oi = []
                      , Ol = 0
                      , Wa = 0;
                    function Wr() {
                        for (var s = Ol, r = Wa = Ol = 0; r < s; ) {
                            var h = oi[r];
                            oi[r++] = null;
                            var m = oi[r];
                            oi[r++] = null;
                            var x = oi[r];
                            oi[r++] = null;
                            var b = oi[r];
                            if (oi[r++] = null,
                            m !== null && x !== null) {
                                var L = m.pending;
                                L === null ? x.next = x : (x.next = L.next,
                                L.next = x),
                                m.pending = x
                            }
                            b !== 0 && jr(h, x, b)
                        }
                    }
                    function Ya(s, r, h, m) {
                        oi[Ol++] = s,
                        oi[Ol++] = r,
                        oi[Ol++] = h,
                        oi[Ol++] = m,
                        Wa |= m,
                        s.lanes |= m,
                        s = s.alternate,
                        s !== null && (s.lanes |= m)
                    }
                    function Fu(s, r, h, m) {
                        return Ya(s, r, h, m),
                        Hu(s)
                    }
                    function Yr(s, r) {
                        return Ya(s, null, null, r),
                        Hu(s)
                    }
                    function jr(s, r, h) {
                        s.lanes |= h;
                        var m = s.alternate;
                        m !== null && (m.lanes |= h);
                        for (var x = !1, b = s.return; b !== null; )
                            b.childLanes |= h,
                            m = b.alternate,
                            m !== null && (m.childLanes |= h),
                            b.tag === 22 && (s = b.stateNode,
                            s === null || s._visibility & 1 || (x = !0)),
                            s = b,
                            b = b.return;
                        return s.tag === 3 ? (b = s.stateNode,
                        x && r !== null && (x = 31 - tt(h),
                        s = b.hiddenUpdates,
                        m = s[x],
                        m === null ? s[x] = [r] : m.push(r),
                        r.lane = h | 536870912),
                        b) : null
                    }
                    function Hu(s) {
                        if (50 < fo)
                            throw fo = 0,
                            La = null,
                            Error(a(185));
                        for (var r = s.return; r !== null; )
                            s = r,
                            r = s.return;
                        return s.tag === 3 ? s.stateNode : null
                    }
                    var ja = {};
                    function Gu(s, r, h, m) {
                        this.tag = s,
                        this.key = h,
                        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                        this.index = 0,
                        this.refCleanup = this.ref = null,
                        this.pendingProps = r,
                        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                        this.mode = m,
                        this.subtreeFlags = this.flags = 0,
                        this.deletions = null,
                        this.childLanes = this.lanes = 0,
                        this.alternate = null
                    }
                    function Li(s, r, h, m) {
                        return new Gu(s,r,h,m)
                    }
                    function Af(s) {
                        return s = s.prototype,
                        !(!s || !s.isReactComponent)
                    }
                    function pr(s, r) {
                        var h = s.alternate;
                        return h === null ? (h = Li(s.tag, r, s.key, s.mode),
                        h.elementType = s.elementType,
                        h.type = s.type,
                        h.stateNode = s.stateNode,
                        h.alternate = s,
                        s.alternate = h) : (h.pendingProps = r,
                        h.type = s.type,
                        h.flags = 0,
                        h.subtreeFlags = 0,
                        h.deletions = null),
                        h.flags = s.flags & 65011712,
                        h.childLanes = s.childLanes,
                        h.lanes = s.lanes,
                        h.child = s.child,
                        h.memoizedProps = s.memoizedProps,
                        h.memoizedState = s.memoizedState,
                        h.updateQueue = s.updateQueue,
                        r = s.dependencies,
                        h.dependencies = r === null ? null : {
                            lanes: r.lanes,
                            firstContext: r.firstContext
                        },
                        h.sibling = s.sibling,
                        h.index = s.index,
                        h.ref = s.ref,
                        h.refCleanup = s.refCleanup,
                        h
                    }
                    function bc(s, r) {
                        s.flags &= 65011714;
                        var h = s.alternate;
                        return h === null ? (s.childLanes = 0,
                        s.lanes = r,
                        s.child = null,
                        s.subtreeFlags = 0,
                        s.memoizedProps = null,
                        s.memoizedState = null,
                        s.updateQueue = null,
                        s.dependencies = null,
                        s.stateNode = null) : (s.childLanes = h.childLanes,
                        s.lanes = h.lanes,
                        s.child = h.child,
                        s.subtreeFlags = 0,
                        s.deletions = null,
                        s.memoizedProps = h.memoizedProps,
                        s.memoizedState = h.memoizedState,
                        s.updateQueue = h.updateQueue,
                        s.type = h.type,
                        r = h.dependencies,
                        s.dependencies = r === null ? null : {
                            lanes: r.lanes,
                            firstContext: r.firstContext
                        }),
                        s
                    }
                    function ku(s, r, h, m, x, b) {
                        var L = 0;
                        if (m = s,
                        typeof s == "function")
                            Af(s) && (L = 1);
                        else if (typeof s == "string")
                            L = cN(s, h, ie.current) ? 26 : s === "html" || s === "head" || s === "body" ? 27 : 5;
                        else
                            e: switch (s) {
                            case P:
                                return s = Li(31, h, r, x),
                                s.elementType = P,
                                s.lanes = b,
                                s;
                            case A:
                                return mr(h.children, x, b, r);
                            case T:
                                L = 8,
                                x |= 24;
                                break;
                            case R:
                                return s = Li(12, h, r, x | 2),
                                s.elementType = R,
                                s.lanes = b,
                                s;
                            case z:
                                return s = Li(13, h, r, x),
                                s.elementType = z,
                                s.lanes = b,
                                s;
                            case I:
                                return s = Li(19, h, r, x),
                                s.elementType = I,
                                s.lanes = b,
                                s;
                            default:
                                if (typeof s == "object" && s !== null)
                                    switch (s.$$typeof) {
                                    case D:
                                        L = 10;
                                        break e;
                                    case N:
                                        L = 9;
                                        break e;
                                    case U:
                                        L = 11;
                                        break e;
                                    case V:
                                        L = 14;
                                        break e;
                                    case B:
                                        L = 16,
                                        m = null;
                                        break e
                                    }
                                L = 29,
                                h = Error(a(130, s === null ? "null" : typeof s, "")),
                                m = null
                            }
                        return r = Li(L, h, r, x),
                        r.elementType = s,
                        r.type = m,
                        r.lanes = b,
                        r
                    }
                    function mr(s, r, h, m) {
                        return s = Li(7, s, m, r),
                        s.lanes = h,
                        s
                    }
                    function Ef(s, r, h) {
                        return s = Li(6, s, null, r),
                        s.lanes = h,
                        s
                    }
                    function Cf(s) {
                        var r = Li(18, null, null, 0);
                        return r.stateNode = s,
                        r
                    }
                    function qu(s, r, h) {
                        return r = Li(4, s.children !== null ? s.children : [], s.key, r),
                        r.lanes = h,
                        r.stateNode = {
                            containerInfo: s.containerInfo,
                            pendingChildren: null,
                            implementation: s.implementation
                        },
                        r
                    }
                    var wf = new WeakMap;
                    function ea(s, r) {
                        if (typeof s == "object" && s !== null) {
                            var h = wf.get(s);
                            return h !== void 0 ? h : (r = {
                                value: s,
                                source: r,
                                stack: Ve(r)
                            },
                            wf.set(s, r),
                            r)
                        }
                        return {
                            value: s,
                            source: r,
                            stack: Ve(r)
                        }
                    }
                    var Bo = []
                      , Xi = 0
                      , Xu = null
                      , Ii = 0
                      , ta = []
                      , Us = 0
                      , Zr = null
                      , gr = 1
                      , Wi = "";
                    function vr(s, r) {
                        Bo[Xi++] = Ii,
                        Bo[Xi++] = Xu,
                        Xu = s,
                        Ii = r
                    }
                    function Rf(s, r, h) {
                        ta[Us++] = gr,
                        ta[Us++] = Wi,
                        ta[Us++] = Zr,
                        Zr = s;
                        var m = gr;
                        s = Wi;
                        var x = 32 - tt(m) - 1;
                        m &= ~(1 << x),
                        h += 1;
                        var b = 32 - tt(r) + x;
                        if (30 < b) {
                            var L = x - x % 5;
                            b = (m & (1 << L) - 1).toString(32),
                            m >>= L,
                            x -= L,
                            gr = 1 << 32 - tt(r) + x | h << x | m,
                            Wi = b + s
                        } else
                            gr = 1 << b | h << x | m,
                            Wi = s
                    }
                    function Po(s) {
                        s.return !== null && (vr(s, 1),
                        Rf(s, 1, 0))
                    }
                    function Nf(s) {
                        for (; s === Xu; )
                            Xu = Bo[--Xi],
                            Bo[Xi] = null,
                            Ii = Bo[--Xi],
                            Bo[Xi] = null;
                        for (; s === Zr; )
                            Zr = ta[--Us],
                            ta[Us] = null,
                            Wi = ta[--Us],
                            ta[Us] = null,
                            gr = ta[--Us],
                            ta[Us] = null
                    }
                    function tm(s, r) {
                        ta[Us++] = gr,
                        ta[Us++] = Wi,
                        ta[Us++] = Zr,
                        gr = r.id,
                        Wi = r.overflow,
                        Zr = s
                    }
                    var Yi = null
                      , Wn = null
                      , hn = !1
                      , _r = null
                      , Ea = !1
                      , nm = Error(a(519));
                    function Vo(s) {
                        throw Tc(ea(Error(a(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", "")), s)),
                        nm
                    }
                    function im(s) {
                        var r = s.stateNode
                          , h = s.type
                          , m = s.memoizedProps;
                        switch (r[Zt] = s,
                        r[Oi] = m,
                        h) {
                        case "dialog":
                            _n("cancel", r),
                            _n("close", r);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            _n("load", r);
                            break;
                        case "video":
                        case "audio":
                            for (h = 0; h < Wm.length; h++)
                                _n(Wm[h], r);
                            break;
                        case "source":
                            _n("error", r);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            _n("error", r),
                            _n("load", r);
                            break;
                        case "details":
                            _n("toggle", r);
                            break;
                        case "input":
                            _n("invalid", r),
                            kr(r, m.value, m.defaultValue, m.checked, m.defaultChecked, m.type, m.name, !0);
                            break;
                        case "select":
                            _n("invalid", r);
                            break;
                        case "textarea":
                            _n("invalid", r),
                            ei(r, m.value, m.defaultValue, m.children)
                        }
                        h = m.children,
                        typeof h != "string" && typeof h != "number" && typeof h != "bigint" || r.textContent === "" + h || m.suppressHydrationWarning === !0 || wT(r.textContent, h) ? (m.popover != null && (_n("beforetoggle", r),
                        _n("toggle", r)),
                        m.onScroll != null && _n("scroll", r),
                        m.onScrollEnd != null && _n("scrollend", r),
                        m.onClick != null && (r.onclick = ur),
                        r = !0) : r = !1,
                        r || Vo(s, !0)
                    }
                    function sm(s) {
                        for (Yi = s.return; Yi; )
                            switch (Yi.tag) {
                            case 5:
                            case 31:
                            case 13:
                                Ea = !1;
                                return;
                            case 27:
                            case 3:
                                Ea = !0;
                                return;
                            default:
                                Yi = Yi.return
                            }
                    }
                    function Za(s) {
                        if (s !== Yi)
                            return !1;
                        if (!hn)
                            return sm(s),
                            hn = !0,
                            !1;
                        var r = s.tag, h;
                        if ((h = r !== 3 && r !== 27) && ((h = r === 5) && (h = s.type,
                        h = !(h !== "form" && h !== "button") || jS(s.type, s.memoizedProps)),
                        h = !h),
                        h && Wn && Vo(s),
                        sm(s),
                        r === 13) {
                            if (s = s.memoizedState,
                            s = s !== null ? s.dehydrated : null,
                            !s)
                                throw Error(a(317));
                            Wn = BT(s)
                        } else if (r === 31) {
                            if (s = s.memoizedState,
                            s = s !== null ? s.dehydrated : null,
                            !s)
                                throw Error(a(317));
                            Wn = BT(s)
                        } else
                            r === 27 ? (r = Wn,
                            Xc(s.type) ? (s = $S,
                            $S = null,
                            Wn = s) : Wn = r) : Wn = Yi ? Or(s.stateNode.nextSibling) : null;
                        return !0
                    }
                    function yr() {
                        Wn = Yi = null,
                        hn = !1
                    }
                    function Df() {
                        var s = _r;
                        return s !== null && (Bt === null ? Bt = s : Bt.push.apply(Bt, s),
                        _r = null),
                        s
                    }
                    function Tc(s) {
                        _r === null ? _r = [s] : _r.push(s)
                    }
                    var am = k(null)
                      , Fo = null
                      , xs = null;
                    function Qr(s, r, h) {
                        Ae(am, r._currentValue),
                        r._currentValue = h
                    }
                    function fn(s) {
                        s._currentValue = am.current,
                        pe(am)
                    }
                    function Wu(s, r, h) {
                        for (; s !== null; ) {
                            var m = s.alternate;
                            if ((s.childLanes & r) !== r ? (s.childLanes |= r,
                            m !== null && (m.childLanes |= r)) : m !== null && (m.childLanes & r) !== r && (m.childLanes |= r),
                            s === h)
                                break;
                            s = s.return
                        }
                    }
                    function rm(s, r, h, m) {
                        var x = s.child;
                        for (x !== null && (x.return = s); x !== null; ) {
                            var b = x.dependencies;
                            if (b !== null) {
                                var L = x.child;
                                b = b.firstContext;
                                e: for (; b !== null; ) {
                                    var W = b;
                                    b = x;
                                    for (var ae = 0; ae < r.length; ae++)
                                        if (W.context === r[ae]) {
                                            b.lanes |= h,
                                            W = b.alternate,
                                            W !== null && (W.lanes |= h),
                                            Wu(b.return, h, s),
                                            m || (L = null);
                                            break e
                                        }
                                    b = W.next
                                }
                            } else if (x.tag === 18) {
                                if (L = x.return,
                                L === null)
                                    throw Error(a(341));
                                L.lanes |= h,
                                b = L.alternate,
                                b !== null && (b.lanes |= h),
                                Wu(L, h, s),
                                L = null
                            } else
                                L = x.child;
                            if (L !== null)
                                L.return = x;
                            else
                                for (L = x; L !== null; ) {
                                    if (L === s) {
                                        L = null;
                                        break
                                    }
                                    if (x = L.sibling,
                                    x !== null) {
                                        x.return = L.return,
                                        L = x;
                                        break
                                    }
                                    L = L.return
                                }
                            x = L
                        }
                    }
                    function Ul(s, r, h, m) {
                        s = null;
                        for (var x = r, b = !1; x !== null; ) {
                            if (!b) {
                                if ((x.flags & 524288) !== 0)
                                    b = !0;
                                else if ((x.flags & 262144) !== 0)
                                    break
                            }
                            if (x.tag === 10) {
                                var L = x.alternate;
                                if (L === null)
                                    throw Error(a(387));
                                if (L = L.memoizedProps,
                                L !== null) {
                                    var W = x.type;
                                    fs(x.pendingProps.value, L.value) || (s !== null ? s.push(W) : s = [W])
                                }
                            } else if (x === Te.current) {
                                if (L = x.alternate,
                                L === null)
                                    throw Error(a(387));
                                L.memoizedState.memoizedState !== x.memoizedState.memoizedState && (s !== null ? s.push(Km) : s = [Km])
                            }
                            x = x.return
                        }
                        s !== null && rm(r, s, h, m),
                        r.flags |= 262144
                    }
                    function Of(s) {
                        for (s = s.firstContext; s !== null; ) {
                            if (!fs(s.context._currentValue, s.memoizedValue))
                                return !0;
                            s = s.next
                        }
                        return !1
                    }
                    function Ll(s) {
                        Fo = s,
                        xs = null,
                        s = s.dependencies,
                        s !== null && (s.firstContext = null)
                    }
                    function ns(s) {
                        return Lf(Fo, s)
                    }
                    function Uf(s, r) {
                        return Fo === null && Ll(s),
                        Lf(s, r)
                    }
                    function Lf(s, r) {
                        var h = r._currentValue;
                        if (r = {
                            context: r,
                            memoizedValue: h,
                            next: null
                        },
                        xs === null) {
                            if (s === null)
                                throw Error(a(308));
                            xs = r,
                            s.dependencies = {
                                lanes: 0,
                                firstContext: r
                            },
                            s.flags |= 524288
                        } else
                            xs = xs.next = r;
                        return h
                    }
                    var Ho = typeof AbortController < "u" ? AbortController : function() {
                        var s = []
                          , r = this.signal = {
                            aborted: !1,
                            addEventListener: function(h, m) {
                                s.push(m)
                            }
                        };
                        this.abort = function() {
                            r.aborted = !0,
                            s.forEach(function(h) {
                                return h()
                            })
                        }
                    }
                      , Iv = e.unstable_scheduleCallback
                      , If = e.unstable_NormalPriority
                      , Yn = {
                        $$typeof: D,
                        Consumer: null,
                        Provider: null,
                        _currentValue: null,
                        _currentValue2: null,
                        _threadCount: 0
                    };
                    function zf() {
                        return {
                            controller: new Ho,
                            data: new Map,
                            refCount: 0
                        }
                    }
                    function Il(s) {
                        s.refCount--,
                        s.refCount === 0 && Iv(If, function() {
                            s.controller.abort()
                        })
                    }
                    var zl = null
                      , om = 0
                      , Bl = 0
                      , Pl = null;
                    function zv(s, r) {
                        if (zl === null) {
                            var h = zl = [];
                            om = 0,
                            Bl = FS(),
                            Pl = {
                                status: "pending",
                                value: void 0,
                                then: function(m) {
                                    h.push(m)
                                }
                            }
                        }
                        return om++,
                        r.then(lm, lm),
                        r
                    }
                    function lm() {
                        if (--om === 0 && zl !== null) {
                            Pl !== null && (Pl.status = "fulfilled");
                            var s = zl;
                            zl = null,
                            Bl = 0,
                            Pl = null;
                            for (var r = 0; r < s.length; r++)
                                (0,
                                s[r])()
                        }
                    }
                    function Bv(s, r) {
                        var h = []
                          , m = {
                            status: "pending",
                            value: null,
                            reason: null,
                            then: function(x) {
                                h.push(x)
                            }
                        };
                        return s.then(function() {
                            m.status = "fulfilled",
                            m.value = r;
                            for (var x = 0; x < h.length; x++)
                                (0,
                                h[x])(r)
                        }, function(x) {
                            for (m.status = "rejected",
                            m.reason = x,
                            x = 0; x < h.length; x++)
                                (0,
                                h[x])(void 0)
                        }),
                        m
                    }
                    var Bf = F.S;
                    F.S = function(s, r) {
                        Bs = he(),
                        typeof r == "object" && r !== null && typeof r.then == "function" && zv(s, r),
                        Bf !== null && Bf(s, r)
                    }
                    ;
                    var Wt = k(null);
                    function cm() {
                        var s = Wt.current;
                        return s !== null ? s : qt.pooledCache
                    }
                    function ds(s, r) {
                        r === null ? Ae(Wt, Wt.current) : Ae(Wt, r.pool)
                    }
                    function Pf() {
                        var s = cm();
                        return s === null ? null : {
                            parent: Yn._currentValue,
                            pool: s
                        }
                    }
                    var Ac = Error(a(460))
                      , Ec = Error(a(474))
                      , Kr = Error(a(542))
                      , Jr = {
                        then: function() {}
                    };
                    function um(s) {
                        return s = s.status,
                        s === "fulfilled" || s === "rejected"
                    }
                    function Vf(s, r, h) {
                        switch (h = s[h],
                        h === void 0 ? s.push(r) : h !== r && (r.then(ur, ur),
                        r = h),
                        r.status) {
                        case "fulfilled":
                            return r.value;
                        case "rejected":
                            throw s = r.reason,
                            Ff(s),
                            s;
                        default:
                            if (typeof r.status == "string")
                                r.then(ur, ur);
                            else {
                                if (s = qt,
                                s !== null && 100 < s.shellSuspendCounter)
                                    throw Error(a(482));
                                s = r,
                                s.status = "pending",
                                s.then(function(m) {
                                    if (r.status === "pending") {
                                        var x = r;
                                        x.status = "fulfilled",
                                        x.value = m
                                    }
                                }, function(m) {
                                    if (r.status === "pending") {
                                        var x = r;
                                        x.status = "rejected",
                                        x.reason = m
                                    }
                                })
                            }
                            switch (r.status) {
                            case "fulfilled":
                                return r.value;
                            case "rejected":
                                throw s = r.reason,
                                Ff(s),
                                s
                            }
                            throw Go = r,
                            Ac
                        }
                    }
                    function Vl(s) {
                        try {
                            var r = s._init;
                            return r(s._payload)
                        } catch (h) {
                            throw h !== null && typeof h == "object" && typeof h.then == "function" ? (Go = h,
                            Ac) : h
                        }
                    }
                    var Go = null;
                    function $r() {
                        if (Go === null)
                            throw Error(a(459));
                        var s = Go;
                        return Go = null,
                        s
                    }
                    function Ff(s) {
                        if (s === Ac || s === Kr)
                            throw Error(a(483))
                    }
                    var ko = null
                      , Fl = 0;
                    function Cc(s) {
                        var r = Fl;
                        return Fl += 1,
                        ko === null && (ko = []),
                        Vf(ko, s, r)
                    }
                    function Ca(s, r) {
                        r = r.props.ref,
                        s.ref = r !== void 0 ? r : null
                    }
                    function Yu(s, r) {
                        throw r.$$typeof === S ? Error(a(525)) : (s = Object.prototype.toString.call(r),
                        Error(a(31, s === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : s)))
                    }
                    function Pv(s) {
                        function r(de, re) {
                            if (s) {
                                var ye = de.deletions;
                                ye === null ? (de.deletions = [re],
                                de.flags |= 16) : ye.push(re)
                            }
                        }
                        function h(de, re) {
                            if (!s)
                                return null;
                            for (; re !== null; )
                                r(de, re),
                                re = re.sibling;
                            return null
                        }
                        function m(de) {
                            for (var re = new Map; de !== null; )
                                de.key !== null ? re.set(de.key, de) : re.set(de.index, de),
                                de = de.sibling;
                            return re
                        }
                        function x(de, re) {
                            return de = pr(de, re),
                            de.index = 0,
                            de.sibling = null,
                            de
                        }
                        function b(de, re, ye) {
                            return de.index = ye,
                            s ? (ye = de.alternate,
                            ye !== null ? (ye = ye.index,
                            ye < re ? (de.flags |= 67108866,
                            re) : ye) : (de.flags |= 67108866,
                            re)) : (de.flags |= 1048576,
                            re)
                        }
                        function L(de) {
                            return s && de.alternate === null && (de.flags |= 67108866),
                            de
                        }
                        function W(de, re, ye, Pe) {
                            return re === null || re.tag !== 6 ? (re = Ef(ye, de.mode, Pe),
                            re.return = de,
                            re) : (re = x(re, ye),
                            re.return = de,
                            re)
                        }
                        function ae(de, re, ye, Pe) {
                            var Lt = ye.type;
                            return Lt === A ? ze(de, re, ye.props.children, Pe, ye.key) : re !== null && (re.elementType === Lt || typeof Lt == "object" && Lt !== null && Lt.$$typeof === B && Vl(Lt) === re.type) ? (re = x(re, ye.props),
                            Ca(re, ye),
                            re.return = de,
                            re) : (re = ku(ye.type, ye.key, ye.props, null, de.mode, Pe),
                            Ca(re, ye),
                            re.return = de,
                            re)
                        }
                        function be(de, re, ye, Pe) {
                            return re === null || re.tag !== 4 || re.stateNode.containerInfo !== ye.containerInfo || re.stateNode.implementation !== ye.implementation ? (re = qu(ye, de.mode, Pe),
                            re.return = de,
                            re) : (re = x(re, ye.children || []),
                            re.return = de,
                            re)
                        }
                        function ze(de, re, ye, Pe, Lt) {
                            return re === null || re.tag !== 7 ? (re = mr(ye, de.mode, Pe, Lt),
                            re.return = de,
                            re) : (re = x(re, ye),
                            re.return = de,
                            re)
                        }
                        function Fe(de, re, ye) {
                            if (typeof re == "string" && re !== "" || typeof re == "number" || typeof re == "bigint")
                                return re = Ef("" + re, de.mode, ye),
                                re.return = de,
                                re;
                            if (typeof re == "object" && re !== null) {
                                switch (re.$$typeof) {
                                case E:
                                    return ye = ku(re.type, re.key, re.props, null, de.mode, ye),
                                    Ca(ye, re),
                                    ye.return = de,
                                    ye;
                                case w:
                                    return re = qu(re, de.mode, ye),
                                    re.return = de,
                                    re;
                                case B:
                                    return re = Vl(re),
                                    Fe(de, re, ye)
                                }
                                if (q(re) || ee(re))
                                    return re = mr(re, de.mode, ye, null),
                                    re.return = de,
                                    re;
                                if (typeof re.then == "function")
                                    return Fe(de, Cc(re), ye);
                                if (re.$$typeof === D)
                                    return Fe(de, Uf(de, re), ye);
                                Yu(de, re)
                            }
                            return null
                        }
                        function Ee(de, re, ye, Pe) {
                            var Lt = re !== null ? re.key : null;
                            if (typeof ye == "string" && ye !== "" || typeof ye == "number" || typeof ye == "bigint")
                                return Lt !== null ? null : W(de, re, "" + ye, Pe);
                            if (typeof ye == "object" && ye !== null) {
                                switch (ye.$$typeof) {
                                case E:
                                    return ye.key === Lt ? ae(de, re, ye, Pe) : null;
                                case w:
                                    return ye.key === Lt ? be(de, re, ye, Pe) : null;
                                case B:
                                    return ye = Vl(ye),
                                    Ee(de, re, ye, Pe)
                                }
                                if (q(ye) || ee(ye))
                                    return Lt !== null ? null : ze(de, re, ye, Pe, null);
                                if (typeof ye.then == "function")
                                    return Ee(de, re, Cc(ye), Pe);
                                if (ye.$$typeof === D)
                                    return Ee(de, re, Uf(de, ye), Pe);
                                Yu(de, ye)
                            }
                            return null
                        }
                        function Ne(de, re, ye, Pe, Lt) {
                            if (typeof Pe == "string" && Pe !== "" || typeof Pe == "number" || typeof Pe == "bigint")
                                return de = de.get(ye) || null,
                                W(re, de, "" + Pe, Lt);
                            if (typeof Pe == "object" && Pe !== null) {
                                switch (Pe.$$typeof) {
                                case E:
                                    return de = de.get(Pe.key === null ? ye : Pe.key) || null,
                                    ae(re, de, Pe, Lt);
                                case w:
                                    return de = de.get(Pe.key === null ? ye : Pe.key) || null,
                                    be(re, de, Pe, Lt);
                                case B:
                                    return Pe = Vl(Pe),
                                    Ne(de, re, ye, Pe, Lt)
                                }
                                if (q(Pe) || ee(Pe))
                                    return de = de.get(ye) || null,
                                    ze(re, de, Pe, Lt, null);
                                if (typeof Pe.then == "function")
                                    return Ne(de, re, ye, Cc(Pe), Lt);
                                if (Pe.$$typeof === D)
                                    return Ne(de, re, ye, Uf(re, Pe), Lt);
                                Yu(re, Pe)
                            }
                            return null
                        }
                        function yt(de, re, ye, Pe) {
                            for (var Lt = null, Dn = null, Mt = re, nn = re = 0, Sn = null; Mt !== null && nn < ye.length; nn++) {
                                Mt.index > nn ? (Sn = Mt,
                                Mt = null) : Sn = Mt.sibling;
                                var On = Ee(de, Mt, ye[nn], Pe);
                                if (On === null) {
                                    Mt === null && (Mt = Sn);
                                    break
                                }
                                s && Mt && On.alternate === null && r(de, Mt),
                                re = b(On, re, nn),
                                Dn === null ? Lt = On : Dn.sibling = On,
                                Dn = On,
                                Mt = Sn
                            }
                            if (nn === ye.length)
                                return h(de, Mt),
                                hn && vr(de, nn),
                                Lt;
                            if (Mt === null) {
                                for (; nn < ye.length; nn++)
                                    Mt = Fe(de, ye[nn], Pe),
                                    Mt !== null && (re = b(Mt, re, nn),
                                    Dn === null ? Lt = Mt : Dn.sibling = Mt,
                                    Dn = Mt);
                                return hn && vr(de, nn),
                                Lt
                            }
                            for (Mt = m(Mt); nn < ye.length; nn++)
                                Sn = Ne(Mt, de, nn, ye[nn], Pe),
                                Sn !== null && (s && Sn.alternate !== null && Mt.delete(Sn.key === null ? nn : Sn.key),
                                re = b(Sn, re, nn),
                                Dn === null ? Lt = Sn : Dn.sibling = Sn,
                                Dn = Sn);
                            return s && Mt.forEach(function(Qc) {
                                return r(de, Qc)
                            }),
                            hn && vr(de, nn),
                            Lt
                        }
                        function Pt(de, re, ye, Pe) {
                            if (ye == null)
                                throw Error(a(151));
                            for (var Lt = null, Dn = null, Mt = re, nn = re = 0, Sn = null, On = ye.next(); Mt !== null && !On.done; nn++,
                            On = ye.next()) {
                                Mt.index > nn ? (Sn = Mt,
                                Mt = null) : Sn = Mt.sibling;
                                var Qc = Ee(de, Mt, On.value, Pe);
                                if (Qc === null) {
                                    Mt === null && (Mt = Sn);
                                    break
                                }
                                s && Mt && Qc.alternate === null && r(de, Mt),
                                re = b(Qc, re, nn),
                                Dn === null ? Lt = Qc : Dn.sibling = Qc,
                                Dn = Qc,
                                Mt = Sn
                            }
                            if (On.done)
                                return h(de, Mt),
                                hn && vr(de, nn),
                                Lt;
                            if (Mt === null) {
                                for (; !On.done; nn++,
                                On = ye.next())
                                    On = Fe(de, On.value, Pe),
                                    On !== null && (re = b(On, re, nn),
                                    Dn === null ? Lt = On : Dn.sibling = On,
                                    Dn = On);
                                return hn && vr(de, nn),
                                Lt
                            }
                            for (Mt = m(Mt); !On.done; nn++,
                            On = ye.next())
                                On = Ne(Mt, de, nn, On.value, Pe),
                                On !== null && (s && On.alternate !== null && Mt.delete(On.key === null ? nn : On.key),
                                re = b(On, re, nn),
                                Dn === null ? Lt = On : Dn.sibling = On,
                                Dn = On);
                            return s && Mt.forEach(function(bN) {
                                return r(de, bN)
                            }),
                            hn && vr(de, nn),
                            Lt
                        }
                        function Qn(de, re, ye, Pe) {
                            if (typeof ye == "object" && ye !== null && ye.type === A && ye.key === null && (ye = ye.props.children),
                            typeof ye == "object" && ye !== null) {
                                switch (ye.$$typeof) {
                                case E:
                                    e: {
                                        for (var Lt = ye.key; re !== null; ) {
                                            if (re.key === Lt) {
                                                if (Lt = ye.type,
                                                Lt === A) {
                                                    if (re.tag === 7) {
                                                        h(de, re.sibling),
                                                        Pe = x(re, ye.props.children),
                                                        Pe.return = de,
                                                        de = Pe;
                                                        break e
                                                    }
                                                } else if (re.elementType === Lt || typeof Lt == "object" && Lt !== null && Lt.$$typeof === B && Vl(Lt) === re.type) {
                                                    h(de, re.sibling),
                                                    Pe = x(re, ye.props),
                                                    Ca(Pe, ye),
                                                    Pe.return = de,
                                                    de = Pe;
                                                    break e
                                                }
                                                h(de, re);
                                                break
                                            } else
                                                r(de, re);
                                            re = re.sibling
                                        }
                                        ye.type === A ? (Pe = mr(ye.props.children, de.mode, Pe, ye.key),
                                        Pe.return = de,
                                        de = Pe) : (Pe = ku(ye.type, ye.key, ye.props, null, de.mode, Pe),
                                        Ca(Pe, ye),
                                        Pe.return = de,
                                        de = Pe)
                                    }
                                    return L(de);
                                case w:
                                    e: {
                                        for (Lt = ye.key; re !== null; ) {
                                            if (re.key === Lt)
                                                if (re.tag === 4 && re.stateNode.containerInfo === ye.containerInfo && re.stateNode.implementation === ye.implementation) {
                                                    h(de, re.sibling),
                                                    Pe = x(re, ye.children || []),
                                                    Pe.return = de,
                                                    de = Pe;
                                                    break e
                                                } else {
                                                    h(de, re);
                                                    break
                                                }
                                            else
                                                r(de, re);
                                            re = re.sibling
                                        }
                                        Pe = qu(ye, de.mode, Pe),
                                        Pe.return = de,
                                        de = Pe
                                    }
                                    return L(de);
                                case B:
                                    return ye = Vl(ye),
                                    Qn(de, re, ye, Pe)
                                }
                                if (q(ye))
                                    return yt(de, re, ye, Pe);
                                if (ee(ye)) {
                                    if (Lt = ee(ye),
                                    typeof Lt != "function")
                                        throw Error(a(150));
                                    return ye = Lt.call(ye),
                                    Pt(de, re, ye, Pe)
                                }
                                if (typeof ye.then == "function")
                                    return Qn(de, re, Cc(ye), Pe);
                                if (ye.$$typeof === D)
                                    return Qn(de, re, Uf(de, ye), Pe);
                                Yu(de, ye)
                            }
                            return typeof ye == "string" && ye !== "" || typeof ye == "number" || typeof ye == "bigint" ? (ye = "" + ye,
                            re !== null && re.tag === 6 ? (h(de, re.sibling),
                            Pe = x(re, ye),
                            Pe.return = de,
                            de = Pe) : (h(de, re),
                            Pe = Ef(ye, de.mode, Pe),
                            Pe.return = de,
                            de = Pe),
                            L(de)) : h(de, re)
                        }
                        return function(de, re, ye, Pe) {
                            try {
                                Fl = 0;
                                var Lt = Qn(de, re, ye, Pe);
                                return ko = null,
                                Lt
                            } catch (Mt) {
                                if (Mt === Ac || Mt === Kr)
                                    throw Mt;
                                var Dn = Li(29, Mt, null, de.mode);
                                return Dn.lanes = Pe,
                                Dn.return = de,
                                Dn
                            }
                        }
                    }
                    var qo = Pv(!0)
                      , Vv = Pv(!1)
                      , zt = !1;
                    function ju(s) {
                        s.updateQueue = {
                            baseState: s.memoizedState,
                            firstBaseUpdate: null,
                            lastBaseUpdate: null,
                            shared: {
                                pending: null,
                                lanes: 0,
                                hiddenCallbacks: null
                            },
                            callbacks: null
                        }
                    }
                    function Hf(s, r) {
                        s = s.updateQueue,
                        r.updateQueue === s && (r.updateQueue = {
                            baseState: s.baseState,
                            firstBaseUpdate: s.firstBaseUpdate,
                            lastBaseUpdate: s.lastBaseUpdate,
                            shared: s.shared,
                            callbacks: null
                        })
                    }
                    function eo(s) {
                        return {
                            lane: s,
                            tag: 0,
                            payload: null,
                            callback: null,
                            next: null
                        }
                    }
                    function Sr(s, r, h) {
                        var m = s.updateQueue;
                        if (m === null)
                            return null;
                        if (m = m.shared,
                        (An & 2) !== 0) {
                            var x = m.pending;
                            return x === null ? r.next = r : (r.next = x.next,
                            x.next = r),
                            m.pending = r,
                            r = Hu(s),
                            jr(s, null, h),
                            r
                        }
                        return Ya(s, m, r, h),
                        Hu(s)
                    }
                    function Zu(s, r, h) {
                        if (r = r.updateQueue,
                        r !== null && (r = r.shared,
                        (h & 4194048) !== 0)) {
                            var m = r.lanes;
                            m &= s.pendingLanes,
                            h |= m,
                            r.lanes = h,
                            vc(s, h)
                        }
                    }
                    function hm(s, r) {
                        var h = s.updateQueue
                          , m = s.alternate;
                        if (m !== null && (m = m.updateQueue,
                        h === m)) {
                            var x = null
                              , b = null;
                            if (h = h.firstBaseUpdate,
                            h !== null) {
                                do {
                                    var L = {
                                        lane: h.lane,
                                        tag: h.tag,
                                        payload: h.payload,
                                        callback: null,
                                        next: null
                                    };
                                    b === null ? x = b = L : b = b.next = L,
                                    h = h.next
                                } while (h !== null);
                                b === null ? x = b = r : b = b.next = r
                            } else
                                x = b = r;
                            h = {
                                baseState: m.baseState,
                                firstBaseUpdate: x,
                                lastBaseUpdate: b,
                                shared: m.shared,
                                callbacks: m.callbacks
                            },
                            s.updateQueue = h;
                            return
                        }
                        s = h.lastBaseUpdate,
                        s === null ? h.firstBaseUpdate = r : s.next = r,
                        h.lastBaseUpdate = r
                    }
                    var Gf = !1;
                    function to() {
                        if (Gf) {
                            var s = Pl;
                            if (s !== null)
                                throw s
                        }
                    }
                    function Qu(s, r, h, m) {
                        Gf = !1;
                        var x = s.updateQueue;
                        zt = !1;
                        var b = x.firstBaseUpdate
                          , L = x.lastBaseUpdate
                          , W = x.shared.pending;
                        if (W !== null) {
                            x.shared.pending = null;
                            var ae = W
                              , be = ae.next;
                            ae.next = null,
                            L === null ? b = be : L.next = be,
                            L = ae;
                            var ze = s.alternate;
                            ze !== null && (ze = ze.updateQueue,
                            W = ze.lastBaseUpdate,
                            W !== L && (W === null ? ze.firstBaseUpdate = be : W.next = be,
                            ze.lastBaseUpdate = ae))
                        }
                        if (b !== null) {
                            var Fe = x.baseState;
                            L = 0,
                            ze = be = ae = null,
                            W = b;
                            do {
                                var Ee = W.lane & -536870913
                                  , Ne = Ee !== W.lane;
                                if (Ne ? (Ut & Ee) === Ee : (m & Ee) === Ee) {
                                    Ee !== 0 && Ee === Bl && (Gf = !0),
                                    ze !== null && (ze = ze.next = {
                                        lane: 0,
                                        tag: W.tag,
                                        payload: W.payload,
                                        callback: null,
                                        next: null
                                    });
                                    e: {
                                        var yt = s
                                          , Pt = W;
                                        Ee = r;
                                        var Qn = h;
                                        switch (Pt.tag) {
                                        case 1:
                                            if (yt = Pt.payload,
                                            typeof yt == "function") {
                                                Fe = yt.call(Qn, Fe, Ee);
                                                break e
                                            }
                                            Fe = yt;
                                            break e;
                                        case 3:
                                            yt.flags = yt.flags & -65537 | 128;
                                        case 0:
                                            if (yt = Pt.payload,
                                            Ee = typeof yt == "function" ? yt.call(Qn, Fe, Ee) : yt,
                                            Ee == null)
                                                break e;
                                            Fe = y({}, Fe, Ee);
                                            break e;
                                        case 2:
                                            zt = !0
                                        }
                                    }
                                    Ee = W.callback,
                                    Ee !== null && (s.flags |= 64,
                                    Ne && (s.flags |= 8192),
                                    Ne = x.callbacks,
                                    Ne === null ? x.callbacks = [Ee] : Ne.push(Ee))
                                } else
                                    Ne = {
                                        lane: Ee,
                                        tag: W.tag,
                                        payload: W.payload,
                                        callback: W.callback,
                                        next: null
                                    },
                                    ze === null ? (be = ze = Ne,
                                    ae = Fe) : ze = ze.next = Ne,
                                    L |= Ee;
                                if (W = W.next,
                                W === null) {
                                    if (W = x.shared.pending,
                                    W === null)
                                        break;
                                    Ne = W,
                                    W = Ne.next,
                                    Ne.next = null,
                                    x.lastBaseUpdate = Ne,
                                    x.shared.pending = null
                                }
                            } while (!0);
                            ze === null && (ae = Fe),
                            x.baseState = ae,
                            x.firstBaseUpdate = be,
                            x.lastBaseUpdate = ze,
                            b === null && (x.shared.lanes = 0),
                            er |= L,
                            s.lanes = L,
                            s.memoizedState = Fe
                        }
                    }
                    function Fv(s, r) {
                        if (typeof s != "function")
                            throw Error(a(191, s));
                        s.call(r)
                    }
                    function Hv(s, r) {
                        var h = s.callbacks;
                        if (h !== null)
                            for (s.callbacks = null,
                            s = 0; s < h.length; s++)
                                Fv(h[s], r)
                    }
                    var wc = k(null)
                      , kf = k(0);
                    function qf(s, r) {
                        s = Oa,
                        Ae(kf, s),
                        Ae(wc, r),
                        Oa = s | r.baseLanes
                    }
                    function Xf() {
                        Ae(kf, Oa),
                        Ae(wc, wc.current)
                    }
                    function Rc() {
                        Oa = kf.current,
                        pe(wc),
                        pe(kf)
                    }
                    var Ls = k(null)
                      , wa = null;
                    function Xo(s) {
                        var r = s.alternate;
                        Ae(Tn, Tn.current & 1),
                        Ae(Ls, s),
                        wa === null && (r === null || wc.current !== null || r.memoizedState !== null) && (wa = s)
                    }
                    function Ku(s) {
                        Ae(Tn, Tn.current),
                        Ae(Ls, s),
                        wa === null && (wa = s)
                    }
                    function xr(s) {
                        s.tag === 22 ? (Ae(Tn, Tn.current),
                        Ae(Ls, s),
                        wa === null && (wa = s)) : ci(s)
                    }
                    function ci() {
                        Ae(Tn, Tn.current),
                        Ae(Ls, Ls.current)
                    }
                    function Ei(s) {
                        pe(Ls),
                        wa === s && (wa = null),
                        pe(Tn)
                    }
                    var Tn = k(0);
                    function Ju(s) {
                        for (var r = s; r !== null; ) {
                            if (r.tag === 13) {
                                var h = r.memoizedState;
                                if (h !== null && (h = h.dehydrated,
                                h === null || KS(h) || JS(h)))
                                    return r
                            } else if (r.tag === 19 && (r.memoizedProps.revealOrder === "forwards" || r.memoizedProps.revealOrder === "backwards" || r.memoizedProps.revealOrder === "unstable_legacy-backwards" || r.memoizedProps.revealOrder === "together")) {
                                if ((r.flags & 128) !== 0)
                                    return r
                            } else if (r.child !== null) {
                                r.child.return = r,
                                r = r.child;
                                continue
                            }
                            if (r === s)
                                break;
                            for (; r.sibling === null; ) {
                                if (r.return === null || r.return === s)
                                    return null;
                                r = r.return
                            }
                            r.sibling.return = r.return,
                            r = r.sibling
                        }
                        return null
                    }
                    var no = 0
                      , Ot = null
                      , yn = null
                      , Ci = null
                      , Wf = !1
                      , Nc = !1
                      , Hl = !1
                      , $u = 0
                      , eh = 0
                      , Gl = null
                      , NS = 0;
                    function Gn() {
                        throw Error(a(321))
                    }
                    function io(s, r) {
                        if (r === null)
                            return !1;
                        for (var h = 0; h < r.length && h < s.length; h++)
                            if (!fs(s[h], r[h]))
                                return !1;
                        return !0
                    }
                    function fm(s, r, h, m, x, b) {
                        return no = b,
                        Ot = r,
                        r.memoizedState = null,
                        r.updateQueue = null,
                        r.lanes = 0,
                        F.H = s === null || s.memoizedState === null ? is : $f,
                        Hl = !1,
                        b = h(m, x),
                        Hl = !1,
                        Nc && (b = kv(r, h, m, x)),
                        Gv(s),
                        b
                    }
                    function Gv(s) {
                        F.H = rh;
                        var r = yn !== null && yn.next !== null;
                        if (no = 0,
                        Ci = yn = Ot = null,
                        Wf = !1,
                        eh = 0,
                        Gl = null,
                        r)
                            throw Error(a(300));
                        s === null || Rn || (s = s.dependencies,
                        s !== null && Of(s) && (Rn = !0))
                    }
                    function kv(s, r, h, m) {
                        Ot = s;
                        var x = 0;
                        do {
                            if (Nc && (Gl = null),
                            eh = 0,
                            Nc = !1,
                            25 <= x)
                                throw Error(a(301));
                            if (x += 1,
                            Ci = yn = null,
                            s.updateQueue != null) {
                                var b = s.updateQueue;
                                b.lastEffect = null,
                                b.events = null,
                                b.stores = null,
                                b.memoCache != null && (b.memoCache.index = 0)
                            }
                            F.H = u_,
                            b = r(h, m)
                        } while (Nc);
                        return b
                    }
                    function th() {
                        var s = F.H
                          , r = s.useState()[0];
                        return r = typeof r.then == "function" ? nh(r) : r,
                        s = s.useState()[0],
                        (yn !== null ? yn.memoizedState : null) !== s && (Ot.flags |= 1024),
                        r
                    }
                    function dm() {
                        var s = $u !== 0;
                        return $u = 0,
                        s
                    }
                    function pm(s, r, h) {
                        r.updateQueue = s.updateQueue,
                        r.flags &= -2053,
                        s.lanes &= ~h
                    }
                    function mm(s) {
                        if (Wf) {
                            for (s = s.memoizedState; s !== null; ) {
                                var r = s.queue;
                                r !== null && (r.pending = null),
                                s = s.next
                            }
                            Wf = !1
                        }
                        no = 0,
                        Ci = yn = Ot = null,
                        Nc = !1,
                        eh = $u = 0,
                        Gl = null
                    }
                    function zi() {
                        var s = {
                            memoizedState: null,
                            baseState: null,
                            baseQueue: null,
                            queue: null,
                            next: null
                        };
                        return Ci === null ? Ot.memoizedState = Ci = s : Ci = Ci.next = s,
                        Ci
                    }
                    function xi() {
                        if (yn === null) {
                            var s = Ot.alternate;
                            s = s !== null ? s.memoizedState : null
                        } else
                            s = yn.next;
                        var r = Ci === null ? Ot.memoizedState : Ci.next;
                        if (r !== null)
                            Ci = r,
                            yn = s;
                        else {
                            if (s === null)
                                throw Ot.alternate === null ? Error(a(467)) : Error(a(310));
                            yn = s,
                            s = {
                                memoizedState: yn.memoizedState,
                                baseState: yn.baseState,
                                baseQueue: yn.baseQueue,
                                queue: yn.queue,
                                next: null
                            },
                            Ci === null ? Ot.memoizedState = Ci = s : Ci = Ci.next = s
                        }
                        return Ci
                    }
                    function Yf() {
                        return {
                            lastEffect: null,
                            events: null,
                            stores: null,
                            memoCache: null
                        }
                    }
                    function nh(s) {
                        var r = eh;
                        return eh += 1,
                        Gl === null && (Gl = []),
                        s = Vf(Gl, s, r),
                        r = Ot,
                        (Ci === null ? r.memoizedState : Ci.next) === null && (r = r.alternate,
                        F.H = r === null || r.memoizedState === null ? is : $f),
                        s
                    }
                    function jf(s) {
                        if (s !== null && typeof s == "object") {
                            if (typeof s.then == "function")
                                return nh(s);
                            if (s.$$typeof === D)
                                return ns(s)
                        }
                        throw Error(a(438, String(s)))
                    }
                    function gm(s) {
                        var r = null
                          , h = Ot.updateQueue;
                        if (h !== null && (r = h.memoCache),
                        r == null) {
                            var m = Ot.alternate;
                            m !== null && (m = m.updateQueue,
                            m !== null && (m = m.memoCache,
                            m != null && (r = {
                                data: m.data.map(function(x) {
                                    return x.slice()
                                }),
                                index: 0
                            })))
                        }
                        if (r ??= {
                            data: [],
                            index: 0
                        },
                        h === null && (h = Yf(),
                        Ot.updateQueue = h),
                        h.memoCache = r,
                        h = r.data[r.index],
                        h === void 0)
                            for (h = r.data[r.index] = Array(s),
                            m = 0; m < s; m++)
                                h[m] = G;
                        return r.index++,
                        h
                    }
                    function so(s, r) {
                        return typeof r == "function" ? r(s) : r
                    }
                    function Zf(s) {
                        return vm(xi(), yn, s)
                    }
                    function vm(s, r, h) {
                        var m = s.queue;
                        if (m === null)
                            throw Error(a(311));
                        m.lastRenderedReducer = h;
                        var x = s.baseQueue
                          , b = m.pending;
                        if (b !== null) {
                            if (x !== null) {
                                var L = x.next;
                                x.next = b.next,
                                b.next = L
                            }
                            r.baseQueue = x = b,
                            m.pending = null
                        }
                        if (b = s.baseState,
                        x === null)
                            s.memoizedState = b;
                        else {
                            r = x.next;
                            var W = L = null
                              , ae = null
                              , be = r
                              , ze = !1;
                            do {
                                var Fe = be.lane & -536870913;
                                if (Fe !== be.lane ? (Ut & Fe) === Fe : (no & Fe) === Fe) {
                                    var Ee = be.revertLane;
                                    if (Ee === 0)
                                        ae !== null && (ae = ae.next = {
                                            lane: 0,
                                            revertLane: 0,
                                            gesture: null,
                                            action: be.action,
                                            hasEagerState: be.hasEagerState,
                                            eagerState: be.eagerState,
                                            next: null
                                        }),
                                        Fe === Bl && (ze = !0);
                                    else if ((no & Ee) === Ee) {
                                        be = be.next,
                                        Ee === Bl && (ze = !0);
                                        continue
                                    } else
                                        Fe = {
                                            lane: 0,
                                            revertLane: be.revertLane,
                                            gesture: null,
                                            action: be.action,
                                            hasEagerState: be.hasEagerState,
                                            eagerState: be.eagerState,
                                            next: null
                                        },
                                        ae === null ? (W = ae = Fe,
                                        L = b) : ae = ae.next = Fe,
                                        Ot.lanes |= Ee,
                                        er |= Ee;
                                    Fe = be.action,
                                    Hl && h(b, Fe),
                                    b = be.hasEagerState ? be.eagerState : h(b, Fe)
                                } else
                                    Ee = {
                                        lane: Fe,
                                        revertLane: be.revertLane,
                                        gesture: be.gesture,
                                        action: be.action,
                                        hasEagerState: be.hasEagerState,
                                        eagerState: be.eagerState,
                                        next: null
                                    },
                                    ae === null ? (W = ae = Ee,
                                    L = b) : ae = ae.next = Ee,
                                    Ot.lanes |= Fe,
                                    er |= Fe;
                                be = be.next
                            } while (be !== null && be !== r);
                            if (ae === null ? L = b : ae.next = W,
                            !fs(b, s.memoizedState) && (Rn = !0,
                            ze && (h = Pl,
                            h !== null)))
                                throw h;
                            s.memoizedState = b,
                            s.baseState = L,
                            s.baseQueue = ae,
                            m.lastRenderedState = b
                        }
                        return x === null && (m.lanes = 0),
                        [s.memoizedState, m.dispatch]
                    }
                    function _m(s) {
                        var r = xi()
                          , h = r.queue;
                        if (h === null)
                            throw Error(a(311));
                        h.lastRenderedReducer = s;
                        var m = h.dispatch
                          , x = h.pending
                          , b = r.memoizedState;
                        if (x !== null) {
                            h.pending = null;
                            var L = x = x.next;
                            do
                                b = s(b, L.action),
                                L = L.next;
                            while (L !== x);
                            fs(b, r.memoizedState) || (Rn = !0),
                            r.memoizedState = b,
                            r.baseQueue === null && (r.baseState = b),
                            h.lastRenderedState = b
                        }
                        return [b, m]
                    }
                    function qv(s, r, h) {
                        var m = Ot
                          , x = xi()
                          , b = hn;
                        if (b) {
                            if (h === void 0)
                                throw Error(a(407));
                            h = h()
                        } else
                            h = r();
                        var L = !fs((yn || x).memoizedState, h);
                        if (L && (x.memoizedState = h,
                        Rn = !0),
                        x = x.queue,
                        Cm(ym.bind(null, m, x, s), [s]),
                        x.getSnapshot !== r || L || Ci !== null && Ci.memoizedState.tag & 1) {
                            if (m.flags |= 2048,
                            Dc(9, {
                                destroy: void 0
                            }, Wv.bind(null, m, x, h, r), null),
                            qt === null)
                                throw Error(a(349));
                            b || (no & 127) !== 0 || Xv(m, r, h)
                        }
                        return h
                    }
                    function Xv(s, r, h) {
                        s.flags |= 16384,
                        s = {
                            getSnapshot: r,
                            value: h
                        },
                        r = Ot.updateQueue,
                        r === null ? (r = Yf(),
                        Ot.updateQueue = r,
                        r.stores = [s]) : (h = r.stores,
                        h === null ? r.stores = [s] : h.push(s))
                    }
                    function Wv(s, r, h, m) {
                        r.value = h,
                        r.getSnapshot = m,
                        Yv(r) && jv(s)
                    }
                    function ym(s, r, h) {
                        return h(function() {
                            Yv(r) && jv(s)
                        })
                    }
                    function Yv(s) {
                        var r = s.getSnapshot;
                        s = s.value;
                        try {
                            var h = r();
                            return !fs(s, h)
                        } catch {
                            return !0
                        }
                    }
                    function jv(s) {
                        var r = Yr(s, 2);
                        r !== null && Zi(r, s, 2)
                    }
                    function Sm(s) {
                        var r = zi();
                        if (typeof s == "function") {
                            var h = s;
                            if (s = h(),
                            Hl) {
                                ot(!0);
                                try {
                                    h()
                                } finally {
                                    ot(!1)
                                }
                            }
                        }
                        return r.memoizedState = r.baseState = s,
                        r.queue = {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: so,
                            lastRenderedState: s
                        },
                        r
                    }
                    function Zv(s, r, h, m) {
                        return s.baseState = h,
                        vm(s, yn, typeof m == "function" ? m : so)
                    }
                    function DS(s, r, h, m, x) {
                        if (Jf(s))
                            throw Error(a(485));
                        if (s = r.action,
                        s !== null) {
                            var b = {
                                payload: x,
                                action: s,
                                next: null,
                                isTransition: !0,
                                status: "pending",
                                value: null,
                                reason: null,
                                listeners: [],
                                then: function(L) {
                                    b.listeners.push(L)
                                }
                            };
                            F.T !== null ? h(!0) : b.isTransition = !1,
                            m(b),
                            h = r.pending,
                            h === null ? (b.next = r.pending = b,
                            Qv(r, b)) : (b.next = h.next,
                            r.pending = h.next = b)
                        }
                    }
                    function Qv(s, r) {
                        var h = r.action
                          , m = r.payload
                          , x = s.state;
                        if (r.isTransition) {
                            var b = F.T
                              , L = {};
                            F.T = L;
                            try {
                                var W = h(x, m)
                                  , ae = F.S;
                                ae !== null && ae(L, W),
                                xm(s, r, W)
                            } catch (be) {
                                bm(s, r, be)
                            } finally {
                                b !== null && L.types !== null && (b.types = L.types),
                                F.T = b
                            }
                        } else
                            try {
                                b = h(x, m),
                                xm(s, r, b)
                            } catch (be) {
                                bm(s, r, be)
                            }
                    }
                    function xm(s, r, h) {
                        h !== null && typeof h == "object" && typeof h.then == "function" ? h.then(function(m) {
                            Mm(s, r, m)
                        }, function(m) {
                            return bm(s, r, m)
                        }) : Mm(s, r, h)
                    }
                    function Mm(s, r, h) {
                        r.status = "fulfilled",
                        r.value = h,
                        Tm(r),
                        s.state = h,
                        r = s.pending,
                        r !== null && (h = r.next,
                        h === r ? s.pending = null : (h = h.next,
                        r.next = h,
                        Qv(s, h)))
                    }
                    function bm(s, r, h) {
                        var m = s.pending;
                        if (s.pending = null,
                        m !== null) {
                            m = m.next;
                            do
                                r.status = "rejected",
                                r.reason = h,
                                Tm(r),
                                r = r.next;
                            while (r !== m)
                        }
                        s.action = null
                    }
                    function Tm(s) {
                        s = s.listeners;
                        for (var r = 0; r < s.length; r++)
                            (0,
                            s[r])()
                    }
                    function Am(s, r) {
                        return r
                    }
                    function Em(s, r) {
                        if (hn) {
                            var h = qt.formState;
                            if (h !== null) {
                                e: {
                                    var m = Ot;
                                    if (hn) {
                                        if (Wn) {
                                            t: {
                                                for (var x = Wn, b = Ea; x.nodeType !== 8; ) {
                                                    if (!b) {
                                                        x = null;
                                                        break t
                                                    }
                                                    if (x = Or(x.nextSibling),
                                                    x === null) {
                                                        x = null;
                                                        break t
                                                    }
                                                }
                                                b = x.data,
                                                x = b === "F!" || b === "F" ? x : null
                                            }
                                            if (x) {
                                                Wn = Or(x.nextSibling),
                                                m = x.data === "F!";
                                                break e
                                            }
                                        }
                                        Vo(m)
                                    }
                                    m = !1
                                }
                                m && (r = h[0])
                            }
                        }
                        return h = zi(),
                        h.memoizedState = h.baseState = r,
                        m = {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: Am,
                            lastRenderedState: r
                        },
                        h.queue = m,
                        h = Im.bind(null, Ot, m),
                        m.dispatch = h,
                        m = Sm(!1),
                        b = zm.bind(null, Ot, !1, m.queue),
                        m = zi(),
                        x = {
                            state: r,
                            dispatch: null,
                            action: s,
                            pending: null
                        },
                        m.queue = x,
                        h = DS.bind(null, Ot, x, b, h),
                        x.dispatch = h,
                        m.memoizedState = s,
                        [r, h, !1]
                    }
                    function Qf(s) {
                        return Kf(xi(), yn, s)
                    }
                    function Kf(s, r, h) {
                        if (r = vm(s, r, Am)[0],
                        s = Zf(so)[0],
                        typeof r == "object" && r !== null && typeof r.then == "function")
                            try {
                                var m = nh(r)
                            } catch (L) {
                                throw L === Ac ? Kr : L
                            }
                        else
                            m = r;
                        r = xi();
                        var x = r.queue
                          , b = x.dispatch;
                        return h !== r.memoizedState && (Ot.flags |= 2048,
                        Dc(9, {
                            destroy: void 0
                        }, OS.bind(null, x, h), null)),
                        [m, b, s]
                    }
                    function OS(s, r) {
                        s.action = r
                    }
                    function Kv(s) {
                        var r = xi()
                          , h = yn;
                        if (h !== null)
                            return Kf(r, h, s);
                        xi(),
                        r = r.memoizedState,
                        h = xi();
                        var m = h.queue.dispatch;
                        return h.memoizedState = s,
                        [r, m, !1]
                    }
                    function Dc(s, r, h, m) {
                        return s = {
                            tag: s,
                            create: h,
                            deps: m,
                            inst: r,
                            next: null
                        },
                        r = Ot.updateQueue,
                        r === null && (r = Yf(),
                        Ot.updateQueue = r),
                        h = r.lastEffect,
                        h === null ? r.lastEffect = s.next = s : (m = h.next,
                        h.next = s,
                        s.next = m,
                        r.lastEffect = s),
                        s
                    }
                    function Jv() {
                        return xi().memoizedState
                    }
                    function ih(s, r, h, m) {
                        var x = zi();
                        Ot.flags |= s,
                        x.memoizedState = Dc(1 | r, {
                            destroy: void 0
                        }, h, m === void 0 ? null : m)
                    }
                    function sh(s, r, h, m) {
                        var x = xi();
                        m = m === void 0 ? null : m;
                        var b = x.memoizedState.inst;
                        yn !== null && m !== null && io(m, yn.memoizedState.deps) ? x.memoizedState = Dc(r, b, h, m) : (Ot.flags |= s,
                        x.memoizedState = Dc(1 | r, b, h, m))
                    }
                    function $v(s, r) {
                        ih(8390656, 8, s, r)
                    }
                    function Cm(s, r) {
                        sh(2048, 8, s, r)
                    }
                    function US(s) {
                        Ot.flags |= 4;
                        var r = Ot.updateQueue;
                        if (r === null)
                            r = Yf(),
                            Ot.updateQueue = r,
                            r.events = [s];
                        else {
                            var h = r.events;
                            h === null ? r.events = [s] : h.push(s)
                        }
                    }
                    function e_(s) {
                        var r = xi().memoizedState;
                        return US({
                            ref: r,
                            nextImpl: s
                        }),
                        function() {
                            if ((An & 2) !== 0)
                                throw Error(a(440));
                            return r.impl.apply(void 0, arguments)
                        }
                    }
                    function t_(s, r) {
                        return sh(4, 2, s, r)
                    }
                    function n_(s, r) {
                        return sh(4, 4, s, r)
                    }
                    function i_(s, r) {
                        if (typeof r == "function") {
                            s = s();
                            var h = r(s);
                            return function() {
                                typeof h == "function" ? h() : r(null)
                            }
                        }
                        if (r != null)
                            return s = s(),
                            r.current = s,
                            function() {
                                r.current = null
                            }
                    }
                    function s_(s, r, h) {
                        h = h != null ? h.concat([s]) : null,
                        sh(4, 4, i_.bind(null, r, s), h)
                    }
                    function wm() {}
                    function a_(s, r) {
                        var h = xi();
                        r = r === void 0 ? null : r;
                        var m = h.memoizedState;
                        return r !== null && io(r, m[1]) ? m[0] : (h.memoizedState = [s, r],
                        s)
                    }
                    function r_(s, r) {
                        var h = xi();
                        r = r === void 0 ? null : r;
                        var m = h.memoizedState;
                        if (r !== null && io(r, m[1]))
                            return m[0];
                        if (m = s(),
                        Hl) {
                            ot(!0);
                            try {
                                s()
                            } finally {
                                ot(!1)
                            }
                        }
                        return h.memoizedState = [m, r],
                        m
                    }
                    function Rm(s, r, h) {
                        return h === void 0 || (no & 1073741824) !== 0 && (Ut & 261930) === 0 ? s.memoizedState = r : (s.memoizedState = h,
                        s = dd(),
                        Ot.lanes |= s,
                        er |= s,
                        h)
                    }
                    function o_(s, r, h, m) {
                        return fs(h, r) ? h : wc.current !== null ? (s = Rm(s, h, m),
                        fs(s, r) || (Rn = !0),
                        s) : (no & 42) === 0 || (no & 1073741824) !== 0 && (Ut & 261930) === 0 ? (Rn = !0,
                        s.memoizedState = h) : (s = dd(),
                        Ot.lanes |= s,
                        er |= s,
                        r)
                    }
                    function Nm(s, r, h, m, x) {
                        var b = X.p;
                        X.p = b !== 0 && 8 > b ? b : 8;
                        var L = F.T
                          , W = {};
                        F.T = W,
                        zm(s, !1, r, h);
                        try {
                            var ae = x()
                              , be = F.S;
                            be !== null && be(W, ae),
                            ae !== null && typeof ae == "object" && typeof ae.then == "function" ? Oc(s, r, Bv(ae, m), Vs(s)) : Oc(s, r, m, Vs(s))
                        } catch (ze) {
                            Oc(s, r, {
                                then: function() {},
                                status: "rejected",
                                reason: ze
                            }, Vs())
                        } finally {
                            X.p = b,
                            L !== null && W.types !== null && (L.types = W.types),
                            F.T = L
                        }
                    }
                    function LS() {}
                    function Dm(s, r, h, m) {
                        if (s.tag !== 5)
                            throw Error(a(476));
                        var x = na(s).queue;
                        Nm(s, x, r, $, h === null ? LS : function() {
                            return Om(s),
                            h(m)
                        }
                        )
                    }
                    function na(s) {
                        var r = s.memoizedState;
                        if (r !== null)
                            return r;
                        r = {
                            memoizedState: $,
                            baseState: $,
                            baseQueue: null,
                            queue: {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: so,
                                lastRenderedState: $
                            },
                            next: null
                        };
                        var h = {};
                        return r.next = {
                            memoizedState: h,
                            baseState: h,
                            baseQueue: null,
                            queue: {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: so,
                                lastRenderedState: h
                            },
                            next: null
                        },
                        s.memoizedState = r,
                        s = s.alternate,
                        s !== null && (s.memoizedState = r),
                        r
                    }
                    function Om(s) {
                        var r = na(s);
                        r.next === null && (r = s.alternate.memoizedState),
                        Oc(s, r.next.queue, {}, Vs())
                    }
                    function ah() {
                        return ns(Km)
                    }
                    function Um() {
                        return xi().memoizedState
                    }
                    function Lm() {
                        return xi().memoizedState
                    }
                    function l_(s) {
                        for (var r = s.return; r !== null; ) {
                            switch (r.tag) {
                            case 24:
                            case 3:
                                var h = Vs();
                                s = eo(h);
                                var m = Sr(r, s, h);
                                m !== null && (Zi(m, r, h),
                                Zu(m, r, h)),
                                r = {
                                    cache: zf()
                                },
                                s.payload = r;
                                return
                            }
                            r = r.return
                        }
                    }
                    function IS(s, r, h) {
                        var m = Vs();
                        h = {
                            lane: m,
                            revertLane: 0,
                            gesture: null,
                            action: h,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        },
                        Jf(s) ? c_(r, h) : (h = Fu(s, r, h, m),
                        h !== null && (Zi(h, s, m),
                        Bm(h, r, m)))
                    }
                    function Im(s, r, h) {
                        Oc(s, r, h, Vs())
                    }
                    function Oc(s, r, h, m) {
                        var x = {
                            lane: m,
                            revertLane: 0,
                            gesture: null,
                            action: h,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        };
                        if (Jf(s))
                            c_(r, x);
                        else {
                            var b = s.alternate;
                            if (s.lanes === 0 && (b === null || b.lanes === 0) && (b = r.lastRenderedReducer,
                            b !== null))
                                try {
                                    var L = r.lastRenderedState
                                      , W = b(L, h);
                                    if (x.hasEagerState = !0,
                                    x.eagerState = W,
                                    fs(W, L))
                                        return Ya(s, r, x, 0),
                                        qt === null && Wr(),
                                        !1
                                } catch {}
                            if (h = Fu(s, r, x, m),
                            h !== null)
                                return Zi(h, s, m),
                                Bm(h, r, m),
                                !0
                        }
                        return !1
                    }
                    function zm(s, r, h, m) {
                        if (m = {
                            lane: 2,
                            revertLane: FS(),
                            gesture: null,
                            action: m,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        },
                        Jf(s)) {
                            if (r)
                                throw Error(a(479))
                        } else
                            r = Fu(s, h, m, 2),
                            r !== null && Zi(r, s, 2)
                    }
                    function Jf(s) {
                        var r = s.alternate;
                        return s === Ot || r !== null && r === Ot
                    }
                    function c_(s, r) {
                        Nc = Wf = !0;
                        var h = s.pending;
                        h === null ? r.next = r : (r.next = h.next,
                        h.next = r),
                        s.pending = r
                    }
                    function Bm(s, r, h) {
                        if ((h & 4194048) !== 0) {
                            var m = r.lanes;
                            m &= s.pendingLanes,
                            h |= m,
                            r.lanes = h,
                            vc(s, h)
                        }
                    }
                    var rh = {
                        readContext: ns,
                        use: jf,
                        useCallback: Gn,
                        useContext: Gn,
                        useEffect: Gn,
                        useImperativeHandle: Gn,
                        useLayoutEffect: Gn,
                        useInsertionEffect: Gn,
                        useMemo: Gn,
                        useReducer: Gn,
                        useRef: Gn,
                        useState: Gn,
                        useDebugValue: Gn,
                        useDeferredValue: Gn,
                        useTransition: Gn,
                        useSyncExternalStore: Gn,
                        useId: Gn,
                        useHostTransitionStatus: Gn,
                        useFormState: Gn,
                        useActionState: Gn,
                        useOptimistic: Gn,
                        useMemoCache: Gn,
                        useCacheRefresh: Gn
                    };
                    rh.useEffectEvent = Gn;
                    var is = {
                        readContext: ns,
                        use: jf,
                        useCallback: function(s, r) {
                            return zi().memoizedState = [s, r === void 0 ? null : r],
                            s
                        },
                        useContext: ns,
                        useEffect: $v,
                        useImperativeHandle: function(s, r, h) {
                            h = h != null ? h.concat([s]) : null,
                            ih(4194308, 4, i_.bind(null, r, s), h)
                        },
                        useLayoutEffect: function(s, r) {
                            return ih(4194308, 4, s, r)
                        },
                        useInsertionEffect: function(s, r) {
                            ih(4, 2, s, r)
                        },
                        useMemo: function(s, r) {
                            var h = zi();
                            r = r === void 0 ? null : r;
                            var m = s();
                            if (Hl) {
                                ot(!0);
                                try {
                                    s()
                                } finally {
                                    ot(!1)
                                }
                            }
                            return h.memoizedState = [m, r],
                            m
                        },
                        useReducer: function(s, r, h) {
                            var m = zi();
                            if (h !== void 0) {
                                var x = h(r);
                                if (Hl) {
                                    ot(!0);
                                    try {
                                        h(r)
                                    } finally {
                                        ot(!1)
                                    }
                                }
                            } else
                                x = r;
                            return m.memoizedState = m.baseState = x,
                            s = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: s,
                                lastRenderedState: x
                            },
                            m.queue = s,
                            s = s.dispatch = IS.bind(null, Ot, s),
                            [m.memoizedState, s]
                        },
                        useRef: function(s) {
                            var r = zi();
                            return s = {
                                current: s
                            },
                            r.memoizedState = s
                        },
                        useState: function(s) {
                            s = Sm(s);
                            var r = s.queue
                              , h = Im.bind(null, Ot, r);
                            return r.dispatch = h,
                            [s.memoizedState, h]
                        },
                        useDebugValue: wm,
                        useDeferredValue: function(s, r) {
                            return Rm(zi(), s, r)
                        },
                        useTransition: function() {
                            var s = Sm(!1);
                            return s = Nm.bind(null, Ot, s.queue, !0, !1),
                            zi().memoizedState = s,
                            [!1, s]
                        },
                        useSyncExternalStore: function(s, r, h) {
                            var m = Ot
                              , x = zi();
                            if (hn) {
                                if (h === void 0)
                                    throw Error(a(407));
                                h = h()
                            } else {
                                if (h = r(),
                                qt === null)
                                    throw Error(a(349));
                                (Ut & 127) !== 0 || Xv(m, r, h)
                            }
                            x.memoizedState = h;
                            var b = {
                                value: h,
                                getSnapshot: r
                            };
                            return x.queue = b,
                            $v(ym.bind(null, m, b, s), [s]),
                            m.flags |= 2048,
                            Dc(9, {
                                destroy: void 0
                            }, Wv.bind(null, m, b, h, r), null),
                            h
                        },
                        useId: function() {
                            var s = zi()
                              , r = qt.identifierPrefix;
                            if (hn) {
                                var h = Wi
                                  , m = gr;
                                h = (m & ~(1 << 32 - tt(m) - 1)).toString(32) + h,
                                r = "_" + r + "R_" + h,
                                h = $u++,
                                0 < h && (r += "H" + h.toString(32)),
                                r += "_"
                            } else
                                h = NS++,
                                r = "_" + r + "r_" + h.toString(32) + "_";
                            return s.memoizedState = r
                        },
                        useHostTransitionStatus: ah,
                        useFormState: Em,
                        useActionState: Em,
                        useOptimistic: function(s) {
                            var r = zi();
                            r.memoizedState = r.baseState = s;
                            var h = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: null,
                                lastRenderedState: null
                            };
                            return r.queue = h,
                            r = zm.bind(null, Ot, !0, h),
                            h.dispatch = r,
                            [s, r]
                        },
                        useMemoCache: gm,
                        useCacheRefresh: function() {
                            return zi().memoizedState = l_.bind(null, Ot)
                        },
                        useEffectEvent: function(s) {
                            var r = zi()
                              , h = {
                                impl: s
                            };
                            return r.memoizedState = h,
                            function() {
                                if ((An & 2) !== 0)
                                    throw Error(a(440));
                                return h.impl.apply(void 0, arguments)
                            }
                        }
                    }
                      , $f = {
                        readContext: ns,
                        use: jf,
                        useCallback: a_,
                        useContext: ns,
                        useEffect: Cm,
                        useImperativeHandle: s_,
                        useInsertionEffect: t_,
                        useLayoutEffect: n_,
                        useMemo: r_,
                        useReducer: Zf,
                        useRef: Jv,
                        useState: function() {
                            return Zf(so)
                        },
                        useDebugValue: wm,
                        useDeferredValue: function(s, r) {
                            return o_(xi(), yn.memoizedState, s, r)
                        },
                        useTransition: function() {
                            var s = Zf(so)[0]
                              , r = xi().memoizedState;
                            return [typeof s == "boolean" ? s : nh(s), r]
                        },
                        useSyncExternalStore: qv,
                        useId: Um,
                        useHostTransitionStatus: ah,
                        useFormState: Qf,
                        useActionState: Qf,
                        useOptimistic: function(s, r) {
                            return Zv(xi(), yn, s, r)
                        },
                        useMemoCache: gm,
                        useCacheRefresh: Lm
                    };
                    $f.useEffectEvent = e_;
                    var u_ = {
                        readContext: ns,
                        use: jf,
                        useCallback: a_,
                        useContext: ns,
                        useEffect: Cm,
                        useImperativeHandle: s_,
                        useInsertionEffect: t_,
                        useLayoutEffect: n_,
                        useMemo: r_,
                        useReducer: _m,
                        useRef: Jv,
                        useState: function() {
                            return _m(so)
                        },
                        useDebugValue: wm,
                        useDeferredValue: function(s, r) {
                            var h = xi();
                            return yn === null ? Rm(h, s, r) : o_(h, yn.memoizedState, s, r)
                        },
                        useTransition: function() {
                            var s = _m(so)[0]
                              , r = xi().memoizedState;
                            return [typeof s == "boolean" ? s : nh(s), r]
                        },
                        useSyncExternalStore: qv,
                        useId: Um,
                        useHostTransitionStatus: ah,
                        useFormState: Kv,
                        useActionState: Kv,
                        useOptimistic: function(s, r) {
                            var h = xi();
                            return yn !== null ? Zv(h, yn, s, r) : (h.baseState = s,
                            [s, h.queue.dispatch])
                        },
                        useMemoCache: gm,
                        useCacheRefresh: Lm
                    };
                    u_.useEffectEvent = e_;
                    function Pm(s, r, h, m) {
                        r = s.memoizedState,
                        h = h(m, r),
                        h = h == null ? r : y({}, r, h),
                        s.memoizedState = h,
                        s.lanes === 0 && (s.updateQueue.baseState = h)
                    }
                    var Vm = {
                        enqueueSetState: function(s, r, h) {
                            s = s._reactInternals;
                            var m = Vs()
                              , x = eo(m);
                            x.payload = r,
                            h != null && (x.callback = h),
                            r = Sr(s, x, m),
                            r !== null && (Zi(r, s, m),
                            Zu(r, s, m))
                        },
                        enqueueReplaceState: function(s, r, h) {
                            s = s._reactInternals;
                            var m = Vs()
                              , x = eo(m);
                            x.tag = 1,
                            x.payload = r,
                            h != null && (x.callback = h),
                            r = Sr(s, x, m),
                            r !== null && (Zi(r, s, m),
                            Zu(r, s, m))
                        },
                        enqueueForceUpdate: function(s, r) {
                            s = s._reactInternals;
                            var h = Vs()
                              , m = eo(h);
                            m.tag = 2,
                            r != null && (m.callback = r),
                            r = Sr(s, m, h),
                            r !== null && (Zi(r, s, h),
                            Zu(r, s, h))
                        }
                    };
                    function Fm(s, r, h, m, x, b, L) {
                        return s = s.stateNode,
                        typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(m, b, L) : r.prototype && r.prototype.isPureReactComponent ? !Xr(h, m) || !Xr(x, b) : !0
                    }
                    function ed(s, r, h, m) {
                        s = r.state,
                        typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(h, m),
                        typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(h, m),
                        r.state !== s && Vm.enqueueReplaceState(r, r.state, null)
                    }
                    function Ra(s, r) {
                        var h = r;
                        if ("ref"in r) {
                            h = {};
                            for (var m in r)
                                m !== "ref" && (h[m] = r[m])
                        }
                        if (s = s.defaultProps) {
                            h === r && (h = y({}, h));
                            for (var x in s)
                                h[x] === void 0 && (h[x] = s[x])
                        }
                        return h
                    }
                    function Uc(s) {
                        Vu(s)
                    }
                    function ia(s) {
                        console.error(s)
                    }
                    function zS(s) {
                        Vu(s)
                    }
                    function td(s, r) {
                        try {
                            var h = s.onUncaughtError;
                            h(r.value, {
                                componentStack: r.stack
                            })
                        } catch (m) {
                            setTimeout(function() {
                                throw m
                            })
                        }
                    }
                    function oh(s, r, h) {
                        try {
                            var m = s.onCaughtError;
                            m(h.value, {
                                componentStack: h.stack,
                                errorBoundary: r.tag === 1 ? r.stateNode : null
                            })
                        } catch (x) {
                            setTimeout(function() {
                                throw x
                            })
                        }
                    }
                    function Lc(s, r, h) {
                        return h = eo(h),
                        h.tag = 3,
                        h.payload = {
                            element: null
                        },
                        h.callback = function() {
                            td(s, r)
                        }
                        ,
                        h
                    }
                    function lh(s) {
                        return s = eo(s),
                        s.tag = 3,
                        s
                    }
                    function nd(s, r, h, m) {
                        var x = h.type.getDerivedStateFromError;
                        if (typeof x == "function") {
                            var b = m.value;
                            s.payload = function() {
                                return x(b)
                            }
                            ,
                            s.callback = function() {
                                oh(r, h, m)
                            }
                        }
                        var L = h.stateNode;
                        L !== null && typeof L.componentDidCatch == "function" && (s.callback = function() {
                            oh(r, h, m),
                            typeof x != "function" && (Dr === null ? Dr = new Set([this]) : Dr.add(this));
                            var W = m.stack;
                            this.componentDidCatch(m.value, {
                                componentStack: W !== null ? W : ""
                            })
                        }
                        )
                    }
                    function BS(s, r, h, m, x) {
                        if (h.flags |= 32768,
                        m !== null && typeof m == "object" && typeof m.then == "function") {
                            if (r = h.alternate,
                            r !== null && Ul(r, h, x, !0),
                            h = Ls.current,
                            h !== null) {
                                switch (h.tag) {
                                case 31:
                                case 13:
                                    return wa === null ? _() : h.alternate === null && ti === 0 && (ti = 3),
                                    h.flags &= -257,
                                    h.flags |= 65536,
                                    h.lanes = x,
                                    m === Jr ? h.flags |= 16384 : (r = h.updateQueue,
                                    r === null ? h.updateQueue = new Set([m]) : r.add(m),
                                    Et(s, m, x)),
                                    !1;
                                case 22:
                                    return h.flags |= 65536,
                                    m === Jr ? h.flags |= 16384 : (r = h.updateQueue,
                                    r === null ? (r = {
                                        transitions: null,
                                        markerInstances: null,
                                        retryQueue: new Set([m])
                                    },
                                    h.updateQueue = r) : (h = r.retryQueue,
                                    h === null ? r.retryQueue = new Set([m]) : h.add(m)),
                                    Et(s, m, x)),
                                    !1
                                }
                                throw Error(a(435, h.tag))
                            }
                            return Et(s, m, x),
                            _(),
                            !1
                        }
                        if (hn)
                            return r = Ls.current,
                            r !== null ? ((r.flags & 65536) === 0 && (r.flags |= 256),
                            r.flags |= 65536,
                            r.lanes = x,
                            m !== nm && (s = Error(a(422), {
                                cause: m
                            }),
                            Tc(ea(s, h)))) : (m !== nm && (r = Error(a(423), {
                                cause: m
                            }),
                            Tc(ea(r, h))),
                            s = s.current.alternate,
                            s.flags |= 65536,
                            x &= -x,
                            s.lanes |= x,
                            m = ea(m, h),
                            x = Lc(s.stateNode, m, x),
                            hm(s, x),
                            ti !== 4 && (ti = 2)),
                            !1;
                        var b = Error(a(520), {
                            cause: m
                        });
                        if (b = ea(b, h),
                        Nn === null ? Nn = [b] : Nn.push(b),
                        ti !== 4 && (ti = 2),
                        r === null)
                            return !0;
                        m = ea(m, h),
                        h = r;
                        do {
                            switch (h.tag) {
                            case 3:
                                return h.flags |= 65536,
                                s = x & -x,
                                h.lanes |= s,
                                s = Lc(h.stateNode, m, s),
                                hm(h, s),
                                !1;
                            case 1:
                                if (r = h.type,
                                b = h.stateNode,
                                (h.flags & 128) === 0 && (typeof r.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (Dr === null || !Dr.has(b))))
                                    return h.flags |= 65536,
                                    x &= -x,
                                    h.lanes |= x,
                                    x = lh(x),
                                    nd(x, s, h, m),
                                    hm(h, x),
                                    !1
                            }
                            h = h.return
                        } while (h !== null);
                        return !1
                    }
                    var Hm = Error(a(461))
                      , Rn = !1;
                    function ji(s, r, h, m) {
                        r.child = s === null ? Vv(r, null, h, m) : qo(r, s.child, h, m)
                    }
                    function h_(s, r, h, m, x) {
                        h = h.render;
                        var b = r.ref;
                        if ("ref"in m) {
                            var L = {};
                            for (var W in m)
                                W !== "ref" && (L[W] = m[W])
                        } else
                            L = m;
                        return Ll(r),
                        m = fm(s, r, h, L, b, x),
                        W = dm(),
                        s !== null && !Rn ? (pm(s, r, x),
                        Jt(s, r, x)) : (hn && W && Po(r),
                        r.flags |= 1,
                        ji(s, r, m, x),
                        r.child)
                    }
                    function id(s, r, h, m, x) {
                        if (s === null) {
                            var b = h.type;
                            return typeof b == "function" && !Af(b) && b.defaultProps === void 0 && h.compare === null ? (r.tag = 15,
                            r.type = b,
                            f_(s, r, b, m, x)) : (s = ku(h.type, null, m, r, r.mode, x),
                            s.ref = r.ref,
                            s.return = r,
                            r.child = s)
                        }
                        if (b = s.child,
                        !aa(s, x)) {
                            var L = b.memoizedProps;
                            if (h = h.compare,
                            h = h !== null ? h : Xr,
                            h(L, m) && s.ref === r.ref)
                                return Jt(s, r, x)
                        }
                        return r.flags |= 1,
                        s = pr(b, m),
                        s.ref = r.ref,
                        s.return = r,
                        r.child = s
                    }
                    function f_(s, r, h, m, x) {
                        if (s !== null) {
                            var b = s.memoizedProps;
                            if (Xr(b, m) && s.ref === r.ref)
                                if (Rn = !1,
                                r.pendingProps = m = b,
                                aa(s, x))
                                    (s.flags & 131072) !== 0 && (Rn = !0);
                                else
                                    return r.lanes = s.lanes,
                                    Jt(s, r, x)
                        }
                        return Wo(s, r, h, m, x)
                    }
                    function d_(s, r, h, m) {
                        var x = m.children
                          , b = s !== null ? s.memoizedState : null;
                        if (s === null && r.stateNode === null && (r.stateNode = {
                            _visibility: 1,
                            _pendingMarkers: null,
                            _retryCache: null,
                            _transitions: null
                        }),
                        m.mode === "hidden") {
                            if ((r.flags & 128) !== 0) {
                                if (b = b !== null ? b.baseLanes | h : h,
                                s !== null) {
                                    for (m = r.child = s.child,
                                    x = 0; m !== null; )
                                        x = x | m.lanes | m.childLanes,
                                        m = m.sibling;
                                    m = x & ~b
                                } else
                                    m = 0,
                                    r.child = null;
                                return Ic(s, r, b, h, m)
                            }
                            if ((h & 536870912) !== 0)
                                r.memoizedState = {
                                    baseLanes: 0,
                                    cachePool: null
                                },
                                s !== null && ds(r, b !== null ? b.cachePool : null),
                                b !== null ? qf(r, b) : Xf(),
                                xr(r);
                            else
                                return m = r.lanes = 536870912,
                                Ic(s, r, b !== null ? b.baseLanes | h : h, h, m)
                        } else
                            b !== null ? (ds(r, b.cachePool),
                            qf(r, b),
                            ci(r),
                            r.memoizedState = null) : (s !== null && ds(r, null),
                            Xf(),
                            ci(r));
                        return ji(s, r, x, h),
                        r.child
                    }
                    function ch(s, r) {
                        return s !== null && s.tag === 22 || r.stateNode !== null || (r.stateNode = {
                            _visibility: 1,
                            _pendingMarkers: null,
                            _retryCache: null,
                            _transitions: null
                        }),
                        r.sibling
                    }
                    function Ic(s, r, h, m, x) {
                        var b = cm();
                        return b = b === null ? null : {
                            parent: Yn._currentValue,
                            pool: b
                        },
                        r.memoizedState = {
                            baseLanes: h,
                            cachePool: b
                        },
                        s !== null && ds(r, null),
                        Xf(),
                        xr(r),
                        s !== null && Ul(s, r, m, !0),
                        r.childLanes = x,
                        null
                    }
                    function ps(s, r) {
                        return r = Yo({
                            mode: r.mode,
                            children: r.children
                        }, s.mode),
                        r.ref = s.ref,
                        s.child = r,
                        r.return = s,
                        r
                    }
                    function Is(s, r, h) {
                        return qo(r, s.child, null, h),
                        s = ps(r, r.pendingProps),
                        s.flags |= 2,
                        Ei(r),
                        r.memoizedState = null,
                        s
                    }
                    function p_(s, r, h) {
                        var m = r.pendingProps
                          , x = (r.flags & 128) !== 0;
                        if (r.flags &= -129,
                        s === null) {
                            if (hn) {
                                if (m.mode === "hidden")
                                    return s = ps(r, m),
                                    r.lanes = 536870912,
                                    ch(null, s);
                                if (Ku(r),
                                (s = Wn) ? (s = zT(s, Ea),
                                s = s !== null && s.data === "&" ? s : null,
                                s !== null && (r.memoizedState = {
                                    dehydrated: s,
                                    treeContext: Zr !== null ? {
                                        id: gr,
                                        overflow: Wi
                                    } : null,
                                    retryLane: 536870912,
                                    hydrationErrors: null
                                },
                                h = Cf(s),
                                h.return = r,
                                r.child = h,
                                Yi = r,
                                Wn = null)) : s = null,
                                s === null)
                                    throw Vo(r);
                                return r.lanes = 536870912,
                                null
                            }
                            return ps(r, m)
                        }
                        var b = s.memoizedState;
                        if (b !== null) {
                            var L = b.dehydrated;
                            if (Ku(r),
                            x)
                                if (r.flags & 256)
                                    r.flags &= -257,
                                    r = Is(s, r, h);
                                else if (r.memoizedState !== null)
                                    r.child = s.child,
                                    r.flags |= 128,
                                    r = null;
                                else
                                    throw Error(a(558));
                            else if (Rn || Ul(s, r, h, !1),
                            x = (h & s.childLanes) !== 0,
                            Rn || x) {
                                if (m = qt,
                                m !== null && (L = Ml(m, h),
                                L !== 0 && L !== b.retryLane))
                                    throw b.retryLane = L,
                                    Yr(s, L),
                                    Zi(m, s, L),
                                    Hm;
                                _(),
                                r = Is(s, r, h)
                            } else
                                s = b.treeContext,
                                Wn = Or(L.nextSibling),
                                Yi = r,
                                hn = !0,
                                _r = null,
                                Ea = !1,
                                s !== null && tm(r, s),
                                r = ps(r, m),
                                r.flags |= 4096;
                            return r
                        }
                        return s = pr(s.child, {
                            mode: m.mode,
                            children: m.children
                        }),
                        s.ref = r.ref,
                        r.child = s,
                        s.return = r,
                        s
                    }
                    function ao(s, r) {
                        var h = r.ref;
                        if (h === null)
                            s !== null && s.ref !== null && (r.flags |= 4194816);
                        else {
                            if (typeof h != "function" && typeof h != "object")
                                throw Error(a(284));
                            (s === null || s.ref !== h) && (r.flags |= 4194816)
                        }
                    }
                    function Wo(s, r, h, m, x) {
                        return Ll(r),
                        h = fm(s, r, h, m, void 0, x),
                        m = dm(),
                        s !== null && !Rn ? (pm(s, r, x),
                        Jt(s, r, x)) : (hn && m && Po(r),
                        r.flags |= 1,
                        ji(s, r, h, x),
                        r.child)
                    }
                    function uh(s, r, h, m, x, b) {
                        return Ll(r),
                        r.updateQueue = null,
                        h = kv(r, m, h, x),
                        Gv(s),
                        m = dm(),
                        s !== null && !Rn ? (pm(s, r, b),
                        Jt(s, r, b)) : (hn && m && Po(r),
                        r.flags |= 1,
                        ji(s, r, h, b),
                        r.child)
                    }
                    function hh(s, r, h, m, x) {
                        if (Ll(r),
                        r.stateNode === null) {
                            var b = ja
                              , L = h.contextType;
                            typeof L == "object" && L !== null && (b = ns(L)),
                            b = new h(m,b),
                            r.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null,
                            b.updater = Vm,
                            r.stateNode = b,
                            b._reactInternals = r,
                            b = r.stateNode,
                            b.props = m,
                            b.state = r.memoizedState,
                            b.refs = {},
                            ju(r),
                            L = h.contextType,
                            b.context = typeof L == "object" && L !== null ? ns(L) : ja,
                            b.state = r.memoizedState,
                            L = h.getDerivedStateFromProps,
                            typeof L == "function" && (Pm(r, h, L, m),
                            b.state = r.memoizedState),
                            typeof h.getDerivedStateFromProps == "function" || typeof b.getSnapshotBeforeUpdate == "function" || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (L = b.state,
                            typeof b.componentWillMount == "function" && b.componentWillMount(),
                            typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(),
                            L !== b.state && Vm.enqueueReplaceState(b, b.state, null),
                            Qu(r, m, b, x),
                            to(),
                            b.state = r.memoizedState),
                            typeof b.componentDidMount == "function" && (r.flags |= 4194308),
                            m = !0
                        } else if (s === null) {
                            b = r.stateNode;
                            var W = r.memoizedProps
                              , ae = Ra(h, W);
                            b.props = ae;
                            var be = b.context
                              , ze = h.contextType;
                            L = ja,
                            typeof ze == "object" && ze !== null && (L = ns(ze));
                            var Fe = h.getDerivedStateFromProps;
                            ze = typeof Fe == "function" || typeof b.getSnapshotBeforeUpdate == "function",
                            W = r.pendingProps !== W,
                            ze || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (W || be !== L) && ed(r, b, m, L),
                            zt = !1;
                            var Ee = r.memoizedState;
                            b.state = Ee,
                            Qu(r, m, b, x),
                            to(),
                            be = r.memoizedState,
                            W || Ee !== be || zt ? (typeof Fe == "function" && (Pm(r, h, Fe, m),
                            be = r.memoizedState),
                            (ae = zt || Fm(r, h, ae, m, Ee, be, L)) ? (ze || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (typeof b.componentWillMount == "function" && b.componentWillMount(),
                            typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()),
                            typeof b.componentDidMount == "function" && (r.flags |= 4194308)) : (typeof b.componentDidMount == "function" && (r.flags |= 4194308),
                            r.memoizedProps = m,
                            r.memoizedState = be),
                            b.props = m,
                            b.state = be,
                            b.context = L,
                            m = ae) : (typeof b.componentDidMount == "function" && (r.flags |= 4194308),
                            m = !1)
                        } else {
                            b = r.stateNode,
                            Hf(s, r),
                            L = r.memoizedProps,
                            ze = Ra(h, L),
                            b.props = ze,
                            Fe = r.pendingProps,
                            Ee = b.context,
                            be = h.contextType,
                            ae = ja,
                            typeof be == "object" && be !== null && (ae = ns(be)),
                            W = h.getDerivedStateFromProps,
                            (be = typeof W == "function" || typeof b.getSnapshotBeforeUpdate == "function") || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (L !== Fe || Ee !== ae) && ed(r, b, m, ae),
                            zt = !1,
                            Ee = r.memoizedState,
                            b.state = Ee,
                            Qu(r, m, b, x),
                            to();
                            var Ne = r.memoizedState;
                            L !== Fe || Ee !== Ne || zt || s !== null && s.dependencies !== null && Of(s.dependencies) ? (typeof W == "function" && (Pm(r, h, W, m),
                            Ne = r.memoizedState),
                            (ze = zt || Fm(r, h, ze, m, Ee, Ne, ae) || s !== null && s.dependencies !== null && Of(s.dependencies)) ? (be || typeof b.UNSAFE_componentWillUpdate != "function" && typeof b.componentWillUpdate != "function" || (typeof b.componentWillUpdate == "function" && b.componentWillUpdate(m, Ne, ae),
                            typeof b.UNSAFE_componentWillUpdate == "function" && b.UNSAFE_componentWillUpdate(m, Ne, ae)),
                            typeof b.componentDidUpdate == "function" && (r.flags |= 4),
                            typeof b.getSnapshotBeforeUpdate == "function" && (r.flags |= 1024)) : (typeof b.componentDidUpdate != "function" || L === s.memoizedProps && Ee === s.memoizedState || (r.flags |= 4),
                            typeof b.getSnapshotBeforeUpdate != "function" || L === s.memoizedProps && Ee === s.memoizedState || (r.flags |= 1024),
                            r.memoizedProps = m,
                            r.memoizedState = Ne),
                            b.props = m,
                            b.state = Ne,
                            b.context = ae,
                            m = ze) : (typeof b.componentDidUpdate != "function" || L === s.memoizedProps && Ee === s.memoizedState || (r.flags |= 4),
                            typeof b.getSnapshotBeforeUpdate != "function" || L === s.memoizedProps && Ee === s.memoizedState || (r.flags |= 1024),
                            m = !1)
                        }
                        return b = m,
                        ao(s, r),
                        m = (r.flags & 128) !== 0,
                        b || m ? (b = r.stateNode,
                        h = m && typeof h.getDerivedStateFromError != "function" ? null : b.render(),
                        r.flags |= 1,
                        s !== null && m ? (r.child = qo(r, s.child, null, x),
                        r.child = qo(r, null, h, x)) : ji(s, r, h, x),
                        r.memoizedState = b.state,
                        s = r.child) : s = Jt(s, r, x),
                        s
                    }
                    function sa(s, r, h, m) {
                        return yr(),
                        r.flags |= 256,
                        ji(s, r, h, m),
                        r.child
                    }
                    var zs = {
                        dehydrated: null,
                        treeContext: null,
                        retryLane: 0,
                        hydrationErrors: null
                    };
                    function ro(s) {
                        return {
                            baseLanes: s,
                            cachePool: Pf()
                        }
                    }
                    function Qa(s, r, h) {
                        return s = s !== null ? s.childLanes & ~h : 0,
                        r && (s |= ca),
                        s
                    }
                    function Mr(s, r, h) {
                        var m = r.pendingProps, x = !1, b = (r.flags & 128) !== 0, L;
                        if ((L = b) || (L = s !== null && s.memoizedState === null ? !1 : (Tn.current & 2) !== 0),
                        L && (x = !0,
                        r.flags &= -129),
                        L = (r.flags & 32) !== 0,
                        r.flags &= -33,
                        s === null) {
                            if (hn) {
                                if (x ? Xo(r) : ci(r),
                                (s = Wn) ? (s = zT(s, Ea),
                                s = s !== null && s.data !== "&" ? s : null,
                                s !== null && (r.memoizedState = {
                                    dehydrated: s,
                                    treeContext: Zr !== null ? {
                                        id: gr,
                                        overflow: Wi
                                    } : null,
                                    retryLane: 536870912,
                                    hydrationErrors: null
                                },
                                h = Cf(s),
                                h.return = r,
                                r.child = h,
                                Yi = r,
                                Wn = null)) : s = null,
                                s === null)
                                    throw Vo(r);
                                return JS(s) ? r.lanes = 32 : r.lanes = 536870912,
                                null
                            }
                            var W = m.children;
                            return m = m.fallback,
                            x ? (ci(r),
                            x = r.mode,
                            W = Yo({
                                mode: "hidden",
                                children: W
                            }, x),
                            m = mr(m, x, h, null),
                            W.return = r,
                            m.return = r,
                            W.sibling = m,
                            r.child = W,
                            m = r.child,
                            m.memoizedState = ro(h),
                            m.childLanes = Qa(s, L, h),
                            r.memoizedState = zs,
                            ch(null, m)) : (Xo(r),
                            Bi(r, W))
                        }
                        var ae = s.memoizedState;
                        if (ae !== null && (W = ae.dehydrated,
                        W !== null)) {
                            if (b)
                                r.flags & 256 ? (Xo(r),
                                r.flags &= -257,
                                r = br(s, r, h)) : r.memoizedState !== null ? (ci(r),
                                r.child = s.child,
                                r.flags |= 128,
                                r = null) : (ci(r),
                                W = m.fallback,
                                x = r.mode,
                                m = Yo({
                                    mode: "visible",
                                    children: m.children
                                }, x),
                                W = mr(W, x, h, null),
                                W.flags |= 2,
                                m.return = r,
                                W.return = r,
                                m.sibling = W,
                                r.child = m,
                                qo(r, s.child, null, h),
                                m = r.child,
                                m.memoizedState = ro(h),
                                m.childLanes = Qa(s, L, h),
                                r.memoizedState = zs,
                                r = ch(null, m));
                            else if (Xo(r),
                            JS(W)) {
                                if (L = W.nextSibling && W.nextSibling.dataset,
                                L)
                                    var be = L.dgst;
                                L = be,
                                m = Error(a(419)),
                                m.stack = "",
                                m.digest = L,
                                Tc({
                                    value: m,
                                    source: null,
                                    stack: null
                                }),
                                r = br(s, r, h)
                            } else if (Rn || Ul(s, r, h, !1),
                            L = (h & s.childLanes) !== 0,
                            Rn || L) {
                                if (L = qt,
                                L !== null && (m = Ml(L, h),
                                m !== 0 && m !== ae.retryLane))
                                    throw ae.retryLane = m,
                                    Yr(s, m),
                                    Zi(L, s, m),
                                    Hm;
                                KS(W) || _(),
                                r = br(s, r, h)
                            } else
                                KS(W) ? (r.flags |= 192,
                                r.child = s.child,
                                r = null) : (s = ae.treeContext,
                                Wn = Or(W.nextSibling),
                                Yi = r,
                                hn = !0,
                                _r = null,
                                Ea = !1,
                                s !== null && tm(r, s),
                                r = Bi(r, m.children),
                                r.flags |= 4096);
                            return r
                        }
                        return x ? (ci(r),
                        W = m.fallback,
                        x = r.mode,
                        ae = s.child,
                        be = ae.sibling,
                        m = pr(ae, {
                            mode: "hidden",
                            children: m.children
                        }),
                        m.subtreeFlags = ae.subtreeFlags & 65011712,
                        be !== null ? W = pr(be, W) : (W = mr(W, x, h, null),
                        W.flags |= 2),
                        W.return = r,
                        m.return = r,
                        m.sibling = W,
                        r.child = m,
                        ch(null, m),
                        m = r.child,
                        W = s.child.memoizedState,
                        W === null ? W = ro(h) : (x = W.cachePool,
                        x !== null ? (ae = Yn._currentValue,
                        x = x.parent !== ae ? {
                            parent: ae,
                            pool: ae
                        } : x) : x = Pf(),
                        W = {
                            baseLanes: W.baseLanes | h,
                            cachePool: x
                        }),
                        m.memoizedState = W,
                        m.childLanes = Qa(s, L, h),
                        r.memoizedState = zs,
                        ch(s.child, m)) : (Xo(r),
                        h = s.child,
                        s = h.sibling,
                        h = pr(h, {
                            mode: "visible",
                            children: m.children
                        }),
                        h.return = r,
                        h.sibling = null,
                        s !== null && (L = r.deletions,
                        L === null ? (r.deletions = [s],
                        r.flags |= 16) : L.push(s)),
                        r.child = h,
                        r.memoizedState = null,
                        h)
                    }
                    function Bi(s, r) {
                        return r = Yo({
                            mode: "visible",
                            children: r
                        }, s.mode),
                        r.return = s,
                        s.child = r
                    }
                    function Yo(s, r) {
                        return s = Li(22, s, null, r),
                        s.lanes = 0,
                        s
                    }
                    function br(s, r, h) {
                        return qo(r, s.child, null, h),
                        s = Bi(r, r.pendingProps.children),
                        s.flags |= 2,
                        r.memoizedState = null,
                        s
                    }
                    function fh(s, r, h) {
                        s.lanes |= r;
                        var m = s.alternate;
                        m !== null && (m.lanes |= r),
                        Wu(s.return, r, h)
                    }
                    function ss(s, r, h, m, x, b) {
                        var L = s.memoizedState;
                        L === null ? s.memoizedState = {
                            isBackwards: r,
                            rendering: null,
                            renderingStartTime: 0,
                            last: m,
                            tail: h,
                            tailMode: x,
                            treeForkCount: b
                        } : (L.isBackwards = r,
                        L.rendering = null,
                        L.renderingStartTime = 0,
                        L.last = m,
                        L.tail = h,
                        L.tailMode = x,
                        L.treeForkCount = b)
                    }
                    function as(s, r, h) {
                        var m = r.pendingProps
                          , x = m.revealOrder
                          , b = m.tail;
                        m = m.children;
                        var L = Tn.current
                          , W = (L & 2) !== 0;
                        if (W ? (L = L & 1 | 2,
                        r.flags |= 128) : L &= 1,
                        Ae(Tn, L),
                        ji(s, r, m, h),
                        m = hn ? Ii : 0,
                        !W && s !== null && (s.flags & 128) !== 0)
                            e: for (s = r.child; s !== null; ) {
                                if (s.tag === 13)
                                    s.memoizedState !== null && fh(s, h, r);
                                else if (s.tag === 19)
                                    fh(s, h, r);
                                else if (s.child !== null) {
                                    s.child.return = s,
                                    s = s.child;
                                    continue
                                }
                                if (s === r)
                                    break e;
                                for (; s.sibling === null; ) {
                                    if (s.return === null || s.return === r)
                                        break e;
                                    s = s.return
                                }
                                s.sibling.return = s.return,
                                s = s.sibling
                            }
                        switch (x) {
                        case "forwards":
                            for (h = r.child,
                            x = null; h !== null; )
                                s = h.alternate,
                                s !== null && Ju(s) === null && (x = h),
                                h = h.sibling;
                            h = x,
                            h === null ? (x = r.child,
                            r.child = null) : (x = h.sibling,
                            h.sibling = null),
                            ss(r, !1, x, h, b, m);
                            break;
                        case "backwards":
                        case "unstable_legacy-backwards":
                            for (h = null,
                            x = r.child,
                            r.child = null; x !== null; ) {
                                if (s = x.alternate,
                                s !== null && Ju(s) === null) {
                                    r.child = x;
                                    break
                                }
                                s = x.sibling,
                                x.sibling = h,
                                h = x,
                                x = s
                            }
                            ss(r, !0, h, null, b, m);
                            break;
                        case "together":
                            ss(r, !1, null, null, void 0, m);
                            break;
                        default:
                            r.memoizedState = null
                        }
                        return r.child
                    }
                    function Jt(s, r, h) {
                        if (s !== null && (r.dependencies = s.dependencies),
                        er |= r.lanes,
                        (h & r.childLanes) === 0)
                            if (s !== null) {
                                if (Ul(s, r, h, !1),
                                (h & r.childLanes) === 0)
                                    return null
                            } else
                                return null;
                        if (s !== null && r.child !== s.child)
                            throw Error(a(153));
                        if (r.child !== null) {
                            for (s = r.child,
                            h = pr(s, s.pendingProps),
                            r.child = h,
                            h.return = r; s.sibling !== null; )
                                s = s.sibling,
                                h = h.sibling = pr(s, s.pendingProps),
                                h.return = r;
                            h.sibling = null
                        }
                        return r.child
                    }
                    function aa(s, r) {
                        return (s.lanes & r) !== 0 ? !0 : (s = s.dependencies,
                        !!(s !== null && Of(s)))
                    }
                    function Tr(s, r, h) {
                        switch (r.tag) {
                        case 3:
                            Je(r, r.stateNode.containerInfo),
                            Qr(r, Yn, s.memoizedState.cache),
                            yr();
                            break;
                        case 27:
                        case 5:
                            Ct(r);
                            break;
                        case 4:
                            Je(r, r.stateNode.containerInfo);
                            break;
                        case 10:
                            Qr(r, r.type, r.memoizedProps.value);
                            break;
                        case 31:
                            if (r.memoizedState !== null)
                                return r.flags |= 128,
                                Ku(r),
                                null;
                            break;
                        case 13:
                            var m = r.memoizedState;
                            if (m !== null)
                                return m.dehydrated !== null ? (Xo(r),
                                r.flags |= 128,
                                null) : (h & r.child.childLanes) !== 0 ? Mr(s, r, h) : (Xo(r),
                                s = Jt(s, r, h),
                                s !== null ? s.sibling : null);
                            Xo(r);
                            break;
                        case 19:
                            var x = (s.flags & 128) !== 0;
                            if (m = (h & r.childLanes) !== 0,
                            m || (Ul(s, r, h, !1),
                            m = (h & r.childLanes) !== 0),
                            x) {
                                if (m)
                                    return as(s, r, h);
                                r.flags |= 128
                            }
                            if (x = r.memoizedState,
                            x !== null && (x.rendering = null,
                            x.tail = null,
                            x.lastEffect = null),
                            Ae(Tn, Tn.current),
                            m)
                                break;
                            return null;
                        case 22:
                            return r.lanes = 0,
                            d_(s, r, h, r.pendingProps);
                        case 24:
                            Qr(r, Yn, s.memoizedState.cache)
                        }
                        return Jt(s, r, h)
                    }
                    function sd(s, r, h) {
                        if (s !== null)
                            if (s.memoizedProps !== r.pendingProps)
                                Rn = !0;
                            else {
                                if (!aa(s, h) && (r.flags & 128) === 0)
                                    return Rn = !1,
                                    Tr(s, r, h);
                                Rn = (s.flags & 131072) !== 0
                            }
                        else
                            Rn = !1,
                            hn && (r.flags & 1048576) !== 0 && Rf(r, Ii, r.index);
                        switch (r.lanes = 0,
                        r.tag) {
                        case 16:
                            e: {
                                var m = r.pendingProps;
                                if (s = Vl(r.elementType),
                                r.type = s,
                                typeof s == "function")
                                    Af(s) ? (m = Ra(s, m),
                                    r.tag = 1,
                                    r = hh(null, r, s, m, h)) : (r.tag = 0,
                                    r = Wo(null, r, s, m, h));
                                else {
                                    if (s != null) {
                                        var x = s.$$typeof;
                                        if (x === U) {
                                            r.tag = 11,
                                            r = h_(null, r, s, m, h);
                                            break e
                                        } else if (x === V) {
                                            r.tag = 14,
                                            r = id(null, r, s, m, h);
                                            break e
                                        }
                                    }
                                    throw r = oe(s) || s,
                                    Error(a(306, r, ""))
                                }
                            }
                            return r;
                        case 0:
                            return Wo(s, r, r.type, r.pendingProps, h);
                        case 1:
                            return m = r.type,
                            x = Ra(m, r.pendingProps),
                            hh(s, r, m, x, h);
                        case 3:
                            e: {
                                if (Je(r, r.stateNode.containerInfo),
                                s === null)
                                    throw Error(a(387));
                                m = r.pendingProps;
                                var b = r.memoizedState;
                                x = b.element,
                                Hf(s, r),
                                Qu(r, m, null, h);
                                var L = r.memoizedState;
                                if (m = L.cache,
                                Qr(r, Yn, m),
                                m !== b.cache && rm(r, [Yn], h, !0),
                                to(),
                                m = L.element,
                                b.isDehydrated)
                                    if (b = {
                                        element: m,
                                        isDehydrated: !1,
                                        cache: L.cache
                                    },
                                    r.updateQueue.baseState = b,
                                    r.memoizedState = b,
                                    r.flags & 256) {
                                        r = sa(s, r, m, h);
                                        break e
                                    } else if (m !== x) {
                                        x = ea(Error(a(424)), r),
                                        Tc(x),
                                        r = sa(s, r, m, h);
                                        break e
                                    } else
                                        for (s = r.stateNode.containerInfo,
                                        s.nodeType === 9 ? s = s.body : s = s.nodeName === "HTML" ? s.ownerDocument.body : s,
                                        Wn = Or(s.firstChild),
                                        Yi = r,
                                        hn = !0,
                                        _r = null,
                                        Ea = !0,
                                        h = Vv(r, null, m, h),
                                        r.child = h; h; )
                                            h.flags = h.flags & -3 | 4096,
                                            h = h.sibling;
                                else {
                                    if (yr(),
                                    m === x) {
                                        r = Jt(s, r, h);
                                        break e
                                    }
                                    ji(s, r, m, h)
                                }
                                r = r.child
                            }
                            return r;
                        case 26:
                            return ao(s, r),
                            s === null ? (h = GT(r.type, null, r.pendingProps, null)) ? r.memoizedState = h : hn || (h = r.type,
                            s = r.pendingProps,
                            m = x_(we.current).createElement(h),
                            m[Zt] = r,
                            m[Oi] = s,
                            Ts(m, h, s),
                            _e(m),
                            r.stateNode = m) : r.memoizedState = GT(r.type, s.memoizedProps, r.pendingProps, s.memoizedState),
                            null;
                        case 27:
                            return Ct(r),
                            s === null && hn && (m = r.stateNode = VT(r.type, r.pendingProps, we.current),
                            Yi = r,
                            Ea = !0,
                            x = Wn,
                            Xc(r.type) ? ($S = x,
                            Wn = Or(m.firstChild)) : Wn = x),
                            ji(s, r, r.pendingProps.children, h),
                            ao(s, r),
                            s === null && (r.flags |= 4194304),
                            r.child;
                        case 5:
                            return s === null && hn && ((x = m = Wn) && (m = Q3(m, r.type, r.pendingProps, Ea),
                            m !== null ? (r.stateNode = m,
                            Yi = r,
                            Wn = Or(m.firstChild),
                            Ea = !1,
                            x = !0) : x = !1),
                            x || Vo(r)),
                            Ct(r),
                            x = r.type,
                            b = r.pendingProps,
                            L = s !== null ? s.memoizedProps : null,
                            m = b.children,
                            jS(x, b) ? m = null : L !== null && jS(x, L) && (r.flags |= 32),
                            r.memoizedState !== null && (x = fm(s, r, th, null, null, h),
                            Km._currentValue = x),
                            ao(s, r),
                            ji(s, r, m, h),
                            r.child;
                        case 6:
                            return s === null && hn && ((s = h = Wn) && (h = K3(h, r.pendingProps, Ea),
                            h !== null ? (r.stateNode = h,
                            Yi = r,
                            Wn = null,
                            s = !0) : s = !1),
                            s || Vo(r)),
                            null;
                        case 13:
                            return Mr(s, r, h);
                        case 4:
                            return Je(r, r.stateNode.containerInfo),
                            m = r.pendingProps,
                            s === null ? r.child = qo(r, null, m, h) : ji(s, r, m, h),
                            r.child;
                        case 11:
                            return h_(s, r, r.type, r.pendingProps, h);
                        case 7:
                            return ji(s, r, r.pendingProps, h),
                            r.child;
                        case 8:
                            return ji(s, r, r.pendingProps.children, h),
                            r.child;
                        case 12:
                            return ji(s, r, r.pendingProps.children, h),
                            r.child;
                        case 10:
                            return m = r.pendingProps,
                            Qr(r, r.type, m.value),
                            ji(s, r, m.children, h),
                            r.child;
                        case 9:
                            return x = r.type._context,
                            m = r.pendingProps.children,
                            Ll(r),
                            x = ns(x),
                            m = m(x),
                            r.flags |= 1,
                            ji(s, r, m, h),
                            r.child;
                        case 14:
                            return id(s, r, r.type, r.pendingProps, h);
                        case 15:
                            return f_(s, r, r.type, r.pendingProps, h);
                        case 19:
                            return as(s, r, h);
                        case 31:
                            return p_(s, r, h);
                        case 22:
                            return d_(s, r, h, r.pendingProps);
                        case 24:
                            return Ll(r),
                            m = ns(Yn),
                            s === null ? (x = cm(),
                            x === null && (x = qt,
                            b = zf(),
                            x.pooledCache = b,
                            b.refCount++,
                            b !== null && (x.pooledCacheLanes |= h),
                            x = b),
                            r.memoizedState = {
                                parent: m,
                                cache: x
                            },
                            ju(r),
                            Qr(r, Yn, x)) : ((s.lanes & h) !== 0 && (Hf(s, r),
                            Qu(r, null, null, h),
                            to()),
                            x = s.memoizedState,
                            b = r.memoizedState,
                            x.parent !== m ? (x = {
                                parent: m,
                                cache: m
                            },
                            r.memoizedState = x,
                            r.lanes === 0 && (r.memoizedState = r.updateQueue.baseState = x),
                            Qr(r, Yn, m)) : (m = b.cache,
                            Qr(r, Yn, m),
                            m !== x.cache && rm(r, [Yn], h, !0))),
                            ji(s, r, r.pendingProps.children, h),
                            r.child;
                        case 29:
                            throw r.pendingProps
                        }
                        throw Error(a(156, r.tag))
                    }
                    function wi(s) {
                        s.flags |= 4
                    }
                    function jo(s, r, h, m, x) {
                        if ((r = (s.mode & 32) !== 0) && (r = !1),
                        r) {
                            if (s.flags |= 16777216,
                            (x & 335544128) === x)
                                if (s.stateNode.complete)
                                    s.flags |= 8192;
                                else if (md())
                                    s.flags |= 8192;
                                else
                                    throw Go = Jr,
                                    Ec
                        } else
                            s.flags &= -16777217
                    }
                    function ad(s, r) {
                        if (r.type !== "stylesheet" || (r.state.loading & 4) !== 0)
                            s.flags &= -16777217;
                        else if (s.flags |= 16777216,
                        !YT(r))
                            if (md())
                                s.flags |= 8192;
                            else
                                throw Go = Jr,
                                Ec
                    }
                    function kl(s, r) {
                        r !== null && (s.flags |= 4),
                        s.flags & 16384 && (r = s.tag !== 22 ? pn() : 536870912,
                        s.lanes |= r,
                        bn |= r)
                    }
                    function Ar(s, r) {
                        if (!hn)
                            switch (s.tailMode) {
                            case "hidden":
                                r = s.tail;
                                for (var h = null; r !== null; )
                                    r.alternate !== null && (h = r),
                                    r = r.sibling;
                                h === null ? s.tail = null : h.sibling = null;
                                break;
                            case "collapsed":
                                h = s.tail;
                                for (var m = null; h !== null; )
                                    h.alternate !== null && (m = h),
                                    h = h.sibling;
                                m === null ? r || s.tail === null ? s.tail = null : s.tail.sibling = null : m.sibling = null
                            }
                    }
                    function kn(s) {
                        var r = s.alternate !== null && s.alternate.child === s.child
                          , h = 0
                          , m = 0;
                        if (r)
                            for (var x = s.child; x !== null; )
                                h |= x.lanes | x.childLanes,
                                m |= x.subtreeFlags & 65011712,
                                m |= x.flags & 65011712,
                                x.return = s,
                                x = x.sibling;
                        else
                            for (x = s.child; x !== null; )
                                h |= x.lanes | x.childLanes,
                                m |= x.subtreeFlags,
                                m |= x.flags,
                                x.return = s,
                                x = x.sibling;
                        return s.subtreeFlags |= m,
                        s.childLanes = h,
                        r
                    }
                    function rd(s, r, h) {
                        var m = r.pendingProps;
                        switch (Nf(r),
                        r.tag) {
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return kn(r),
                            null;
                        case 1:
                            return kn(r),
                            null;
                        case 3:
                            return h = r.stateNode,
                            m = null,
                            s !== null && (m = s.memoizedState.cache),
                            r.memoizedState.cache !== m && (r.flags |= 2048),
                            fn(Yn),
                            Ze(),
                            h.pendingContext && (h.context = h.pendingContext,
                            h.pendingContext = null),
                            (s === null || s.child === null) && (Za(r) ? wi(r) : s === null || s.memoizedState.isDehydrated && (r.flags & 256) === 0 || (r.flags |= 1024,
                            Df())),
                            kn(r),
                            null;
                        case 26:
                            var x = r.type
                              , b = r.memoizedState;
                            return s === null ? (wi(r),
                            b !== null ? (kn(r),
                            ad(r, b)) : (kn(r),
                            jo(r, x, null, m, h))) : b ? b !== s.memoizedState ? (wi(r),
                            kn(r),
                            ad(r, b)) : (kn(r),
                            r.flags &= -16777217) : (s = s.memoizedProps,
                            s !== m && wi(r),
                            kn(r),
                            jo(r, x, s, m, h)),
                            null;
                        case 27:
                            if (bt(r),
                            h = we.current,
                            x = r.type,
                            s !== null && r.stateNode != null)
                                s.memoizedProps !== m && wi(r);
                            else {
                                if (!m) {
                                    if (r.stateNode === null)
                                        throw Error(a(166));
                                    return kn(r),
                                    null
                                }
                                s = ie.current,
                                Za(r) ? im(r, s) : (s = VT(x, m, h),
                                r.stateNode = s,
                                wi(r))
                            }
                            return kn(r),
                            null;
                        case 5:
                            if (bt(r),
                            x = r.type,
                            s !== null && r.stateNode != null)
                                s.memoizedProps !== m && wi(r);
                            else {
                                if (!m) {
                                    if (r.stateNode === null)
                                        throw Error(a(166));
                                    return kn(r),
                                    null
                                }
                                if (b = ie.current,
                                Za(r))
                                    im(r, b);
                                else {
                                    var L = x_(we.current);
                                    switch (b) {
                                    case 1:
                                        b = L.createElementNS("http://www.w3.org/2000/svg", x);
                                        break;
                                    case 2:
                                        b = L.createElementNS("http://www.w3.org/1998/Math/MathML", x);
                                        break;
                                    default:
                                        switch (x) {
                                        case "svg":
                                            b = L.createElementNS("http://www.w3.org/2000/svg", x);
                                            break;
                                        case "math":
                                            b = L.createElementNS("http://www.w3.org/1998/Math/MathML", x);
                                            break;
                                        case "script":
                                            b = L.createElement("div"),
                                            b.innerHTML = "<script><\/script>",
                                            b = b.removeChild(b.firstChild);
                                            break;
                                        case "select":
                                            b = typeof m.is == "string" ? L.createElement("select", {
                                                is: m.is
                                            }) : L.createElement("select"),
                                            m.multiple ? b.multiple = !0 : m.size && (b.size = m.size);
                                            break;
                                        default:
                                            b = typeof m.is == "string" ? L.createElement(x, {
                                                is: m.is
                                            }) : L.createElement(x)
                                        }
                                    }
                                    b[Zt] = r,
                                    b[Oi] = m;
                                    e: for (L = r.child; L !== null; ) {
                                        if (L.tag === 5 || L.tag === 6)
                                            b.appendChild(L.stateNode);
                                        else if (L.tag !== 4 && L.tag !== 27 && L.child !== null) {
                                            L.child.return = L,
                                            L = L.child;
                                            continue
                                        }
                                        if (L === r)
                                            break e;
                                        for (; L.sibling === null; ) {
                                            if (L.return === null || L.return === r)
                                                break e;
                                            L = L.return
                                        }
                                        L.sibling.return = L.return,
                                        L = L.sibling
                                    }
                                    r.stateNode = b;
                                    e: switch (Ts(b, x, m),
                                    x) {
                                    case "button":
                                    case "input":
                                    case "select":
                                    case "textarea":
                                        m = !!m.autoFocus;
                                        break e;
                                    case "img":
                                        m = !0;
                                        break e;
                                    default:
                                        m = !1
                                    }
                                    m && wi(r)
                                }
                            }
                            return kn(r),
                            jo(r, r.type, s === null ? null : s.memoizedProps, r.pendingProps, h),
                            null;
                        case 6:
                            if (s && r.stateNode != null)
                                s.memoizedProps !== m && wi(r);
                            else {
                                if (typeof m != "string" && r.stateNode === null)
                                    throw Error(a(166));
                                if (s = we.current,
                                Za(r)) {
                                    if (s = r.stateNode,
                                    h = r.memoizedProps,
                                    m = null,
                                    x = Yi,
                                    x !== null)
                                        switch (x.tag) {
                                        case 27:
                                        case 5:
                                            m = x.memoizedProps
                                        }
                                    s[Zt] = r,
                                    s = !!(s.nodeValue === h || m !== null && m.suppressHydrationWarning === !0 || wT(s.nodeValue, h)),
                                    s || Vo(r, !0)
                                } else
                                    s = x_(s).createTextNode(m),
                                    s[Zt] = r,
                                    r.stateNode = s
                            }
                            return kn(r),
                            null;
                        case 31:
                            if (h = r.memoizedState,
                            s === null || s.memoizedState !== null) {
                                if (m = Za(r),
                                h !== null) {
                                    if (s === null) {
                                        if (!m)
                                            throw Error(a(318));
                                        if (s = r.memoizedState,
                                        s = s !== null ? s.dehydrated : null,
                                        !s)
                                            throw Error(a(557));
                                        s[Zt] = r
                                    } else
                                        yr(),
                                        (r.flags & 128) === 0 && (r.memoizedState = null),
                                        r.flags |= 4;
                                    kn(r),
                                    s = !1
                                } else
                                    h = Df(),
                                    s !== null && s.memoizedState !== null && (s.memoizedState.hydrationErrors = h),
                                    s = !0;
                                if (!s)
                                    return r.flags & 256 ? (Ei(r),
                                    r) : (Ei(r),
                                    null);
                                if ((r.flags & 128) !== 0)
                                    throw Error(a(558))
                            }
                            return kn(r),
                            null;
                        case 13:
                            if (m = r.memoizedState,
                            s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
                                if (x = Za(r),
                                m !== null && m.dehydrated !== null) {
                                    if (s === null) {
                                        if (!x)
                                            throw Error(a(318));
                                        if (x = r.memoizedState,
                                        x = x !== null ? x.dehydrated : null,
                                        !x)
                                            throw Error(a(317));
                                        x[Zt] = r
                                    } else
                                        yr(),
                                        (r.flags & 128) === 0 && (r.memoizedState = null),
                                        r.flags |= 4;
                                    kn(r),
                                    x = !1
                                } else
                                    x = Df(),
                                    s !== null && s.memoizedState !== null && (s.memoizedState.hydrationErrors = x),
                                    x = !0;
                                if (!x)
                                    return r.flags & 256 ? (Ei(r),
                                    r) : (Ei(r),
                                    null)
                            }
                            return Ei(r),
                            (r.flags & 128) !== 0 ? (r.lanes = h,
                            r) : (h = m !== null,
                            s = s !== null && s.memoizedState !== null,
                            h && (m = r.child,
                            x = null,
                            m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (x = m.alternate.memoizedState.cachePool.pool),
                            b = null,
                            m.memoizedState !== null && m.memoizedState.cachePool !== null && (b = m.memoizedState.cachePool.pool),
                            b !== x && (m.flags |= 2048)),
                            h !== s && h && (r.child.flags |= 8192),
                            kl(r, r.updateQueue),
                            kn(r),
                            null);
                        case 4:
                            return Ze(),
                            s === null && TT(r.stateNode.containerInfo),
                            kn(r),
                            null;
                        case 10:
                            return fn(r.type),
                            kn(r),
                            null;
                        case 19:
                            if (pe(Tn),
                            m = r.memoizedState,
                            m === null)
                                return kn(r),
                                null;
                            if (x = (r.flags & 128) !== 0,
                            b = m.rendering,
                            b === null)
                                if (x)
                                    Ar(m, !1);
                                else {
                                    if (ti !== 0 || s !== null && (s.flags & 128) !== 0)
                                        for (s = r.child; s !== null; ) {
                                            if (b = Ju(s),
                                            b !== null) {
                                                for (r.flags |= 128,
                                                Ar(m, !1),
                                                s = b.updateQueue,
                                                r.updateQueue = s,
                                                kl(r, s),
                                                r.subtreeFlags = 0,
                                                s = h,
                                                h = r.child; h !== null; )
                                                    bc(h, s),
                                                    h = h.sibling;
                                                return Ae(Tn, Tn.current & 1 | 2),
                                                hn && vr(r, m.treeForkCount),
                                                r.child
                                            }
                                            s = s.sibling
                                        }
                                    m.tail !== null && he() > Ua && (r.flags |= 128,
                                    x = !0,
                                    Ar(m, !1),
                                    r.lanes = 4194304)
                                }
                            else {
                                if (!x)
                                    if (s = Ju(b),
                                    s !== null) {
                                        if (r.flags |= 128,
                                        x = !0,
                                        s = s.updateQueue,
                                        r.updateQueue = s,
                                        kl(r, s),
                                        Ar(m, !0),
                                        m.tail === null && m.tailMode === "hidden" && !b.alternate && !hn)
                                            return kn(r),
                                            null
                                    } else
                                        2 * he() - m.renderingStartTime > Ua && h !== 536870912 && (r.flags |= 128,
                                        x = !0,
                                        Ar(m, !1),
                                        r.lanes = 4194304);
                                m.isBackwards ? (b.sibling = r.child,
                                r.child = b) : (s = m.last,
                                s !== null ? s.sibling = b : r.child = b,
                                m.last = b)
                            }
                            return m.tail !== null ? (s = m.tail,
                            m.rendering = s,
                            m.tail = s.sibling,
                            m.renderingStartTime = he(),
                            s.sibling = null,
                            h = Tn.current,
                            Ae(Tn, x ? h & 1 | 2 : h & 1),
                            hn && vr(r, m.treeForkCount),
                            s) : (kn(r),
                            null);
                        case 22:
                        case 23:
                            return Ei(r),
                            Rc(),
                            m = r.memoizedState !== null,
                            s !== null ? s.memoizedState !== null !== m && (r.flags |= 8192) : m && (r.flags |= 8192),
                            m ? (h & 536870912) !== 0 && (r.flags & 128) === 0 && (kn(r),
                            r.subtreeFlags & 6 && (r.flags |= 8192)) : kn(r),
                            h = r.updateQueue,
                            h !== null && kl(r, h.retryQueue),
                            h = null,
                            s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool),
                            m = null,
                            r.memoizedState !== null && r.memoizedState.cachePool !== null && (m = r.memoizedState.cachePool.pool),
                            m !== h && (r.flags |= 2048),
                            s !== null && pe(Wt),
                            null;
                        case 24:
                            return h = null,
                            s !== null && (h = s.memoizedState.cache),
                            r.memoizedState.cache !== h && (r.flags |= 2048),
                            fn(Yn),
                            kn(r),
                            null;
                        case 25:
                            return null;
                        case 30:
                            return null
                        }
                        throw Error(a(156, r.tag))
                    }
                    function Gm(s, r) {
                        switch (Nf(r),
                        r.tag) {
                        case 1:
                            return s = r.flags,
                            s & 65536 ? (r.flags = s & -65537 | 128,
                            r) : null;
                        case 3:
                            return fn(Yn),
                            Ze(),
                            s = r.flags,
                            (s & 65536) !== 0 && (s & 128) === 0 ? (r.flags = s & -65537 | 128,
                            r) : null;
                        case 26:
                        case 27:
                        case 5:
                            return bt(r),
                            null;
                        case 31:
                            if (r.memoizedState !== null) {
                                if (Ei(r),
                                r.alternate === null)
                                    throw Error(a(340));
                                yr()
                            }
                            return s = r.flags,
                            s & 65536 ? (r.flags = s & -65537 | 128,
                            r) : null;
                        case 13:
                            if (Ei(r),
                            s = r.memoizedState,
                            s !== null && s.dehydrated !== null) {
                                if (r.alternate === null)
                                    throw Error(a(340));
                                yr()
                            }
                            return s = r.flags,
                            s & 65536 ? (r.flags = s & -65537 | 128,
                            r) : null;
                        case 19:
                            return pe(Tn),
                            null;
                        case 4:
                            return Ze(),
                            null;
                        case 10:
                            return fn(r.type),
                            null;
                        case 22:
                        case 23:
                            return Ei(r),
                            Rc(),
                            s !== null && pe(Wt),
                            s = r.flags,
                            s & 65536 ? (r.flags = s & -65537 | 128,
                            r) : null;
                        case 24:
                            return fn(Yn),
                            null;
                        case 25:
                            return null;
                        default:
                            return null
                        }
                    }
                    function ql(s, r) {
                        switch (Nf(r),
                        r.tag) {
                        case 3:
                            fn(Yn),
                            Ze();
                            break;
                        case 26:
                        case 27:
                        case 5:
                            bt(r);
                            break;
                        case 4:
                            Ze();
                            break;
                        case 31:
                            r.memoizedState !== null && Ei(r);
                            break;
                        case 13:
                            Ei(r);
                            break;
                        case 19:
                            pe(Tn);
                            break;
                        case 10:
                            fn(r.type);
                            break;
                        case 22:
                        case 23:
                            Ei(r),
                            Rc(),
                            s !== null && pe(Wt);
                            break;
                        case 24:
                            fn(Yn)
                        }
                    }
                    function oo(s, r) {
                        try {
                            var h = r.updateQueue
                              , m = h !== null ? h.lastEffect : null;
                            if (m !== null) {
                                var x = m.next;
                                h = x;
                                do {
                                    if ((h.tag & s) === s) {
                                        m = void 0;
                                        var b = h.create
                                          , L = h.inst;
                                        m = b(),
                                        L.destroy = m
                                    }
                                    h = h.next
                                } while (h !== x)
                            }
                        } catch (W) {
                            Be(r, r.return, W)
                        }
                    }
                    function Er(s, r, h) {
                        try {
                            var m = r.updateQueue
                              , x = m !== null ? m.lastEffect : null;
                            if (x !== null) {
                                var b = x.next;
                                m = b;
                                do {
                                    if ((m.tag & s) === s) {
                                        var L = m.inst
                                          , W = L.destroy;
                                        if (W !== void 0) {
                                            L.destroy = void 0,
                                            x = r;
                                            var ae = h
                                              , be = W;
                                            try {
                                                be()
                                            } catch (ze) {
                                                Be(x, ae, ze)
                                            }
                                        }
                                    }
                                    m = m.next
                                } while (m !== b)
                            }
                        } catch (ze) {
                            Be(r, r.return, ze)
                        }
                    }
                    function Xl(s) {
                        var r = s.updateQueue;
                        if (r !== null) {
                            var h = s.stateNode;
                            try {
                                Hv(r, h)
                            } catch (m) {
                                Be(s, s.return, m)
                            }
                        }
                    }
                    function Wl(s, r, h) {
                        h.props = Ra(s.type, s.memoizedProps),
                        h.state = s.memoizedState;
                        try {
                            h.componentWillUnmount()
                        } catch (m) {
                            Be(s, r, m)
                        }
                    }
                    function Na(s, r) {
                        try {
                            var h = s.ref;
                            if (h !== null) {
                                switch (s.tag) {
                                case 26:
                                case 27:
                                case 5:
                                    var m = s.stateNode;
                                    break;
                                case 30:
                                    m = s.stateNode;
                                    break;
                                default:
                                    m = s.stateNode
                                }
                                typeof h == "function" ? s.refCleanup = h(m) : h.current = m
                            }
                        } catch (x) {
                            Be(s, r, x)
                        }
                    }
                    function Da(s, r) {
                        var h = s.ref
                          , m = s.refCleanup;
                        if (h !== null)
                            if (typeof m == "function")
                                try {
                                    m()
                                } catch (x) {
                                    Be(s, r, x)
                                } finally {
                                    s.refCleanup = null,
                                    s = s.alternate,
                                    s != null && (s.refCleanup = null)
                                }
                            else if (typeof h == "function")
                                try {
                                    h(null)
                                } catch (x) {
                                    Be(s, r, x)
                                }
                            else
                                h.current = null
                    }
                    function m_(s) {
                        var r = s.type
                          , h = s.memoizedProps
                          , m = s.stateNode;
                        try {
                            e: switch (r) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                h.autoFocus && m.focus();
                                break e;
                            case "img":
                                h.src ? m.src = h.src : h.srcSet && (m.srcset = h.srcSet)
                            }
                        } catch (x) {
                            Be(s, s.return, x)
                        }
                    }
                    function Yl(s, r, h) {
                        try {
                            var m = s.stateNode;
                            q3(m, s.type, h, r),
                            m[Oi] = r
                        } catch (x) {
                            Be(s, s.return, x)
                        }
                    }
                    function od(s) {
                        return s.tag === 5 || s.tag === 3 || s.tag === 26 || s.tag === 27 && Xc(s.type) || s.tag === 4
                    }
                    function zc(s) {
                        e: for (; ; ) {
                            for (; s.sibling === null; ) {
                                if (s.return === null || od(s.return))
                                    return null;
                                s = s.return
                            }
                            for (s.sibling.return = s.return,
                            s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
                                if (s.tag === 27 && Xc(s.type) || s.flags & 2 || s.child === null || s.tag === 4)
                                    continue e;
                                s.child.return = s,
                                s = s.child
                            }
                            if (!(s.flags & 2))
                                return s.stateNode
                        }
                    }
                    function Zo(s, r, h) {
                        var m = s.tag;
                        if (m === 5 || m === 6)
                            s = s.stateNode,
                            r ? (h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h).insertBefore(s, r) : (r = h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h,
                            r.appendChild(s),
                            h = h._reactRootContainer,
                            h != null || r.onclick !== null || (r.onclick = ur));
                        else if (m !== 4 && (m === 27 && Xc(s.type) && (h = s.stateNode,
                        r = null),
                        s = s.child,
                        s !== null))
                            for (Zo(s, r, h),
                            s = s.sibling; s !== null; )
                                Zo(s, r, h),
                                s = s.sibling
                    }
                    function lo(s, r, h) {
                        var m = s.tag;
                        if (m === 5 || m === 6)
                            s = s.stateNode,
                            r ? h.insertBefore(s, r) : h.appendChild(s);
                        else if (m !== 4 && (m === 27 && Xc(s.type) && (h = s.stateNode),
                        s = s.child,
                        s !== null))
                            for (lo(s, r, h),
                            s = s.sibling; s !== null; )
                                lo(s, r, h),
                                s = s.sibling
                    }
                    function Bc(s) {
                        var r = s.stateNode
                          , h = s.memoizedProps;
                        try {
                            for (var m = s.type, x = r.attributes; x.length; )
                                r.removeAttributeNode(x[0]);
                            Ts(r, m, h),
                            r[Zt] = s,
                            r[Oi] = h
                        } catch (b) {
                            Be(s, s.return, b)
                        }
                    }
                    var Ms = !1
                      , Mi = !1
                      , Qo = !1
                      , dh = typeof WeakSet == "function" ? WeakSet : Set
                      , Un = null;
                    function Cr(s, r) {
                        if (s = s.containerInfo,
                        WS = w_,
                        s = Zp(s),
                        Rl(s)) {
                            if ("selectionStart"in s)
                                var h = {
                                    start: s.selectionStart,
                                    end: s.selectionEnd
                                };
                            else
                                e: {
                                    h = (h = s.ownerDocument) && h.defaultView || window;
                                    var m = h.getSelection && h.getSelection();
                                    if (m && m.rangeCount !== 0) {
                                        h = m.anchorNode;
                                        var x = m.anchorOffset
                                          , b = m.focusNode;
                                        m = m.focusOffset;
                                        try {
                                            h.nodeType,
                                            b.nodeType
                                        } catch {
                                            h = null;
                                            break e
                                        }
                                        var L = 0
                                          , W = -1
                                          , ae = -1
                                          , be = 0
                                          , ze = 0
                                          , Fe = s
                                          , Ee = null;
                                        t: for (; ; ) {
                                            for (var Ne; Fe !== h || x !== 0 && Fe.nodeType !== 3 || (W = L + x),
                                            Fe !== b || m !== 0 && Fe.nodeType !== 3 || (ae = L + m),
                                            Fe.nodeType === 3 && (L += Fe.nodeValue.length),
                                            (Ne = Fe.firstChild) !== null; )
                                                Ee = Fe,
                                                Fe = Ne;
                                            for (; ; ) {
                                                if (Fe === s)
                                                    break t;
                                                if (Ee === h && ++be === x && (W = L),
                                                Ee === b && ++ze === m && (ae = L),
                                                (Ne = Fe.nextSibling) !== null)
                                                    break;
                                                Fe = Ee,
                                                Ee = Fe.parentNode
                                            }
                                            Fe = Ne
                                        }
                                        h = W === -1 || ae === -1 ? null : {
                                            start: W,
                                            end: ae
                                        }
                                    } else
                                        h = null
                                }
                            h = h || {
                                start: 0,
                                end: 0
                            }
                        } else
                            h = null;
                        for (YS = {
                            focusedElem: s,
                            selectionRange: h
                        },
                        w_ = !1,
                        Un = r; Un !== null; )
                            if (r = Un,
                            s = r.child,
                            (r.subtreeFlags & 1028) !== 0 && s !== null)
                                s.return = r,
                                Un = s;
                            else
                                for (; Un !== null; ) {
                                    switch (r = Un,
                                    b = r.alternate,
                                    s = r.flags,
                                    r.tag) {
                                    case 0:
                                        if ((s & 4) !== 0 && (s = r.updateQueue,
                                        s = s !== null ? s.events : null,
                                        s !== null))
                                            for (h = 0; h < s.length; h++)
                                                x = s[h],
                                                x.ref.impl = x.nextImpl;
                                        break;
                                    case 11:
                                    case 15:
                                        break;
                                    case 1:
                                        if ((s & 1024) !== 0 && b !== null) {
                                            s = void 0,
                                            h = r,
                                            x = b.memoizedProps,
                                            b = b.memoizedState,
                                            m = h.stateNode;
                                            try {
                                                var yt = Ra(h.type, x);
                                                s = m.getSnapshotBeforeUpdate(yt, b),
                                                m.__reactInternalSnapshotBeforeUpdate = s
                                            } catch (Pt) {
                                                Be(h, h.return, Pt)
                                            }
                                        }
                                        break;
                                    case 3:
                                        if ((s & 1024) !== 0) {
                                            if (s = r.stateNode.containerInfo,
                                            h = s.nodeType,
                                            h === 9)
                                                QS(s);
                                            else if (h === 1)
                                                switch (s.nodeName) {
                                                case "HEAD":
                                                case "HTML":
                                                case "BODY":
                                                    QS(s);
                                                    break;
                                                default:
                                                    s.textContent = ""
                                                }
                                        }
                                        break;
                                    case 5:
                                    case 26:
                                    case 27:
                                    case 6:
                                    case 4:
                                    case 17:
                                        break;
                                    default:
                                        if ((s & 1024) !== 0)
                                            throw Error(a(163))
                                    }
                                    if (s = r.sibling,
                                    s !== null) {
                                        s.return = r.return,
                                        Un = s;
                                        break
                                    }
                                    Un = r.return
                                }
                    }
                    function Ri(s, r, h) {
                        var m = h.flags;
                        switch (h.tag) {
                        case 0:
                        case 11:
                        case 15:
                            ms(s, h),
                            m & 4 && oo(5, h);
                            break;
                        case 1:
                            if (ms(s, h),
                            m & 4)
                                if (s = h.stateNode,
                                r === null)
                                    try {
                                        s.componentDidMount()
                                    } catch (L) {
                                        Be(h, h.return, L)
                                    }
                                else {
                                    var x = Ra(h.type, r.memoizedProps);
                                    r = r.memoizedState;
                                    try {
                                        s.componentDidUpdate(x, r, s.__reactInternalSnapshotBeforeUpdate)
                                    } catch (L) {
                                        Be(h, h.return, L)
                                    }
                                }
                            m & 64 && Xl(h),
                            m & 512 && Na(h, h.return);
                            break;
                        case 3:
                            if (ms(s, h),
                            m & 64 && (s = h.updateQueue,
                            s !== null)) {
                                if (r = null,
                                h.child !== null)
                                    switch (h.child.tag) {
                                    case 27:
                                    case 5:
                                        r = h.child.stateNode;
                                        break;
                                    case 1:
                                        r = h.child.stateNode
                                    }
                                try {
                                    Hv(s, r)
                                } catch (L) {
                                    Be(h, h.return, L)
                                }
                            }
                            break;
                        case 27:
                            r === null && m & 4 && Bc(h);
                        case 26:
                        case 5:
                            ms(s, h),
                            r === null && m & 4 && m_(h),
                            m & 512 && Na(h, h.return);
                            break;
                        case 12:
                            ms(s, h);
                            break;
                        case 31:
                            ms(s, h),
                            m & 4 && jl(s, h);
                            break;
                        case 13:
                            ms(s, h),
                            m & 4 && Ko(s, h),
                            m & 64 && (s = h.memoizedState,
                            s !== null && (s = s.dehydrated,
                            s !== null && (h = En.bind(null, h),
                            J3(s, h))));
                            break;
                        case 22:
                            if (m = h.memoizedState !== null || Ms,
                            !m) {
                                r = r !== null && r.memoizedState !== null || Mi,
                                x = Ms;
                                var b = Mi;
                                Ms = m,
                                (Mi = r) && !b ? Ja(s, h, (h.subtreeFlags & 8772) !== 0) : ms(s, h),
                                Ms = x,
                                Mi = b
                            }
                            break;
                        case 30:
                            break;
                        default:
                            ms(s, h)
                        }
                    }
                    function co(s) {
                        var r = s.alternate;
                        r !== null && (s.alternate = null,
                        co(r)),
                        s.child = null,
                        s.deletions = null,
                        s.sibling = null,
                        s.tag === 5 && (r = s.stateNode,
                        r !== null && Tl(r)),
                        s.stateNode = null,
                        s.return = null,
                        s.dependencies = null,
                        s.memoizedProps = null,
                        s.memoizedState = null,
                        s.pendingProps = null,
                        s.stateNode = null,
                        s.updateQueue = null
                    }
                    var St = null
                      , Qt = !1;
                    function Bn(s, r, h) {
                        for (h = h.child; h !== null; )
                            ph(s, r, h),
                            h = h.sibling
                    }
                    function ph(s, r, h) {
                        if (nt && typeof nt.onCommitFiberUnmount == "function")
                            try {
                                nt.onCommitFiberUnmount(Xe, h)
                            } catch {}
                        switch (h.tag) {
                        case 26:
                            Mi || Da(h, r),
                            Bn(s, r, h),
                            h.memoizedState ? h.memoizedState.count-- : h.stateNode && (h = h.stateNode,
                            h.parentNode.removeChild(h));
                            break;
                        case 27:
                            Mi || Da(h, r);
                            var m = St
                              , x = Qt;
                            Xc(h.type) && (St = h.stateNode,
                            Qt = !1),
                            Bn(s, r, h),
                            jm(h.stateNode),
                            St = m,
                            Qt = x;
                            break;
                        case 5:
                            Mi || Da(h, r);
                        case 6:
                            if (m = St,
                            x = Qt,
                            St = null,
                            Bn(s, r, h),
                            St = m,
                            Qt = x,
                            St !== null)
                                if (Qt)
                                    try {
                                        (St.nodeType === 9 ? St.body : St.nodeName === "HTML" ? St.ownerDocument.body : St).removeChild(h.stateNode)
                                    } catch (b) {
                                        Be(h, r, b)
                                    }
                                else
                                    try {
                                        St.removeChild(h.stateNode)
                                    } catch (b) {
                                        Be(h, r, b)
                                    }
                            break;
                        case 18:
                            St !== null && (Qt ? (s = St,
                            LT(s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, h.stateNode),
                            yd(s)) : LT(St, h.stateNode));
                            break;
                        case 4:
                            m = St,
                            x = Qt,
                            St = h.stateNode.containerInfo,
                            Qt = !0,
                            Bn(s, r, h),
                            St = m,
                            Qt = x;
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Er(2, h, r),
                            Mi || Er(4, h, r),
                            Bn(s, r, h);
                            break;
                        case 1:
                            Mi || (Da(h, r),
                            m = h.stateNode,
                            typeof m.componentWillUnmount == "function" && Wl(h, r, m)),
                            Bn(s, r, h);
                            break;
                        case 21:
                            Bn(s, r, h);
                            break;
                        case 22:
                            Mi = (m = Mi) || h.memoizedState !== null,
                            Bn(s, r, h),
                            Mi = m;
                            break;
                        default:
                            Bn(s, r, h)
                        }
                    }
                    function jl(s, r) {
                        if (r.memoizedState === null && (s = r.alternate,
                        s !== null && (s = s.memoizedState,
                        s !== null))) {
                            s = s.dehydrated;
                            try {
                                yd(s)
                            } catch (h) {
                                Be(r, r.return, h)
                            }
                        }
                    }
                    function Ko(s, r) {
                        if (r.memoizedState === null && (s = r.alternate,
                        s !== null && (s = s.memoizedState,
                        s !== null && (s = s.dehydrated,
                        s !== null))))
                            try {
                                yd(s)
                            } catch (h) {
                                Be(r, r.return, h)
                            }
                    }
                    function ld(s) {
                        switch (s.tag) {
                        case 31:
                        case 13:
                        case 19:
                            var r = s.stateNode;
                            return r === null && (r = s.stateNode = new dh),
                            r;
                        case 22:
                            return s = s.stateNode,
                            r = s._retryCache,
                            r === null && (r = s._retryCache = new dh),
                            r;
                        default:
                            throw Error(a(435, s.tag))
                        }
                    }
                    function Jo(s, r) {
                        var h = ld(s);
                        r.forEach(function(m) {
                            if (!h.has(m)) {
                                h.add(m);
                                var x = Qi.bind(null, s, m);
                                m.then(x, x)
                            }
                        })
                    }
                    function Pi(s, r) {
                        var h = r.deletions;
                        if (h !== null)
                            for (var m = 0; m < h.length; m++) {
                                var x = h[m]
                                  , b = s
                                  , L = r
                                  , W = L;
                                e: for (; W !== null; ) {
                                    switch (W.tag) {
                                    case 27:
                                        if (Xc(W.type)) {
                                            St = W.stateNode,
                                            Qt = !1;
                                            break e
                                        }
                                        break;
                                    case 5:
                                        St = W.stateNode,
                                        Qt = !1;
                                        break e;
                                    case 3:
                                    case 4:
                                        St = W.stateNode.containerInfo,
                                        Qt = !0;
                                        break e
                                    }
                                    W = W.return
                                }
                                if (St === null)
                                    throw Error(a(160));
                                ph(b, L, x),
                                St = null,
                                Qt = !1,
                                b = x.alternate,
                                b !== null && (b.return = null),
                                x.return = null
                            }
                        if (r.subtreeFlags & 13886)
                            for (r = r.child; r !== null; )
                                cd(r, s),
                                r = r.sibling
                    }
                    var Ka = null;
                    function cd(s, r) {
                        var h = s.alternate
                          , m = s.flags;
                        switch (s.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Pi(r, s),
                            ui(s),
                            m & 4 && (Er(3, s, s.return),
                            oo(3, s),
                            Er(5, s, s.return));
                            break;
                        case 1:
                            Pi(r, s),
                            ui(s),
                            m & 512 && (Mi || h === null || Da(h, h.return)),
                            m & 64 && Ms && (s = s.updateQueue,
                            s !== null && (m = s.callbacks,
                            m !== null && (h = s.shared.hiddenCallbacks,
                            s.shared.hiddenCallbacks = h === null ? m : h.concat(m))));
                            break;
                        case 26:
                            var x = Ka;
                            if (Pi(r, s),
                            ui(s),
                            m & 512 && (Mi || h === null || Da(h, h.return)),
                            m & 4) {
                                var b = h !== null ? h.memoizedState : null;
                                if (m = s.memoizedState,
                                h === null)
                                    if (m === null)
                                        if (s.stateNode === null) {
                                            e: {
                                                m = s.type,
                                                h = s.memoizedProps,
                                                x = x.ownerDocument || x;
                                                t: switch (m) {
                                                case "title":
                                                    b = x.getElementsByTagName("title")[0],
                                                    (!b || b[Gr] || b[Zt] || b.namespaceURI === "http://www.w3.org/2000/svg" || b.hasAttribute("itemprop")) && (b = x.createElement(m),
                                                    x.head.insertBefore(b, x.querySelector("head > title"))),
                                                    Ts(b, m, h),
                                                    b[Zt] = s,
                                                    _e(b),
                                                    m = b;
                                                    break e;
                                                case "link":
                                                    var L = XT("link", "href", x).get(m + (h.href || ""));
                                                    if (L) {
                                                        for (var W = 0; W < L.length; W++)
                                                            if (b = L[W],
                                                            b.getAttribute("href") === (h.href == null || h.href === "" ? null : h.href) && b.getAttribute("rel") === (h.rel == null ? null : h.rel) && b.getAttribute("title") === (h.title == null ? null : h.title) && b.getAttribute("crossorigin") === (h.crossOrigin == null ? null : h.crossOrigin)) {
                                                                L.splice(W, 1);
                                                                break t
                                                            }
                                                    }
                                                    b = x.createElement(m),
                                                    Ts(b, m, h),
                                                    x.head.appendChild(b);
                                                    break;
                                                case "meta":
                                                    if (L = XT("meta", "content", x).get(m + (h.content || ""))) {
                                                        for (W = 0; W < L.length; W++)
                                                            if (b = L[W],
                                                            b.getAttribute("content") === (h.content == null ? null : "" + h.content) && b.getAttribute("name") === (h.name == null ? null : h.name) && b.getAttribute("property") === (h.property == null ? null : h.property) && b.getAttribute("http-equiv") === (h.httpEquiv == null ? null : h.httpEquiv) && b.getAttribute("charset") === (h.charSet == null ? null : h.charSet)) {
                                                                L.splice(W, 1);
                                                                break t
                                                            }
                                                    }
                                                    b = x.createElement(m),
                                                    Ts(b, m, h),
                                                    x.head.appendChild(b);
                                                    break;
                                                default:
                                                    throw Error(a(468, m))
                                                }
                                                b[Zt] = s,
                                                _e(b),
                                                m = b
                                            }
                                            s.stateNode = m
                                        } else
                                            WT(x, s.type, s.stateNode);
                                    else
                                        s.stateNode = qT(x, m, s.memoizedProps);
                                else
                                    b !== m ? (b === null ? h.stateNode !== null && (h = h.stateNode,
                                    h.parentNode.removeChild(h)) : b.count--,
                                    m === null ? WT(x, s.type, s.stateNode) : qT(x, m, s.memoizedProps)) : m === null && s.stateNode !== null && Yl(s, s.memoizedProps, h.memoizedProps)
                            }
                            break;
                        case 27:
                            Pi(r, s),
                            ui(s),
                            m & 512 && (Mi || h === null || Da(h, h.return)),
                            h !== null && m & 4 && Yl(s, s.memoizedProps, h.memoizedProps);
                            break;
                        case 5:
                            if (Pi(r, s),
                            ui(s),
                            m & 512 && (Mi || h === null || Da(h, h.return)),
                            s.flags & 32) {
                                x = s.stateNode;
                                try {
                                    Ui(x, "")
                                } catch (yt) {
                                    Be(s, s.return, yt)
                                }
                            }
                            m & 4 && s.stateNode != null && (x = s.memoizedProps,
                            Yl(s, x, h !== null ? h.memoizedProps : x)),
                            m & 1024 && (Qo = !0);
                            break;
                        case 6:
                            if (Pi(r, s),
                            ui(s),
                            m & 4) {
                                if (s.stateNode === null)
                                    throw Error(a(162));
                                m = s.memoizedProps,
                                h = s.stateNode;
                                try {
                                    h.nodeValue = m
                                } catch (yt) {
                                    Be(s, s.return, yt)
                                }
                            }
                            break;
                        case 3:
                            if (T_ = null,
                            x = Ka,
                            Ka = M_(r.containerInfo),
                            Pi(r, s),
                            Ka = x,
                            ui(s),
                            m & 4 && h !== null && h.memoizedState.isDehydrated)
                                try {
                                    yd(r.containerInfo)
                                } catch (yt) {
                                    Be(s, s.return, yt)
                                }
                            Qo && (Qo = !1,
                            $o(s));
                            break;
                        case 4:
                            m = Ka,
                            Ka = M_(s.stateNode.containerInfo),
                            Pi(r, s),
                            ui(s),
                            Ka = m;
                            break;
                        case 12:
                            Pi(r, s),
                            ui(s);
                            break;
                        case 31:
                            Pi(r, s),
                            ui(s),
                            m & 4 && (m = s.updateQueue,
                            m !== null && (s.updateQueue = null,
                            Jo(s, m)));
                            break;
                        case 13:
                            Pi(r, s),
                            ui(s),
                            s.child.flags & 8192 && s.memoizedState !== null != (h !== null && h.memoizedState !== null) && (Ln = he()),
                            m & 4 && (m = s.updateQueue,
                            m !== null && (s.updateQueue = null,
                            Jo(s, m)));
                            break;
                        case 22:
                            x = s.memoizedState !== null;
                            var ae = h !== null && h.memoizedState !== null
                              , be = Ms
                              , ze = Mi;
                            if (Ms = be || x,
                            Mi = ze || ae,
                            Pi(r, s),
                            Mi = ze,
                            Ms = be,
                            ui(s),
                            m & 8192)
                                e: for (r = s.stateNode,
                                r._visibility = x ? r._visibility & -2 : r._visibility | 1,
                                x && (h === null || ae || Ms || Mi || ra(s)),
                                h = null,
                                r = s; ; ) {
                                    if (r.tag === 5 || r.tag === 26) {
                                        if (h === null) {
                                            ae = h = r;
                                            try {
                                                if (b = ae.stateNode,
                                                x)
                                                    L = b.style,
                                                    typeof L.setProperty == "function" ? L.setProperty("display", "none", "important") : L.display = "none";
                                                else {
                                                    W = ae.stateNode;
                                                    var Fe = ae.memoizedProps.style
                                                      , Ee = Fe != null && Fe.hasOwnProperty("display") ? Fe.display : null;
                                                    W.style.display = Ee == null || typeof Ee == "boolean" ? "" : ("" + Ee).trim()
                                                }
                                            } catch (yt) {
                                                Be(ae, ae.return, yt)
                                            }
                                        }
                                    } else if (r.tag === 6) {
                                        if (h === null) {
                                            ae = r;
                                            try {
                                                ae.stateNode.nodeValue = x ? "" : ae.memoizedProps
                                            } catch (yt) {
                                                Be(ae, ae.return, yt)
                                            }
                                        }
                                    } else if (r.tag === 18) {
                                        if (h === null) {
                                            ae = r;
                                            try {
                                                var Ne = ae.stateNode;
                                                x ? IT(Ne, !0) : IT(ae.stateNode, !1)
                                            } catch (yt) {
                                                Be(ae, ae.return, yt)
                                            }
                                        }
                                    } else if ((r.tag !== 22 && r.tag !== 23 || r.memoizedState === null || r === s) && r.child !== null) {
                                        r.child.return = r,
                                        r = r.child;
                                        continue
                                    }
                                    if (r === s)
                                        break e;
                                    for (; r.sibling === null; ) {
                                        if (r.return === null || r.return === s)
                                            break e;
                                        h === r && (h = null),
                                        r = r.return
                                    }
                                    h === r && (h = null),
                                    r.sibling.return = r.return,
                                    r = r.sibling
                                }
                            m & 4 && (m = s.updateQueue,
                            m !== null && (h = m.retryQueue,
                            h !== null && (m.retryQueue = null,
                            Jo(s, h))));
                            break;
                        case 19:
                            Pi(r, s),
                            ui(s),
                            m & 4 && (m = s.updateQueue,
                            m !== null && (s.updateQueue = null,
                            Jo(s, m)));
                            break;
                        case 30:
                            break;
                        case 21:
                            break;
                        default:
                            Pi(r, s),
                            ui(s)
                        }
                    }
                    function ui(s) {
                        var r = s.flags;
                        if (r & 2) {
                            try {
                                for (var h, m = s.return; m !== null; ) {
                                    if (od(m)) {
                                        h = m;
                                        break
                                    }
                                    m = m.return
                                }
                                if (h == null)
                                    throw Error(a(160));
                                switch (h.tag) {
                                case 27:
                                    var x = h.stateNode;
                                    lo(s, zc(s), x);
                                    break;
                                case 5:
                                    var b = h.stateNode;
                                    h.flags & 32 && (Ui(b, ""),
                                    h.flags &= -33),
                                    lo(s, zc(s), b);
                                    break;
                                case 3:
                                case 4:
                                    var L = h.stateNode.containerInfo;
                                    Zo(s, zc(s), L);
                                    break;
                                default:
                                    throw Error(a(161))
                                }
                            } catch (W) {
                                Be(s, s.return, W)
                            }
                            s.flags &= -3
                        }
                        r & 4096 && (s.flags &= -4097)
                    }
                    function $o(s) {
                        if (s.subtreeFlags & 1024)
                            for (s = s.child; s !== null; ) {
                                var r = s;
                                $o(r),
                                r.tag === 5 && r.flags & 1024 && r.stateNode.reset(),
                                s = s.sibling
                            }
                    }
                    function ms(s, r) {
                        if (r.subtreeFlags & 8772)
                            for (r = r.child; r !== null; )
                                Ri(s, r.alternate, r),
                                r = r.sibling
                    }
                    function ra(s) {
                        for (s = s.child; s !== null; ) {
                            var r = s;
                            switch (r.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Er(4, r, r.return),
                                ra(r);
                                break;
                            case 1:
                                Da(r, r.return);
                                var h = r.stateNode;
                                typeof h.componentWillUnmount == "function" && Wl(r, r.return, h),
                                ra(r);
                                break;
                            case 27:
                                jm(r.stateNode);
                            case 26:
                            case 5:
                                Da(r, r.return),
                                ra(r);
                                break;
                            case 22:
                                r.memoizedState === null && ra(r);
                                break;
                            case 30:
                                ra(r);
                                break;
                            default:
                                ra(r)
                            }
                            s = s.sibling
                        }
                    }
                    function Ja(s, r, h) {
                        for (h = h && (r.subtreeFlags & 8772) !== 0,
                        r = r.child; r !== null; ) {
                            var m = r.alternate
                              , x = s
                              , b = r
                              , L = b.flags;
                            switch (b.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Ja(x, b, h),
                                oo(4, b);
                                break;
                            case 1:
                                if (Ja(x, b, h),
                                m = b,
                                x = m.stateNode,
                                typeof x.componentDidMount == "function")
                                    try {
                                        x.componentDidMount()
                                    } catch (be) {
                                        Be(m, m.return, be)
                                    }
                                if (m = b,
                                x = m.updateQueue,
                                x !== null) {
                                    var W = m.stateNode;
                                    try {
                                        var ae = x.shared.hiddenCallbacks;
                                        if (ae !== null)
                                            for (x.shared.hiddenCallbacks = null,
                                            x = 0; x < ae.length; x++)
                                                Fv(ae[x], W)
                                    } catch (be) {
                                        Be(m, m.return, be)
                                    }
                                }
                                h && L & 64 && Xl(b),
                                Na(b, b.return);
                                break;
                            case 27:
                                Bc(b);
                            case 26:
                            case 5:
                                Ja(x, b, h),
                                h && m === null && L & 4 && m_(b),
                                Na(b, b.return);
                                break;
                            case 12:
                                Ja(x, b, h);
                                break;
                            case 31:
                                Ja(x, b, h),
                                h && L & 4 && jl(x, b);
                                break;
                            case 13:
                                Ja(x, b, h),
                                h && L & 4 && Ko(x, b);
                                break;
                            case 22:
                                b.memoizedState === null && Ja(x, b, h),
                                Na(b, b.return);
                                break;
                            case 30:
                                break;
                            default:
                                Ja(x, b, h)
                            }
                            r = r.sibling
                        }
                    }
                    function ud(s, r) {
                        var h = null;
                        s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool),
                        s = null,
                        r.memoizedState !== null && r.memoizedState.cachePool !== null && (s = r.memoizedState.cachePool.pool),
                        s !== h && (s != null && s.refCount++,
                        h != null && Il(h))
                    }
                    function hd(s, r) {
                        s = null,
                        r.alternate !== null && (s = r.alternate.memoizedState.cache),
                        r = r.memoizedState.cache,
                        r !== s && (r.refCount++,
                        s != null && Il(s))
                    }
                    function Pn(s, r, h, m) {
                        if (r.subtreeFlags & 10256)
                            for (r = r.child; r !== null; )
                                fd(s, r, h, m),
                                r = r.sibling
                    }
                    function fd(s, r, h, m) {
                        var x = r.flags;
                        switch (r.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Pn(s, r, h, m),
                            x & 2048 && oo(9, r);
                            break;
                        case 1:
                            Pn(s, r, h, m);
                            break;
                        case 3:
                            Pn(s, r, h, m),
                            x & 2048 && (s = null,
                            r.alternate !== null && (s = r.alternate.memoizedState.cache),
                            r = r.memoizedState.cache,
                            r !== s && (r.refCount++,
                            s != null && Il(s)));
                            break;
                        case 12:
                            if (x & 2048) {
                                Pn(s, r, h, m),
                                s = r.stateNode;
                                try {
                                    var b = r.memoizedProps
                                      , L = b.id
                                      , W = b.onPostCommit;
                                    typeof W == "function" && W(L, r.alternate === null ? "mount" : "update", s.passiveEffectDuration, -0)
                                } catch (ae) {
                                    Be(r, r.return, ae)
                                }
                            } else
                                Pn(s, r, h, m);
                            break;
                        case 31:
                            Pn(s, r, h, m);
                            break;
                        case 13:
                            Pn(s, r, h, m);
                            break;
                        case 23:
                            break;
                        case 22:
                            b = r.stateNode,
                            L = r.alternate,
                            r.memoizedState !== null ? b._visibility & 2 ? Pn(s, r, h, m) : $a(s, r) : b._visibility & 2 ? Pn(s, r, h, m) : (b._visibility |= 2,
                            uo(s, r, h, m, (r.subtreeFlags & 10256) !== 0 || !1)),
                            x & 2048 && ud(L, r);
                            break;
                        case 24:
                            Pn(s, r, h, m),
                            x & 2048 && hd(r.alternate, r);
                            break;
                        default:
                            Pn(s, r, h, m)
                        }
                    }
                    function uo(s, r, h, m, x) {
                        for (x = x && ((r.subtreeFlags & 10256) !== 0 || !1),
                        r = r.child; r !== null; ) {
                            var b = s
                              , L = r
                              , W = h
                              , ae = m
                              , be = L.flags;
                            switch (L.tag) {
                            case 0:
                            case 11:
                            case 15:
                                uo(b, L, W, ae, x),
                                oo(8, L);
                                break;
                            case 23:
                                break;
                            case 22:
                                var ze = L.stateNode;
                                L.memoizedState !== null ? ze._visibility & 2 ? uo(b, L, W, ae, x) : $a(b, L) : (ze._visibility |= 2,
                                uo(b, L, W, ae, x)),
                                x && be & 2048 && ud(L.alternate, L);
                                break;
                            case 24:
                                uo(b, L, W, ae, x),
                                x && be & 2048 && hd(L.alternate, L);
                                break;
                            default:
                                uo(b, L, W, ae, x)
                            }
                            r = r.sibling
                        }
                    }
                    function $a(s, r) {
                        if (r.subtreeFlags & 10256)
                            for (r = r.child; r !== null; ) {
                                var h = s
                                  , m = r
                                  , x = m.flags;
                                switch (m.tag) {
                                case 22:
                                    $a(h, m),
                                    x & 2048 && ud(m.alternate, m);
                                    break;
                                case 24:
                                    $a(h, m),
                                    x & 2048 && hd(m.alternate, m);
                                    break;
                                default:
                                    $a(h, m)
                                }
                                r = r.sibling
                            }
                    }
                    var oa = 8192;
                    function Pc(s, r, h) {
                        if (s.subtreeFlags & oa)
                            for (s = s.child; s !== null; )
                                g_(s, r, h),
                                s = s.sibling
                    }
                    function g_(s, r, h) {
                        switch (s.tag) {
                        case 26:
                            Pc(s, r, h),
                            s.flags & oa && s.memoizedState !== null && uN(h, Ka, s.memoizedState, s.memoizedProps);
                            break;
                        case 5:
                            Pc(s, r, h);
                            break;
                        case 3:
                        case 4:
                            var m = Ka;
                            Ka = M_(s.stateNode.containerInfo),
                            Pc(s, r, h),
                            Ka = m;
                            break;
                        case 22:
                            s.memoizedState === null && (m = s.alternate,
                            m !== null && m.memoizedState !== null ? (m = oa,
                            oa = 16777216,
                            Pc(s, r, h),
                            oa = m) : Pc(s, r, h));
                            break;
                        default:
                            Pc(s, r, h)
                        }
                    }
                    function v_(s) {
                        var r = s.alternate;
                        if (r !== null && (s = r.child,
                        s !== null)) {
                            r.child = null;
                            do
                                r = s.sibling,
                                s.sibling = null,
                                s = r;
                            while (s !== null)
                        }
                    }
                    function jn(s) {
                        var r = s.deletions;
                        if ((s.flags & 16) !== 0) {
                            if (r !== null)
                                for (var h = 0; h < r.length; h++) {
                                    var m = r[h];
                                    Un = m,
                                    Rr(m, s)
                                }
                            v_(s)
                        }
                        if (s.subtreeFlags & 10256)
                            for (s = s.child; s !== null; )
                                km(s),
                                s = s.sibling
                    }
                    function km(s) {
                        switch (s.tag) {
                        case 0:
                        case 11:
                        case 15:
                            jn(s),
                            s.flags & 2048 && Er(9, s, s.return);
                            break;
                        case 3:
                            jn(s);
                            break;
                        case 12:
                            jn(s);
                            break;
                        case 22:
                            var r = s.stateNode;
                            s.memoizedState !== null && r._visibility & 2 && (s.return === null || s.return.tag !== 13) ? (r._visibility &= -3,
                            wr(s)) : jn(s);
                            break;
                        default:
                            jn(s)
                        }
                    }
                    function wr(s) {
                        var r = s.deletions;
                        if ((s.flags & 16) !== 0) {
                            if (r !== null)
                                for (var h = 0; h < r.length; h++) {
                                    var m = r[h];
                                    Un = m,
                                    Rr(m, s)
                                }
                            v_(s)
                        }
                        for (s = s.child; s !== null; ) {
                            switch (r = s,
                            r.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Er(8, r, r.return),
                                wr(r);
                                break;
                            case 22:
                                h = r.stateNode,
                                h._visibility & 2 && (h._visibility &= -3,
                                wr(r));
                                break;
                            default:
                                wr(r)
                            }
                            s = s.sibling
                        }
                    }
                    function Rr(s, r) {
                        for (; Un !== null; ) {
                            var h = Un;
                            switch (h.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Er(8, h, r);
                                break;
                            case 23:
                            case 22:
                                if (h.memoizedState !== null && h.memoizedState.cachePool !== null) {
                                    var m = h.memoizedState.cachePool.pool;
                                    m != null && m.refCount++
                                }
                                break;
                            case 24:
                                Il(h.memoizedState.cache)
                            }
                            if (m = h.child,
                            m !== null)
                                m.return = h,
                                Un = m;
                            else
                                e: for (h = s; Un !== null; ) {
                                    m = Un;
                                    var x = m.sibling
                                      , b = m.return;
                                    if (co(m),
                                    m === h) {
                                        Un = null;
                                        break e
                                    }
                                    if (x !== null) {
                                        x.return = b,
                                        Un = x;
                                        break e
                                    }
                                    Un = b
                                }
                        }
                    }
                    var mi = {
                        getCacheForType: function(s) {
                            var r = ns(Yn)
                              , h = r.data.get(s);
                            return h === void 0 && (h = s(),
                            r.data.set(s, h)),
                            h
                        },
                        cacheSignal: function() {
                            return ns(Yn).controller.signal
                        }
                    }
                      , qm = typeof WeakMap == "function" ? WeakMap : Map
                      , An = 0
                      , qt = null
                      , on = null
                      , Ut = 0
                      , Kt = 0
                      , hi = null
                      , la = !1
                      , Vc = !1
                      , Fc = !1
                      , Oa = 0
                      , ti = 0
                      , er = 0
                      , Nr = 0
                      , Zl = 0
                      , ca = 0
                      , bn = 0
                      , Nn = null
                      , Bt = null
                      , mn = !1
                      , Ln = 0
                      , Bs = 0
                      , Ua = 1 / 0
                      , ho = null
                      , Dr = null
                      , qn = 0
                      , In = null
                      , ua = null
                      , bs = 0
                      , mh = 0
                      , Ps = null
                      , Ql = null
                      , fo = 0
                      , La = null;
                    function Vs() {
                        return (An & 2) !== 0 && Ut !== 0 ? Ut & -Ut : F.T !== null ? FS() : Ks()
                    }
                    function dd() {
                        if (ca === 0)
                            if ((Ut & 536870912) === 0 || hn) {
                                var s = dt;
                                dt <<= 1,
                                (dt & 3932160) === 0 && (dt = 262144),
                                ca = s
                            } else
                                ca = 536870912;
                        return s = Ls.current,
                        s !== null && (s.flags |= 32),
                        ca
                    }
                    function Zi(s, r, h) {
                        (s === qt && (Kt === 2 || Kt === 9) || s.cancelPendingCommit !== null) && (tl(s, 0),
                        Fs(s, Ut, ca, !1)),
                        ys(s, h),
                        ((An & 2) === 0 || s !== qt) && (s === qt && ((An & 2) === 0 && (Nr |= h),
                        ti === 4 && Fs(s, Ut, ca, !1)),
                        Kl(s))
                    }
                    function gh(s, r, h) {
                        if ((An & 6) !== 0)
                            throw Error(a(327));
                        var m = !h && (r & 127) === 0 && (r & s.expiredLanes) === 0 || Tt(s, r)
                          , x = m ? O(s, r) : M(s, r, !0)
                          , b = m;
                        do {
                            if (x === 0) {
                                Vc && !m && Fs(s, r, 0, !1);
                                break
                            } else {
                                if (h = s.current.alternate,
                                b && !pd(h)) {
                                    x = M(s, r, !1),
                                    b = !1;
                                    continue
                                }
                                if (x === 2) {
                                    if (b = r,
                                    s.errorRecoveryDisabledLanes & b)
                                        var L = 0;
                                    else
                                        L = s.pendingLanes & -536870913,
                                        L = L !== 0 ? L : L & 536870912 ? 536870912 : 0;
                                    if (L !== 0) {
                                        r = L;
                                        e: {
                                            var W = s;
                                            x = Nn;
                                            var ae = W.current.memoizedState.isDehydrated;
                                            if (ae && (tl(W, L).flags |= 256),
                                            L = M(W, L, !1),
                                            L !== 2) {
                                                if (Fc && !ae) {
                                                    W.errorRecoveryDisabledLanes |= b,
                                                    Nr |= b,
                                                    x = 4;
                                                    break e
                                                }
                                                b = Bt,
                                                Bt = x,
                                                b !== null && (Bt === null ? Bt = b : Bt.push.apply(Bt, b))
                                            }
                                            x = L
                                        }
                                        if (b = !1,
                                        x !== 2)
                                            continue
                                    }
                                }
                                if (x === 1) {
                                    tl(s, 0),
                                    Fs(s, r, 0, !0);
                                    break
                                }
                                e: {
                                    switch (m = s,
                                    b = x,
                                    b) {
                                    case 0:
                                    case 1:
                                        throw Error(a(345));
                                    case 4:
                                        if ((r & 4194048) !== r)
                                            break;
                                    case 6:
                                        Fs(m, r, ca, !la);
                                        break e;
                                    case 2:
                                        Bt = null;
                                        break;
                                    case 3:
                                    case 5:
                                        break;
                                    default:
                                        throw Error(a(329))
                                    }
                                    if ((r & 62914560) === r && (x = Ln + 300 - he(),
                                    10 < x)) {
                                        if (Fs(m, r, ca, !la),
                                        mt(m, 0, !0) !== 0)
                                            break e;
                                        bs = r,
                                        m.timeoutHandle = OT(po.bind(null, m, h, Bt, ho, mn, r, ca, Nr, bn, la, b, "Throttled", -0, 0), x);
                                        break e
                                    }
                                    po(m, h, Bt, ho, mn, r, ca, Nr, bn, la, b, null, -0, 0)
                                }
                            }
                            break
                        } while (!0);
                        Kl(s)
                    }
                    function po(s, r, h, m, x, b, L, W, ae, be, ze, Fe, Ee, Ne) {
                        if (s.timeoutHandle = -1,
                        Fe = r.subtreeFlags,
                        Fe & 8192 || (Fe & 16785408) === 16785408) {
                            Fe = {
                                stylesheets: null,
                                count: 0,
                                imgCount: 0,
                                imgBytes: 0,
                                suspenseyImages: [],
                                waitingForImages: !0,
                                waitingForViewTransition: !1,
                                unsuspend: ur
                            },
                            g_(r, b, Fe);
                            var yt = (b & 62914560) === b ? Ln - he() : (b & 4194048) === b ? Bs - he() : 0;
                            if (yt = hN(Fe, yt),
                            yt !== null) {
                                bs = b,
                                s.cancelPendingCommit = yt(ct.bind(null, s, r, b, h, m, x, L, W, ae, ze, Fe, null, Ee, Ne)),
                                Fs(s, b, L, !be);
                                return
                            }
                        }
                        ct(s, r, b, h, m, x, L, W, ae)
                    }
                    function pd(s) {
                        for (var r = s; ; ) {
                            var h = r.tag;
                            if ((h === 0 || h === 11 || h === 15) && r.flags & 16384 && (h = r.updateQueue,
                            h !== null && (h = h.stores,
                            h !== null)))
                                for (var m = 0; m < h.length; m++) {
                                    var x = h[m]
                                      , b = x.getSnapshot;
                                    x = x.value;
                                    try {
                                        if (!fs(b(), x))
                                            return !1
                                    } catch {
                                        return !1
                                    }
                                }
                            if (h = r.child,
                            r.subtreeFlags & 16384 && h !== null)
                                h.return = r,
                                r = h;
                            else {
                                if (r === s)
                                    break;
                                for (; r.sibling === null; ) {
                                    if (r.return === null || r.return === s)
                                        return !0;
                                    r = r.return
                                }
                                r.sibling.return = r.return,
                                r = r.sibling
                            }
                        }
                        return !0
                    }
                    function Fs(s, r, h, m) {
                        r &= ~Zl,
                        r &= ~Nr,
                        s.suspendedLanes |= r,
                        s.pingedLanes &= ~r,
                        m && (s.warmLanes |= r),
                        m = s.expirationTimes;
                        for (var x = r; 0 < x; ) {
                            var b = 31 - tt(x)
                              , L = 1 << b;
                            m[b] = -1,
                            x &= ~L
                        }
                        h !== 0 && xl(s, h, r)
                    }
                    function el() {
                        return (An & 6) === 0 ? (Xm(0, !1),
                        !1) : !0
                    }
                    function vh() {
                        if (on !== null) {
                            if (Kt === 0)
                                var s = on.return;
                            else
                                s = on,
                                xs = Fo = null,
                                mm(s),
                                ko = null,
                                Fl = 0,
                                s = on;
                            for (; s !== null; )
                                ql(s.alternate, s),
                                s = s.return;
                            on = null
                        }
                    }
                    function tl(s, r) {
                        var h = s.timeoutHandle;
                        h !== -1 && (s.timeoutHandle = -1,
                        Y3(h)),
                        h = s.cancelPendingCommit,
                        h !== null && (s.cancelPendingCommit = null,
                        h()),
                        bs = 0,
                        vh(),
                        qt = s,
                        on = h = pr(s.current, null),
                        Ut = r,
                        Kt = 0,
                        hi = null,
                        la = !1,
                        Vc = Tt(s, r),
                        Fc = !1,
                        bn = ca = Zl = Nr = er = ti = 0,
                        Bt = Nn = null,
                        mn = !1,
                        (r & 8) !== 0 && (r |= r & 32);
                        var m = s.entangledLanes;
                        if (m !== 0)
                            for (s = s.entanglements,
                            m &= r; 0 < m; ) {
                                var x = 31 - tt(m)
                                  , b = 1 << x;
                                r |= s[x],
                                m &= ~b
                            }
                        return Oa = r,
                        Wr(),
                        h
                    }
                    function Hc(s, r) {
                        Ot = null,
                        F.H = rh,
                        r === Ac || r === Kr ? (r = $r(),
                        Kt = 3) : r === Ec ? (r = $r(),
                        Kt = 4) : Kt = r === Hm ? 8 : r !== null && typeof r == "object" && typeof r.then == "function" ? 6 : 1,
                        hi = r,
                        on === null && (ti = 1,
                        td(s, ea(r, s.current)))
                    }
                    function md() {
                        var s = Ls.current;
                        return s === null ? !0 : (Ut & 4194048) === Ut ? wa === null : (Ut & 62914560) === Ut || (Ut & 536870912) !== 0 ? s === wa : !1
                    }
                    function l() {
                        var s = F.H;
                        return F.H = rh,
                        s === null ? rh : s
                    }
                    function c() {
                        var s = F.A;
                        return F.A = mi,
                        s
                    }
                    function _() {
                        ti = 4,
                        la || (Ut & 4194048) !== Ut && Ls.current !== null || (Vc = !0),
                        (er & 134217727) === 0 && (Nr & 134217727) === 0 || qt === null || Fs(qt, Ut, ca, !1)
                    }
                    function M(s, r, h) {
                        var m = An;
                        An |= 2;
                        var x = l()
                          , b = c();
                        (qt !== s || Ut !== r) && (ho = null,
                        tl(s, r)),
                        r = !1;
                        var L = ti;
                        e: do
                            try {
                                if (Kt !== 0 && on !== null) {
                                    var W = on
                                      , ae = hi;
                                    switch (Kt) {
                                    case 8:
                                        vh(),
                                        L = 6;
                                        break e;
                                    case 3:
                                    case 2:
                                    case 9:
                                    case 6:
                                        Ls.current === null && (r = !0);
                                        var be = Kt;
                                        if (Kt = 0,
                                        hi = null,
                                        Ie(s, W, ae, be),
                                        h && Vc) {
                                            L = 0;
                                            break e
                                        }
                                        break;
                                    default:
                                        be = Kt,
                                        Kt = 0,
                                        hi = null,
                                        Ie(s, W, ae, be)
                                    }
                                }
                                C(),
                                L = ti;
                                break
                            } catch (ze) {
                                Hc(s, ze)
                            }
                        while (!0);
                        return r && s.shellSuspendCounter++,
                        xs = Fo = null,
                        An = m,
                        F.H = x,
                        F.A = b,
                        on === null && (qt = null,
                        Ut = 0,
                        Wr()),
                        L
                    }
                    function C() {
                        for (; on !== null; )
                            se(on)
                    }
                    function O(s, r) {
                        var h = An;
                        An |= 2;
                        var m = l()
                          , x = c();
                        qt !== s || Ut !== r ? (ho = null,
                        Ua = he() + 500,
                        tl(s, r)) : Vc = Tt(s, r);
                        e: do
                            try {
                                if (Kt !== 0 && on !== null) {
                                    r = on;
                                    var b = hi;
                                    t: switch (Kt) {
                                    case 1:
                                        Kt = 0,
                                        hi = null,
                                        Ie(s, r, b, 1);
                                        break;
                                    case 2:
                                    case 9:
                                        if (um(b)) {
                                            Kt = 0,
                                            hi = null,
                                            ge(r);
                                            break
                                        }
                                        r = function() {
                                            Kt !== 2 && Kt !== 9 || qt !== s || (Kt = 7),
                                            Kl(s)
                                        }
                                        ,
                                        b.then(r, r);
                                        break e;
                                    case 3:
                                        Kt = 7;
                                        break e;
                                    case 4:
                                        Kt = 5;
                                        break e;
                                    case 7:
                                        um(b) ? (Kt = 0,
                                        hi = null,
                                        ge(r)) : (Kt = 0,
                                        hi = null,
                                        Ie(s, r, b, 7));
                                        break;
                                    case 5:
                                        var L = null;
                                        switch (on.tag) {
                                        case 26:
                                            L = on.memoizedState;
                                        case 5:
                                        case 27:
                                            var W = on;
                                            if (L ? YT(L) : W.stateNode.complete) {
                                                Kt = 0,
                                                hi = null;
                                                var ae = W.sibling;
                                                if (ae !== null)
                                                    on = ae;
                                                else {
                                                    var be = W.return;
                                                    be !== null ? (on = be,
                                                    $e(be)) : on = null
                                                }
                                                break t
                                            }
                                        }
                                        Kt = 0,
                                        hi = null,
                                        Ie(s, r, b, 5);
                                        break;
                                    case 6:
                                        Kt = 0,
                                        hi = null,
                                        Ie(s, r, b, 6);
                                        break;
                                    case 8:
                                        vh(),
                                        ti = 6;
                                        break e;
                                    default:
                                        throw Error(a(462))
                                    }
                                }
                                j();
                                break
                            } catch (ze) {
                                Hc(s, ze)
                            }
                        while (!0);
                        return xs = Fo = null,
                        F.H = m,
                        F.A = x,
                        An = h,
                        on !== null ? 0 : (qt = null,
                        Ut = 0,
                        Wr(),
                        ti)
                    }
                    function j() {
                        for (; on !== null && !Z(); )
                            se(on)
                    }
                    function se(s) {
                        var r = sd(s.alternate, s, Oa);
                        s.memoizedProps = s.pendingProps,
                        r === null ? $e(s) : on = r
                    }
                    function ge(s) {
                        var r = s
                          , h = r.alternate;
                        switch (r.tag) {
                        case 15:
                        case 0:
                            r = uh(h, r, r.pendingProps, r.type, void 0, Ut);
                            break;
                        case 11:
                            r = uh(h, r, r.pendingProps, r.type.render, r.ref, Ut);
                            break;
                        case 5:
                            mm(r);
                        default:
                            ql(h, r),
                            r = on = bc(r, Oa),
                            r = sd(h, r, Oa)
                        }
                        s.memoizedProps = s.pendingProps,
                        r === null ? $e(s) : on = r
                    }
                    function Ie(s, r, h, m) {
                        xs = Fo = null,
                        mm(r),
                        ko = null,
                        Fl = 0;
                        var x = r.return;
                        try {
                            if (BS(s, x, r, h, Ut)) {
                                ti = 1,
                                td(s, ea(h, s.current)),
                                on = null;
                                return
                            }
                        } catch (b) {
                            if (x !== null)
                                throw on = x,
                                b;
                            ti = 1,
                            td(s, ea(h, s.current)),
                            on = null;
                            return
                        }
                        r.flags & 32768 ? (hn || m === 1 ? s = !0 : Vc || (Ut & 536870912) !== 0 ? s = !1 : (la = s = !0,
                        (m === 2 || m === 9 || m === 3 || m === 6) && (m = Ls.current,
                        m !== null && m.tag === 13 && (m.flags |= 16384))),
                        lt(r, s)) : $e(r)
                    }
                    function $e(s) {
                        var r = s;
                        do {
                            if ((r.flags & 32768) !== 0) {
                                lt(r, la);
                                return
                            }
                            s = r.return;
                            var h = rd(r.alternate, r, Oa);
                            if (h !== null) {
                                on = h;
                                return
                            }
                            if (r = r.sibling,
                            r !== null) {
                                on = r;
                                return
                            }
                            on = r = s
                        } while (r !== null);
                        ti === 0 && (ti = 5)
                    }
                    function lt(s, r) {
                        do {
                            var h = Gm(s.alternate, s);
                            if (h !== null) {
                                h.flags &= 32767,
                                on = h;
                                return
                            }
                            if (h = s.return,
                            h !== null && (h.flags |= 32768,
                            h.subtreeFlags = 0,
                            h.deletions = null),
                            !r && (s = s.sibling,
                            s !== null)) {
                                on = s;
                                return
                            }
                            on = s = h
                        } while (s !== null);
                        ti = 6,
                        on = null
                    }
                    function ct(s, r, h, m, x, b, L, W, ae) {
                        s.cancelPendingCommit = null;
                        do
                            xe();
                        while (qn !== 0);
                        if ((An & 6) !== 0)
                            throw Error(a(327));
                        if (r !== null) {
                            if (r === s.current)
                                throw Error(a(177));
                            if (b = r.lanes | r.childLanes,
                            b |= Wa,
                            Tu(s, h, b, L, W, ae),
                            s === qt && (on = qt = null,
                            Ut = 0),
                            ua = r,
                            In = s,
                            bs = h,
                            mh = b,
                            Ps = x,
                            Ql = m,
                            (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? (s.callbackNode = null,
                            s.callbackPriority = 0,
                            Cn(pt, function() {
                                return fe(),
                                null
                            })) : (s.callbackNode = null,
                            s.callbackPriority = 0),
                            m = (r.flags & 13878) !== 0,
                            (r.subtreeFlags & 13878) !== 0 || m) {
                                m = F.T,
                                F.T = null,
                                x = X.p,
                                X.p = 2,
                                L = An,
                                An |= 4;
                                try {
                                    Cr(s, r, h)
                                } finally {
                                    An = L,
                                    X.p = x,
                                    F.T = m
                                }
                            }
                            qn = 1,
                            Yt(),
                            ha(),
                            Gc()
                        }
                    }
                    function Yt() {
                        if (qn === 1) {
                            qn = 0;
                            var s = In
                              , r = ua
                              , h = (r.flags & 13878) !== 0;
                            if ((r.subtreeFlags & 13878) !== 0 || h) {
                                h = F.T,
                                F.T = null;
                                var m = X.p;
                                X.p = 2;
                                var x = An;
                                An |= 4;
                                try {
                                    cd(r, s);
                                    var b = YS
                                      , L = Zp(s.containerInfo)
                                      , W = b.focusedElem
                                      , ae = b.selectionRange;
                                    if (L !== W && W && W.ownerDocument && Dv(W.ownerDocument.documentElement, W)) {
                                        if (ae !== null && Rl(W)) {
                                            var be = ae.start
                                              , ze = ae.end;
                                            if (ze === void 0 && (ze = be),
                                            "selectionStart"in W)
                                                W.selectionStart = be,
                                                W.selectionEnd = Math.min(ze, W.value.length);
                                            else {
                                                var Fe = W.ownerDocument || document
                                                  , Ee = Fe && Fe.defaultView || window;
                                                if (Ee.getSelection) {
                                                    var Ne = Ee.getSelection()
                                                      , yt = W.textContent.length
                                                      , Pt = Math.min(ae.start, yt)
                                                      , Qn = ae.end === void 0 ? Pt : Math.min(ae.end, yt);
                                                    !Ne.extend && Pt > Qn && (L = Qn,
                                                    Qn = Pt,
                                                    Pt = L);
                                                    var de = Nv(W, Pt)
                                                      , re = Nv(W, Qn);
                                                    if (de && re && (Ne.rangeCount !== 1 || Ne.anchorNode !== de.node || Ne.anchorOffset !== de.offset || Ne.focusNode !== re.node || Ne.focusOffset !== re.offset)) {
                                                        var ye = Fe.createRange();
                                                        ye.setStart(de.node, de.offset),
                                                        Ne.removeAllRanges(),
                                                        Pt > Qn ? (Ne.addRange(ye),
                                                        Ne.extend(re.node, re.offset)) : (ye.setEnd(re.node, re.offset),
                                                        Ne.addRange(ye))
                                                    }
                                                }
                                            }
                                        }
                                        for (Fe = [],
                                        Ne = W; Ne = Ne.parentNode; )
                                            Ne.nodeType === 1 && Fe.push({
                                                element: Ne,
                                                left: Ne.scrollLeft,
                                                top: Ne.scrollTop
                                            });
                                        for (typeof W.focus == "function" && W.focus(),
                                        W = 0; W < Fe.length; W++) {
                                            var Pe = Fe[W];
                                            Pe.element.scrollLeft = Pe.left,
                                            Pe.element.scrollTop = Pe.top
                                        }
                                    }
                                    w_ = !!WS,
                                    YS = WS = null
                                } finally {
                                    An = x,
                                    X.p = m,
                                    F.T = h
                                }
                            }
                            s.current = r,
                            qn = 2
                        }
                    }
                    function ha() {
                        if (qn === 2) {
                            qn = 0;
                            var s = In
                              , r = ua
                              , h = (r.flags & 8772) !== 0;
                            if ((r.subtreeFlags & 8772) !== 0 || h) {
                                h = F.T,
                                F.T = null;
                                var m = X.p;
                                X.p = 2;
                                var x = An;
                                An |= 4;
                                try {
                                    Ri(s, r.alternate, r)
                                } finally {
                                    An = x,
                                    X.p = m,
                                    F.T = h
                                }
                            }
                            qn = 3
                        }
                    }
                    function Gc() {
                        if (qn === 4 || qn === 3) {
                            qn = 0,
                            H();
                            var s = In
                              , r = ua
                              , h = bs
                              , m = Ql;
                            (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? qn = 5 : (qn = 0,
                            ua = In = null,
                            nl(s, s.pendingLanes));
                            var x = s.pendingLanes;
                            if (x === 0 && (Dr = null),
                            Ta(h),
                            r = r.stateNode,
                            nt && typeof nt.onCommitFiberRoot == "function")
                                try {
                                    nt.onCommitFiberRoot(Xe, r, void 0, (r.current.flags & 128) === 128)
                                } catch {}
                            if (m !== null) {
                                r = F.T,
                                x = X.p,
                                X.p = 2,
                                F.T = null;
                                try {
                                    for (var b = s.onRecoverableError, L = 0; L < m.length; L++) {
                                        var W = m[L];
                                        b(W.value, {
                                            componentStack: W.stack
                                        })
                                    }
                                } finally {
                                    F.T = r,
                                    X.p = x
                                }
                            }
                            (bs & 3) !== 0 && xe(),
                            Kl(s),
                            x = s.pendingLanes,
                            (h & 261930) !== 0 && (x & 42) !== 0 ? s === La ? fo++ : (fo = 0,
                            La = s) : fo = 0,
                            Xm(0, !1)
                        }
                    }
                    function nl(s, r) {
                        (s.pooledCacheLanes &= r) === 0 && (r = s.pooledCache,
                        r != null && (s.pooledCache = null,
                        Il(r)))
                    }
                    function xe() {
                        return Yt(),
                        ha(),
                        Gc(),
                        fe()
                    }
                    function fe() {
                        if (qn !== 5)
                            return !1;
                        var s = In
                          , r = mh;
                        mh = 0;
                        var h = Ta(bs)
                          , m = F.T
                          , x = X.p;
                        try {
                            X.p = 32 > h ? 32 : h,
                            F.T = null,
                            h = Ps,
                            Ps = null;
                            var b = In
                              , L = bs;
                            if (qn = 0,
                            ua = In = null,
                            bs = 0,
                            (An & 6) !== 0)
                                throw Error(a(331));
                            var W = An;
                            if (An |= 4,
                            km(b.current),
                            fd(b, b.current, L, h),
                            An = W,
                            Xm(0, !1),
                            nt && typeof nt.onPostCommitFiberRoot == "function")
                                try {
                                    nt.onPostCommitFiberRoot(Xe, b)
                                } catch {}
                            return !0
                        } finally {
                            X.p = x,
                            F.T = m,
                            nl(s, r)
                        }
                    }
                    function Re(s, r, h) {
                        r = ea(h, r),
                        r = Lc(s.stateNode, r, 2),
                        s = Sr(s, r, 2),
                        s !== null && (ys(s, 2),
                        Kl(s))
                    }
                    function Be(s, r, h) {
                        if (s.tag === 3)
                            Re(s, s, h);
                        else
                            for (; r !== null; ) {
                                if (r.tag === 3) {
                                    Re(r, s, h);
                                    break
                                } else if (r.tag === 1) {
                                    var m = r.stateNode;
                                    if (typeof r.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (Dr === null || !Dr.has(m))) {
                                        s = ea(h, s),
                                        h = lh(2),
                                        m = Sr(r, h, 2),
                                        m !== null && (nd(h, m, r, s),
                                        ys(m, 2),
                                        Kl(m));
                                        break
                                    }
                                }
                                r = r.return
                            }
                    }
                    function Et(s, r, h) {
                        var m = s.pingCache;
                        if (m === null) {
                            m = s.pingCache = new qm;
                            var x = new Set;
                            m.set(r, x)
                        } else
                            x = m.get(r),
                            x === void 0 && (x = new Set,
                            m.set(r, x));
                        x.has(h) || (Fc = !0,
                        x.add(h),
                        s = ni.bind(null, s, r, h),
                        r.then(s, s))
                    }
                    function ni(s, r, h) {
                        var m = s.pingCache;
                        m !== null && m.delete(r),
                        s.pingedLanes |= s.suspendedLanes & h,
                        s.warmLanes &= ~h,
                        qt === s && (Ut & h) === h && (ti === 4 || ti === 3 && (Ut & 62914560) === Ut && 300 > he() - Ln ? (An & 2) === 0 && tl(s, 0) : Zl |= h,
                        bn === Ut && (bn = 0)),
                        Kl(s)
                    }
                    function Ft(s, r) {
                        r === 0 && (r = pn()),
                        s = Yr(s, r),
                        s !== null && (ys(s, r),
                        Kl(s))
                    }
                    function En(s) {
                        var r = s.memoizedState
                          , h = 0;
                        r !== null && (h = r.retryLane),
                        Ft(s, h)
                    }
                    function Qi(s, r) {
                        var h = 0;
                        switch (s.tag) {
                        case 31:
                        case 13:
                            var m = s.stateNode
                              , x = s.memoizedState;
                            x !== null && (h = x.retryLane);
                            break;
                        case 19:
                            m = s.stateNode;
                            break;
                        case 22:
                            m = s.stateNode._retryCache;
                            break;
                        default:
                            throw Error(a(314))
                        }
                        m !== null && m.delete(r),
                        Ft(s, h)
                    }
                    function Cn(s, r) {
                        return ke(s, r)
                    }
                    var tr = null
                      , kc = null
                      , PS = !1
                      , __ = !1
                      , VS = !1
                      , qc = 0;
                    function Kl(s) {
                        s !== kc && s.next === null && (kc === null ? tr = kc = s : kc = kc.next = s),
                        __ = !0,
                        PS || (PS = !0,
                        P3())
                    }
                    function Xm(s, r) {
                        if (!VS && __) {
                            VS = !0;
                            do
                                for (var h = !1, m = tr; m !== null; ) {
                                    if (!r)
                                        if (s !== 0) {
                                            var x = m.pendingLanes;
                                            if (x === 0)
                                                var b = 0;
                                            else {
                                                var L = m.suspendedLanes
                                                  , W = m.pingedLanes;
                                                b = (1 << 31 - tt(42 | s) + 1) - 1,
                                                b &= x & ~(L & ~W),
                                                b = b & 201326741 ? b & 201326741 | 1 : b ? b | 2 : 0
                                            }
                                            b !== 0 && (h = !0,
                                            ST(m, b))
                                        } else
                                            b = Ut,
                                            b = mt(m, m === qt ? b : 0, m.cancelPendingCommit !== null || m.timeoutHandle !== -1),
                                            (b & 3) === 0 || Tt(m, b) || (h = !0,
                                            ST(m, b));
                                    m = m.next
                                }
                            while (h);
                            VS = !1
                        }
                    }
                    function B3() {
                        vT()
                    }
                    function vT() {
                        __ = PS = !1;
                        var s = 0;
                        qc !== 0 && W3() && (s = qc);
                        for (var r = he(), h = null, m = tr; m !== null; ) {
                            var x = m.next
                              , b = _T(m, r);
                            b === 0 ? (m.next = null,
                            h === null ? tr = x : h.next = x,
                            x === null && (kc = h)) : (h = m,
                            (s !== 0 || (b & 3) !== 0) && (__ = !0)),
                            m = x
                        }
                        qn !== 0 && qn !== 5 || Xm(s, !1),
                        qc !== 0 && (qc = 0)
                    }
                    function _T(s, r) {
                        for (var h = s.suspendedLanes, m = s.pingedLanes, x = s.expirationTimes, b = s.pendingLanes & -62914561; 0 < b; ) {
                            var L = 31 - tt(b)
                              , W = 1 << L
                              , ae = x[L];
                            ae === -1 ? ((W & h) === 0 || (W & m) !== 0) && (x[L] = si(W, r)) : ae <= r && (s.expiredLanes |= W),
                            b &= ~W
                        }
                        if (r = qt,
                        h = Ut,
                        h = mt(s, s === r ? h : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1),
                        m = s.callbackNode,
                        h === 0 || s === r && (Kt === 2 || Kt === 9) || s.cancelPendingCommit !== null)
                            return m !== null && m !== null && Nt(m),
                            s.callbackNode = null,
                            s.callbackPriority = 0;
                        if ((h & 3) === 0 || Tt(s, h)) {
                            if (r = h & -h,
                            r === s.callbackPriority)
                                return r;
                            switch (m !== null && Nt(m),
                            Ta(h)) {
                            case 2:
                            case 8:
                                h = Oe;
                                break;
                            case 32:
                                h = pt;
                                break;
                            case 268435456:
                                h = xt;
                                break;
                            default:
                                h = pt
                            }
                            return m = yT.bind(null, s),
                            h = ke(h, m),
                            s.callbackPriority = r,
                            s.callbackNode = h,
                            r
                        }
                        return m !== null && m !== null && Nt(m),
                        s.callbackPriority = 2,
                        s.callbackNode = null,
                        2
                    }
                    function yT(s, r) {
                        if (qn !== 0 && qn !== 5)
                            return s.callbackNode = null,
                            s.callbackPriority = 0,
                            null;
                        var h = s.callbackNode;
                        if (xe() && s.callbackNode !== h)
                            return null;
                        var m = Ut;
                        return m = mt(s, s === qt ? m : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1),
                        m === 0 ? null : (gh(s, m, r),
                        _T(s, he()),
                        s.callbackNode != null && s.callbackNode === h ? yT.bind(null, s) : null)
                    }
                    function ST(s, r) {
                        if (xe())
                            return null;
                        gh(s, r, !0)
                    }
                    function P3() {
                        j3(function() {
                            (An & 6) !== 0 ? ke(He, B3) : vT()
                        })
                    }
                    function FS() {
                        if (qc === 0) {
                            var s = Bl;
                            s === 0 && (s = Qe,
                            Qe <<= 1,
                            (Qe & 261888) === 0 && (Qe = 256)),
                            qc = s
                        }
                        return qc
                    }
                    function xT(s) {
                        return s == null || typeof s == "symbol" || typeof s == "boolean" ? null : typeof s == "function" ? s : Cu("" + s)
                    }
                    function MT(s, r) {
                        var h = r.ownerDocument.createElement("input");
                        return h.name = r.name,
                        h.value = r.value,
                        s.id && h.setAttribute("form", s.id),
                        r.parentNode.insertBefore(h, r),
                        s = new FormData(s),
                        h.parentNode.removeChild(h),
                        s
                    }
                    function V3(s, r, h, m, x) {
                        if (r === "submit" && h && h.stateNode === x) {
                            var b = xT((x[Oi] || null).action)
                              , L = m.submitter;
                            L && (r = (r = L[Oi] || null) ? xT(r.formAction) : L.getAttribute("formAction"),
                            r !== null && (b = r,
                            L = null));
                            var W = new Du("action","action",null,m,x);
                            s.push({
                                event: W,
                                listeners: [{
                                    instance: null,
                                    listener: function() {
                                        if (m.defaultPrevented) {
                                            if (qc !== 0) {
                                                var ae = L ? MT(x, L) : new FormData(x);
                                                Dm(h, {
                                                    pending: !0,
                                                    data: ae,
                                                    method: x.method,
                                                    action: b
                                                }, null, ae)
                                            }
                                        } else
                                            typeof b == "function" && (W.preventDefault(),
                                            ae = L ? MT(x, L) : new FormData(x),
                                            Dm(h, {
                                                pending: !0,
                                                data: ae,
                                                method: x.method,
                                                action: b
                                            }, b, ae))
                                    },
                                    currentTarget: x
                                }]
                            })
                        }
                    }
                    for (var HS = 0; HS < Pu.length; HS++) {
                        var GS = Pu[HS];
                        ri(GS.toLowerCase(), "on" + (GS[0].toUpperCase() + GS.slice(1)))
                    }
                    ri(Kp, "onAnimationEnd"),
                    ri(Ov, "onAnimationIteration"),
                    ri(Jp, "onAnimationStart"),
                    ri("dblclick", "onDoubleClick"),
                    ri("focusin", "onFocus"),
                    ri("focusout", "onBlur"),
                    ri(Uv, "onTransitionRun"),
                    ri(Xa, "onTransitionStart"),
                    ri($p, "onTransitionCancel"),
                    ri(em, "onTransitionEnd"),
                    st("onMouseEnter", ["mouseout", "mouseover"]),
                    st("onMouseLeave", ["mouseout", "mouseover"]),
                    st("onPointerEnter", ["pointerout", "pointerover"]),
                    st("onPointerLeave", ["pointerout", "pointerover"]),
                    Ye("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
                    Ye("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
                    Ye("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
                    Ye("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
                    Ye("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
                    Ye("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                    var Wm = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
                      , F3 = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Wm));
                    function bT(s, r) {
                        r = (r & 4) !== 0;
                        for (var h = 0; h < s.length; h++) {
                            var m = s[h]
                              , x = m.event;
                            m = m.listeners;
                            e: {
                                var b = void 0;
                                if (r)
                                    for (var L = m.length - 1; 0 <= L; L--) {
                                        var W = m[L]
                                          , ae = W.instance
                                          , be = W.currentTarget;
                                        if (W = W.listener,
                                        ae !== b && x.isPropagationStopped())
                                            break e;
                                        b = W,
                                        x.currentTarget = be;
                                        try {
                                            b(x)
                                        } catch (ze) {
                                            Vu(ze)
                                        }
                                        x.currentTarget = null,
                                        b = ae
                                    }
                                else
                                    for (L = 0; L < m.length; L++) {
                                        if (W = m[L],
                                        ae = W.instance,
                                        be = W.currentTarget,
                                        W = W.listener,
                                        ae !== b && x.isPropagationStopped())
                                            break e;
                                        b = W,
                                        x.currentTarget = be;
                                        try {
                                            b(x)
                                        } catch (ze) {
                                            Vu(ze)
                                        }
                                        x.currentTarget = null,
                                        b = ae
                                    }
                            }
                        }
                    }
                    function _n(s, r) {
                        var h = r[bl];
                        h === void 0 && (h = r[bl] = new Set);
                        var m = s + "__bubble";
                        h.has(m) || (AT(r, s, 2, !1),
                        h.add(m))
                    }
                    function kS(s, r, h) {
                        var m = 0;
                        r && (m |= 4),
                        AT(h, s, m, r)
                    }
                    var y_ = "_reactListening" + Math.random().toString(36).slice(2);
                    function TT(s) {
                        if (!s[y_]) {
                            s[y_] = !0,
                            Se.forEach(function(h) {
                                h !== "selectionchange" && (F3.has(h) || kS(h, !1, s),
                                kS(h, !0, s))
                            });
                            var r = s.nodeType === 9 ? s : s.ownerDocument;
                            r === null || r[y_] || (r[y_] = !0,
                            kS("selectionchange", !1, r))
                        }
                    }
                    function AT(s, r, h, m) {
                        switch (JT(r)) {
                        case 2:
                            var x = gN;
                            break;
                        case 8:
                            x = vN;
                            break;
                        default:
                            x = sx
                        }
                        h = x.bind(null, r, h, s),
                        x = void 0,
                        !uf || r !== "touchstart" && r !== "touchmove" && r !== "wheel" || (x = !0),
                        m ? x !== void 0 ? s.addEventListener(r, h, {
                            capture: !0,
                            passive: x
                        }) : s.addEventListener(r, h, !0) : x !== void 0 ? s.addEventListener(r, h, {
                            passive: x
                        }) : s.addEventListener(r, h, !1)
                    }
                    function qS(s, r, h, m, x) {
                        var b = m;
                        if ((r & 1) === 0 && (r & 2) === 0 && m !== null)
                            e: for (; ; ) {
                                if (m === null)
                                    return;
                                var L = m.tag;
                                if (L === 3 || L === 4) {
                                    var W = m.stateNode.containerInfo;
                                    if (W === x)
                                        break;
                                    if (L === 4)
                                        for (L = m.return; L !== null; ) {
                                            var ae = L.tag;
                                            if ((ae === 3 || ae === 4) && L.stateNode.containerInfo === x)
                                                return;
                                            L = L.return
                                        }
                                    for (; W !== null; ) {
                                        if (L = yi(W),
                                        L === null)
                                            return;
                                        if (ae = L.tag,
                                        ae === 5 || ae === 6 || ae === 26 || ae === 27) {
                                            m = b = L;
                                            continue e
                                        }
                                        W = W.parentNode
                                    }
                                }
                                m = m.return
                            }
                        Ip(function() {
                            var be = b
                              , ze = lf(h)
                              , Fe = [];
                            e: {
                                var Ee = Lv.get(s);
                                if (Ee !== void 0) {
                                    var Ne = Du
                                      , yt = s;
                                    switch (s) {
                                    case "keypress":
                                        if (Cl(h) === 0)
                                            break e;
                                    case "keydown":
                                    case "keyup":
                                        Ne = Mv;
                                        break;
                                    case "focusin":
                                        yt = "focus",
                                        Ne = mf;
                                        break;
                                    case "focusout":
                                        yt = "blur",
                                        Ne = mf;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        Ne = mf;
                                        break;
                                    case "click":
                                        if (h.button === 2)
                                            break e;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        Ne = vv;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        Ne = ts;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        Ne = Vp;
                                        break;
                                    case Kp:
                                    case Ov:
                                    case Jp:
                                        Ne = _v;
                                        break;
                                    case em:
                                        Ne = bv;
                                        break;
                                    case "scroll":
                                    case "scrollend":
                                        Ne = df;
                                        break;
                                    case "wheel":
                                        Ne = Fp;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        Ne = yv;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        Ne = vf;
                                        break;
                                    case "toggle":
                                    case "beforetoggle":
                                        Ne = Hp
                                    }
                                    var Pt = (r & 4) !== 0
                                      , Qn = !Pt && (s === "scroll" || s === "scrollend")
                                      , de = Pt ? Ee !== null ? Ee + "Capture" : null : Ee;
                                    Pt = [];
                                    for (var re = be, ye; re !== null; ) {
                                        var Pe = re;
                                        if (ye = Pe.stateNode,
                                        Pe = Pe.tag,
                                        Pe !== 5 && Pe !== 26 && Pe !== 27 || ye === null || de === null || (Pe = El(re, de),
                                        Pe != null && Pt.push(Ym(re, Pe, ye))),
                                        Qn)
                                            break;
                                        re = re.return
                                    }
                                    0 < Pt.length && (Ee = new Ne(Ee,yt,null,h,ze),
                                    Fe.push({
                                        event: Ee,
                                        listeners: Pt
                                    }))
                                }
                            }
                            if ((r & 7) === 0) {
                                e: {
                                    if (Ee = s === "mouseover" || s === "pointerover",
                                    Ne = s === "mouseout" || s === "pointerout",
                                    Ee && h !== wu && (yt = h.relatedTarget || h.fromElement) && (yi(yt) || yt[Aa]))
                                        break e;
                                    if ((Ne || Ee) && (Ee = ze.window === ze ? ze : (Ee = ze.ownerDocument) ? Ee.defaultView || Ee.parentWindow : window,
                                    Ne ? (yt = h.relatedTarget || h.toElement,
                                    Ne = be,
                                    yt = yt ? yi(yt) : null,
                                    yt !== null && (Qn = u(yt),
                                    Pt = yt.tag,
                                    yt !== Qn || Pt !== 5 && Pt !== 27 && Pt !== 6) && (yt = null)) : (Ne = null,
                                    yt = be),
                                    Ne !== yt)) {
                                        if (Pt = vv,
                                        Pe = "onMouseLeave",
                                        de = "onMouseEnter",
                                        re = "mouse",
                                        (s === "pointerout" || s === "pointerover") && (Pt = vf,
                                        Pe = "onPointerLeave",
                                        de = "onPointerEnter",
                                        re = "pointer"),
                                        Qn = Ne == null ? Ee : Y(Ne),
                                        ye = yt == null ? Ee : Y(yt),
                                        Ee = new Pt(Pe,re + "leave",Ne,h,ze),
                                        Ee.target = Qn,
                                        Ee.relatedTarget = ye,
                                        Pe = null,
                                        yi(ze) === be && (Pt = new Pt(de,re + "enter",yt,h,ze),
                                        Pt.target = ye,
                                        Pt.relatedTarget = Qn,
                                        Pe = Pt),
                                        Qn = Pe,
                                        Ne && yt)
                                            t: {
                                                for (Pt = H3,
                                                de = Ne,
                                                re = yt,
                                                ye = 0,
                                                Pe = de; Pe; Pe = Pt(Pe))
                                                    ye++;
                                                Pe = 0;
                                                for (var Lt = re; Lt; Lt = Pt(Lt))
                                                    Pe++;
                                                for (; 0 < ye - Pe; )
                                                    de = Pt(de),
                                                    ye--;
                                                for (; 0 < Pe - ye; )
                                                    re = Pt(re),
                                                    Pe--;
                                                for (; ye--; ) {
                                                    if (de === re || re !== null && de === re.alternate) {
                                                        Pt = de;
                                                        break t
                                                    }
                                                    de = Pt(de),
                                                    re = Pt(re)
                                                }
                                                Pt = null
                                            }
                                        else
                                            Pt = null;
                                        Ne !== null && ET(Fe, Ee, Ne, Pt, !1),
                                        yt !== null && Qn !== null && ET(Fe, Qn, yt, Pt, !0)
                                    }
                                }
                                e: {
                                    if (Ee = be ? Y(be) : window,
                                    Ne = Ee.nodeName && Ee.nodeName.toLowerCase(),
                                    Ne === "select" || Ne === "input" && Ee.type === "file")
                                        var Dn = xc;
                                    else if (zu(Ee))
                                        if (Sf)
                                            Dn = jp;
                                        else {
                                            Dn = wv;
                                            var Mt = Cv
                                        }
                                    else
                                        Ne = Ee.nodeName,
                                        !Ne || Ne.toLowerCase() !== "input" || Ee.type !== "checkbox" && Ee.type !== "radio" ? be && Eu(be.elementType) && (Dn = xc) : Dn = Yp;
                                    if (Dn && (Dn = Dn(s, be))) {
                                        Uo(Fe, Dn, h, ze);
                                        break e
                                    }
                                    Mt && Mt(s, Ee, be),
                                    s === "focusout" && be && Ee.type === "number" && be.memoizedProps.value != null && wn(Ee, "number", Ee.value)
                                }
                                switch (Mt = be ? Y(be) : window,
                                s) {
                                case "focusin":
                                    (zu(Mt) || Mt.contentEditable === "true") && (Nl = Mt,
                                    bf = be,
                                    qa = null);
                                    break;
                                case "focusout":
                                    qa = bf = Nl = null;
                                    break;
                                case "mousedown":
                                    Ss = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    Ss = !1,
                                    Qp(Fe, h, ze);
                                    break;
                                case "selectionchange":
                                    if (Io)
                                        break;
                                case "keydown":
                                case "keyup":
                                    Qp(Fe, h, ze)
                                }
                                var nn;
                                if (_f)
                                    e: {
                                        switch (s) {
                                        case "compositionstart":
                                            var Sn = "onCompositionStart";
                                            break e;
                                        case "compositionend":
                                            Sn = "onCompositionEnd";
                                            break e;
                                        case "compositionupdate":
                                            Sn = "onCompositionUpdate";
                                            break e
                                        }
                                        Sn = void 0
                                    }
                                else
                                    Ds ? kp(s, h) && (Sn = "onCompositionEnd") : s === "keydown" && h.keyCode === 229 && (Sn = "onCompositionStart");
                                Sn && (fr && h.locale !== "ko" && (Ds || Sn !== "onCompositionStart" ? Sn === "onCompositionEnd" && Ds && (nn = ff()) : (No = ze,
                                hf = "value"in No ? No.value : No.textContent,
                                Ds = !0)),
                                Mt = S_(be, Sn),
                                0 < Mt.length && (Sn = new Bp(Sn,s,null,h,ze),
                                Fe.push({
                                    event: Sn,
                                    listeners: Mt
                                }),
                                nn ? Sn.data = nn : (nn = qr(h),
                                nn !== null && (Sn.data = nn)))),
                                (nn = Tv ? qp(s, h) : Xp(s, h)) && (Sn = S_(be, "onBeforeInput"),
                                0 < Sn.length && (Mt = new Bp("onBeforeInput","beforeinput",null,h,ze),
                                Fe.push({
                                    event: Mt,
                                    listeners: Sn
                                }),
                                Mt.data = nn)),
                                V3(Fe, s, be, h, ze)
                            }
                            bT(Fe, r)
                        })
                    }
                    function Ym(s, r, h) {
                        return {
                            instance: s,
                            listener: r,
                            currentTarget: h
                        }
                    }
                    function S_(s, r) {
                        for (var h = r + "Capture", m = []; s !== null; ) {
                            var x = s
                              , b = x.stateNode;
                            if (x = x.tag,
                            x !== 5 && x !== 26 && x !== 27 || b === null || (x = El(s, h),
                            x != null && m.unshift(Ym(s, x, b)),
                            x = El(s, r),
                            x != null && m.push(Ym(s, x, b))),
                            s.tag === 3)
                                return m;
                            s = s.return
                        }
                        return []
                    }
                    function H3(s) {
                        if (s === null)
                            return null;
                        do
                            s = s.return;
                        while (s && s.tag !== 5 && s.tag !== 27);
                        return s || null
                    }
                    function ET(s, r, h, m, x) {
                        for (var b = r._reactName, L = []; h !== null && h !== m; ) {
                            var W = h
                              , ae = W.alternate
                              , be = W.stateNode;
                            if (W = W.tag,
                            ae !== null && ae === m)
                                break;
                            W !== 5 && W !== 26 && W !== 27 || be === null || (ae = be,
                            x ? (be = El(h, b),
                            be != null && L.unshift(Ym(h, be, ae))) : x || (be = El(h, b),
                            be != null && L.push(Ym(h, be, ae)))),
                            h = h.return
                        }
                        L.length !== 0 && s.push({
                            event: r,
                            listeners: L
                        })
                    }
                    var G3 = /\r\n?/g
                      , k3 = /\u0000|\uFFFD/g;
                    function CT(s) {
                        return (typeof s == "string" ? s : "" + s).replace(G3, `
`).replace(k3, "")
                    }
                    function wT(s, r) {
                        return r = CT(r),
                        CT(s) === r
                    }
                    function Zn(s, r, h, m, x, b) {
                        switch (h) {
                        case "children":
                            typeof m == "string" ? r === "body" || r === "textarea" && m === "" || Ui(s, m) : (typeof m == "number" || typeof m == "bigint") && r !== "body" && Ui(s, "" + m);
                            break;
                        case "className":
                            tn(s, "class", m);
                            break;
                        case "tabIndex":
                            tn(s, "tabindex", m);
                            break;
                        case "dir":
                        case "role":
                        case "viewBox":
                        case "width":
                        case "height":
                            tn(s, h, m);
                            break;
                        case "style":
                            Up(s, m, b);
                            break;
                        case "data":
                            if (r !== "object") {
                                tn(s, "data", m);
                                break
                            }
                        case "src":
                        case "href":
                            if (m === "" && (r !== "a" || h !== "href")) {
                                s.removeAttribute(h);
                                break
                            }
                            if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
                                s.removeAttribute(h);
                                break
                            }
                            m = Cu("" + m),
                            s.setAttribute(h, m);
                            break;
                        case "action":
                        case "formAction":
                            if (typeof m == "function") {
                                s.setAttribute(h, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                                break
                            } else
                                typeof b == "function" && (h === "formAction" ? (r !== "input" && Zn(s, r, "name", x.name, x, null),
                                Zn(s, r, "formEncType", x.formEncType, x, null),
                                Zn(s, r, "formMethod", x.formMethod, x, null),
                                Zn(s, r, "formTarget", x.formTarget, x, null)) : (Zn(s, r, "encType", x.encType, x, null),
                                Zn(s, r, "method", x.method, x, null),
                                Zn(s, r, "target", x.target, x, null)));
                            if (m == null || typeof m == "symbol" || typeof m == "boolean") {
                                s.removeAttribute(h);
                                break
                            }
                            m = Cu("" + m),
                            s.setAttribute(h, m);
                            break;
                        case "onClick":
                            m != null && (s.onclick = ur);
                            break;
                        case "onScroll":
                            m != null && _n("scroll", s);
                            break;
                        case "onScrollEnd":
                            m != null && _n("scrollend", s);
                            break;
                        case "dangerouslySetInnerHTML":
                            if (m != null) {
                                if (typeof m != "object" || !("__html"in m))
                                    throw Error(a(61));
                                if (h = m.__html,
                                h != null) {
                                    if (x.children != null)
                                        throw Error(a(60));
                                    s.innerHTML = h
                                }
                            }
                            break;
                        case "multiple":
                            s.multiple = m && typeof m != "function" && typeof m != "symbol";
                            break;
                        case "muted":
                            s.muted = m && typeof m != "function" && typeof m != "symbol";
                            break;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "defaultValue":
                        case "defaultChecked":
                        case "innerHTML":
                        case "ref":
                            break;
                        case "autoFocus":
                            break;
                        case "xlinkHref":
                            if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
                                s.removeAttribute("xlink:href");
                                break
                            }
                            h = Cu("" + m),
                            s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", h);
                            break;
                        case "contentEditable":
                        case "spellCheck":
                        case "draggable":
                        case "value":
                        case "autoReverse":
                        case "externalResourcesRequired":
                        case "focusable":
                        case "preserveAlpha":
                            m != null && typeof m != "function" && typeof m != "symbol" ? s.setAttribute(h, "" + m) : s.removeAttribute(h);
                            break;
                        case "inert":
                        case "allowFullScreen":
                        case "async":
                        case "autoPlay":
                        case "controls":
                        case "default":
                        case "defer":
                        case "disabled":
                        case "disablePictureInPicture":
                        case "disableRemotePlayback":
                        case "formNoValidate":
                        case "hidden":
                        case "loop":
                        case "noModule":
                        case "noValidate":
                        case "open":
                        case "playsInline":
                        case "readOnly":
                        case "required":
                        case "reversed":
                        case "scoped":
                        case "seamless":
                        case "itemScope":
                            m && typeof m != "function" && typeof m != "symbol" ? s.setAttribute(h, "") : s.removeAttribute(h);
                            break;
                        case "capture":
                        case "download":
                            m === !0 ? s.setAttribute(h, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? s.setAttribute(h, m) : s.removeAttribute(h);
                            break;
                        case "cols":
                        case "rows":
                        case "size":
                        case "span":
                            m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? s.setAttribute(h, m) : s.removeAttribute(h);
                            break;
                        case "rowSpan":
                        case "start":
                            m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? s.removeAttribute(h) : s.setAttribute(h, m);
                            break;
                        case "popover":
                            _n("beforetoggle", s),
                            _n("toggle", s),
                            wt(s, "popover", m);
                            break;
                        case "xlinkActuate":
                            rn(s, "http://www.w3.org/1999/xlink", "xlink:actuate", m);
                            break;
                        case "xlinkArcrole":
                            rn(s, "http://www.w3.org/1999/xlink", "xlink:arcrole", m);
                            break;
                        case "xlinkRole":
                            rn(s, "http://www.w3.org/1999/xlink", "xlink:role", m);
                            break;
                        case "xlinkShow":
                            rn(s, "http://www.w3.org/1999/xlink", "xlink:show", m);
                            break;
                        case "xlinkTitle":
                            rn(s, "http://www.w3.org/1999/xlink", "xlink:title", m);
                            break;
                        case "xlinkType":
                            rn(s, "http://www.w3.org/1999/xlink", "xlink:type", m);
                            break;
                        case "xmlBase":
                            rn(s, "http://www.w3.org/XML/1998/namespace", "xml:base", m);
                            break;
                        case "xmlLang":
                            rn(s, "http://www.w3.org/XML/1998/namespace", "xml:lang", m);
                            break;
                        case "xmlSpace":
                            rn(s, "http://www.w3.org/XML/1998/namespace", "xml:space", m);
                            break;
                        case "is":
                            wt(s, "is", m);
                            break;
                        case "innerText":
                        case "textContent":
                            break;
                        default:
                            (!(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (h = mv.get(h) || h,
                            wt(s, h, m))
                        }
                    }
                    function XS(s, r, h, m, x, b) {
                        switch (h) {
                        case "style":
                            Up(s, m, b);
                            break;
                        case "dangerouslySetInnerHTML":
                            if (m != null) {
                                if (typeof m != "object" || !("__html"in m))
                                    throw Error(a(61));
                                if (h = m.__html,
                                h != null) {
                                    if (x.children != null)
                                        throw Error(a(60));
                                    s.innerHTML = h
                                }
                            }
                            break;
                        case "children":
                            typeof m == "string" ? Ui(s, m) : (typeof m == "number" || typeof m == "bigint") && Ui(s, "" + m);
                            break;
                        case "onScroll":
                            m != null && _n("scroll", s);
                            break;
                        case "onScrollEnd":
                            m != null && _n("scrollend", s);
                            break;
                        case "onClick":
                            m != null && (s.onclick = ur);
                            break;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "innerHTML":
                        case "ref":
                            break;
                        case "innerText":
                        case "textContent":
                            break;
                        default:
                            if (!me.hasOwnProperty(h))
                                e: {
                                    if (h[0] === "o" && h[1] === "n" && (x = h.endsWith("Capture"),
                                    r = h.slice(2, x ? h.length - 7 : void 0),
                                    b = s[Oi] || null,
                                    b = b != null ? b[h] : null,
                                    typeof b == "function" && s.removeEventListener(r, b, x),
                                    typeof m == "function")) {
                                        typeof b != "function" && b !== null && (h in s ? s[h] = null : s.hasAttribute(h) && s.removeAttribute(h)),
                                        s.addEventListener(r, m, x);
                                        break e
                                    }
                                    h in s ? s[h] = m : m === !0 ? s.setAttribute(h, "") : wt(s, h, m)
                                }
                        }
                    }
                    function Ts(s, r, h) {
                        switch (r) {
                        case "div":
                        case "span":
                        case "svg":
                        case "path":
                        case "a":
                        case "g":
                        case "p":
                        case "li":
                            break;
                        case "img":
                            _n("error", s),
                            _n("load", s);
                            var m = !1, x = !1, b;
                            for (b in h)
                                if (h.hasOwnProperty(b)) {
                                    var L = h[b];
                                    if (L != null)
                                        switch (b) {
                                        case "src":
                                            m = !0;
                                            break;
                                        case "srcSet":
                                            x = !0;
                                            break;
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            throw Error(a(137, r));
                                        default:
                                            Zn(s, r, b, L, h, null)
                                        }
                                }
                            x && Zn(s, r, "srcSet", h.srcSet, h, null),
                            m && Zn(s, r, "src", h.src, h, null);
                            return;
                        case "input":
                            _n("invalid", s);
                            var W = b = L = x = null
                              , ae = null
                              , be = null;
                            for (m in h)
                                if (h.hasOwnProperty(m)) {
                                    var ze = h[m];
                                    if (ze != null)
                                        switch (m) {
                                        case "name":
                                            x = ze;
                                            break;
                                        case "type":
                                            L = ze;
                                            break;
                                        case "checked":
                                            ae = ze;
                                            break;
                                        case "defaultChecked":
                                            be = ze;
                                            break;
                                        case "value":
                                            b = ze;
                                            break;
                                        case "defaultValue":
                                            W = ze;
                                            break;
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            if (ze != null)
                                                throw Error(a(137, r));
                                            break;
                                        default:
                                            Zn(s, r, m, ze, h, null)
                                        }
                                }
                            kr(s, b, W, ae, be, L, x, !1);
                            return;
                        case "select":
                            _n("invalid", s),
                            m = L = b = null;
                            for (x in h)
                                if (h.hasOwnProperty(x) && (W = h[x],
                                W != null))
                                    switch (x) {
                                    case "value":
                                        b = W;
                                        break;
                                    case "defaultValue":
                                        L = W;
                                        break;
                                    case "multiple":
                                        m = W;
                                    default:
                                        Zn(s, r, x, W, h, null)
                                    }
                            r = b,
                            h = L,
                            s.multiple = !!m,
                            r != null ? Si(s, !!m, r, !1) : h != null && Si(s, !!m, h, !0);
                            return;
                        case "textarea":
                            _n("invalid", s),
                            b = x = m = null;
                            for (L in h)
                                if (h.hasOwnProperty(L) && (W = h[L],
                                W != null))
                                    switch (L) {
                                    case "value":
                                        m = W;
                                        break;
                                    case "defaultValue":
                                        x = W;
                                        break;
                                    case "children":
                                        b = W;
                                        break;
                                    case "dangerouslySetInnerHTML":
                                        if (W != null)
                                            throw Error(a(91));
                                        break;
                                    default:
                                        Zn(s, r, L, W, h, null)
                                    }
                            ei(s, m, x, b);
                            return;
                        case "option":
                            for (ae in h)
                                h.hasOwnProperty(ae) && (m = h[ae],
                                m != null) && (ae === "selected" ? s.selected = m && typeof m != "function" && typeof m != "symbol" : Zn(s, r, ae, m, h, null));
                            return;
                        case "dialog":
                            _n("beforetoggle", s),
                            _n("toggle", s),
                            _n("cancel", s),
                            _n("close", s);
                            break;
                        case "iframe":
                        case "object":
                            _n("load", s);
                            break;
                        case "video":
                        case "audio":
                            for (m = 0; m < Wm.length; m++)
                                _n(Wm[m], s);
                            break;
                        case "image":
                            _n("error", s),
                            _n("load", s);
                            break;
                        case "details":
                            _n("toggle", s);
                            break;
                        case "embed":
                        case "source":
                        case "link":
                            _n("error", s),
                            _n("load", s);
                        case "area":
                        case "base":
                        case "br":
                        case "col":
                        case "hr":
                        case "keygen":
                        case "meta":
                        case "param":
                        case "track":
                        case "wbr":
                        case "menuitem":
                            for (be in h)
                                if (h.hasOwnProperty(be) && (m = h[be],
                                m != null))
                                    switch (be) {
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        throw Error(a(137, r));
                                    default:
                                        Zn(s, r, be, m, h, null)
                                    }
                            return;
                        default:
                            if (Eu(r)) {
                                for (ze in h)
                                    h.hasOwnProperty(ze) && (m = h[ze],
                                    m !== void 0 && XS(s, r, ze, m, h, void 0));
                                return
                            }
                        }
                        for (W in h)
                            h.hasOwnProperty(W) && (m = h[W],
                            m != null && Zn(s, r, W, m, h, null))
                    }
                    function q3(s, r, h, m) {
                        switch (r) {
                        case "div":
                        case "span":
                        case "svg":
                        case "path":
                        case "a":
                        case "g":
                        case "p":
                        case "li":
                            break;
                        case "input":
                            var x = null
                              , b = null
                              , L = null
                              , W = null
                              , ae = null
                              , be = null
                              , ze = null;
                            for (Ne in h) {
                                var Fe = h[Ne];
                                if (h.hasOwnProperty(Ne) && Fe != null)
                                    switch (Ne) {
                                    case "checked":
                                        break;
                                    case "value":
                                        break;
                                    case "defaultValue":
                                        ae = Fe;
                                    default:
                                        m.hasOwnProperty(Ne) || Zn(s, r, Ne, null, m, Fe)
                                    }
                            }
                            for (var Ee in m) {
                                var Ne = m[Ee];
                                if (Fe = h[Ee],
                                m.hasOwnProperty(Ee) && (Ne != null || Fe != null))
                                    switch (Ee) {
                                    case "type":
                                        b = Ne;
                                        break;
                                    case "name":
                                        x = Ne;
                                        break;
                                    case "checked":
                                        be = Ne;
                                        break;
                                    case "defaultChecked":
                                        ze = Ne;
                                        break;
                                    case "value":
                                        L = Ne;
                                        break;
                                    case "defaultValue":
                                        W = Ne;
                                        break;
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        if (Ne != null)
                                            throw Error(a(137, r));
                                        break;
                                    default:
                                        Ne !== Fe && Zn(s, r, Ee, Ne, m, Fe)
                                    }
                            }
                            qi(s, L, W, ae, be, ze, b, x);
                            return;
                        case "select":
                            Ne = L = W = Ee = null;
                            for (b in h)
                                if (ae = h[b],
                                h.hasOwnProperty(b) && ae != null)
                                    switch (b) {
                                    case "value":
                                        break;
                                    case "multiple":
                                        Ne = ae;
                                    default:
                                        m.hasOwnProperty(b) || Zn(s, r, b, null, m, ae)
                                    }
                            for (x in m)
                                if (b = m[x],
                                ae = h[x],
                                m.hasOwnProperty(x) && (b != null || ae != null))
                                    switch (x) {
                                    case "value":
                                        Ee = b;
                                        break;
                                    case "defaultValue":
                                        W = b;
                                        break;
                                    case "multiple":
                                        L = b;
                                    default:
                                        b !== ae && Zn(s, r, x, b, m, ae)
                                    }
                            r = W,
                            h = L,
                            m = Ne,
                            Ee != null ? Si(s, !!h, Ee, !1) : !!m != !!h && (r != null ? Si(s, !!h, r, !0) : Si(s, !!h, h ? [] : "", !1));
                            return;
                        case "textarea":
                            Ne = Ee = null;
                            for (W in h)
                                if (x = h[W],
                                h.hasOwnProperty(W) && x != null && !m.hasOwnProperty(W))
                                    switch (W) {
                                    case "value":
                                        break;
                                    case "children":
                                        break;
                                    default:
                                        Zn(s, r, W, null, m, x)
                                    }
                            for (L in m)
                                if (x = m[L],
                                b = h[L],
                                m.hasOwnProperty(L) && (x != null || b != null))
                                    switch (L) {
                                    case "value":
                                        Ee = x;
                                        break;
                                    case "defaultValue":
                                        Ne = x;
                                        break;
                                    case "children":
                                        break;
                                    case "dangerouslySetInnerHTML":
                                        if (x != null)
                                            throw Error(a(91));
                                        break;
                                    default:
                                        x !== b && Zn(s, r, L, x, m, b)
                                    }
                            us(s, Ee, Ne);
                            return;
                        case "option":
                            for (var yt in h)
                                Ee = h[yt],
                                h.hasOwnProperty(yt) && Ee != null && !m.hasOwnProperty(yt) && (yt === "selected" ? s.selected = !1 : Zn(s, r, yt, null, m, Ee));
                            for (ae in m)
                                Ee = m[ae],
                                Ne = h[ae],
                                m.hasOwnProperty(ae) && Ee !== Ne && (Ee != null || Ne != null) && (ae === "selected" ? s.selected = Ee && typeof Ee != "function" && typeof Ee != "symbol" : Zn(s, r, ae, Ee, m, Ne));
                            return;
                        case "img":
                        case "link":
                        case "area":
                        case "base":
                        case "br":
                        case "col":
                        case "embed":
                        case "hr":
                        case "keygen":
                        case "meta":
                        case "param":
                        case "source":
                        case "track":
                        case "wbr":
                        case "menuitem":
                            for (var Pt in h)
                                Ee = h[Pt],
                                h.hasOwnProperty(Pt) && Ee != null && !m.hasOwnProperty(Pt) && Zn(s, r, Pt, null, m, Ee);
                            for (be in m)
                                if (Ee = m[be],
                                Ne = h[be],
                                m.hasOwnProperty(be) && Ee !== Ne && (Ee != null || Ne != null))
                                    switch (be) {
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        if (Ee != null)
                                            throw Error(a(137, r));
                                        break;
                                    default:
                                        Zn(s, r, be, Ee, m, Ne)
                                    }
                            return;
                        default:
                            if (Eu(r)) {
                                for (var Qn in h)
                                    Ee = h[Qn],
                                    h.hasOwnProperty(Qn) && Ee !== void 0 && !m.hasOwnProperty(Qn) && XS(s, r, Qn, void 0, m, Ee);
                                for (ze in m)
                                    Ee = m[ze],
                                    Ne = h[ze],
                                    !m.hasOwnProperty(ze) || Ee === Ne || Ee === void 0 && Ne === void 0 || XS(s, r, ze, Ee, m, Ne);
                                return
                            }
                        }
                        for (var de in h)
                            Ee = h[de],
                            h.hasOwnProperty(de) && Ee != null && !m.hasOwnProperty(de) && Zn(s, r, de, null, m, Ee);
                        for (Fe in m)
                            Ee = m[Fe],
                            Ne = h[Fe],
                            !m.hasOwnProperty(Fe) || Ee === Ne || Ee == null && Ne == null || Zn(s, r, Fe, Ee, m, Ne)
                    }
                    function RT(s) {
                        switch (s) {
                        case "css":
                        case "script":
                        case "font":
                        case "img":
                        case "image":
                        case "input":
                        case "link":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    function X3() {
                        if (typeof performance.getEntriesByType == "function") {
                            for (var s = 0, r = 0, h = performance.getEntriesByType("resource"), m = 0; m < h.length; m++) {
                                var x = h[m]
                                  , b = x.transferSize
                                  , L = x.initiatorType
                                  , W = x.duration;
                                if (b && W && RT(L)) {
                                    for (L = 0,
                                    W = x.responseEnd,
                                    m += 1; m < h.length; m++) {
                                        var ae = h[m]
                                          , be = ae.startTime;
                                        if (be > W)
                                            break;
                                        var ze = ae.transferSize
                                          , Fe = ae.initiatorType;
                                        ze && RT(Fe) && (ae = ae.responseEnd,
                                        L += ze * (ae < W ? 1 : (W - be) / (ae - be)))
                                    }
                                    if (--m,
                                    r += 8 * (b + L) / (x.duration / 1e3),
                                    s++,
                                    10 < s)
                                        break
                                }
                            }
                            if (0 < s)
                                return r / s / 1e6
                        }
                        return navigator.connection && (s = navigator.connection.downlink,
                        typeof s == "number") ? s : 5
                    }
                    var WS = null
                      , YS = null;
                    function x_(s) {
                        return s.nodeType === 9 ? s : s.ownerDocument
                    }
                    function NT(s) {
                        switch (s) {
                        case "http://www.w3.org/2000/svg":
                            return 1;
                        case "http://www.w3.org/1998/Math/MathML":
                            return 2;
                        default:
                            return 0
                        }
                    }
                    function DT(s, r) {
                        if (s === 0)
                            switch (r) {
                            case "svg":
                                return 1;
                            case "math":
                                return 2;
                            default:
                                return 0
                            }
                        return s === 1 && r === "foreignObject" ? 0 : s
                    }
                    function jS(s, r) {
                        return s === "textarea" || s === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.children == "bigint" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null
                    }
                    var ZS = null;
                    function W3() {
                        var s = window.event;
                        return s && s.type === "popstate" ? s === ZS ? !1 : (ZS = s,
                        !0) : (ZS = null,
                        !1)
                    }
                    var OT = typeof setTimeout == "function" ? setTimeout : void 0
                      , Y3 = typeof clearTimeout == "function" ? clearTimeout : void 0
                      , UT = typeof Promise == "function" ? Promise : void 0
                      , j3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof UT < "u" ? function(s) {
                        return UT.resolve(null).then(s).catch(Z3)
                    }
                    : OT;
                    function Z3(s) {
                        setTimeout(function() {
                            throw s
                        })
                    }
                    function Xc(s) {
                        return s === "head"
                    }
                    function LT(s, r) {
                        var h = r
                          , m = 0;
                        do {
                            var x = h.nextSibling;
                            if (s.removeChild(h),
                            x && x.nodeType === 8)
                                if (h = x.data,
                                h === "/$" || h === "/&") {
                                    if (m === 0) {
                                        s.removeChild(x),
                                        yd(r);
                                        return
                                    }
                                    m--
                                } else if (h === "$" || h === "$?" || h === "$~" || h === "$!" || h === "&")
                                    m++;
                                else if (h === "html")
                                    jm(s.ownerDocument.documentElement);
                                else if (h === "head") {
                                    h = s.ownerDocument.head,
                                    jm(h);
                                    for (var b = h.firstChild; b; ) {
                                        var L = b.nextSibling
                                          , W = b.nodeName;
                                        b[Gr] || W === "SCRIPT" || W === "STYLE" || W === "LINK" && b.rel.toLowerCase() === "stylesheet" || h.removeChild(b),
                                        b = L
                                    }
                                } else
                                    h === "body" && jm(s.ownerDocument.body);
                            h = x
                        } while (h);
                        yd(r)
                    }
                    function IT(s, r) {
                        var h = s;
                        s = 0;
                        do {
                            var m = h.nextSibling;
                            if (h.nodeType === 1 ? r ? (h._stashedDisplay = h.style.display,
                            h.style.display = "none") : (h.style.display = h._stashedDisplay || "",
                            h.getAttribute("style") === "" && h.removeAttribute("style")) : h.nodeType === 3 && (r ? (h._stashedText = h.nodeValue,
                            h.nodeValue = "") : h.nodeValue = h._stashedText || ""),
                            m && m.nodeType === 8)
                                if (h = m.data,
                                h === "/$") {
                                    if (s === 0)
                                        break;
                                    s--
                                } else
                                    h !== "$" && h !== "$?" && h !== "$~" && h !== "$!" || s++;
                            h = m
                        } while (h)
                    }
                    function QS(s) {
                        var r = s.firstChild;
                        for (r && r.nodeType === 10 && (r = r.nextSibling); r; ) {
                            var h = r;
                            switch (r = r.nextSibling,
                            h.nodeName) {
                            case "HTML":
                            case "HEAD":
                            case "BODY":
                                QS(h),
                                Tl(h);
                                continue;
                            case "SCRIPT":
                            case "STYLE":
                                continue;
                            case "LINK":
                                if (h.rel.toLowerCase() === "stylesheet")
                                    continue
                            }
                            s.removeChild(h)
                        }
                    }
                    function Q3(s, r, h, m) {
                        for (; s.nodeType === 1; ) {
                            var x = h;
                            if (s.nodeName.toLowerCase() !== r.toLowerCase()) {
                                if (!m && (s.nodeName !== "INPUT" || s.type !== "hidden"))
                                    break
                            } else if (m) {
                                if (!s[Gr])
                                    switch (r) {
                                    case "meta":
                                        if (!s.hasAttribute("itemprop"))
                                            break;
                                        return s;
                                    case "link":
                                        if (b = s.getAttribute("rel"),
                                        b === "stylesheet" && s.hasAttribute("data-precedence"))
                                            break;
                                        if (b !== x.rel || s.getAttribute("href") !== (x.href == null || x.href === "" ? null : x.href) || s.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin) || s.getAttribute("title") !== (x.title == null ? null : x.title))
                                            break;
                                        return s;
                                    case "style":
                                        if (s.hasAttribute("data-precedence"))
                                            break;
                                        return s;
                                    case "script":
                                        if (b = s.getAttribute("src"),
                                        (b !== (x.src == null ? null : x.src) || s.getAttribute("type") !== (x.type == null ? null : x.type) || s.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin)) && b && s.hasAttribute("async") && !s.hasAttribute("itemprop"))
                                            break;
                                        return s;
                                    default:
                                        return s
                                    }
                            } else if (r === "input" && s.type === "hidden") {
                                var b = x.name == null ? null : "" + x.name;
                                if (x.type === "hidden" && s.getAttribute("name") === b)
                                    return s
                            } else
                                return s;
                            if (s = Or(s.nextSibling),
                            s === null)
                                break
                        }
                        return null
                    }
                    function K3(s, r, h) {
                        if (r === "")
                            return null;
                        for (; s.nodeType !== 3; )
                            if ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") && !h || (s = Or(s.nextSibling),
                            s === null))
                                return null;
                        return s
                    }
                    function zT(s, r) {
                        for (; s.nodeType !== 8; )
                            if ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") && !r || (s = Or(s.nextSibling),
                            s === null))
                                return null;
                        return s
                    }
                    function KS(s) {
                        return s.data === "$?" || s.data === "$~"
                    }
                    function JS(s) {
                        return s.data === "$!" || s.data === "$?" && s.ownerDocument.readyState !== "loading"
                    }
                    function J3(s, r) {
                        var h = s.ownerDocument;
                        if (s.data === "$~")
                            s._reactRetry = r;
                        else if (s.data !== "$?" || h.readyState !== "loading")
                            r();
                        else {
                            var m = function() {
                                r(),
                                h.removeEventListener("DOMContentLoaded", m)
                            };
                            h.addEventListener("DOMContentLoaded", m),
                            s._reactRetry = m
                        }
                    }
                    function Or(s) {
                        for (; s != null; s = s.nextSibling) {
                            var r = s.nodeType;
                            if (r === 1 || r === 3)
                                break;
                            if (r === 8) {
                                if (r = s.data,
                                r === "$" || r === "$!" || r === "$?" || r === "$~" || r === "&" || r === "F!" || r === "F")
                                    break;
                                if (r === "/$" || r === "/&")
                                    return null
                            }
                        }
                        return s
                    }
                    var $S = null;
                    function BT(s) {
                        s = s.nextSibling;
                        for (var r = 0; s; ) {
                            if (s.nodeType === 8) {
                                var h = s.data;
                                if (h === "/$" || h === "/&") {
                                    if (r === 0)
                                        return Or(s.nextSibling);
                                    r--
                                } else
                                    h !== "$" && h !== "$!" && h !== "$?" && h !== "$~" && h !== "&" || r++
                            }
                            s = s.nextSibling
                        }
                        return null
                    }
                    function PT(s) {
                        s = s.previousSibling;
                        for (var r = 0; s; ) {
                            if (s.nodeType === 8) {
                                var h = s.data;
                                if (h === "$" || h === "$!" || h === "$?" || h === "$~" || h === "&") {
                                    if (r === 0)
                                        return s;
                                    r--
                                } else
                                    h !== "/$" && h !== "/&" || r++
                            }
                            s = s.previousSibling
                        }
                        return null
                    }
                    function VT(s, r, h) {
                        switch (r = x_(h),
                        s) {
                        case "html":
                            if (s = r.documentElement,
                            !s)
                                throw Error(a(452));
                            return s;
                        case "head":
                            if (s = r.head,
                            !s)
                                throw Error(a(453));
                            return s;
                        case "body":
                            if (s = r.body,
                            !s)
                                throw Error(a(454));
                            return s;
                        default:
                            throw Error(a(451))
                        }
                    }
                    function jm(s) {
                        for (var r = s.attributes; r.length; )
                            s.removeAttributeNode(r[0]);
                        Tl(s)
                    }
                    var Ur = new Map
                      , FT = new Set;
                    function M_(s) {
                        return typeof s.getRootNode == "function" ? s.getRootNode() : s.nodeType === 9 ? s : s.ownerDocument
                    }
                    var Jl = X.d;
                    X.d = {
                        f: $3,
                        r: eN,
                        D: tN,
                        C: nN,
                        L: iN,
                        m: sN,
                        X: rN,
                        S: aN,
                        M: oN
                    };
                    function $3() {
                        var s = Jl.f()
                          , r = el();
                        return s || r
                    }
                    function eN(s) {
                        var r = Fn(s);
                        r !== null && r.tag === 5 && r.type === "form" ? Om(r) : Jl.r(s)
                    }
                    var gd = typeof document > "u" ? null : document;
                    function HT(s, r, h) {
                        var m = gd;
                        if (m && typeof r == "string" && r) {
                            var x = Ti(r);
                            x = 'link[rel="' + s + '"][href="' + x + '"]',
                            typeof h == "string" && (x += '[crossorigin="' + h + '"]'),
                            FT.has(x) || (FT.add(x),
                            s = {
                                rel: s,
                                crossOrigin: h,
                                href: r
                            },
                            m.querySelector(x) === null && (r = m.createElement("link"),
                            Ts(r, "link", s),
                            _e(r),
                            m.head.appendChild(r)))
                        }
                    }
                    function tN(s) {
                        Jl.D(s),
                        HT("dns-prefetch", s, null)
                    }
                    function nN(s, r) {
                        Jl.C(s, r),
                        HT("preconnect", s, r)
                    }
                    function iN(s, r, h) {
                        Jl.L(s, r, h);
                        var m = gd;
                        if (m && s && r) {
                            var x = 'link[rel="preload"][as="' + Ti(r) + '"]';
                            r === "image" && h && h.imageSrcSet ? (x += '[imagesrcset="' + Ti(h.imageSrcSet) + '"]',
                            typeof h.imageSizes == "string" && (x += '[imagesizes="' + Ti(h.imageSizes) + '"]')) : x += '[href="' + Ti(s) + '"]';
                            var b = x;
                            switch (r) {
                            case "style":
                                b = vd(s);
                                break;
                            case "script":
                                b = _d(s)
                            }
                            Ur.has(b) || (s = y({
                                rel: "preload",
                                href: r === "image" && h && h.imageSrcSet ? void 0 : s,
                                as: r
                            }, h),
                            Ur.set(b, s),
                            m.querySelector(x) !== null || r === "style" && m.querySelector(Zm(b)) || r === "script" && m.querySelector(Qm(b)) || (r = m.createElement("link"),
                            Ts(r, "link", s),
                            _e(r),
                            m.head.appendChild(r)))
                        }
                    }
                    function sN(s, r) {
                        Jl.m(s, r);
                        var h = gd;
                        if (h && s) {
                            var m = r && typeof r.as == "string" ? r.as : "script"
                              , x = 'link[rel="modulepreload"][as="' + Ti(m) + '"][href="' + Ti(s) + '"]'
                              , b = x;
                            switch (m) {
                            case "audioworklet":
                            case "paintworklet":
                            case "serviceworker":
                            case "sharedworker":
                            case "worker":
                            case "script":
                                b = _d(s)
                            }
                            if (!Ur.has(b) && (s = y({
                                rel: "modulepreload",
                                href: s
                            }, r),
                            Ur.set(b, s),
                            h.querySelector(x) === null)) {
                                switch (m) {
                                case "audioworklet":
                                case "paintworklet":
                                case "serviceworker":
                                case "sharedworker":
                                case "worker":
                                case "script":
                                    if (h.querySelector(Qm(b)))
                                        return
                                }
                                m = h.createElement("link"),
                                Ts(m, "link", s),
                                _e(m),
                                h.head.appendChild(m)
                            }
                        }
                    }
                    function aN(s, r, h) {
                        Jl.S(s, r, h);
                        var m = gd;
                        if (m && s) {
                            var x = ue(m).hoistableStyles
                              , b = vd(s);
                            r = r || "default";
                            var L = x.get(b);
                            if (!L) {
                                var W = {
                                    loading: 0,
                                    preload: null
                                };
                                if (L = m.querySelector(Zm(b)))
                                    W.loading = 5;
                                else {
                                    s = y({
                                        rel: "stylesheet",
                                        href: s,
                                        "data-precedence": r
                                    }, h),
                                    (h = Ur.get(b)) && ex(s, h);
                                    var ae = L = m.createElement("link");
                                    _e(ae),
                                    Ts(ae, "link", s),
                                    ae._p = new Promise(function(be, ze) {
                                        ae.onload = be,
                                        ae.onerror = ze
                                    }
                                    ),
                                    ae.addEventListener("load", function() {
                                        W.loading |= 1
                                    }),
                                    ae.addEventListener("error", function() {
                                        W.loading |= 2
                                    }),
                                    W.loading |= 4,
                                    b_(L, r, m)
                                }
                                L = {
                                    type: "stylesheet",
                                    instance: L,
                                    count: 1,
                                    state: W
                                },
                                x.set(b, L)
                            }
                        }
                    }
                    function rN(s, r) {
                        Jl.X(s, r);
                        var h = gd;
                        if (h && s) {
                            var m = ue(h).hoistableScripts
                              , x = _d(s)
                              , b = m.get(x);
                            b || (b = h.querySelector(Qm(x)),
                            b || (s = y({
                                src: s,
                                async: !0
                            }, r),
                            (r = Ur.get(x)) && tx(s, r),
                            b = h.createElement("script"),
                            _e(b),
                            Ts(b, "link", s),
                            h.head.appendChild(b)),
                            b = {
                                type: "script",
                                instance: b,
                                count: 1,
                                state: null
                            },
                            m.set(x, b))
                        }
                    }
                    function oN(s, r) {
                        Jl.M(s, r);
                        var h = gd;
                        if (h && s) {
                            var m = ue(h).hoistableScripts
                              , x = _d(s)
                              , b = m.get(x);
                            b || (b = h.querySelector(Qm(x)),
                            b || (s = y({
                                src: s,
                                async: !0,
                                type: "module"
                            }, r),
                            (r = Ur.get(x)) && tx(s, r),
                            b = h.createElement("script"),
                            _e(b),
                            Ts(b, "link", s),
                            h.head.appendChild(b)),
                            b = {
                                type: "script",
                                instance: b,
                                count: 1,
                                state: null
                            },
                            m.set(x, b))
                        }
                    }
                    function GT(s, r, h, m) {
                        var x = (x = we.current) ? M_(x) : null;
                        if (!x)
                            throw Error(a(446));
                        switch (s) {
                        case "meta":
                        case "title":
                            return null;
                        case "style":
                            return typeof h.precedence == "string" && typeof h.href == "string" ? (r = vd(h.href),
                            h = ue(x).hoistableStyles,
                            m = h.get(r),
                            m || (m = {
                                type: "style",
                                instance: null,
                                count: 0,
                                state: null
                            },
                            h.set(r, m)),
                            m) : {
                                type: "void",
                                instance: null,
                                count: 0,
                                state: null
                            };
                        case "link":
                            if (h.rel === "stylesheet" && typeof h.href == "string" && typeof h.precedence == "string") {
                                s = vd(h.href);
                                var b = ue(x).hoistableStyles
                                  , L = b.get(s);
                                if (L || (x = x.ownerDocument || x,
                                L = {
                                    type: "stylesheet",
                                    instance: null,
                                    count: 0,
                                    state: {
                                        loading: 0,
                                        preload: null
                                    }
                                },
                                b.set(s, L),
                                (b = x.querySelector(Zm(s))) && !b._p && (L.instance = b,
                                L.state.loading = 5),
                                Ur.has(s) || (h = {
                                    rel: "preload",
                                    as: "style",
                                    href: h.href,
                                    crossOrigin: h.crossOrigin,
                                    integrity: h.integrity,
                                    media: h.media,
                                    hrefLang: h.hrefLang,
                                    referrerPolicy: h.referrerPolicy
                                },
                                Ur.set(s, h),
                                b || lN(x, s, h, L.state))),
                                r && m === null)
                                    throw Error(a(528, ""));
                                return L
                            }
                            if (r && m !== null)
                                throw Error(a(529, ""));
                            return null;
                        case "script":
                            return r = h.async,
                            h = h.src,
                            typeof h == "string" && r && typeof r != "function" && typeof r != "symbol" ? (r = _d(h),
                            h = ue(x).hoistableScripts,
                            m = h.get(r),
                            m || (m = {
                                type: "script",
                                instance: null,
                                count: 0,
                                state: null
                            },
                            h.set(r, m)),
                            m) : {
                                type: "void",
                                instance: null,
                                count: 0,
                                state: null
                            };
                        default:
                            throw Error(a(444, s))
                        }
                    }
                    function vd(s) {
                        return 'href="' + Ti(s) + '"'
                    }
                    function Zm(s) {
                        return 'link[rel="stylesheet"][' + s + "]"
                    }
                    function kT(s) {
                        return y({}, s, {
                            "data-precedence": s.precedence,
                            precedence: null
                        })
                    }
                    function lN(s, r, h, m) {
                        s.querySelector('link[rel="preload"][as="style"][' + r + "]") ? m.loading = 1 : (r = s.createElement("link"),
                        m.preload = r,
                        r.addEventListener("load", function() {
                            return m.loading |= 1
                        }),
                        r.addEventListener("error", function() {
                            return m.loading |= 2
                        }),
                        Ts(r, "link", h),
                        _e(r),
                        s.head.appendChild(r))
                    }
                    function _d(s) {
                        return '[src="' + Ti(s) + '"]'
                    }
                    function Qm(s) {
                        return "script[async]" + s
                    }
                    function qT(s, r, h) {
                        if (r.count++,
                        r.instance === null)
                            switch (r.type) {
                            case "style":
                                var m = s.querySelector('style[data-href~="' + Ti(h.href) + '"]');
                                if (m)
                                    return r.instance = m,
                                    _e(m),
                                    m;
                                var x = y({}, h, {
                                    "data-href": h.href,
                                    "data-precedence": h.precedence,
                                    href: null,
                                    precedence: null
                                });
                                return m = (s.ownerDocument || s).createElement("style"),
                                _e(m),
                                Ts(m, "style", x),
                                b_(m, h.precedence, s),
                                r.instance = m;
                            case "stylesheet":
                                x = vd(h.href);
                                var b = s.querySelector(Zm(x));
                                if (b)
                                    return r.state.loading |= 4,
                                    r.instance = b,
                                    _e(b),
                                    b;
                                m = kT(h),
                                (x = Ur.get(x)) && ex(m, x),
                                b = (s.ownerDocument || s).createElement("link"),
                                _e(b);
                                var L = b;
                                return L._p = new Promise(function(W, ae) {
                                    L.onload = W,
                                    L.onerror = ae
                                }
                                ),
                                Ts(b, "link", m),
                                r.state.loading |= 4,
                                b_(b, h.precedence, s),
                                r.instance = b;
                            case "script":
                                return b = _d(h.src),
                                (x = s.querySelector(Qm(b))) ? (r.instance = x,
                                _e(x),
                                x) : (m = h,
                                (x = Ur.get(b)) && (m = y({}, h),
                                tx(m, x)),
                                s = s.ownerDocument || s,
                                x = s.createElement("script"),
                                _e(x),
                                Ts(x, "link", m),
                                s.head.appendChild(x),
                                r.instance = x);
                            case "void":
                                return null;
                            default:
                                throw Error(a(443, r.type))
                            }
                        else
                            r.type === "stylesheet" && (r.state.loading & 4) === 0 && (m = r.instance,
                            r.state.loading |= 4,
                            b_(m, h.precedence, s));
                        return r.instance
                    }
                    function b_(s, r, h) {
                        for (var m = h.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), x = m.length ? m[m.length - 1] : null, b = x, L = 0; L < m.length; L++) {
                            var W = m[L];
                            if (W.dataset.precedence === r)
                                b = W;
                            else if (b !== x)
                                break
                        }
                        b ? b.parentNode.insertBefore(s, b.nextSibling) : (r = h.nodeType === 9 ? h.head : h,
                        r.insertBefore(s, r.firstChild))
                    }
                    function ex(s, r) {
                        s.crossOrigin ??= r.crossOrigin,
                        s.referrerPolicy ??= r.referrerPolicy,
                        s.title ??= r.title
                    }
                    function tx(s, r) {
                        s.crossOrigin ??= r.crossOrigin,
                        s.referrerPolicy ??= r.referrerPolicy,
                        s.integrity ??= r.integrity
                    }
                    var T_ = null;
                    function XT(s, r, h) {
                        if (T_ === null) {
                            var m = new Map
                              , x = T_ = new Map;
                            x.set(h, m)
                        } else
                            x = T_,
                            m = x.get(h),
                            m || (m = new Map,
                            x.set(h, m));
                        if (m.has(s))
                            return m;
                        for (m.set(s, null),
                        h = h.getElementsByTagName(s),
                        x = 0; x < h.length; x++) {
                            var b = h[x];
                            if (!(b[Gr] || b[Zt] || s === "link" && b.getAttribute("rel") === "stylesheet") && b.namespaceURI !== "http://www.w3.org/2000/svg") {
                                var L = b.getAttribute(r) || "";
                                L = s + L;
                                var W = m.get(L);
                                W ? W.push(b) : m.set(L, [b])
                            }
                        }
                        return m
                    }
                    function WT(s, r, h) {
                        s = s.ownerDocument || s,
                        s.head.insertBefore(h, r === "title" ? s.querySelector("head > title") : null)
                    }
                    function cN(s, r, h) {
                        if (h === 1 || r.itemProp != null)
                            return !1;
                        switch (s) {
                        case "meta":
                        case "title":
                            return !0;
                        case "style":
                            if (typeof r.precedence != "string" || typeof r.href != "string" || r.href === "")
                                break;
                            return !0;
                        case "link":
                            if (typeof r.rel != "string" || typeof r.href != "string" || r.href === "" || r.onLoad || r.onError)
                                break;
                            return r.rel === "stylesheet" ? (s = r.disabled,
                            typeof r.precedence == "string" && s == null) : !0;
                        case "script":
                            if (r.async && typeof r.async != "function" && typeof r.async != "symbol" && !r.onLoad && !r.onError && r.src && typeof r.src == "string")
                                return !0
                        }
                        return !1
                    }
                    function YT(s) {
                        return !(s.type === "stylesheet" && (s.state.loading & 3) === 0)
                    }
                    function uN(s, r, h, m) {
                        if (h.type === "stylesheet" && (typeof m.media != "string" || matchMedia(m.media).matches !== !1) && (h.state.loading & 4) === 0) {
                            if (h.instance === null) {
                                var x = vd(m.href)
                                  , b = r.querySelector(Zm(x));
                                if (b) {
                                    r = b._p,
                                    r !== null && typeof r == "object" && typeof r.then == "function" && (s.count++,
                                    s = A_.bind(s),
                                    r.then(s, s)),
                                    h.state.loading |= 4,
                                    h.instance = b,
                                    _e(b);
                                    return
                                }
                                b = r.ownerDocument || r,
                                m = kT(m),
                                (x = Ur.get(x)) && ex(m, x),
                                b = b.createElement("link"),
                                _e(b);
                                var L = b;
                                L._p = new Promise(function(W, ae) {
                                    L.onload = W,
                                    L.onerror = ae
                                }
                                ),
                                Ts(b, "link", m),
                                h.instance = b
                            }
                            s.stylesheets === null && (s.stylesheets = new Map),
                            s.stylesheets.set(h, r),
                            (r = h.state.preload) && (h.state.loading & 3) === 0 && (s.count++,
                            h = A_.bind(s),
                            r.addEventListener("load", h),
                            r.addEventListener("error", h))
                        }
                    }
                    var nx = 0;
                    function hN(s, r) {
                        return s.stylesheets && s.count === 0 && C_(s, s.stylesheets),
                        0 < s.count || 0 < s.imgCount ? function(h) {
                            var m = setTimeout(function() {
                                if (s.stylesheets && C_(s, s.stylesheets),
                                s.unsuspend) {
                                    var b = s.unsuspend;
                                    s.unsuspend = null,
                                    b()
                                }
                            }, 6e4 + r);
                            0 < s.imgBytes && nx === 0 && (nx = 62500 * X3());
                            var x = setTimeout(function() {
                                if (s.waitingForImages = !1,
                                s.count === 0 && (s.stylesheets && C_(s, s.stylesheets),
                                s.unsuspend)) {
                                    var b = s.unsuspend;
                                    s.unsuspend = null,
                                    b()
                                }
                            }, (s.imgBytes > nx ? 50 : 800) + r);
                            return s.unsuspend = h,
                            function() {
                                s.unsuspend = null,
                                clearTimeout(m),
                                clearTimeout(x)
                            }
                        }
                        : null
                    }
                    function A_() {
                        if (this.count--,
                        this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
                            if (this.stylesheets)
                                C_(this, this.stylesheets);
                            else if (this.unsuspend) {
                                var s = this.unsuspend;
                                this.unsuspend = null,
                                s()
                            }
                        }
                    }
                    var E_ = null;
                    function C_(s, r) {
                        s.stylesheets = null,
                        s.unsuspend !== null && (s.count++,
                        E_ = new Map,
                        r.forEach(fN, s),
                        E_ = null,
                        A_.call(s))
                    }
                    function fN(s, r) {
                        if (!(r.state.loading & 4)) {
                            var h = E_.get(s);
                            if (h)
                                var m = h.get(null);
                            else {
                                h = new Map,
                                E_.set(s, h);
                                for (var x = s.querySelectorAll("link[data-precedence],style[data-precedence]"), b = 0; b < x.length; b++) {
                                    var L = x[b];
                                    (L.nodeName === "LINK" || L.getAttribute("media") !== "not all") && (h.set(L.dataset.precedence, L),
                                    m = L)
                                }
                                m && h.set(null, m)
                            }
                            x = r.instance,
                            L = x.getAttribute("data-precedence"),
                            b = h.get(L) || m,
                            b === m && h.set(null, x),
                            h.set(L, x),
                            this.count++,
                            m = A_.bind(this),
                            x.addEventListener("load", m),
                            x.addEventListener("error", m),
                            b ? b.parentNode.insertBefore(x, b.nextSibling) : (s = s.nodeType === 9 ? s.head : s,
                            s.insertBefore(x, s.firstChild)),
                            r.state.loading |= 4
                        }
                    }
                    var Km = {
                        $$typeof: D,
                        Provider: null,
                        Consumer: null,
                        _currentValue: $,
                        _currentValue2: $,
                        _threadCount: 0
                    };
                    function dN(s, r, h, m, x, b, L, W, ae) {
                        this.tag = 1,
                        this.containerInfo = s,
                        this.pingCache = this.current = this.pendingChildren = null,
                        this.timeoutHandle = -1,
                        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                        this.callbackPriority = 0,
                        this.expirationTimes = cs(-1),
                        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                        this.entanglements = cs(0),
                        this.hiddenUpdates = cs(null),
                        this.identifierPrefix = m,
                        this.onUncaughtError = x,
                        this.onCaughtError = b,
                        this.onRecoverableError = L,
                        this.pooledCache = null,
                        this.pooledCacheLanes = 0,
                        this.formState = ae,
                        this.incompleteTransitions = new Map
                    }
                    function pN(s, r, h, m, x, b, L, W, ae, be, ze, Fe) {
                        return s = new dN(s,r,h,L,ae,be,ze,Fe,W),
                        r = 1,
                        b === !0 && (r |= 24),
                        b = Li(3, null, null, r),
                        s.current = b,
                        b.stateNode = s,
                        r = zf(),
                        r.refCount++,
                        s.pooledCache = r,
                        r.refCount++,
                        b.memoizedState = {
                            element: m,
                            isDehydrated: h,
                            cache: r
                        },
                        ju(b),
                        s
                    }
                    function mN(s) {
                        return s ? (s = ja,
                        s) : ja
                    }
                    function jT(s, r, h, m, x, b) {
                        x = mN(x),
                        m.context === null ? m.context = x : m.pendingContext = x,
                        m = eo(r),
                        m.payload = {
                            element: h
                        },
                        b = b === void 0 ? null : b,
                        b !== null && (m.callback = b),
                        h = Sr(s, m, r),
                        h !== null && (Zi(h, s, r),
                        Zu(h, s, r))
                    }
                    function ZT(s, r) {
                        if (s = s.memoizedState,
                        s !== null && s.dehydrated !== null) {
                            var h = s.retryLane;
                            s.retryLane = h !== 0 && h < r ? h : r
                        }
                    }
                    function ix(s, r) {
                        ZT(s, r),
                        (s = s.alternate) && ZT(s, r)
                    }
                    function QT(s) {
                        if (s.tag === 13 || s.tag === 31) {
                            var r = Yr(s, 67108864);
                            r !== null && Zi(r, s, 67108864),
                            ix(s, 67108864)
                        }
                    }
                    function KT(s) {
                        if (s.tag === 13 || s.tag === 31) {
                            var r = Vs();
                            r = ba(r);
                            var h = Yr(s, r);
                            h !== null && Zi(h, s, r),
                            ix(s, r)
                        }
                    }
                    var w_ = !0;
                    function gN(s, r, h, m) {
                        var x = F.T;
                        F.T = null;
                        var b = X.p;
                        try {
                            X.p = 2,
                            sx(s, r, h, m)
                        } finally {
                            X.p = b,
                            F.T = x
                        }
                    }
                    function vN(s, r, h, m) {
                        var x = F.T;
                        F.T = null;
                        var b = X.p;
                        try {
                            X.p = 8,
                            sx(s, r, h, m)
                        } finally {
                            X.p = b,
                            F.T = x
                        }
                    }
                    function sx(s, r, h, m) {
                        if (w_) {
                            var x = ax(m);
                            if (x === null)
                                qS(s, r, m, R_, h),
                                $T(s, m);
                            else if (yN(x, s, r, h, m))
                                m.stopPropagation();
                            else if ($T(s, m),
                            r & 4 && -1 < _N.indexOf(s)) {
                                for (; x !== null; ) {
                                    var b = Fn(x);
                                    if (b !== null)
                                        switch (b.tag) {
                                        case 3:
                                            if (b = b.stateNode,
                                            b.current.memoizedState.isDehydrated) {
                                                var L = De(b.pendingLanes);
                                                if (L !== 0) {
                                                    var W = b;
                                                    for (W.pendingLanes |= 2,
                                                    W.entangledLanes |= 2; L; ) {
                                                        var ae = 1 << 31 - tt(L);
                                                        W.entanglements[1] |= ae,
                                                        L &= ~ae
                                                    }
                                                    Kl(b),
                                                    (An & 6) === 0 && (Ua = he() + 500,
                                                    Xm(0, !1))
                                                }
                                            }
                                            break;
                                        case 31:
                                        case 13:
                                            W = Yr(b, 2),
                                            W !== null && Zi(W, b, 2),
                                            el(),
                                            ix(b, 2)
                                        }
                                    if (b = ax(m),
                                    b === null && qS(s, r, m, R_, h),
                                    b === x)
                                        break;
                                    x = b
                                }
                                x !== null && m.stopPropagation()
                            } else
                                qS(s, r, m, null, h)
                        }
                    }
                    function ax(s) {
                        return s = lf(s),
                        rx(s)
                    }
                    var R_ = null;
                    function rx(s) {
                        if (R_ = null,
                        s = yi(s),
                        s !== null) {
                            var r = u(s);
                            if (r === null)
                                s = null;
                            else {
                                var h = r.tag;
                                if (h === 13) {
                                    if (s = f(r),
                                    s !== null)
                                        return s;
                                    s = null
                                } else if (h === 31) {
                                    if (s = d(r),
                                    s !== null)
                                        return s;
                                    s = null
                                } else if (h === 3) {
                                    if (r.stateNode.current.memoizedState.isDehydrated)
                                        return r.tag === 3 ? r.stateNode.containerInfo : null;
                                    s = null
                                } else
                                    r !== s && (s = null)
                            }
                        }
                        return R_ = s,
                        null
                    }
                    function JT(s) {
                        switch (s) {
                        case "beforetoggle":
                        case "cancel":
                        case "click":
                        case "close":
                        case "contextmenu":
                        case "copy":
                        case "cut":
                        case "auxclick":
                        case "dblclick":
                        case "dragend":
                        case "dragstart":
                        case "drop":
                        case "focusin":
                        case "focusout":
                        case "input":
                        case "invalid":
                        case "keydown":
                        case "keypress":
                        case "keyup":
                        case "mousedown":
                        case "mouseup":
                        case "paste":
                        case "pause":
                        case "play":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                        case "ratechange":
                        case "reset":
                        case "resize":
                        case "seeked":
                        case "submit":
                        case "toggle":
                        case "touchcancel":
                        case "touchend":
                        case "touchstart":
                        case "volumechange":
                        case "change":
                        case "selectionchange":
                        case "textInput":
                        case "compositionstart":
                        case "compositionend":
                        case "compositionupdate":
                        case "beforeblur":
                        case "afterblur":
                        case "beforeinput":
                        case "blur":
                        case "fullscreenchange":
                        case "focus":
                        case "hashchange":
                        case "popstate":
                        case "select":
                        case "selectstart":
                            return 2;
                        case "drag":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "mousemove":
                        case "mouseout":
                        case "mouseover":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "scroll":
                        case "touchmove":
                        case "wheel":
                        case "mouseenter":
                        case "mouseleave":
                        case "pointerenter":
                        case "pointerleave":
                            return 8;
                        case "message":
                            switch (Le()) {
                            case He:
                                return 2;
                            case Oe:
                                return 8;
                            case pt:
                            case et:
                                return 32;
                            case xt:
                                return 268435456;
                            default:
                                return 32
                            }
                        default:
                            return 32
                        }
                    }
                    var ox = !1
                      , Wc = null
                      , Yc = null
                      , jc = null
                      , Jm = new Map
                      , $m = new Map
                      , Zc = []
                      , _N = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
                    function $T(s, r) {
                        switch (s) {
                        case "focusin":
                        case "focusout":
                            Wc = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            Yc = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            jc = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            Jm.delete(r.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            $m.delete(r.pointerId)
                        }
                    }
                    function eg(s, r, h, m, x, b) {
                        return s === null || s.nativeEvent !== b ? (s = {
                            blockedOn: r,
                            domEventName: h,
                            eventSystemFlags: m,
                            nativeEvent: b,
                            targetContainers: [x]
                        },
                        r !== null && (r = Fn(r),
                        r !== null && QT(r)),
                        s) : (s.eventSystemFlags |= m,
                        r = s.targetContainers,
                        x !== null && r.indexOf(x) === -1 && r.push(x),
                        s)
                    }
                    function yN(s, r, h, m, x) {
                        switch (r) {
                        case "focusin":
                            return Wc = eg(Wc, s, r, h, m, x),
                            !0;
                        case "dragenter":
                            return Yc = eg(Yc, s, r, h, m, x),
                            !0;
                        case "mouseover":
                            return jc = eg(jc, s, r, h, m, x),
                            !0;
                        case "pointerover":
                            var b = x.pointerId;
                            return Jm.set(b, eg(Jm.get(b) || null, s, r, h, m, x)),
                            !0;
                        case "gotpointercapture":
                            return b = x.pointerId,
                            $m.set(b, eg($m.get(b) || null, s, r, h, m, x)),
                            !0
                        }
                        return !1
                    }
                    function e1(s) {
                        var r = yi(s.target);
                        if (r !== null) {
                            var h = u(r);
                            if (h !== null) {
                                if (r = h.tag,
                                r === 13) {
                                    if (r = f(h),
                                    r !== null) {
                                        s.blockedOn = r,
                                        Js(s.priority, function() {
                                            KT(h)
                                        });
                                        return
                                    }
                                } else if (r === 31) {
                                    if (r = d(h),
                                    r !== null) {
                                        s.blockedOn = r,
                                        Js(s.priority, function() {
                                            KT(h)
                                        });
                                        return
                                    }
                                } else if (r === 3 && h.stateNode.current.memoizedState.isDehydrated) {
                                    s.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null;
                                    return
                                }
                            }
                        }
                        s.blockedOn = null
                    }
                    function N_(s) {
                        if (s.blockedOn !== null)
                            return !1;
                        for (var r = s.targetContainers; 0 < r.length; ) {
                            var h = ax(s.nativeEvent);
                            if (h === null) {
                                h = s.nativeEvent;
                                var m = new h.constructor(h.type,h);
                                wu = m,
                                h.target.dispatchEvent(m),
                                wu = null
                            } else
                                return r = Fn(h),
                                r !== null && QT(r),
                                s.blockedOn = h,
                                !1;
                            r.shift()
                        }
                        return !0
                    }
                    function t1(s, r, h) {
                        N_(s) && h.delete(r)
                    }
                    function SN() {
                        ox = !1,
                        Wc !== null && N_(Wc) && (Wc = null),
                        Yc !== null && N_(Yc) && (Yc = null),
                        jc !== null && N_(jc) && (jc = null),
                        Jm.forEach(t1),
                        $m.forEach(t1)
                    }
                    function D_(s, r) {
                        s.blockedOn === r && (s.blockedOn = null,
                        ox || (ox = !0,
                        e.unstable_scheduleCallback(e.unstable_NormalPriority, SN)))
                    }
                    var O_ = null;
                    function n1(s) {
                        O_ !== s && (O_ = s,
                        e.unstable_scheduleCallback(e.unstable_NormalPriority, function() {
                            O_ === s && (O_ = null);
                            for (var r = 0; r < s.length; r += 3) {
                                var h = s[r]
                                  , m = s[r + 1]
                                  , x = s[r + 2];
                                if (typeof m != "function") {
                                    if (rx(m || h) === null)
                                        continue;
                                    break
                                }
                                var b = Fn(h);
                                b !== null && (s.splice(r, 3),
                                r -= 3,
                                Dm(b, {
                                    pending: !0,
                                    data: x,
                                    method: h.method,
                                    action: m
                                }, m, x))
                            }
                        }))
                    }
                    function yd(s) {
                        function r(ae) {
                            return D_(ae, s)
                        }
                        Wc !== null && D_(Wc, s),
                        Yc !== null && D_(Yc, s),
                        jc !== null && D_(jc, s),
                        Jm.forEach(r),
                        $m.forEach(r);
                        for (var h = 0; h < Zc.length; h++) {
                            var m = Zc[h];
                            m.blockedOn === s && (m.blockedOn = null)
                        }
                        for (; 0 < Zc.length && (h = Zc[0],
                        h.blockedOn === null); )
                            e1(h),
                            h.blockedOn === null && Zc.shift();
                        if (h = (s.ownerDocument || s).$$reactFormReplay,
                        h != null)
                            for (m = 0; m < h.length; m += 3) {
                                var x = h[m]
                                  , b = h[m + 1]
                                  , L = x[Oi] || null;
                                if (typeof b == "function")
                                    L || n1(h);
                                else if (L) {
                                    var W = null;
                                    if (b && b.hasAttribute("formAction")) {
                                        if (x = b,
                                        L = b[Oi] || null)
                                            W = L.formAction;
                                        else if (rx(x) !== null)
                                            continue
                                    } else
                                        W = L.action;
                                    typeof W == "function" ? h[m + 1] = W : (h.splice(m, 3),
                                    m -= 3),
                                    n1(h)
                                }
                            }
                    }
                    function xN() {
                        function s(b) {
                            b.canIntercept && b.info === "react-transition" && b.intercept({
                                handler: function() {
                                    return new Promise(function(L) {
                                        return x = L
                                    }
                                    )
                                },
                                focusReset: "manual",
                                scroll: "manual"
                            })
                        }
                        function r() {
                            x !== null && (x(),
                            x = null),
                            m || setTimeout(h, 20)
                        }
                        function h() {
                            if (!m && !navigation.transition) {
                                var b = navigation.currentEntry;
                                b && b.url != null && navigation.navigate(b.url, {
                                    state: b.getState(),
                                    info: "react-transition",
                                    history: "replace"
                                })
                            }
                        }
                        if (typeof navigation == "object") {
                            var m = !1
                              , x = null;
                            return navigation.addEventListener("navigate", s),
                            navigation.addEventListener("navigatesuccess", r),
                            navigation.addEventListener("navigateerror", r),
                            setTimeout(h, 100),
                            function() {
                                m = !0,
                                navigation.removeEventListener("navigate", s),
                                navigation.removeEventListener("navigatesuccess", r),
                                navigation.removeEventListener("navigateerror", r),
                                x !== null && (x(),
                                x = null)
                            }
                        }
                    }
                    function lx(s) {
                        this._internalRoot = s
                    }
                    cx.prototype.render = lx.prototype.render = function(s) {
                        var r = this._internalRoot;
                        if (r === null)
                            throw Error(a(409));
                        var h = r.current;
                        jT(h, Vs(), s, r, null, null)
                    }
                    ,
                    cx.prototype.unmount = lx.prototype.unmount = function() {
                        var s = this._internalRoot;
                        if (s !== null) {
                            this._internalRoot = null;
                            var r = s.containerInfo;
                            jT(s.current, 2, null, s, null, null),
                            el(),
                            r[Aa] = null
                        }
                    }
                    ;
                    function cx(s) {
                        this._internalRoot = s
                    }
                    cx.prototype.unstable_scheduleHydration = function(s) {
                        if (s) {
                            var r = Ks();
                            s = {
                                blockedOn: null,
                                target: s,
                                priority: r
                            };
                            for (var h = 0; h < Zc.length && r !== 0 && r < Zc[h].priority; h++)
                                ;
                            Zc.splice(h, 0, s),
                            h === 0 && e1(s)
                        }
                    }
                    ;
                    var i1 = n.version;
                    if (i1 !== "19.2.3")
                        throw Error(a(527, i1, "19.2.3"));
                    X.findDOMNode = function(s) {
                        var r = s._reactInternals;
                        if (r === void 0)
                            throw typeof s.render == "function" ? Error(a(188)) : (s = Object.keys(s).join(","),
                            Error(a(268, s)));
                        return s = g(r),
                        s = s !== null ? v(s) : null,
                        s = s === null ? null : s.stateNode,
                        s
                    }
                    ;
                    var MN = {
                        bundleType: 0,
                        version: "19.2.3",
                        rendererPackageName: "react-dom",
                        currentDispatcherRef: F,
                        reconcilerVersion: "19.2.3"
                    };
                    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
                        var U_ = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                        if (!U_.isDisabled && U_.supportsFiber)
                            try {
                                Xe = U_.inject(MN),
                                nt = U_
                            } catch {}
                    }
                    t.createRoot = function(s, r) {
                        if (!o(s))
                            throw Error(a(299));
                        var h = !1
                          , m = ""
                          , x = Uc
                          , b = ia
                          , L = zS;
                        return r != null && (r.unstable_strictMode === !0 && (h = !0),
                        r.identifierPrefix !== void 0 && (m = r.identifierPrefix),
                        r.onUncaughtError !== void 0 && (x = r.onUncaughtError),
                        r.onCaughtError !== void 0 && (b = r.onCaughtError),
                        r.onRecoverableError !== void 0 && (L = r.onRecoverableError)),
                        r = pN(s, 1, !1, null, null, h, m, null, x, b, L, xN),
                        s[Aa] = r.current,
                        TT(s),
                        new lx(r)
                    }
                }
                ))
                  , FN = ln(( (t, e) => {
                    function n() {
                        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                            try {
                                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                            } catch (i) {
                                console.error(i)
                            }
                    }
                    n(),
                    e.exports = VN()
                }
                ));
                var HN = ln((t => {
                    t.ConcurrentRoot = 1,
                    t.ContinuousEventPriority = 8,
                    t.DefaultEventPriority = 32,
                    t.DiscreteEventPriority = 2
                }
                ))
                  , l1 = ln(( (t, e) => {
                    e.exports = HN()
                }
                ))
                  , I_ = l1()
                  , GN = tg(FN())
                  , gt = tg(Sd(), 1)
                  , c1 = o1();
                const z_ = "182"
                  , kN = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                }
                  , qN = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                }
                  , u1 = 0
                  , hx = 1
                  , h1 = 2
                  , XN = 3
                  , f1 = 0
                  , xd = 1
                  , ng = 2
                  , _h = 3
                  , $l = 0
                  , fa = 1
                  , il = 2
                  , sl = 0
                  , yh = 1
                  , fx = 2
                  , dx = 3
                  , px = 4
                  , d1 = 5
                  , Kc = 100
                  , p1 = 101
                  , m1 = 102
                  , g1 = 103
                  , v1 = 104
                  , _1 = 200
                  , y1 = 201
                  , S1 = 202
                  , x1 = 203
                  , B_ = 204
                  , P_ = 205
                  , M1 = 206
                  , b1 = 207
                  , T1 = 208
                  , A1 = 209
                  , E1 = 210
                  , C1 = 211
                  , w1 = 212
                  , R1 = 213
                  , N1 = 214
                  , V_ = 0
                  , F_ = 1
                  , H_ = 2
                  , Sh = 3
                  , G_ = 4
                  , k_ = 5
                  , q_ = 6
                  , X_ = 7
                  , ig = 0
                  , D1 = 1
                  , O1 = 2
                  , Lr = 0
                  , mx = 1
                  , gx = 2
                  , vx = 3
                  , W_ = 4
                  , _x = 5
                  , yx = 6
                  , Sx = 7
                  , xx = "attached"
                  , U1 = "detached"
                  , Y_ = 300
                  , al = 301
                  , Jc = 302
                  , sg = 303
                  , ag = 304
                  , Md = 306
                  , rg = 1e3
                  , Ia = 1001
                  , og = 1002
                  , Vi = 1003
                  , Mx = 1004
                  , WN = 1004
                  , bd = 1005
                  , YN = 1005
                  , fi = 1006
                  , lg = 1007
                  , jN = 1007
                  , rl = 1008
                  , ZN = 1008
                  , da = 1009
                  , bx = 1010
                  , Tx = 1011
                  , Td = 1012
                  , j_ = 1013
                  , Ir = 1014
                  , pa = 1015
                  , ol = 1016
                  , Z_ = 1017
                  , Q_ = 1018
                  , Ad = 1020
                  , Ax = 35902
                  , Ex = 35899
                  , Cx = 1021
                  , wx = 1022
                  , Hs = 1023
                  , ll = 1026
                  , $c = 1027
                  , K_ = 1028
                  , cg = 1029
                  , xh = 1030
                  , J_ = 1031
                  , QN = 1032
                  , $_ = 1033
                  , ug = 33776
                  , hg = 33777
                  , fg = 33778
                  , dg = 33779
                  , e0 = 35840
                  , t0 = 35841
                  , n0 = 35842
                  , i0 = 35843
                  , s0 = 36196
                  , a0 = 37492
                  , r0 = 37496
                  , o0 = 37488
                  , l0 = 37489
                  , c0 = 37490
                  , u0 = 37491
                  , h0 = 37808
                  , f0 = 37809
                  , d0 = 37810
                  , p0 = 37811
                  , m0 = 37812
                  , g0 = 37813
                  , v0 = 37814
                  , _0 = 37815
                  , y0 = 37816
                  , S0 = 37817
                  , x0 = 37818
                  , M0 = 37819
                  , b0 = 37820
                  , T0 = 37821
                  , A0 = 36492
                  , E0 = 36494
                  , C0 = 36495
                  , w0 = 36283
                  , R0 = 36284
                  , N0 = 36285
                  , D0 = 36286
                  , L1 = 2200
                  , I1 = 2201
                  , z1 = 2202
                  , pg = 2300
                  , O0 = 2301
                  , U0 = 2302
                  , Mh = 2400
                  , bh = 2401
                  , mg = 2402
                  , L0 = 2500
                  , Rx = 2501
                  , KN = 0
                  , JN = 1
                  , $N = 2
                  , B1 = 3200
                  , eD = 3201
                  , tD = 3202
                  , nD = 3203
                  , eu = 0
                  , P1 = 1
                  , ec = ""
                  , Gs = "srgb"
                  , tu = "srgb-linear"
                  , gg = "linear"
                  , Vn = "srgb"
                  , iD = ""
                  , sD = "rg"
                  , aD = "ga"
                  , rD = 0
                  , Th = 7680
                  , oD = 7681
                  , lD = 7682
                  , cD = 7683
                  , uD = 34055
                  , hD = 34056
                  , fD = 5386
                  , dD = 512
                  , pD = 513
                  , mD = 514
                  , gD = 515
                  , vD = 516
                  , _D = 517
                  , yD = 518
                  , Nx = 519
                  , V1 = 512
                  , F1 = 513
                  , H1 = 514
                  , I0 = 515
                  , G1 = 516
                  , k1 = 517
                  , z0 = 518
                  , q1 = 519
                  , vg = 35044
                  , SD = 35048
                  , xD = 35040
                  , MD = 35045
                  , bD = 35049
                  , TD = 35041
                  , AD = 35046
                  , ED = 35050
                  , CD = 35042
                  , wD = "100"
                  , Dx = "300 es"
                  , nr = 2e3
                  , Ed = 2001
                  , RD = {
                    COMPUTE: "compute",
                    RENDER: "render"
                }
                  , ND = {
                    PERSPECTIVE: "perspective",
                    LINEAR: "linear",
                    FLAT: "flat"
                }
                  , DD = {
                    NORMAL: "normal",
                    CENTROID: "centroid",
                    SAMPLE: "sample",
                    FIRST: "first",
                    EITHER: "either"
                };
                function X1(t) {
                    for (let e = t.length - 1; e >= 0; --e)
                        if (t[e] >= 65535)
                            return !0;
                    return !1
                }
                const OD = {
                    Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                };
                function Cd(t, e) {
                    return new OD[t](e)
                }
                function W1(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                }
                function _g(t) {
                    return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                }
                function Y1() {
                    const t = _g("canvas");
                    return t.style.display = "block",
                    t
                }
                const j1 = {};
                let nu = null;
                function UD(t) {
                    nu = t
                }
                function LD() {
                    return nu
                }
                function yg(...t) {
                    const e = "THREE." + t.shift();
                    nu ? nu("log", e, ...t) : console.log(e, ...t)
                }
                function at(...t) {
                    const e = "THREE." + t.shift();
                    nu ? nu("warn", e, ...t) : console.warn(e, ...t)
                }
                function Rt(...t) {
                    const e = "THREE." + t.shift();
                    nu ? nu("error", e, ...t) : console.error(e, ...t)
                }
                function wd(...t) {
                    const e = t.join(" ");
                    e in j1 || (j1[e] = !0,
                    at(...t))
                }
                function ID(t, e, n) {
                    return new Promise(function(i, a) {
                        function o() {
                            switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                            case t.WAIT_FAILED:
                                a();
                                break;
                            case t.TIMEOUT_EXPIRED:
                                setTimeout(o, n);
                                break;
                            default:
                                i()
                            }
                        }
                        setTimeout(o, n)
                    }
                    )
                }
                var cl = class {
                    addEventListener(t, e) {
                        this._listeners === void 0 && (this._listeners = {});
                        const n = this._listeners;
                        n[t] === void 0 && (n[t] = []),
                        n[t].indexOf(e) === -1 && n[t].push(e)
                    }
                    hasEventListener(t, e) {
                        const n = this._listeners;
                        return n === void 0 ? !1 : n[t] !== void 0 && n[t].indexOf(e) !== -1
                    }
                    removeEventListener(t, e) {
                        const n = this._listeners;
                        if (n === void 0)
                            return;
                        const i = n[t];
                        if (i !== void 0) {
                            const a = i.indexOf(e);
                            a !== -1 && i.splice(a, 1)
                        }
                    }
                    dispatchEvent(t) {
                        const e = this._listeners;
                        if (e === void 0)
                            return;
                        const n = e[t.type];
                        if (n !== void 0) {
                            t.target = this;
                            const i = n.slice(0);
                            for (let a = 0, o = i.length; a < o; a++)
                                i[a].call(this, t);
                            t.target = null
                        }
                    }
                }
                ;
                const ks = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                let Z1 = 1234567;
                const Ah = Math.PI / 180
                  , Rd = 180 / Math.PI;
                function ir() {
                    const t = Math.random() * 4294967295 | 0
                      , e = Math.random() * 4294967295 | 0
                      , n = Math.random() * 4294967295 | 0
                      , i = Math.random() * 4294967295 | 0;
                    return (ks[t & 255] + ks[t >> 8 & 255] + ks[t >> 16 & 255] + ks[t >> 24 & 255] + "-" + ks[e & 255] + ks[e >> 8 & 255] + "-" + ks[e >> 16 & 15 | 64] + ks[e >> 24 & 255] + "-" + ks[n & 63 | 128] + ks[n >> 8 & 255] + "-" + ks[n >> 16 & 255] + ks[n >> 24 & 255] + ks[i & 255] + ks[i >> 8 & 255] + ks[i >> 16 & 255] + ks[i >> 24 & 255]).toLowerCase()
                }
                function Ht(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                }
                function Ox(t, e) {
                    return (t % e + e) % e
                }
                function zD(t, e, n, i, a) {
                    return i + (t - e) * (a - i) / (n - e)
                }
                function BD(t, e, n) {
                    return t !== e ? (n - t) / (e - t) : 0
                }
                function Sg(t, e, n) {
                    return (1 - n) * t + n * e
                }
                function PD(t, e, n, i) {
                    return Sg(t, e, 1 - Math.exp(-n * i))
                }
                function VD(t, e=1) {
                    return e - Math.abs(Ox(t, e * 2) - e)
                }
                function FD(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
                    t * t * (3 - 2 * t))
                }
                function HD(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
                    t * t * t * (t * (t * 6 - 15) + 10))
                }
                function GD(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                }
                function kD(t, e) {
                    return t + Math.random() * (e - t)
                }
                function qD(t) {
                    return t * (.5 - Math.random())
                }
                function XD(t) {
                    t !== void 0 && (Z1 = t);
                    let e = Z1 += 1831565813;
                    return e = Math.imul(e ^ e >>> 15, e | 1),
                    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
                    ((e ^ e >>> 14) >>> 0) / 4294967296
                }
                function WD(t) {
                    return t * Ah
                }
                function YD(t) {
                    return t * Rd
                }
                function jD(t) {
                    return (t & t - 1) === 0 && t !== 0
                }
                function ZD(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                }
                function QD(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
                function KD(t, e, n, i, a) {
                    const o = Math.cos
                      , u = Math.sin
                      , f = o(n / 2)
                      , d = u(n / 2)
                      , p = o((e + i) / 2)
                      , g = u((e + i) / 2)
                      , v = o((e - i) / 2)
                      , y = u((e - i) / 2)
                      , S = o((i - e) / 2)
                      , E = u((i - e) / 2);
                    switch (a) {
                    case "XYX":
                        t.set(f * g, d * v, d * y, f * p);
                        break;
                    case "YZY":
                        t.set(d * y, f * g, d * v, f * p);
                        break;
                    case "ZXZ":
                        t.set(d * v, d * y, f * g, f * p);
                        break;
                    case "XZX":
                        t.set(f * g, d * E, d * S, f * p);
                        break;
                    case "YXY":
                        t.set(d * S, f * g, d * E, f * p);
                        break;
                    case "ZYZ":
                        t.set(d * E, d * S, f * g, f * p);
                        break;
                    default:
                        at("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a)
                    }
                }
                function ma(t, e) {
                    switch (e.constructor) {
                    case Float32Array:
                        return t;
                    case Uint32Array:
                        return t / 4294967295;
                    case Uint16Array:
                        return t / 65535;
                    case Uint8Array:
                        return t / 255;
                    case Int32Array:
                        return Math.max(t / 2147483647, -1);
                    case Int16Array:
                        return Math.max(t / 32767, -1);
                    case Int8Array:
                        return Math.max(t / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                function $t(t, e) {
                    switch (e.constructor) {
                    case Float32Array:
                        return t;
                    case Uint32Array:
                        return Math.round(t * 4294967295);
                    case Uint16Array:
                        return Math.round(t * 65535);
                    case Uint8Array:
                        return Math.round(t * 255);
                    case Int32Array:
                        return Math.round(t * 2147483647);
                    case Int16Array:
                        return Math.round(t * 32767);
                    case Int8Array:
                        return Math.round(t * 127);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                const JD = {
                    DEG2RAD: Ah,
                    RAD2DEG: Rd,
                    generateUUID: ir,
                    clamp: Ht,
                    euclideanModulo: Ox,
                    mapLinear: zD,
                    inverseLerp: BD,
                    lerp: Sg,
                    damp: PD,
                    pingpong: VD,
                    smoothstep: FD,
                    smootherstep: HD,
                    randInt: GD,
                    randFloat: kD,
                    randFloatSpread: qD,
                    seededRandom: XD,
                    degToRad: WD,
                    radToDeg: YD,
                    isPowerOfTwo: jD,
                    ceilPowerOfTwo: ZD,
                    floorPowerOfTwo: QD,
                    setQuaternionFromProperEuler: KD,
                    normalize: $t,
                    denormalize: ma
                };
                var Ge = class hR {
                    constructor(e=0, n=0) {
                        hR.prototype.isVector2 = !0,
                        this.x = e,
                        this.y = n
                    }
                    get width() {
                        return this.x
                    }
                    set width(e) {
                        this.x = e
                    }
                    get height() {
                        return this.y
                    }
                    set height(e) {
                        this.y = e
                    }
                    set(e, n) {
                        return this.x = e,
                        this.y = n,
                        this
                    }
                    setScalar(e) {
                        return this.x = e,
                        this.y = e,
                        this
                    }
                    setX(e) {
                        return this.x = e,
                        this
                    }
                    setY(e) {
                        return this.y = e,
                        this
                    }
                    setComponent(e, n) {
                        switch (e) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                        return this
                    }
                    getComponent(e) {
                        switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y)
                    }
                    copy(e) {
                        return this.x = e.x,
                        this.y = e.y,
                        this
                    }
                    add(e) {
                        return this.x += e.x,
                        this.y += e.y,
                        this
                    }
                    addScalar(e) {
                        return this.x += e,
                        this.y += e,
                        this
                    }
                    addVectors(e, n) {
                        return this.x = e.x + n.x,
                        this.y = e.y + n.y,
                        this
                    }
                    addScaledVector(e, n) {
                        return this.x += e.x * n,
                        this.y += e.y * n,
                        this
                    }
                    sub(e) {
                        return this.x -= e.x,
                        this.y -= e.y,
                        this
                    }
                    subScalar(e) {
                        return this.x -= e,
                        this.y -= e,
                        this
                    }
                    subVectors(e, n) {
                        return this.x = e.x - n.x,
                        this.y = e.y - n.y,
                        this
                    }
                    multiply(e) {
                        return this.x *= e.x,
                        this.y *= e.y,
                        this
                    }
                    multiplyScalar(e) {
                        return this.x *= e,
                        this.y *= e,
                        this
                    }
                    divide(e) {
                        return this.x /= e.x,
                        this.y /= e.y,
                        this
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e)
                    }
                    applyMatrix3(e) {
                        const n = this.x
                          , i = this.y
                          , a = e.elements;
                        return this.x = a[0] * n + a[3] * i + a[6],
                        this.y = a[1] * n + a[4] * i + a[7],
                        this
                    }
                    min(e) {
                        return this.x = Math.min(this.x, e.x),
                        this.y = Math.min(this.y, e.y),
                        this
                    }
                    max(e) {
                        return this.x = Math.max(this.x, e.x),
                        this.y = Math.max(this.y, e.y),
                        this
                    }
                    clamp(e, n) {
                        return this.x = Ht(this.x, e.x, n.x),
                        this.y = Ht(this.y, e.y, n.y),
                        this
                    }
                    clampScalar(e, n) {
                        return this.x = Ht(this.x, e, n),
                        this.y = Ht(this.y, e, n),
                        this
                    }
                    clampLength(e, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Ht(i, e, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y
                    }
                    cross(e) {
                        return this.x * e.y - this.y * e.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    angleTo(e) {
                        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const i = this.dot(e) / n;
                        return Math.acos(Ht(i, -1, 1))
                    }
                    distanceTo(e) {
                        return Math.sqrt(this.distanceToSquared(e))
                    }
                    distanceToSquared(e) {
                        const n = this.x - e.x
                          , i = this.y - e.y;
                        return n * n + i * i
                    }
                    manhattanDistanceTo(e) {
                        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                    lerp(e, n) {
                        return this.x += (e.x - this.x) * n,
                        this.y += (e.y - this.y) * n,
                        this
                    }
                    lerpVectors(e, n, i) {
                        return this.x = e.x + (n.x - e.x) * i,
                        this.y = e.y + (n.y - e.y) * i,
                        this
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y
                    }
                    fromArray(e, n=0) {
                        return this.x = e[n],
                        this.y = e[n + 1],
                        this
                    }
                    toArray(e=[], n=0) {
                        return e[n] = this.x,
                        e[n + 1] = this.y,
                        e
                    }
                    fromBufferAttribute(e, n) {
                        return this.x = e.getX(n),
                        this.y = e.getY(n),
                        this
                    }
                    rotateAround(e, n) {
                        const i = Math.cos(n)
                          , a = Math.sin(n)
                          , o = this.x - e.x
                          , u = this.y - e.y;
                        return this.x = o * i - u * a + e.x,
                        this.y = o * a + u * i + e.y,
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y
                    }
                }
                  , za = class {
                    constructor(t=0, e=0, n=0, i=1) {
                        this.isQuaternion = !0,
                        this._x = t,
                        this._y = e,
                        this._z = n,
                        this._w = i
                    }
                    static slerpFlat(t, e, n, i, a, o, u) {
                        let f = n[i + 0]
                          , d = n[i + 1]
                          , p = n[i + 2]
                          , g = n[i + 3]
                          , v = a[o + 0]
                          , y = a[o + 1]
                          , S = a[o + 2]
                          , E = a[o + 3];
                        if (u <= 0) {
                            t[e + 0] = f,
                            t[e + 1] = d,
                            t[e + 2] = p,
                            t[e + 3] = g;
                            return
                        }
                        if (u >= 1) {
                            t[e + 0] = v,
                            t[e + 1] = y,
                            t[e + 2] = S,
                            t[e + 3] = E;
                            return
                        }
                        if (g !== E || f !== v || d !== y || p !== S) {
                            let w = f * v + d * y + p * S + g * E;
                            w < 0 && (v = -v,
                            y = -y,
                            S = -S,
                            E = -E,
                            w = -w);
                            let A = 1 - u;
                            if (w < .9995) {
                                const T = Math.acos(w)
                                  , R = Math.sin(T);
                                A = Math.sin(A * T) / R,
                                u = Math.sin(u * T) / R,
                                f = f * A + v * u,
                                d = d * A + y * u,
                                p = p * A + S * u,
                                g = g * A + E * u
                            } else {
                                f = f * A + v * u,
                                d = d * A + y * u,
                                p = p * A + S * u,
                                g = g * A + E * u;
                                const T = 1 / Math.sqrt(f * f + d * d + p * p + g * g);
                                f *= T,
                                d *= T,
                                p *= T,
                                g *= T
                            }
                        }
                        t[e] = f,
                        t[e + 1] = d,
                        t[e + 2] = p,
                        t[e + 3] = g
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, a, o) {
                        const u = n[i]
                          , f = n[i + 1]
                          , d = n[i + 2]
                          , p = n[i + 3]
                          , g = a[o]
                          , v = a[o + 1]
                          , y = a[o + 2]
                          , S = a[o + 3];
                        return t[e] = u * S + p * g + f * y - d * v,
                        t[e + 1] = f * S + p * v + d * g - u * y,
                        t[e + 2] = d * S + p * y + u * v - f * g,
                        t[e + 3] = p * S - u * g - f * v - d * y,
                        t
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t,
                        this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(t) {
                        this._w = t,
                        this._onChangeCallback()
                    }
                    set(t, e, n, i) {
                        return this._x = t,
                        this._y = e,
                        this._z = n,
                        this._w = i,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._w)
                    }
                    copy(t) {
                        return this._x = t.x,
                        this._y = t.y,
                        this._z = t.z,
                        this._w = t.w,
                        this._onChangeCallback(),
                        this
                    }
                    setFromEuler(t, e=!0) {
                        const n = t._x
                          , i = t._y
                          , a = t._z
                          , o = t._order
                          , u = Math.cos
                          , f = Math.sin
                          , d = u(n / 2)
                          , p = u(i / 2)
                          , g = u(a / 2)
                          , v = f(n / 2)
                          , y = f(i / 2)
                          , S = f(a / 2);
                        switch (o) {
                        case "XYZ":
                            this._x = v * p * g + d * y * S,
                            this._y = d * y * g - v * p * S,
                            this._z = d * p * S + v * y * g,
                            this._w = d * p * g - v * y * S;
                            break;
                        case "YXZ":
                            this._x = v * p * g + d * y * S,
                            this._y = d * y * g - v * p * S,
                            this._z = d * p * S - v * y * g,
                            this._w = d * p * g + v * y * S;
                            break;
                        case "ZXY":
                            this._x = v * p * g - d * y * S,
                            this._y = d * y * g + v * p * S,
                            this._z = d * p * S + v * y * g,
                            this._w = d * p * g - v * y * S;
                            break;
                        case "ZYX":
                            this._x = v * p * g - d * y * S,
                            this._y = d * y * g + v * p * S,
                            this._z = d * p * S - v * y * g,
                            this._w = d * p * g + v * y * S;
                            break;
                        case "YZX":
                            this._x = v * p * g + d * y * S,
                            this._y = d * y * g + v * p * S,
                            this._z = d * p * S - v * y * g,
                            this._w = d * p * g - v * y * S;
                            break;
                        case "XZY":
                            this._x = v * p * g - d * y * S,
                            this._y = d * y * g - v * p * S,
                            this._z = d * p * S + v * y * g,
                            this._w = d * p * g + v * y * S;
                            break;
                        default:
                            at("Quaternion: .setFromEuler() encountered an unknown order: " + o)
                        }
                        return e === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2
                          , i = Math.sin(n);
                        return this._x = t.x * i,
                        this._y = t.y * i,
                        this._z = t.z * i,
                        this._w = Math.cos(n),
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements
                          , n = e[0]
                          , i = e[4]
                          , a = e[8]
                          , o = e[1]
                          , u = e[5]
                          , f = e[9]
                          , d = e[2]
                          , p = e[6]
                          , g = e[10]
                          , v = n + u + g;
                        if (v > 0) {
                            const y = .5 / Math.sqrt(v + 1);
                            this._w = .25 / y,
                            this._x = (p - f) * y,
                            this._y = (a - d) * y,
                            this._z = (o - i) * y
                        } else if (n > u && n > g) {
                            const y = 2 * Math.sqrt(1 + n - u - g);
                            this._w = (p - f) / y,
                            this._x = .25 * y,
                            this._y = (i + o) / y,
                            this._z = (a + d) / y
                        } else if (u > g) {
                            const y = 2 * Math.sqrt(1 + u - n - g);
                            this._w = (a - d) / y,
                            this._x = (i + o) / y,
                            this._y = .25 * y,
                            this._z = (f + p) / y
                        } else {
                            const y = 2 * Math.sqrt(1 + g - n - u);
                            this._w = (o - i) / y,
                            this._x = (a + d) / y,
                            this._y = (f + p) / y,
                            this._z = .25 * y
                        }
                        return this._onChangeCallback(),
                        this
                    }
                    setFromUnitVectors(t, e) {
                        let n = t.dot(e) + 1;
                        return n < 1e-8 ? (n = 0,
                        Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                        this._y = t.x,
                        this._z = 0,
                        this._w = n) : (this._x = 0,
                        this._y = -t.z,
                        this._z = t.y,
                        this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                        this._y = t.z * e.x - t.x * e.z,
                        this._z = t.x * e.y - t.y * e.x,
                        this._w = n),
                        this.normalize()
                    }
                    angleTo(t) {
                        return 2 * Math.acos(Math.abs(Ht(this.dot(t), -1, 1)))
                    }
                    rotateTowards(t, e) {
                        const n = this.angleTo(t);
                        if (n === 0)
                            return this;
                        const i = Math.min(1, e / n);
                        return this.slerp(t, i),
                        this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this._onChangeCallback(),
                        this
                    }
                    dot(t) {
                        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let t = this.length();
                        return t === 0 ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (t = 1 / t,
                        this._x = this._x * t,
                        this._y = this._y * t,
                        this._z = this._z * t,
                        this._w = this._w * t),
                        this._onChangeCallback(),
                        this
                    }
                    multiply(t) {
                        return this.multiplyQuaternions(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyQuaternions(t, this)
                    }
                    multiplyQuaternions(t, e) {
                        const n = t._x
                          , i = t._y
                          , a = t._z
                          , o = t._w
                          , u = e._x
                          , f = e._y
                          , d = e._z
                          , p = e._w;
                        return this._x = n * p + o * u + i * d - a * f,
                        this._y = i * p + o * f + a * u - n * d,
                        this._z = a * p + o * d + n * f - i * u,
                        this._w = o * p - n * u - i * f - a * d,
                        this._onChangeCallback(),
                        this
                    }
                    slerp(t, e) {
                        if (e <= 0)
                            return this;
                        if (e >= 1)
                            return this.copy(t);
                        let n = t._x
                          , i = t._y
                          , a = t._z
                          , o = t._w
                          , u = this.dot(t);
                        u < 0 && (n = -n,
                        i = -i,
                        a = -a,
                        o = -o,
                        u = -u);
                        let f = 1 - e;
                        if (u < .9995) {
                            const d = Math.acos(u)
                              , p = Math.sin(d);
                            f = Math.sin(f * d) / p,
                            e = Math.sin(e * d) / p,
                            this._x = this._x * f + n * e,
                            this._y = this._y * f + i * e,
                            this._z = this._z * f + a * e,
                            this._w = this._w * f + o * e,
                            this._onChangeCallback()
                        } else
                            this._x = this._x * f + n * e,
                            this._y = this._y * f + i * e,
                            this._z = this._z * f + a * e,
                            this._w = this._w * f + o * e,
                            this.normalize();
                        return this
                    }
                    slerpQuaternions(t, e, n) {
                        return this.copy(t).slerp(e, n)
                    }
                    random() {
                        const t = 2 * Math.PI * Math.random()
                          , e = 2 * Math.PI * Math.random()
                          , n = Math.random()
                          , i = Math.sqrt(1 - n)
                          , a = Math.sqrt(n);
                        return this.set(i * Math.sin(t), i * Math.cos(t), a * Math.sin(e), a * Math.cos(e))
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                    }
                    fromArray(t, e=0) {
                        return this._x = t[e],
                        this._y = t[e + 1],
                        this._z = t[e + 2],
                        this._w = t[e + 3],
                        this._onChangeCallback(),
                        this
                    }
                    toArray(t=[], e=0) {
                        return t[e] = this._x,
                        t[e + 1] = this._y,
                        t[e + 2] = this._z,
                        t[e + 3] = this._w,
                        t
                    }
                    fromBufferAttribute(t, e) {
                        return this._x = t.getX(e),
                        this._y = t.getY(e),
                        this._z = t.getZ(e),
                        this._w = t.getW(e),
                        this._onChangeCallback(),
                        this
                    }
                    toJSON() {
                        return this.toArray()
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._w
                    }
                }
                  , J = class fR {
                    constructor(e=0, n=0, i=0) {
                        fR.prototype.isVector3 = !0,
                        this.x = e,
                        this.y = n,
                        this.z = i
                    }
                    set(e, n, i) {
                        return i === void 0 && (i = this.z),
                        this.x = e,
                        this.y = n,
                        this.z = i,
                        this
                    }
                    setScalar(e) {
                        return this.x = e,
                        this.y = e,
                        this.z = e,
                        this
                    }
                    setX(e) {
                        return this.x = e,
                        this
                    }
                    setY(e) {
                        return this.y = e,
                        this
                    }
                    setZ(e) {
                        return this.z = e,
                        this
                    }
                    setComponent(e, n) {
                        switch (e) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                        return this
                    }
                    getComponent(e) {
                        switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z)
                    }
                    copy(e) {
                        return this.x = e.x,
                        this.y = e.y,
                        this.z = e.z,
                        this
                    }
                    add(e) {
                        return this.x += e.x,
                        this.y += e.y,
                        this.z += e.z,
                        this
                    }
                    addScalar(e) {
                        return this.x += e,
                        this.y += e,
                        this.z += e,
                        this
                    }
                    addVectors(e, n) {
                        return this.x = e.x + n.x,
                        this.y = e.y + n.y,
                        this.z = e.z + n.z,
                        this
                    }
                    addScaledVector(e, n) {
                        return this.x += e.x * n,
                        this.y += e.y * n,
                        this.z += e.z * n,
                        this
                    }
                    sub(e) {
                        return this.x -= e.x,
                        this.y -= e.y,
                        this.z -= e.z,
                        this
                    }
                    subScalar(e) {
                        return this.x -= e,
                        this.y -= e,
                        this.z -= e,
                        this
                    }
                    subVectors(e, n) {
                        return this.x = e.x - n.x,
                        this.y = e.y - n.y,
                        this.z = e.z - n.z,
                        this
                    }
                    multiply(e) {
                        return this.x *= e.x,
                        this.y *= e.y,
                        this.z *= e.z,
                        this
                    }
                    multiplyScalar(e) {
                        return this.x *= e,
                        this.y *= e,
                        this.z *= e,
                        this
                    }
                    multiplyVectors(e, n) {
                        return this.x = e.x * n.x,
                        this.y = e.y * n.y,
                        this.z = e.z * n.z,
                        this
                    }
                    applyEuler(e) {
                        return this.applyQuaternion(Q1.setFromEuler(e))
                    }
                    applyAxisAngle(e, n) {
                        return this.applyQuaternion(Q1.setFromAxisAngle(e, n))
                    }
                    applyMatrix3(e) {
                        const n = this.x
                          , i = this.y
                          , a = this.z
                          , o = e.elements;
                        return this.x = o[0] * n + o[3] * i + o[6] * a,
                        this.y = o[1] * n + o[4] * i + o[7] * a,
                        this.z = o[2] * n + o[5] * i + o[8] * a,
                        this
                    }
                    applyNormalMatrix(e) {
                        return this.applyMatrix3(e).normalize()
                    }
                    applyMatrix4(e) {
                        const n = this.x
                          , i = this.y
                          , a = this.z
                          , o = e.elements
                          , u = 1 / (o[3] * n + o[7] * i + o[11] * a + o[15]);
                        return this.x = (o[0] * n + o[4] * i + o[8] * a + o[12]) * u,
                        this.y = (o[1] * n + o[5] * i + o[9] * a + o[13]) * u,
                        this.z = (o[2] * n + o[6] * i + o[10] * a + o[14]) * u,
                        this
                    }
                    applyQuaternion(e) {
                        const n = this.x
                          , i = this.y
                          , a = this.z
                          , o = e.x
                          , u = e.y
                          , f = e.z
                          , d = e.w
                          , p = 2 * (u * a - f * i)
                          , g = 2 * (f * n - o * a)
                          , v = 2 * (o * i - u * n);
                        return this.x = n + d * p + u * v - f * g,
                        this.y = i + d * g + f * p - o * v,
                        this.z = a + d * v + o * g - u * p,
                        this
                    }
                    project(e) {
                        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                    }
                    unproject(e) {
                        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                    }
                    transformDirection(e) {
                        const n = this.x
                          , i = this.y
                          , a = this.z
                          , o = e.elements;
                        return this.x = o[0] * n + o[4] * i + o[8] * a,
                        this.y = o[1] * n + o[5] * i + o[9] * a,
                        this.z = o[2] * n + o[6] * i + o[10] * a,
                        this.normalize()
                    }
                    divide(e) {
                        return this.x /= e.x,
                        this.y /= e.y,
                        this.z /= e.z,
                        this
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e)
                    }
                    min(e) {
                        return this.x = Math.min(this.x, e.x),
                        this.y = Math.min(this.y, e.y),
                        this.z = Math.min(this.z, e.z),
                        this
                    }
                    max(e) {
                        return this.x = Math.max(this.x, e.x),
                        this.y = Math.max(this.y, e.y),
                        this.z = Math.max(this.z, e.z),
                        this
                    }
                    clamp(e, n) {
                        return this.x = Ht(this.x, e.x, n.x),
                        this.y = Ht(this.y, e.y, n.y),
                        this.z = Ht(this.z, e.z, n.z),
                        this
                    }
                    clampScalar(e, n) {
                        return this.x = Ht(this.x, e, n),
                        this.y = Ht(this.y, e, n),
                        this.z = Ht(this.z, e, n),
                        this
                    }
                    clampLength(e, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Ht(i, e, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                    lerp(e, n) {
                        return this.x += (e.x - this.x) * n,
                        this.y += (e.y - this.y) * n,
                        this.z += (e.z - this.z) * n,
                        this
                    }
                    lerpVectors(e, n, i) {
                        return this.x = e.x + (n.x - e.x) * i,
                        this.y = e.y + (n.y - e.y) * i,
                        this.z = e.z + (n.z - e.z) * i,
                        this
                    }
                    cross(e) {
                        return this.crossVectors(this, e)
                    }
                    crossVectors(e, n) {
                        const i = e.x
                          , a = e.y
                          , o = e.z
                          , u = n.x
                          , f = n.y
                          , d = n.z;
                        return this.x = a * d - o * f,
                        this.y = o * u - i * d,
                        this.z = i * f - a * u,
                        this
                    }
                    projectOnVector(e) {
                        const n = e.lengthSq();
                        if (n === 0)
                            return this.set(0, 0, 0);
                        const i = e.dot(this) / n;
                        return this.copy(e).multiplyScalar(i)
                    }
                    projectOnPlane(e) {
                        return Ux.copy(this).projectOnVector(e),
                        this.sub(Ux)
                    }
                    reflect(e) {
                        return this.sub(Ux.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                    angleTo(e) {
                        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const i = this.dot(e) / n;
                        return Math.acos(Ht(i, -1, 1))
                    }
                    distanceTo(e) {
                        return Math.sqrt(this.distanceToSquared(e))
                    }
                    distanceToSquared(e) {
                        const n = this.x - e.x
                          , i = this.y - e.y
                          , a = this.z - e.z;
                        return n * n + i * i + a * a
                    }
                    manhattanDistanceTo(e) {
                        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                    }
                    setFromSpherical(e) {
                        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                    }
                    setFromSphericalCoords(e, n, i) {
                        const a = Math.sin(n) * e;
                        return this.x = a * Math.sin(i),
                        this.y = Math.cos(n) * e,
                        this.z = a * Math.cos(i),
                        this
                    }
                    setFromCylindrical(e) {
                        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                    }
                    setFromCylindricalCoords(e, n, i) {
                        return this.x = e * Math.sin(n),
                        this.y = i,
                        this.z = e * Math.cos(n),
                        this
                    }
                    setFromMatrixPosition(e) {
                        const n = e.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this
                    }
                    setFromMatrixScale(e) {
                        const n = this.setFromMatrixColumn(e, 0).length()
                          , i = this.setFromMatrixColumn(e, 1).length()
                          , a = this.setFromMatrixColumn(e, 2).length();
                        return this.x = n,
                        this.y = i,
                        this.z = a,
                        this
                    }
                    setFromMatrixColumn(e, n) {
                        return this.fromArray(e.elements, n * 4)
                    }
                    setFromMatrix3Column(e, n) {
                        return this.fromArray(e.elements, n * 3)
                    }
                    setFromEuler(e) {
                        return this.x = e._x,
                        this.y = e._y,
                        this.z = e._z,
                        this
                    }
                    setFromColor(e) {
                        return this.x = e.r,
                        this.y = e.g,
                        this.z = e.b,
                        this
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y && e.z === this.z
                    }
                    fromArray(e, n=0) {
                        return this.x = e[n],
                        this.y = e[n + 1],
                        this.z = e[n + 2],
                        this
                    }
                    toArray(e=[], n=0) {
                        return e[n] = this.x,
                        e[n + 1] = this.y,
                        e[n + 2] = this.z,
                        e
                    }
                    fromBufferAttribute(e, n) {
                        return this.x = e.getX(n),
                        this.y = e.getY(n),
                        this.z = e.getZ(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this
                    }
                    randomDirection() {
                        const e = Math.random() * Math.PI * 2
                          , n = Math.random() * 2 - 1
                          , i = Math.sqrt(1 - n * n);
                        return this.x = i * Math.cos(e),
                        this.y = n,
                        this.z = i * Math.sin(e),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z
                    }
                }
                ;
                const Ux = new J
                  , Q1 = new za;
                var sn = class dR {
                    constructor(e, n, i, a, o, u, f, d, p) {
                        dR.prototype.isMatrix3 = !0,
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        e !== void 0 && this.set(e, n, i, a, o, u, f, d, p)
                    }
                    set(e, n, i, a, o, u, f, d, p) {
                        const g = this.elements;
                        return g[0] = e,
                        g[1] = a,
                        g[2] = f,
                        g[3] = n,
                        g[4] = o,
                        g[5] = d,
                        g[6] = i,
                        g[7] = u,
                        g[8] = p,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                    }
                    copy(e) {
                        const n = this.elements
                          , i = e.elements;
                        return n[0] = i[0],
                        n[1] = i[1],
                        n[2] = i[2],
                        n[3] = i[3],
                        n[4] = i[4],
                        n[5] = i[5],
                        n[6] = i[6],
                        n[7] = i[7],
                        n[8] = i[8],
                        this
                    }
                    extractBasis(e, n, i) {
                        return e.setFromMatrix3Column(this, 0),
                        n.setFromMatrix3Column(this, 1),
                        i.setFromMatrix3Column(this, 2),
                        this
                    }
                    setFromMatrix4(e) {
                        const n = e.elements;
                        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]),
                        this
                    }
                    multiply(e) {
                        return this.multiplyMatrices(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyMatrices(e, this)
                    }
                    multiplyMatrices(e, n) {
                        const i = e.elements
                          , a = n.elements
                          , o = this.elements
                          , u = i[0]
                          , f = i[3]
                          , d = i[6]
                          , p = i[1]
                          , g = i[4]
                          , v = i[7]
                          , y = i[2]
                          , S = i[5]
                          , E = i[8]
                          , w = a[0]
                          , A = a[3]
                          , T = a[6]
                          , R = a[1]
                          , N = a[4]
                          , D = a[7]
                          , U = a[2]
                          , z = a[5]
                          , I = a[8];
                        return o[0] = u * w + f * R + d * U,
                        o[3] = u * A + f * N + d * z,
                        o[6] = u * T + f * D + d * I,
                        o[1] = p * w + g * R + v * U,
                        o[4] = p * A + g * N + v * z,
                        o[7] = p * T + g * D + v * I,
                        o[2] = y * w + S * R + E * U,
                        o[5] = y * A + S * N + E * z,
                        o[8] = y * T + S * D + E * I,
                        this
                    }
                    multiplyScalar(e) {
                        const n = this.elements;
                        return n[0] *= e,
                        n[3] *= e,
                        n[6] *= e,
                        n[1] *= e,
                        n[4] *= e,
                        n[7] *= e,
                        n[2] *= e,
                        n[5] *= e,
                        n[8] *= e,
                        this
                    }
                    determinant() {
                        const e = this.elements
                          , n = e[0]
                          , i = e[1]
                          , a = e[2]
                          , o = e[3]
                          , u = e[4]
                          , f = e[5]
                          , d = e[6]
                          , p = e[7]
                          , g = e[8];
                        return n * u * g - n * f * p - i * o * g + i * f * d + a * o * p - a * u * d
                    }
                    invert() {
                        const e = this.elements
                          , n = e[0]
                          , i = e[1]
                          , a = e[2]
                          , o = e[3]
                          , u = e[4]
                          , f = e[5]
                          , d = e[6]
                          , p = e[7]
                          , g = e[8]
                          , v = g * u - f * p
                          , y = f * d - g * o
                          , S = p * o - u * d
                          , E = n * v + i * y + a * S;
                        if (E === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const w = 1 / E;
                        return e[0] = v * w,
                        e[1] = (a * p - g * i) * w,
                        e[2] = (f * i - a * u) * w,
                        e[3] = y * w,
                        e[4] = (g * n - a * d) * w,
                        e[5] = (a * o - f * n) * w,
                        e[6] = S * w,
                        e[7] = (i * d - p * n) * w,
                        e[8] = (u * n - i * o) * w,
                        this
                    }
                    transpose() {
                        let e;
                        const n = this.elements;
                        return e = n[1],
                        n[1] = n[3],
                        n[3] = e,
                        e = n[2],
                        n[2] = n[6],
                        n[6] = e,
                        e = n[5],
                        n[5] = n[7],
                        n[7] = e,
                        this
                    }
                    getNormalMatrix(e) {
                        return this.setFromMatrix4(e).invert().transpose()
                    }
                    transposeIntoArray(e) {
                        const n = this.elements;
                        return e[0] = n[0],
                        e[1] = n[3],
                        e[2] = n[6],
                        e[3] = n[1],
                        e[4] = n[4],
                        e[5] = n[7],
                        e[6] = n[2],
                        e[7] = n[5],
                        e[8] = n[8],
                        this
                    }
                    setUvTransform(e, n, i, a, o, u, f) {
                        const d = Math.cos(o)
                          , p = Math.sin(o);
                        return this.set(i * d, i * p, -i * (d * u + p * f) + u + e, -a * p, a * d, -a * (-p * u + d * f) + f + n, 0, 0, 1),
                        this
                    }
                    scale(e, n) {
                        return this.premultiply(Lx.makeScale(e, n)),
                        this
                    }
                    rotate(e) {
                        return this.premultiply(Lx.makeRotation(-e)),
                        this
                    }
                    translate(e, n) {
                        return this.premultiply(Lx.makeTranslation(e, n)),
                        this
                    }
                    makeTranslation(e, n) {
                        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
                        this
                    }
                    makeRotation(e) {
                        const n = Math.cos(e)
                          , i = Math.sin(e);
                        return this.set(n, -i, 0, i, n, 0, 0, 0, 1),
                        this
                    }
                    makeScale(e, n) {
                        return this.set(e, 0, 0, 0, n, 0, 0, 0, 1),
                        this
                    }
                    equals(e) {
                        const n = this.elements
                          , i = e.elements;
                        for (let a = 0; a < 9; a++)
                            if (n[a] !== i[a])
                                return !1;
                        return !0
                    }
                    fromArray(e, n=0) {
                        for (let i = 0; i < 9; i++)
                            this.elements[i] = e[i + n];
                        return this
                    }
                    toArray(e=[], n=0) {
                        const i = this.elements;
                        return e[n] = i[0],
                        e[n + 1] = i[1],
                        e[n + 2] = i[2],
                        e[n + 3] = i[3],
                        e[n + 4] = i[4],
                        e[n + 5] = i[5],
                        e[n + 6] = i[6],
                        e[n + 7] = i[7],
                        e[n + 8] = i[8],
                        e
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements)
                    }
                }
                ;
                const Lx = new sn
                  , K1 = new sn().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
                  , J1 = new sn().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
                function $D() {
                    const t = {
                        enabled: !0,
                        workingColorSpace: tu,
                        spaces: {},
                        convert: function(a, o, u) {
                            return this.enabled === !1 || o === u || !o || !u || (this.spaces[o].transfer === Vn && (a.r = tc(a.r),
                            a.g = tc(a.g),
                            a.b = tc(a.b)),
                            this.spaces[o].primaries !== this.spaces[u].primaries && (a.applyMatrix3(this.spaces[o].toXYZ),
                            a.applyMatrix3(this.spaces[u].fromXYZ)),
                            this.spaces[u].transfer === Vn && (a.r = Nd(a.r),
                            a.g = Nd(a.g),
                            a.b = Nd(a.b))),
                            a
                        },
                        workingToColorSpace: function(a, o) {
                            return this.convert(a, this.workingColorSpace, o)
                        },
                        colorSpaceToWorking: function(a, o) {
                            return this.convert(a, o, this.workingColorSpace)
                        },
                        getPrimaries: function(a) {
                            return this.spaces[a].primaries
                        },
                        getTransfer: function(a) {
                            return a === ec ? gg : this.spaces[a].transfer
                        },
                        getToneMappingMode: function(a) {
                            return this.spaces[a].outputColorSpaceConfig.toneMappingMode || "standard"
                        },
                        getLuminanceCoefficients: function(a, o=this.workingColorSpace) {
                            return a.fromArray(this.spaces[o].luminanceCoefficients)
                        },
                        define: function(a) {
                            Object.assign(this.spaces, a)
                        },
                        _getMatrix: function(a, o, u) {
                            return a.copy(this.spaces[o].toXYZ).multiply(this.spaces[u].fromXYZ)
                        },
                        _getDrawingBufferColorSpace: function(a) {
                            return this.spaces[a].outputColorSpaceConfig.drawingBufferColorSpace
                        },
                        _getUnpackColorSpace: function(a=this.workingColorSpace) {
                            return this.spaces[a].workingColorSpaceConfig.unpackColorSpace
                        },
                        fromWorkingColorSpace: function(a, o) {
                            return wd("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
                            t.workingToColorSpace(a, o)
                        },
                        toWorkingColorSpace: function(a, o) {
                            return wd("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
                            t.colorSpaceToWorking(a, o)
                        }
                    }
                      , e = [.64, .33, .3, .6, .15, .06]
                      , n = [.2126, .7152, .0722]
                      , i = [.3127, .329];
                    return t.define({
                        [tu]: {
                            primaries: e,
                            whitePoint: i,
                            transfer: gg,
                            toXYZ: K1,
                            fromXYZ: J1,
                            luminanceCoefficients: n,
                            workingColorSpaceConfig: {
                                unpackColorSpace: Gs
                            },
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: Gs
                            }
                        },
                        [Gs]: {
                            primaries: e,
                            whitePoint: i,
                            transfer: Vn,
                            toXYZ: K1,
                            fromXYZ: J1,
                            luminanceCoefficients: n,
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: Gs
                            }
                        }
                    }),
                    t
                }
                const xn = $D();
                function tc(t) {
                    return t < .04045 ? t * .0773993808 : Math.pow(t * .9478672986 + .0521327014, 2.4)
                }
                function Nd(t) {
                    return t < .0031308 ? t * 12.92 : 1.055 * Math.pow(t, .41666) - .055
                }
                let Dd;
                var $1 = class {
                    static getDataURL(t, e="image/png") {
                        if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
                            return t.src;
                        let n;
                        if (t instanceof HTMLCanvasElement)
                            n = t;
                        else {
                            Dd === void 0 && (Dd = _g("canvas")),
                            Dd.width = t.width,
                            Dd.height = t.height;
                            const i = Dd.getContext("2d");
                            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height),
                            n = Dd
                        }
                        return n.toDataURL(e)
                    }
                    static sRGBToLinear(t) {
                        if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
                            const e = _g("canvas");
                            e.width = t.width,
                            e.height = t.height;
                            const n = e.getContext("2d");
                            n.drawImage(t, 0, 0, t.width, t.height);
                            const i = n.getImageData(0, 0, t.width, t.height)
                              , a = i.data;
                            for (let o = 0; o < a.length; o++)
                                a[o] = tc(a[o] / 255) * 255;
                            return n.putImageData(i, 0, 0),
                            e
                        } else if (t.data) {
                            const e = t.data.slice(0);
                            for (let n = 0; n < e.length; n++)
                                e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(tc(e[n] / 255) * 255) : e[n] = tc(e[n]);
                            return {
                                data: e,
                                width: t.width,
                                height: t.height
                            }
                        } else
                            return at("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                            t
                    }
                }
                ;
                let eO = 0;
                var iu = class {
                    constructor(t=null) {
                        this.isSource = !0,
                        Object.defineProperty(this, "id", {
                            value: eO++
                        }),
                        this.uuid = ir(),
                        this.data = t,
                        this.dataReady = !0,
                        this.version = 0
                    }
                    getSize(t) {
                        const e = this.data;
                        return typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement ? t.set(e.videoWidth, e.videoHeight, 0) : typeof VideoFrame < "u" && e instanceof VideoFrame ? t.set(e.displayHeight, e.displayWidth, 0) : e !== null ? t.set(e.width, e.height, e.depth || 0) : t.set(0, 0, 0),
                        t
                    }
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    }
                    toJSON(t) {
                        const e = t === void 0 || typeof t == "string";
                        if (!e && t.images[this.uuid] !== void 0)
                            return t.images[this.uuid];
                        const n = {
                            uuid: this.uuid,
                            url: ""
                        }
                          , i = this.data;
                        if (i !== null) {
                            let a;
                            if (Array.isArray(i)) {
                                a = [];
                                for (let o = 0, u = i.length; o < u; o++)
                                    i[o].isDataTexture ? a.push(Ix(i[o].image)) : a.push(Ix(i[o]))
                            } else
                                a = Ix(i);
                            n.url = a
                        }
                        return e || (t.images[this.uuid] = n),
                        n
                    }
                }
                ;
                function Ix(t) {
                    return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? $1.getDataURL(t) : t.data ? {
                        data: Array.from(t.data),
                        width: t.width,
                        height: t.height,
                        type: t.data.constructor.name
                    } : (at("Texture: Unable to serialize Texture."),
                    {})
                }
                let tO = 0;
                const zx = new J;
                var gs = class AS extends cl {
                    constructor(e=AS.DEFAULT_IMAGE, n=AS.DEFAULT_MAPPING, i=Ia, a=Ia, o=fi, u=rl, f=Hs, d=da, p=AS.DEFAULT_ANISOTROPY, g=ec) {
                        super(),
                        this.isTexture = !0,
                        Object.defineProperty(this, "id", {
                            value: tO++
                        }),
                        this.uuid = ir(),
                        this.name = "",
                        this.source = new iu(e),
                        this.mipmaps = [],
                        this.mapping = n,
                        this.channel = 0,
                        this.wrapS = i,
                        this.wrapT = a,
                        this.magFilter = o,
                        this.minFilter = u,
                        this.anisotropy = p,
                        this.format = f,
                        this.internalFormat = null,
                        this.type = d,
                        this.offset = new Ge(0,0),
                        this.repeat = new Ge(1,1),
                        this.center = new Ge(0,0),
                        this.rotation = 0,
                        this.matrixAutoUpdate = !0,
                        this.matrix = new sn,
                        this.generateMipmaps = !0,
                        this.premultiplyAlpha = !1,
                        this.flipY = !0,
                        this.unpackAlignment = 4,
                        this.colorSpace = g,
                        this.userData = {},
                        this.updateRanges = [],
                        this.version = 0,
                        this.onUpdate = null,
                        this.renderTarget = null,
                        this.isRenderTargetTexture = !1,
                        this.isArrayTexture = !!(e && e.depth && e.depth > 1),
                        this.pmremVersion = 0
                    }
                    get width() {
                        return this.source.getSize(zx).x
                    }
                    get height() {
                        return this.source.getSize(zx).y
                    }
                    get depth() {
                        return this.source.getSize(zx).z
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(e=null) {
                        this.source.data = e
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    addUpdateRange(e, n) {
                        this.updateRanges.push({
                            start: e,
                            count: n
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.name = e.name,
                        this.source = e.source,
                        this.mipmaps = e.mipmaps.slice(0),
                        this.mapping = e.mapping,
                        this.channel = e.channel,
                        this.wrapS = e.wrapS,
                        this.wrapT = e.wrapT,
                        this.magFilter = e.magFilter,
                        this.minFilter = e.minFilter,
                        this.anisotropy = e.anisotropy,
                        this.format = e.format,
                        this.internalFormat = e.internalFormat,
                        this.type = e.type,
                        this.offset.copy(e.offset),
                        this.repeat.copy(e.repeat),
                        this.center.copy(e.center),
                        this.rotation = e.rotation,
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this.matrix.copy(e.matrix),
                        this.generateMipmaps = e.generateMipmaps,
                        this.premultiplyAlpha = e.premultiplyAlpha,
                        this.flipY = e.flipY,
                        this.unpackAlignment = e.unpackAlignment,
                        this.colorSpace = e.colorSpace,
                        this.renderTarget = e.renderTarget,
                        this.isRenderTargetTexture = e.isRenderTargetTexture,
                        this.isArrayTexture = e.isArrayTexture,
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        this.needsUpdate = !0,
                        this
                    }
                    setValues(e) {
                        for (const n in e) {
                            const i = e[n];
                            if (i === void 0) {
                                at(`Texture.setValues(): parameter '${n}' has value of undefined.`);
                                continue
                            }
                            const a = this[n];
                            if (a === void 0) {
                                at(`Texture.setValues(): property '${n}' does not exist.`);
                                continue
                            }
                            a && i && a.isVector2 && i.isVector2 || a && i && a.isVector3 && i.isVector3 || a && i && a.isMatrix3 && i.isMatrix3 ? a.copy(i) : this[n] = i
                        }
                    }
                    toJSON(e) {
                        const n = e === void 0 || typeof e == "string";
                        if (!n && e.textures[this.uuid] !== void 0)
                            return e.textures[this.uuid];
                        const i = {
                            metadata: {
                                version: 4.7,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(e).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                        n || (e.textures[this.uuid] = i),
                        i
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(e) {
                        if (this.mapping !== Y_)
                            return e;
                        if (e.applyMatrix3(this.matrix),
                        e.x < 0 || e.x > 1)
                            switch (this.wrapS) {
                            case rg:
                                e.x = e.x - Math.floor(e.x);
                                break;
                            case Ia:
                                e.x = e.x < 0 ? 0 : 1;
                                break;
                            case og:
                                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                                break
                            }
                        if (e.y < 0 || e.y > 1)
                            switch (this.wrapT) {
                            case rg:
                                e.y = e.y - Math.floor(e.y);
                                break;
                            case Ia:
                                e.y = e.y < 0 ? 0 : 1;
                                break;
                            case og:
                                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                                break
                            }
                        return this.flipY && (e.y = 1 - e.y),
                        e
                    }
                    set needsUpdate(e) {
                        e === !0 && (this.version++,
                        this.source.needsUpdate = !0)
                    }
                    set needsPMREMUpdate(e) {
                        e === !0 && this.pmremVersion++
                    }
                }
                ;
                gs.DEFAULT_IMAGE = null,
                gs.DEFAULT_MAPPING = Y_,
                gs.DEFAULT_ANISOTROPY = 1;
                var di = class pR {
                    constructor(e=0, n=0, i=0, a=1) {
                        pR.prototype.isVector4 = !0,
                        this.x = e,
                        this.y = n,
                        this.z = i,
                        this.w = a
                    }
                    get width() {
                        return this.z
                    }
                    set width(e) {
                        this.z = e
                    }
                    get height() {
                        return this.w
                    }
                    set height(e) {
                        this.w = e
                    }
                    set(e, n, i, a) {
                        return this.x = e,
                        this.y = n,
                        this.z = i,
                        this.w = a,
                        this
                    }
                    setScalar(e) {
                        return this.x = e,
                        this.y = e,
                        this.z = e,
                        this.w = e,
                        this
                    }
                    setX(e) {
                        return this.x = e,
                        this
                    }
                    setY(e) {
                        return this.y = e,
                        this
                    }
                    setZ(e) {
                        return this.z = e,
                        this
                    }
                    setW(e) {
                        return this.w = e,
                        this
                    }
                    setComponent(e, n) {
                        switch (e) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        case 3:
                            this.w = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                        return this
                    }
                    getComponent(e) {
                        switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z,this.w)
                    }
                    copy(e) {
                        return this.x = e.x,
                        this.y = e.y,
                        this.z = e.z,
                        this.w = e.w !== void 0 ? e.w : 1,
                        this
                    }
                    add(e) {
                        return this.x += e.x,
                        this.y += e.y,
                        this.z += e.z,
                        this.w += e.w,
                        this
                    }
                    addScalar(e) {
                        return this.x += e,
                        this.y += e,
                        this.z += e,
                        this.w += e,
                        this
                    }
                    addVectors(e, n) {
                        return this.x = e.x + n.x,
                        this.y = e.y + n.y,
                        this.z = e.z + n.z,
                        this.w = e.w + n.w,
                        this
                    }
                    addScaledVector(e, n) {
                        return this.x += e.x * n,
                        this.y += e.y * n,
                        this.z += e.z * n,
                        this.w += e.w * n,
                        this
                    }
                    sub(e) {
                        return this.x -= e.x,
                        this.y -= e.y,
                        this.z -= e.z,
                        this.w -= e.w,
                        this
                    }
                    subScalar(e) {
                        return this.x -= e,
                        this.y -= e,
                        this.z -= e,
                        this.w -= e,
                        this
                    }
                    subVectors(e, n) {
                        return this.x = e.x - n.x,
                        this.y = e.y - n.y,
                        this.z = e.z - n.z,
                        this.w = e.w - n.w,
                        this
                    }
                    multiply(e) {
                        return this.x *= e.x,
                        this.y *= e.y,
                        this.z *= e.z,
                        this.w *= e.w,
                        this
                    }
                    multiplyScalar(e) {
                        return this.x *= e,
                        this.y *= e,
                        this.z *= e,
                        this.w *= e,
                        this
                    }
                    applyMatrix4(e) {
                        const n = this.x
                          , i = this.y
                          , a = this.z
                          , o = this.w
                          , u = e.elements;
                        return this.x = u[0] * n + u[4] * i + u[8] * a + u[12] * o,
                        this.y = u[1] * n + u[5] * i + u[9] * a + u[13] * o,
                        this.z = u[2] * n + u[6] * i + u[10] * a + u[14] * o,
                        this.w = u[3] * n + u[7] * i + u[11] * a + u[15] * o,
                        this
                    }
                    divide(e) {
                        return this.x /= e.x,
                        this.y /= e.y,
                        this.z /= e.z,
                        this.w /= e.w,
                        this
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e)
                    }
                    setAxisAngleFromQuaternion(e) {
                        this.w = 2 * Math.acos(e.w);
                        const n = Math.sqrt(1 - e.w * e.w);
                        return n < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = e.x / n,
                        this.y = e.y / n,
                        this.z = e.z / n),
                        this
                    }
                    setAxisAngleFromRotationMatrix(e) {
                        let n, i, a, o;
                        const d = e.elements
                          , p = d[0]
                          , g = d[4]
                          , v = d[8]
                          , y = d[1]
                          , S = d[5]
                          , E = d[9]
                          , w = d[2]
                          , A = d[6]
                          , T = d[10];
                        if (Math.abs(g - y) < .01 && Math.abs(v - w) < .01 && Math.abs(E - A) < .01) {
                            if (Math.abs(g + y) < .1 && Math.abs(v + w) < .1 && Math.abs(E + A) < .1 && Math.abs(p + S + T - 3) < .1)
                                return this.set(1, 0, 0, 0),
                                this;
                            n = Math.PI;
                            const N = (p + 1) / 2
                              , D = (S + 1) / 2
                              , U = (T + 1) / 2
                              , z = (g + y) / 4
                              , I = (v + w) / 4
                              , V = (E + A) / 4;
                            return N > D && N > U ? N < .01 ? (i = 0,
                            a = .707106781,
                            o = .707106781) : (i = Math.sqrt(N),
                            a = z / i,
                            o = I / i) : D > U ? D < .01 ? (i = .707106781,
                            a = 0,
                            o = .707106781) : (a = Math.sqrt(D),
                            i = z / a,
                            o = V / a) : U < .01 ? (i = .707106781,
                            a = .707106781,
                            o = 0) : (o = Math.sqrt(U),
                            i = I / o,
                            a = V / o),
                            this.set(i, a, o, n),
                            this
                        }
                        let R = Math.sqrt((A - E) * (A - E) + (v - w) * (v - w) + (y - g) * (y - g));
                        return Math.abs(R) < .001 && (R = 1),
                        this.x = (A - E) / R,
                        this.y = (v - w) / R,
                        this.z = (y - g) / R,
                        this.w = Math.acos((p + S + T - 1) / 2),
                        this
                    }
                    setFromMatrixPosition(e) {
                        const n = e.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this.w = n[15],
                        this
                    }
                    min(e) {
                        return this.x = Math.min(this.x, e.x),
                        this.y = Math.min(this.y, e.y),
                        this.z = Math.min(this.z, e.z),
                        this.w = Math.min(this.w, e.w),
                        this
                    }
                    max(e) {
                        return this.x = Math.max(this.x, e.x),
                        this.y = Math.max(this.y, e.y),
                        this.z = Math.max(this.z, e.z),
                        this.w = Math.max(this.w, e.w),
                        this
                    }
                    clamp(e, n) {
                        return this.x = Ht(this.x, e.x, n.x),
                        this.y = Ht(this.y, e.y, n.y),
                        this.z = Ht(this.z, e.z, n.z),
                        this.w = Ht(this.w, e.w, n.w),
                        this
                    }
                    clampScalar(e, n) {
                        return this.x = Ht(this.x, e, n),
                        this.y = Ht(this.y, e, n),
                        this.z = Ht(this.z, e, n),
                        this.w = Ht(this.w, e, n),
                        this
                    }
                    clampLength(e, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Ht(i, e, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this.w = Math.trunc(this.w),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                    lerp(e, n) {
                        return this.x += (e.x - this.x) * n,
                        this.y += (e.y - this.y) * n,
                        this.z += (e.z - this.z) * n,
                        this.w += (e.w - this.w) * n,
                        this
                    }
                    lerpVectors(e, n, i) {
                        return this.x = e.x + (n.x - e.x) * i,
                        this.y = e.y + (n.y - e.y) * i,
                        this.z = e.z + (n.z - e.z) * i,
                        this.w = e.w + (n.w - e.w) * i,
                        this
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                    }
                    fromArray(e, n=0) {
                        return this.x = e[n],
                        this.y = e[n + 1],
                        this.z = e[n + 2],
                        this.w = e[n + 3],
                        this
                    }
                    toArray(e=[], n=0) {
                        return e[n] = this.x,
                        e[n + 1] = this.y,
                        e[n + 2] = this.z,
                        e[n + 3] = this.w,
                        e
                    }
                    fromBufferAttribute(e, n) {
                        return this.x = e.getX(n),
                        this.y = e.getY(n),
                        this.z = e.getZ(n),
                        this.w = e.getW(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this.w = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z,
                        yield this.w
                    }
                }
                  , Bx = class extends cl {
                    constructor(t=1, e=1, n={}) {
                        super(),
                        n = Object.assign({
                            generateMipmaps: !1,
                            internalFormat: null,
                            minFilter: fi,
                            depthBuffer: !0,
                            stencilBuffer: !1,
                            resolveDepthBuffer: !0,
                            resolveStencilBuffer: !0,
                            depthTexture: null,
                            samples: 0,
                            count: 1,
                            depth: 1,
                            multiview: !1
                        }, n),
                        this.isRenderTarget = !0,
                        this.width = t,
                        this.height = e,
                        this.depth = n.depth,
                        this.scissor = new di(0,0,t,e),
                        this.scissorTest = !1,
                        this.viewport = new di(0,0,t,e);
                        const i = new gs({
                            width: t,
                            height: e,
                            depth: n.depth
                        });
                        this.textures = [];
                        const a = n.count;
                        for (let o = 0; o < a; o++)
                            this.textures[o] = i.clone(),
                            this.textures[o].isRenderTargetTexture = !0,
                            this.textures[o].renderTarget = this;
                        this._setTextureOptions(n),
                        this.depthBuffer = n.depthBuffer,
                        this.stencilBuffer = n.stencilBuffer,
                        this.resolveDepthBuffer = n.resolveDepthBuffer,
                        this.resolveStencilBuffer = n.resolveStencilBuffer,
                        this._depthTexture = null,
                        this.depthTexture = n.depthTexture,
                        this.samples = n.samples,
                        this.multiview = n.multiview
                    }
                    _setTextureOptions(t={}) {
                        const e = {
                            minFilter: fi,
                            generateMipmaps: !1,
                            flipY: !1,
                            internalFormat: null
                        };
                        t.mapping !== void 0 && (e.mapping = t.mapping),
                        t.wrapS !== void 0 && (e.wrapS = t.wrapS),
                        t.wrapT !== void 0 && (e.wrapT = t.wrapT),
                        t.wrapR !== void 0 && (e.wrapR = t.wrapR),
                        t.magFilter !== void 0 && (e.magFilter = t.magFilter),
                        t.minFilter !== void 0 && (e.minFilter = t.minFilter),
                        t.format !== void 0 && (e.format = t.format),
                        t.type !== void 0 && (e.type = t.type),
                        t.anisotropy !== void 0 && (e.anisotropy = t.anisotropy),
                        t.colorSpace !== void 0 && (e.colorSpace = t.colorSpace),
                        t.flipY !== void 0 && (e.flipY = t.flipY),
                        t.generateMipmaps !== void 0 && (e.generateMipmaps = t.generateMipmaps),
                        t.internalFormat !== void 0 && (e.internalFormat = t.internalFormat);
                        for (let n = 0; n < this.textures.length; n++)
                            this.textures[n].setValues(e)
                    }
                    get texture() {
                        return this.textures[0]
                    }
                    set texture(t) {
                        this.textures[0] = t
                    }
                    set depthTexture(t) {
                        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
                        t !== null && (t.renderTarget = this),
                        this._depthTexture = t
                    }
                    get depthTexture() {
                        return this._depthTexture
                    }
                    setSize(t, e, n=1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t,
                            this.height = e,
                            this.depth = n;
                            for (let i = 0, a = this.textures.length; i < a; i++)
                                this.textures[i].image.width = t,
                                this.textures[i].image.height = e,
                                this.textures[i].image.depth = n,
                                this.textures[i].isData3DTexture !== !0 && (this.textures[i].isArrayTexture = this.textures[i].image.depth > 1);
                            this.dispose()
                        }
                        this.viewport.set(0, 0, t, e),
                        this.scissor.set(0, 0, t, e)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        this.width = t.width,
                        this.height = t.height,
                        this.depth = t.depth,
                        this.scissor.copy(t.scissor),
                        this.scissorTest = t.scissorTest,
                        this.viewport.copy(t.viewport),
                        this.textures.length = 0;
                        for (let e = 0, n = t.textures.length; e < n; e++) {
                            this.textures[e] = t.textures[e].clone(),
                            this.textures[e].isRenderTargetTexture = !0,
                            this.textures[e].renderTarget = this;
                            const i = Object.assign({}, t.textures[e].image);
                            this.textures[e].source = new iu(i)
                        }
                        return this.depthBuffer = t.depthBuffer,
                        this.stencilBuffer = t.stencilBuffer,
                        this.resolveDepthBuffer = t.resolveDepthBuffer,
                        this.resolveStencilBuffer = t.resolveStencilBuffer,
                        t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()),
                        this.samples = t.samples,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                  , sr = class extends Bx {
                    constructor(t=1, e=1, n={}) {
                        super(t, e, n),
                        this.isWebGLRenderTarget = !0
                    }
                }
                  , B0 = class extends gs {
                    constructor(t=null, e=1, n=1, i=1) {
                        super(null),
                        this.isDataArrayTexture = !0,
                        this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: i
                        },
                        this.magFilter = Vi,
                        this.minFilter = Vi,
                        this.wrapR = Ia,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(t) {
                        this.layerUpdates.add(t)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , nO = class extends sr {
                    constructor(t=1, e=1, n=1, i={}) {
                        super(t, e, i),
                        this.isWebGLArrayRenderTarget = !0,
                        this.depth = n,
                        this.texture = new B0(null,t,e,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , P0 = class extends gs {
                    constructor(t=null, e=1, n=1, i=1) {
                        super(null),
                        this.isData3DTexture = !0,
                        this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: i
                        },
                        this.magFilter = Vi,
                        this.minFilter = Vi,
                        this.wrapR = Ia,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                  , iO = class extends sr {
                    constructor(t=1, e=1, n=1, i={}) {
                        super(t, e, i),
                        this.isWebGL3DRenderTarget = !0,
                        this.depth = n,
                        this.texture = new P0(null,t,e,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , qs = class {
                    constructor(t=new J(1 / 0,1 / 0,1 / 0), e=new J(-1 / 0,-1 / 0,-1 / 0)) {
                        this.isBox3 = !0,
                        this.min = t,
                        this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t),
                        this.max.copy(e),
                        this
                    }
                    setFromArray(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e += 3)
                            this.expandByPoint(mo.fromArray(t, e));
                        return this
                    }
                    setFromBufferAttribute(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.count; e < n; e++)
                            this.expandByPoint(mo.fromBufferAttribute(t, e));
                        return this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++)
                            this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = mo.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n),
                        this.max.copy(t).add(n),
                        this
                    }
                    setFromObject(t, e=!1) {
                        return this.makeEmpty(),
                        this.expandByObject(t, e)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min),
                        this.max.copy(t.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0,
                        this.max.x = this.max.y = this.max.z = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(t) {
                        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t),
                        this.max.max(t),
                        this
                    }
                    expandByVector(t) {
                        return this.min.sub(t),
                        this.max.add(t),
                        this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t),
                        this.max.addScalar(t),
                        this
                    }
                    expandByObject(t, e=!1) {
                        t.updateWorldMatrix(!1, !1);
                        const n = t.geometry;
                        if (n !== void 0) {
                            const a = n.getAttribute("position");
                            if (e === !0 && a !== void 0 && t.isInstancedMesh !== !0)
                                for (let o = 0, u = a.count; o < u; o++)
                                    t.isMesh === !0 ? t.getVertexPosition(o, mo) : mo.fromBufferAttribute(a, o),
                                    mo.applyMatrix4(t.matrixWorld),
                                    this.expandByPoint(mo);
                            else
                                t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(),
                                V0.copy(t.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                                V0.copy(n.boundingBox)),
                                V0.applyMatrix4(t.matrixWorld),
                                this.union(V0)
                        }
                        const i = t.children;
                        for (let a = 0, o = i.length; a < o; a++)
                            this.expandByObject(i[a], e);
                        return this
                    }
                    containsPoint(t) {
                        return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                    }
                    getParameter(t, e) {
                        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(t) {
                        return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z
                    }
                    intersectsSphere(t) {
                        return this.clampPoint(t.center, mo),
                        mo.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                    intersectsPlane(t) {
                        let e, n;
                        return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                        n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                        n = t.normal.x * this.min.x),
                        t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                        n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                        n += t.normal.y * this.min.y),
                        t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                        n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                        n += t.normal.z * this.min.z),
                        e <= -t.constant && n >= -t.constant
                    }
                    intersectsTriangle(t) {
                        if (this.isEmpty())
                            return !1;
                        this.getCenter(xg),
                        F0.subVectors(this.max, xg),
                        Od.subVectors(t.a, xg),
                        Ud.subVectors(t.b, xg),
                        Ld.subVectors(t.c, xg),
                        su.subVectors(Ud, Od),
                        au.subVectors(Ld, Ud),
                        Eh.subVectors(Od, Ld);
                        let e = [0, -su.z, su.y, 0, -au.z, au.y, 0, -Eh.z, Eh.y, su.z, 0, -su.x, au.z, 0, -au.x, Eh.z, 0, -Eh.x, -su.y, su.x, 0, -au.y, au.x, 0, -Eh.y, Eh.x, 0];
                        return !Px(e, Od, Ud, Ld, F0) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        !Px(e, Od, Ud, Ld, F0)) ? !1 : (H0.crossVectors(su, au),
                        e = [H0.x, H0.y, H0.z],
                        Px(e, Od, Ud, Ld, F0))
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return this.clampPoint(t, mo).distanceTo(t)
                    }
                    getBoundingSphere(t) {
                        return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center),
                        t.radius = this.getSize(mo).length() * .5),
                        t
                    }
                    intersect(t) {
                        return this.min.max(t.min),
                        this.max.min(t.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(t) {
                        return this.min.min(t.min),
                        this.max.max(t.max),
                        this
                    }
                    applyMatrix4(t) {
                        return this.isEmpty() ? this : (nc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                        nc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                        nc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                        nc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                        nc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                        nc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                        nc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                        nc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                        this.setFromPoints(nc),
                        this)
                    }
                    translate(t) {
                        return this.min.add(t),
                        this.max.add(t),
                        this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                    toJSON() {
                        return {
                            min: this.min.toArray(),
                            max: this.max.toArray()
                        }
                    }
                    fromJSON(t) {
                        return this.min.fromArray(t.min),
                        this.max.fromArray(t.max),
                        this
                    }
                }
                ;
                const nc = [new J, new J, new J, new J, new J, new J, new J, new J]
                  , mo = new J
                  , V0 = new qs
                  , Od = new J
                  , Ud = new J
                  , Ld = new J
                  , su = new J
                  , au = new J
                  , Eh = new J
                  , xg = new J
                  , F0 = new J
                  , H0 = new J
                  , Ch = new J;
                function Px(t, e, n, i, a) {
                    for (let o = 0, u = t.length - 3; o <= u; o += 3) {
                        Ch.fromArray(t, o);
                        const f = a.x * Math.abs(Ch.x) + a.y * Math.abs(Ch.y) + a.z * Math.abs(Ch.z)
                          , d = e.dot(Ch)
                          , p = n.dot(Ch)
                          , g = i.dot(Ch);
                        if (Math.max(-Math.max(d, p, g), Math.min(d, p, g)) > f)
                            return !1
                    }
                    return !0
                }
                const sO = new qs
                  , Mg = new J
                  , Vx = new J;
                var As = class {
                    constructor(t=new J, e=-1) {
                        this.isSphere = !0,
                        this.center = t,
                        this.radius = e
                    }
                    set(t, e) {
                        return this.center.copy(t),
                        this.radius = e,
                        this
                    }
                    setFromPoints(t, e) {
                        const n = this.center;
                        e !== void 0 ? n.copy(e) : sO.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let a = 0, o = t.length; a < o; a++)
                            i = Math.max(i, n.distanceToSquared(t[a]));
                        return this.radius = Math.sqrt(i),
                        this
                    }
                    copy(t) {
                        return this.center.copy(t.center),
                        this.radius = t.radius,
                        this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0),
                        this.radius = -1,
                        this
                    }
                    containsPoint(t) {
                        return t.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(t) {
                        return t.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(t) {
                        const e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e
                    }
                    intersectsBox(t) {
                        return t.intersectsSphere(this)
                    }
                    intersectsPlane(t) {
                        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(t, e) {
                        const n = this.center.distanceToSquared(t);
                        return e.copy(t),
                        n > this.radius * this.radius && (e.sub(this.center).normalize(),
                        e.multiplyScalar(this.radius).add(this.center)),
                        e
                    }
                    getBoundingBox(t) {
                        return this.isEmpty() ? (t.makeEmpty(),
                        t) : (t.set(this.center, this.center),
                        t.expandByScalar(this.radius),
                        t)
                    }
                    applyMatrix4(t) {
                        return this.center.applyMatrix4(t),
                        this.radius = this.radius * t.getMaxScaleOnAxis(),
                        this
                    }
                    translate(t) {
                        return this.center.add(t),
                        this
                    }
                    expandByPoint(t) {
                        if (this.isEmpty())
                            return this.center.copy(t),
                            this.radius = 0,
                            this;
                        Mg.subVectors(t, this.center);
                        const e = Mg.lengthSq();
                        if (e > this.radius * this.radius) {
                            const n = Math.sqrt(e)
                              , i = (n - this.radius) * .5;
                            this.center.addScaledVector(Mg, i / n),
                            this.radius += i
                        }
                        return this
                    }
                    union(t) {
                        return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t),
                        this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (Vx.subVectors(t.center, this.center).setLength(t.radius),
                        this.expandByPoint(Mg.copy(t.center).add(Vx)),
                        this.expandByPoint(Mg.copy(t.center).sub(Vx))),
                        this)
                    }
                    equals(t) {
                        return t.center.equals(this.center) && t.radius === this.radius
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        return {
                            radius: this.radius,
                            center: this.center.toArray()
                        }
                    }
                    fromJSON(t) {
                        return this.radius = t.radius,
                        this.center.fromArray(t.center),
                        this
                    }
                }
                ;
                const ic = new J
                  , Fx = new J
                  , G0 = new J
                  , ru = new J
                  , Hx = new J
                  , k0 = new J
                  , Gx = new J;
                var Id = class {
                    constructor(t=new J, e=new J(0,0,-1)) {
                        this.origin = t,
                        this.direction = e
                    }
                    set(t, e) {
                        return this.origin.copy(t),
                        this.direction.copy(e),
                        this
                    }
                    copy(t) {
                        return this.origin.copy(t.origin),
                        this.direction.copy(t.direction),
                        this
                    }
                    at(t, e) {
                        return e.copy(this.origin).addScaledVector(this.direction, t)
                    }
                    lookAt(t) {
                        return this.direction.copy(t).sub(this.origin).normalize(),
                        this
                    }
                    recast(t) {
                        return this.origin.copy(this.at(t, ic)),
                        this
                    }
                    closestPointToPoint(t, e) {
                        e.subVectors(t, this.origin);
                        const n = e.dot(this.direction);
                        return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
                    }
                    distanceToPoint(t) {
                        return Math.sqrt(this.distanceSqToPoint(t))
                    }
                    distanceSqToPoint(t) {
                        const e = ic.subVectors(t, this.origin).dot(this.direction);
                        return e < 0 ? this.origin.distanceToSquared(t) : (ic.copy(this.origin).addScaledVector(this.direction, e),
                        ic.distanceToSquared(t))
                    }
                    distanceSqToSegment(t, e, n, i) {
                        Fx.copy(t).add(e).multiplyScalar(.5),
                        G0.copy(e).sub(t).normalize(),
                        ru.copy(this.origin).sub(Fx);
                        const a = t.distanceTo(e) * .5
                          , o = -this.direction.dot(G0)
                          , u = ru.dot(this.direction)
                          , f = -ru.dot(G0)
                          , d = ru.lengthSq()
                          , p = Math.abs(1 - o * o);
                        let g, v, y, S;
                        if (p > 0)
                            if (g = o * f - u,
                            v = o * u - f,
                            S = a * p,
                            g >= 0)
                                if (v >= -S)
                                    if (v <= S) {
                                        const E = 1 / p;
                                        g *= E,
                                        v *= E,
                                        y = g * (g + o * v + 2 * u) + v * (o * g + v + 2 * f) + d
                                    } else
                                        v = a,
                                        g = Math.max(0, -(o * v + u)),
                                        y = -g * g + v * (v + 2 * f) + d;
                                else
                                    v = -a,
                                    g = Math.max(0, -(o * v + u)),
                                    y = -g * g + v * (v + 2 * f) + d;
                            else
                                v <= -S ? (g = Math.max(0, -(-o * a + u)),
                                v = g > 0 ? -a : Math.min(Math.max(-a, -f), a),
                                y = -g * g + v * (v + 2 * f) + d) : v <= S ? (g = 0,
                                v = Math.min(Math.max(-a, -f), a),
                                y = v * (v + 2 * f) + d) : (g = Math.max(0, -(o * a + u)),
                                v = g > 0 ? a : Math.min(Math.max(-a, -f), a),
                                y = -g * g + v * (v + 2 * f) + d);
                        else
                            v = o > 0 ? -a : a,
                            g = Math.max(0, -(o * v + u)),
                            y = -g * g + v * (v + 2 * f) + d;
                        return n && n.copy(this.origin).addScaledVector(this.direction, g),
                        i && i.copy(Fx).addScaledVector(G0, v),
                        y
                    }
                    intersectSphere(t, e) {
                        ic.subVectors(t.center, this.origin);
                        const n = ic.dot(this.direction)
                          , i = ic.dot(ic) - n * n
                          , a = t.radius * t.radius;
                        if (i > a)
                            return null;
                        const o = Math.sqrt(a - i)
                          , u = n - o
                          , f = n + o;
                        return f < 0 ? null : u < 0 ? this.at(f, e) : this.at(u, e)
                    }
                    intersectsSphere(t) {
                        return t.radius < 0 ? !1 : this.distanceSqToPoint(t.center) <= t.radius * t.radius
                    }
                    distanceToPlane(t) {
                        const e = t.normal.dot(this.direction);
                        if (e === 0)
                            return t.distanceToPoint(this.origin) === 0 ? 0 : null;
                        const n = -(this.origin.dot(t.normal) + t.constant) / e;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(t, e) {
                        const n = this.distanceToPlane(t);
                        return n === null ? null : this.at(n, e)
                    }
                    intersectsPlane(t) {
                        const e = t.distanceToPoint(this.origin);
                        return e === 0 || t.normal.dot(this.direction) * e < 0
                    }
                    intersectBox(t, e) {
                        let n, i, a, o, u, f;
                        const d = 1 / this.direction.x
                          , p = 1 / this.direction.y
                          , g = 1 / this.direction.z
                          , v = this.origin;
                        return d >= 0 ? (n = (t.min.x - v.x) * d,
                        i = (t.max.x - v.x) * d) : (n = (t.max.x - v.x) * d,
                        i = (t.min.x - v.x) * d),
                        p >= 0 ? (a = (t.min.y - v.y) * p,
                        o = (t.max.y - v.y) * p) : (a = (t.max.y - v.y) * p,
                        o = (t.min.y - v.y) * p),
                        n > o || a > i || ((a > n || isNaN(n)) && (n = a),
                        (o < i || isNaN(i)) && (i = o),
                        g >= 0 ? (u = (t.min.z - v.z) * g,
                        f = (t.max.z - v.z) * g) : (u = (t.max.z - v.z) * g,
                        f = (t.min.z - v.z) * g),
                        n > f || u > i) || ((u > n || n !== n) && (n = u),
                        (f < i || i !== i) && (i = f),
                        i < 0) ? null : this.at(n >= 0 ? n : i, e)
                    }
                    intersectsBox(t) {
                        return this.intersectBox(t, ic) !== null
                    }
                    intersectTriangle(t, e, n, i, a) {
                        Hx.subVectors(e, t),
                        k0.subVectors(n, t),
                        Gx.crossVectors(Hx, k0);
                        let o = this.direction.dot(Gx), u;
                        if (o > 0) {
                            if (i)
                                return null;
                            u = 1
                        } else if (o < 0)
                            u = -1,
                            o = -o;
                        else
                            return null;
                        ru.subVectors(this.origin, t);
                        const f = u * this.direction.dot(k0.crossVectors(ru, k0));
                        if (f < 0)
                            return null;
                        const d = u * this.direction.dot(Hx.cross(ru));
                        if (d < 0 || f + d > o)
                            return null;
                        const p = -u * ru.dot(Gx);
                        return p < 0 ? null : this.at(p / o, a)
                    }
                    applyMatrix4(t) {
                        return this.origin.applyMatrix4(t),
                        this.direction.transformDirection(t),
                        this
                    }
                    equals(t) {
                        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , jt = class pT {
                    constructor(e, n, i, a, o, u, f, d, p, g, v, y, S, E, w, A) {
                        pT.prototype.isMatrix4 = !0,
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                        e !== void 0 && this.set(e, n, i, a, o, u, f, d, p, g, v, y, S, E, w, A)
                    }
                    set(e, n, i, a, o, u, f, d, p, g, v, y, S, E, w, A) {
                        const T = this.elements;
                        return T[0] = e,
                        T[4] = n,
                        T[8] = i,
                        T[12] = a,
                        T[1] = o,
                        T[5] = u,
                        T[9] = f,
                        T[13] = d,
                        T[2] = p,
                        T[6] = g,
                        T[10] = v,
                        T[14] = y,
                        T[3] = S,
                        T[7] = E,
                        T[11] = w,
                        T[15] = A,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    clone() {
                        return new pT().fromArray(this.elements)
                    }
                    copy(e) {
                        const n = this.elements
                          , i = e.elements;
                        return n[0] = i[0],
                        n[1] = i[1],
                        n[2] = i[2],
                        n[3] = i[3],
                        n[4] = i[4],
                        n[5] = i[5],
                        n[6] = i[6],
                        n[7] = i[7],
                        n[8] = i[8],
                        n[9] = i[9],
                        n[10] = i[10],
                        n[11] = i[11],
                        n[12] = i[12],
                        n[13] = i[13],
                        n[14] = i[14],
                        n[15] = i[15],
                        this
                    }
                    copyPosition(e) {
                        const n = this.elements
                          , i = e.elements;
                        return n[12] = i[12],
                        n[13] = i[13],
                        n[14] = i[14],
                        this
                    }
                    setFromMatrix3(e) {
                        const n = e.elements;
                        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1),
                        this
                    }
                    extractBasis(e, n, i) {
                        return this.determinant() === 0 ? (e.set(1, 0, 0),
                        n.set(0, 1, 0),
                        i.set(0, 0, 1),
                        this) : (e.setFromMatrixColumn(this, 0),
                        n.setFromMatrixColumn(this, 1),
                        i.setFromMatrixColumn(this, 2),
                        this)
                    }
                    makeBasis(e, n, i) {
                        return this.set(e.x, n.x, i.x, 0, e.y, n.y, i.y, 0, e.z, n.z, i.z, 0, 0, 0, 0, 1),
                        this
                    }
                    extractRotation(e) {
                        if (e.determinant() === 0)
                            return this.identity();
                        const n = this.elements
                          , i = e.elements
                          , a = 1 / zd.setFromMatrixColumn(e, 0).length()
                          , o = 1 / zd.setFromMatrixColumn(e, 1).length()
                          , u = 1 / zd.setFromMatrixColumn(e, 2).length();
                        return n[0] = i[0] * a,
                        n[1] = i[1] * a,
                        n[2] = i[2] * a,
                        n[3] = 0,
                        n[4] = i[4] * o,
                        n[5] = i[5] * o,
                        n[6] = i[6] * o,
                        n[7] = 0,
                        n[8] = i[8] * u,
                        n[9] = i[9] * u,
                        n[10] = i[10] * u,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromEuler(e) {
                        const n = this.elements
                          , i = e.x
                          , a = e.y
                          , o = e.z
                          , u = Math.cos(i)
                          , f = Math.sin(i)
                          , d = Math.cos(a)
                          , p = Math.sin(a)
                          , g = Math.cos(o)
                          , v = Math.sin(o);
                        if (e.order === "XYZ") {
                            const y = u * g
                              , S = u * v
                              , E = f * g
                              , w = f * v;
                            n[0] = d * g,
                            n[4] = -d * v,
                            n[8] = p,
                            n[1] = S + E * p,
                            n[5] = y - w * p,
                            n[9] = -f * d,
                            n[2] = w - y * p,
                            n[6] = E + S * p,
                            n[10] = u * d
                        } else if (e.order === "YXZ") {
                            const y = d * g
                              , S = d * v
                              , E = p * g
                              , w = p * v;
                            n[0] = y + w * f,
                            n[4] = E * f - S,
                            n[8] = u * p,
                            n[1] = u * v,
                            n[5] = u * g,
                            n[9] = -f,
                            n[2] = S * f - E,
                            n[6] = w + y * f,
                            n[10] = u * d
                        } else if (e.order === "ZXY") {
                            const y = d * g
                              , S = d * v
                              , E = p * g
                              , w = p * v;
                            n[0] = y - w * f,
                            n[4] = -u * v,
                            n[8] = E + S * f,
                            n[1] = S + E * f,
                            n[5] = u * g,
                            n[9] = w - y * f,
                            n[2] = -u * p,
                            n[6] = f,
                            n[10] = u * d
                        } else if (e.order === "ZYX") {
                            const y = u * g
                              , S = u * v
                              , E = f * g
                              , w = f * v;
                            n[0] = d * g,
                            n[4] = E * p - S,
                            n[8] = y * p + w,
                            n[1] = d * v,
                            n[5] = w * p + y,
                            n[9] = S * p - E,
                            n[2] = -p,
                            n[6] = f * d,
                            n[10] = u * d
                        } else if (e.order === "YZX") {
                            const y = u * d
                              , S = u * p
                              , E = f * d
                              , w = f * p;
                            n[0] = d * g,
                            n[4] = w - y * v,
                            n[8] = E * v + S,
                            n[1] = v,
                            n[5] = u * g,
                            n[9] = -f * g,
                            n[2] = -p * g,
                            n[6] = S * v + E,
                            n[10] = y - w * v
                        } else if (e.order === "XZY") {
                            const y = u * d
                              , S = u * p
                              , E = f * d
                              , w = f * p;
                            n[0] = d * g,
                            n[4] = -v,
                            n[8] = p * g,
                            n[1] = y * v + w,
                            n[5] = u * g,
                            n[9] = S * v - E,
                            n[2] = E * v - S,
                            n[6] = f * g,
                            n[10] = w * v + y
                        }
                        return n[3] = 0,
                        n[7] = 0,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromQuaternion(e) {
                        return this.compose(aO, e, rO)
                    }
                    lookAt(e, n, i) {
                        const a = this.elements;
                        return ar.subVectors(e, n),
                        ar.lengthSq() === 0 && (ar.z = 1),
                        ar.normalize(),
                        ou.crossVectors(i, ar),
                        ou.lengthSq() === 0 && (Math.abs(i.z) === 1 ? ar.x += 1e-4 : ar.z += 1e-4,
                        ar.normalize(),
                        ou.crossVectors(i, ar)),
                        ou.normalize(),
                        q0.crossVectors(ar, ou),
                        a[0] = ou.x,
                        a[4] = q0.x,
                        a[8] = ar.x,
                        a[1] = ou.y,
                        a[5] = q0.y,
                        a[9] = ar.y,
                        a[2] = ou.z,
                        a[6] = q0.z,
                        a[10] = ar.z,
                        this
                    }
                    multiply(e) {
                        return this.multiplyMatrices(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyMatrices(e, this)
                    }
                    multiplyMatrices(e, n) {
                        const i = e.elements
                          , a = n.elements
                          , o = this.elements
                          , u = i[0]
                          , f = i[4]
                          , d = i[8]
                          , p = i[12]
                          , g = i[1]
                          , v = i[5]
                          , y = i[9]
                          , S = i[13]
                          , E = i[2]
                          , w = i[6]
                          , A = i[10]
                          , T = i[14]
                          , R = i[3]
                          , N = i[7]
                          , D = i[11]
                          , U = i[15]
                          , z = a[0]
                          , I = a[4]
                          , V = a[8]
                          , B = a[12]
                          , P = a[1]
                          , G = a[5]
                          , K = a[9]
                          , ee = a[13]
                          , te = a[2]
                          , oe = a[6]
                          , q = a[10]
                          , F = a[14]
                          , X = a[3]
                          , $ = a[7]
                          , ne = a[11]
                          , ce = a[15];
                        return o[0] = u * z + f * P + d * te + p * X,
                        o[4] = u * I + f * G + d * oe + p * $,
                        o[8] = u * V + f * K + d * q + p * ne,
                        o[12] = u * B + f * ee + d * F + p * ce,
                        o[1] = g * z + v * P + y * te + S * X,
                        o[5] = g * I + v * G + y * oe + S * $,
                        o[9] = g * V + v * K + y * q + S * ne,
                        o[13] = g * B + v * ee + y * F + S * ce,
                        o[2] = E * z + w * P + A * te + T * X,
                        o[6] = E * I + w * G + A * oe + T * $,
                        o[10] = E * V + w * K + A * q + T * ne,
                        o[14] = E * B + w * ee + A * F + T * ce,
                        o[3] = R * z + N * P + D * te + U * X,
                        o[7] = R * I + N * G + D * oe + U * $,
                        o[11] = R * V + N * K + D * q + U * ne,
                        o[15] = R * B + N * ee + D * F + U * ce,
                        this
                    }
                    multiplyScalar(e) {
                        const n = this.elements;
                        return n[0] *= e,
                        n[4] *= e,
                        n[8] *= e,
                        n[12] *= e,
                        n[1] *= e,
                        n[5] *= e,
                        n[9] *= e,
                        n[13] *= e,
                        n[2] *= e,
                        n[6] *= e,
                        n[10] *= e,
                        n[14] *= e,
                        n[3] *= e,
                        n[7] *= e,
                        n[11] *= e,
                        n[15] *= e,
                        this
                    }
                    determinant() {
                        const e = this.elements
                          , n = e[0]
                          , i = e[4]
                          , a = e[8]
                          , o = e[12]
                          , u = e[1]
                          , f = e[5]
                          , d = e[9]
                          , p = e[13]
                          , g = e[2]
                          , v = e[6]
                          , y = e[10]
                          , S = e[14]
                          , E = e[3]
                          , w = e[7]
                          , A = e[11]
                          , T = e[15]
                          , R = d * S - p * y
                          , N = f * S - p * v
                          , D = f * y - d * v
                          , U = u * S - p * g
                          , z = u * y - d * g
                          , I = u * v - f * g;
                        return n * (w * R - A * N + T * D) - i * (E * R - A * U + T * z) + a * (E * N - w * U + T * I) - o * (E * D - w * z + A * I)
                    }
                    transpose() {
                        const e = this.elements;
                        let n;
                        return n = e[1],
                        e[1] = e[4],
                        e[4] = n,
                        n = e[2],
                        e[2] = e[8],
                        e[8] = n,
                        n = e[6],
                        e[6] = e[9],
                        e[9] = n,
                        n = e[3],
                        e[3] = e[12],
                        e[12] = n,
                        n = e[7],
                        e[7] = e[13],
                        e[13] = n,
                        n = e[11],
                        e[11] = e[14],
                        e[14] = n,
                        this
                    }
                    setPosition(e, n, i) {
                        const a = this.elements;
                        return e.isVector3 ? (a[12] = e.x,
                        a[13] = e.y,
                        a[14] = e.z) : (a[12] = e,
                        a[13] = n,
                        a[14] = i),
                        this
                    }
                    invert() {
                        const e = this.elements
                          , n = e[0]
                          , i = e[1]
                          , a = e[2]
                          , o = e[3]
                          , u = e[4]
                          , f = e[5]
                          , d = e[6]
                          , p = e[7]
                          , g = e[8]
                          , v = e[9]
                          , y = e[10]
                          , S = e[11]
                          , E = e[12]
                          , w = e[13]
                          , A = e[14]
                          , T = e[15]
                          , R = v * A * p - w * y * p + w * d * S - f * A * S - v * d * T + f * y * T
                          , N = E * y * p - g * A * p - E * d * S + u * A * S + g * d * T - u * y * T
                          , D = g * w * p - E * v * p + E * f * S - u * w * S - g * f * T + u * v * T
                          , U = E * v * d - g * w * d - E * f * y + u * w * y + g * f * A - u * v * A
                          , z = n * R + i * N + a * D + o * U;
                        if (z === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const I = 1 / z;
                        return e[0] = R * I,
                        e[1] = (w * y * o - v * A * o - w * a * S + i * A * S + v * a * T - i * y * T) * I,
                        e[2] = (f * A * o - w * d * o + w * a * p - i * A * p - f * a * T + i * d * T) * I,
                        e[3] = (v * d * o - f * y * o - v * a * p + i * y * p + f * a * S - i * d * S) * I,
                        e[4] = N * I,
                        e[5] = (g * A * o - E * y * o + E * a * S - n * A * S - g * a * T + n * y * T) * I,
                        e[6] = (E * d * o - u * A * o - E * a * p + n * A * p + u * a * T - n * d * T) * I,
                        e[7] = (u * y * o - g * d * o + g * a * p - n * y * p - u * a * S + n * d * S) * I,
                        e[8] = D * I,
                        e[9] = (E * v * o - g * w * o - E * i * S + n * w * S + g * i * T - n * v * T) * I,
                        e[10] = (u * w * o - E * f * o + E * i * p - n * w * p - u * i * T + n * f * T) * I,
                        e[11] = (g * f * o - u * v * o - g * i * p + n * v * p + u * i * S - n * f * S) * I,
                        e[12] = U * I,
                        e[13] = (g * w * a - E * v * a + E * i * y - n * w * y - g * i * A + n * v * A) * I,
                        e[14] = (E * f * a - u * w * a - E * i * d + n * w * d + u * i * A - n * f * A) * I,
                        e[15] = (u * v * a - g * f * a + g * i * d - n * v * d - u * i * y + n * f * y) * I,
                        this
                    }
                    scale(e) {
                        const n = this.elements
                          , i = e.x
                          , a = e.y
                          , o = e.z;
                        return n[0] *= i,
                        n[4] *= a,
                        n[8] *= o,
                        n[1] *= i,
                        n[5] *= a,
                        n[9] *= o,
                        n[2] *= i,
                        n[6] *= a,
                        n[10] *= o,
                        n[3] *= i,
                        n[7] *= a,
                        n[11] *= o,
                        this
                    }
                    getMaxScaleOnAxis() {
                        const e = this.elements
                          , n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                          , a = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                        return Math.sqrt(Math.max(n, i, a))
                    }
                    makeTranslation(e, n, i) {
                        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1),
                        this
                    }
                    makeRotationX(e) {
                        const n = Math.cos(e)
                          , i = Math.sin(e);
                        return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationY(e) {
                        const n = Math.cos(e)
                          , i = Math.sin(e);
                        return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationZ(e) {
                        const n = Math.cos(e)
                          , i = Math.sin(e);
                        return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationAxis(e, n) {
                        const i = Math.cos(n)
                          , a = Math.sin(n)
                          , o = 1 - i
                          , u = e.x
                          , f = e.y
                          , d = e.z
                          , p = o * u
                          , g = o * f;
                        return this.set(p * u + i, p * f - a * d, p * d + a * f, 0, p * f + a * d, g * f + i, g * d - a * u, 0, p * d - a * f, g * d + a * u, o * d * d + i, 0, 0, 0, 0, 1),
                        this
                    }
                    makeScale(e, n, i) {
                        return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
                        this
                    }
                    makeShear(e, n, i, a, o, u) {
                        return this.set(1, i, o, 0, e, 1, u, 0, n, a, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    compose(e, n, i) {
                        const a = this.elements
                          , o = n._x
                          , u = n._y
                          , f = n._z
                          , d = n._w
                          , p = o + o
                          , g = u + u
                          , v = f + f
                          , y = o * p
                          , S = o * g
                          , E = o * v
                          , w = u * g
                          , A = u * v
                          , T = f * v
                          , R = d * p
                          , N = d * g
                          , D = d * v
                          , U = i.x
                          , z = i.y
                          , I = i.z;
                        return a[0] = (1 - (w + T)) * U,
                        a[1] = (S + D) * U,
                        a[2] = (E - N) * U,
                        a[3] = 0,
                        a[4] = (S - D) * z,
                        a[5] = (1 - (y + T)) * z,
                        a[6] = (A + R) * z,
                        a[7] = 0,
                        a[8] = (E + N) * I,
                        a[9] = (A - R) * I,
                        a[10] = (1 - (y + w)) * I,
                        a[11] = 0,
                        a[12] = e.x,
                        a[13] = e.y,
                        a[14] = e.z,
                        a[15] = 1,
                        this
                    }
                    decompose(e, n, i) {
                        const a = this.elements;
                        if (e.x = a[12],
                        e.y = a[13],
                        e.z = a[14],
                        this.determinant() === 0)
                            return i.set(1, 1, 1),
                            n.identity(),
                            this;
                        let o = zd.set(a[0], a[1], a[2]).length();
                        const u = zd.set(a[4], a[5], a[6]).length()
                          , f = zd.set(a[8], a[9], a[10]).length();
                        this.determinant() < 0 && (o = -o),
                        go.copy(this);
                        const d = 1 / o
                          , p = 1 / u
                          , g = 1 / f;
                        return go.elements[0] *= d,
                        go.elements[1] *= d,
                        go.elements[2] *= d,
                        go.elements[4] *= p,
                        go.elements[5] *= p,
                        go.elements[6] *= p,
                        go.elements[8] *= g,
                        go.elements[9] *= g,
                        go.elements[10] *= g,
                        n.setFromRotationMatrix(go),
                        i.x = o,
                        i.y = u,
                        i.z = f,
                        this
                    }
                    makePerspective(e, n, i, a, o, u, f=nr, d=!1) {
                        const p = this.elements
                          , g = 2 * o / (n - e)
                          , v = 2 * o / (i - a)
                          , y = (n + e) / (n - e)
                          , S = (i + a) / (i - a);
                        let E, w;
                        if (d)
                            E = o / (u - o),
                            w = u * o / (u - o);
                        else if (f === nr)
                            E = -(u + o) / (u - o),
                            w = -2 * u * o / (u - o);
                        else if (f === Ed)
                            E = -u / (u - o),
                            w = -u * o / (u - o);
                        else
                            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + f);
                        return p[0] = g,
                        p[4] = 0,
                        p[8] = y,
                        p[12] = 0,
                        p[1] = 0,
                        p[5] = v,
                        p[9] = S,
                        p[13] = 0,
                        p[2] = 0,
                        p[6] = 0,
                        p[10] = E,
                        p[14] = w,
                        p[3] = 0,
                        p[7] = 0,
                        p[11] = -1,
                        p[15] = 0,
                        this
                    }
                    makeOrthographic(e, n, i, a, o, u, f=nr, d=!1) {
                        const p = this.elements
                          , g = 2 / (n - e)
                          , v = 2 / (i - a)
                          , y = -(n + e) / (n - e)
                          , S = -(i + a) / (i - a);
                        let E, w;
                        if (d)
                            E = 1 / (u - o),
                            w = u / (u - o);
                        else if (f === nr)
                            E = -2 / (u - o),
                            w = -(u + o) / (u - o);
                        else if (f === Ed)
                            E = -1 / (u - o),
                            w = -o / (u - o);
                        else
                            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + f);
                        return p[0] = g,
                        p[4] = 0,
                        p[8] = 0,
                        p[12] = y,
                        p[1] = 0,
                        p[5] = v,
                        p[9] = 0,
                        p[13] = S,
                        p[2] = 0,
                        p[6] = 0,
                        p[10] = E,
                        p[14] = w,
                        p[3] = 0,
                        p[7] = 0,
                        p[11] = 0,
                        p[15] = 1,
                        this
                    }
                    equals(e) {
                        const n = this.elements
                          , i = e.elements;
                        for (let a = 0; a < 16; a++)
                            if (n[a] !== i[a])
                                return !1;
                        return !0
                    }
                    fromArray(e, n=0) {
                        for (let i = 0; i < 16; i++)
                            this.elements[i] = e[i + n];
                        return this
                    }
                    toArray(e=[], n=0) {
                        const i = this.elements;
                        return e[n] = i[0],
                        e[n + 1] = i[1],
                        e[n + 2] = i[2],
                        e[n + 3] = i[3],
                        e[n + 4] = i[4],
                        e[n + 5] = i[5],
                        e[n + 6] = i[6],
                        e[n + 7] = i[7],
                        e[n + 8] = i[8],
                        e[n + 9] = i[9],
                        e[n + 10] = i[10],
                        e[n + 11] = i[11],
                        e[n + 12] = i[12],
                        e[n + 13] = i[13],
                        e[n + 14] = i[14],
                        e[n + 15] = i[15],
                        e
                    }
                }
                ;
                const zd = new J
                  , go = new jt
                  , aO = new J(0,0,0)
                  , rO = new J(1,1,1)
                  , ou = new J
                  , q0 = new J
                  , ar = new J
                  , eA = new jt
                  , tA = new za;
                var vo = class mR {
                    constructor(e=0, n=0, i=0, a=mR.DEFAULT_ORDER) {
                        this.isEuler = !0,
                        this._x = e,
                        this._y = n,
                        this._z = i,
                        this._order = a
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x = e,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y = e,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(e) {
                        this._z = e,
                        this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(e) {
                        this._order = e,
                        this._onChangeCallback()
                    }
                    set(e, n, i, a=this._order) {
                        return this._x = e,
                        this._y = n,
                        this._z = i,
                        this._order = a,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._order)
                    }
                    copy(e) {
                        return this._x = e._x,
                        this._y = e._y,
                        this._z = e._z,
                        this._order = e._order,
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(e, n=this._order, i=!0) {
                        const a = e.elements
                          , o = a[0]
                          , u = a[4]
                          , f = a[8]
                          , d = a[1]
                          , p = a[5]
                          , g = a[9]
                          , v = a[2]
                          , y = a[6]
                          , S = a[10];
                        switch (n) {
                        case "XYZ":
                            this._y = Math.asin(Ht(f, -1, 1)),
                            Math.abs(f) < .9999999 ? (this._x = Math.atan2(-g, S),
                            this._z = Math.atan2(-u, o)) : (this._x = Math.atan2(y, p),
                            this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-Ht(g, -1, 1)),
                            Math.abs(g) < .9999999 ? (this._y = Math.atan2(f, S),
                            this._z = Math.atan2(d, p)) : (this._y = Math.atan2(-v, o),
                            this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(Ht(y, -1, 1)),
                            Math.abs(y) < .9999999 ? (this._y = Math.atan2(-v, S),
                            this._z = Math.atan2(-u, p)) : (this._y = 0,
                            this._z = Math.atan2(d, o));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-Ht(v, -1, 1)),
                            Math.abs(v) < .9999999 ? (this._x = Math.atan2(y, S),
                            this._z = Math.atan2(d, o)) : (this._x = 0,
                            this._z = Math.atan2(-u, p));
                            break;
                        case "YZX":
                            this._z = Math.asin(Ht(d, -1, 1)),
                            Math.abs(d) < .9999999 ? (this._x = Math.atan2(-g, p),
                            this._y = Math.atan2(-v, o)) : (this._x = 0,
                            this._y = Math.atan2(f, S));
                            break;
                        case "XZY":
                            this._z = Math.asin(-Ht(u, -1, 1)),
                            Math.abs(u) < .9999999 ? (this._x = Math.atan2(y, p),
                            this._y = Math.atan2(f, o)) : (this._x = Math.atan2(-g, S),
                            this._y = 0);
                            break;
                        default:
                            at("Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
                        }
                        return this._order = n,
                        i === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromQuaternion(e, n, i) {
                        return eA.makeRotationFromQuaternion(e),
                        this.setFromRotationMatrix(eA, n, i)
                    }
                    setFromVector3(e, n=this._order) {
                        return this.set(e.x, e.y, e.z, n)
                    }
                    reorder(e) {
                        return tA.setFromEuler(this),
                        this.setFromQuaternion(tA, e)
                    }
                    equals(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                    }
                    fromArray(e) {
                        return this._x = e[0],
                        this._y = e[1],
                        this._z = e[2],
                        e[3] !== void 0 && (this._order = e[3]),
                        this._onChangeCallback(),
                        this
                    }
                    toArray(e=[], n=0) {
                        return e[n] = this._x,
                        e[n + 1] = this._y,
                        e[n + 2] = this._z,
                        e[n + 3] = this._order,
                        e
                    }
                    _onChange(e) {
                        return this._onChangeCallback = e,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._order
                    }
                }
                ;
                vo.DEFAULT_ORDER = "XYZ";
                var Bd = class {
                    constructor() {
                        this.mask = 1
                    }
                    set(t) {
                        this.mask = (1 << t | 0) >>> 0
                    }
                    enable(t) {
                        this.mask |= 1 << t | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(t) {
                        this.mask ^= 1 << t | 0
                    }
                    disable(t) {
                        this.mask &= ~(1 << t | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(t) {
                        return (this.mask & t.mask) !== 0
                    }
                    isEnabled(t) {
                        return (this.mask & (1 << t | 0)) !== 0
                    }
                }
                ;
                let oO = 0;
                const nA = new J
                  , Pd = new za
                  , sc = new jt
                  , X0 = new J
                  , bg = new J
                  , lO = new J
                  , cO = new za
                  , iA = new J(1,0,0)
                  , sA = new J(0,1,0)
                  , aA = new J(0,0,1)
                  , rA = {
                    type: "added"
                }
                  , uO = {
                    type: "removed"
                }
                  , Vd = {
                    type: "childadded",
                    child: null
                }
                  , kx = {
                    type: "childremoved",
                    child: null
                };
                var zn = class ES extends cl {
                    constructor() {
                        super(),
                        this.isObject3D = !0,
                        Object.defineProperty(this, "id", {
                            value: oO++
                        }),
                        this.uuid = ir(),
                        this.name = "",
                        this.type = "Object3D",
                        this.parent = null,
                        this.children = [],
                        this.up = ES.DEFAULT_UP.clone();
                        const e = new J
                          , n = new vo
                          , i = new za
                          , a = new J(1,1,1);
                        function o() {
                            i.setFromEuler(n, !1)
                        }
                        function u() {
                            n.setFromQuaternion(i, void 0, !1)
                        }
                        n._onChange(o),
                        i._onChange(u),
                        Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: e
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: i
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: a
                            },
                            modelViewMatrix: {
                                value: new jt
                            },
                            normalMatrix: {
                                value: new sn
                            }
                        }),
                        this.matrix = new jt,
                        this.matrixWorld = new jt,
                        this.matrixAutoUpdate = ES.DEFAULT_MATRIX_AUTO_UPDATE,
                        this.matrixWorldAutoUpdate = ES.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                        this.matrixWorldNeedsUpdate = !1,
                        this.layers = new Bd,
                        this.visible = !0,
                        this.castShadow = !1,
                        this.receiveShadow = !1,
                        this.frustumCulled = !0,
                        this.renderOrder = 0,
                        this.animations = [],
                        this.customDepthMaterial = void 0,
                        this.customDistanceMaterial = void 0,
                        this.userData = {}
                    }
                    onBeforeShadow() {}
                    onAfterShadow() {}
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(e) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(e),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(e) {
                        return this.quaternion.premultiply(e),
                        this
                    }
                    setRotationFromAxisAngle(e, n) {
                        this.quaternion.setFromAxisAngle(e, n)
                    }
                    setRotationFromEuler(e) {
                        this.quaternion.setFromEuler(e, !0)
                    }
                    setRotationFromMatrix(e) {
                        this.quaternion.setFromRotationMatrix(e)
                    }
                    setRotationFromQuaternion(e) {
                        this.quaternion.copy(e)
                    }
                    rotateOnAxis(e, n) {
                        return Pd.setFromAxisAngle(e, n),
                        this.quaternion.multiply(Pd),
                        this
                    }
                    rotateOnWorldAxis(e, n) {
                        return Pd.setFromAxisAngle(e, n),
                        this.quaternion.premultiply(Pd),
                        this
                    }
                    rotateX(e) {
                        return this.rotateOnAxis(iA, e)
                    }
                    rotateY(e) {
                        return this.rotateOnAxis(sA, e)
                    }
                    rotateZ(e) {
                        return this.rotateOnAxis(aA, e)
                    }
                    translateOnAxis(e, n) {
                        return nA.copy(e).applyQuaternion(this.quaternion),
                        this.position.add(nA.multiplyScalar(n)),
                        this
                    }
                    translateX(e) {
                        return this.translateOnAxis(iA, e)
                    }
                    translateY(e) {
                        return this.translateOnAxis(sA, e)
                    }
                    translateZ(e) {
                        return this.translateOnAxis(aA, e)
                    }
                    localToWorld(e) {
                        return this.updateWorldMatrix(!0, !1),
                        e.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(e) {
                        return this.updateWorldMatrix(!0, !1),
                        e.applyMatrix4(sc.copy(this.matrixWorld).invert())
                    }
                    lookAt(e, n, i) {
                        e.isVector3 ? X0.copy(e) : X0.set(e, n, i);
                        const a = this.parent;
                        this.updateWorldMatrix(!0, !1),
                        bg.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? sc.lookAt(bg, X0, this.up) : sc.lookAt(X0, bg, this.up),
                        this.quaternion.setFromRotationMatrix(sc),
                        a && (sc.extractRotation(a.matrixWorld),
                        Pd.setFromRotationMatrix(sc),
                        this.quaternion.premultiply(Pd.invert()))
                    }
                    add(e) {
                        if (arguments.length > 1) {
                            for (let n = 0; n < arguments.length; n++)
                                this.add(arguments[n]);
                            return this
                        }
                        return e === this ? (Rt("Object3D.add: object can't be added as a child of itself.", e),
                        this) : (e && e.isObject3D ? (e.removeFromParent(),
                        e.parent = this,
                        this.children.push(e),
                        e.dispatchEvent(rA),
                        Vd.child = e,
                        this.dispatchEvent(Vd),
                        Vd.child = null) : Rt("Object3D.add: object not an instance of THREE.Object3D.", e),
                        this)
                    }
                    remove(e) {
                        if (arguments.length > 1) {
                            for (let i = 0; i < arguments.length; i++)
                                this.remove(arguments[i]);
                            return this
                        }
                        const n = this.children.indexOf(e);
                        return n !== -1 && (e.parent = null,
                        this.children.splice(n, 1),
                        e.dispatchEvent(uO),
                        kx.child = e,
                        this.dispatchEvent(kx),
                        kx.child = null),
                        this
                    }
                    removeFromParent() {
                        const e = this.parent;
                        return e !== null && e.remove(this),
                        this
                    }
                    clear() {
                        return this.remove(...this.children)
                    }
                    attach(e) {
                        return this.updateWorldMatrix(!0, !1),
                        sc.copy(this.matrixWorld).invert(),
                        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
                        sc.multiply(e.parent.matrixWorld)),
                        e.applyMatrix4(sc),
                        e.removeFromParent(),
                        e.parent = this,
                        this.children.push(e),
                        e.updateWorldMatrix(!1, !0),
                        e.dispatchEvent(rA),
                        Vd.child = e,
                        this.dispatchEvent(Vd),
                        Vd.child = null,
                        this
                    }
                    getObjectById(e) {
                        return this.getObjectByProperty("id", e)
                    }
                    getObjectByName(e) {
                        return this.getObjectByProperty("name", e)
                    }
                    getObjectByProperty(e, n) {
                        if (this[e] === n)
                            return this;
                        for (let i = 0, a = this.children.length; i < a; i++) {
                            const o = this.children[i].getObjectByProperty(e, n);
                            if (o !== void 0)
                                return o
                        }
                    }
                    getObjectsByProperty(e, n, i=[]) {
                        this[e] === n && i.push(this);
                        const a = this.children;
                        for (let o = 0, u = a.length; o < u; o++)
                            a[o].getObjectsByProperty(e, n, i);
                        return i
                    }
                    getWorldPosition(e) {
                        return this.updateWorldMatrix(!0, !1),
                        e.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(e) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(bg, e, lO),
                        e
                    }
                    getWorldScale(e) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(bg, cO, e),
                        e
                    }
                    getWorldDirection(e) {
                        this.updateWorldMatrix(!0, !1);
                        const n = this.matrixWorld.elements;
                        return e.set(n[8], n[9], n[10]).normalize()
                    }
                    raycast() {}
                    traverse(e) {
                        e(this);
                        const n = this.children;
                        for (let i = 0, a = n.length; i < a; i++)
                            n[i].traverse(e)
                    }
                    traverseVisible(e) {
                        if (this.visible === !1)
                            return;
                        e(this);
                        const n = this.children;
                        for (let i = 0, a = n.length; i < a; i++)
                            n[i].traverseVisible(e)
                    }
                    traverseAncestors(e) {
                        const n = this.parent;
                        n !== null && (e(n),
                        n.traverseAncestors(e))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(e) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        this.matrixWorldNeedsUpdate = !1,
                        e = !0);
                        const n = this.children;
                        for (let i = 0, a = n.length; i < a; i++)
                            n[i].updateMatrixWorld(e)
                    }
                    updateWorldMatrix(e, n) {
                        const i = this.parent;
                        if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        n === !0) {
                            const a = this.children;
                            for (let o = 0, u = a.length; o < u; o++)
                                a[o].updateWorldMatrix(!1, !0)
                        }
                    }
                    toJSON(e) {
                        const n = e === void 0 || typeof e == "string"
                          , i = {};
                        n && (e = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                            nodes: {}
                        },
                        i.metadata = {
                            version: 4.7,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const a = {};
                        a.uuid = this.uuid,
                        a.type = this.type,
                        this.name !== "" && (a.name = this.name),
                        this.castShadow === !0 && (a.castShadow = !0),
                        this.receiveShadow === !0 && (a.receiveShadow = !0),
                        this.visible === !1 && (a.visible = !1),
                        this.frustumCulled === !1 && (a.frustumCulled = !1),
                        this.renderOrder !== 0 && (a.renderOrder = this.renderOrder),
                        Object.keys(this.userData).length > 0 && (a.userData = this.userData),
                        a.layers = this.layers.mask,
                        a.matrix = this.matrix.toArray(),
                        a.up = this.up.toArray(),
                        this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1),
                        this.isInstancedMesh && (a.type = "InstancedMesh",
                        a.count = this.count,
                        a.instanceMatrix = this.instanceMatrix.toJSON(),
                        this.instanceColor !== null && (a.instanceColor = this.instanceColor.toJSON())),
                        this.isBatchedMesh && (a.type = "BatchedMesh",
                        a.perObjectFrustumCulled = this.perObjectFrustumCulled,
                        a.sortObjects = this.sortObjects,
                        a.drawRanges = this._drawRanges,
                        a.reservedRanges = this._reservedRanges,
                        a.geometryInfo = this._geometryInfo.map(f => ({
                            ...f,
                            boundingBox: f.boundingBox ? f.boundingBox.toJSON() : void 0,
                            boundingSphere: f.boundingSphere ? f.boundingSphere.toJSON() : void 0
                        })),
                        a.instanceInfo = this._instanceInfo.map(f => ({
                            ...f
                        })),
                        a.availableInstanceIds = this._availableInstanceIds.slice(),
                        a.availableGeometryIds = this._availableGeometryIds.slice(),
                        a.nextIndexStart = this._nextIndexStart,
                        a.nextVertexStart = this._nextVertexStart,
                        a.geometryCount = this._geometryCount,
                        a.maxInstanceCount = this._maxInstanceCount,
                        a.maxVertexCount = this._maxVertexCount,
                        a.maxIndexCount = this._maxIndexCount,
                        a.geometryInitialized = this._geometryInitialized,
                        a.matricesTexture = this._matricesTexture.toJSON(e),
                        a.indirectTexture = this._indirectTexture.toJSON(e),
                        this._colorsTexture !== null && (a.colorsTexture = this._colorsTexture.toJSON(e)),
                        this.boundingSphere !== null && (a.boundingSphere = this.boundingSphere.toJSON()),
                        this.boundingBox !== null && (a.boundingBox = this.boundingBox.toJSON()));
                        function o(f, d) {
                            return f[d.uuid] === void 0 && (f[d.uuid] = d.toJSON(e)),
                            d.uuid
                        }
                        if (this.isScene)
                            this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(e).uuid)),
                            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (a.environment = this.environment.toJSON(e).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            a.geometry = o(e.geometries, this.geometry);
                            const f = this.geometry.parameters;
                            if (f !== void 0 && f.shapes !== void 0) {
                                const d = f.shapes;
                                if (Array.isArray(d))
                                    for (let p = 0, g = d.length; p < g; p++) {
                                        const v = d[p];
                                        o(e.shapes, v)
                                    }
                                else
                                    o(e.shapes, d)
                            }
                        }
                        if (this.isSkinnedMesh && (a.bindMode = this.bindMode,
                        a.bindMatrix = this.bindMatrix.toArray(),
                        this.skeleton !== void 0 && (o(e.skeletons, this.skeleton),
                        a.skeleton = this.skeleton.uuid)),
                        this.material !== void 0)
                            if (Array.isArray(this.material)) {
                                const f = [];
                                for (let d = 0, p = this.material.length; d < p; d++)
                                    f.push(o(e.materials, this.material[d]));
                                a.material = f
                            } else
                                a.material = o(e.materials, this.material);
                        if (this.children.length > 0) {
                            a.children = [];
                            for (let f = 0; f < this.children.length; f++)
                                a.children.push(this.children[f].toJSON(e).object)
                        }
                        if (this.animations.length > 0) {
                            a.animations = [];
                            for (let f = 0; f < this.animations.length; f++) {
                                const d = this.animations[f];
                                a.animations.push(o(e.animations, d))
                            }
                        }
                        if (n) {
                            const f = u(e.geometries)
                              , d = u(e.materials)
                              , p = u(e.textures)
                              , g = u(e.images)
                              , v = u(e.shapes)
                              , y = u(e.skeletons)
                              , S = u(e.animations)
                              , E = u(e.nodes);
                            f.length > 0 && (i.geometries = f),
                            d.length > 0 && (i.materials = d),
                            p.length > 0 && (i.textures = p),
                            g.length > 0 && (i.images = g),
                            v.length > 0 && (i.shapes = v),
                            y.length > 0 && (i.skeletons = y),
                            S.length > 0 && (i.animations = S),
                            E.length > 0 && (i.nodes = E)
                        }
                        return i.object = a,
                        i;
                        function u(f) {
                            const d = [];
                            for (const p in f) {
                                const g = f[p];
                                delete g.metadata,
                                d.push(g)
                            }
                            return d
                        }
                    }
                    clone(e) {
                        return new this.constructor().copy(this, e)
                    }
                    copy(e, n=!0) {
                        if (this.name = e.name,
                        this.up.copy(e.up),
                        this.position.copy(e.position),
                        this.rotation.order = e.rotation.order,
                        this.quaternion.copy(e.quaternion),
                        this.scale.copy(e.scale),
                        this.matrix.copy(e.matrix),
                        this.matrixWorld.copy(e.matrixWorld),
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                        this.layers.mask = e.layers.mask,
                        this.visible = e.visible,
                        this.castShadow = e.castShadow,
                        this.receiveShadow = e.receiveShadow,
                        this.frustumCulled = e.frustumCulled,
                        this.renderOrder = e.renderOrder,
                        this.animations = e.animations.slice(),
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        n === !0)
                            for (let i = 0; i < e.children.length; i++) {
                                const a = e.children[i];
                                this.add(a.clone())
                            }
                        return this
                    }
                }
                ;
                zn.DEFAULT_UP = new J(0,1,0),
                zn.DEFAULT_MATRIX_AUTO_UPDATE = !0,
                zn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                const _o = new J
                  , ac = new J
                  , qx = new J
                  , rc = new J
                  , Fd = new J
                  , Hd = new J
                  , oA = new J
                  , Xx = new J
                  , Wx = new J
                  , Yx = new J
                  , jx = new di
                  , Zx = new di
                  , Qx = new di;
                var lu = class Np {
                    constructor(e=new J, n=new J, i=new J) {
                        this.a = e,
                        this.b = n,
                        this.c = i
                    }
                    static getNormal(e, n, i, a) {
                        a.subVectors(i, n),
                        _o.subVectors(e, n),
                        a.cross(_o);
                        const o = a.lengthSq();
                        return o > 0 ? a.multiplyScalar(1 / Math.sqrt(o)) : a.set(0, 0, 0)
                    }
                    static getBarycoord(e, n, i, a, o) {
                        _o.subVectors(a, n),
                        ac.subVectors(i, n),
                        qx.subVectors(e, n);
                        const u = _o.dot(_o)
                          , f = _o.dot(ac)
                          , d = _o.dot(qx)
                          , p = ac.dot(ac)
                          , g = ac.dot(qx)
                          , v = u * p - f * f;
                        if (v === 0)
                            return o.set(0, 0, 0),
                            null;
                        const y = 1 / v
                          , S = (p * d - f * g) * y
                          , E = (u * g - f * d) * y;
                        return o.set(1 - S - E, E, S)
                    }
                    static containsPoint(e, n, i, a) {
                        return this.getBarycoord(e, n, i, a, rc) === null ? !1 : rc.x >= 0 && rc.y >= 0 && rc.x + rc.y <= 1
                    }
                    static getInterpolation(e, n, i, a, o, u, f, d) {
                        return this.getBarycoord(e, n, i, a, rc) === null ? (d.x = 0,
                        d.y = 0,
                        "z"in d && (d.z = 0),
                        "w"in d && (d.w = 0),
                        null) : (d.setScalar(0),
                        d.addScaledVector(o, rc.x),
                        d.addScaledVector(u, rc.y),
                        d.addScaledVector(f, rc.z),
                        d)
                    }
                    static getInterpolatedAttribute(e, n, i, a, o, u) {
                        return jx.setScalar(0),
                        Zx.setScalar(0),
                        Qx.setScalar(0),
                        jx.fromBufferAttribute(e, n),
                        Zx.fromBufferAttribute(e, i),
                        Qx.fromBufferAttribute(e, a),
                        u.setScalar(0),
                        u.addScaledVector(jx, o.x),
                        u.addScaledVector(Zx, o.y),
                        u.addScaledVector(Qx, o.z),
                        u
                    }
                    static isFrontFacing(e, n, i, a) {
                        return _o.subVectors(i, n),
                        ac.subVectors(e, n),
                        _o.cross(ac).dot(a) < 0
                    }
                    set(e, n, i) {
                        return this.a.copy(e),
                        this.b.copy(n),
                        this.c.copy(i),
                        this
                    }
                    setFromPointsAndIndices(e, n, i, a) {
                        return this.a.copy(e[n]),
                        this.b.copy(e[i]),
                        this.c.copy(e[a]),
                        this
                    }
                    setFromAttributeAndIndices(e, n, i, a) {
                        return this.a.fromBufferAttribute(e, n),
                        this.b.fromBufferAttribute(e, i),
                        this.c.fromBufferAttribute(e, a),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.a.copy(e.a),
                        this.b.copy(e.b),
                        this.c.copy(e.c),
                        this
                    }
                    getArea() {
                        return _o.subVectors(this.c, this.b),
                        ac.subVectors(this.a, this.b),
                        _o.cross(ac).length() * .5
                    }
                    getMidpoint(e) {
                        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(e) {
                        return Np.getNormal(this.a, this.b, this.c, e)
                    }
                    getPlane(e) {
                        return e.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(e, n) {
                        return Np.getBarycoord(e, this.a, this.b, this.c, n)
                    }
                    getInterpolation(e, n, i, a, o) {
                        return Np.getInterpolation(e, this.a, this.b, this.c, n, i, a, o)
                    }
                    containsPoint(e) {
                        return Np.containsPoint(e, this.a, this.b, this.c)
                    }
                    isFrontFacing(e) {
                        return Np.isFrontFacing(this.a, this.b, this.c, e)
                    }
                    intersectsBox(e) {
                        return e.intersectsTriangle(this)
                    }
                    closestPointToPoint(e, n) {
                        const i = this.a
                          , a = this.b
                          , o = this.c;
                        let u, f;
                        Fd.subVectors(a, i),
                        Hd.subVectors(o, i),
                        Xx.subVectors(e, i);
                        const d = Fd.dot(Xx)
                          , p = Hd.dot(Xx);
                        if (d <= 0 && p <= 0)
                            return n.copy(i);
                        Wx.subVectors(e, a);
                        const g = Fd.dot(Wx)
                          , v = Hd.dot(Wx);
                        if (g >= 0 && v <= g)
                            return n.copy(a);
                        const y = d * v - g * p;
                        if (y <= 0 && d >= 0 && g <= 0)
                            return u = d / (d - g),
                            n.copy(i).addScaledVector(Fd, u);
                        Yx.subVectors(e, o);
                        const S = Fd.dot(Yx)
                          , E = Hd.dot(Yx);
                        if (E >= 0 && S <= E)
                            return n.copy(o);
                        const w = S * p - d * E;
                        if (w <= 0 && p >= 0 && E <= 0)
                            return f = p / (p - E),
                            n.copy(i).addScaledVector(Hd, f);
                        const A = g * E - S * v;
                        if (A <= 0 && v - g >= 0 && S - E >= 0)
                            return oA.subVectors(o, a),
                            f = (v - g) / (v - g + (S - E)),
                            n.copy(a).addScaledVector(oA, f);
                        const T = 1 / (A + w + y);
                        return u = w * T,
                        f = y * T,
                        n.copy(i).addScaledVector(Fd, u).addScaledVector(Hd, f)
                    }
                    equals(e) {
                        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                    }
                }
                ;
                const lA = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                }
                  , cu = {
                    h: 0,
                    s: 0,
                    l: 0
                }
                  , W0 = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                function Kx(t, e, n) {
                    return n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t
                }
                var ut = class {
                    constructor(t, e, n) {
                        return this.isColor = !0,
                        this.r = 1,
                        this.g = 1,
                        this.b = 1,
                        this.set(t, e, n)
                    }
                    set(t, e, n) {
                        if (e === void 0 && n === void 0) {
                            const i = t;
                            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
                        } else
                            this.setRGB(t, e, n);
                        return this
                    }
                    setScalar(t) {
                        return this.r = t,
                        this.g = t,
                        this.b = t,
                        this
                    }
                    setHex(t, e=Gs) {
                        return t = Math.floor(t),
                        this.r = (t >> 16 & 255) / 255,
                        this.g = (t >> 8 & 255) / 255,
                        this.b = (t & 255) / 255,
                        xn.colorSpaceToWorking(this, e),
                        this
                    }
                    setRGB(t, e, n, i=xn.workingColorSpace) {
                        return this.r = t,
                        this.g = e,
                        this.b = n,
                        xn.colorSpaceToWorking(this, i),
                        this
                    }
                    setHSL(t, e, n, i=xn.workingColorSpace) {
                        if (t = Ox(t, 1),
                        e = Ht(e, 0, 1),
                        n = Ht(n, 0, 1),
                        e === 0)
                            this.r = this.g = this.b = n;
                        else {
                            const a = n <= .5 ? n * (1 + e) : n + e - n * e
                              , o = 2 * n - a;
                            this.r = Kx(o, a, t + 1 / 3),
                            this.g = Kx(o, a, t),
                            this.b = Kx(o, a, t - 1 / 3)
                        }
                        return xn.colorSpaceToWorking(this, i),
                        this
                    }
                    setStyle(t, e=Gs) {
                        function n(a) {
                            a !== void 0 && parseFloat(a) < 1 && at("Color: Alpha component of " + t + " will be ignored.")
                        }
                        let i;
                        if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                            let a;
                            const o = i[1]
                              , u = i[2];
                            switch (o) {
                            case "rgb":
                            case "rgba":
                                if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
                                    return n(a[4]),
                                    this.setRGB(Math.min(255, parseInt(a[1], 10)) / 255, Math.min(255, parseInt(a[2], 10)) / 255, Math.min(255, parseInt(a[3], 10)) / 255, e);
                                if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
                                    return n(a[4]),
                                    this.setRGB(Math.min(100, parseInt(a[1], 10)) / 100, Math.min(100, parseInt(a[2], 10)) / 100, Math.min(100, parseInt(a[3], 10)) / 100, e);
                                break;
                            case "hsl":
                            case "hsla":
                                if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
                                    return n(a[4]),
                                    this.setHSL(parseFloat(a[1]) / 360, parseFloat(a[2]) / 100, parseFloat(a[3]) / 100, e);
                                break;
                            default:
                                at("Color: Unknown color model " + t)
                            }
                        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const a = i[1]
                              , o = a.length;
                            if (o === 3)
                                return this.setRGB(parseInt(a.charAt(0), 16) / 15, parseInt(a.charAt(1), 16) / 15, parseInt(a.charAt(2), 16) / 15, e);
                            if (o === 6)
                                return this.setHex(parseInt(a, 16), e);
                            at("Color: Invalid hex color " + t)
                        } else if (t && t.length > 0)
                            return this.setColorName(t, e);
                        return this
                    }
                    setColorName(t, e=Gs) {
                        const n = lA[t.toLowerCase()];
                        return n !== void 0 ? this.setHex(n, e) : at("Color: Unknown color " + t),
                        this
                    }
                    clone() {
                        return new this.constructor(this.r,this.g,this.b)
                    }
                    copy(t) {
                        return this.r = t.r,
                        this.g = t.g,
                        this.b = t.b,
                        this
                    }
                    copySRGBToLinear(t) {
                        return this.r = tc(t.r),
                        this.g = tc(t.g),
                        this.b = tc(t.b),
                        this
                    }
                    copyLinearToSRGB(t) {
                        return this.r = Nd(t.r),
                        this.g = Nd(t.g),
                        this.b = Nd(t.b),
                        this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this),
                        this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this),
                        this
                    }
                    getHex(t=Gs) {
                        return xn.workingToColorSpace(Xs.copy(this), t),
                        Math.round(Ht(Xs.r * 255, 0, 255)) * 65536 + Math.round(Ht(Xs.g * 255, 0, 255)) * 256 + Math.round(Ht(Xs.b * 255, 0, 255))
                    }
                    getHexString(t=Gs) {
                        return ("000000" + this.getHex(t).toString(16)).slice(-6)
                    }
                    getHSL(t, e=xn.workingColorSpace) {
                        xn.workingToColorSpace(Xs.copy(this), e);
                        const n = Xs.r
                          , i = Xs.g
                          , a = Xs.b
                          , o = Math.max(n, i, a)
                          , u = Math.min(n, i, a);
                        let f, d;
                        const p = (u + o) / 2;
                        if (u === o)
                            f = 0,
                            d = 0;
                        else {
                            const g = o - u;
                            switch (d = p <= .5 ? g / (o + u) : g / (2 - o - u),
                            o) {
                            case n:
                                f = (i - a) / g + (i < a ? 6 : 0);
                                break;
                            case i:
                                f = (a - n) / g + 2;
                                break;
                            case a:
                                f = (n - i) / g + 4;
                                break
                            }
                            f /= 6
                        }
                        return t.h = f,
                        t.s = d,
                        t.l = p,
                        t
                    }
                    getRGB(t, e=xn.workingColorSpace) {
                        return xn.workingToColorSpace(Xs.copy(this), e),
                        t.r = Xs.r,
                        t.g = Xs.g,
                        t.b = Xs.b,
                        t
                    }
                    getStyle(t=Gs) {
                        xn.workingToColorSpace(Xs.copy(this), t);
                        const e = Xs.r
                          , n = Xs.g
                          , i = Xs.b;
                        return t !== Gs ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
                    }
                    offsetHSL(t, e, n) {
                        return this.getHSL(cu),
                        this.setHSL(cu.h + t, cu.s + e, cu.l + n)
                    }
                    add(t) {
                        return this.r += t.r,
                        this.g += t.g,
                        this.b += t.b,
                        this
                    }
                    addColors(t, e) {
                        return this.r = t.r + e.r,
                        this.g = t.g + e.g,
                        this.b = t.b + e.b,
                        this
                    }
                    addScalar(t) {
                        return this.r += t,
                        this.g += t,
                        this.b += t,
                        this
                    }
                    sub(t) {
                        return this.r = Math.max(0, this.r - t.r),
                        this.g = Math.max(0, this.g - t.g),
                        this.b = Math.max(0, this.b - t.b),
                        this
                    }
                    multiply(t) {
                        return this.r *= t.r,
                        this.g *= t.g,
                        this.b *= t.b,
                        this
                    }
                    multiplyScalar(t) {
                        return this.r *= t,
                        this.g *= t,
                        this.b *= t,
                        this
                    }
                    lerp(t, e) {
                        return this.r += (t.r - this.r) * e,
                        this.g += (t.g - this.g) * e,
                        this.b += (t.b - this.b) * e,
                        this
                    }
                    lerpColors(t, e, n) {
                        return this.r = t.r + (e.r - t.r) * n,
                        this.g = t.g + (e.g - t.g) * n,
                        this.b = t.b + (e.b - t.b) * n,
                        this
                    }
                    lerpHSL(t, e) {
                        this.getHSL(cu),
                        t.getHSL(W0);
                        const n = Sg(cu.h, W0.h, e)
                          , i = Sg(cu.s, W0.s, e)
                          , a = Sg(cu.l, W0.l, e);
                        return this.setHSL(n, i, a),
                        this
                    }
                    setFromVector3(t) {
                        return this.r = t.x,
                        this.g = t.y,
                        this.b = t.z,
                        this
                    }
                    applyMatrix3(t) {
                        const e = this.r
                          , n = this.g
                          , i = this.b
                          , a = t.elements;
                        return this.r = a[0] * e + a[3] * n + a[6] * i,
                        this.g = a[1] * e + a[4] * n + a[7] * i,
                        this.b = a[2] * e + a[5] * n + a[8] * i,
                        this
                    }
                    equals(t) {
                        return t.r === this.r && t.g === this.g && t.b === this.b
                    }
                    fromArray(t, e=0) {
                        return this.r = t[e],
                        this.g = t[e + 1],
                        this.b = t[e + 2],
                        this
                    }
                    toArray(t=[], e=0) {
                        return t[e] = this.r,
                        t[e + 1] = this.g,
                        t[e + 2] = this.b,
                        t
                    }
                    fromBufferAttribute(t, e) {
                        return this.r = t.getX(e),
                        this.g = t.getY(e),
                        this.b = t.getZ(e),
                        this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                    *[Symbol.iterator]() {
                        yield this.r,
                        yield this.g,
                        yield this.b
                    }
                }
                ;
                const Xs = new ut;
                ut.NAMES = lA;
                let hO = 0;
                var Ws = class extends cl {
                    constructor() {
                        super(),
                        this.isMaterial = !0,
                        Object.defineProperty(this, "id", {
                            value: hO++
                        }),
                        this.uuid = ir(),
                        this.name = "",
                        this.type = "Material",
                        this.blending = yh,
                        this.side = $l,
                        this.vertexColors = !1,
                        this.opacity = 1,
                        this.transparent = !1,
                        this.alphaHash = !1,
                        this.blendSrc = B_,
                        this.blendDst = P_,
                        this.blendEquation = Kc,
                        this.blendSrcAlpha = null,
                        this.blendDstAlpha = null,
                        this.blendEquationAlpha = null,
                        this.blendColor = new ut(0,0,0),
                        this.blendAlpha = 0,
                        this.depthFunc = Sh,
                        this.depthTest = !0,
                        this.depthWrite = !0,
                        this.stencilWriteMask = 255,
                        this.stencilFunc = Nx,
                        this.stencilRef = 0,
                        this.stencilFuncMask = 255,
                        this.stencilFail = Th,
                        this.stencilZFail = Th,
                        this.stencilZPass = Th,
                        this.stencilWrite = !1,
                        this.clippingPlanes = null,
                        this.clipIntersection = !1,
                        this.clipShadows = !1,
                        this.shadowSide = null,
                        this.colorWrite = !0,
                        this.precision = null,
                        this.polygonOffset = !1,
                        this.polygonOffsetFactor = 0,
                        this.polygonOffsetUnits = 0,
                        this.dithering = !1,
                        this.alphaToCoverage = !1,
                        this.premultipliedAlpha = !1,
                        this.forceSinglePass = !1,
                        this.allowOverride = !0,
                        this.visible = !0,
                        this.toneMapped = !0,
                        this.userData = {},
                        this.version = 0,
                        this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(t) {
                        this._alphaTest > 0 != t > 0 && this.version++,
                        this._alphaTest = t
                    }
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(t) {
                        if (t !== void 0)
                            for (const e in t) {
                                const n = t[e];
                                if (n === void 0) {
                                    at(`Material: parameter '${e}' has value of undefined.`);
                                    continue
                                }
                                const i = this[e];
                                if (i === void 0) {
                                    at(`Material: '${e}' is not a property of THREE.${this.type}.`);
                                    continue
                                }
                                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n
                            }
                    }
                    toJSON(t) {
                        const e = t === void 0 || typeof t == "string";
                        e && (t = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.7,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        n.uuid = this.uuid,
                        n.type = this.type,
                        this.name !== "" && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        this.roughness !== void 0 && (n.roughness = this.roughness),
                        this.metalness !== void 0 && (n.metalness = this.metalness),
                        this.sheen !== void 0 && (n.sheen = this.sheen),
                        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
                        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                        this.shininess !== void 0 && (n.shininess = this.shininess),
                        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
                        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                        this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(t).uuid),
                        this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(t).uuid),
                        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
                        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
                        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
                        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
                        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
                        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
                        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
                        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                        n.lightMapIntensity = this.lightMapIntensity),
                        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                        n.aoMapIntensity = this.aoMapIntensity),
                        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                        n.bumpScale = this.bumpScale),
                        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                        n.normalMapType = this.normalMapType,
                        n.normalScale = this.normalScale.toArray()),
                        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                        n.displacementScale = this.displacementScale,
                        n.displacementBias = this.displacementBias),
                        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
                        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                        this.combine !== void 0 && (n.combine = this.combine)),
                        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
                        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
                        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
                        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
                        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                        this.transmission !== void 0 && (n.transmission = this.transmission),
                        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                        this.thickness !== void 0 && (n.thickness = this.thickness),
                        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
                        this.size !== void 0 && (n.size = this.size),
                        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
                        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== yh && (n.blending = this.blending),
                        this.side !== $l && (n.side = this.side),
                        this.vertexColors === !0 && (n.vertexColors = !0),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        this.transparent === !0 && (n.transparent = !0),
                        this.blendSrc !== B_ && (n.blendSrc = this.blendSrc),
                        this.blendDst !== P_ && (n.blendDst = this.blendDst),
                        this.blendEquation !== Kc && (n.blendEquation = this.blendEquation),
                        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
                        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
                        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
                        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
                        this.depthFunc !== Sh && (n.depthFunc = this.depthFunc),
                        this.depthTest === !1 && (n.depthTest = this.depthTest),
                        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
                        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
                        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
                        this.stencilFunc !== Nx && (n.stencilFunc = this.stencilFunc),
                        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
                        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
                        this.stencilFail !== Th && (n.stencilFail = this.stencilFail),
                        this.stencilZFail !== Th && (n.stencilZFail = this.stencilZFail),
                        this.stencilZPass !== Th && (n.stencilZPass = this.stencilZPass),
                        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
                        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
                        this.polygonOffset === !0 && (n.polygonOffset = !0),
                        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
                        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
                        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
                        this.scale !== void 0 && (n.scale = this.scale),
                        this.dithering === !0 && (n.dithering = !0),
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        this.alphaHash === !0 && (n.alphaHash = !0),
                        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
                        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
                        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
                        this.allowOverride === !1 && (n.allowOverride = !1),
                        this.wireframe === !0 && (n.wireframe = !0),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
                        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
                        this.flatShading === !0 && (n.flatShading = !0),
                        this.visible === !1 && (n.visible = !1),
                        this.toneMapped === !1 && (n.toneMapped = !1),
                        this.fog === !1 && (n.fog = !1),
                        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
                        function i(a) {
                            const o = [];
                            for (const u in a) {
                                const f = a[u];
                                delete f.metadata,
                                o.push(f)
                            }
                            return o
                        }
                        if (e) {
                            const a = i(t.textures)
                              , o = i(t.images);
                            a.length > 0 && (n.textures = a),
                            o.length > 0 && (n.images = o)
                        }
                        return n
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        this.name = t.name,
                        this.blending = t.blending,
                        this.side = t.side,
                        this.vertexColors = t.vertexColors,
                        this.opacity = t.opacity,
                        this.transparent = t.transparent,
                        this.blendSrc = t.blendSrc,
                        this.blendDst = t.blendDst,
                        this.blendEquation = t.blendEquation,
                        this.blendSrcAlpha = t.blendSrcAlpha,
                        this.blendDstAlpha = t.blendDstAlpha,
                        this.blendEquationAlpha = t.blendEquationAlpha,
                        this.blendColor.copy(t.blendColor),
                        this.blendAlpha = t.blendAlpha,
                        this.depthFunc = t.depthFunc,
                        this.depthTest = t.depthTest,
                        this.depthWrite = t.depthWrite,
                        this.stencilWriteMask = t.stencilWriteMask,
                        this.stencilFunc = t.stencilFunc,
                        this.stencilRef = t.stencilRef,
                        this.stencilFuncMask = t.stencilFuncMask,
                        this.stencilFail = t.stencilFail,
                        this.stencilZFail = t.stencilZFail,
                        this.stencilZPass = t.stencilZPass,
                        this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (e !== null) {
                            const i = e.length;
                            n = new Array(i);
                            for (let a = 0; a !== i; ++a)
                                n[a] = e[a].clone()
                        }
                        return this.clippingPlanes = n,
                        this.clipIntersection = t.clipIntersection,
                        this.clipShadows = t.clipShadows,
                        this.shadowSide = t.shadowSide,
                        this.colorWrite = t.colorWrite,
                        this.precision = t.precision,
                        this.polygonOffset = t.polygonOffset,
                        this.polygonOffsetFactor = t.polygonOffsetFactor,
                        this.polygonOffsetUnits = t.polygonOffsetUnits,
                        this.dithering = t.dithering,
                        this.alphaTest = t.alphaTest,
                        this.alphaHash = t.alphaHash,
                        this.alphaToCoverage = t.alphaToCoverage,
                        this.premultipliedAlpha = t.premultipliedAlpha,
                        this.forceSinglePass = t.forceSinglePass,
                        this.allowOverride = t.allowOverride,
                        this.visible = t.visible,
                        this.toneMapped = t.toneMapped,
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    }
                }
                  , uu = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshBasicMaterial = !0,
                        this.type = "MeshBasicMaterial",
                        this.color = new ut(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new vo,
                        this.combine = ig,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.map = t.map,
                        this.lightMap = t.lightMap,
                        this.lightMapIntensity = t.lightMapIntensity,
                        this.aoMap = t.aoMap,
                        this.aoMapIntensity = t.aoMapIntensity,
                        this.specularMap = t.specularMap,
                        this.alphaMap = t.alphaMap,
                        this.envMap = t.envMap,
                        this.envMapRotation.copy(t.envMapRotation),
                        this.combine = t.combine,
                        this.reflectivity = t.reflectivity,
                        this.refractionRatio = t.refractionRatio,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.wireframeLinecap = t.wireframeLinecap,
                        this.wireframeLinejoin = t.wireframeLinejoin,
                        this.fog = t.fog,
                        this
                    }
                }
                ;
                const oc = fO();
                function fO() {
                    const t = new ArrayBuffer(4)
                      , e = new Float32Array(t)
                      , n = new Uint32Array(t)
                      , i = new Uint32Array(512)
                      , a = new Uint32Array(512);
                    for (let d = 0; d < 256; ++d) {
                        const p = d - 127;
                        p < -27 ? (i[d] = 0,
                        i[d | 256] = 32768,
                        a[d] = 24,
                        a[d | 256] = 24) : p < -14 ? (i[d] = 1024 >> -p - 14,
                        i[d | 256] = 1024 >> -p - 14 | 32768,
                        a[d] = -p - 1,
                        a[d | 256] = -p - 1) : p <= 15 ? (i[d] = p + 15 << 10,
                        i[d | 256] = p + 15 << 10 | 32768,
                        a[d] = 13,
                        a[d | 256] = 13) : p < 128 ? (i[d] = 31744,
                        i[d | 256] = 64512,
                        a[d] = 24,
                        a[d | 256] = 24) : (i[d] = 31744,
                        i[d | 256] = 64512,
                        a[d] = 13,
                        a[d | 256] = 13)
                    }
                    const o = new Uint32Array(2048)
                      , u = new Uint32Array(64)
                      , f = new Uint32Array(64);
                    for (let d = 1; d < 1024; ++d) {
                        let p = d << 13
                          , g = 0;
                        for (; (p & 8388608) === 0; )
                            p <<= 1,
                            g -= 8388608;
                        p &= -8388609,
                        g += 947912704,
                        o[d] = p | g
                    }
                    for (let d = 1024; d < 2048; ++d)
                        o[d] = 939524096 + (d - 1024 << 13);
                    for (let d = 1; d < 31; ++d)
                        u[d] = d << 23;
                    u[31] = 1199570944,
                    u[32] = 2147483648;
                    for (let d = 33; d < 63; ++d)
                        u[d] = 2147483648 + (d - 32 << 23);
                    u[63] = 3347054592;
                    for (let d = 1; d < 64; ++d)
                        d !== 32 && (f[d] = 1024);
                    return {
                        floatView: e,
                        uint32View: n,
                        baseTable: i,
                        shiftTable: a,
                        mantissaTable: o,
                        exponentTable: u,
                        offsetTable: f
                    }
                }
                function Ba(t) {
                    Math.abs(t) > 65504 && at("DataUtils.toHalfFloat(): Value out of range."),
                    t = Ht(t, -65504, 65504),
                    oc.floatView[0] = t;
                    const e = oc.uint32View[0]
                      , n = e >> 23 & 511;
                    return oc.baseTable[n] + ((e & 8388607) >> oc.shiftTable[n])
                }
                function Tg(t) {
                    const e = t >> 10;
                    return oc.uint32View[0] = oc.mantissaTable[oc.offsetTable[e] + (t & 1023)] + oc.exponentTable[e],
                    oc.floatView[0]
                }
                var dO = class {
                    static toHalfFloat(t) {
                        return Ba(t)
                    }
                    static fromHalfFloat(t) {
                        return Tg(t)
                    }
                }
                ;
                const Ki = new J
                  , Y0 = new Ge;
                let pO = 0;
                var Kn = class {
                    constructor(t, e, n=!1) {
                        if (Array.isArray(t))
                            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0,
                        Object.defineProperty(this, "id", {
                            value: pO++
                        }),
                        this.name = "",
                        this.array = t,
                        this.itemSize = e,
                        this.count = t !== void 0 ? t.length / e : 0,
                        this.normalized = n,
                        this.usage = vg,
                        this.updateRanges = [],
                        this.gpuType = pa,
                        this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    }
                    setUsage(t) {
                        return this.usage = t,
                        this
                    }
                    addUpdateRange(t, e) {
                        this.updateRanges.push({
                            start: t,
                            count: e
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(t) {
                        return this.name = t.name,
                        this.array = new t.array.constructor(t.array),
                        this.itemSize = t.itemSize,
                        this.count = t.count,
                        this.normalized = t.normalized,
                        this.usage = t.usage,
                        this.gpuType = t.gpuType,
                        this
                    }
                    copyAt(t, e, n) {
                        t *= this.itemSize,
                        n *= e.itemSize;
                        for (let i = 0, a = this.itemSize; i < a; i++)
                            this.array[t + i] = e.array[n + i];
                        return this
                    }
                    copyArray(t) {
                        return this.array.set(t),
                        this
                    }
                    applyMatrix3(t) {
                        if (this.itemSize === 2)
                            for (let e = 0, n = this.count; e < n; e++)
                                Y0.fromBufferAttribute(this, e),
                                Y0.applyMatrix3(t),
                                this.setXY(e, Y0.x, Y0.y);
                        else if (this.itemSize === 3)
                            for (let e = 0, n = this.count; e < n; e++)
                                Ki.fromBufferAttribute(this, e),
                                Ki.applyMatrix3(t),
                                this.setXYZ(e, Ki.x, Ki.y, Ki.z);
                        return this
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            Ki.fromBufferAttribute(this, e),
                            Ki.applyMatrix4(t),
                            this.setXYZ(e, Ki.x, Ki.y, Ki.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            Ki.fromBufferAttribute(this, e),
                            Ki.applyNormalMatrix(t),
                            this.setXYZ(e, Ki.x, Ki.y, Ki.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++)
                            Ki.fromBufferAttribute(this, e),
                            Ki.transformDirection(t),
                            this.setXYZ(e, Ki.x, Ki.y, Ki.z);
                        return this
                    }
                    set(t, e=0) {
                        return this.array.set(t, e),
                        this
                    }
                    getComponent(t, e) {
                        let n = this.array[t * this.itemSize + e];
                        return this.normalized && (n = ma(n, this.array)),
                        n
                    }
                    setComponent(t, e, n) {
                        return this.normalized && (n = $t(n, this.array)),
                        this.array[t * this.itemSize + e] = n,
                        this
                    }
                    getX(t) {
                        let e = this.array[t * this.itemSize];
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setX(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize] = e,
                        this
                    }
                    getY(t) {
                        let e = this.array[t * this.itemSize + 1];
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setY(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize + 1] = e,
                        this
                    }
                    getZ(t) {
                        let e = this.array[t * this.itemSize + 2];
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setZ(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize + 2] = e,
                        this
                    }
                    getW(t) {
                        let e = this.array[t * this.itemSize + 3];
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setW(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize + 3] = e,
                        this
                    }
                    setXY(t, e, n) {
                        return t *= this.itemSize,
                        this.normalized && (e = $t(e, this.array),
                        n = $t(n, this.array)),
                        this.array[t + 0] = e,
                        this.array[t + 1] = n,
                        this
                    }
                    setXYZ(t, e, n, i) {
                        return t *= this.itemSize,
                        this.normalized && (e = $t(e, this.array),
                        n = $t(n, this.array),
                        i = $t(i, this.array)),
                        this.array[t + 0] = e,
                        this.array[t + 1] = n,
                        this.array[t + 2] = i,
                        this
                    }
                    setXYZW(t, e, n, i, a) {
                        return t *= this.itemSize,
                        this.normalized && (e = $t(e, this.array),
                        n = $t(n, this.array),
                        i = $t(i, this.array),
                        a = $t(a, this.array)),
                        this.array[t + 0] = e,
                        this.array[t + 1] = n,
                        this.array[t + 2] = i,
                        this.array[t + 3] = a,
                        this
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t,
                        this
                    }
                    clone() {
                        return new this.constructor(this.array,this.itemSize).copy(this)
                    }
                    toJSON() {
                        const t = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        return this.name !== "" && (t.name = this.name),
                        this.usage !== vg && (t.usage = this.usage),
                        t
                    }
                }
                  , mO = class extends Kn {
                    constructor(t, e, n) {
                        super(new Int8Array(t), e, n)
                    }
                }
                  , gO = class extends Kn {
                    constructor(t, e, n) {
                        super(new Uint8Array(t), e, n)
                    }
                }
                  , vO = class extends Kn {
                    constructor(t, e, n) {
                        super(new Uint8ClampedArray(t), e, n)
                    }
                }
                  , _O = class extends Kn {
                    constructor(t, e, n) {
                        super(new Int16Array(t), e, n)
                    }
                }
                  , Jx = class extends Kn {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n)
                    }
                }
                  , yO = class extends Kn {
                    constructor(t, e, n) {
                        super(new Int32Array(t), e, n)
                    }
                }
                  , $x = class extends Kn {
                    constructor(t, e, n) {
                        super(new Uint32Array(t), e, n)
                    }
                }
                  , SO = class extends Kn {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n),
                        this.isFloat16BufferAttribute = !0
                    }
                    getX(t) {
                        let e = Tg(this.array[t * this.itemSize]);
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setX(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize] = Ba(e),
                        this
                    }
                    getY(t) {
                        let e = Tg(this.array[t * this.itemSize + 1]);
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setY(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize + 1] = Ba(e),
                        this
                    }
                    getZ(t) {
                        let e = Tg(this.array[t * this.itemSize + 2]);
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setZ(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize + 2] = Ba(e),
                        this
                    }
                    getW(t) {
                        let e = Tg(this.array[t * this.itemSize + 3]);
                        return this.normalized && (e = ma(e, this.array)),
                        e
                    }
                    setW(t, e) {
                        return this.normalized && (e = $t(e, this.array)),
                        this.array[t * this.itemSize + 3] = Ba(e),
                        this
                    }
                    setXY(t, e, n) {
                        return t *= this.itemSize,
                        this.normalized && (e = $t(e, this.array),
                        n = $t(n, this.array)),
                        this.array[t + 0] = Ba(e),
                        this.array[t + 1] = Ba(n),
                        this
                    }
                    setXYZ(t, e, n, i) {
                        return t *= this.itemSize,
                        this.normalized && (e = $t(e, this.array),
                        n = $t(n, this.array),
                        i = $t(i, this.array)),
                        this.array[t + 0] = Ba(e),
                        this.array[t + 1] = Ba(n),
                        this.array[t + 2] = Ba(i),
                        this
                    }
                    setXYZW(t, e, n, i, a) {
                        return t *= this.itemSize,
                        this.normalized && (e = $t(e, this.array),
                        n = $t(n, this.array),
                        i = $t(i, this.array),
                        a = $t(a, this.array)),
                        this.array[t + 0] = Ba(e),
                        this.array[t + 1] = Ba(n),
                        this.array[t + 2] = Ba(i),
                        this.array[t + 3] = Ba(a),
                        this
                    }
                }
                  , _t = class extends Kn {
                    constructor(t, e, n) {
                        super(new Float32Array(t), e, n)
                    }
                }
                ;
                let xO = 0;
                const zr = new jt
                  , eM = new zn
                  , Gd = new J
                  , rr = new qs
                  , Ag = new qs
                  , vs = new J;
                var en = class gR extends cl {
                    constructor() {
                        super(),
                        this.isBufferGeometry = !0,
                        Object.defineProperty(this, "id", {
                            value: xO++
                        }),
                        this.uuid = ir(),
                        this.name = "",
                        this.type = "BufferGeometry",
                        this.index = null,
                        this.indirect = null,
                        this.indirectOffset = 0,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.morphTargetsRelative = !1,
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        },
                        this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(e) {
                        return Array.isArray(e) ? this.index = new (X1(e) ? $x : Jx)(e,1) : this.index = e,
                        this
                    }
                    setIndirect(e, n=0) {
                        return this.indirect = e,
                        this.indirectOffset = n,
                        this
                    }
                    getIndirect() {
                        return this.indirect
                    }
                    getAttribute(e) {
                        return this.attributes[e]
                    }
                    setAttribute(e, n) {
                        return this.attributes[e] = n,
                        this
                    }
                    deleteAttribute(e) {
                        return delete this.attributes[e],
                        this
                    }
                    hasAttribute(e) {
                        return this.attributes[e] !== void 0
                    }
                    addGroup(e, n, i=0) {
                        this.groups.push({
                            start: e,
                            count: n,
                            materialIndex: i
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(e, n) {
                        this.drawRange.start = e,
                        this.drawRange.count = n
                    }
                    applyMatrix4(e) {
                        const n = this.attributes.position;
                        n !== void 0 && (n.applyMatrix4(e),
                        n.needsUpdate = !0);
                        const i = this.attributes.normal;
                        if (i !== void 0) {
                            const o = new sn().getNormalMatrix(e);
                            i.applyNormalMatrix(o),
                            i.needsUpdate = !0
                        }
                        const a = this.attributes.tangent;
                        return a !== void 0 && (a.transformDirection(e),
                        a.needsUpdate = !0),
                        this.boundingBox !== null && this.computeBoundingBox(),
                        this.boundingSphere !== null && this.computeBoundingSphere(),
                        this
                    }
                    applyQuaternion(e) {
                        return zr.makeRotationFromQuaternion(e),
                        this.applyMatrix4(zr),
                        this
                    }
                    rotateX(e) {
                        return zr.makeRotationX(e),
                        this.applyMatrix4(zr),
                        this
                    }
                    rotateY(e) {
                        return zr.makeRotationY(e),
                        this.applyMatrix4(zr),
                        this
                    }
                    rotateZ(e) {
                        return zr.makeRotationZ(e),
                        this.applyMatrix4(zr),
                        this
                    }
                    translate(e, n, i) {
                        return zr.makeTranslation(e, n, i),
                        this.applyMatrix4(zr),
                        this
                    }
                    scale(e, n, i) {
                        return zr.makeScale(e, n, i),
                        this.applyMatrix4(zr),
                        this
                    }
                    lookAt(e) {
                        return eM.lookAt(e),
                        eM.updateMatrix(),
                        this.applyMatrix4(eM.matrix),
                        this
                    }
                    center() {
                        return this.computeBoundingBox(),
                        this.boundingBox.getCenter(Gd).negate(),
                        this.translate(Gd.x, Gd.y, Gd.z),
                        this
                    }
                    setFromPoints(e) {
                        const n = this.getAttribute("position");
                        if (n === void 0) {
                            const i = [];
                            for (let a = 0, o = e.length; a < o; a++) {
                                const u = e[a];
                                i.push(u.x, u.y, u.z || 0)
                            }
                            this.setAttribute("position", new _t(i,3))
                        } else {
                            const i = Math.min(e.length, n.count);
                            for (let a = 0; a < i; a++) {
                                const o = e[a];
                                n.setXYZ(a, o.x, o.y, o.z || 0)
                            }
                            e.length > n.count && at("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                            n.needsUpdate = !0
                        }
                        return this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new qs);
                        const e = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (e && e.isGLBufferAttribute) {
                            Rt("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                            this.boundingBox.set(new J(-1 / 0,-1 / 0,-1 / 0), new J(1 / 0,1 / 0,1 / 0));
                            return
                        }
                        if (e !== void 0) {
                            if (this.boundingBox.setFromBufferAttribute(e),
                            n)
                                for (let i = 0, a = n.length; i < a; i++) {
                                    const o = n[i];
                                    rr.setFromBufferAttribute(o),
                                    this.morphTargetsRelative ? (vs.addVectors(this.boundingBox.min, rr.min),
                                    this.boundingBox.expandByPoint(vs),
                                    vs.addVectors(this.boundingBox.max, rr.max),
                                    this.boundingBox.expandByPoint(vs)) : (this.boundingBox.expandByPoint(rr.min),
                                    this.boundingBox.expandByPoint(rr.max))
                                }
                        } else
                            this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && Rt('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new As);
                        const e = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (e && e.isGLBufferAttribute) {
                            Rt("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                            this.boundingSphere.set(new J, 1 / 0);
                            return
                        }
                        if (e) {
                            const i = this.boundingSphere.center;
                            if (rr.setFromBufferAttribute(e),
                            n)
                                for (let o = 0, u = n.length; o < u; o++) {
                                    const f = n[o];
                                    Ag.setFromBufferAttribute(f),
                                    this.morphTargetsRelative ? (vs.addVectors(rr.min, Ag.min),
                                    rr.expandByPoint(vs),
                                    vs.addVectors(rr.max, Ag.max),
                                    rr.expandByPoint(vs)) : (rr.expandByPoint(Ag.min),
                                    rr.expandByPoint(Ag.max))
                                }
                            rr.getCenter(i);
                            let a = 0;
                            for (let o = 0, u = e.count; o < u; o++)
                                vs.fromBufferAttribute(e, o),
                                a = Math.max(a, i.distanceToSquared(vs));
                            if (n)
                                for (let o = 0, u = n.length; o < u; o++) {
                                    const f = n[o]
                                      , d = this.morphTargetsRelative;
                                    for (let p = 0, g = f.count; p < g; p++)
                                        vs.fromBufferAttribute(f, p),
                                        d && (Gd.fromBufferAttribute(e, p),
                                        vs.add(Gd)),
                                        a = Math.max(a, i.distanceToSquared(vs))
                                }
                            this.boundingSphere.radius = Math.sqrt(a),
                            isNaN(this.boundingSphere.radius) && Rt('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const e = this.index
                          , n = this.attributes;
                        if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
                            Rt("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            return
                        }
                        const i = n.position
                          , a = n.normal
                          , o = n.uv;
                        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Kn(new Float32Array(4 * i.count),4));
                        const u = this.getAttribute("tangent")
                          , f = []
                          , d = [];
                        for (let V = 0; V < i.count; V++)
                            f[V] = new J,
                            d[V] = new J;
                        const p = new J
                          , g = new J
                          , v = new J
                          , y = new Ge
                          , S = new Ge
                          , E = new Ge
                          , w = new J
                          , A = new J;
                        function T(V, B, P) {
                            p.fromBufferAttribute(i, V),
                            g.fromBufferAttribute(i, B),
                            v.fromBufferAttribute(i, P),
                            y.fromBufferAttribute(o, V),
                            S.fromBufferAttribute(o, B),
                            E.fromBufferAttribute(o, P),
                            g.sub(p),
                            v.sub(p),
                            S.sub(y),
                            E.sub(y);
                            const G = 1 / (S.x * E.y - E.x * S.y);
                            isFinite(G) && (w.copy(g).multiplyScalar(E.y).addScaledVector(v, -S.y).multiplyScalar(G),
                            A.copy(v).multiplyScalar(S.x).addScaledVector(g, -E.x).multiplyScalar(G),
                            f[V].add(w),
                            f[B].add(w),
                            f[P].add(w),
                            d[V].add(A),
                            d[B].add(A),
                            d[P].add(A))
                        }
                        let R = this.groups;
                        R.length === 0 && (R = [{
                            start: 0,
                            count: e.count
                        }]);
                        for (let V = 0, B = R.length; V < B; ++V) {
                            const P = R[V]
                              , G = P.start
                              , K = P.count;
                            for (let ee = G, te = G + K; ee < te; ee += 3)
                                T(e.getX(ee + 0), e.getX(ee + 1), e.getX(ee + 2))
                        }
                        const N = new J
                          , D = new J
                          , U = new J
                          , z = new J;
                        function I(V) {
                            U.fromBufferAttribute(a, V),
                            z.copy(U);
                            const B = f[V];
                            N.copy(B),
                            N.sub(U.multiplyScalar(U.dot(B))).normalize(),
                            D.crossVectors(z, B);
                            const P = D.dot(d[V]) < 0 ? -1 : 1;
                            u.setXYZW(V, N.x, N.y, N.z, P)
                        }
                        for (let V = 0, B = R.length; V < B; ++V) {
                            const P = R[V]
                              , G = P.start
                              , K = P.count;
                            for (let ee = G, te = G + K; ee < te; ee += 3)
                                I(e.getX(ee + 0)),
                                I(e.getX(ee + 1)),
                                I(e.getX(ee + 2))
                        }
                    }
                    computeVertexNormals() {
                        const e = this.index
                          , n = this.getAttribute("position");
                        if (n !== void 0) {
                            let i = this.getAttribute("normal");
                            if (i === void 0)
                                i = new Kn(new Float32Array(n.count * 3),3),
                                this.setAttribute("normal", i);
                            else
                                for (let y = 0, S = i.count; y < S; y++)
                                    i.setXYZ(y, 0, 0, 0);
                            const a = new J
                              , o = new J
                              , u = new J
                              , f = new J
                              , d = new J
                              , p = new J
                              , g = new J
                              , v = new J;
                            if (e)
                                for (let y = 0, S = e.count; y < S; y += 3) {
                                    const E = e.getX(y + 0)
                                      , w = e.getX(y + 1)
                                      , A = e.getX(y + 2);
                                    a.fromBufferAttribute(n, E),
                                    o.fromBufferAttribute(n, w),
                                    u.fromBufferAttribute(n, A),
                                    g.subVectors(u, o),
                                    v.subVectors(a, o),
                                    g.cross(v),
                                    f.fromBufferAttribute(i, E),
                                    d.fromBufferAttribute(i, w),
                                    p.fromBufferAttribute(i, A),
                                    f.add(g),
                                    d.add(g),
                                    p.add(g),
                                    i.setXYZ(E, f.x, f.y, f.z),
                                    i.setXYZ(w, d.x, d.y, d.z),
                                    i.setXYZ(A, p.x, p.y, p.z)
                                }
                            else
                                for (let y = 0, S = n.count; y < S; y += 3)
                                    a.fromBufferAttribute(n, y + 0),
                                    o.fromBufferAttribute(n, y + 1),
                                    u.fromBufferAttribute(n, y + 2),
                                    g.subVectors(u, o),
                                    v.subVectors(a, o),
                                    g.cross(v),
                                    i.setXYZ(y + 0, g.x, g.y, g.z),
                                    i.setXYZ(y + 1, g.x, g.y, g.z),
                                    i.setXYZ(y + 2, g.x, g.y, g.z);
                            this.normalizeNormals(),
                            i.needsUpdate = !0
                        }
                    }
                    normalizeNormals() {
                        const e = this.attributes.normal;
                        for (let n = 0, i = e.count; n < i; n++)
                            vs.fromBufferAttribute(e, n),
                            vs.normalize(),
                            e.setXYZ(n, vs.x, vs.y, vs.z)
                    }
                    toNonIndexed() {
                        function e(f, d) {
                            const p = f.array
                              , g = f.itemSize
                              , v = f.normalized
                              , y = new p.constructor(d.length * g);
                            let S = 0
                              , E = 0;
                            for (let w = 0, A = d.length; w < A; w++) {
                                f.isInterleavedBufferAttribute ? S = d[w] * f.data.stride + f.offset : S = d[w] * g;
                                for (let T = 0; T < g; T++)
                                    y[E++] = p[S++]
                            }
                            return new Kn(y,g,v)
                        }
                        if (this.index === null)
                            return at("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                            this;
                        const n = new gR
                          , i = this.index.array
                          , a = this.attributes;
                        for (const f in a) {
                            const d = a[f]
                              , p = e(d, i);
                            n.setAttribute(f, p)
                        }
                        const o = this.morphAttributes;
                        for (const f in o) {
                            const d = []
                              , p = o[f];
                            for (let g = 0, v = p.length; g < v; g++) {
                                const y = p[g]
                                  , S = e(y, i);
                                d.push(S)
                            }
                            n.morphAttributes[f] = d
                        }
                        n.morphTargetsRelative = this.morphTargetsRelative;
                        const u = this.groups;
                        for (let f = 0, d = u.length; f < d; f++) {
                            const p = u[f];
                            n.addGroup(p.start, p.count, p.materialIndex)
                        }
                        return n
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.7,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (e.uuid = this.uuid,
                        e.type = this.type,
                        this.name !== "" && (e.name = this.name),
                        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                        this.parameters !== void 0) {
                            const d = this.parameters;
                            for (const p in d)
                                d[p] !== void 0 && (e[p] = d[p]);
                            return e
                        }
                        e.data = {
                            attributes: {}
                        };
                        const n = this.index;
                        n !== null && (e.data.index = {
                            type: n.array.constructor.name,
                            array: Array.prototype.slice.call(n.array)
                        });
                        const i = this.attributes;
                        for (const d in i) {
                            const p = i[d];
                            e.data.attributes[d] = p.toJSON(e.data)
                        }
                        const a = {};
                        let o = !1;
                        for (const d in this.morphAttributes) {
                            const p = this.morphAttributes[d]
                              , g = [];
                            for (let v = 0, y = p.length; v < y; v++) {
                                const S = p[v];
                                g.push(S.toJSON(e.data))
                            }
                            g.length > 0 && (a[d] = g,
                            o = !0)
                        }
                        o && (e.data.morphAttributes = a,
                        e.data.morphTargetsRelative = this.morphTargetsRelative);
                        const u = this.groups;
                        u.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(u)));
                        const f = this.boundingSphere;
                        return f !== null && (e.data.boundingSphere = f.toJSON()),
                        e
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.index = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        const n = {};
                        this.name = e.name;
                        const i = e.index;
                        i !== null && this.setIndex(i.clone());
                        const a = e.attributes;
                        for (const p in a) {
                            const g = a[p];
                            this.setAttribute(p, g.clone(n))
                        }
                        const o = e.morphAttributes;
                        for (const p in o) {
                            const g = []
                              , v = o[p];
                            for (let y = 0, S = v.length; y < S; y++)
                                g.push(v[y].clone(n));
                            this.morphAttributes[p] = g
                        }
                        this.morphTargetsRelative = e.morphTargetsRelative;
                        const u = e.groups;
                        for (let p = 0, g = u.length; p < g; p++) {
                            const v = u[p];
                            this.addGroup(v.start, v.count, v.materialIndex)
                        }
                        const f = e.boundingBox;
                        f !== null && (this.boundingBox = f.clone());
                        const d = e.boundingSphere;
                        return d !== null && (this.boundingSphere = d.clone()),
                        this.drawRange.start = e.drawRange.start,
                        this.drawRange.count = e.drawRange.count,
                        this.userData = e.userData,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                ;
                const cA = new jt
                  , wh = new Id
                  , j0 = new As
                  , uA = new J
                  , Z0 = new J
                  , Q0 = new J
                  , K0 = new J
                  , tM = new J
                  , J0 = new J
                  , hA = new J
                  , $0 = new J;
                var Ji = class extends zn {
                    constructor(t=new en, e=new uu) {
                        super(),
                        this.isMesh = !0,
                        this.type = "Mesh",
                        this.geometry = t,
                        this.material = e,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.count = 1,
                        this.updateMorphTargets()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                        t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                        this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                        this.geometry = t.geometry,
                        this
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes
                          , e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, a = n.length; i < a; i++) {
                                    const o = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[o] = i
                                }
                            }
                        }
                    }
                    getVertexPosition(t, e) {
                        const n = this.geometry
                          , i = n.attributes.position
                          , a = n.morphAttributes.position
                          , o = n.morphTargetsRelative;
                        e.fromBufferAttribute(i, t);
                        const u = this.morphTargetInfluences;
                        if (a && u) {
                            J0.set(0, 0, 0);
                            for (let f = 0, d = a.length; f < d; f++) {
                                const p = u[f]
                                  , g = a[f];
                                p !== 0 && (tM.fromBufferAttribute(g, t),
                                o ? J0.addScaledVector(tM, p) : J0.addScaledVector(tM.sub(e), p))
                            }
                            e.add(J0)
                        }
                        return e
                    }
                    raycast(t, e) {
                        const n = this.geometry
                          , i = this.material
                          , a = this.matrixWorld;
                        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
                        j0.copy(n.boundingSphere),
                        j0.applyMatrix4(a),
                        wh.copy(t.ray).recast(t.near),
                        !(j0.containsPoint(wh.origin) === !1 && (wh.intersectSphere(j0, uA) === null || wh.origin.distanceToSquared(uA) > (t.far - t.near) ** 2)) && (cA.copy(a).invert(),
                        wh.copy(t.ray).applyMatrix4(cA),
                        !(n.boundingBox !== null && wh.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(t, e, wh)))
                    }
                    _computeIntersections(t, e, n) {
                        let i;
                        const a = this.geometry
                          , o = this.material
                          , u = a.index
                          , f = a.attributes.position
                          , d = a.attributes.uv
                          , p = a.attributes.uv1
                          , g = a.attributes.normal
                          , v = a.groups
                          , y = a.drawRange;
                        if (u !== null)
                            if (Array.isArray(o))
                                for (let S = 0, E = v.length; S < E; S++) {
                                    const w = v[S]
                                      , A = o[w.materialIndex]
                                      , T = Math.max(w.start, y.start)
                                      , R = Math.min(u.count, Math.min(w.start + w.count, y.start + y.count));
                                    for (let N = T, D = R; N < D; N += 3) {
                                        const U = u.getX(N)
                                          , z = u.getX(N + 1)
                                          , I = u.getX(N + 2);
                                        i = ey(this, A, t, n, d, p, g, U, z, I),
                                        i && (i.faceIndex = Math.floor(N / 3),
                                        i.face.materialIndex = w.materialIndex,
                                        e.push(i))
                                    }
                                }
                            else {
                                const S = Math.max(0, y.start)
                                  , E = Math.min(u.count, y.start + y.count);
                                for (let w = S, A = E; w < A; w += 3) {
                                    const T = u.getX(w)
                                      , R = u.getX(w + 1)
                                      , N = u.getX(w + 2);
                                    i = ey(this, o, t, n, d, p, g, T, R, N),
                                    i && (i.faceIndex = Math.floor(w / 3),
                                    e.push(i))
                                }
                            }
                        else if (f !== void 0)
                            if (Array.isArray(o))
                                for (let S = 0, E = v.length; S < E; S++) {
                                    const w = v[S]
                                      , A = o[w.materialIndex]
                                      , T = Math.max(w.start, y.start)
                                      , R = Math.min(f.count, Math.min(w.start + w.count, y.start + y.count));
                                    for (let N = T, D = R; N < D; N += 3) {
                                        const U = N
                                          , z = N + 1
                                          , I = N + 2;
                                        i = ey(this, A, t, n, d, p, g, U, z, I),
                                        i && (i.faceIndex = Math.floor(N / 3),
                                        i.face.materialIndex = w.materialIndex,
                                        e.push(i))
                                    }
                                }
                            else {
                                const S = Math.max(0, y.start)
                                  , E = Math.min(f.count, y.start + y.count);
                                for (let w = S, A = E; w < A; w += 3) {
                                    const T = w
                                      , R = w + 1
                                      , N = w + 2;
                                    i = ey(this, o, t, n, d, p, g, T, R, N),
                                    i && (i.faceIndex = Math.floor(w / 3),
                                    e.push(i))
                                }
                            }
                    }
                }
                ;
                function MO(t, e, n, i, a, o, u, f) {
                    let d;
                    if (e.side === fa ? d = i.intersectTriangle(u, o, a, !0, f) : d = i.intersectTriangle(a, o, u, e.side === $l, f),
                    d === null)
                        return null;
                    $0.copy(f),
                    $0.applyMatrix4(t.matrixWorld);
                    const p = n.ray.origin.distanceTo($0);
                    return p < n.near || p > n.far ? null : {
                        distance: p,
                        point: $0.clone(),
                        object: t
                    }
                }
                function ey(t, e, n, i, a, o, u, f, d, p) {
                    t.getVertexPosition(f, Z0),
                    t.getVertexPosition(d, Q0),
                    t.getVertexPosition(p, K0);
                    const g = MO(t, e, n, i, Z0, Q0, K0, hA);
                    if (g) {
                        const v = new J;
                        lu.getBarycoord(hA, Z0, Q0, K0, v),
                        a && (g.uv = lu.getInterpolatedAttribute(a, f, d, p, v, new Ge)),
                        o && (g.uv1 = lu.getInterpolatedAttribute(o, f, d, p, v, new Ge)),
                        u && (g.normal = lu.getInterpolatedAttribute(u, f, d, p, v, new J),
                        g.normal.dot(i.direction) > 0 && g.normal.multiplyScalar(-1));
                        const y = {
                            a: f,
                            b: d,
                            c: p,
                            normal: new J,
                            materialIndex: 0
                        };
                        lu.getNormal(Z0, Q0, K0, y.normal),
                        g.face = y,
                        g.barycoord = v
                    }
                    return g
                }
                var Eg = class vR extends en {
                    constructor(e=1, n=1, i=1, a=1, o=1, u=1) {
                        super(),
                        this.type = "BoxGeometry",
                        this.parameters = {
                            width: e,
                            height: n,
                            depth: i,
                            widthSegments: a,
                            heightSegments: o,
                            depthSegments: u
                        };
                        const f = this;
                        a = Math.floor(a),
                        o = Math.floor(o),
                        u = Math.floor(u);
                        const d = []
                          , p = []
                          , g = []
                          , v = [];
                        let y = 0
                          , S = 0;
                        E("z", "y", "x", -1, -1, i, n, e, u, o, 0),
                        E("z", "y", "x", 1, -1, i, n, -e, u, o, 1),
                        E("x", "z", "y", 1, 1, e, i, n, a, u, 2),
                        E("x", "z", "y", 1, -1, e, i, -n, a, u, 3),
                        E("x", "y", "z", 1, -1, e, n, i, a, o, 4),
                        E("x", "y", "z", -1, -1, e, n, -i, a, o, 5),
                        this.setIndex(d),
                        this.setAttribute("position", new _t(p,3)),
                        this.setAttribute("normal", new _t(g,3)),
                        this.setAttribute("uv", new _t(v,2));
                        function E(w, A, T, R, N, D, U, z, I, V, B) {
                            const P = D / I
                              , G = U / V
                              , K = D / 2
                              , ee = U / 2
                              , te = z / 2
                              , oe = I + 1
                              , q = V + 1;
                            let F = 0
                              , X = 0;
                            const $ = new J;
                            for (let ne = 0; ne < q; ne++) {
                                const ce = ne * G - ee;
                                for (let k = 0; k < oe; k++)
                                    $[w] = (k * P - K) * R,
                                    $[A] = ce * N,
                                    $[T] = te,
                                    p.push($.x, $.y, $.z),
                                    $[w] = 0,
                                    $[A] = 0,
                                    $[T] = z > 0 ? 1 : -1,
                                    g.push($.x, $.y, $.z),
                                    v.push(k / I),
                                    v.push(1 - ne / V),
                                    F += 1
                            }
                            for (let ne = 0; ne < V; ne++)
                                for (let ce = 0; ce < I; ce++) {
                                    const k = y + ce + oe * ne
                                      , pe = y + ce + oe * (ne + 1)
                                      , Ae = y + (ce + 1) + oe * (ne + 1)
                                      , ie = y + (ce + 1) + oe * ne;
                                    d.push(k, pe, ie),
                                    d.push(pe, Ae, ie),
                                    X += 6
                                }
                            f.addGroup(S, X, B),
                            S += X,
                            y += F
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new vR(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
                    }
                }
                ;
                function kd(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const a = t[n][i];
                            a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion) ? a.isRenderTargetTexture ? (at("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                            e[n][i] = null) : e[n][i] = a.clone() : Array.isArray(a) ? e[n][i] = a.slice() : e[n][i] = a
                        }
                    }
                    return e
                }
                function ga(t) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const i = kd(t[n]);
                        for (const a in i)
                            e[a] = i[a]
                    }
                    return e
                }
                function bO(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++)
                        e.push(t[n].clone());
                    return e
                }
                function fA(t) {
                    const e = t.getRenderTarget();
                    return e === null ? t.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : xn.workingColorSpace
                }
                const dA = {
                    clone: kd,
                    merge: ga
                };
                var TO = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
                  , AO = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
                  , Br = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isShaderMaterial = !0,
                        this.type = "ShaderMaterial",
                        this.defines = {},
                        this.uniforms = {},
                        this.uniformsGroups = [],
                        this.vertexShader = TO,
                        this.fragmentShader = AO,
                        this.linewidth = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.fog = !1,
                        this.lights = !1,
                        this.clipping = !1,
                        this.forceSinglePass = !0,
                        this.extensions = {
                            clipCullDistance: !1,
                            multiDraw: !1
                        },
                        this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv1: [0, 0]
                        },
                        this.index0AttributeName = void 0,
                        this.uniformsNeedUpdate = !1,
                        this.glslVersion = null,
                        t !== void 0 && this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.fragmentShader = t.fragmentShader,
                        this.vertexShader = t.vertexShader,
                        this.uniforms = kd(t.uniforms),
                        this.uniformsGroups = bO(t.uniformsGroups),
                        this.defines = Object.assign({}, t.defines),
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.fog = t.fog,
                        this.lights = t.lights,
                        this.clipping = t.clipping,
                        this.extensions = Object.assign({}, t.extensions),
                        this.glslVersion = t.glslVersion,
                        this.defaultAttributeValues = Object.assign({}, t.defaultAttributeValues),
                        this.index0AttributeName = t.index0AttributeName,
                        this.uniformsNeedUpdate = t.uniformsNeedUpdate,
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion,
                        e.uniforms = {};
                        for (const i in this.uniforms) {
                            const a = this.uniforms[i].value;
                            a && a.isTexture ? e.uniforms[i] = {
                                type: "t",
                                value: a.toJSON(t).uuid
                            } : a && a.isColor ? e.uniforms[i] = {
                                type: "c",
                                value: a.getHex()
                            } : a && a.isVector2 ? e.uniforms[i] = {
                                type: "v2",
                                value: a.toArray()
                            } : a && a.isVector3 ? e.uniforms[i] = {
                                type: "v3",
                                value: a.toArray()
                            } : a && a.isVector4 ? e.uniforms[i] = {
                                type: "v4",
                                value: a.toArray()
                            } : a && a.isMatrix3 ? e.uniforms[i] = {
                                type: "m3",
                                value: a.toArray()
                            } : a && a.isMatrix4 ? e.uniforms[i] = {
                                type: "m4",
                                value: a.toArray()
                            } : e.uniforms[i] = {
                                value: a
                            }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                        e.vertexShader = this.vertexShader,
                        e.fragmentShader = this.fragmentShader,
                        e.lights = this.lights,
                        e.clipping = this.clipping;
                        const n = {};
                        for (const i in this.extensions)
                            this.extensions[i] === !0 && (n[i] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n),
                        e
                    }
                }
                  , ty = class extends zn {
                    constructor() {
                        super(),
                        this.isCamera = !0,
                        this.type = "Camera",
                        this.matrixWorldInverse = new jt,
                        this.projectionMatrix = new jt,
                        this.projectionMatrixInverse = new jt,
                        this.coordinateSystem = nr,
                        this._reversedDepth = !1
                    }
                    get reversedDepth() {
                        return this._reversedDepth
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.matrixWorldInverse.copy(t.matrixWorldInverse),
                        this.projectionMatrix.copy(t.projectionMatrix),
                        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        this.coordinateSystem = t.coordinateSystem,
                        this
                    }
                    getWorldDirection(t) {
                        return super.getWorldDirection(t).negate()
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(t, e) {
                        super.updateWorldMatrix(t, e),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const hu = new J
                  , pA = new Ge
                  , mA = new Ge;
                var _s = class extends ty {
                    constructor(t=50, e=1, n=.1, i=2e3) {
                        super(),
                        this.isPerspectiveCamera = !0,
                        this.type = "PerspectiveCamera",
                        this.fov = t,
                        this.zoom = 1,
                        this.near = n,
                        this.far = i,
                        this.focus = 10,
                        this.aspect = e,
                        this.view = null,
                        this.filmGauge = 35,
                        this.filmOffset = 0,
                        this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.fov = t.fov,
                        this.zoom = t.zoom,
                        this.near = t.near,
                        this.far = t.far,
                        this.focus = t.focus,
                        this.aspect = t.aspect,
                        this.view = t.view === null ? null : Object.assign({}, t.view),
                        this.filmGauge = t.filmGauge,
                        this.filmOffset = t.filmOffset,
                        this
                    }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = Rd * 2 * Math.atan(e),
                        this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const t = Math.tan(Ah * .5 * this.fov);
                        return .5 * this.getFilmHeight() / t
                    }
                    getEffectiveFOV() {
                        return Rd * 2 * Math.atan(Math.tan(Ah * .5 * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    getViewBounds(t, e, n) {
                        hu.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                        e.set(hu.x, hu.y).multiplyScalar(-t / hu.z),
                        hu.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                        n.set(hu.x, hu.y).multiplyScalar(-t / hu.z)
                    }
                    getViewSize(t, e) {
                        return this.getViewBounds(t, pA, mA),
                        e.subVectors(mA, pA)
                    }
                    setViewOffset(t, e, n, i, a, o) {
                        this.aspect = t / e,
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = t,
                        this.view.fullHeight = e,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = a,
                        this.view.height = o,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(Ah * .5 * this.fov) / this.zoom
                          , n = 2 * e
                          , i = this.aspect * n
                          , a = -.5 * i;
                        const o = this.view;
                        if (this.view !== null && this.view.enabled) {
                            const f = o.fullWidth
                              , d = o.fullHeight;
                            a += o.offsetX * i / f,
                            e -= o.offsetY * n / d,
                            i *= o.width / f,
                            n *= o.height / d
                        }
                        const u = this.filmOffset;
                        u !== 0 && (a += t * u / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(a, a + i, e, e - n, t, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.fov = this.fov,
                        e.object.zoom = this.zoom,
                        e.object.near = this.near,
                        e.object.far = this.far,
                        e.object.focus = this.focus,
                        e.object.aspect = this.aspect,
                        this.view !== null && (e.object.view = Object.assign({}, this.view)),
                        e.object.filmGauge = this.filmGauge,
                        e.object.filmOffset = this.filmOffset,
                        e
                    }
                }
                ;
                const qd = -90
                  , Xd = 1;
                var gA = class extends zn {
                    constructor(t, e, n) {
                        super(),
                        this.type = "CubeCamera",
                        this.renderTarget = n,
                        this.coordinateSystem = null,
                        this.activeMipmapLevel = 0;
                        const i = new _s(qd,Xd,t,e);
                        i.layers = this.layers,
                        this.add(i);
                        const a = new _s(qd,Xd,t,e);
                        a.layers = this.layers,
                        this.add(a);
                        const o = new _s(qd,Xd,t,e);
                        o.layers = this.layers,
                        this.add(o);
                        const u = new _s(qd,Xd,t,e);
                        u.layers = this.layers,
                        this.add(u);
                        const f = new _s(qd,Xd,t,e);
                        f.layers = this.layers,
                        this.add(f);
                        const d = new _s(qd,Xd,t,e);
                        d.layers = this.layers,
                        this.add(d)
                    }
                    updateCoordinateSystem() {
                        const t = this.coordinateSystem
                          , e = this.children.concat()
                          , [n,i,a,o,u,f] = e;
                        for (const d of e)
                            this.remove(d);
                        if (t === nr)
                            n.up.set(0, 1, 0),
                            n.lookAt(1, 0, 0),
                            i.up.set(0, 1, 0),
                            i.lookAt(-1, 0, 0),
                            a.up.set(0, 0, -1),
                            a.lookAt(0, 1, 0),
                            o.up.set(0, 0, 1),
                            o.lookAt(0, -1, 0),
                            u.up.set(0, 1, 0),
                            u.lookAt(0, 0, 1),
                            f.up.set(0, 1, 0),
                            f.lookAt(0, 0, -1);
                        else if (t === Ed)
                            n.up.set(0, -1, 0),
                            n.lookAt(-1, 0, 0),
                            i.up.set(0, -1, 0),
                            i.lookAt(1, 0, 0),
                            a.up.set(0, 0, 1),
                            a.lookAt(0, 1, 0),
                            o.up.set(0, 0, -1),
                            o.lookAt(0, -1, 0),
                            u.up.set(0, -1, 0),
                            u.lookAt(0, 0, 1),
                            f.up.set(0, -1, 0),
                            f.lookAt(0, 0, -1);
                        else
                            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                        for (const d of e)
                            this.add(d),
                            d.updateMatrixWorld()
                    }
                    update(t, e) {
                        this.parent === null && this.updateMatrixWorld();
                        const {renderTarget: n, activeMipmapLevel: i} = this;
                        this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem,
                        this.updateCoordinateSystem());
                        const [a,o,u,f,d,p] = this.children
                          , g = t.getRenderTarget()
                          , v = t.getActiveCubeFace()
                          , y = t.getActiveMipmapLevel()
                          , S = t.xr.enabled;
                        t.xr.enabled = !1;
                        const E = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1,
                        t.setRenderTarget(n, 0, i),
                        t.render(e, a),
                        t.setRenderTarget(n, 1, i),
                        t.render(e, o),
                        t.setRenderTarget(n, 2, i),
                        t.render(e, u),
                        t.setRenderTarget(n, 3, i),
                        t.render(e, f),
                        t.setRenderTarget(n, 4, i),
                        t.render(e, d),
                        n.texture.generateMipmaps = E,
                        t.setRenderTarget(n, 5, i),
                        t.render(e, p),
                        t.setRenderTarget(g, v, y),
                        t.xr.enabled = S,
                        n.texture.needsPMREMUpdate = !0
                    }
                }
                  , Cg = class extends gs {
                    constructor(t=[], e=al, n, i, a, o, u, f, d, p) {
                        super(t, e, n, i, a, o, u, f, d, p),
                        this.isCubeTexture = !0,
                        this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(t) {
                        this.image = t
                    }
                }
                  , nM = class extends sr {
                    constructor(t=1, e={}) {
                        super(t, t, e),
                        this.isWebGLCubeRenderTarget = !0;
                        const n = {
                            width: t,
                            height: t,
                            depth: 1
                        };
                        this.texture = new Cg([n, n, n, n, n, n]),
                        this._setTextureOptions(e),
                        this.texture.isRenderTargetTexture = !0
                    }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type,
                        this.texture.colorSpace = e.colorSpace,
                        this.texture.generateMipmaps = e.generateMipmaps,
                        this.texture.minFilter = e.minFilter,
                        this.texture.magFilter = e.magFilter;
                        const n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        }
                          , i = new Eg(5,5,5)
                          , a = new Br({
                            name: "CubemapFromEquirect",
                            uniforms: kd(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: fa,
                            blending: sl
                        });
                        a.uniforms.tEquirect.value = e;
                        const o = new Ji(i,a)
                          , u = e.minFilter;
                        return e.minFilter === rl && (e.minFilter = fi),
                        new gA(1,10,this).update(t, o),
                        e.minFilter = u,
                        o.geometry.dispose(),
                        o.material.dispose(),
                        this
                    }
                    clear(t, e=!0, n=!0, i=!0) {
                        const a = t.getRenderTarget();
                        for (let o = 0; o < 6; o++)
                            t.setRenderTarget(this, o),
                            t.clear(e, n, i);
                        t.setRenderTarget(a)
                    }
                }
                  , Wd = class extends zn {
                    constructor() {
                        super(),
                        this.isGroup = !0,
                        this.type = "Group"
                    }
                }
                ;
                const EO = {
                    type: "move"
                };
                var ny = class {
                    constructor() {
                        this._targetRay = null,
                        this._grip = null,
                        this._hand = null
                    }
                    getHandSpace() {
                        return this._hand === null && (this._hand = new Wd,
                        this._hand.matrixAutoUpdate = !1,
                        this._hand.visible = !1,
                        this._hand.joints = {},
                        this._hand.inputState = {
                            pinching: !1
                        }),
                        this._hand
                    }
                    getTargetRaySpace() {
                        return this._targetRay === null && (this._targetRay = new Wd,
                        this._targetRay.matrixAutoUpdate = !1,
                        this._targetRay.visible = !1,
                        this._targetRay.hasLinearVelocity = !1,
                        this._targetRay.linearVelocity = new J,
                        this._targetRay.hasAngularVelocity = !1,
                        this._targetRay.angularVelocity = new J),
                        this._targetRay
                    }
                    getGripSpace() {
                        return this._grip === null && (this._grip = new Wd,
                        this._grip.matrixAutoUpdate = !1,
                        this._grip.visible = !1,
                        this._grip.hasLinearVelocity = !1,
                        this._grip.linearVelocity = new J,
                        this._grip.hasAngularVelocity = !1,
                        this._grip.angularVelocity = new J),
                        this._grip
                    }
                    dispatchEvent(t) {
                        return this._targetRay !== null && this._targetRay.dispatchEvent(t),
                        this._grip !== null && this._grip.dispatchEvent(t),
                        this._hand !== null && this._hand.dispatchEvent(t),
                        this
                    }
                    connect(t) {
                        if (t && t.hand) {
                            const e = this._hand;
                            if (e)
                                for (const n of t.hand.values())
                                    this._getHandJoint(e, n)
                        }
                        return this.dispatchEvent({
                            type: "connected",
                            data: t
                        }),
                        this
                    }
                    disconnect(t) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: t
                        }),
                        this._targetRay !== null && (this._targetRay.visible = !1),
                        this._grip !== null && (this._grip.visible = !1),
                        this._hand !== null && (this._hand.visible = !1),
                        this
                    }
                    update(t, e, n) {
                        let i = null
                          , a = null
                          , o = null;
                        const u = this._targetRay
                          , f = this._grip
                          , d = this._hand;
                        if (t && e.session.visibilityState !== "visible-blurred") {
                            if (d && t.hand) {
                                o = !0;
                                for (const E of t.hand.values()) {
                                    const w = e.getJointPose(E, n)
                                      , A = this._getHandJoint(d, E);
                                    w !== null && (A.matrix.fromArray(w.transform.matrix),
                                    A.matrix.decompose(A.position, A.rotation, A.scale),
                                    A.matrixWorldNeedsUpdate = !0,
                                    A.jointRadius = w.radius),
                                    A.visible = w !== null
                                }
                                const p = d.joints["index-finger-tip"]
                                  , g = d.joints["thumb-tip"]
                                  , v = p.position.distanceTo(g.position)
                                  , y = .02
                                  , S = .005;
                                d.inputState.pinching && v > y + S ? (d.inputState.pinching = !1,
                                this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !d.inputState.pinching && v <= y - S && (d.inputState.pinching = !0,
                                this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                }))
                            } else
                                f !== null && t.gripSpace && (a = e.getPose(t.gripSpace, n),
                                a !== null && (f.matrix.fromArray(a.transform.matrix),
                                f.matrix.decompose(f.position, f.rotation, f.scale),
                                f.matrixWorldNeedsUpdate = !0,
                                a.linearVelocity ? (f.hasLinearVelocity = !0,
                                f.linearVelocity.copy(a.linearVelocity)) : f.hasLinearVelocity = !1,
                                a.angularVelocity ? (f.hasAngularVelocity = !0,
                                f.angularVelocity.copy(a.angularVelocity)) : f.hasAngularVelocity = !1));
                            u !== null && (i = e.getPose(t.targetRaySpace, n),
                            i === null && a !== null && (i = a),
                            i !== null && (u.matrix.fromArray(i.transform.matrix),
                            u.matrix.decompose(u.position, u.rotation, u.scale),
                            u.matrixWorldNeedsUpdate = !0,
                            i.linearVelocity ? (u.hasLinearVelocity = !0,
                            u.linearVelocity.copy(i.linearVelocity)) : u.hasLinearVelocity = !1,
                            i.angularVelocity ? (u.hasAngularVelocity = !0,
                            u.angularVelocity.copy(i.angularVelocity)) : u.hasAngularVelocity = !1,
                            this.dispatchEvent(EO)))
                        }
                        return u !== null && (u.visible = i !== null),
                        f !== null && (f.visible = a !== null),
                        d !== null && (d.visible = o !== null),
                        this
                    }
                    _getHandJoint(t, e) {
                        if (t.joints[e.jointName] === void 0) {
                            const n = new Wd;
                            n.matrixAutoUpdate = !1,
                            n.visible = !1,
                            t.joints[e.jointName] = n,
                            t.add(n)
                        }
                        return t.joints[e.jointName]
                    }
                }
                  , vA = class _R {
                    constructor(e, n=25e-5) {
                        this.isFogExp2 = !0,
                        this.name = "",
                        this.color = new ut(e),
                        this.density = n
                    }
                    clone() {
                        return new _R(this.color,this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            name: this.name,
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                  , _A = class yR {
                    constructor(e, n=1, i=1e3) {
                        this.isFog = !0,
                        this.name = "",
                        this.color = new ut(e),
                        this.near = n,
                        this.far = i
                    }
                    clone() {
                        return new yR(this.color,this.near,this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            name: this.name,
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                  , iM = class extends zn {
                    constructor() {
                        super(),
                        this.isScene = !0,
                        this.type = "Scene",
                        this.background = null,
                        this.environment = null,
                        this.fog = null,
                        this.backgroundBlurriness = 0,
                        this.backgroundIntensity = 1,
                        this.backgroundRotation = new vo,
                        this.environmentIntensity = 1,
                        this.environmentRotation = new vo,
                        this.overrideMaterial = null,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        t.background !== null && (this.background = t.background.clone()),
                        t.environment !== null && (this.environment = t.environment.clone()),
                        t.fog !== null && (this.fog = t.fog.clone()),
                        this.backgroundBlurriness = t.backgroundBlurriness,
                        this.backgroundIntensity = t.backgroundIntensity,
                        this.backgroundRotation.copy(t.backgroundRotation),
                        this.environmentIntensity = t.environmentIntensity,
                        this.environmentRotation.copy(t.environmentRotation),
                        t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()),
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return this.fog !== null && (e.object.fog = this.fog.toJSON()),
                        this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness),
                        this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity),
                        e.object.backgroundRotation = this.backgroundRotation.toArray(),
                        this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity),
                        e.object.environmentRotation = this.environmentRotation.toArray(),
                        e
                    }
                }
                  , iy = class {
                    constructor(t, e) {
                        this.isInterleavedBuffer = !0,
                        this.array = t,
                        this.stride = e,
                        this.count = t !== void 0 ? t.length / e : 0,
                        this.usage = vg,
                        this.updateRanges = [],
                        this.version = 0,
                        this.uuid = ir()
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    }
                    setUsage(t) {
                        return this.usage = t,
                        this
                    }
                    addUpdateRange(t, e) {
                        this.updateRanges.push({
                            start: t,
                            count: e
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(t) {
                        return this.array = new t.array.constructor(t.array),
                        this.count = t.count,
                        this.stride = t.stride,
                        this.usage = t.usage,
                        this
                    }
                    copyAt(t, e, n) {
                        t *= this.stride,
                        n *= e.stride;
                        for (let i = 0, a = this.stride; i < a; i++)
                            this.array[t + i] = e.array[n + i];
                        return this
                    }
                    set(t, e=0) {
                        return this.array.set(t, e),
                        this
                    }
                    clone(t) {
                        t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ir()),
                        t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
                          , n = new this.constructor(e,this.stride);
                        return n.setUsage(this.usage),
                        n
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t,
                        this
                    }
                    toJSON(t) {
                        return t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ir()),
                        t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                ;
                const va = new J;
                var wg = class SR {
                    constructor(e, n, i, a=!1) {
                        this.isInterleavedBufferAttribute = !0,
                        this.name = "",
                        this.data = e,
                        this.itemSize = n,
                        this.offset = i,
                        this.normalized = a
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(e) {
                        this.data.needsUpdate = e
                    }
                    applyMatrix4(e) {
                        for (let n = 0, i = this.data.count; n < i; n++)
                            va.fromBufferAttribute(this, n),
                            va.applyMatrix4(e),
                            this.setXYZ(n, va.x, va.y, va.z);
                        return this
                    }
                    applyNormalMatrix(e) {
                        for (let n = 0, i = this.count; n < i; n++)
                            va.fromBufferAttribute(this, n),
                            va.applyNormalMatrix(e),
                            this.setXYZ(n, va.x, va.y, va.z);
                        return this
                    }
                    transformDirection(e) {
                        for (let n = 0, i = this.count; n < i; n++)
                            va.fromBufferAttribute(this, n),
                            va.transformDirection(e),
                            this.setXYZ(n, va.x, va.y, va.z);
                        return this
                    }
                    getComponent(e, n) {
                        let i = this.array[e * this.data.stride + this.offset + n];
                        return this.normalized && (i = ma(i, this.array)),
                        i
                    }
                    setComponent(e, n, i) {
                        return this.normalized && (i = $t(i, this.array)),
                        this.data.array[e * this.data.stride + this.offset + n] = i,
                        this
                    }
                    setX(e, n) {
                        return this.normalized && (n = $t(n, this.array)),
                        this.data.array[e * this.data.stride + this.offset] = n,
                        this
                    }
                    setY(e, n) {
                        return this.normalized && (n = $t(n, this.array)),
                        this.data.array[e * this.data.stride + this.offset + 1] = n,
                        this
                    }
                    setZ(e, n) {
                        return this.normalized && (n = $t(n, this.array)),
                        this.data.array[e * this.data.stride + this.offset + 2] = n,
                        this
                    }
                    setW(e, n) {
                        return this.normalized && (n = $t(n, this.array)),
                        this.data.array[e * this.data.stride + this.offset + 3] = n,
                        this
                    }
                    getX(e) {
                        let n = this.data.array[e * this.data.stride + this.offset];
                        return this.normalized && (n = ma(n, this.array)),
                        n
                    }
                    getY(e) {
                        let n = this.data.array[e * this.data.stride + this.offset + 1];
                        return this.normalized && (n = ma(n, this.array)),
                        n
                    }
                    getZ(e) {
                        let n = this.data.array[e * this.data.stride + this.offset + 2];
                        return this.normalized && (n = ma(n, this.array)),
                        n
                    }
                    getW(e) {
                        let n = this.data.array[e * this.data.stride + this.offset + 3];
                        return this.normalized && (n = ma(n, this.array)),
                        n
                    }
                    setXY(e, n, i) {
                        return e = e * this.data.stride + this.offset,
                        this.normalized && (n = $t(n, this.array),
                        i = $t(i, this.array)),
                        this.data.array[e + 0] = n,
                        this.data.array[e + 1] = i,
                        this
                    }
                    setXYZ(e, n, i, a) {
                        return e = e * this.data.stride + this.offset,
                        this.normalized && (n = $t(n, this.array),
                        i = $t(i, this.array),
                        a = $t(a, this.array)),
                        this.data.array[e + 0] = n,
                        this.data.array[e + 1] = i,
                        this.data.array[e + 2] = a,
                        this
                    }
                    setXYZW(e, n, i, a, o) {
                        return e = e * this.data.stride + this.offset,
                        this.normalized && (n = $t(n, this.array),
                        i = $t(i, this.array),
                        a = $t(a, this.array),
                        o = $t(o, this.array)),
                        this.data.array[e + 0] = n,
                        this.data.array[e + 1] = i,
                        this.data.array[e + 2] = a,
                        this.data.array[e + 3] = o,
                        this
                    }
                    clone(e) {
                        if (e === void 0) {
                            yg("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let i = 0; i < this.count; i++) {
                                const a = i * this.data.stride + this.offset;
                                for (let o = 0; o < this.itemSize; o++)
                                    n.push(this.data.array[a + o])
                            }
                            return new Kn(new this.array.constructor(n),this.itemSize,this.normalized)
                        } else
                            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                            new SR(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                    }
                    toJSON(e) {
                        if (e === void 0) {
                            yg("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let i = 0; i < this.count; i++) {
                                const a = i * this.data.stride + this.offset;
                                for (let o = 0; o < this.itemSize; o++)
                                    n.push(this.data.array[a + o])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: n,
                                normalized: this.normalized
                            }
                        } else
                            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                            {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                    }
                }
                  , sM = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isSpriteMaterial = !0,
                        this.type = "SpriteMaterial",
                        this.color = new ut(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.rotation = 0,
                        this.sizeAttenuation = !0,
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.map = t.map,
                        this.alphaMap = t.alphaMap,
                        this.rotation = t.rotation,
                        this.sizeAttenuation = t.sizeAttenuation,
                        this.fog = t.fog,
                        this
                    }
                }
                ;
                let Yd;
                const Rg = new J
                  , jd = new J
                  , Zd = new J
                  , Qd = new Ge
                  , Ng = new Ge
                  , yA = new jt
                  , sy = new J
                  , Dg = new J
                  , ay = new J
                  , SA = new Ge
                  , aM = new Ge
                  , xA = new Ge;
                var MA = class extends zn {
                    constructor(t=new sM) {
                        if (super(),
                        this.isSprite = !0,
                        this.type = "Sprite",
                        Yd === void 0) {
                            Yd = new en;
                            const e = new iy(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
                            Yd.setIndex([0, 1, 2, 0, 2, 3]),
                            Yd.setAttribute("position", new wg(e,3,0,!1)),
                            Yd.setAttribute("uv", new wg(e,2,3,!1))
                        }
                        this.geometry = Yd,
                        this.material = t,
                        this.center = new Ge(.5,.5),
                        this.count = 1
                    }
                    raycast(t, e) {
                        t.camera === null && Rt('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                        jd.setFromMatrixScale(this.matrixWorld),
                        yA.copy(t.camera.matrixWorld),
                        this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
                        Zd.setFromMatrixPosition(this.modelViewMatrix),
                        t.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && jd.multiplyScalar(-Zd.z);
                        const n = this.material.rotation;
                        let i, a;
                        n !== 0 && (a = Math.cos(n),
                        i = Math.sin(n));
                        const o = this.center;
                        ry(sy.set(-.5, -.5, 0), Zd, o, jd, i, a),
                        ry(Dg.set(.5, -.5, 0), Zd, o, jd, i, a),
                        ry(ay.set(.5, .5, 0), Zd, o, jd, i, a),
                        SA.set(0, 0),
                        aM.set(1, 0),
                        xA.set(1, 1);
                        let u = t.ray.intersectTriangle(sy, Dg, ay, !1, Rg);
                        if (u === null && (ry(Dg.set(-.5, .5, 0), Zd, o, jd, i, a),
                        aM.set(0, 1),
                        u = t.ray.intersectTriangle(sy, ay, Dg, !1, Rg),
                        u === null))
                            return;
                        const f = t.ray.origin.distanceTo(Rg);
                        f < t.near || f > t.far || e.push({
                            distance: f,
                            point: Rg.clone(),
                            uv: lu.getInterpolation(Rg, sy, Dg, ay, SA, aM, xA, new Ge),
                            face: null,
                            object: this
                        })
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        t.center !== void 0 && this.center.copy(t.center),
                        this.material = t.material,
                        this
                    }
                }
                ;
                function ry(t, e, n, i, a, o) {
                    Qd.subVectors(t, n).addScalar(.5).multiply(i),
                    a !== void 0 ? (Ng.x = o * Qd.x - a * Qd.y,
                    Ng.y = a * Qd.x + o * Qd.y) : Ng.copy(Qd),
                    t.copy(e),
                    t.x += Ng.x,
                    t.y += Ng.y,
                    t.applyMatrix4(yA)
                }
                const oy = new J
                  , bA = new J;
                var TA = class extends zn {
                    constructor() {
                        super(),
                        this.isLOD = !0,
                        this._currentLevel = 0,
                        this.type = "LOD",
                        Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            }
                        }),
                        this.autoUpdate = !0
                    }
                    copy(t) {
                        super.copy(t, !1);
                        const e = t.levels;
                        for (let n = 0, i = e.length; n < i; n++) {
                            const a = e[n];
                            this.addLevel(a.object.clone(), a.distance, a.hysteresis)
                        }
                        return this.autoUpdate = t.autoUpdate,
                        this
                    }
                    addLevel(t, e=0, n=0) {
                        e = Math.abs(e);
                        const i = this.levels;
                        let a;
                        for (a = 0; a < i.length && !(e < i[a].distance); a++)
                            ;
                        return i.splice(a, 0, {
                            distance: e,
                            hysteresis: n,
                            object: t
                        }),
                        this.add(t),
                        this
                    }
                    removeLevel(t) {
                        const e = this.levels;
                        for (let n = 0; n < e.length; n++)
                            if (e[n].distance === t) {
                                const i = e.splice(n, 1);
                                return this.remove(i[0].object),
                                !0
                            }
                        return !1
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(t) {
                        const e = this.levels;
                        if (e.length > 0) {
                            let n, i;
                            for (n = 1,
                            i = e.length; n < i; n++) {
                                let a = e[n].distance;
                                if (e[n].object.visible && (a -= a * e[n].hysteresis),
                                t < a)
                                    break
                            }
                            return e[n - 1].object
                        }
                        return null
                    }
                    raycast(t, e) {
                        if (this.levels.length > 0) {
                            oy.setFromMatrixPosition(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(oy);
                            this.getObjectForDistance(n).raycast(t, e)
                        }
                    }
                    update(t) {
                        const e = this.levels;
                        if (e.length > 1) {
                            oy.setFromMatrixPosition(t.matrixWorld),
                            bA.setFromMatrixPosition(this.matrixWorld);
                            const n = oy.distanceTo(bA) / t.zoom;
                            e[0].object.visible = !0;
                            let i, a;
                            for (i = 1,
                            a = e.length; i < a; i++) {
                                let o = e[i].distance;
                                if (e[i].object.visible && (o -= o * e[i].hysteresis),
                                n >= o)
                                    e[i - 1].object.visible = !1,
                                    e[i].object.visible = !0;
                                else
                                    break
                            }
                            for (this._currentLevel = i - 1; i < a; i++)
                                e[i].object.visible = !1
                        }
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        this.autoUpdate === !1 && (e.object.autoUpdate = !1),
                        e.object.levels = [];
                        const n = this.levels;
                        for (let i = 0, a = n.length; i < a; i++) {
                            const o = n[i];
                            e.object.levels.push({
                                object: o.object.uuid,
                                distance: o.distance,
                                hysteresis: o.hysteresis
                            })
                        }
                        return e
                    }
                }
                ;
                const AA = new J
                  , EA = new di
                  , CA = new di
                  , CO = new J
                  , wA = new jt
                  , ly = new J
                  , rM = new As
                  , RA = new jt
                  , oM = new Id;
                var NA = class extends Ji {
                    constructor(t, e) {
                        super(t, e),
                        this.isSkinnedMesh = !0,
                        this.type = "SkinnedMesh",
                        this.bindMode = xx,
                        this.bindMatrix = new jt,
                        this.bindMatrixInverse = new jt,
                        this.boundingBox = null,
                        this.boundingSphere = null
                    }
                    computeBoundingBox() {
                        const t = this.geometry;
                        this.boundingBox === null && (this.boundingBox = new qs),
                        this.boundingBox.makeEmpty();
                        const e = t.getAttribute("position");
                        for (let n = 0; n < e.count; n++)
                            this.getVertexPosition(n, ly),
                            this.boundingBox.expandByPoint(ly)
                    }
                    computeBoundingSphere() {
                        const t = this.geometry;
                        this.boundingSphere === null && (this.boundingSphere = new As),
                        this.boundingSphere.makeEmpty();
                        const e = t.getAttribute("position");
                        for (let n = 0; n < e.count; n++)
                            this.getVertexPosition(n, ly),
                            this.boundingSphere.expandByPoint(ly)
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.bindMode = t.bindMode,
                        this.bindMatrix.copy(t.bindMatrix),
                        this.bindMatrixInverse.copy(t.bindMatrixInverse),
                        this.skeleton = t.skeleton,
                        t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
                        t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()),
                        this
                    }
                    raycast(t, e) {
                        const n = this.material
                          , i = this.matrixWorld;
                        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        rM.copy(this.boundingSphere),
                        rM.applyMatrix4(i),
                        t.ray.intersectsSphere(rM) !== !1 && (RA.copy(i).invert(),
                        oM.copy(t.ray).applyMatrix4(RA),
                        !(this.boundingBox !== null && oM.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(t, e, oM)))
                    }
                    getVertexPosition(t, e) {
                        return super.getVertexPosition(t, e),
                        this.applyBoneTransform(t, e),
                        e
                    }
                    bind(t, e) {
                        this.skeleton = t,
                        e === void 0 && (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        e = this.matrixWorld),
                        this.bindMatrix.copy(e),
                        this.bindMatrixInverse.copy(e).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const t = new di
                          , e = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = e.count; n < i; n++) {
                            t.fromBufferAttribute(e, n);
                            const a = 1 / t.manhattanLength();
                            a !== 1 / 0 ? t.multiplyScalar(a) : t.set(1, 0, 0, 0),
                            e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t),
                        this.bindMode === xx ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === U1 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : at("SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    applyBoneTransform(t, e) {
                        const n = this.skeleton
                          , i = this.geometry;
                        EA.fromBufferAttribute(i.attributes.skinIndex, t),
                        CA.fromBufferAttribute(i.attributes.skinWeight, t),
                        AA.copy(e).applyMatrix4(this.bindMatrix),
                        e.set(0, 0, 0);
                        for (let a = 0; a < 4; a++) {
                            const o = CA.getComponent(a);
                            if (o !== 0) {
                                const u = EA.getComponent(a);
                                wA.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]),
                                e.addScaledVector(CO.copy(AA).applyMatrix4(wA), o)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                  , lM = class extends zn {
                    constructor() {
                        super(),
                        this.isBone = !0,
                        this.type = "Bone"
                    }
                }
                  , yo = class extends gs {
                    constructor(t=null, e=1, n=1, i, a, o, u, f, d=Vi, p=Vi, g, v) {
                        super(null, o, u, f, d, p, i, a, g, v),
                        this.isDataTexture = !0,
                        this.image = {
                            data: t,
                            width: e,
                            height: n
                        },
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                ;
                const DA = new jt
                  , wO = new jt;
                var OA = class xR {
                    constructor(e=[], n=[]) {
                        this.uuid = ir(),
                        this.bones = e.slice(0),
                        this.boneInverses = n,
                        this.boneMatrices = null,
                        this.previousBoneMatrices = null,
                        this.boneTexture = null,
                        this.init()
                    }
                    init() {
                        const e = this.bones
                          , n = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(e.length * 16),
                        n.length === 0)
                            this.calculateInverses();
                        else if (e.length !== n.length) {
                            at("Skeleton: Number of inverse bone matrices does not match amount of bones."),
                            this.boneInverses = [];
                            for (let i = 0, a = this.bones.length; i < a; i++)
                                this.boneInverses.push(new jt)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let e = 0, n = this.bones.length; e < n; e++) {
                            const i = new jt;
                            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
                            this.boneInverses.push(i)
                        }
                    }
                    pose() {
                        for (let e = 0, n = this.bones.length; e < n; e++) {
                            const i = this.bones[e];
                            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
                        }
                        for (let e = 0, n = this.bones.length; e < n; e++) {
                            const i = this.bones[e];
                            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
                            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
                            i.matrix.decompose(i.position, i.quaternion, i.scale))
                        }
                    }
                    update() {
                        const e = this.bones
                          , n = this.boneInverses
                          , i = this.boneMatrices
                          , a = this.boneTexture;
                        for (let o = 0, u = e.length; o < u; o++) {
                            const f = e[o] ? e[o].matrixWorld : wO;
                            DA.multiplyMatrices(f, n[o]),
                            DA.toArray(i, o * 16)
                        }
                        a !== null && (a.needsUpdate = !0)
                    }
                    clone() {
                        return new xR(this.bones,this.boneInverses)
                    }
                    computeBoneTexture() {
                        let e = Math.sqrt(this.bones.length * 4);
                        e = Math.ceil(e / 4) * 4,
                        e = Math.max(e, 4);
                        const n = new Float32Array(e * e * 4);
                        n.set(this.boneMatrices);
                        const i = new yo(n,e,e,Hs,pa);
                        return i.needsUpdate = !0,
                        this.boneMatrices = n,
                        this.boneTexture = i,
                        this
                    }
                    getBoneByName(e) {
                        for (let n = 0, i = this.bones.length; n < i; n++) {
                            const a = this.bones[n];
                            if (a.name === e)
                                return a
                        }
                    }
                    dispose() {
                        this.boneTexture !== null && (this.boneTexture.dispose(),
                        this.boneTexture = null)
                    }
                    fromJSON(e, n) {
                        this.uuid = e.uuid;
                        for (let i = 0, a = e.bones.length; i < a; i++) {
                            const o = e.bones[i];
                            let u = n[o];
                            u === void 0 && (at("Skeleton: No bone found with UUID:", o),
                            u = new lM),
                            this.bones.push(u),
                            this.boneInverses.push(new jt().fromArray(e.boneInverses[i]))
                        }
                        return this.init(),
                        this
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.7,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        e.uuid = this.uuid;
                        const n = this.bones
                          , i = this.boneInverses;
                        for (let a = 0, o = n.length; a < o; a++) {
                            const u = n[a];
                            e.bones.push(u.uuid);
                            const f = i[a];
                            e.boneInverses.push(f.toArray())
                        }
                        return e
                    }
                }
                  , Kd = class extends Kn {
                    constructor(t, e, n, i=1) {
                        super(t, e, n),
                        this.isInstancedBufferAttribute = !0,
                        this.meshPerAttribute = i
                    }
                    copy(t) {
                        return super.copy(t),
                        this.meshPerAttribute = t.meshPerAttribute,
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.meshPerAttribute = this.meshPerAttribute,
                        t.isInstancedBufferAttribute = !0,
                        t
                    }
                }
                ;
                const Jd = new jt
                  , UA = new jt
                  , cy = []
                  , LA = new qs
                  , RO = new jt
                  , Og = new Ji
                  , Ug = new As;
                var IA = class extends Ji {
                    constructor(t, e, n) {
                        super(t, e),
                        this.isInstancedMesh = !0,
                        this.instanceMatrix = new Kd(new Float32Array(n * 16),16),
                        this.instanceColor = null,
                        this.morphTexture = null,
                        this.count = n,
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        for (let i = 0; i < n; i++)
                            this.setMatrixAt(i, RO)
                    }
                    computeBoundingBox() {
                        const t = this.geometry
                          , e = this.count;
                        this.boundingBox === null && (this.boundingBox = new qs),
                        t.boundingBox === null && t.computeBoundingBox(),
                        this.boundingBox.makeEmpty();
                        for (let n = 0; n < e; n++)
                            this.getMatrixAt(n, Jd),
                            LA.copy(t.boundingBox).applyMatrix4(Jd),
                            this.boundingBox.union(LA)
                    }
                    computeBoundingSphere() {
                        const t = this.geometry
                          , e = this.count;
                        this.boundingSphere === null && (this.boundingSphere = new As),
                        t.boundingSphere === null && t.computeBoundingSphere(),
                        this.boundingSphere.makeEmpty();
                        for (let n = 0; n < e; n++)
                            this.getMatrixAt(n, Jd),
                            Ug.copy(t.boundingSphere).applyMatrix4(Jd),
                            this.boundingSphere.union(Ug)
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.instanceMatrix.copy(t.instanceMatrix),
                        t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()),
                        t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()),
                        this.count = t.count,
                        t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
                        t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()),
                        this
                    }
                    getColorAt(t, e) {
                        e.fromArray(this.instanceColor.array, t * 3)
                    }
                    getMatrixAt(t, e) {
                        e.fromArray(this.instanceMatrix.array, t * 16)
                    }
                    getMorphAt(t, e) {
                        const n = e.morphTargetInfluences
                          , i = this.morphTexture.source.data.data
                          , a = t * (n.length + 1) + 1;
                        for (let o = 0; o < n.length; o++)
                            n[o] = i[a + o]
                    }
                    raycast(t, e) {
                        const n = this.matrixWorld
                          , i = this.count;
                        if (Og.geometry = this.geometry,
                        Og.material = this.material,
                        Og.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        Ug.copy(this.boundingSphere),
                        Ug.applyMatrix4(n),
                        t.ray.intersectsSphere(Ug) !== !1))
                            for (let a = 0; a < i; a++) {
                                this.getMatrixAt(a, Jd),
                                UA.multiplyMatrices(n, Jd),
                                Og.matrixWorld = UA,
                                Og.raycast(t, cy);
                                for (let o = 0, u = cy.length; o < u; o++) {
                                    const f = cy[o];
                                    f.instanceId = a,
                                    f.object = this,
                                    e.push(f)
                                }
                                cy.length = 0
                            }
                    }
                    setColorAt(t, e) {
                        this.instanceColor === null && (this.instanceColor = new Kd(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
                        e.toArray(this.instanceColor.array, t * 3)
                    }
                    setMatrixAt(t, e) {
                        e.toArray(this.instanceMatrix.array, t * 16)
                    }
                    setMorphAt(t, e) {
                        const n = e.morphTargetInfluences
                          , i = n.length + 1;
                        this.morphTexture === null && (this.morphTexture = new yo(new Float32Array(i * this.count),i,this.count,K_,pa));
                        const a = this.morphTexture.source.data.data;
                        let o = 0;
                        for (let d = 0; d < n.length; d++)
                            o += n[d];
                        const u = this.geometry.morphTargetsRelative ? 1 : 1 - o
                          , f = i * t;
                        a[f] = u,
                        a.set(n, f + 1)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        }),
                        this.morphTexture !== null && (this.morphTexture.dispose(),
                        this.morphTexture = null)
                    }
                }
                ;
                const cM = new J
                  , NO = new J
                  , DO = new sn;
                var fu = class {
                    constructor(t=new J(1,0,0), e=0) {
                        this.isPlane = !0,
                        this.normal = t,
                        this.constant = e
                    }
                    set(t, e) {
                        return this.normal.copy(t),
                        this.constant = e,
                        this
                    }
                    setComponents(t, e, n, i) {
                        return this.normal.set(t, e, n),
                        this.constant = i,
                        this
                    }
                    setFromNormalAndCoplanarPoint(t, e) {
                        return this.normal.copy(t),
                        this.constant = -e.dot(this.normal),
                        this
                    }
                    setFromCoplanarPoints(t, e, n) {
                        const i = cM.subVectors(n, e).cross(NO.subVectors(t, e)).normalize();
                        return this.setFromNormalAndCoplanarPoint(i, t),
                        this
                    }
                    copy(t) {
                        return this.normal.copy(t.normal),
                        this.constant = t.constant,
                        this
                    }
                    normalize() {
                        const t = 1 / this.normal.length();
                        return this.normal.multiplyScalar(t),
                        this.constant *= t,
                        this
                    }
                    negate() {
                        return this.constant *= -1,
                        this.normal.negate(),
                        this
                    }
                    distanceToPoint(t) {
                        return this.normal.dot(t) + this.constant
                    }
                    distanceToSphere(t) {
                        return this.distanceToPoint(t.center) - t.radius
                    }
                    projectPoint(t, e) {
                        return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
                    }
                    intersectLine(t, e) {
                        const n = t.delta(cM)
                          , i = this.normal.dot(n);
                        if (i === 0)
                            return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
                        const a = -(t.start.dot(this.normal) + this.constant) / i;
                        return a < 0 || a > 1 ? null : e.copy(t.start).addScaledVector(n, a)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start)
                          , n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) {
                        return t.intersectsPlane(this)
                    }
                    intersectsSphere(t) {
                        return t.intersectsPlane(this)
                    }
                    coplanarPoint(t) {
                        return t.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(t, e) {
                        const n = e || DO.getNormalMatrix(t)
                          , i = this.coplanarPoint(cM).applyMatrix4(t)
                          , a = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(a),
                        this
                    }
                    translate(t) {
                        return this.constant -= t.dot(this.normal),
                        this
                    }
                    equals(t) {
                        return t.normal.equals(this.normal) && t.constant === this.constant
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const Rh = new As
                  , OO = new Ge(.5,.5)
                  , uy = new J;
                var $d = class {
                    constructor(t=new fu, e=new fu, n=new fu, i=new fu, a=new fu, o=new fu) {
                        this.planes = [t, e, n, i, a, o]
                    }
                    set(t, e, n, i, a, o) {
                        const u = this.planes;
                        return u[0].copy(t),
                        u[1].copy(e),
                        u[2].copy(n),
                        u[3].copy(i),
                        u[4].copy(a),
                        u[5].copy(o),
                        this
                    }
                    copy(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            e[n].copy(t.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(t, e=nr, n=!1) {
                        const i = this.planes
                          , a = t.elements
                          , o = a[0]
                          , u = a[1]
                          , f = a[2]
                          , d = a[3]
                          , p = a[4]
                          , g = a[5]
                          , v = a[6]
                          , y = a[7]
                          , S = a[8]
                          , E = a[9]
                          , w = a[10]
                          , A = a[11]
                          , T = a[12]
                          , R = a[13]
                          , N = a[14]
                          , D = a[15];
                        if (i[0].setComponents(d - o, y - p, A - S, D - T).normalize(),
                        i[1].setComponents(d + o, y + p, A + S, D + T).normalize(),
                        i[2].setComponents(d + u, y + g, A + E, D + R).normalize(),
                        i[3].setComponents(d - u, y - g, A - E, D - R).normalize(),
                        n)
                            i[4].setComponents(f, v, w, N).normalize(),
                            i[5].setComponents(d - f, y - v, A - w, D - N).normalize();
                        else if (i[4].setComponents(d - f, y - v, A - w, D - N).normalize(),
                        e === nr)
                            i[5].setComponents(d + f, y + v, A + w, D + N).normalize();
                        else if (e === Ed)
                            i[5].setComponents(f, v, w, N).normalize();
                        else
                            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                        return this
                    }
                    intersectsObject(t) {
                        if (t.boundingSphere !== void 0)
                            t.boundingSphere === null && t.computeBoundingSphere(),
                            Rh.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                        else {
                            const e = t.geometry;
                            e.boundingSphere === null && e.computeBoundingSphere(),
                            Rh.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                        }
                        return this.intersectsSphere(Rh)
                    }
                    intersectsSprite(t) {
                        return Rh.center.set(0, 0, 0),
                        Rh.radius = .7071067811865476 + OO.distanceTo(t.center),
                        Rh.applyMatrix4(t.matrixWorld),
                        this.intersectsSphere(Rh)
                    }
                    intersectsSphere(t) {
                        const e = this.planes
                          , n = t.center
                          , i = -t.radius;
                        for (let a = 0; a < 6; a++)
                            if (e[a].distanceToPoint(n) < i)
                                return !1;
                        return !0
                    }
                    intersectsBox(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const i = e[n];
                            if (uy.x = i.normal.x > 0 ? t.max.x : t.min.x,
                            uy.y = i.normal.y > 0 ? t.max.y : t.min.y,
                            uy.z = i.normal.z > 0 ? t.max.z : t.min.z,
                            i.distanceToPoint(uy) < 0)
                                return !1
                        }
                        return !0
                    }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0)
                                return !1;
                        return !0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const ul = new jt
                  , hl = new $d;
                var zA = class MR {
                    constructor() {
                        this.coordinateSystem = nr
                    }
                    intersectsObject(e, n) {
                        if (!n.isArrayCamera || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const a = n.cameras[i];
                            if (ul.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
                            hl.setFromProjectionMatrix(ul, a.coordinateSystem, a.reversedDepth),
                            hl.intersectsObject(e))
                                return !0
                        }
                        return !1
                    }
                    intersectsSprite(e, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const a = n.cameras[i];
                            if (ul.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
                            hl.setFromProjectionMatrix(ul, a.coordinateSystem, a.reversedDepth),
                            hl.intersectsSprite(e))
                                return !0
                        }
                        return !1
                    }
                    intersectsSphere(e, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const a = n.cameras[i];
                            if (ul.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
                            hl.setFromProjectionMatrix(ul, a.coordinateSystem, a.reversedDepth),
                            hl.intersectsSphere(e))
                                return !0
                        }
                        return !1
                    }
                    intersectsBox(e, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const a = n.cameras[i];
                            if (ul.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
                            hl.setFromProjectionMatrix(ul, a.coordinateSystem, a.reversedDepth),
                            hl.intersectsBox(e))
                                return !0
                        }
                        return !1
                    }
                    containsPoint(e, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const a = n.cameras[i];
                            if (ul.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
                            hl.setFromProjectionMatrix(ul, a.coordinateSystem, a.reversedDepth),
                            hl.containsPoint(e))
                                return !0
                        }
                        return !1
                    }
                    clone() {
                        return new MR
                    }
                }
                ;
                function uM(t, e) {
                    return t - e
                }
                function UO(t, e) {
                    return t.z - e.z
                }
                function LO(t, e) {
                    return e.z - t.z
                }
                var IO = class {
                    constructor() {
                        this.index = 0,
                        this.pool = [],
                        this.list = []
                    }
                    push(t, e, n, i) {
                        const a = this.pool
                          , o = this.list;
                        this.index >= a.length && a.push({
                            start: -1,
                            count: -1,
                            z: -1,
                            index: -1
                        });
                        const u = a[this.index];
                        o.push(u),
                        this.index++,
                        u.start = t,
                        u.count = e,
                        u.z = n,
                        u.index = i
                    }
                    reset() {
                        this.list.length = 0,
                        this.index = 0
                    }
                }
                ;
                const Pa = new jt
                  , zO = new ut(1,1,1)
                  , BA = new $d
                  , BO = new zA
                  , hy = new qs
                  , Nh = new As
                  , Lg = new J
                  , PA = new J
                  , PO = new J
                  , hM = new IO
                  , Ys = new Ji
                  , fy = [];
                function VO(t, e, n=0) {
                    const i = e.itemSize;
                    if (t.isInterleavedBufferAttribute || t.array.constructor !== e.array.constructor) {
                        const a = t.count;
                        for (let o = 0; o < a; o++)
                            for (let u = 0; u < i; u++)
                                e.setComponent(o + n, u, t.getComponent(o, u))
                    } else
                        e.array.set(t.array, n * i);
                    e.needsUpdate = !0
                }
                function Dh(t, e) {
                    if (t.constructor !== e.constructor) {
                        const n = Math.min(t.length, e.length);
                        for (let i = 0; i < n; i++)
                            e[i] = t[i]
                    } else {
                        const n = Math.min(t.length, e.length);
                        e.set(new t.constructor(t.buffer,0,n))
                    }
                }
                var VA = class extends Ji {
                    constructor(t, e, n=e * 2, i) {
                        super(new en, i),
                        this.isBatchedMesh = !0,
                        this.perObjectFrustumCulled = !0,
                        this.sortObjects = !0,
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.customSort = null,
                        this._instanceInfo = [],
                        this._geometryInfo = [],
                        this._availableInstanceIds = [],
                        this._availableGeometryIds = [],
                        this._nextIndexStart = 0,
                        this._nextVertexStart = 0,
                        this._geometryCount = 0,
                        this._visibilityChanged = !0,
                        this._geometryInitialized = !1,
                        this._maxInstanceCount = t,
                        this._maxVertexCount = e,
                        this._maxIndexCount = n,
                        this._multiDrawCounts = new Int32Array(t),
                        this._multiDrawStarts = new Int32Array(t),
                        this._multiDrawCount = 0,
                        this._multiDrawInstances = null,
                        this._matricesTexture = null,
                        this._indirectTexture = null,
                        this._colorsTexture = null,
                        this._initMatricesTexture(),
                        this._initIndirectTexture()
                    }
                    get maxInstanceCount() {
                        return this._maxInstanceCount
                    }
                    get instanceCount() {
                        return this._instanceInfo.length - this._availableInstanceIds.length
                    }
                    get unusedVertexCount() {
                        return this._maxVertexCount - this._nextVertexStart
                    }
                    get unusedIndexCount() {
                        return this._maxIndexCount - this._nextIndexStart
                    }
                    _initMatricesTexture() {
                        let t = Math.sqrt(this._maxInstanceCount * 4);
                        t = Math.ceil(t / 4) * 4,
                        t = Math.max(t, 4),
                        this._matricesTexture = new yo(new Float32Array(t * t * 4),t,t,Hs,pa)
                    }
                    _initIndirectTexture() {
                        let t = Math.sqrt(this._maxInstanceCount);
                        t = Math.ceil(t),
                        this._indirectTexture = new yo(new Uint32Array(t * t),t,t,cg,Ir)
                    }
                    _initColorsTexture() {
                        let t = Math.sqrt(this._maxInstanceCount);
                        t = Math.ceil(t);
                        const e = new yo(new Float32Array(t * t * 4).fill(1),t,t,Hs,pa);
                        e.colorSpace = xn.workingColorSpace,
                        this._colorsTexture = e
                    }
                    _initializeGeometry(t) {
                        const e = this.geometry
                          , n = this._maxVertexCount
                          , i = this._maxIndexCount;
                        if (this._geometryInitialized === !1) {
                            for (const a in t.attributes) {
                                const {array: o, itemSize: u, normalized: f} = t.getAttribute(a)
                                  , d = new Kn(new o.constructor(n * u),u,f);
                                e.setAttribute(a, d)
                            }
                            if (t.getIndex() !== null) {
                                const a = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                                e.setIndex(new Kn(a,1))
                            }
                            this._geometryInitialized = !0
                        }
                    }
                    _validateGeometry(t) {
                        const e = this.geometry;
                        if (!!t.getIndex() != !!e.getIndex())
                            throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
                        for (const n in e.attributes) {
                            if (!t.hasAttribute(n))
                                throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                            const i = t.getAttribute(n)
                              , a = e.getAttribute(n);
                            if (i.itemSize !== a.itemSize || i.normalized !== a.normalized)
                                throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                        }
                    }
                    validateInstanceId(t) {
                        const e = this._instanceInfo;
                        if (t < 0 || t >= e.length || e[t].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)
                    }
                    validateGeometryId(t) {
                        const e = this._geometryInfo;
                        if (t < 0 || t >= e.length || e[t].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)
                    }
                    setCustomSort(t) {
                        return this.customSort = t,
                        this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new qs);
                        const t = this.boundingBox
                          , e = this._instanceInfo;
                        t.makeEmpty();
                        for (let n = 0, i = e.length; n < i; n++) {
                            if (e[n].active === !1)
                                continue;
                            const a = e[n].geometryIndex;
                            this.getMatrixAt(n, Pa),
                            this.getBoundingBoxAt(a, hy).applyMatrix4(Pa),
                            t.union(hy)
                        }
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new As);
                        const t = this.boundingSphere
                          , e = this._instanceInfo;
                        t.makeEmpty();
                        for (let n = 0, i = e.length; n < i; n++) {
                            if (e[n].active === !1)
                                continue;
                            const a = e[n].geometryIndex;
                            this.getMatrixAt(n, Pa),
                            this.getBoundingSphereAt(a, Nh).applyMatrix4(Pa),
                            t.union(Nh)
                        }
                    }
                    addInstance(t) {
                        if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
                            throw new Error("THREE.BatchedMesh: Maximum item count reached.");
                        const e = {
                            visible: !0,
                            active: !0,
                            geometryIndex: t
                        };
                        let n = null;
                        this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(uM),
                        n = this._availableInstanceIds.shift(),
                        this._instanceInfo[n] = e) : (n = this._instanceInfo.length,
                        this._instanceInfo.push(e));
                        const i = this._matricesTexture;
                        Pa.identity().toArray(i.image.data, n * 16),
                        i.needsUpdate = !0;
                        const a = this._colorsTexture;
                        return a && (zO.toArray(a.image.data, n * 4),
                        a.needsUpdate = !0),
                        this._visibilityChanged = !0,
                        n
                    }
                    addGeometry(t, e=-1, n=-1) {
                        this._initializeGeometry(t),
                        this._validateGeometry(t);
                        const i = {
                            vertexStart: -1,
                            vertexCount: -1,
                            reservedVertexCount: -1,
                            indexStart: -1,
                            indexCount: -1,
                            reservedIndexCount: -1,
                            start: -1,
                            count: -1,
                            boundingBox: null,
                            boundingSphere: null,
                            active: !0
                        }
                          , a = this._geometryInfo;
                        i.vertexStart = this._nextVertexStart,
                        i.reservedVertexCount = e === -1 ? t.getAttribute("position").count : e;
                        const o = t.getIndex();
                        if (o !== null && (i.indexStart = this._nextIndexStart,
                        i.reservedIndexCount = n === -1 ? o.count : n),
                        i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                        let u;
                        return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(uM),
                        u = this._availableGeometryIds.shift(),
                        a[u] = i) : (u = this._geometryCount,
                        this._geometryCount++,
                        a.push(i)),
                        this.setGeometryAt(u, t),
                        this._nextIndexStart = i.indexStart + i.reservedIndexCount,
                        this._nextVertexStart = i.vertexStart + i.reservedVertexCount,
                        u
                    }
                    setGeometryAt(t, e) {
                        if (t >= this._geometryCount)
                            throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
                        this._validateGeometry(e);
                        const n = this.geometry
                          , i = n.getIndex() !== null
                          , a = n.getIndex()
                          , o = e.getIndex()
                          , u = this._geometryInfo[t];
                        if (i && o.count > u.reservedIndexCount || e.attributes.position.count > u.reservedVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
                        const f = u.vertexStart
                          , d = u.reservedVertexCount;
                        u.vertexCount = e.getAttribute("position").count;
                        for (const p in n.attributes) {
                            const g = e.getAttribute(p)
                              , v = n.getAttribute(p);
                            VO(g, v, f);
                            const y = g.itemSize;
                            for (let S = g.count, E = d; S < E; S++) {
                                const w = f + S;
                                for (let A = 0; A < y; A++)
                                    v.setComponent(w, A, 0)
                            }
                            v.needsUpdate = !0,
                            v.addUpdateRange(f * y, d * y)
                        }
                        if (i) {
                            const p = u.indexStart
                              , g = u.reservedIndexCount;
                            u.indexCount = e.getIndex().count;
                            for (let v = 0; v < o.count; v++)
                                a.setX(p + v, f + o.getX(v));
                            for (let v = o.count, y = g; v < y; v++)
                                a.setX(p + v, f);
                            a.needsUpdate = !0,
                            a.addUpdateRange(p, u.reservedIndexCount)
                        }
                        return u.start = i ? u.indexStart : u.vertexStart,
                        u.count = i ? u.indexCount : u.vertexCount,
                        u.boundingBox = null,
                        e.boundingBox !== null && (u.boundingBox = e.boundingBox.clone()),
                        u.boundingSphere = null,
                        e.boundingSphere !== null && (u.boundingSphere = e.boundingSphere.clone()),
                        this._visibilityChanged = !0,
                        t
                    }
                    deleteGeometry(t) {
                        const e = this._geometryInfo;
                        if (t >= e.length || e[t].active === !1)
                            return this;
                        const n = this._instanceInfo;
                        for (let i = 0, a = n.length; i < a; i++)
                            n[i].active && n[i].geometryIndex === t && this.deleteInstance(i);
                        return e[t].active = !1,
                        this._availableGeometryIds.push(t),
                        this._visibilityChanged = !0,
                        this
                    }
                    deleteInstance(t) {
                        return this.validateInstanceId(t),
                        this._instanceInfo[t].active = !1,
                        this._availableInstanceIds.push(t),
                        this._visibilityChanged = !0,
                        this
                    }
                    optimize() {
                        let t = 0
                          , e = 0;
                        const n = this._geometryInfo
                          , i = n.map( (o, u) => u).sort( (o, u) => n[o].vertexStart - n[u].vertexStart)
                          , a = this.geometry;
                        for (let o = 0, u = n.length; o < u; o++) {
                            const f = n[i[o]];
                            if (f.active !== !1) {
                                if (a.index !== null) {
                                    if (f.indexStart !== e) {
                                        const {indexStart: d, vertexStart: p, reservedIndexCount: g} = f
                                          , v = a.index
                                          , y = v.array
                                          , S = t - p;
                                        for (let E = d; E < d + g; E++)
                                            y[E] = y[E] + S;
                                        v.array.copyWithin(e, d, d + g),
                                        v.addUpdateRange(e, g),
                                        v.needsUpdate = !0,
                                        f.indexStart = e
                                    }
                                    e += f.reservedIndexCount
                                }
                                if (f.vertexStart !== t) {
                                    const {vertexStart: d, reservedVertexCount: p} = f
                                      , g = a.attributes;
                                    for (const v in g) {
                                        const y = g[v]
                                          , {array: S, itemSize: E} = y;
                                        S.copyWithin(t * E, d * E, (d + p) * E),
                                        y.addUpdateRange(t * E, p * E),
                                        y.needsUpdate = !0
                                    }
                                    f.vertexStart = t
                                }
                                t += f.reservedVertexCount,
                                f.start = a.index ? f.indexStart : f.vertexStart,
                                this._nextIndexStart = a.index ? f.indexStart + f.reservedIndexCount : 0,
                                this._nextVertexStart = f.vertexStart + f.reservedVertexCount
                            }
                        }
                        return this._visibilityChanged = !0,
                        this
                    }
                    getBoundingBoxAt(t, e) {
                        if (t >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , i = this._geometryInfo[t];
                        if (i.boundingBox === null) {
                            const a = new qs
                              , o = n.index
                              , u = n.attributes.position;
                            for (let f = i.start, d = i.start + i.count; f < d; f++) {
                                let p = f;
                                o && (p = o.getX(p)),
                                a.expandByPoint(Lg.fromBufferAttribute(u, p))
                            }
                            i.boundingBox = a
                        }
                        return e.copy(i.boundingBox),
                        e
                    }
                    getBoundingSphereAt(t, e) {
                        if (t >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , i = this._geometryInfo[t];
                        if (i.boundingSphere === null) {
                            const a = new As;
                            this.getBoundingBoxAt(t, hy),
                            hy.getCenter(a.center);
                            const o = n.index
                              , u = n.attributes.position;
                            let f = 0;
                            for (let d = i.start, p = i.start + i.count; d < p; d++) {
                                let g = d;
                                o && (g = o.getX(g)),
                                Lg.fromBufferAttribute(u, g),
                                f = Math.max(f, a.center.distanceToSquared(Lg))
                            }
                            a.radius = Math.sqrt(f),
                            i.boundingSphere = a
                        }
                        return e.copy(i.boundingSphere),
                        e
                    }
                    setMatrixAt(t, e) {
                        this.validateInstanceId(t);
                        const n = this._matricesTexture
                          , i = this._matricesTexture.image.data;
                        return e.toArray(i, t * 16),
                        n.needsUpdate = !0,
                        this
                    }
                    getMatrixAt(t, e) {
                        return this.validateInstanceId(t),
                        e.fromArray(this._matricesTexture.image.data, t * 16)
                    }
                    setColorAt(t, e) {
                        return this.validateInstanceId(t),
                        this._colorsTexture === null && this._initColorsTexture(),
                        e.toArray(this._colorsTexture.image.data, t * 4),
                        this._colorsTexture.needsUpdate = !0,
                        this
                    }
                    getColorAt(t, e) {
                        return this.validateInstanceId(t),
                        e.fromArray(this._colorsTexture.image.data, t * 4)
                    }
                    setVisibleAt(t, e) {
                        return this.validateInstanceId(t),
                        this._instanceInfo[t].visible === e ? this : (this._instanceInfo[t].visible = e,
                        this._visibilityChanged = !0,
                        this)
                    }
                    getVisibleAt(t) {
                        return this.validateInstanceId(t),
                        this._instanceInfo[t].visible
                    }
                    setGeometryIdAt(t, e) {
                        return this.validateInstanceId(t),
                        this.validateGeometryId(e),
                        this._instanceInfo[t].geometryIndex = e,
                        this
                    }
                    getGeometryIdAt(t) {
                        return this.validateInstanceId(t),
                        this._instanceInfo[t].geometryIndex
                    }
                    getGeometryRangeAt(t, e={}) {
                        this.validateGeometryId(t);
                        const n = this._geometryInfo[t];
                        return e.vertexStart = n.vertexStart,
                        e.vertexCount = n.vertexCount,
                        e.reservedVertexCount = n.reservedVertexCount,
                        e.indexStart = n.indexStart,
                        e.indexCount = n.indexCount,
                        e.reservedIndexCount = n.reservedIndexCount,
                        e.start = n.start,
                        e.count = n.count,
                        e
                    }
                    setInstanceCount(t) {
                        const e = this._availableInstanceIds
                          , n = this._instanceInfo;
                        for (e.sort(uM); e[e.length - 1] === n.length - 1; )
                            n.pop(),
                            e.pop();
                        if (t < n.length)
                            throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);
                        const i = new Int32Array(t)
                          , a = new Int32Array(t);
                        Dh(this._multiDrawCounts, i),
                        Dh(this._multiDrawStarts, a),
                        this._multiDrawCounts = i,
                        this._multiDrawStarts = a,
                        this._maxInstanceCount = t;
                        const o = this._indirectTexture
                          , u = this._matricesTexture
                          , f = this._colorsTexture;
                        o.dispose(),
                        this._initIndirectTexture(),
                        Dh(o.image.data, this._indirectTexture.image.data),
                        u.dispose(),
                        this._initMatricesTexture(),
                        Dh(u.image.data, this._matricesTexture.image.data),
                        f && (f.dispose(),
                        this._initColorsTexture(),
                        Dh(f.image.data, this._colorsTexture.image.data))
                    }
                    setGeometrySize(t, e) {
                        const n = [...this._geometryInfo].filter(o => o.active);
                        if (Math.max(...n.map(o => o.vertexStart + o.reservedVertexCount)) > t)
                            throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);
                        if (this.geometry.index && Math.max(...n.map(o => o.indexStart + o.reservedIndexCount)) > e)
                            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`);
                        const i = this.geometry;
                        i.dispose(),
                        this._maxVertexCount = t,
                        this._maxIndexCount = e,
                        this._geometryInitialized && (this._geometryInitialized = !1,
                        this.geometry = new en,
                        this._initializeGeometry(i));
                        const a = this.geometry;
                        i.index && Dh(i.index.array, a.index.array);
                        for (const o in i.attributes)
                            Dh(i.attributes[o].array, a.attributes[o].array)
                    }
                    raycast(t, e) {
                        const n = this._instanceInfo
                          , i = this._geometryInfo
                          , a = this.matrixWorld
                          , o = this.geometry;
                        Ys.material = this.material,
                        Ys.geometry.index = o.index,
                        Ys.geometry.attributes = o.attributes,
                        Ys.geometry.boundingBox === null && (Ys.geometry.boundingBox = new qs),
                        Ys.geometry.boundingSphere === null && (Ys.geometry.boundingSphere = new As);
                        for (let u = 0, f = n.length; u < f; u++) {
                            if (!n[u].visible || !n[u].active)
                                continue;
                            const d = n[u].geometryIndex
                              , p = i[d];
                            Ys.geometry.setDrawRange(p.start, p.count),
                            this.getMatrixAt(u, Ys.matrixWorld).premultiply(a),
                            this.getBoundingBoxAt(d, Ys.geometry.boundingBox),
                            this.getBoundingSphereAt(d, Ys.geometry.boundingSphere),
                            Ys.raycast(t, fy);
                            for (let g = 0, v = fy.length; g < v; g++) {
                                const y = fy[g];
                                y.object = this,
                                y.batchId = u,
                                e.push(y)
                            }
                            fy.length = 0
                        }
                        Ys.material = null,
                        Ys.geometry.index = null,
                        Ys.geometry.attributes = {},
                        Ys.geometry.setDrawRange(0, 1 / 0)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.geometry = t.geometry.clone(),
                        this.perObjectFrustumCulled = t.perObjectFrustumCulled,
                        this.sortObjects = t.sortObjects,
                        this.boundingBox = t.boundingBox !== null ? t.boundingBox.clone() : null,
                        this.boundingSphere = t.boundingSphere !== null ? t.boundingSphere.clone() : null,
                        this._geometryInfo = t._geometryInfo.map(e => ({
                            ...e,
                            boundingBox: e.boundingBox !== null ? e.boundingBox.clone() : null,
                            boundingSphere: e.boundingSphere !== null ? e.boundingSphere.clone() : null
                        })),
                        this._instanceInfo = t._instanceInfo.map(e => ({
                            ...e
                        })),
                        this._availableInstanceIds = t._availableInstanceIds.slice(),
                        this._availableGeometryIds = t._availableGeometryIds.slice(),
                        this._nextIndexStart = t._nextIndexStart,
                        this._nextVertexStart = t._nextVertexStart,
                        this._geometryCount = t._geometryCount,
                        this._maxInstanceCount = t._maxInstanceCount,
                        this._maxVertexCount = t._maxVertexCount,
                        this._maxIndexCount = t._maxIndexCount,
                        this._geometryInitialized = t._geometryInitialized,
                        this._multiDrawCounts = t._multiDrawCounts.slice(),
                        this._multiDrawStarts = t._multiDrawStarts.slice(),
                        this._indirectTexture = t._indirectTexture.clone(),
                        this._indirectTexture.image.data = this._indirectTexture.image.data.slice(),
                        this._matricesTexture = t._matricesTexture.clone(),
                        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
                        this._colorsTexture !== null && (this._colorsTexture = t._colorsTexture.clone(),
                        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this._matricesTexture.dispose(),
                        this._matricesTexture = null,
                        this._indirectTexture.dispose(),
                        this._indirectTexture = null,
                        this._colorsTexture !== null && (this._colorsTexture.dispose(),
                        this._colorsTexture = null)
                    }
                    onBeforeRender(t, e, n, i, a) {
                        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                            return;
                        const o = i.getIndex()
                          , u = o === null ? 1 : o.array.BYTES_PER_ELEMENT
                          , f = this._instanceInfo
                          , d = this._multiDrawStarts
                          , p = this._multiDrawCounts
                          , g = this._geometryInfo
                          , v = this.perObjectFrustumCulled
                          , y = this._indirectTexture
                          , S = y.image.data
                          , E = n.isArrayCamera ? BO : BA;
                        v && !n.isArrayCamera && (Pa.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
                        BA.setFromProjectionMatrix(Pa, n.coordinateSystem, n.reversedDepth));
                        let w = 0;
                        if (this.sortObjects) {
                            Pa.copy(this.matrixWorld).invert(),
                            Lg.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Pa),
                            PA.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(Pa);
                            for (let R = 0, N = f.length; R < N; R++)
                                if (f[R].visible && f[R].active) {
                                    const D = f[R].geometryIndex;
                                    this.getMatrixAt(R, Pa),
                                    this.getBoundingSphereAt(D, Nh).applyMatrix4(Pa);
                                    let U = !1;
                                    if (v && (U = !E.intersectsSphere(Nh, n)),
                                    !U) {
                                        const z = g[D]
                                          , I = PO.subVectors(Nh.center, Lg).dot(PA);
                                        hM.push(z.start, z.count, I, R)
                                    }
                                }
                            const A = hM.list
                              , T = this.customSort;
                            T === null ? A.sort(a.transparent ? LO : UO) : T.call(this, A, n);
                            for (let R = 0, N = A.length; R < N; R++) {
                                const D = A[R];
                                d[w] = D.start * u,
                                p[w] = D.count,
                                S[w] = D.index,
                                w++
                            }
                            hM.reset()
                        } else
                            for (let A = 0, T = f.length; A < T; A++)
                                if (f[A].visible && f[A].active) {
                                    const R = f[A].geometryIndex;
                                    let N = !1;
                                    if (v && (this.getMatrixAt(A, Pa),
                                    this.getBoundingSphereAt(R, Nh).applyMatrix4(Pa),
                                    N = !E.intersectsSphere(Nh, n)),
                                    !N) {
                                        const D = g[R];
                                        d[w] = D.start * u,
                                        p[w] = D.count,
                                        S[w] = A,
                                        w++
                                    }
                                }
                        y.needsUpdate = !0,
                        this._multiDrawCount = w,
                        this._visibilityChanged = !1
                    }
                    onBeforeShadow(t, e, n, i, a, o) {
                        this.onBeforeRender(t, null, i, a, o)
                    }
                }
                  , _a = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isLineBasicMaterial = !0,
                        this.type = "LineBasicMaterial",
                        this.color = new ut(16777215),
                        this.map = null,
                        this.linewidth = 1,
                        this.linecap = "round",
                        this.linejoin = "round",
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.map = t.map,
                        this.linewidth = t.linewidth,
                        this.linecap = t.linecap,
                        this.linejoin = t.linejoin,
                        this.fog = t.fog,
                        this
                    }
                }
                ;
                const dy = new J
                  , py = new J
                  , FA = new jt
                  , Ig = new Id
                  , my = new As
                  , fM = new J
                  , HA = new J;
                var du = class extends zn {
                    constructor(t=new en, e=new _a) {
                        super(),
                        this.isLine = !0,
                        this.type = "Line",
                        this.geometry = t,
                        this.material = e,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                        this.geometry = t.geometry,
                        this
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.index === null) {
                            const e = t.attributes.position
                              , n = [0];
                            for (let i = 1, a = e.count; i < a; i++)
                                dy.fromBufferAttribute(e, i - 1),
                                py.fromBufferAttribute(e, i),
                                n[i] = n[i - 1],
                                n[i] += dy.distanceTo(py);
                            t.setAttribute("lineDistance", new _t(n,1))
                        } else
                            at("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry
                          , i = this.matrixWorld
                          , a = t.params.Line.threshold
                          , o = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        my.copy(n.boundingSphere),
                        my.applyMatrix4(i),
                        my.radius += a,
                        t.ray.intersectsSphere(my) === !1)
                            return;
                        FA.copy(i).invert(),
                        Ig.copy(t.ray).applyMatrix4(FA);
                        const u = a / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , f = u * u
                          , d = this.isLineSegments ? 2 : 1
                          , p = n.index
                          , g = n.attributes.position;
                        if (p !== null) {
                            const v = Math.max(0, o.start)
                              , y = Math.min(p.count, o.start + o.count);
                            for (let S = v, E = y - 1; S < E; S += d) {
                                const w = p.getX(S)
                                  , A = p.getX(S + 1)
                                  , T = gy(this, t, Ig, f, w, A, S);
                                T && e.push(T)
                            }
                            if (this.isLineLoop) {
                                const S = p.getX(y - 1)
                                  , E = p.getX(v)
                                  , w = gy(this, t, Ig, f, S, E, y - 1);
                                w && e.push(w)
                            }
                        } else {
                            const v = Math.max(0, o.start)
                              , y = Math.min(g.count, o.start + o.count);
                            for (let S = v, E = y - 1; S < E; S += d) {
                                const w = gy(this, t, Ig, f, S, S + 1, S);
                                w && e.push(w)
                            }
                            if (this.isLineLoop) {
                                const S = gy(this, t, Ig, f, y - 1, v, y - 1);
                                S && e.push(S)
                            }
                        }
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes
                          , e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, a = n.length; i < a; i++) {
                                    const o = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[o] = i
                                }
                            }
                        }
                    }
                }
                ;
                function gy(t, e, n, i, a, o, u) {
                    const f = t.geometry.attributes.position;
                    if (dy.fromBufferAttribute(f, a),
                    py.fromBufferAttribute(f, o),
                    n.distanceSqToSegment(dy, py, fM, HA) > i)
                        return;
                    fM.applyMatrix4(t.matrixWorld);
                    const d = e.ray.origin.distanceTo(fM);
                    if (!(d < e.near || d > e.far))
                        return {
                            distance: d,
                            point: HA.clone().applyMatrix4(t.matrixWorld),
                            index: u,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: t
                        }
                }
                const GA = new J
                  , kA = new J;
                var fl = class extends du {
                    constructor(t, e) {
                        super(t, e),
                        this.isLineSegments = !0,
                        this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.index === null) {
                            const e = t.attributes.position
                              , n = [];
                            for (let i = 0, a = e.count; i < a; i += 2)
                                GA.fromBufferAttribute(e, i),
                                kA.fromBufferAttribute(e, i + 1),
                                n[i] = i === 0 ? 0 : n[i - 1],
                                n[i + 1] = n[i] + GA.distanceTo(kA);
                            t.setAttribute("lineDistance", new _t(n,1))
                        } else
                            at("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                }
                  , qA = class extends du {
                    constructor(t, e) {
                        super(t, e),
                        this.isLineLoop = !0,
                        this.type = "LineLoop"
                    }
                }
                  , dM = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isPointsMaterial = !0,
                        this.type = "PointsMaterial",
                        this.color = new ut(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.size = 1,
                        this.sizeAttenuation = !0,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.map = t.map,
                        this.alphaMap = t.alphaMap,
                        this.size = t.size,
                        this.sizeAttenuation = t.sizeAttenuation,
                        this.fog = t.fog,
                        this
                    }
                }
                ;
                const XA = new jt
                  , pM = new Id
                  , vy = new As
                  , _y = new J;
                var WA = class extends zn {
                    constructor(t=new en, e=new dM) {
                        super(),
                        this.isPoints = !0,
                        this.type = "Points",
                        this.geometry = t,
                        this.material = e,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                        this.geometry = t.geometry,
                        this
                    }
                    raycast(t, e) {
                        const n = this.geometry
                          , i = this.matrixWorld
                          , a = t.params.Points.threshold
                          , o = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        vy.copy(n.boundingSphere),
                        vy.applyMatrix4(i),
                        vy.radius += a,
                        t.ray.intersectsSphere(vy) === !1)
                            return;
                        XA.copy(i).invert(),
                        pM.copy(t.ray).applyMatrix4(XA);
                        const u = a / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , f = u * u
                          , d = n.index
                          , p = n.attributes.position;
                        if (d !== null) {
                            const g = Math.max(0, o.start)
                              , v = Math.min(d.count, o.start + o.count);
                            for (let y = g, S = v; y < S; y++) {
                                const E = d.getX(y);
                                _y.fromBufferAttribute(p, E),
                                YA(_y, E, f, i, t, e, this)
                            }
                        } else {
                            const g = Math.max(0, o.start)
                              , v = Math.min(p.count, o.start + o.count);
                            for (let y = g, S = v; y < S; y++)
                                _y.fromBufferAttribute(p, y),
                                YA(_y, y, f, i, t, e, this)
                        }
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes
                          , e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, a = n.length; i < a; i++) {
                                    const o = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[o] = i
                                }
                            }
                        }
                    }
                }
                ;
                function YA(t, e, n, i, a, o, u) {
                    const f = pM.distanceSqToPoint(t);
                    if (f < n) {
                        const d = new J;
                        pM.closestPointToPoint(t, d),
                        d.applyMatrix4(i);
                        const p = a.ray.origin.distanceTo(d);
                        if (p < a.near || p > a.far)
                            return;
                        o.push({
                            distance: p,
                            distanceToRay: Math.sqrt(f),
                            point: d,
                            index: e,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: u
                        })
                    }
                }
                var jA = class extends gs {
                    constructor(t, e, n, i, a=fi, o=fi, u, f, d) {
                        super(t, e, n, i, a, o, u, f, d),
                        this.isVideoTexture = !0,
                        this.generateMipmaps = !1,
                        this._requestVideoFrameCallbackId = 0;
                        const p = this;
                        function g() {
                            p.needsUpdate = !0,
                            p._requestVideoFrameCallbackId = t.requestVideoFrameCallback(g)
                        }
                        "requestVideoFrameCallback"in t && (this._requestVideoFrameCallbackId = t.requestVideoFrameCallback(g))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const t = this.image;
                        !("requestVideoFrameCallback"in t) && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                    dispose() {
                        this._requestVideoFrameCallbackId !== 0 && (this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),
                        this._requestVideoFrameCallbackId = 0),
                        super.dispose()
                    }
                }
                  , FO = class extends jA {
                    constructor(t, e, n, i, a, o, u, f) {
                        super({}, t, e, n, i, a, o, u, f),
                        this.isVideoFrameTexture = !0
                    }
                    update() {}
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    setFrame(t) {
                        this.image = t,
                        this.needsUpdate = !0
                    }
                }
                  , HO = class extends gs {
                    constructor(t, e) {
                        super({
                            width: t,
                            height: e
                        }),
                        this.isFramebufferTexture = !0,
                        this.magFilter = Vi,
                        this.minFilter = Vi,
                        this.generateMipmaps = !1,
                        this.needsUpdate = !0
                    }
                }
                  , yy = class extends gs {
                    constructor(t, e, n, i, a, o, u, f, d, p, g, v) {
                        super(null, o, u, f, d, p, i, a, g, v),
                        this.isCompressedTexture = !0,
                        this.image = {
                            width: e,
                            height: n
                        },
                        this.mipmaps = t,
                        this.flipY = !1,
                        this.generateMipmaps = !1
                    }
                }
                  , GO = class extends yy {
                    constructor(t, e, n, i, a, o) {
                        super(t, e, n, a, o),
                        this.isCompressedArrayTexture = !0,
                        this.image.depth = i,
                        this.wrapR = Ia,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(t) {
                        this.layerUpdates.add(t)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , kO = class extends yy {
                    constructor(t, e, n) {
                        super(void 0, t[0].width, t[0].height, e, n, al),
                        this.isCompressedCubeTexture = !0,
                        this.isCubeTexture = !0,
                        this.image = t
                    }
                }
                  , qO = class extends gs {
                    constructor(t, e, n, i, a, o, u, f, d) {
                        super(t, e, n, i, a, o, u, f, d),
                        this.isCanvasTexture = !0,
                        this.needsUpdate = !0
                    }
                }
                  , ep = class extends gs {
                    constructor(t, e, n=Ir, i, a, o, u=Vi, f=Vi, d, p=ll, g=1) {
                        if (p !== ll && p !== $c)
                            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        super({
                            width: t,
                            height: e,
                            depth: g
                        }, i, a, o, u, f, p, n, d),
                        this.isDepthTexture = !0,
                        this.flipY = !1,
                        this.generateMipmaps = !1,
                        this.compareFunction = null
                    }
                    copy(t) {
                        return super.copy(t),
                        this.source = new iu(Object.assign({}, t.image)),
                        this.compareFunction = t.compareFunction,
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return this.compareFunction !== null && (e.compareFunction = this.compareFunction),
                        e
                    }
                }
                  , ZA = class extends ep {
                    constructor(t, e=Ir, n=al, i, a, o=Vi, u=Vi, f, d=ll) {
                        const p = {
                            width: t,
                            height: t,
                            depth: 1
                        }
                          , g = [p, p, p, p, p, p];
                        super(t, t, e, n, i, a, o, u, f, d),
                        this.image = g,
                        this.isCubeDepthTexture = !0,
                        this.isCubeTexture = !0
                    }
                    get images() {
                        return this.image
                    }
                    set images(t) {
                        this.image = t
                    }
                }
                  , mM = class extends gs {
                    constructor(t=null) {
                        super(),
                        this.sourceTexture = t,
                        this.isExternalTexture = !0
                    }
                    copy(t) {
                        return super.copy(t),
                        this.sourceTexture = t.sourceTexture,
                        this
                    }
                }
                  , QA = class bR extends en {
                    constructor(e=1, n=1, i=4, a=8, o=1) {
                        super(),
                        this.type = "CapsuleGeometry",
                        this.parameters = {
                            radius: e,
                            height: n,
                            capSegments: i,
                            radialSegments: a,
                            heightSegments: o
                        },
                        n = Math.max(0, n),
                        i = Math.max(1, Math.floor(i)),
                        a = Math.max(3, Math.floor(a)),
                        o = Math.max(1, Math.floor(o));
                        const u = []
                          , f = []
                          , d = []
                          , p = []
                          , g = n / 2
                          , v = Math.PI / 2 * e
                          , y = n
                          , S = 2 * v + y
                          , E = i * 2 + o
                          , w = a + 1
                          , A = new J
                          , T = new J;
                        for (let R = 0; R <= E; R++) {
                            let N = 0
                              , D = 0
                              , U = 0
                              , z = 0;
                            if (R <= i) {
                                const B = R / i
                                  , P = B * Math.PI / 2;
                                D = -g - e * Math.cos(P),
                                U = e * Math.sin(P),
                                z = -e * Math.cos(P),
                                N = B * v
                            } else if (R <= i + o) {
                                const B = (R - i) / o;
                                D = -g + B * n,
                                U = e,
                                z = 0,
                                N = v + B * y
                            } else {
                                const B = (R - i - o) / i
                                  , P = B * Math.PI / 2;
                                D = g + e * Math.sin(P),
                                U = e * Math.cos(P),
                                z = e * Math.sin(P),
                                N = v + y + B * v
                            }
                            const I = Math.max(0, Math.min(1, N / S));
                            let V = 0;
                            R === 0 ? V = .5 / a : R === E && (V = -.5 / a);
                            for (let B = 0; B <= a; B++) {
                                const P = B / a
                                  , G = P * Math.PI * 2
                                  , K = Math.sin(G)
                                  , ee = Math.cos(G);
                                T.x = -U * ee,
                                T.y = D,
                                T.z = U * K,
                                f.push(T.x, T.y, T.z),
                                A.set(-U * ee, z, U * K),
                                A.normalize(),
                                d.push(A.x, A.y, A.z),
                                p.push(P + V, I)
                            }
                            if (R > 0) {
                                const B = (R - 1) * w;
                                for (let P = 0; P < a; P++) {
                                    const G = B + P
                                      , K = B + P + 1
                                      , ee = R * w + P
                                      , te = R * w + P + 1;
                                    u.push(G, K, ee),
                                    u.push(K, te, ee)
                                }
                            }
                        }
                        this.setIndex(u),
                        this.setAttribute("position", new _t(f,3)),
                        this.setAttribute("normal", new _t(d,3)),
                        this.setAttribute("uv", new _t(p,2))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new bR(e.radius,e.height,e.capSegments,e.radialSegments,e.heightSegments)
                    }
                }
                  , KA = class TR extends en {
                    constructor(e=1, n=32, i=0, a=Math.PI * 2) {
                        super(),
                        this.type = "CircleGeometry",
                        this.parameters = {
                            radius: e,
                            segments: n,
                            thetaStart: i,
                            thetaLength: a
                        },
                        n = Math.max(3, n);
                        const o = []
                          , u = []
                          , f = []
                          , d = []
                          , p = new J
                          , g = new Ge;
                        u.push(0, 0, 0),
                        f.push(0, 0, 1),
                        d.push(.5, .5);
                        for (let v = 0, y = 3; v <= n; v++,
                        y += 3) {
                            const S = i + v / n * a;
                            p.x = e * Math.cos(S),
                            p.y = e * Math.sin(S),
                            u.push(p.x, p.y, p.z),
                            f.push(0, 0, 1),
                            g.x = (u[y] / e + 1) / 2,
                            g.y = (u[y + 1] / e + 1) / 2,
                            d.push(g.x, g.y)
                        }
                        for (let v = 1; v <= n; v++)
                            o.push(v, v + 1, 0);
                        this.setIndex(o),
                        this.setAttribute("position", new _t(u,3)),
                        this.setAttribute("normal", new _t(f,3)),
                        this.setAttribute("uv", new _t(d,2))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new TR(e.radius,e.segments,e.thetaStart,e.thetaLength)
                    }
                }
                  , gM = class AR extends en {
                    constructor(e=1, n=1, i=1, a=32, o=1, u=!1, f=0, d=Math.PI * 2) {
                        super(),
                        this.type = "CylinderGeometry",
                        this.parameters = {
                            radiusTop: e,
                            radiusBottom: n,
                            height: i,
                            radialSegments: a,
                            heightSegments: o,
                            openEnded: u,
                            thetaStart: f,
                            thetaLength: d
                        };
                        const p = this;
                        a = Math.floor(a),
                        o = Math.floor(o);
                        const g = []
                          , v = []
                          , y = []
                          , S = [];
                        let E = 0;
                        const w = []
                          , A = i / 2;
                        let T = 0;
                        R(),
                        u === !1 && (e > 0 && N(!0),
                        n > 0 && N(!1)),
                        this.setIndex(g),
                        this.setAttribute("position", new _t(v,3)),
                        this.setAttribute("normal", new _t(y,3)),
                        this.setAttribute("uv", new _t(S,2));
                        function R() {
                            const D = new J
                              , U = new J;
                            let z = 0;
                            const I = (n - e) / i;
                            for (let V = 0; V <= o; V++) {
                                const B = []
                                  , P = V / o
                                  , G = P * (n - e) + e;
                                for (let K = 0; K <= a; K++) {
                                    const ee = K / a
                                      , te = ee * d + f
                                      , oe = Math.sin(te)
                                      , q = Math.cos(te);
                                    U.x = G * oe,
                                    U.y = -P * i + A,
                                    U.z = G * q,
                                    v.push(U.x, U.y, U.z),
                                    D.set(oe, I, q).normalize(),
                                    y.push(D.x, D.y, D.z),
                                    S.push(ee, 1 - P),
                                    B.push(E++)
                                }
                                w.push(B)
                            }
                            for (let V = 0; V < a; V++)
                                for (let B = 0; B < o; B++) {
                                    const P = w[B][V]
                                      , G = w[B + 1][V]
                                      , K = w[B + 1][V + 1]
                                      , ee = w[B][V + 1];
                                    (e > 0 || B !== 0) && (g.push(P, G, ee),
                                    z += 3),
                                    (n > 0 || B !== o - 1) && (g.push(G, K, ee),
                                    z += 3)
                                }
                            p.addGroup(T, z, 0),
                            T += z
                        }
                        function N(D) {
                            const U = E
                              , z = new Ge
                              , I = new J;
                            let V = 0;
                            const B = D === !0 ? e : n
                              , P = D === !0 ? 1 : -1;
                            for (let K = 1; K <= a; K++)
                                v.push(0, A * P, 0),
                                y.push(0, P, 0),
                                S.push(.5, .5),
                                E++;
                            const G = E;
                            for (let K = 0; K <= a; K++) {
                                const ee = K / a * d + f
                                  , te = Math.cos(ee)
                                  , oe = Math.sin(ee);
                                I.x = B * oe,
                                I.y = A * P,
                                I.z = B * te,
                                v.push(I.x, I.y, I.z),
                                y.push(0, P, 0),
                                z.x = te * .5 + .5,
                                z.y = oe * .5 * P + .5,
                                S.push(z.x, z.y),
                                E++
                            }
                            for (let K = 0; K < a; K++) {
                                const ee = U + K
                                  , te = G + K;
                                D === !0 ? g.push(te, te + 1, ee) : g.push(te + 1, te, ee),
                                V += 3
                            }
                            p.addGroup(T, V, D === !0 ? 1 : 2),
                            T += V
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new AR(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
                    }
                }
                  , vM = class ER extends gM {
                    constructor(e=1, n=1, i=32, a=1, o=!1, u=0, f=Math.PI * 2) {
                        super(0, e, n, i, a, o, u, f),
                        this.type = "ConeGeometry",
                        this.parameters = {
                            radius: e,
                            height: n,
                            radialSegments: i,
                            heightSegments: a,
                            openEnded: o,
                            thetaStart: u,
                            thetaLength: f
                        }
                    }
                    static fromJSON(e) {
                        return new ER(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
                    }
                }
                  , tp = class CR extends en {
                    constructor(e=[], n=[], i=1, a=0) {
                        super(),
                        this.type = "PolyhedronGeometry",
                        this.parameters = {
                            vertices: e,
                            indices: n,
                            radius: i,
                            detail: a
                        };
                        const o = []
                          , u = [];
                        f(a),
                        p(i),
                        g(),
                        this.setAttribute("position", new _t(o,3)),
                        this.setAttribute("normal", new _t(o.slice(),3)),
                        this.setAttribute("uv", new _t(u,2)),
                        a === 0 ? this.computeVertexNormals() : this.normalizeNormals();
                        function f(R) {
                            const N = new J
                              , D = new J
                              , U = new J;
                            for (let z = 0; z < n.length; z += 3)
                                S(n[z + 0], N),
                                S(n[z + 1], D),
                                S(n[z + 2], U),
                                d(N, D, U, R)
                        }
                        function d(R, N, D, U) {
                            const z = U + 1
                              , I = [];
                            for (let V = 0; V <= z; V++) {
                                I[V] = [];
                                const B = R.clone().lerp(D, V / z)
                                  , P = N.clone().lerp(D, V / z)
                                  , G = z - V;
                                for (let K = 0; K <= G; K++)
                                    K === 0 && V === z ? I[V][K] = B : I[V][K] = B.clone().lerp(P, K / G)
                            }
                            for (let V = 0; V < z; V++)
                                for (let B = 0; B < 2 * (z - V) - 1; B++) {
                                    const P = Math.floor(B / 2);
                                    B % 2 === 0 ? (y(I[V][P + 1]),
                                    y(I[V + 1][P]),
                                    y(I[V][P])) : (y(I[V][P + 1]),
                                    y(I[V + 1][P + 1]),
                                    y(I[V + 1][P]))
                                }
                        }
                        function p(R) {
                            const N = new J;
                            for (let D = 0; D < o.length; D += 3)
                                N.x = o[D + 0],
                                N.y = o[D + 1],
                                N.z = o[D + 2],
                                N.normalize().multiplyScalar(R),
                                o[D + 0] = N.x,
                                o[D + 1] = N.y,
                                o[D + 2] = N.z
                        }
                        function g() {
                            const R = new J;
                            for (let N = 0; N < o.length; N += 3) {
                                R.x = o[N + 0],
                                R.y = o[N + 1],
                                R.z = o[N + 2];
                                const D = A(R) / 2 / Math.PI + .5
                                  , U = T(R) / Math.PI + .5;
                                u.push(D, 1 - U)
                            }
                            E(),
                            v()
                        }
                        function v() {
                            for (let R = 0; R < u.length; R += 6) {
                                const N = u[R + 0]
                                  , D = u[R + 2]
                                  , U = u[R + 4];
                                Math.max(N, D, U) > .9 && Math.min(N, D, U) < .1 && (N < .2 && (u[R + 0] += 1),
                                D < .2 && (u[R + 2] += 1),
                                U < .2 && (u[R + 4] += 1))
                            }
                        }
                        function y(R) {
                            o.push(R.x, R.y, R.z)
                        }
                        function S(R, N) {
                            const D = R * 3;
                            N.x = e[D + 0],
                            N.y = e[D + 1],
                            N.z = e[D + 2]
                        }
                        function E() {
                            const R = new J
                              , N = new J
                              , D = new J
                              , U = new J
                              , z = new Ge
                              , I = new Ge
                              , V = new Ge;
                            for (let B = 0, P = 0; B < o.length; B += 9,
                            P += 6) {
                                R.set(o[B + 0], o[B + 1], o[B + 2]),
                                N.set(o[B + 3], o[B + 4], o[B + 5]),
                                D.set(o[B + 6], o[B + 7], o[B + 8]),
                                z.set(u[P + 0], u[P + 1]),
                                I.set(u[P + 2], u[P + 3]),
                                V.set(u[P + 4], u[P + 5]),
                                U.copy(R).add(N).add(D).divideScalar(3);
                                const G = A(U);
                                w(z, P + 0, R, G),
                                w(I, P + 2, N, G),
                                w(V, P + 4, D, G)
                            }
                        }
                        function w(R, N, D, U) {
                            U < 0 && R.x === 1 && (u[N] = R.x - 1),
                            D.x === 0 && D.z === 0 && (u[N] = U / 2 / Math.PI + .5)
                        }
                        function A(R) {
                            return Math.atan2(R.z, -R.x)
                        }
                        function T(R) {
                            return Math.atan2(-R.y, Math.sqrt(R.x * R.x + R.z * R.z))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new CR(e.vertices,e.indices,e.radius,e.detail)
                    }
                }
                  , JA = class wR extends tp {
                    constructor(e=1, n=0) {
                        const i = (1 + Math.sqrt(5)) / 2
                          , a = 1 / i
                          , o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -a, -i, 0, -a, i, 0, a, -i, 0, a, i, -a, -i, 0, -a, i, 0, a, -i, 0, a, i, 0, -i, 0, -a, i, 0, -a, -i, 0, a, i, 0, a];
                        super(o, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, n),
                        this.type = "DodecahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: n
                        }
                    }
                    static fromJSON(e) {
                        return new wR(e.radius,e.detail)
                    }
                }
                ;
                const Sy = new J
                  , xy = new J
                  , _M = new J
                  , My = new lu;
                var $A = class extends en {
                    constructor(t=null, e=1) {
                        if (super(),
                        this.type = "EdgesGeometry",
                        this.parameters = {
                            geometry: t,
                            thresholdAngle: e
                        },
                        t !== null) {
                            const n = Math.pow(10, 4)
                              , i = Math.cos(Ah * e)
                              , a = t.getIndex()
                              , o = t.getAttribute("position")
                              , u = a ? a.count : o.count
                              , f = [0, 0, 0]
                              , d = ["a", "b", "c"]
                              , p = new Array(3)
                              , g = {}
                              , v = [];
                            for (let y = 0; y < u; y += 3) {
                                a ? (f[0] = a.getX(y),
                                f[1] = a.getX(y + 1),
                                f[2] = a.getX(y + 2)) : (f[0] = y,
                                f[1] = y + 1,
                                f[2] = y + 2);
                                const {a: S, b: E, c: w} = My;
                                if (S.fromBufferAttribute(o, f[0]),
                                E.fromBufferAttribute(o, f[1]),
                                w.fromBufferAttribute(o, f[2]),
                                My.getNormal(_M),
                                p[0] = `${Math.round(S.x * n)},${Math.round(S.y * n)},${Math.round(S.z * n)}`,
                                p[1] = `${Math.round(E.x * n)},${Math.round(E.y * n)},${Math.round(E.z * n)}`,
                                p[2] = `${Math.round(w.x * n)},${Math.round(w.y * n)},${Math.round(w.z * n)}`,
                                !(p[0] === p[1] || p[1] === p[2] || p[2] === p[0]))
                                    for (let A = 0; A < 3; A++) {
                                        const T = (A + 1) % 3
                                          , R = p[A]
                                          , N = p[T]
                                          , D = My[d[A]]
                                          , U = My[d[T]]
                                          , z = `${R}_${N}`
                                          , I = `${N}_${R}`;
                                        I in g && g[I] ? (_M.dot(g[I].normal) <= i && (v.push(D.x, D.y, D.z),
                                        v.push(U.x, U.y, U.z)),
                                        g[I] = null) : z in g || (g[z] = {
                                            index0: f[A],
                                            index1: f[T],
                                            normal: _M.clone()
                                        })
                                    }
                            }
                            for (const y in g)
                                if (g[y]) {
                                    const {index0: S, index1: E} = g[y];
                                    Sy.fromBufferAttribute(o, S),
                                    xy.fromBufferAttribute(o, E),
                                    v.push(Sy.x, Sy.y, Sy.z),
                                    v.push(xy.x, xy.y, xy.z)
                                }
                            this.setAttribute("position", new _t(v,3))
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                }
                  , So = class {
                    constructor() {
                        this.type = "Curve",
                        this.arcLengthDivisions = 200,
                        this.needsUpdate = !1,
                        this.cacheArcLengths = null
                    }
                    getPoint() {
                        at("Curve: .getPoint() not implemented.")
                    }
                    getPointAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getPoint(n, e)
                    }
                    getPoints(t=5) {
                        const e = [];
                        for (let n = 0; n <= t; n++)
                            e.push(this.getPoint(n / t));
                        return e
                    }
                    getSpacedPoints(t=5) {
                        const e = [];
                        for (let n = 0; n <= t; n++)
                            e.push(this.getPointAt(n / t));
                        return e
                    }
                    getLength() {
                        const t = this.getLengths();
                        return t[t.length - 1]
                    }
                    getLengths(t=this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, i = this.getPoint(0), a = 0;
                        e.push(0);
                        for (let o = 1; o <= t; o++)
                            n = this.getPoint(o / t),
                            a += n.distanceTo(i),
                            e.push(a),
                            i = n;
                        return this.cacheArcLengths = e,
                        e
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.getLengths()
                    }
                    getUtoTmapping(t, e=null) {
                        const n = this.getLengths();
                        let i = 0;
                        const a = n.length;
                        let o;
                        e ? o = e : o = t * n[a - 1];
                        let u = 0, f = a - 1, d;
                        for (; u <= f; )
                            if (i = Math.floor(u + (f - u) / 2),
                            d = n[i] - o,
                            d < 0)
                                u = i + 1;
                            else if (d > 0)
                                f = i - 1;
                            else {
                                f = i;
                                break
                            }
                        if (i = f,
                        n[i] === o)
                            return i / (a - 1);
                        const p = n[i]
                          , g = n[i + 1] - p
                          , v = (o - p) / g;
                        return (i + v) / (a - 1)
                    }
                    getTangent(t, e) {
                        let i = t - 1e-4
                          , a = t + 1e-4;
                        i < 0 && (i = 0),
                        a > 1 && (a = 1);
                        const o = this.getPoint(i)
                          , u = this.getPoint(a)
                          , f = e || (o.isVector2 ? new Ge : new J);
                        return f.copy(u).sub(o).normalize(),
                        f
                    }
                    getTangentAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getTangent(n, e)
                    }
                    computeFrenetFrames(t, e=!1) {
                        const n = new J
                          , i = []
                          , a = []
                          , o = []
                          , u = new J
                          , f = new jt;
                        for (let y = 0; y <= t; y++) {
                            const S = y / t;
                            i[y] = this.getTangentAt(S, new J)
                        }
                        a[0] = new J,
                        o[0] = new J;
                        let d = Number.MAX_VALUE;
                        const p = Math.abs(i[0].x)
                          , g = Math.abs(i[0].y)
                          , v = Math.abs(i[0].z);
                        p <= d && (d = p,
                        n.set(1, 0, 0)),
                        g <= d && (d = g,
                        n.set(0, 1, 0)),
                        v <= d && n.set(0, 0, 1),
                        u.crossVectors(i[0], n).normalize(),
                        a[0].crossVectors(i[0], u),
                        o[0].crossVectors(i[0], a[0]);
                        for (let y = 1; y <= t; y++) {
                            if (a[y] = a[y - 1].clone(),
                            o[y] = o[y - 1].clone(),
                            u.crossVectors(i[y - 1], i[y]),
                            u.length() > Number.EPSILON) {
                                u.normalize();
                                const S = Math.acos(Ht(i[y - 1].dot(i[y]), -1, 1));
                                a[y].applyMatrix4(f.makeRotationAxis(u, S))
                            }
                            o[y].crossVectors(i[y], a[y])
                        }
                        if (e === !0) {
                            let y = Math.acos(Ht(a[0].dot(a[t]), -1, 1));
                            y /= t,
                            i[0].dot(u.crossVectors(a[0], a[t])) > 0 && (y = -y);
                            for (let S = 1; S <= t; S++)
                                a[S].applyMatrix4(f.makeRotationAxis(i[S], y * S)),
                                o[S].crossVectors(i[S], a[S])
                        }
                        return {
                            tangents: i,
                            normals: a,
                            binormals: o
                        }
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions,
                        this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return t.arcLengthDivisions = this.arcLengthDivisions,
                        t.type = this.type,
                        t
                    }
                    fromJSON(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions,
                        this
                    }
                }
                  , by = class extends So {
                    constructor(t=0, e=0, n=1, i=1, a=0, o=Math.PI * 2, u=!1, f=0) {
                        super(),
                        this.isEllipseCurve = !0,
                        this.type = "EllipseCurve",
                        this.aX = t,
                        this.aY = e,
                        this.xRadius = n,
                        this.yRadius = i,
                        this.aStartAngle = a,
                        this.aEndAngle = o,
                        this.aClockwise = u,
                        this.aRotation = f
                    }
                    getPoint(t, e=new Ge) {
                        const n = e
                          , i = Math.PI * 2;
                        let a = this.aEndAngle - this.aStartAngle;
                        const o = Math.abs(a) < Number.EPSILON;
                        for (; a < 0; )
                            a += i;
                        for (; a > i; )
                            a -= i;
                        a < Number.EPSILON && (o ? a = 0 : a = i),
                        this.aClockwise === !0 && !o && (a === i ? a = -i : a = a - i);
                        const u = this.aStartAngle + t * a;
                        let f = this.aX + this.xRadius * Math.cos(u)
                          , d = this.aY + this.yRadius * Math.sin(u);
                        if (this.aRotation !== 0) {
                            const p = Math.cos(this.aRotation)
                              , g = Math.sin(this.aRotation)
                              , v = f - this.aX
                              , y = d - this.aY;
                            f = v * p - y * g + this.aX,
                            d = v * g + y * p + this.aY
                        }
                        return n.set(f, d)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.aX = t.aX,
                        this.aY = t.aY,
                        this.xRadius = t.xRadius,
                        this.yRadius = t.yRadius,
                        this.aStartAngle = t.aStartAngle,
                        this.aEndAngle = t.aEndAngle,
                        this.aClockwise = t.aClockwise,
                        this.aRotation = t.aRotation,
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.aX = this.aX,
                        t.aY = this.aY,
                        t.xRadius = this.xRadius,
                        t.yRadius = this.yRadius,
                        t.aStartAngle = this.aStartAngle,
                        t.aEndAngle = this.aEndAngle,
                        t.aClockwise = this.aClockwise,
                        t.aRotation = this.aRotation,
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.aX = t.aX,
                        this.aY = t.aY,
                        this.xRadius = t.xRadius,
                        this.yRadius = t.yRadius,
                        this.aStartAngle = t.aStartAngle,
                        this.aEndAngle = t.aEndAngle,
                        this.aClockwise = t.aClockwise,
                        this.aRotation = t.aRotation,
                        this
                    }
                }
                  , eE = class extends by {
                    constructor(t, e, n, i, a, o) {
                        super(t, e, n, n, i, a, o),
                        this.isArcCurve = !0,
                        this.type = "ArcCurve"
                    }
                }
                ;
                function yM() {
                    let t = 0
                      , e = 0
                      , n = 0
                      , i = 0;
                    function a(o, u, f, d) {
                        t = o,
                        e = f,
                        n = -3 * o + 3 * u - 2 * f - d,
                        i = 2 * o - 2 * u + f + d
                    }
                    return {
                        initCatmullRom: function(o, u, f, d, p) {
                            a(u, f, p * (f - o), p * (d - u))
                        },
                        initNonuniformCatmullRom: function(o, u, f, d, p, g, v) {
                            let y = (u - o) / p - (f - o) / (p + g) + (f - u) / g
                              , S = (f - u) / g - (d - u) / (g + v) + (d - f) / v;
                            y *= g,
                            S *= g,
                            a(u, f, y, S)
                        },
                        calc: function(o) {
                            const u = o * o
                              , f = u * o;
                            return t + e * o + n * u + i * f
                        }
                    }
                }
                const Ty = new J
                  , SM = new yM
                  , xM = new yM
                  , MM = new yM;
                var tE = class extends So {
                    constructor(t=[], e=!1, n="centripetal", i=.5) {
                        super(),
                        this.isCatmullRomCurve3 = !0,
                        this.type = "CatmullRomCurve3",
                        this.points = t,
                        this.closed = e,
                        this.curveType = n,
                        this.tension = i
                    }
                    getPoint(t, e=new J) {
                        const n = e
                          , i = this.points
                          , a = i.length
                          , o = (a - (this.closed ? 0 : 1)) * t;
                        let u = Math.floor(o)
                          , f = o - u;
                        this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / a) + 1) * a : f === 0 && u === a - 1 && (u = a - 2,
                        f = 1);
                        let d, p;
                        this.closed || u > 0 ? d = i[(u - 1) % a] : (Ty.subVectors(i[0], i[1]).add(i[0]),
                        d = Ty);
                        const g = i[u % a]
                          , v = i[(u + 1) % a];
                        if (this.closed || u + 2 < a ? p = i[(u + 2) % a] : (Ty.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]),
                        p = Ty),
                        this.curveType === "centripetal" || this.curveType === "chordal") {
                            const y = this.curveType === "chordal" ? .5 : .25;
                            let S = Math.pow(d.distanceToSquared(g), y)
                              , E = Math.pow(g.distanceToSquared(v), y)
                              , w = Math.pow(v.distanceToSquared(p), y);
                            E < 1e-4 && (E = 1),
                            S < 1e-4 && (S = E),
                            w < 1e-4 && (w = E),
                            SM.initNonuniformCatmullRom(d.x, g.x, v.x, p.x, S, E, w),
                            xM.initNonuniformCatmullRom(d.y, g.y, v.y, p.y, S, E, w),
                            MM.initNonuniformCatmullRom(d.z, g.z, v.z, p.z, S, E, w)
                        } else
                            this.curveType === "catmullrom" && (SM.initCatmullRom(d.x, g.x, v.x, p.x, this.tension),
                            xM.initCatmullRom(d.y, g.y, v.y, p.y, this.tension),
                            MM.initCatmullRom(d.z, g.z, v.z, p.z, this.tension));
                        return n.set(SM.calc(f), xM.calc(f), MM.calc(f)),
                        n
                    }
                    copy(t) {
                        super.copy(t),
                        this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const i = t.points[e];
                            this.points.push(i.clone())
                        }
                        return this.closed = t.closed,
                        this.curveType = t.curveType,
                        this.tension = t.tension,
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const i = this.points[e];
                            t.points.push(i.toArray())
                        }
                        return t.closed = this.closed,
                        t.curveType = this.curveType,
                        t.tension = this.tension,
                        t
                    }
                    fromJSON(t) {
                        super.fromJSON(t),
                        this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const i = t.points[e];
                            this.points.push(new J().fromArray(i))
                        }
                        return this.closed = t.closed,
                        this.curveType = t.curveType,
                        this.tension = t.tension,
                        this
                    }
                }
                ;
                function nE(t, e, n, i, a) {
                    const o = (i - e) * .5
                      , u = (a - n) * .5
                      , f = t * t
                      , d = t * f;
                    return (2 * n - 2 * i + o + u) * d + (-3 * n + 3 * i - 2 * o - u) * f + o * t + n
                }
                function XO(t, e) {
                    const n = 1 - t;
                    return n * n * e
                }
                function WO(t, e) {
                    return 2 * (1 - t) * t * e
                }
                function YO(t, e) {
                    return t * t * e
                }
                function zg(t, e, n, i) {
                    return XO(t, e) + WO(t, n) + YO(t, i)
                }
                function jO(t, e) {
                    const n = 1 - t;
                    return n * n * n * e
                }
                function ZO(t, e) {
                    const n = 1 - t;
                    return 3 * n * n * t * e
                }
                function QO(t, e) {
                    return 3 * (1 - t) * t * t * e
                }
                function KO(t, e) {
                    return t * t * t * e
                }
                function Bg(t, e, n, i, a) {
                    return jO(t, e) + ZO(t, n) + QO(t, i) + KO(t, a)
                }
                var bM = class extends So {
                    constructor(t=new Ge, e=new Ge, n=new Ge, i=new Ge) {
                        super(),
                        this.isCubicBezierCurve = !0,
                        this.type = "CubicBezierCurve",
                        this.v0 = t,
                        this.v1 = e,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(t, e=new Ge) {
                        const n = e
                          , i = this.v0
                          , a = this.v1
                          , o = this.v2
                          , u = this.v3;
                        return n.set(Bg(t, i.x, a.x, o.x, u.x), Bg(t, i.y, a.y, o.y, u.y)),
                        n
                    }
                    copy(t) {
                        return super.copy(t),
                        this.v0.copy(t.v0),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this.v3.copy(t.v3),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(),
                        t.v1 = this.v1.toArray(),
                        t.v2 = this.v2.toArray(),
                        t.v3 = this.v3.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this.v3.fromArray(t.v3),
                        this
                    }
                }
                  , iE = class extends So {
                    constructor(t=new J, e=new J, n=new J, i=new J) {
                        super(),
                        this.isCubicBezierCurve3 = !0,
                        this.type = "CubicBezierCurve3",
                        this.v0 = t,
                        this.v1 = e,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(t, e=new J) {
                        const n = e
                          , i = this.v0
                          , a = this.v1
                          , o = this.v2
                          , u = this.v3;
                        return n.set(Bg(t, i.x, a.x, o.x, u.x), Bg(t, i.y, a.y, o.y, u.y), Bg(t, i.z, a.z, o.z, u.z)),
                        n
                    }
                    copy(t) {
                        return super.copy(t),
                        this.v0.copy(t.v0),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this.v3.copy(t.v3),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(),
                        t.v1 = this.v1.toArray(),
                        t.v2 = this.v2.toArray(),
                        t.v3 = this.v3.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this.v3.fromArray(t.v3),
                        this
                    }
                }
                  , TM = class extends So {
                    constructor(t=new Ge, e=new Ge) {
                        super(),
                        this.isLineCurve = !0,
                        this.type = "LineCurve",
                        this.v1 = t,
                        this.v2 = e
                    }
                    getPoint(t, e=new Ge) {
                        const n = e;
                        return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(t).add(this.v1)),
                        n
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    getTangent(t, e=new Ge) {
                        return e.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(t, e) {
                        return this.getTangent(t, e)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(),
                        t.v2 = this.v2.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this
                    }
                }
                  , sE = class extends So {
                    constructor(t=new J, e=new J) {
                        super(),
                        this.isLineCurve3 = !0,
                        this.type = "LineCurve3",
                        this.v1 = t,
                        this.v2 = e
                    }
                    getPoint(t, e=new J) {
                        const n = e;
                        return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(t).add(this.v1)),
                        n
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    getTangent(t, e=new J) {
                        return e.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(t, e) {
                        return this.getTangent(t, e)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(),
                        t.v2 = this.v2.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this
                    }
                }
                  , AM = class extends So {
                    constructor(t=new Ge, e=new Ge, n=new Ge) {
                        super(),
                        this.isQuadraticBezierCurve = !0,
                        this.type = "QuadraticBezierCurve",
                        this.v0 = t,
                        this.v1 = e,
                        this.v2 = n
                    }
                    getPoint(t, e=new Ge) {
                        const n = e
                          , i = this.v0
                          , a = this.v1
                          , o = this.v2;
                        return n.set(zg(t, i.x, a.x, o.x), zg(t, i.y, a.y, o.y)),
                        n
                    }
                    copy(t) {
                        return super.copy(t),
                        this.v0.copy(t.v0),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(),
                        t.v1 = this.v1.toArray(),
                        t.v2 = this.v2.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this
                    }
                }
                  , EM = class extends So {
                    constructor(t=new J, e=new J, n=new J) {
                        super(),
                        this.isQuadraticBezierCurve3 = !0,
                        this.type = "QuadraticBezierCurve3",
                        this.v0 = t,
                        this.v1 = e,
                        this.v2 = n
                    }
                    getPoint(t, e=new J) {
                        const n = e
                          , i = this.v0
                          , a = this.v1
                          , o = this.v2;
                        return n.set(zg(t, i.x, a.x, o.x), zg(t, i.y, a.y, o.y), zg(t, i.z, a.z, o.z)),
                        n
                    }
                    copy(t) {
                        return super.copy(t),
                        this.v0.copy(t.v0),
                        this.v1.copy(t.v1),
                        this.v2.copy(t.v2),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(),
                        t.v1 = this.v1.toArray(),
                        t.v2 = this.v2.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.v0.fromArray(t.v0),
                        this.v1.fromArray(t.v1),
                        this.v2.fromArray(t.v2),
                        this
                    }
                }
                  , CM = class extends So {
                    constructor(t=[]) {
                        super(),
                        this.isSplineCurve = !0,
                        this.type = "SplineCurve",
                        this.points = t
                    }
                    getPoint(t, e=new Ge) {
                        const n = e
                          , i = this.points
                          , a = (i.length - 1) * t
                          , o = Math.floor(a)
                          , u = a - o
                          , f = i[o === 0 ? o : o - 1]
                          , d = i[o]
                          , p = i[o > i.length - 2 ? i.length - 1 : o + 1]
                          , g = i[o > i.length - 3 ? i.length - 1 : o + 2];
                        return n.set(nE(u, f.x, d.x, p.x, g.x), nE(u, f.y, d.y, p.y, g.y)),
                        n
                    }
                    copy(t) {
                        super.copy(t),
                        this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const i = t.points[e];
                            this.points.push(i.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const i = this.points[e];
                            t.points.push(i.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t),
                        this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const i = t.points[e];
                            this.points.push(new Ge().fromArray(i))
                        }
                        return this
                    }
                }
                  , Ay = Object.freeze({
                    __proto__: null,
                    ArcCurve: eE,
                    CatmullRomCurve3: tE,
                    CubicBezierCurve: bM,
                    CubicBezierCurve3: iE,
                    EllipseCurve: by,
                    LineCurve: TM,
                    LineCurve3: sE,
                    QuadraticBezierCurve: AM,
                    QuadraticBezierCurve3: EM,
                    SplineCurve: CM
                })
                  , aE = class extends So {
                    constructor() {
                        super(),
                        this.type = "CurvePath",
                        this.curves = [],
                        this.autoClose = !1
                    }
                    add(t) {
                        this.curves.push(t)
                    }
                    closePath() {
                        const t = this.curves[0].getPoint(0)
                          , e = this.curves[this.curves.length - 1].getPoint(1);
                        if (!t.equals(e)) {
                            const n = t.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                            this.curves.push(new Ay[n](e,t))
                        }
                        return this
                    }
                    getPoint(t, e) {
                        const n = t * this.getLength()
                          , i = this.getCurveLengths();
                        let a = 0;
                        for (; a < i.length; ) {
                            if (i[a] >= n) {
                                const o = i[a] - n
                                  , u = this.curves[a]
                                  , f = u.getLength()
                                  , d = f === 0 ? 0 : 1 - o / f;
                                return u.getPointAt(d, e)
                            }
                            a++
                        }
                        return null
                    }
                    getLength() {
                        const t = this.getCurveLengths();
                        return t[t.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.cacheLengths = null,
                        this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                            return this.cacheLengths;
                        const t = [];
                        let e = 0;
                        for (let n = 0, i = this.curves.length; n < i; n++)
                            e += this.curves[n].getLength(),
                            t.push(e);
                        return this.cacheLengths = t,
                        t
                    }
                    getSpacedPoints(t=40) {
                        const e = [];
                        for (let n = 0; n <= t; n++)
                            e.push(this.getPoint(n / t));
                        return this.autoClose && e.push(e[0]),
                        e
                    }
                    getPoints(t=12) {
                        const e = [];
                        let n;
                        for (let i = 0, a = this.curves; i < a.length; i++) {
                            const o = a[i]
                              , u = o.isEllipseCurve ? t * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? t * o.points.length : t
                              , f = o.getPoints(u);
                            for (let d = 0; d < f.length; d++) {
                                const p = f[d];
                                n && n.equals(p) || (e.push(p),
                                n = p)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
                        e
                    }
                    copy(t) {
                        super.copy(t),
                        this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const i = t.curves[e];
                            this.curves.push(i.clone())
                        }
                        return this.autoClose = t.autoClose,
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose,
                        t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const i = this.curves[e];
                            t.curves.push(i.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t),
                        this.autoClose = t.autoClose,
                        this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const i = t.curves[e];
                            this.curves.push(new Ay[i.type]().fromJSON(i))
                        }
                        return this
                    }
                }
                  , Ey = class extends aE {
                    constructor(t) {
                        super(),
                        this.type = "Path",
                        this.currentPoint = new Ge,
                        t && this.setFromPoints(t)
                    }
                    setFromPoints(t) {
                        this.moveTo(t[0].x, t[0].y);
                        for (let e = 1, n = t.length; e < n; e++)
                            this.lineTo(t[e].x, t[e].y);
                        return this
                    }
                    moveTo(t, e) {
                        return this.currentPoint.set(t, e),
                        this
                    }
                    lineTo(t, e) {
                        const n = new TM(this.currentPoint.clone(),new Ge(t,e));
                        return this.curves.push(n),
                        this.currentPoint.set(t, e),
                        this
                    }
                    quadraticCurveTo(t, e, n, i) {
                        const a = new AM(this.currentPoint.clone(),new Ge(t,e),new Ge(n,i));
                        return this.curves.push(a),
                        this.currentPoint.set(n, i),
                        this
                    }
                    bezierCurveTo(t, e, n, i, a, o) {
                        const u = new bM(this.currentPoint.clone(),new Ge(t,e),new Ge(n,i),new Ge(a,o));
                        return this.curves.push(u),
                        this.currentPoint.set(a, o),
                        this
                    }
                    splineThru(t) {
                        const e = new CM([this.currentPoint.clone()].concat(t));
                        return this.curves.push(e),
                        this.currentPoint.copy(t[t.length - 1]),
                        this
                    }
                    arc(t, e, n, i, a, o) {
                        const u = this.currentPoint.x
                          , f = this.currentPoint.y;
                        return this.absarc(t + u, e + f, n, i, a, o),
                        this
                    }
                    absarc(t, e, n, i, a, o) {
                        return this.absellipse(t, e, n, n, i, a, o),
                        this
                    }
                    ellipse(t, e, n, i, a, o, u, f) {
                        const d = this.currentPoint.x
                          , p = this.currentPoint.y;
                        return this.absellipse(t + d, e + p, n, i, a, o, u, f),
                        this
                    }
                    absellipse(t, e, n, i, a, o, u, f) {
                        const d = new by(t,e,n,i,a,o,u,f);
                        if (this.curves.length > 0) {
                            const g = d.getPoint(0);
                            g.equals(this.currentPoint) || this.lineTo(g.x, g.y)
                        }
                        this.curves.push(d);
                        const p = d.getPoint(1);
                        return this.currentPoint.copy(p),
                        this
                    }
                    copy(t) {
                        return super.copy(t),
                        this.currentPoint.copy(t.currentPoint),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.currentPoint = this.currentPoint.toArray(),
                        t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t),
                        this.currentPoint.fromArray(t.currentPoint),
                        this
                    }
                }
                  , Oh = class extends Ey {
                    constructor(t) {
                        super(t),
                        this.uuid = ir(),
                        this.type = "Shape",
                        this.holes = []
                    }
                    getPointsHoles(t) {
                        const e = [];
                        for (let n = 0, i = this.holes.length; n < i; n++)
                            e[n] = this.holes[n].getPoints(t);
                        return e
                    }
                    extractPoints(t) {
                        return {
                            shape: this.getPoints(t),
                            holes: this.getPointsHoles(t)
                        }
                    }
                    copy(t) {
                        super.copy(t),
                        this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const i = t.holes[e];
                            this.holes.push(i.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid,
                        t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const i = this.holes[e];
                            t.holes.push(i.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t),
                        this.uuid = t.uuid,
                        this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const i = t.holes[e];
                            this.holes.push(new Ey().fromJSON(i))
                        }
                        return this
                    }
                }
                ;
                function JO(t, e, n=2) {
                    const i = e && e.length
                      , a = i ? e[0] * n : t.length;
                    let o = rE(t, 0, a, n, !0);
                    const u = [];
                    if (!o || o.next === o.prev)
                        return u;
                    let f, d, p;
                    if (i && (o = iU(t, e, o, n)),
                    t.length > 80 * n) {
                        f = t[0],
                        d = t[1];
                        let g = f
                          , v = d;
                        for (let y = n; y < a; y += n) {
                            const S = t[y]
                              , E = t[y + 1];
                            S < f && (f = S),
                            E < d && (d = E),
                            S > g && (g = S),
                            E > v && (v = E)
                        }
                        p = Math.max(g - f, v - d),
                        p = p !== 0 ? 32767 / p : 0
                    }
                    return Pg(o, u, n, f, d, p, 0),
                    u
                }
                function rE(t, e, n, i, a) {
                    let o;
                    if (a === pU(t, e, n, i) > 0)
                        for (let u = e; u < n; u += i)
                            o = uE(u / i | 0, t[u], t[u + 1], o);
                    else
                        for (let u = n - i; u >= e; u -= i)
                            o = uE(u / i | 0, t[u], t[u + 1], o);
                    return o && np(o, o.next) && (Hg(o),
                    o = o.next),
                    o
                }
                function Uh(t, e) {
                    if (!t)
                        return t;
                    e || (e = t);
                    let n = t, i;
                    do
                        if (i = !1,
                        !n.steiner && (np(n, n.next) || bi(n.prev, n, n.next) === 0)) {
                            if (Hg(n),
                            n = e = n.prev,
                            n === n.next)
                                break;
                            i = !0
                        } else
                            n = n.next;
                    while (i || n !== e);
                    return e
                }
                function Pg(t, e, n, i, a, o, u) {
                    if (!t)
                        return;
                    !u && o && lU(t, i, a, o);
                    let f = t;
                    for (; t.prev !== t.next; ) {
                        const d = t.prev
                          , p = t.next;
                        if (o ? eU(t, i, a, o) : $O(t)) {
                            e.push(d.i, t.i, p.i),
                            Hg(t),
                            t = p.next,
                            f = p.next;
                            continue
                        }
                        if (t = p,
                        t === f) {
                            u ? u === 1 ? (t = tU(Uh(t), e),
                            Pg(t, e, n, i, a, o, 2)) : u === 2 && nU(t, e, n, i, a, o) : Pg(Uh(t), e, n, i, a, o, 1);
                            break
                        }
                    }
                }
                function $O(t) {
                    const e = t.prev
                      , n = t
                      , i = t.next;
                    if (bi(e, n, i) >= 0)
                        return !1;
                    const a = e.x
                      , o = n.x
                      , u = i.x
                      , f = e.y
                      , d = n.y
                      , p = i.y
                      , g = Math.min(a, o, u)
                      , v = Math.min(f, d, p)
                      , y = Math.max(a, o, u)
                      , S = Math.max(f, d, p);
                    let E = i.next;
                    for (; E !== e; ) {
                        if (E.x >= g && E.x <= y && E.y >= v && E.y <= S && Vg(a, f, o, d, u, p, E.x, E.y) && bi(E.prev, E, E.next) >= 0)
                            return !1;
                        E = E.next
                    }
                    return !0
                }
                function eU(t, e, n, i) {
                    const a = t.prev
                      , o = t
                      , u = t.next;
                    if (bi(a, o, u) >= 0)
                        return !1;
                    const f = a.x
                      , d = o.x
                      , p = u.x
                      , g = a.y
                      , v = o.y
                      , y = u.y
                      , S = Math.min(f, d, p)
                      , E = Math.min(g, v, y)
                      , w = Math.max(f, d, p)
                      , A = Math.max(g, v, y)
                      , T = wM(S, E, e, n, i)
                      , R = wM(w, A, e, n, i);
                    let N = t.prevZ
                      , D = t.nextZ;
                    for (; N && N.z >= T && D && D.z <= R; ) {
                        if (N.x >= S && N.x <= w && N.y >= E && N.y <= A && N !== a && N !== u && Vg(f, g, d, v, p, y, N.x, N.y) && bi(N.prev, N, N.next) >= 0 || (N = N.prevZ,
                        D.x >= S && D.x <= w && D.y >= E && D.y <= A && D !== a && D !== u && Vg(f, g, d, v, p, y, D.x, D.y) && bi(D.prev, D, D.next) >= 0))
                            return !1;
                        D = D.nextZ
                    }
                    for (; N && N.z >= T; ) {
                        if (N.x >= S && N.x <= w && N.y >= E && N.y <= A && N !== a && N !== u && Vg(f, g, d, v, p, y, N.x, N.y) && bi(N.prev, N, N.next) >= 0)
                            return !1;
                        N = N.prevZ
                    }
                    for (; D && D.z <= R; ) {
                        if (D.x >= S && D.x <= w && D.y >= E && D.y <= A && D !== a && D !== u && Vg(f, g, d, v, p, y, D.x, D.y) && bi(D.prev, D, D.next) >= 0)
                            return !1;
                        D = D.nextZ
                    }
                    return !0
                }
                function tU(t, e) {
                    let n = t;
                    do {
                        const i = n.prev
                          , a = n.next.next;
                        !np(i, a) && lE(i, n, n.next, a) && Fg(i, a) && Fg(a, i) && (e.push(i.i, n.i, a.i),
                        Hg(n),
                        Hg(n.next),
                        n = t = a),
                        n = n.next
                    } while (n !== t);
                    return Uh(n)
                }
                function nU(t, e, n, i, a, o) {
                    let u = t;
                    do {
                        let f = u.next.next;
                        for (; f !== u.prev; ) {
                            if (u.i !== f.i && hU(u, f)) {
                                let d = cE(u, f);
                                u = Uh(u, u.next),
                                d = Uh(d, d.next),
                                Pg(u, e, n, i, a, o, 0),
                                Pg(d, e, n, i, a, o, 0);
                                return
                            }
                            f = f.next
                        }
                        u = u.next
                    } while (u !== t)
                }
                function iU(t, e, n, i) {
                    const a = [];
                    for (let o = 0, u = e.length; o < u; o++) {
                        const f = rE(t, e[o] * i, o < u - 1 ? e[o + 1] * i : t.length, i, !1);
                        f === f.next && (f.steiner = !0),
                        a.push(uU(f))
                    }
                    a.sort(sU);
                    for (let o = 0; o < a.length; o++)
                        n = aU(a[o], n);
                    return n
                }
                function sU(t, e) {
                    let n = t.x - e.x;
                    return n === 0 && (n = t.y - e.y,
                    n === 0 && (n = (t.next.y - t.y) / (t.next.x - t.x) - (e.next.y - e.y) / (e.next.x - e.x))),
                    n
                }
                function aU(t, e) {
                    const n = rU(t, e);
                    if (!n)
                        return e;
                    const i = cE(n, t);
                    return Uh(i, i.next),
                    Uh(n, n.next)
                }
                function rU(t, e) {
                    let n = e;
                    const i = t.x
                      , a = t.y;
                    let o = -1 / 0, u;
                    if (np(t, n))
                        return n;
                    do {
                        if (np(t, n.next))
                            return n.next;
                        if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                            const v = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (v <= i && v > o && (o = v,
                            u = n.x < n.next.x ? n : n.next,
                            v === i))
                                return u
                        }
                        n = n.next
                    } while (n !== e);
                    if (!u)
                        return null;
                    const f = u
                      , d = u.x
                      , p = u.y;
                    let g = 1 / 0;
                    n = u;
                    do {
                        if (i >= n.x && n.x >= d && i !== n.x && oE(a < p ? i : o, a, d, p, a < p ? o : i, a, n.x, n.y)) {
                            const v = Math.abs(a - n.y) / (i - n.x);
                            Fg(n, t) && (v < g || v === g && (n.x > u.x || n.x === u.x && oU(u, n))) && (u = n,
                            g = v)
                        }
                        n = n.next
                    } while (n !== f);
                    return u
                }
                function oU(t, e) {
                    return bi(t.prev, t, e.prev) < 0 && bi(e.next, t, t.next) < 0
                }
                function lU(t, e, n, i) {
                    let a = t;
                    do
                        a.z === 0 && (a.z = wM(a.x, a.y, e, n, i)),
                        a.prevZ = a.prev,
                        a.nextZ = a.next,
                        a = a.next;
                    while (a !== t);
                    a.prevZ.nextZ = null,
                    a.prevZ = null,
                    cU(a)
                }
                function cU(t) {
                    let e, n = 1;
                    do {
                        let i = t, a;
                        t = null;
                        let o = null;
                        for (e = 0; i; ) {
                            e++;
                            let u = i
                              , f = 0;
                            for (let p = 0; p < n && (f++,
                            u = u.nextZ,
                            !!u); p++)
                                ;
                            let d = n;
                            for (; f > 0 || d > 0 && u; )
                                f !== 0 && (d === 0 || !u || i.z <= u.z) ? (a = i,
                                i = i.nextZ,
                                f--) : (a = u,
                                u = u.nextZ,
                                d--),
                                o ? o.nextZ = a : t = a,
                                a.prevZ = o,
                                o = a;
                            i = u
                        }
                        o.nextZ = null,
                        n *= 2
                    } while (e > 1);
                    return t
                }
                function wM(t, e, n, i, a) {
                    return t = (t - n) * a | 0,
                    e = (e - i) * a | 0,
                    t = (t | t << 8) & 16711935,
                    t = (t | t << 4) & 252645135,
                    t = (t | t << 2) & 858993459,
                    t = (t | t << 1) & 1431655765,
                    e = (e | e << 8) & 16711935,
                    e = (e | e << 4) & 252645135,
                    e = (e | e << 2) & 858993459,
                    e = (e | e << 1) & 1431655765,
                    t | e << 1
                }
                function uU(t) {
                    let e = t
                      , n = t;
                    do
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
                        e = e.next;
                    while (e !== t);
                    return n
                }
                function oE(t, e, n, i, a, o, u, f) {
                    return (a - u) * (e - f) >= (t - u) * (o - f) && (t - u) * (i - f) >= (n - u) * (e - f) && (n - u) * (o - f) >= (a - u) * (i - f)
                }
                function Vg(t, e, n, i, a, o, u, f) {
                    return !(t === u && e === f) && oE(t, e, n, i, a, o, u, f)
                }
                function hU(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && !fU(t, e) && (Fg(t, e) && Fg(e, t) && dU(t, e) && (bi(t.prev, t, e.prev) || bi(t, e.prev, e)) || np(t, e) && bi(t.prev, t, t.next) > 0 && bi(e.prev, e, e.next) > 0)
                }
                function bi(t, e, n) {
                    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                }
                function np(t, e) {
                    return t.x === e.x && t.y === e.y
                }
                function lE(t, e, n, i) {
                    const a = wy(bi(t, e, n))
                      , o = wy(bi(t, e, i))
                      , u = wy(bi(n, i, t))
                      , f = wy(bi(n, i, e));
                    return !!(a !== o && u !== f || a === 0 && Cy(t, n, e) || o === 0 && Cy(t, i, e) || u === 0 && Cy(n, t, i) || f === 0 && Cy(n, e, i))
                }
                function Cy(t, e, n) {
                    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                }
                function wy(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }
                function fU(t, e) {
                    let n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && lE(n, n.next, t, e))
                            return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }
                function Fg(t, e) {
                    return bi(t.prev, t, t.next) < 0 ? bi(t, e, t.next) >= 0 && bi(t, t.prev, e) >= 0 : bi(t, e, t.prev) < 0 || bi(t, t.next, e) < 0
                }
                function dU(t, e) {
                    let n = t
                      , i = !1;
                    const a = (t.x + e.x) / 2
                      , o = (t.y + e.y) / 2;
                    do
                        n.y > o != n.next.y > o && n.next.y !== n.y && a < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                        n = n.next;
                    while (n !== t);
                    return i
                }
                function cE(t, e) {
                    const n = RM(t.i, t.x, t.y)
                      , i = RM(e.i, e.x, e.y)
                      , a = t.next
                      , o = e.prev;
                    return t.next = e,
                    e.prev = t,
                    n.next = a,
                    a.prev = n,
                    i.next = n,
                    n.prev = i,
                    o.next = i,
                    i.prev = o,
                    i
                }
                function uE(t, e, n, i) {
                    const a = RM(t, e, n);
                    return i ? (a.next = i.next,
                    a.prev = i,
                    i.next.prev = a,
                    i.next = a) : (a.prev = a,
                    a.next = a),
                    a
                }
                function Hg(t) {
                    t.next.prev = t.prev,
                    t.prev.next = t.next,
                    t.prevZ && (t.prevZ.nextZ = t.nextZ),
                    t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }
                function RM(t, e, n) {
                    return {
                        i: t,
                        x: e,
                        y: n,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                function pU(t, e, n, i) {
                    let a = 0;
                    for (let o = e, u = n - i; o < n; o += i)
                        a += (t[u] - t[o]) * (t[o + 1] + t[u + 1]),
                        u = o;
                    return a
                }
                var mU = class {
                    static triangulate(t, e, n=2) {
                        return JO(t, e, n)
                    }
                }
                  , lc = class RR {
                    static area(e) {
                        const n = e.length;
                        let i = 0;
                        for (let a = n - 1, o = 0; o < n; a = o++)
                            i += e[a].x * e[o].y - e[o].x * e[a].y;
                        return i * .5
                    }
                    static isClockWise(e) {
                        return RR.area(e) < 0
                    }
                    static triangulateShape(e, n) {
                        const i = []
                          , a = []
                          , o = [];
                        hE(e),
                        fE(i, e);
                        let u = e.length;
                        n.forEach(hE);
                        for (let d = 0; d < n.length; d++)
                            a.push(u),
                            u += n[d].length,
                            fE(i, n[d]);
                        const f = mU.triangulate(i, a);
                        for (let d = 0; d < f.length; d += 3)
                            o.push(f.slice(d, d + 3));
                        return o
                    }
                }
                ;
                function hE(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }
                function fE(t, e) {
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].x),
                        t.push(e[n].y)
                }
                var dE = class NR extends en {
                    constructor(e=new Oh([new Ge(.5,.5), new Ge(-.5,.5), new Ge(-.5,-.5), new Ge(.5,-.5)]), n={}) {
                        super(),
                        this.type = "ExtrudeGeometry",
                        this.parameters = {
                            shapes: e,
                            options: n
                        },
                        e = Array.isArray(e) ? e : [e];
                        const i = this
                          , a = []
                          , o = [];
                        for (let f = 0, d = e.length; f < d; f++) {
                            const p = e[f];
                            u(p)
                        }
                        this.setAttribute("position", new _t(a,3)),
                        this.setAttribute("uv", new _t(o,2)),
                        this.computeVertexNormals();
                        function u(f) {
                            const d = []
                              , p = n.curveSegments !== void 0 ? n.curveSegments : 12
                              , g = n.steps !== void 0 ? n.steps : 1
                              , v = n.depth !== void 0 ? n.depth : 1;
                            let y = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0
                              , S = n.bevelThickness !== void 0 ? n.bevelThickness : .2
                              , E = n.bevelSize !== void 0 ? n.bevelSize : S - .1
                              , w = n.bevelOffset !== void 0 ? n.bevelOffset : 0
                              , A = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
                            const T = n.extrudePath
                              , R = n.UVGenerator !== void 0 ? n.UVGenerator : gU;
                            let N, D = !1, U, z, I, V;
                            if (T) {
                                N = T.getSpacedPoints(g),
                                D = !0,
                                y = !1;
                                const Ue = T.isCatmullRomCurve3 ? T.closed : !1;
                                U = T.computeFrenetFrames(g, Ue),
                                z = new J,
                                I = new J,
                                V = new J
                            }
                            y || (A = 0,
                            S = 0,
                            E = 0,
                            w = 0);
                            const B = f.extractPoints(p);
                            let P = B.shape;
                            const G = B.holes;
                            if (!lc.isClockWise(P)) {
                                P = P.reverse();
                                for (let Ue = 0, ve = G.length; Ue < ve; Ue++) {
                                    const Ce = G[Ue];
                                    lc.isClockWise(Ce) && (G[Ue] = Ce.reverse())
                                }
                            }
                            function K(Ue) {
                                const Ce = 10000000000000001e-36;
                                let qe = Ue[0];
                                for (let Q = 1; Q <= Ue.length; Q++) {
                                    const Ke = Q % Ue.length
                                      , Ve = Ue[Ke]
                                      , ft = Ve.x - qe.x
                                      , ke = Ve.y - qe.y
                                      , Nt = ft * ft + ke * ke
                                      , Z = Math.max(Math.abs(Ve.x), Math.abs(Ve.y), Math.abs(qe.x), Math.abs(qe.y));
                                    if (Nt <= Ce * Z * Z) {
                                        Ue.splice(Ke, 1),
                                        Q--;
                                        continue
                                    }
                                    qe = Ve
                                }
                            }
                            K(P),
                            G.forEach(K);
                            const ee = G.length
                              , te = P;
                            for (let Ue = 0; Ue < ee; Ue++) {
                                const ve = G[Ue];
                                P = P.concat(ve)
                            }
                            function oe(Ue, ve, Ce) {
                                return ve || Rt("ExtrudeGeometry: vec does not exist"),
                                Ue.clone().addScaledVector(ve, Ce)
                            }
                            const q = P.length;
                            function F(Ue, ve, Ce) {
                                let qe, Q, Ke;
                                const Ve = Ue.x - ve.x
                                  , ft = Ue.y - ve.y
                                  , ke = Ce.x - Ue.x
                                  , Nt = Ce.y - Ue.y
                                  , Z = Ve * Ve + ft * ft
                                  , H = Ve * Nt - ft * ke;
                                if (Math.abs(H) > Number.EPSILON) {
                                    const he = Math.sqrt(Z)
                                      , Le = Math.sqrt(ke * ke + Nt * Nt)
                                      , He = ve.x - ft / he
                                      , Oe = ve.y + Ve / he
                                      , pt = Ce.x - Nt / Le
                                      , et = Ce.y + ke / Le
                                      , xt = ((pt - He) * Nt - (et - Oe) * ke) / (Ve * Nt - ft * ke);
                                    qe = He + Ve * xt - Ue.x,
                                    Q = Oe + ft * xt - Ue.y;
                                    const Dt = qe * qe + Q * Q;
                                    if (Dt <= 2)
                                        return new Ge(qe,Q);
                                    Ke = Math.sqrt(Dt / 2)
                                } else {
                                    let he = !1;
                                    Ve > Number.EPSILON ? ke > Number.EPSILON && (he = !0) : Ve < -Number.EPSILON ? ke < -Number.EPSILON && (he = !0) : Math.sign(ft) === Math.sign(Nt) && (he = !0),
                                    he ? (qe = -ft,
                                    Q = Ve,
                                    Ke = Math.sqrt(Z)) : (qe = Ve,
                                    Q = ft,
                                    Ke = Math.sqrt(Z / 2))
                                }
                                return new Ge(qe / Ke,Q / Ke)
                            }
                            const X = [];
                            for (let Ue = 0, ve = te.length, Ce = ve - 1, qe = Ue + 1; Ue < ve; Ue++,
                            Ce++,
                            qe++)
                                Ce === ve && (Ce = 0),
                                qe === ve && (qe = 0),
                                X[Ue] = F(te[Ue], te[Ce], te[qe]);
                            const $ = [];
                            let ne, ce = X.concat();
                            for (let Ue = 0, ve = ee; Ue < ve; Ue++) {
                                const Ce = G[Ue];
                                ne = [];
                                for (let qe = 0, Q = Ce.length, Ke = Q - 1, Ve = qe + 1; qe < Q; qe++,
                                Ke++,
                                Ve++)
                                    Ke === Q && (Ke = 0),
                                    Ve === Q && (Ve = 0),
                                    ne[qe] = F(Ce[qe], Ce[Ke], Ce[Ve]);
                                $.push(ne),
                                ce = ce.concat(ne)
                            }
                            let k;
                            if (A === 0)
                                k = lc.triangulateShape(te, G);
                            else {
                                const Ue = []
                                  , ve = [];
                                for (let Ce = 0; Ce < A; Ce++) {
                                    const qe = Ce / A
                                      , Q = S * Math.cos(qe * Math.PI / 2)
                                      , Ke = E * Math.sin(qe * Math.PI / 2) + w;
                                    for (let Ve = 0, ft = te.length; Ve < ft; Ve++) {
                                        const ke = oe(te[Ve], X[Ve], Ke);
                                        Te(ke.x, ke.y, -Q),
                                        qe === 0 && Ue.push(ke)
                                    }
                                    for (let Ve = 0, ft = ee; Ve < ft; Ve++) {
                                        const ke = G[Ve];
                                        ne = $[Ve];
                                        const Nt = [];
                                        for (let Z = 0, H = ke.length; Z < H; Z++) {
                                            const he = oe(ke[Z], ne[Z], Ke);
                                            Te(he.x, he.y, -Q),
                                            qe === 0 && Nt.push(he)
                                        }
                                        qe === 0 && ve.push(Nt)
                                    }
                                }
                                k = lc.triangulateShape(Ue, ve)
                            }
                            const pe = k.length
                              , Ae = E + w;
                            for (let Ue = 0; Ue < q; Ue++) {
                                const ve = y ? oe(P[Ue], ce[Ue], Ae) : P[Ue];
                                D ? (I.copy(U.normals[0]).multiplyScalar(ve.x),
                                z.copy(U.binormals[0]).multiplyScalar(ve.y),
                                V.copy(N[0]).add(I).add(z),
                                Te(V.x, V.y, V.z)) : Te(ve.x, ve.y, 0)
                            }
                            for (let Ue = 1; Ue <= g; Ue++)
                                for (let ve = 0; ve < q; ve++) {
                                    const Ce = y ? oe(P[ve], ce[ve], Ae) : P[ve];
                                    D ? (I.copy(U.normals[Ue]).multiplyScalar(Ce.x),
                                    z.copy(U.binormals[Ue]).multiplyScalar(Ce.y),
                                    V.copy(N[Ue]).add(I).add(z),
                                    Te(V.x, V.y, V.z)) : Te(Ce.x, Ce.y, v / g * Ue)
                                }
                            for (let Ue = A - 1; Ue >= 0; Ue--) {
                                const ve = Ue / A
                                  , Ce = S * Math.cos(ve * Math.PI / 2)
                                  , qe = E * Math.sin(ve * Math.PI / 2) + w;
                                for (let Q = 0, Ke = te.length; Q < Ke; Q++) {
                                    const Ve = oe(te[Q], X[Q], qe);
                                    Te(Ve.x, Ve.y, v + Ce)
                                }
                                for (let Q = 0, Ke = G.length; Q < Ke; Q++) {
                                    const Ve = G[Q];
                                    ne = $[Q];
                                    for (let ft = 0, ke = Ve.length; ft < ke; ft++) {
                                        const Nt = oe(Ve[ft], ne[ft], qe);
                                        D ? Te(Nt.x, Nt.y + N[g - 1].y, N[g - 1].x + Ce) : Te(Nt.x, Nt.y, v + Ce)
                                    }
                                }
                            }
                            ie(),
                            Me();
                            function ie() {
                                const Ue = a.length / 3;
                                if (y) {
                                    let ve = 0
                                      , Ce = q * ve;
                                    for (let qe = 0; qe < pe; qe++) {
                                        const Q = k[qe];
                                        Je(Q[2] + Ce, Q[1] + Ce, Q[0] + Ce)
                                    }
                                    ve = g + A * 2,
                                    Ce = q * ve;
                                    for (let qe = 0; qe < pe; qe++) {
                                        const Q = k[qe];
                                        Je(Q[0] + Ce, Q[1] + Ce, Q[2] + Ce)
                                    }
                                } else {
                                    for (let ve = 0; ve < pe; ve++) {
                                        const Ce = k[ve];
                                        Je(Ce[2], Ce[1], Ce[0])
                                    }
                                    for (let ve = 0; ve < pe; ve++) {
                                        const Ce = k[ve];
                                        Je(Ce[0] + q * g, Ce[1] + q * g, Ce[2] + q * g)
                                    }
                                }
                                i.addGroup(Ue, a.length / 3 - Ue, 0)
                            }
                            function Me() {
                                const Ue = a.length / 3;
                                let ve = 0;
                                we(te, ve),
                                ve += te.length;
                                for (let Ce = 0, qe = G.length; Ce < qe; Ce++) {
                                    const Q = G[Ce];
                                    we(Q, ve),
                                    ve += Q.length
                                }
                                i.addGroup(Ue, a.length / 3 - Ue, 1)
                            }
                            function we(Ue, ve) {
                                let Ce = Ue.length;
                                for (; --Ce >= 0; ) {
                                    const qe = Ce;
                                    let Q = Ce - 1;
                                    Q < 0 && (Q = Ue.length - 1);
                                    for (let Ke = 0, Ve = g + A * 2; Ke < Ve; Ke++) {
                                        const ft = q * Ke
                                          , ke = q * (Ke + 1);
                                        Ze(ve + qe + ft, ve + Q + ft, ve + Q + ke, ve + qe + ke)
                                    }
                                }
                            }
                            function Te(Ue, ve, Ce) {
                                d.push(Ue),
                                d.push(ve),
                                d.push(Ce)
                            }
                            function Je(Ue, ve, Ce) {
                                Ct(Ue),
                                Ct(ve),
                                Ct(Ce);
                                const qe = a.length / 3
                                  , Q = R.generateTopUV(i, a, qe - 3, qe - 2, qe - 1);
                                bt(Q[0]),
                                bt(Q[1]),
                                bt(Q[2])
                            }
                            function Ze(Ue, ve, Ce, qe) {
                                Ct(Ue),
                                Ct(ve),
                                Ct(qe),
                                Ct(ve),
                                Ct(Ce),
                                Ct(qe);
                                const Q = a.length / 3
                                  , Ke = R.generateSideWallUV(i, a, Q - 6, Q - 3, Q - 2, Q - 1);
                                bt(Ke[0]),
                                bt(Ke[1]),
                                bt(Ke[3]),
                                bt(Ke[1]),
                                bt(Ke[2]),
                                bt(Ke[3])
                            }
                            function Ct(Ue) {
                                a.push(d[Ue * 3 + 0]),
                                a.push(d[Ue * 3 + 1]),
                                a.push(d[Ue * 3 + 2])
                            }
                            function bt(Ue) {
                                o.push(Ue.x),
                                o.push(Ue.y)
                            }
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON()
                          , n = this.parameters.shapes
                          , i = this.parameters.options;
                        return vU(n, i, e)
                    }
                    static fromJSON(e, n) {
                        const i = [];
                        for (let o = 0, u = e.shapes.length; o < u; o++) {
                            const f = n[e.shapes[o]];
                            i.push(f)
                        }
                        const a = e.options.extrudePath;
                        return a !== void 0 && (e.options.extrudePath = new Ay[a.type]().fromJSON(a)),
                        new NR(i,e.options)
                    }
                }
                ;
                const gU = {
                    generateTopUV: function(t, e, n, i, a) {
                        const o = e[n * 3]
                          , u = e[n * 3 + 1]
                          , f = e[i * 3]
                          , d = e[i * 3 + 1]
                          , p = e[a * 3]
                          , g = e[a * 3 + 1];
                        return [new Ge(o,u), new Ge(f,d), new Ge(p,g)]
                    },
                    generateSideWallUV: function(t, e, n, i, a, o) {
                        const u = e[n * 3]
                          , f = e[n * 3 + 1]
                          , d = e[n * 3 + 2]
                          , p = e[i * 3]
                          , g = e[i * 3 + 1]
                          , v = e[i * 3 + 2]
                          , y = e[a * 3]
                          , S = e[a * 3 + 1]
                          , E = e[a * 3 + 2]
                          , w = e[o * 3]
                          , A = e[o * 3 + 1]
                          , T = e[o * 3 + 2];
                        return Math.abs(f - g) < Math.abs(u - p) ? [new Ge(u,1 - d), new Ge(p,1 - v), new Ge(y,1 - E), new Ge(w,1 - T)] : [new Ge(f,1 - d), new Ge(g,1 - v), new Ge(S,1 - E), new Ge(A,1 - T)]
                    }
                };
                function vU(t, e, n) {
                    if (n.shapes = [],
                    Array.isArray(t))
                        for (let i = 0, a = t.length; i < a; i++) {
                            const o = t[i];
                            n.shapes.push(o.uuid)
                        }
                    else
                        n.shapes.push(t.uuid);
                    return n.options = Object.assign({}, e),
                    e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()),
                    n
                }
                var pE = class DR extends tp {
                    constructor(e=1, n=0) {
                        const i = (1 + Math.sqrt(5)) / 2
                          , a = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
                        super(a, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, n),
                        this.type = "IcosahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: n
                        }
                    }
                    static fromJSON(e) {
                        return new DR(e.radius,e.detail)
                    }
                }
                  , mE = class OR extends en {
                    constructor(e=[new Ge(0,-.5), new Ge(.5,0), new Ge(0,.5)], n=12, i=0, a=Math.PI * 2) {
                        super(),
                        this.type = "LatheGeometry",
                        this.parameters = {
                            points: e,
                            segments: n,
                            phiStart: i,
                            phiLength: a
                        },
                        n = Math.floor(n),
                        a = Ht(a, 0, Math.PI * 2);
                        const o = []
                          , u = []
                          , f = []
                          , d = []
                          , p = []
                          , g = 1 / n
                          , v = new J
                          , y = new Ge
                          , S = new J
                          , E = new J
                          , w = new J;
                        let A = 0
                          , T = 0;
                        for (let R = 0; R <= e.length - 1; R++)
                            switch (R) {
                            case 0:
                                A = e[R + 1].x - e[R].x,
                                T = e[R + 1].y - e[R].y,
                                S.x = T * 1,
                                S.y = -A,
                                S.z = T * 0,
                                w.copy(S),
                                S.normalize(),
                                d.push(S.x, S.y, S.z);
                                break;
                            case e.length - 1:
                                d.push(w.x, w.y, w.z);
                                break;
                            default:
                                A = e[R + 1].x - e[R].x,
                                T = e[R + 1].y - e[R].y,
                                S.x = T * 1,
                                S.y = -A,
                                S.z = T * 0,
                                E.copy(S),
                                S.x += w.x,
                                S.y += w.y,
                                S.z += w.z,
                                S.normalize(),
                                d.push(S.x, S.y, S.z),
                                w.copy(E)
                            }
                        for (let R = 0; R <= n; R++) {
                            const N = i + R * g * a
                              , D = Math.sin(N)
                              , U = Math.cos(N);
                            for (let z = 0; z <= e.length - 1; z++) {
                                v.x = e[z].x * D,
                                v.y = e[z].y,
                                v.z = e[z].x * U,
                                u.push(v.x, v.y, v.z),
                                y.x = R / n,
                                y.y = z / (e.length - 1),
                                f.push(y.x, y.y);
                                const I = d[3 * z + 0] * D
                                  , V = d[3 * z + 1]
                                  , B = d[3 * z + 0] * U;
                                p.push(I, V, B)
                            }
                        }
                        for (let R = 0; R < n; R++)
                            for (let N = 0; N < e.length - 1; N++) {
                                const D = N + R * e.length
                                  , U = D
                                  , z = D + e.length
                                  , I = D + e.length + 1
                                  , V = D + 1;
                                o.push(U, z, V),
                                o.push(I, V, z)
                            }
                        this.setIndex(o),
                        this.setAttribute("position", new _t(u,3)),
                        this.setAttribute("uv", new _t(f,2)),
                        this.setAttribute("normal", new _t(p,3))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new OR(e.points,e.segments,e.phiStart,e.phiLength)
                    }
                }
                  , NM = class UR extends tp {
                    constructor(e=1, n=0) {
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, n),
                        this.type = "OctahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: n
                        }
                    }
                    static fromJSON(e) {
                        return new UR(e.radius,e.detail)
                    }
                }
                  , Ry = class LR extends en {
                    constructor(e=1, n=1, i=1, a=1) {
                        super(),
                        this.type = "PlaneGeometry",
                        this.parameters = {
                            width: e,
                            height: n,
                            widthSegments: i,
                            heightSegments: a
                        };
                        const o = e / 2
                          , u = n / 2
                          , f = Math.floor(i)
                          , d = Math.floor(a)
                          , p = f + 1
                          , g = d + 1
                          , v = e / f
                          , y = n / d
                          , S = []
                          , E = []
                          , w = []
                          , A = [];
                        for (let T = 0; T < g; T++) {
                            const R = T * y - u;
                            for (let N = 0; N < p; N++) {
                                const D = N * v - o;
                                E.push(D, -R, 0),
                                w.push(0, 0, 1),
                                A.push(N / f),
                                A.push(1 - T / d)
                            }
                        }
                        for (let T = 0; T < d; T++)
                            for (let R = 0; R < f; R++) {
                                const N = R + p * T
                                  , D = R + p * (T + 1)
                                  , U = R + 1 + p * (T + 1)
                                  , z = R + 1 + p * T;
                                S.push(N, D, z),
                                S.push(D, U, z)
                            }
                        this.setIndex(S),
                        this.setAttribute("position", new _t(E,3)),
                        this.setAttribute("normal", new _t(w,3)),
                        this.setAttribute("uv", new _t(A,2))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new LR(e.width,e.height,e.widthSegments,e.heightSegments)
                    }
                }
                  , gE = class IR extends en {
                    constructor(e=.5, n=1, i=32, a=1, o=0, u=Math.PI * 2) {
                        super(),
                        this.type = "RingGeometry",
                        this.parameters = {
                            innerRadius: e,
                            outerRadius: n,
                            thetaSegments: i,
                            phiSegments: a,
                            thetaStart: o,
                            thetaLength: u
                        },
                        i = Math.max(3, i),
                        a = Math.max(1, a);
                        const f = []
                          , d = []
                          , p = []
                          , g = [];
                        let v = e;
                        const y = (n - e) / a
                          , S = new J
                          , E = new Ge;
                        for (let w = 0; w <= a; w++) {
                            for (let A = 0; A <= i; A++) {
                                const T = o + A / i * u;
                                S.x = v * Math.cos(T),
                                S.y = v * Math.sin(T),
                                d.push(S.x, S.y, S.z),
                                p.push(0, 0, 1),
                                E.x = (S.x / n + 1) / 2,
                                E.y = (S.y / n + 1) / 2,
                                g.push(E.x, E.y)
                            }
                            v += y
                        }
                        for (let w = 0; w < a; w++) {
                            const A = w * (i + 1);
                            for (let T = 0; T < i; T++) {
                                const R = T + A
                                  , N = R
                                  , D = R + i + 1
                                  , U = R + i + 2
                                  , z = R + 1;
                                f.push(N, D, z),
                                f.push(D, U, z)
                            }
                        }
                        this.setIndex(f),
                        this.setAttribute("position", new _t(d,3)),
                        this.setAttribute("normal", new _t(p,3)),
                        this.setAttribute("uv", new _t(g,2))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new IR(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
                    }
                }
                  , vE = class zR extends en {
                    constructor(e=new Oh([new Ge(0,.5), new Ge(-.5,-.5), new Ge(.5,-.5)]), n=12) {
                        super(),
                        this.type = "ShapeGeometry",
                        this.parameters = {
                            shapes: e,
                            curveSegments: n
                        };
                        const i = []
                          , a = []
                          , o = []
                          , u = [];
                        let f = 0
                          , d = 0;
                        if (Array.isArray(e) === !1)
                            p(e);
                        else
                            for (let g = 0; g < e.length; g++)
                                p(e[g]),
                                this.addGroup(f, d, g),
                                f += d,
                                d = 0;
                        this.setIndex(i),
                        this.setAttribute("position", new _t(a,3)),
                        this.setAttribute("normal", new _t(o,3)),
                        this.setAttribute("uv", new _t(u,2));
                        function p(g) {
                            const v = a.length / 3
                              , y = g.extractPoints(n);
                            let S = y.shape;
                            const E = y.holes;
                            lc.isClockWise(S) === !1 && (S = S.reverse());
                            for (let A = 0, T = E.length; A < T; A++) {
                                const R = E[A];
                                lc.isClockWise(R) === !0 && (E[A] = R.reverse())
                            }
                            const w = lc.triangulateShape(S, E);
                            for (let A = 0, T = E.length; A < T; A++) {
                                const R = E[A];
                                S = S.concat(R)
                            }
                            for (let A = 0, T = S.length; A < T; A++) {
                                const R = S[A];
                                a.push(R.x, R.y, 0),
                                o.push(0, 0, 1),
                                u.push(R.x, R.y)
                            }
                            for (let A = 0, T = w.length; A < T; A++) {
                                const R = w[A]
                                  , N = R[0] + v
                                  , D = R[1] + v
                                  , U = R[2] + v;
                                i.push(N, D, U),
                                d += 3
                            }
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON()
                          , n = this.parameters.shapes;
                        return _U(n, e)
                    }
                    static fromJSON(e, n) {
                        const i = [];
                        for (let a = 0, o = e.shapes.length; a < o; a++) {
                            const u = n[e.shapes[a]];
                            i.push(u)
                        }
                        return new zR(i,e.curveSegments)
                    }
                }
                ;
                function _U(t, e) {
                    if (e.shapes = [],
                    Array.isArray(t))
                        for (let n = 0, i = t.length; n < i; n++) {
                            const a = t[n];
                            e.shapes.push(a.uuid)
                        }
                    else
                        e.shapes.push(t.uuid);
                    return e
                }
                var DM = class BR extends en {
                    constructor(e=1, n=32, i=16, a=0, o=Math.PI * 2, u=0, f=Math.PI) {
                        super(),
                        this.type = "SphereGeometry",
                        this.parameters = {
                            radius: e,
                            widthSegments: n,
                            heightSegments: i,
                            phiStart: a,
                            phiLength: o,
                            thetaStart: u,
                            thetaLength: f
                        },
                        n = Math.max(3, Math.floor(n)),
                        i = Math.max(2, Math.floor(i));
                        const d = Math.min(u + f, Math.PI);
                        let p = 0;
                        const g = []
                          , v = new J
                          , y = new J
                          , S = []
                          , E = []
                          , w = []
                          , A = [];
                        for (let T = 0; T <= i; T++) {
                            const R = []
                              , N = T / i;
                            let D = 0;
                            T === 0 && u === 0 ? D = .5 / n : T === i && d === Math.PI && (D = -.5 / n);
                            for (let U = 0; U <= n; U++) {
                                const z = U / n;
                                v.x = -e * Math.cos(a + z * o) * Math.sin(u + N * f),
                                v.y = e * Math.cos(u + N * f),
                                v.z = e * Math.sin(a + z * o) * Math.sin(u + N * f),
                                E.push(v.x, v.y, v.z),
                                y.copy(v).normalize(),
                                w.push(y.x, y.y, y.z),
                                A.push(z + D, 1 - N),
                                R.push(p++)
                            }
                            g.push(R)
                        }
                        for (let T = 0; T < i; T++)
                            for (let R = 0; R < n; R++) {
                                const N = g[T][R + 1]
                                  , D = g[T][R]
                                  , U = g[T + 1][R]
                                  , z = g[T + 1][R + 1];
                                (T !== 0 || u > 0) && S.push(N, D, z),
                                (T !== i - 1 || d < Math.PI) && S.push(D, U, z)
                            }
                        this.setIndex(S),
                        this.setAttribute("position", new _t(E,3)),
                        this.setAttribute("normal", new _t(w,3)),
                        this.setAttribute("uv", new _t(A,2))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new BR(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
                    }
                }
                  , _E = class PR extends tp {
                    constructor(e=1, n=0) {
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, n),
                        this.type = "TetrahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: n
                        }
                    }
                    static fromJSON(e) {
                        return new PR(e.radius,e.detail)
                    }
                }
                  , yE = class VR extends en {
                    constructor(e=1, n=.4, i=12, a=48, o=Math.PI * 2) {
                        super(),
                        this.type = "TorusGeometry",
                        this.parameters = {
                            radius: e,
                            tube: n,
                            radialSegments: i,
                            tubularSegments: a,
                            arc: o
                        },
                        i = Math.floor(i),
                        a = Math.floor(a);
                        const u = []
                          , f = []
                          , d = []
                          , p = []
                          , g = new J
                          , v = new J
                          , y = new J;
                        for (let S = 0; S <= i; S++)
                            for (let E = 0; E <= a; E++) {
                                const w = E / a * o
                                  , A = S / i * Math.PI * 2;
                                v.x = (e + n * Math.cos(A)) * Math.cos(w),
                                v.y = (e + n * Math.cos(A)) * Math.sin(w),
                                v.z = n * Math.sin(A),
                                f.push(v.x, v.y, v.z),
                                g.x = e * Math.cos(w),
                                g.y = e * Math.sin(w),
                                y.subVectors(v, g).normalize(),
                                d.push(y.x, y.y, y.z),
                                p.push(E / a),
                                p.push(S / i)
                            }
                        for (let S = 1; S <= i; S++)
                            for (let E = 1; E <= a; E++) {
                                const w = (a + 1) * S + E - 1
                                  , A = (a + 1) * (S - 1) + E - 1
                                  , T = (a + 1) * (S - 1) + E
                                  , R = (a + 1) * S + E;
                                u.push(w, A, R),
                                u.push(A, T, R)
                            }
                        this.setIndex(u),
                        this.setAttribute("position", new _t(f,3)),
                        this.setAttribute("normal", new _t(d,3)),
                        this.setAttribute("uv", new _t(p,2))
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new VR(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
                    }
                }
                  , SE = class FR extends en {
                    constructor(e=1, n=.4, i=64, a=8, o=2, u=3) {
                        super(),
                        this.type = "TorusKnotGeometry",
                        this.parameters = {
                            radius: e,
                            tube: n,
                            tubularSegments: i,
                            radialSegments: a,
                            p: o,
                            q: u
                        },
                        i = Math.floor(i),
                        a = Math.floor(a);
                        const f = []
                          , d = []
                          , p = []
                          , g = []
                          , v = new J
                          , y = new J
                          , S = new J
                          , E = new J
                          , w = new J
                          , A = new J
                          , T = new J;
                        for (let N = 0; N <= i; ++N) {
                            const D = N / i * o * Math.PI * 2;
                            R(D, o, u, e, S),
                            R(D + .01, o, u, e, E),
                            A.subVectors(E, S),
                            T.addVectors(E, S),
                            w.crossVectors(A, T),
                            T.crossVectors(w, A),
                            w.normalize(),
                            T.normalize();
                            for (let U = 0; U <= a; ++U) {
                                const z = U / a * Math.PI * 2
                                  , I = -n * Math.cos(z)
                                  , V = n * Math.sin(z);
                                v.x = S.x + (I * T.x + V * w.x),
                                v.y = S.y + (I * T.y + V * w.y),
                                v.z = S.z + (I * T.z + V * w.z),
                                d.push(v.x, v.y, v.z),
                                y.subVectors(v, S).normalize(),
                                p.push(y.x, y.y, y.z),
                                g.push(N / i),
                                g.push(U / a)
                            }
                        }
                        for (let N = 1; N <= i; N++)
                            for (let D = 1; D <= a; D++) {
                                const U = (a + 1) * (N - 1) + (D - 1)
                                  , z = (a + 1) * N + (D - 1)
                                  , I = (a + 1) * N + D
                                  , V = (a + 1) * (N - 1) + D;
                                f.push(U, z, V),
                                f.push(z, I, V)
                            }
                        this.setIndex(f),
                        this.setAttribute("position", new _t(d,3)),
                        this.setAttribute("normal", new _t(p,3)),
                        this.setAttribute("uv", new _t(g,2));
                        function R(N, D, U, z, I) {
                            const V = Math.cos(N)
                              , B = Math.sin(N)
                              , P = U / D * N
                              , G = Math.cos(P);
                            I.x = z * (2 + G) * .5 * V,
                            I.y = z * (2 + G) * B * .5,
                            I.z = z * Math.sin(P) * .5
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    static fromJSON(e) {
                        return new FR(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
                    }
                }
                  , xE = class HR extends en {
                    constructor(e=new EM(new J(-1,-1,0),new J(-1,1,0),new J(1,1,0)), n=64, i=1, a=8, o=!1) {
                        super(),
                        this.type = "TubeGeometry",
                        this.parameters = {
                            path: e,
                            tubularSegments: n,
                            radius: i,
                            radialSegments: a,
                            closed: o
                        };
                        const u = e.computeFrenetFrames(n, o);
                        this.tangents = u.tangents,
                        this.normals = u.normals,
                        this.binormals = u.binormals;
                        const f = new J
                          , d = new J
                          , p = new Ge;
                        let g = new J;
                        const v = []
                          , y = []
                          , S = []
                          , E = [];
                        w(),
                        this.setIndex(E),
                        this.setAttribute("position", new _t(v,3)),
                        this.setAttribute("normal", new _t(y,3)),
                        this.setAttribute("uv", new _t(S,2));
                        function w() {
                            for (let N = 0; N < n; N++)
                                A(N);
                            A(o === !1 ? n : 0),
                            R(),
                            T()
                        }
                        function A(N) {
                            g = e.getPointAt(N / n, g);
                            const D = u.normals[N]
                              , U = u.binormals[N];
                            for (let z = 0; z <= a; z++) {
                                const I = z / a * Math.PI * 2
                                  , V = Math.sin(I)
                                  , B = -Math.cos(I);
                                d.x = B * D.x + V * U.x,
                                d.y = B * D.y + V * U.y,
                                d.z = B * D.z + V * U.z,
                                d.normalize(),
                                y.push(d.x, d.y, d.z),
                                f.x = g.x + i * d.x,
                                f.y = g.y + i * d.y,
                                f.z = g.z + i * d.z,
                                v.push(f.x, f.y, f.z)
                            }
                        }
                        function T() {
                            for (let N = 1; N <= n; N++)
                                for (let D = 1; D <= a; D++) {
                                    const U = (a + 1) * (N - 1) + (D - 1)
                                      , z = (a + 1) * N + (D - 1)
                                      , I = (a + 1) * N + D
                                      , V = (a + 1) * (N - 1) + D;
                                    E.push(U, z, V),
                                    E.push(z, I, V)
                                }
                        }
                        function R() {
                            for (let N = 0; N <= n; N++)
                                for (let D = 0; D <= a; D++)
                                    p.x = N / n,
                                    p.y = D / a,
                                    S.push(p.x, p.y)
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.path = this.parameters.path.toJSON(),
                        e
                    }
                    static fromJSON(e) {
                        return new HR(new Ay[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
                    }
                }
                  , ME = class extends en {
                    constructor(t=null) {
                        if (super(),
                        this.type = "WireframeGeometry",
                        this.parameters = {
                            geometry: t
                        },
                        t !== null) {
                            const e = []
                              , n = new Set
                              , i = new J
                              , a = new J;
                            if (t.index !== null) {
                                const o = t.attributes.position
                                  , u = t.index;
                                let f = t.groups;
                                f.length === 0 && (f = [{
                                    start: 0,
                                    count: u.count,
                                    materialIndex: 0
                                }]);
                                for (let d = 0, p = f.length; d < p; ++d) {
                                    const g = f[d]
                                      , v = g.start
                                      , y = g.count;
                                    for (let S = v, E = v + y; S < E; S += 3)
                                        for (let w = 0; w < 3; w++) {
                                            const A = u.getX(S + w)
                                              , T = u.getX(S + (w + 1) % 3);
                                            i.fromBufferAttribute(o, A),
                                            a.fromBufferAttribute(o, T),
                                            bE(i, a, n) === !0 && (e.push(i.x, i.y, i.z),
                                            e.push(a.x, a.y, a.z))
                                        }
                                }
                            } else {
                                const o = t.attributes.position;
                                for (let u = 0, f = o.count / 3; u < f; u++)
                                    for (let d = 0; d < 3; d++) {
                                        const p = 3 * u + d
                                          , g = 3 * u + (d + 1) % 3;
                                        i.fromBufferAttribute(o, p),
                                        a.fromBufferAttribute(o, g),
                                        bE(i, a, n) === !0 && (e.push(i.x, i.y, i.z),
                                        e.push(a.x, a.y, a.z))
                                    }
                            }
                            this.setAttribute("position", new _t(e,3))
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                }
                ;
                function bE(t, e, n) {
                    const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`
                      , a = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                    return n.has(i) === !0 || n.has(a) === !0 ? !1 : (n.add(i),
                    n.add(a),
                    !0)
                }
                var TE = Object.freeze({
                    __proto__: null,
                    BoxGeometry: Eg,
                    CapsuleGeometry: QA,
                    CircleGeometry: KA,
                    ConeGeometry: vM,
                    CylinderGeometry: gM,
                    DodecahedronGeometry: JA,
                    EdgesGeometry: $A,
                    ExtrudeGeometry: dE,
                    IcosahedronGeometry: pE,
                    LatheGeometry: mE,
                    OctahedronGeometry: NM,
                    PlaneGeometry: Ry,
                    PolyhedronGeometry: tp,
                    RingGeometry: gE,
                    ShapeGeometry: vE,
                    SphereGeometry: DM,
                    TetrahedronGeometry: _E,
                    TorusGeometry: yE,
                    TorusKnotGeometry: SE,
                    TubeGeometry: xE,
                    WireframeGeometry: ME
                })
                  , AE = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isShadowMaterial = !0,
                        this.type = "ShadowMaterial",
                        this.color = new ut(0),
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.fog = t.fog,
                        this
                    }
                }
                  , OM = class extends Br {
                    constructor(t) {
                        super(t),
                        this.isRawShaderMaterial = !0,
                        this.type = "RawShaderMaterial"
                    }
                }
                  , UM = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshStandardMaterial = !0,
                        this.type = "MeshStandardMaterial",
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color = new ut(16777215),
                        this.roughness = 1,
                        this.metalness = 0,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ut(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = eu,
                        this.normalScale = new Ge(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.roughnessMap = null,
                        this.metalnessMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new vo,
                        this.envMapIntensity = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color.copy(t.color),
                        this.roughness = t.roughness,
                        this.metalness = t.metalness,
                        this.map = t.map,
                        this.lightMap = t.lightMap,
                        this.lightMapIntensity = t.lightMapIntensity,
                        this.aoMap = t.aoMap,
                        this.aoMapIntensity = t.aoMapIntensity,
                        this.emissive.copy(t.emissive),
                        this.emissiveMap = t.emissiveMap,
                        this.emissiveIntensity = t.emissiveIntensity,
                        this.bumpMap = t.bumpMap,
                        this.bumpScale = t.bumpScale,
                        this.normalMap = t.normalMap,
                        this.normalMapType = t.normalMapType,
                        this.normalScale.copy(t.normalScale),
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.roughnessMap = t.roughnessMap,
                        this.metalnessMap = t.metalnessMap,
                        this.alphaMap = t.alphaMap,
                        this.envMap = t.envMap,
                        this.envMapRotation.copy(t.envMapRotation),
                        this.envMapIntensity = t.envMapIntensity,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.wireframeLinecap = t.wireframeLinecap,
                        this.wireframeLinejoin = t.wireframeLinejoin,
                        this.flatShading = t.flatShading,
                        this.fog = t.fog,
                        this
                    }
                }
                  , EE = class extends UM {
                    constructor(t) {
                        super(),
                        this.isMeshPhysicalMaterial = !0,
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.type = "MeshPhysicalMaterial",
                        this.anisotropyRotation = 0,
                        this.anisotropyMap = null,
                        this.clearcoatMap = null,
                        this.clearcoatRoughness = 0,
                        this.clearcoatRoughnessMap = null,
                        this.clearcoatNormalScale = new Ge(1,1),
                        this.clearcoatNormalMap = null,
                        this.ior = 1.5,
                        Object.defineProperty(this, "reflectivity", {
                            get: function() {
                                return Ht(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function(e) {
                                this.ior = (1 + .4 * e) / (1 - .4 * e)
                            }
                        }),
                        this.iridescenceMap = null,
                        this.iridescenceIOR = 1.3,
                        this.iridescenceThicknessRange = [100, 400],
                        this.iridescenceThicknessMap = null,
                        this.sheenColor = new ut(0),
                        this.sheenColorMap = null,
                        this.sheenRoughness = 1,
                        this.sheenRoughnessMap = null,
                        this.transmissionMap = null,
                        this.thickness = 0,
                        this.thicknessMap = null,
                        this.attenuationDistance = 1 / 0,
                        this.attenuationColor = new ut(1,1,1),
                        this.specularIntensity = 1,
                        this.specularIntensityMap = null,
                        this.specularColor = new ut(1,1,1),
                        this.specularColorMap = null,
                        this._anisotropy = 0,
                        this._clearcoat = 0,
                        this._dispersion = 0,
                        this._iridescence = 0,
                        this._sheen = 0,
                        this._transmission = 0,
                        this.setValues(t)
                    }
                    get anisotropy() {
                        return this._anisotropy
                    }
                    set anisotropy(t) {
                        this._anisotropy > 0 != t > 0 && this.version++,
                        this._anisotropy = t
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(t) {
                        this._clearcoat > 0 != t > 0 && this.version++,
                        this._clearcoat = t
                    }
                    get iridescence() {
                        return this._iridescence
                    }
                    set iridescence(t) {
                        this._iridescence > 0 != t > 0 && this.version++,
                        this._iridescence = t
                    }
                    get dispersion() {
                        return this._dispersion
                    }
                    set dispersion(t) {
                        this._dispersion > 0 != t > 0 && this.version++,
                        this._dispersion = t
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(t) {
                        this._sheen > 0 != t > 0 && this.version++,
                        this._sheen = t
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(t) {
                        this._transmission > 0 != t > 0 && this.version++,
                        this._transmission = t
                    }
                    copy(t) {
                        return super.copy(t),
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.anisotropy = t.anisotropy,
                        this.anisotropyRotation = t.anisotropyRotation,
                        this.anisotropyMap = t.anisotropyMap,
                        this.clearcoat = t.clearcoat,
                        this.clearcoatMap = t.clearcoatMap,
                        this.clearcoatRoughness = t.clearcoatRoughness,
                        this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
                        this.clearcoatNormalMap = t.clearcoatNormalMap,
                        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                        this.dispersion = t.dispersion,
                        this.ior = t.ior,
                        this.iridescence = t.iridescence,
                        this.iridescenceMap = t.iridescenceMap,
                        this.iridescenceIOR = t.iridescenceIOR,
                        this.iridescenceThicknessRange = [...t.iridescenceThicknessRange],
                        this.iridescenceThicknessMap = t.iridescenceThicknessMap,
                        this.sheen = t.sheen,
                        this.sheenColor.copy(t.sheenColor),
                        this.sheenColorMap = t.sheenColorMap,
                        this.sheenRoughness = t.sheenRoughness,
                        this.sheenRoughnessMap = t.sheenRoughnessMap,
                        this.transmission = t.transmission,
                        this.transmissionMap = t.transmissionMap,
                        this.thickness = t.thickness,
                        this.thicknessMap = t.thicknessMap,
                        this.attenuationDistance = t.attenuationDistance,
                        this.attenuationColor.copy(t.attenuationColor),
                        this.specularIntensity = t.specularIntensity,
                        this.specularIntensityMap = t.specularIntensityMap,
                        this.specularColor.copy(t.specularColor),
                        this.specularColorMap = t.specularColorMap,
                        this
                    }
                }
                  , CE = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshPhongMaterial = !0,
                        this.type = "MeshPhongMaterial",
                        this.color = new ut(16777215),
                        this.specular = new ut(1118481),
                        this.shininess = 30,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ut(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = eu,
                        this.normalScale = new Ge(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new vo,
                        this.combine = ig,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.specular.copy(t.specular),
                        this.shininess = t.shininess,
                        this.map = t.map,
                        this.lightMap = t.lightMap,
                        this.lightMapIntensity = t.lightMapIntensity,
                        this.aoMap = t.aoMap,
                        this.aoMapIntensity = t.aoMapIntensity,
                        this.emissive.copy(t.emissive),
                        this.emissiveMap = t.emissiveMap,
                        this.emissiveIntensity = t.emissiveIntensity,
                        this.bumpMap = t.bumpMap,
                        this.bumpScale = t.bumpScale,
                        this.normalMap = t.normalMap,
                        this.normalMapType = t.normalMapType,
                        this.normalScale.copy(t.normalScale),
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.specularMap = t.specularMap,
                        this.alphaMap = t.alphaMap,
                        this.envMap = t.envMap,
                        this.envMapRotation.copy(t.envMapRotation),
                        this.combine = t.combine,
                        this.reflectivity = t.reflectivity,
                        this.refractionRatio = t.refractionRatio,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.wireframeLinecap = t.wireframeLinecap,
                        this.wireframeLinejoin = t.wireframeLinejoin,
                        this.flatShading = t.flatShading,
                        this.fog = t.fog,
                        this
                    }
                }
                  , wE = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshToonMaterial = !0,
                        this.defines = {
                            TOON: ""
                        },
                        this.type = "MeshToonMaterial",
                        this.color = new ut(16777215),
                        this.map = null,
                        this.gradientMap = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ut(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = eu,
                        this.normalScale = new Ge(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.map = t.map,
                        this.gradientMap = t.gradientMap,
                        this.lightMap = t.lightMap,
                        this.lightMapIntensity = t.lightMapIntensity,
                        this.aoMap = t.aoMap,
                        this.aoMapIntensity = t.aoMapIntensity,
                        this.emissive.copy(t.emissive),
                        this.emissiveMap = t.emissiveMap,
                        this.emissiveIntensity = t.emissiveIntensity,
                        this.bumpMap = t.bumpMap,
                        this.bumpScale = t.bumpScale,
                        this.normalMap = t.normalMap,
                        this.normalMapType = t.normalMapType,
                        this.normalScale.copy(t.normalScale),
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.alphaMap = t.alphaMap,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.wireframeLinecap = t.wireframeLinecap,
                        this.wireframeLinejoin = t.wireframeLinejoin,
                        this.fog = t.fog,
                        this
                    }
                }
                  , RE = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshNormalMaterial = !0,
                        this.type = "MeshNormalMaterial",
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = eu,
                        this.normalScale = new Ge(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.flatShading = !1,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.bumpMap = t.bumpMap,
                        this.bumpScale = t.bumpScale,
                        this.normalMap = t.normalMap,
                        this.normalMapType = t.normalMapType,
                        this.normalScale.copy(t.normalScale),
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.flatShading = t.flatShading,
                        this
                    }
                }
                  , NE = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshLambertMaterial = !0,
                        this.type = "MeshLambertMaterial",
                        this.color = new ut(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new ut(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = eu,
                        this.normalScale = new Ge(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new vo,
                        this.combine = ig,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.color.copy(t.color),
                        this.map = t.map,
                        this.lightMap = t.lightMap,
                        this.lightMapIntensity = t.lightMapIntensity,
                        this.aoMap = t.aoMap,
                        this.aoMapIntensity = t.aoMapIntensity,
                        this.emissive.copy(t.emissive),
                        this.emissiveMap = t.emissiveMap,
                        this.emissiveIntensity = t.emissiveIntensity,
                        this.bumpMap = t.bumpMap,
                        this.bumpScale = t.bumpScale,
                        this.normalMap = t.normalMap,
                        this.normalMapType = t.normalMapType,
                        this.normalScale.copy(t.normalScale),
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.specularMap = t.specularMap,
                        this.alphaMap = t.alphaMap,
                        this.envMap = t.envMap,
                        this.envMapRotation.copy(t.envMapRotation),
                        this.combine = t.combine,
                        this.reflectivity = t.reflectivity,
                        this.refractionRatio = t.refractionRatio,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.wireframeLinecap = t.wireframeLinecap,
                        this.wireframeLinejoin = t.wireframeLinejoin,
                        this.flatShading = t.flatShading,
                        this.fog = t.fog,
                        this
                    }
                }
                  , LM = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshDepthMaterial = !0,
                        this.type = "MeshDepthMaterial",
                        this.depthPacking = B1,
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.depthPacking = t.depthPacking,
                        this.map = t.map,
                        this.alphaMap = t.alphaMap,
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this
                    }
                }
                  , IM = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshDistanceMaterial = !0,
                        this.type = "MeshDistanceMaterial",
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.map = t.map,
                        this.alphaMap = t.alphaMap,
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this
                    }
                }
                  , DE = class extends Ws {
                    constructor(t) {
                        super(),
                        this.isMeshMatcapMaterial = !0,
                        this.defines = {
                            MATCAP: ""
                        },
                        this.type = "MeshMatcapMaterial",
                        this.color = new ut(16777215),
                        this.matcap = null,
                        this.map = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = eu,
                        this.normalScale = new Ge(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.defines = {
                            MATCAP: ""
                        },
                        this.color.copy(t.color),
                        this.matcap = t.matcap,
                        this.map = t.map,
                        this.bumpMap = t.bumpMap,
                        this.bumpScale = t.bumpScale,
                        this.normalMap = t.normalMap,
                        this.normalMapType = t.normalMapType,
                        this.normalScale.copy(t.normalScale),
                        this.displacementMap = t.displacementMap,
                        this.displacementScale = t.displacementScale,
                        this.displacementBias = t.displacementBias,
                        this.alphaMap = t.alphaMap,
                        this.wireframe = t.wireframe,
                        this.wireframeLinewidth = t.wireframeLinewidth,
                        this.flatShading = t.flatShading,
                        this.fog = t.fog,
                        this
                    }
                }
                  , OE = class extends _a {
                    constructor(t) {
                        super(),
                        this.isLineDashedMaterial = !0,
                        this.type = "LineDashedMaterial",
                        this.scale = 1,
                        this.dashSize = 3,
                        this.gapSize = 1,
                        this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.scale = t.scale,
                        this.dashSize = t.dashSize,
                        this.gapSize = t.gapSize,
                        this
                    }
                }
                ;
                function Lh(t, e) {
                    return !t || t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t)
                }
                function UE(t) {
                    function e(a, o) {
                        return t[a] - t[o]
                    }
                    const n = t.length
                      , i = new Array(n);
                    for (let a = 0; a !== n; ++a)
                        i[a] = a;
                    return i.sort(e),
                    i
                }
                function zM(t, e, n) {
                    const i = t.length
                      , a = new t.constructor(i);
                    for (let o = 0, u = 0; u !== i; ++o) {
                        const f = n[o] * e;
                        for (let d = 0; d !== e; ++d)
                            a[u++] = t[f + d]
                    }
                    return a
                }
                function BM(t, e, n, i) {
                    let a = 1
                      , o = t[0];
                    for (; o !== void 0 && o[i] === void 0; )
                        o = t[a++];
                    if (o === void 0)
                        return;
                    let u = o[i];
                    if (u !== void 0)
                        if (Array.isArray(u))
                            do
                                u = o[i],
                                u !== void 0 && (e.push(o.time),
                                n.push(...u)),
                                o = t[a++];
                            while (o !== void 0);
                        else if (u.toArray !== void 0)
                            do
                                u = o[i],
                                u !== void 0 && (e.push(o.time),
                                u.toArray(n, n.length)),
                                o = t[a++];
                            while (o !== void 0);
                        else
                            do
                                u = o[i],
                                u !== void 0 && (e.push(o.time),
                                n.push(u)),
                                o = t[a++];
                            while (o !== void 0)
                }
                function yU(t, e, n, i, a=30) {
                    const o = t.clone();
                    o.name = e;
                    const u = [];
                    for (let d = 0; d < o.tracks.length; ++d) {
                        const p = o.tracks[d]
                          , g = p.getValueSize()
                          , v = []
                          , y = [];
                        for (let S = 0; S < p.times.length; ++S) {
                            const E = p.times[S] * a;
                            if (!(E < n || E >= i)) {
                                v.push(p.times[S]);
                                for (let w = 0; w < g; ++w)
                                    y.push(p.values[S * g + w])
                            }
                        }
                        v.length !== 0 && (p.times = Lh(v, p.times.constructor),
                        p.values = Lh(y, p.values.constructor),
                        u.push(p))
                    }
                    o.tracks = u;
                    let f = 1 / 0;
                    for (let d = 0; d < o.tracks.length; ++d)
                        f > o.tracks[d].times[0] && (f = o.tracks[d].times[0]);
                    for (let d = 0; d < o.tracks.length; ++d)
                        o.tracks[d].shift(-1 * f);
                    return o.resetDuration(),
                    o
                }
                function SU(t, e=0, n=t, i=30) {
                    i <= 0 && (i = 30);
                    const a = n.tracks.length
                      , o = e / i;
                    for (let u = 0; u < a; ++u) {
                        const f = n.tracks[u]
                          , d = f.ValueTypeName;
                        if (d === "bool" || d === "string")
                            continue;
                        const p = t.tracks.find(function(T) {
                            return T.name === f.name && T.ValueTypeName === d
                        });
                        if (p === void 0)
                            continue;
                        let g = 0;
                        const v = f.getValueSize();
                        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (g = v / 3);
                        let y = 0;
                        const S = p.getValueSize();
                        p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (y = S / 3);
                        const E = f.times.length - 1;
                        let w;
                        if (o <= f.times[0]) {
                            const T = g
                              , R = v - g;
                            w = f.values.slice(T, R)
                        } else if (o >= f.times[E]) {
                            const T = E * v + g
                              , R = T + v - g;
                            w = f.values.slice(T, R)
                        } else {
                            const T = f.createInterpolant()
                              , R = g
                              , N = v - g;
                            T.evaluate(o),
                            w = T.resultBuffer.slice(R, N)
                        }
                        d === "quaternion" && new za().fromArray(w).normalize().conjugate().toArray(w);
                        const A = p.times.length;
                        for (let T = 0; T < A; ++T) {
                            const R = T * S + y;
                            if (d === "quaternion")
                                za.multiplyQuaternionsFlat(p.values, R, w, 0, p.values, R);
                            else {
                                const N = S - y * 2;
                                for (let D = 0; D < N; ++D)
                                    p.values[R + D] -= w[D]
                            }
                        }
                    }
                    return t.blendMode = Rx,
                    t
                }
                var xU = class {
                    static convertArray(t, e) {
                        return Lh(t, e)
                    }
                    static isTypedArray(t) {
                        return W1(t)
                    }
                    static getKeyframeOrder(t) {
                        return UE(t)
                    }
                    static sortedArray(t, e, n) {
                        return zM(t, e, n)
                    }
                    static flattenJSON(t, e, n, i) {
                        BM(t, e, n, i)
                    }
                    static subclip(t, e, n, i, a=30) {
                        return yU(t, e, n, i, a)
                    }
                    static makeClipAdditive(t, e=0, n=t, i=30) {
                        return SU(t, e, n, i)
                    }
                }
                  , Gg = class {
                    constructor(t, e, n, i) {
                        this.parameterPositions = t,
                        this._cachedIndex = 0,
                        this.resultBuffer = i !== void 0 ? i : new e.constructor(n),
                        this.sampleValues = e,
                        this.valueSize = n,
                        this.settings = null,
                        this.DefaultSettings_ = {}
                    }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex
                          , i = e[n]
                          , a = e[n - 1];
                        e: {
                            t: {
                                let o;
                                n: {
                                    i: if (!(t < i)) {
                                        for (let u = n + 2; ; ) {
                                            if (i === void 0) {
                                                if (t < a)
                                                    break i;
                                                return n = e.length,
                                                this._cachedIndex = n,
                                                this.copySampleValue_(n - 1)
                                            }
                                            if (n === u)
                                                break;
                                            if (a = i,
                                            i = e[++n],
                                            t < i)
                                                break t
                                        }
                                        o = e.length;
                                        break n
                                    }
                                    if (!(t >= a)) {
                                        const u = e[1];
                                        t < u && (n = 2,
                                        a = u);
                                        for (let f = n - 2; ; ) {
                                            if (a === void 0)
                                                return this._cachedIndex = 0,
                                                this.copySampleValue_(0);
                                            if (n === f)
                                                break;
                                            if (i = a,
                                            a = e[--n - 1],
                                            t >= a)
                                                break t
                                        }
                                        o = n,
                                        n = 0;
                                        break n
                                    }
                                    break e
                                }
                                for (; n < o; ) {
                                    const u = n + o >>> 1;
                                    t < e[u] ? o = u : n = u + 1
                                }
                                if (i = e[n],
                                a = e[n - 1],
                                a === void 0)
                                    return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                if (i === void 0)
                                    return n = e.length,
                                    this._cachedIndex = n,
                                    this.copySampleValue_(n - 1)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, a, i)
                        }
                        return this.interpolate_(n, a, t, i)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer
                          , n = this.sampleValues
                          , i = this.valueSize
                          , a = t * i;
                        for (let o = 0; o !== i; ++o)
                            e[o] = n[a + o];
                        return e
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                  , LE = class extends Gg {
                    constructor(t, e, n, i) {
                        super(t, e, n, i),
                        this._weightPrev = -0,
                        this._offsetPrev = -0,
                        this._weightNext = -0,
                        this._offsetNext = -0,
                        this.DefaultSettings_ = {
                            endingStart: Mh,
                            endingEnd: Mh
                        }
                    }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let a = t - 2
                          , o = t + 1
                          , u = i[a]
                          , f = i[o];
                        if (u === void 0)
                            switch (this.getSettings_().endingStart) {
                            case bh:
                                a = t,
                                u = 2 * e - n;
                                break;
                            case mg:
                                a = i.length - 2,
                                u = e + i[a] - i[a + 1];
                                break;
                            default:
                                a = t,
                                u = n
                            }
                        if (f === void 0)
                            switch (this.getSettings_().endingEnd) {
                            case bh:
                                o = t,
                                f = 2 * n - e;
                                break;
                            case mg:
                                o = 1,
                                f = n + i[1] - i[0];
                                break;
                            default:
                                o = t - 1,
                                f = e
                            }
                        const d = (n - e) * .5
                          , p = this.valueSize;
                        this._weightPrev = d / (e - u),
                        this._weightNext = d / (f - n),
                        this._offsetPrev = a * p,
                        this._offsetNext = o * p
                    }
                    interpolate_(t, e, n, i) {
                        const a = this.resultBuffer
                          , o = this.sampleValues
                          , u = this.valueSize
                          , f = t * u
                          , d = f - u
                          , p = this._offsetPrev
                          , g = this._offsetNext
                          , v = this._weightPrev
                          , y = this._weightNext
                          , S = (n - e) / (i - e)
                          , E = S * S
                          , w = E * S
                          , A = -v * w + 2 * v * E - v * S
                          , T = (1 + v) * w + (-1.5 - 2 * v) * E + (-.5 + v) * S + 1
                          , R = (-1 - y) * w + (1.5 + y) * E + .5 * S
                          , N = y * w - y * E;
                        for (let D = 0; D !== u; ++D)
                            a[D] = A * o[p + D] + T * o[d + D] + R * o[f + D] + N * o[g + D];
                        return a
                    }
                }
                  , PM = class extends Gg {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    interpolate_(t, e, n, i) {
                        const a = this.resultBuffer
                          , o = this.sampleValues
                          , u = this.valueSize
                          , f = t * u
                          , d = f - u
                          , p = (n - e) / (i - e)
                          , g = 1 - p;
                        for (let v = 0; v !== u; ++v)
                            a[v] = o[d + v] * g + o[f + v] * p;
                        return a
                    }
                }
                  , IE = class extends Gg {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    interpolate_(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }
                  , Pr = class {
                    constructor(t, e, n, i) {
                        if (t === void 0)
                            throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (e === void 0 || e.length === 0)
                            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t,
                        this.times = Lh(e, this.TimeBufferType),
                        this.values = Lh(n, this.ValueBufferType),
                        this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON)
                            n = e.toJSON(t);
                        else {
                            n = {
                                name: t.name,
                                times: Lh(t.times, Array),
                                values: Lh(t.values, Array)
                            };
                            const i = t.getInterpolation();
                            i !== t.DefaultInterpolation && (n.interpolation = i)
                        }
                        return n.type = t.ValueTypeName,
                        n
                    }
                    InterpolantFactoryMethodDiscrete(t) {
                        return new IE(this.times,this.values,this.getValueSize(),t)
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new PM(this.times,this.values,this.getValueSize(),t)
                    }
                    InterpolantFactoryMethodSmooth(t) {
                        return new LE(this.times,this.values,this.getValueSize(),t)
                    }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                        case pg:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case O0:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case U0:
                            e = this.InterpolantFactoryMethodSmooth;
                            break
                        }
                        if (e === void 0) {
                            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (this.createInterpolant === void 0)
                                if (t !== this.DefaultInterpolation)
                                    this.setInterpolation(this.DefaultInterpolation);
                                else
                                    throw new Error(n);
                            return at("KeyframeTrack:", n),
                            this
                        }
                        return this.createInterpolant = e,
                        this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return pg;
                        case this.InterpolantFactoryMethodLinear:
                            return O0;
                        case this.InterpolantFactoryMethodSmooth:
                            return U0
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(t) {
                        if (t !== 0) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n)
                                e[n] += t
                        }
                        return this
                    }
                    scale(t) {
                        if (t !== 1) {
                            const e = this.times;
                            for (let n = 0, i = e.length; n !== i; ++n)
                                e[n] *= t
                        }
                        return this
                    }
                    trim(t, e) {
                        const n = this.times
                          , i = n.length;
                        let a = 0
                          , o = i - 1;
                        for (; a !== i && n[a] < t; )
                            ++a;
                        for (; o !== -1 && n[o] > e; )
                            --o;
                        if (++o,
                        a !== 0 || o !== i) {
                            a >= o && (o = Math.max(o, 1),
                            a = o - 1);
                            const u = this.getValueSize();
                            this.times = n.slice(a, o),
                            this.values = this.values.slice(a * u, o * u)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) !== 0 && (Rt("KeyframeTrack: Invalid value size in track.", this),
                        t = !1);
                        const n = this.times
                          , i = this.values
                          , a = n.length;
                        a === 0 && (Rt("KeyframeTrack: Track is empty.", this),
                        t = !1);
                        let o = null;
                        for (let u = 0; u !== a; u++) {
                            const f = n[u];
                            if (typeof f == "number" && isNaN(f)) {
                                Rt("KeyframeTrack: Time is not a valid number.", this, u, f),
                                t = !1;
                                break
                            }
                            if (o !== null && o > f) {
                                Rt("KeyframeTrack: Out of order keys.", this, u, f, o),
                                t = !1;
                                break
                            }
                            o = f
                        }
                        if (i !== void 0 && W1(i))
                            for (let u = 0, f = i.length; u !== f; ++u) {
                                const d = i[u];
                                if (isNaN(d)) {
                                    Rt("KeyframeTrack: Value is not a valid number.", this, u, d),
                                    t = !1;
                                    break
                                }
                            }
                        return t
                    }
                    optimize() {
                        const t = this.times.slice()
                          , e = this.values.slice()
                          , n = this.getValueSize()
                          , i = this.getInterpolation() === U0
                          , a = t.length - 1;
                        let o = 1;
                        for (let u = 1; u < a; ++u) {
                            let f = !1;
                            const d = t[u];
                            if (d !== t[u + 1] && (u !== 1 || d !== t[0]))
                                if (i)
                                    f = !0;
                                else {
                                    const p = u * n
                                      , g = p - n
                                      , v = p + n;
                                    for (let y = 0; y !== n; ++y) {
                                        const S = e[p + y];
                                        if (S !== e[g + y] || S !== e[v + y]) {
                                            f = !0;
                                            break
                                        }
                                    }
                                }
                            if (f) {
                                if (u !== o) {
                                    t[o] = t[u];
                                    const p = u * n
                                      , g = o * n;
                                    for (let v = 0; v !== n; ++v)
                                        e[g + v] = e[p + v]
                                }
                                ++o
                            }
                        }
                        if (a > 0) {
                            t[o] = t[a];
                            for (let u = a * n, f = o * n, d = 0; d !== n; ++d)
                                e[f + d] = e[u + d];
                            ++o
                        }
                        return o !== t.length ? (this.times = t.slice(0, o),
                        this.values = e.slice(0, o * n)) : (this.times = t,
                        this.values = e),
                        this
                    }
                    clone() {
                        const t = this.times.slice()
                          , e = this.values.slice()
                          , n = this.constructor
                          , i = new n(this.name,t,e);
                        return i.createInterpolant = this.createInterpolant,
                        i
                    }
                }
                ;
                Pr.prototype.ValueTypeName = "",
                Pr.prototype.TimeBufferType = Float32Array,
                Pr.prototype.ValueBufferType = Float32Array,
                Pr.prototype.DefaultInterpolation = O0;
                var Ih = class extends Pr {
                    constructor(t, e, n) {
                        super(t, e, n)
                    }
                }
                ;
                Ih.prototype.ValueTypeName = "bool",
                Ih.prototype.ValueBufferType = Array,
                Ih.prototype.DefaultInterpolation = pg,
                Ih.prototype.InterpolantFactoryMethodLinear = void 0,
                Ih.prototype.InterpolantFactoryMethodSmooth = void 0;
                var VM = class extends Pr {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                }
                ;
                VM.prototype.ValueTypeName = "color";
                var kg = class extends Pr {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                }
                ;
                kg.prototype.ValueTypeName = "number";
                var zE = class extends Gg {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    interpolate_(t, e, n, i) {
                        const a = this.resultBuffer
                          , o = this.sampleValues
                          , u = this.valueSize
                          , f = (n - e) / (i - e);
                        let d = t * u;
                        for (let p = d + u; d !== p; d += 4)
                            za.slerpFlat(a, 0, o, d - u, o, d, f);
                        return a
                    }
                }
                  , qg = class extends Pr {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new zE(this.times,this.values,this.getValueSize(),t)
                    }
                }
                ;
                qg.prototype.ValueTypeName = "quaternion",
                qg.prototype.InterpolantFactoryMethodSmooth = void 0;
                var zh = class extends Pr {
                    constructor(t, e, n) {
                        super(t, e, n)
                    }
                }
                ;
                zh.prototype.ValueTypeName = "string",
                zh.prototype.ValueBufferType = Array,
                zh.prototype.DefaultInterpolation = pg,
                zh.prototype.InterpolantFactoryMethodLinear = void 0,
                zh.prototype.InterpolantFactoryMethodSmooth = void 0;
                var Xg = class extends Pr {
                    constructor(t, e, n, i) {
                        super(t, e, n, i)
                    }
                }
                ;
                Xg.prototype.ValueTypeName = "vector";
                var Wg = class {
                    constructor(t="", e=-1, n=[], i=L0) {
                        this.name = t,
                        this.tracks = n,
                        this.duration = e,
                        this.blendMode = i,
                        this.uuid = ir(),
                        this.userData = {},
                        this.duration < 0 && this.resetDuration()
                    }
                    static parse(t) {
                        const e = []
                          , n = t.tracks
                          , i = 1 / (t.fps || 1);
                        for (let o = 0, u = n.length; o !== u; ++o)
                            e.push(bU(n[o]).scale(i));
                        const a = new this(t.name,t.duration,e,t.blendMode);
                        return a.uuid = t.uuid,
                        a.userData = JSON.parse(t.userData || "{}"),
                        a
                    }
                    static toJSON(t) {
                        const e = []
                          , n = t.tracks
                          , i = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode,
                            userData: JSON.stringify(t.userData)
                        };
                        for (let a = 0, o = n.length; a !== o; ++a)
                            e.push(Pr.toJSON(n[a]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(t, e, n, i) {
                        const a = e.length
                          , o = [];
                        for (let u = 0; u < a; u++) {
                            let f = []
                              , d = [];
                            f.push((u + a - 1) % a, u, (u + 1) % a),
                            d.push(0, 1, 0);
                            const p = UE(f);
                            f = zM(f, 1, p),
                            d = zM(d, 1, p),
                            !i && f[0] === 0 && (f.push(a),
                            d.push(d[0])),
                            o.push(new kg(".morphTargetInfluences[" + e[u].name + "]",f,d).scale(1 / n))
                        }
                        return new this(t,-1,o)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const i = t;
                            n = i.geometry && i.geometry.animations || i.animations
                        }
                        for (let i = 0; i < n.length; i++)
                            if (n[i].name === e)
                                return n[i];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const i = {}
                          , a = /^([\w-]*?)([\d]+)$/;
                        for (let u = 0, f = t.length; u < f; u++) {
                            const d = t[u]
                              , p = d.name.match(a);
                            if (p && p.length > 1) {
                                const g = p[1];
                                let v = i[g];
                                v || (i[g] = v = []),
                                v.push(d)
                            }
                        }
                        const o = [];
                        for (const u in i)
                            o.push(this.CreateFromMorphTargetSequence(u, i[u], e, n));
                        return o
                    }
                    static parseAnimation(t, e) {
                        if (at("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
                        !t)
                            return Rt("AnimationClip: No animation in JSONLoader data."),
                            null;
                        const n = function(p, g, v, y, S) {
                            if (v.length !== 0) {
                                const E = []
                                  , w = [];
                                BM(v, E, w, y),
                                E.length !== 0 && S.push(new p(g,E,w))
                            }
                        }
                          , i = []
                          , a = t.name || "default"
                          , o = t.fps || 30
                          , u = t.blendMode;
                        let f = t.length || -1;
                        const d = t.hierarchy || [];
                        for (let p = 0; p < d.length; p++) {
                            const g = d[p].keys;
                            if (!(!g || g.length === 0))
                                if (g[0].morphTargets) {
                                    const v = {};
                                    let y;
                                    for (y = 0; y < g.length; y++)
                                        if (g[y].morphTargets)
                                            for (let S = 0; S < g[y].morphTargets.length; S++)
                                                v[g[y].morphTargets[S]] = -1;
                                    for (const S in v) {
                                        const E = []
                                          , w = [];
                                        for (let A = 0; A !== g[y].morphTargets.length; ++A) {
                                            const T = g[y];
                                            E.push(T.time),
                                            w.push(T.morphTarget === S ? 1 : 0)
                                        }
                                        i.push(new kg(".morphTargetInfluence[" + S + "]",E,w))
                                    }
                                    f = v.length * o
                                } else {
                                    const v = ".bones[" + e[p].name + "]";
                                    n(Xg, v + ".position", g, "pos", i),
                                    n(qg, v + ".quaternion", g, "rot", i),
                                    n(Xg, v + ".scale", g, "scl", i)
                                }
                        }
                        return i.length === 0 ? null : new this(a,f,i,u)
                    }
                    resetDuration() {
                        const t = this.tracks;
                        let e = 0;
                        for (let n = 0, i = t.length; n !== i; ++n) {
                            const a = this.tracks[n];
                            e = Math.max(e, a.times[a.times.length - 1])
                        }
                        return this.duration = e,
                        this
                    }
                    trim() {
                        for (let t = 0; t < this.tracks.length; t++)
                            this.tracks[t].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let t = !0;
                        for (let e = 0; e < this.tracks.length; e++)
                            t = t && this.tracks[e].validate();
                        return t
                    }
                    optimize() {
                        for (let t = 0; t < this.tracks.length; t++)
                            this.tracks[t].optimize();
                        return this
                    }
                    clone() {
                        const t = [];
                        for (let n = 0; n < this.tracks.length; n++)
                            t.push(this.tracks[n].clone());
                        const e = new this.constructor(this.name,this.duration,t,this.blendMode);
                        return e.userData = JSON.parse(JSON.stringify(this.userData)),
                        e
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }
                ;
                function MU(t) {
                    switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return kg;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Xg;
                    case "color":
                        return VM;
                    case "quaternion":
                        return qg;
                    case "bool":
                    case "boolean":
                        return Ih;
                    case "string":
                        return zh
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }
                function bU(t) {
                    if (t.type === void 0)
                        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = MU(t.type);
                    if (t.times === void 0) {
                        const n = []
                          , i = [];
                        BM(t.keys, n, i, "value"),
                        t.times = n,
                        t.values = i
                    }
                    return e.parse !== void 0 ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
                }
                const dl = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        this.enabled !== !1 && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (this.enabled !== !1)
                            return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                var FM = class {
                    constructor(t, e, n) {
                        const i = this;
                        let a = !1, o = 0, u = 0, f;
                        const d = [];
                        this.onStart = void 0,
                        this.onLoad = t,
                        this.onProgress = e,
                        this.onError = n,
                        this._abortController = null,
                        this.itemStart = function(p) {
                            u++,
                            a === !1 && i.onStart !== void 0 && i.onStart(p, o, u),
                            a = !0
                        }
                        ,
                        this.itemEnd = function(p) {
                            o++,
                            i.onProgress !== void 0 && i.onProgress(p, o, u),
                            o === u && (a = !1,
                            i.onLoad !== void 0 && i.onLoad())
                        }
                        ,
                        this.itemError = function(p) {
                            i.onError !== void 0 && i.onError(p)
                        }
                        ,
                        this.resolveURL = function(p) {
                            return f ? f(p) : p
                        }
                        ,
                        this.setURLModifier = function(p) {
                            return f = p,
                            this
                        }
                        ,
                        this.addHandler = function(p, g) {
                            return d.push(p, g),
                            this
                        }
                        ,
                        this.removeHandler = function(p) {
                            const g = d.indexOf(p);
                            return g !== -1 && d.splice(g, 2),
                            this
                        }
                        ,
                        this.getHandler = function(p) {
                            for (let g = 0, v = d.length; g < v; g += 2) {
                                const y = d[g]
                                  , S = d[g + 1];
                                if (y.global && (y.lastIndex = 0),
                                y.test(p))
                                    return S
                            }
                            return null
                        }
                        ,
                        this.abort = function() {
                            return this.abortController.abort(),
                            this._abortController = null,
                            this
                        }
                    }
                    get abortController() {
                        return this._abortController || (this._abortController = new AbortController),
                        this._abortController
                    }
                }
                ;
                const BE = new FM;
                var Va = class {
                    constructor(t) {
                        this.manager = t !== void 0 ? t : BE,
                        this.crossOrigin = "anonymous",
                        this.withCredentials = !1,
                        this.path = "",
                        this.resourcePath = "",
                        this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(t, e) {
                        const n = this;
                        return new Promise(function(i, a) {
                            n.load(t, i, e, a)
                        }
                        )
                    }
                    parse() {}
                    setCrossOrigin(t) {
                        return this.crossOrigin = t,
                        this
                    }
                    setWithCredentials(t) {
                        return this.withCredentials = t,
                        this
                    }
                    setPath(t) {
                        return this.path = t,
                        this
                    }
                    setResourcePath(t) {
                        return this.resourcePath = t,
                        this
                    }
                    setRequestHeader(t) {
                        return this.requestHeader = t,
                        this
                    }
                    abort() {
                        return this
                    }
                }
                ;
                Va.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                const cc = {};
                var TU = class extends Error {
                    constructor(t, e) {
                        super(t),
                        this.response = e
                    }
                }
                  , uc = class extends Va {
                    constructor(t) {
                        super(t),
                        this.mimeType = "",
                        this.responseType = "",
                        this._abortController = new AbortController
                    }
                    load(t, e, n, i) {
                        t === void 0 && (t = ""),
                        this.path !== void 0 && (t = this.path + t),
                        t = this.manager.resolveURL(t);
                        const a = dl.get(`file:${t}`);
                        if (a !== void 0)
                            return this.manager.itemStart(t),
                            setTimeout( () => {
                                e && e(a),
                                this.manager.itemEnd(t)
                            }
                            , 0),
                            a;
                        if (cc[t] !== void 0) {
                            cc[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: i
                            });
                            return
                        }
                        cc[t] = [],
                        cc[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: i
                        });
                        const o = new Request(t,{
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin",
                            signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
                        })
                          , u = this.mimeType
                          , f = this.responseType;
                        fetch(o).then(d => {
                            if (d.status === 200 || d.status === 0) {
                                if (d.status === 0 && at("FileLoader: HTTP Status 0 received."),
                                typeof ReadableStream > "u" || d.body === void 0 || d.body.getReader === void 0)
                                    return d;
                                const p = cc[t]
                                  , g = d.body.getReader()
                                  , v = d.headers.get("X-File-Size") || d.headers.get("Content-Length")
                                  , y = v ? parseInt(v) : 0
                                  , S = y !== 0;
                                let E = 0;
                                const w = new ReadableStream({
                                    start(A) {
                                        T();
                                        function T() {
                                            g.read().then( ({done: R, value: N}) => {
                                                if (R)
                                                    A.close();
                                                else {
                                                    E += N.byteLength;
                                                    const D = new ProgressEvent("progress",{
                                                        lengthComputable: S,
                                                        loaded: E,
                                                        total: y
                                                    });
                                                    for (let U = 0, z = p.length; U < z; U++) {
                                                        const I = p[U];
                                                        I.onProgress && I.onProgress(D)
                                                    }
                                                    A.enqueue(N),
                                                    T()
                                                }
                                            }
                                            , R => {
                                                A.error(R)
                                            }
                                            )
                                        }
                                    }
                                });
                                return new Response(w)
                            } else
                                throw new TU(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,d)
                        }
                        ).then(d => {
                            switch (f) {
                            case "arraybuffer":
                                return d.arrayBuffer();
                            case "blob":
                                return d.blob();
                            case "document":
                                return d.text().then(p => new DOMParser().parseFromString(p, u));
                            case "json":
                                return d.json();
                            default:
                                if (u === "")
                                    return d.text();
                                {
                                    const p = /charset="?([^;"\s]*)"?/i.exec(u)
                                      , g = p && p[1] ? p[1].toLowerCase() : void 0
                                      , v = new TextDecoder(g);
                                    return d.arrayBuffer().then(y => v.decode(y))
                                }
                            }
                        }
                        ).then(d => {
                            dl.add(`file:${t}`, d);
                            const p = cc[t];
                            delete cc[t];
                            for (let g = 0, v = p.length; g < v; g++) {
                                const y = p[g];
                                y.onLoad && y.onLoad(d)
                            }
                        }
                        ).catch(d => {
                            const p = cc[t];
                            if (p === void 0)
                                throw this.manager.itemError(t),
                                d;
                            delete cc[t];
                            for (let g = 0, v = p.length; g < v; g++) {
                                const y = p[g];
                                y.onError && y.onError(d)
                            }
                            this.manager.itemError(t)
                        }
                        ).finally( () => {
                            this.manager.itemEnd(t)
                        }
                        ),
                        this.manager.itemStart(t)
                    }
                    setResponseType(t) {
                        return this.responseType = t,
                        this
                    }
                    setMimeType(t) {
                        return this.mimeType = t,
                        this
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                  , AU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this
                          , o = new uc(this.manager);
                        o.setPath(this.path),
                        o.setRequestHeader(this.requestHeader),
                        o.setWithCredentials(this.withCredentials),
                        o.load(t, function(u) {
                            try {
                                e(a.parse(JSON.parse(u)))
                            } catch (f) {
                                i ? i(f) : Rt(f),
                                a.manager.itemError(t)
                            }
                        }, n, i)
                    }
                    parse(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = Wg.parse(t[n]);
                            e.push(i)
                        }
                        return e
                    }
                }
                  , EU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this
                          , o = []
                          , u = new yy
                          , f = new uc(this.manager);
                        f.setPath(this.path),
                        f.setResponseType("arraybuffer"),
                        f.setRequestHeader(this.requestHeader),
                        f.setWithCredentials(a.withCredentials);
                        let d = 0;
                        function p(g) {
                            f.load(t[g], function(v) {
                                const y = a.parse(v, !0);
                                o[g] = {
                                    width: y.width,
                                    height: y.height,
                                    format: y.format,
                                    mipmaps: y.mipmaps
                                },
                                d += 1,
                                d === 6 && (y.mipmapCount === 1 && (u.minFilter = fi),
                                u.image = o,
                                u.format = y.format,
                                u.needsUpdate = !0,
                                e && e(u))
                            }, n, i)
                        }
                        if (Array.isArray(t))
                            for (let g = 0, v = t.length; g < v; ++g)
                                p(g);
                        else
                            f.load(t, function(g) {
                                const v = a.parse(g, !0);
                                if (v.isCubemap) {
                                    const y = v.mipmaps.length / v.mipmapCount;
                                    for (let S = 0; S < y; S++) {
                                        o[S] = {
                                            mipmaps: []
                                        };
                                        for (let E = 0; E < v.mipmapCount; E++)
                                            o[S].mipmaps.push(v.mipmaps[S * v.mipmapCount + E]),
                                            o[S].format = v.format,
                                            o[S].width = v.width,
                                            o[S].height = v.height
                                    }
                                    u.image = o
                                } else
                                    u.image.width = v.width,
                                    u.image.height = v.height,
                                    u.mipmaps = v.mipmaps;
                                v.mipmapCount === 1 && (u.minFilter = fi),
                                u.format = v.format,
                                u.needsUpdate = !0,
                                e && e(u)
                            }, n, i);
                        return u
                    }
                }
                ;
                const ip = new WeakMap;
                var Yg = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        this.path !== void 0 && (t = this.path + t),
                        t = this.manager.resolveURL(t);
                        const a = this
                          , o = dl.get(`image:${t}`);
                        if (o !== void 0) {
                            if (o.complete === !0)
                                a.manager.itemStart(t),
                                setTimeout(function() {
                                    e && e(o),
                                    a.manager.itemEnd(t)
                                }, 0);
                            else {
                                let g = ip.get(o);
                                g === void 0 && (g = [],
                                ip.set(o, g)),
                                g.push({
                                    onLoad: e,
                                    onError: i
                                })
                            }
                            return o
                        }
                        const u = _g("img");
                        function f() {
                            p(),
                            e && e(this);
                            const g = ip.get(this) || [];
                            for (let v = 0; v < g.length; v++) {
                                const y = g[v];
                                y.onLoad && y.onLoad(this)
                            }
                            ip.delete(this),
                            a.manager.itemEnd(t)
                        }
                        function d(g) {
                            p(),
                            i && i(g),
                            dl.remove(`image:${t}`);
                            const v = ip.get(this) || [];
                            for (let y = 0; y < v.length; y++) {
                                const S = v[y];
                                S.onError && S.onError(g)
                            }
                            ip.delete(this),
                            a.manager.itemError(t),
                            a.manager.itemEnd(t)
                        }
                        function p() {
                            u.removeEventListener("load", f, !1),
                            u.removeEventListener("error", d, !1)
                        }
                        return u.addEventListener("load", f, !1),
                        u.addEventListener("error", d, !1),
                        t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (u.crossOrigin = this.crossOrigin),
                        dl.add(`image:${t}`, u),
                        a.manager.itemStart(t),
                        u.src = t,
                        u
                    }
                }
                  , CU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = new Cg;
                        a.colorSpace = Gs;
                        const o = new Yg(this.manager);
                        o.setCrossOrigin(this.crossOrigin),
                        o.setPath(this.path);
                        let u = 0;
                        function f(d) {
                            o.load(t[d], function(p) {
                                a.images[d] = p,
                                u++,
                                u === 6 && (a.needsUpdate = !0,
                                e && e(a))
                            }, void 0, i)
                        }
                        for (let d = 0; d < t.length; ++d)
                            f(d);
                        return a
                    }
                }
                  , wU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this
                          , o = new yo
                          , u = new uc(this.manager);
                        return u.setResponseType("arraybuffer"),
                        u.setRequestHeader(this.requestHeader),
                        u.setPath(this.path),
                        u.setWithCredentials(a.withCredentials),
                        u.load(t, function(f) {
                            let d;
                            try {
                                d = a.parse(f)
                            } catch (p) {
                                if (i !== void 0)
                                    i(p);
                                else {
                                    p(p);
                                    return
                                }
                            }
                            d.image !== void 0 ? o.image = d.image : d.data !== void 0 && (o.image.width = d.width,
                            o.image.height = d.height,
                            o.image.data = d.data),
                            o.wrapS = d.wrapS !== void 0 ? d.wrapS : Ia,
                            o.wrapT = d.wrapT !== void 0 ? d.wrapT : Ia,
                            o.magFilter = d.magFilter !== void 0 ? d.magFilter : fi,
                            o.minFilter = d.minFilter !== void 0 ? d.minFilter : fi,
                            o.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1,
                            d.colorSpace !== void 0 && (o.colorSpace = d.colorSpace),
                            d.flipY !== void 0 && (o.flipY = d.flipY),
                            d.format !== void 0 && (o.format = d.format),
                            d.type !== void 0 && (o.type = d.type),
                            d.mipmaps !== void 0 && (o.mipmaps = d.mipmaps,
                            o.minFilter = rl),
                            d.mipmapCount === 1 && (o.minFilter = fi),
                            d.generateMipmaps !== void 0 && (o.generateMipmaps = d.generateMipmaps),
                            o.needsUpdate = !0,
                            e && e(o, d)
                        }, n, i),
                        o
                    }
                }
                  , RU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = new gs
                          , o = new Yg(this.manager);
                        return o.setCrossOrigin(this.crossOrigin),
                        o.setPath(this.path),
                        o.load(t, function(u) {
                            a.image = u,
                            a.needsUpdate = !0,
                            e !== void 0 && e(a)
                        }, n, i),
                        a
                    }
                }
                  , pu = class extends zn {
                    constructor(t, e=1) {
                        super(),
                        this.isLight = !0,
                        this.type = "Light",
                        this.color = new ut(t),
                        this.intensity = e
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.color.copy(t.color),
                        this.intensity = t.intensity,
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.color = this.color.getHex(),
                        e.object.intensity = this.intensity,
                        e
                    }
                }
                  , PE = class extends pu {
                    constructor(t, e, n) {
                        super(t, n),
                        this.isHemisphereLight = !0,
                        this.type = "HemisphereLight",
                        this.position.copy(zn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.groundColor = new ut(e)
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.groundColor.copy(t.groundColor),
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.groundColor = this.groundColor.getHex(),
                        e
                    }
                }
                ;
                const HM = new jt
                  , VE = new J
                  , FE = new J;
                var GM = class {
                    constructor(t) {
                        this.camera = t,
                        this.intensity = 1,
                        this.bias = 0,
                        this.normalBias = 0,
                        this.radius = 1,
                        this.blurSamples = 8,
                        this.mapSize = new Ge(512,512),
                        this.mapType = da,
                        this.map = null,
                        this.mapPass = null,
                        this.matrix = new jt,
                        this.autoUpdate = !0,
                        this.needsUpdate = !1,
                        this._frustum = new $d,
                        this._frameExtents = new Ge(1,1),
                        this._viewportCount = 1,
                        this._viewports = [new di(0,0,1,1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(t) {
                        const e = this.camera
                          , n = this.matrix;
                        VE.setFromMatrixPosition(t.matrixWorld),
                        e.position.copy(VE),
                        FE.setFromMatrixPosition(t.target.matrixWorld),
                        e.lookAt(FE),
                        e.updateMatrixWorld(),
                        HM.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(HM, e.coordinateSystem, e.reversedDepth),
                        e.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        n.multiply(HM)
                    }
                    getViewport(t) {
                        return this._viewports[t]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(),
                        this.mapPass && this.mapPass.dispose()
                    }
                    copy(t) {
                        return this.camera = t.camera.clone(),
                        this.intensity = t.intensity,
                        this.bias = t.bias,
                        this.radius = t.radius,
                        this.autoUpdate = t.autoUpdate,
                        this.needsUpdate = t.needsUpdate,
                        this.normalBias = t.normalBias,
                        this.blurSamples = t.blurSamples,
                        this.mapSize.copy(t.mapSize),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        const t = {};
                        return this.intensity !== 1 && (t.intensity = this.intensity),
                        this.bias !== 0 && (t.bias = this.bias),
                        this.normalBias !== 0 && (t.normalBias = this.normalBias),
                        this.radius !== 1 && (t.radius = this.radius),
                        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()),
                        t.camera = this.camera.toJSON(!1).object,
                        delete t.camera.matrix,
                        t
                    }
                }
                  , NU = class extends GM {
                    constructor() {
                        super(new _s(50,1,.5,500)),
                        this.isSpotLightShadow = !0,
                        this.focus = 1,
                        this.aspect = 1
                    }
                    updateMatrices(t) {
                        const e = this.camera
                          , n = Rd * 2 * t.angle * this.focus
                          , i = this.mapSize.width / this.mapSize.height * this.aspect
                          , a = t.distance || e.far;
                        (n !== e.fov || i !== e.aspect || a !== e.far) && (e.fov = n,
                        e.aspect = i,
                        e.far = a,
                        e.updateProjectionMatrix()),
                        super.updateMatrices(t)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.focus = t.focus,
                        this
                    }
                }
                  , HE = class extends pu {
                    constructor(t, e, n=0, i=Math.PI / 3, a=0, o=2) {
                        super(t, e),
                        this.isSpotLight = !0,
                        this.type = "SpotLight",
                        this.position.copy(zn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new zn,
                        this.distance = n,
                        this.angle = i,
                        this.penumbra = a,
                        this.decay = o,
                        this.map = null,
                        this.shadow = new NU
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / Math.PI
                    }
                    dispose() {
                        super.dispose(),
                        this.shadow.dispose()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.distance = t.distance,
                        this.angle = t.angle,
                        this.penumbra = t.penumbra,
                        this.decay = t.decay,
                        this.target = t.target.clone(),
                        this.map = t.map,
                        this.shadow = t.shadow.clone(),
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.distance = this.distance,
                        e.object.angle = this.angle,
                        e.object.decay = this.decay,
                        e.object.penumbra = this.penumbra,
                        e.object.target = this.target.uuid,
                        this.map && this.map.isTexture && (e.object.map = this.map.toJSON(t).uuid),
                        e.object.shadow = this.shadow.toJSON(),
                        e
                    }
                }
                  , DU = class extends GM {
                    constructor() {
                        super(new _s(90,1,.5,500)),
                        this.isPointLightShadow = !0
                    }
                }
                  , GE = class extends pu {
                    constructor(t, e, n=0, i=2) {
                        super(t, e),
                        this.isPointLight = !0,
                        this.type = "PointLight",
                        this.distance = n,
                        this.decay = i,
                        this.shadow = new DU
                    }
                    get power() {
                        return this.intensity * 4 * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                    dispose() {
                        super.dispose(),
                        this.shadow.dispose()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.distance = t.distance,
                        this.decay = t.decay,
                        this.shadow = t.shadow.clone(),
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.distance = this.distance,
                        e.object.decay = this.decay,
                        e.object.shadow = this.shadow.toJSON(),
                        e
                    }
                }
                  , sp = class extends ty {
                    constructor(t=-1, e=1, n=1, i=-1, a=.1, o=2e3) {
                        super(),
                        this.isOrthographicCamera = !0,
                        this.type = "OrthographicCamera",
                        this.zoom = 1,
                        this.view = null,
                        this.left = t,
                        this.right = e,
                        this.top = n,
                        this.bottom = i,
                        this.near = a,
                        this.far = o,
                        this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.left = t.left,
                        this.right = t.right,
                        this.top = t.top,
                        this.bottom = t.bottom,
                        this.near = t.near,
                        this.far = t.far,
                        this.zoom = t.zoom,
                        this.view = t.view === null ? null : Object.assign({}, t.view),
                        this
                    }
                    setViewOffset(t, e, n, i, a, o) {
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = t,
                        this.view.fullHeight = e,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = a,
                        this.view.height = o,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom)
                          , e = (this.top - this.bottom) / (2 * this.zoom)
                          , n = (this.right + this.left) / 2
                          , i = (this.top + this.bottom) / 2;
                        let a = n - t
                          , o = n + t
                          , u = i + e
                          , f = i - e;
                        if (this.view !== null && this.view.enabled) {
                            const d = (this.right - this.left) / this.view.fullWidth / this.zoom
                              , p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            a += d * this.view.offsetX,
                            o = a + d * this.view.width,
                            u -= p * this.view.offsetY,
                            f = u - p * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(a, o, u, f, this.near, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.zoom = this.zoom,
                        e.object.left = this.left,
                        e.object.right = this.right,
                        e.object.top = this.top,
                        e.object.bottom = this.bottom,
                        e.object.near = this.near,
                        e.object.far = this.far,
                        this.view !== null && (e.object.view = Object.assign({}, this.view)),
                        e
                    }
                }
                  , OU = class extends GM {
                    constructor() {
                        super(new sp(-5,5,5,-5,.5,500)),
                        this.isDirectionalLightShadow = !0
                    }
                }
                  , kE = class extends pu {
                    constructor(t, e) {
                        super(t, e),
                        this.isDirectionalLight = !0,
                        this.type = "DirectionalLight",
                        this.position.copy(zn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new zn,
                        this.shadow = new OU
                    }
                    dispose() {
                        super.dispose(),
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t),
                        this.target = t.target.clone(),
                        this.shadow = t.shadow.clone(),
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.shadow = this.shadow.toJSON(),
                        e.object.target = this.target.uuid,
                        e
                    }
                }
                  , qE = class extends pu {
                    constructor(t, e) {
                        super(t, e),
                        this.isAmbientLight = !0,
                        this.type = "AmbientLight"
                    }
                }
                  , XE = class extends pu {
                    constructor(t, e, n=10, i=10) {
                        super(t, e),
                        this.isRectAreaLight = !0,
                        this.type = "RectAreaLight",
                        this.width = n,
                        this.height = i
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (this.width * this.height * Math.PI)
                    }
                    copy(t) {
                        return super.copy(t),
                        this.width = t.width,
                        this.height = t.height,
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.width = this.width,
                        e.object.height = this.height,
                        e
                    }
                }
                  , kM = class {
                    constructor() {
                        this.isSphericalHarmonics3 = !0,
                        this.coefficients = [];
                        for (let t = 0; t < 9; t++)
                            this.coefficients.push(new J)
                    }
                    set(t) {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].copy(t[e]);
                        return this
                    }
                    zero() {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].set(0, 0, 0);
                        return this
                    }
                    getAt(t, e) {
                        const n = t.x
                          , i = t.y
                          , a = t.z
                          , o = this.coefficients;
                        return e.copy(o[0]).multiplyScalar(.282095),
                        e.addScaledVector(o[1], .488603 * i),
                        e.addScaledVector(o[2], .488603 * a),
                        e.addScaledVector(o[3], .488603 * n),
                        e.addScaledVector(o[4], 1.092548 * (n * i)),
                        e.addScaledVector(o[5], 1.092548 * (i * a)),
                        e.addScaledVector(o[6], .315392 * (3 * a * a - 1)),
                        e.addScaledVector(o[7], 1.092548 * (n * a)),
                        e.addScaledVector(o[8], .546274 * (n * n - i * i)),
                        e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x
                          , i = t.y
                          , a = t.z
                          , o = this.coefficients;
                        return e.copy(o[0]).multiplyScalar(.886227),
                        e.addScaledVector(o[1], 2 * .511664 * i),
                        e.addScaledVector(o[2], 2 * .511664 * a),
                        e.addScaledVector(o[3], 2 * .511664 * n),
                        e.addScaledVector(o[4], 2 * .429043 * n * i),
                        e.addScaledVector(o[5], 2 * .429043 * i * a),
                        e.addScaledVector(o[6], .743125 * a * a - .247708),
                        e.addScaledVector(o[7], 2 * .429043 * n * a),
                        e.addScaledVector(o[8], .429043 * (n * n - i * i)),
                        e
                    }
                    add(t) {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].add(t.coefficients[e]);
                        return this
                    }
                    addScaledSH(t, e) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].addScaledVector(t.coefficients[n], e);
                        return this
                    }
                    scale(t) {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].multiplyScalar(t);
                        return this
                    }
                    lerp(t, e) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].lerp(t.coefficients[n], e);
                        return this
                    }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e]))
                                return !1;
                        return !0
                    }
                    copy(t) {
                        return this.set(t.coefficients)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    fromArray(t, e=0) {
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++)
                            n[i].fromArray(t, e + i * 3);
                        return this
                    }
                    toArray(t=[], e=0) {
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++)
                            n[i].toArray(t, e + i * 3);
                        return t
                    }
                    static getBasisAt(t, e) {
                        const n = t.x
                          , i = t.y
                          , a = t.z;
                        e[0] = .282095,
                        e[1] = .488603 * i,
                        e[2] = .488603 * a,
                        e[3] = .488603 * n,
                        e[4] = 1.092548 * n * i,
                        e[5] = 1.092548 * i * a,
                        e[6] = .315392 * (3 * a * a - 1),
                        e[7] = 1.092548 * n * a,
                        e[8] = .546274 * (n * n - i * i)
                    }
                }
                  , WE = class extends pu {
                    constructor(t=new kM, e=1) {
                        super(void 0, e),
                        this.isLightProbe = !0,
                        this.sh = t
                    }
                    copy(t) {
                        return super.copy(t),
                        this.sh.copy(t.sh),
                        this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.sh = this.sh.toArray(),
                        e
                    }
                }
                  , YE = class GR extends Va {
                    constructor(e) {
                        super(e),
                        this.textures = {}
                    }
                    load(e, n, i, a) {
                        const o = this
                          , u = new uc(o.manager);
                        u.setPath(o.path),
                        u.setRequestHeader(o.requestHeader),
                        u.setWithCredentials(o.withCredentials),
                        u.load(e, function(f) {
                            try {
                                n(o.parse(JSON.parse(f)))
                            } catch (d) {
                                a ? a(d) : Rt(d),
                                o.manager.itemError(e)
                            }
                        }, i, a)
                    }
                    parse(e) {
                        const n = this.textures;
                        function i(o) {
                            return n[o] === void 0 && at("MaterialLoader: Undefined texture", o),
                            n[o]
                        }
                        const a = this.createMaterialFromType(e.type);
                        if (e.uuid !== void 0 && (a.uuid = e.uuid),
                        e.name !== void 0 && (a.name = e.name),
                        e.color !== void 0 && a.color !== void 0 && a.color.setHex(e.color),
                        e.roughness !== void 0 && (a.roughness = e.roughness),
                        e.metalness !== void 0 && (a.metalness = e.metalness),
                        e.sheen !== void 0 && (a.sheen = e.sheen),
                        e.sheenColor !== void 0 && (a.sheenColor = new ut().setHex(e.sheenColor)),
                        e.sheenRoughness !== void 0 && (a.sheenRoughness = e.sheenRoughness),
                        e.emissive !== void 0 && a.emissive !== void 0 && a.emissive.setHex(e.emissive),
                        e.specular !== void 0 && a.specular !== void 0 && a.specular.setHex(e.specular),
                        e.specularIntensity !== void 0 && (a.specularIntensity = e.specularIntensity),
                        e.specularColor !== void 0 && a.specularColor !== void 0 && a.specularColor.setHex(e.specularColor),
                        e.shininess !== void 0 && (a.shininess = e.shininess),
                        e.clearcoat !== void 0 && (a.clearcoat = e.clearcoat),
                        e.clearcoatRoughness !== void 0 && (a.clearcoatRoughness = e.clearcoatRoughness),
                        e.dispersion !== void 0 && (a.dispersion = e.dispersion),
                        e.iridescence !== void 0 && (a.iridescence = e.iridescence),
                        e.iridescenceIOR !== void 0 && (a.iridescenceIOR = e.iridescenceIOR),
                        e.iridescenceThicknessRange !== void 0 && (a.iridescenceThicknessRange = e.iridescenceThicknessRange),
                        e.transmission !== void 0 && (a.transmission = e.transmission),
                        e.thickness !== void 0 && (a.thickness = e.thickness),
                        e.attenuationDistance !== void 0 && (a.attenuationDistance = e.attenuationDistance),
                        e.attenuationColor !== void 0 && a.attenuationColor !== void 0 && a.attenuationColor.setHex(e.attenuationColor),
                        e.anisotropy !== void 0 && (a.anisotropy = e.anisotropy),
                        e.anisotropyRotation !== void 0 && (a.anisotropyRotation = e.anisotropyRotation),
                        e.fog !== void 0 && (a.fog = e.fog),
                        e.flatShading !== void 0 && (a.flatShading = e.flatShading),
                        e.blending !== void 0 && (a.blending = e.blending),
                        e.combine !== void 0 && (a.combine = e.combine),
                        e.side !== void 0 && (a.side = e.side),
                        e.shadowSide !== void 0 && (a.shadowSide = e.shadowSide),
                        e.opacity !== void 0 && (a.opacity = e.opacity),
                        e.transparent !== void 0 && (a.transparent = e.transparent),
                        e.alphaTest !== void 0 && (a.alphaTest = e.alphaTest),
                        e.alphaHash !== void 0 && (a.alphaHash = e.alphaHash),
                        e.depthFunc !== void 0 && (a.depthFunc = e.depthFunc),
                        e.depthTest !== void 0 && (a.depthTest = e.depthTest),
                        e.depthWrite !== void 0 && (a.depthWrite = e.depthWrite),
                        e.colorWrite !== void 0 && (a.colorWrite = e.colorWrite),
                        e.blendSrc !== void 0 && (a.blendSrc = e.blendSrc),
                        e.blendDst !== void 0 && (a.blendDst = e.blendDst),
                        e.blendEquation !== void 0 && (a.blendEquation = e.blendEquation),
                        e.blendSrcAlpha !== void 0 && (a.blendSrcAlpha = e.blendSrcAlpha),
                        e.blendDstAlpha !== void 0 && (a.blendDstAlpha = e.blendDstAlpha),
                        e.blendEquationAlpha !== void 0 && (a.blendEquationAlpha = e.blendEquationAlpha),
                        e.blendColor !== void 0 && a.blendColor !== void 0 && a.blendColor.setHex(e.blendColor),
                        e.blendAlpha !== void 0 && (a.blendAlpha = e.blendAlpha),
                        e.stencilWriteMask !== void 0 && (a.stencilWriteMask = e.stencilWriteMask),
                        e.stencilFunc !== void 0 && (a.stencilFunc = e.stencilFunc),
                        e.stencilRef !== void 0 && (a.stencilRef = e.stencilRef),
                        e.stencilFuncMask !== void 0 && (a.stencilFuncMask = e.stencilFuncMask),
                        e.stencilFail !== void 0 && (a.stencilFail = e.stencilFail),
                        e.stencilZFail !== void 0 && (a.stencilZFail = e.stencilZFail),
                        e.stencilZPass !== void 0 && (a.stencilZPass = e.stencilZPass),
                        e.stencilWrite !== void 0 && (a.stencilWrite = e.stencilWrite),
                        e.wireframe !== void 0 && (a.wireframe = e.wireframe),
                        e.wireframeLinewidth !== void 0 && (a.wireframeLinewidth = e.wireframeLinewidth),
                        e.wireframeLinecap !== void 0 && (a.wireframeLinecap = e.wireframeLinecap),
                        e.wireframeLinejoin !== void 0 && (a.wireframeLinejoin = e.wireframeLinejoin),
                        e.rotation !== void 0 && (a.rotation = e.rotation),
                        e.linewidth !== void 0 && (a.linewidth = e.linewidth),
                        e.dashSize !== void 0 && (a.dashSize = e.dashSize),
                        e.gapSize !== void 0 && (a.gapSize = e.gapSize),
                        e.scale !== void 0 && (a.scale = e.scale),
                        e.polygonOffset !== void 0 && (a.polygonOffset = e.polygonOffset),
                        e.polygonOffsetFactor !== void 0 && (a.polygonOffsetFactor = e.polygonOffsetFactor),
                        e.polygonOffsetUnits !== void 0 && (a.polygonOffsetUnits = e.polygonOffsetUnits),
                        e.dithering !== void 0 && (a.dithering = e.dithering),
                        e.alphaToCoverage !== void 0 && (a.alphaToCoverage = e.alphaToCoverage),
                        e.premultipliedAlpha !== void 0 && (a.premultipliedAlpha = e.premultipliedAlpha),
                        e.forceSinglePass !== void 0 && (a.forceSinglePass = e.forceSinglePass),
                        e.allowOverride !== void 0 && (a.allowOverride = e.allowOverride),
                        e.visible !== void 0 && (a.visible = e.visible),
                        e.toneMapped !== void 0 && (a.toneMapped = e.toneMapped),
                        e.userData !== void 0 && (a.userData = e.userData),
                        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors),
                        e.uniforms !== void 0)
                            for (const o in e.uniforms) {
                                const u = e.uniforms[o];
                                switch (a.uniforms[o] = {},
                                u.type) {
                                case "t":
                                    a.uniforms[o].value = i(u.value);
                                    break;
                                case "c":
                                    a.uniforms[o].value = new ut().setHex(u.value);
                                    break;
                                case "v2":
                                    a.uniforms[o].value = new Ge().fromArray(u.value);
                                    break;
                                case "v3":
                                    a.uniforms[o].value = new J().fromArray(u.value);
                                    break;
                                case "v4":
                                    a.uniforms[o].value = new di().fromArray(u.value);
                                    break;
                                case "m3":
                                    a.uniforms[o].value = new sn().fromArray(u.value);
                                    break;
                                case "m4":
                                    a.uniforms[o].value = new jt().fromArray(u.value);
                                    break;
                                default:
                                    a.uniforms[o].value = u.value
                                }
                            }
                        if (e.defines !== void 0 && (a.defines = e.defines),
                        e.vertexShader !== void 0 && (a.vertexShader = e.vertexShader),
                        e.fragmentShader !== void 0 && (a.fragmentShader = e.fragmentShader),
                        e.glslVersion !== void 0 && (a.glslVersion = e.glslVersion),
                        e.extensions !== void 0)
                            for (const o in e.extensions)
                                a.extensions[o] = e.extensions[o];
                        if (e.lights !== void 0 && (a.lights = e.lights),
                        e.clipping !== void 0 && (a.clipping = e.clipping),
                        e.size !== void 0 && (a.size = e.size),
                        e.sizeAttenuation !== void 0 && (a.sizeAttenuation = e.sizeAttenuation),
                        e.map !== void 0 && (a.map = i(e.map)),
                        e.matcap !== void 0 && (a.matcap = i(e.matcap)),
                        e.alphaMap !== void 0 && (a.alphaMap = i(e.alphaMap)),
                        e.bumpMap !== void 0 && (a.bumpMap = i(e.bumpMap)),
                        e.bumpScale !== void 0 && (a.bumpScale = e.bumpScale),
                        e.normalMap !== void 0 && (a.normalMap = i(e.normalMap)),
                        e.normalMapType !== void 0 && (a.normalMapType = e.normalMapType),
                        e.normalScale !== void 0) {
                            let o = e.normalScale;
                            Array.isArray(o) === !1 && (o = [o, o]),
                            a.normalScale = new Ge().fromArray(o)
                        }
                        return e.displacementMap !== void 0 && (a.displacementMap = i(e.displacementMap)),
                        e.displacementScale !== void 0 && (a.displacementScale = e.displacementScale),
                        e.displacementBias !== void 0 && (a.displacementBias = e.displacementBias),
                        e.roughnessMap !== void 0 && (a.roughnessMap = i(e.roughnessMap)),
                        e.metalnessMap !== void 0 && (a.metalnessMap = i(e.metalnessMap)),
                        e.emissiveMap !== void 0 && (a.emissiveMap = i(e.emissiveMap)),
                        e.emissiveIntensity !== void 0 && (a.emissiveIntensity = e.emissiveIntensity),
                        e.specularMap !== void 0 && (a.specularMap = i(e.specularMap)),
                        e.specularIntensityMap !== void 0 && (a.specularIntensityMap = i(e.specularIntensityMap)),
                        e.specularColorMap !== void 0 && (a.specularColorMap = i(e.specularColorMap)),
                        e.envMap !== void 0 && (a.envMap = i(e.envMap)),
                        e.envMapRotation !== void 0 && a.envMapRotation.fromArray(e.envMapRotation),
                        e.envMapIntensity !== void 0 && (a.envMapIntensity = e.envMapIntensity),
                        e.reflectivity !== void 0 && (a.reflectivity = e.reflectivity),
                        e.refractionRatio !== void 0 && (a.refractionRatio = e.refractionRatio),
                        e.lightMap !== void 0 && (a.lightMap = i(e.lightMap)),
                        e.lightMapIntensity !== void 0 && (a.lightMapIntensity = e.lightMapIntensity),
                        e.aoMap !== void 0 && (a.aoMap = i(e.aoMap)),
                        e.aoMapIntensity !== void 0 && (a.aoMapIntensity = e.aoMapIntensity),
                        e.gradientMap !== void 0 && (a.gradientMap = i(e.gradientMap)),
                        e.clearcoatMap !== void 0 && (a.clearcoatMap = i(e.clearcoatMap)),
                        e.clearcoatRoughnessMap !== void 0 && (a.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
                        e.clearcoatNormalMap !== void 0 && (a.clearcoatNormalMap = i(e.clearcoatNormalMap)),
                        e.clearcoatNormalScale !== void 0 && (a.clearcoatNormalScale = new Ge().fromArray(e.clearcoatNormalScale)),
                        e.iridescenceMap !== void 0 && (a.iridescenceMap = i(e.iridescenceMap)),
                        e.iridescenceThicknessMap !== void 0 && (a.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
                        e.transmissionMap !== void 0 && (a.transmissionMap = i(e.transmissionMap)),
                        e.thicknessMap !== void 0 && (a.thicknessMap = i(e.thicknessMap)),
                        e.anisotropyMap !== void 0 && (a.anisotropyMap = i(e.anisotropyMap)),
                        e.sheenColorMap !== void 0 && (a.sheenColorMap = i(e.sheenColorMap)),
                        e.sheenRoughnessMap !== void 0 && (a.sheenRoughnessMap = i(e.sheenRoughnessMap)),
                        a
                    }
                    setTextures(e) {
                        return this.textures = e,
                        this
                    }
                    createMaterialFromType(e) {
                        return GR.createMaterialFromType(e)
                    }
                    static createMaterialFromType(e) {
                        return new {
                            ShadowMaterial: AE,
                            SpriteMaterial: sM,
                            RawShaderMaterial: OM,
                            ShaderMaterial: Br,
                            PointsMaterial: dM,
                            MeshPhysicalMaterial: EE,
                            MeshStandardMaterial: UM,
                            MeshPhongMaterial: CE,
                            MeshToonMaterial: wE,
                            MeshNormalMaterial: RE,
                            MeshLambertMaterial: NE,
                            MeshDepthMaterial: LM,
                            MeshDistanceMaterial: IM,
                            MeshBasicMaterial: uu,
                            MeshMatcapMaterial: DE,
                            LineDashedMaterial: OE,
                            LineBasicMaterial: _a,
                            Material: Ws
                        }[e]
                    }
                }
                  , qM = class {
                    static extractUrlBase(t) {
                        const e = t.lastIndexOf("/");
                        return e === -1 ? "./" : t.slice(0, e + 1)
                    }
                    static resolveURL(t, e) {
                        return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                        /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                    }
                }
                  , jE = class extends en {
                    constructor() {
                        super(),
                        this.isInstancedBufferGeometry = !0,
                        this.type = "InstancedBufferGeometry",
                        this.instanceCount = 1 / 0
                    }
                    copy(t) {
                        return super.copy(t),
                        this.instanceCount = t.instanceCount,
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.instanceCount = this.instanceCount,
                        t.isInstancedBufferGeometry = !0,
                        t
                    }
                }
                  , ZE = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this
                          , o = new uc(a.manager);
                        o.setPath(a.path),
                        o.setRequestHeader(a.requestHeader),
                        o.setWithCredentials(a.withCredentials),
                        o.load(t, function(u) {
                            try {
                                e(a.parse(JSON.parse(u)))
                            } catch (f) {
                                i ? i(f) : Rt(f),
                                a.manager.itemError(t)
                            }
                        }, n, i)
                    }
                    parse(t) {
                        const e = {}
                          , n = {};
                        function i(v, y) {
                            if (e[y] !== void 0)
                                return e[y];
                            const S = v.interleavedBuffers[y]
                              , E = a(v, S.buffer)
                              , w = new iy(Cd(S.type, E),S.stride);
                            return w.uuid = S.uuid,
                            e[y] = w,
                            w
                        }
                        function a(v, y) {
                            if (n[y] !== void 0)
                                return n[y];
                            const S = v.arrayBuffers[y]
                              , E = new Uint32Array(S).buffer;
                            return n[y] = E,
                            E
                        }
                        const o = t.isInstancedBufferGeometry ? new jE : new en
                          , u = t.data.index;
                        if (u !== void 0) {
                            const v = Cd(u.type, u.array);
                            o.setIndex(new Kn(v,1))
                        }
                        const f = t.data.attributes;
                        for (const v in f) {
                            const y = f[v];
                            let S;
                            if (y.isInterleavedBufferAttribute)
                                S = new wg(i(t.data, y.data),y.itemSize,y.offset,y.normalized);
                            else {
                                const E = Cd(y.type, y.array);
                                S = new (y.isInstancedBufferAttribute ? Kd : Kn)(E,y.itemSize,y.normalized)
                            }
                            y.name !== void 0 && (S.name = y.name),
                            y.usage !== void 0 && S.setUsage(y.usage),
                            o.setAttribute(v, S)
                        }
                        const d = t.data.morphAttributes;
                        if (d)
                            for (const v in d) {
                                const y = d[v]
                                  , S = [];
                                for (let E = 0, w = y.length; E < w; E++) {
                                    const A = y[E];
                                    let T;
                                    A.isInterleavedBufferAttribute ? T = new wg(i(t.data, A.data),A.itemSize,A.offset,A.normalized) : T = new Kn(Cd(A.type, A.array),A.itemSize,A.normalized),
                                    A.name !== void 0 && (T.name = A.name),
                                    S.push(T)
                                }
                                o.morphAttributes[v] = S
                            }
                        t.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
                        const p = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (p !== void 0)
                            for (let v = 0, y = p.length; v !== y; ++v) {
                                const S = p[v];
                                o.addGroup(S.start, S.count, S.materialIndex)
                            }
                        const g = t.data.boundingSphere;
                        return g !== void 0 && (o.boundingSphere = new As().fromJSON(g)),
                        t.name && (o.name = t.name),
                        t.userData && (o.userData = t.userData),
                        o
                    }
                }
                  , UU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this
                          , o = this.path === "" ? qM.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || o;
                        const u = new uc(this.manager);
                        u.setPath(this.path),
                        u.setRequestHeader(this.requestHeader),
                        u.setWithCredentials(this.withCredentials),
                        u.load(t, function(f) {
                            let d = null;
                            try {
                                d = JSON.parse(f)
                            } catch (g) {
                                i !== void 0 && i(g),
                                g("ObjectLoader: Can't parse " + t + ".", g.message);
                                return
                            }
                            const p = d.metadata;
                            if (p === void 0 || p.type === void 0 || p.type.toLowerCase() === "geometry") {
                                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + t)),
                                Rt("ObjectLoader: Can't load " + t);
                                return
                            }
                            a.parse(d, e)
                        }, n, i)
                    }
                    async loadAsync(t, e) {
                        const n = this
                          , i = this.path === "" ? qM.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || i;
                        const a = new uc(this.manager);
                        a.setPath(this.path),
                        a.setRequestHeader(this.requestHeader),
                        a.setWithCredentials(this.withCredentials);
                        const o = await a.loadAsync(t, e)
                          , u = JSON.parse(o)
                          , f = u.metadata;
                        if (f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry")
                            throw new Error("THREE.ObjectLoader: Can't load " + t);
                        return await n.parseAsync(u)
                    }
                    parse(t, e) {
                        const n = this.parseAnimations(t.animations)
                          , i = this.parseShapes(t.shapes)
                          , a = this.parseGeometries(t.geometries, i)
                          , o = this.parseImages(t.images, function() {
                            e !== void 0 && e(d)
                        })
                          , u = this.parseTextures(t.textures, o)
                          , f = this.parseMaterials(t.materials, u)
                          , d = this.parseObject(t.object, a, f, u, n)
                          , p = this.parseSkeletons(t.skeletons, d);
                        if (this.bindSkeletons(d, p),
                        this.bindLightTargets(d),
                        e !== void 0) {
                            let g = !1;
                            for (const v in o)
                                if (o[v].data instanceof HTMLImageElement) {
                                    g = !0;
                                    break
                                }
                            g === !1 && e(d)
                        }
                        return d
                    }
                    async parseAsync(t) {
                        const e = this.parseAnimations(t.animations)
                          , n = this.parseShapes(t.shapes)
                          , i = this.parseGeometries(t.geometries, n)
                          , a = await this.parseImagesAsync(t.images)
                          , o = this.parseTextures(t.textures, a)
                          , u = this.parseMaterials(t.materials, o)
                          , f = this.parseObject(t.object, i, u, o, e)
                          , d = this.parseSkeletons(t.skeletons, f);
                        return this.bindSkeletons(f, d),
                        this.bindLightTargets(f),
                        f
                    }
                    parseShapes(t) {
                        const e = {};
                        if (t !== void 0)
                            for (let n = 0, i = t.length; n < i; n++) {
                                const a = new Oh().fromJSON(t[n]);
                                e[a.uuid] = a
                            }
                        return e
                    }
                    parseSkeletons(t, e) {
                        const n = {}
                          , i = {};
                        if (e.traverse(function(a) {
                            a.isBone && (i[a.uuid] = a)
                        }),
                        t !== void 0)
                            for (let a = 0, o = t.length; a < o; a++) {
                                const u = new OA().fromJSON(t[a], i);
                                n[u.uuid] = u
                            }
                        return n
                    }
                    parseGeometries(t, e) {
                        const n = {};
                        if (t !== void 0) {
                            const i = new ZE;
                            for (let a = 0, o = t.length; a < o; a++) {
                                let u;
                                const f = t[a];
                                switch (f.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    u = i.parse(f);
                                    break;
                                default:
                                    f.type in TE ? u = TE[f.type].fromJSON(f, e) : at(`ObjectLoader: Unsupported geometry type "${f.type}"`)
                                }
                                u.uuid = f.uuid,
                                f.name !== void 0 && (u.name = f.name),
                                f.userData !== void 0 && (u.userData = f.userData),
                                n[f.uuid] = u
                            }
                        }
                        return n
                    }
                    parseMaterials(t, e) {
                        const n = {}
                          , i = {};
                        if (t !== void 0) {
                            const a = new YE;
                            a.setTextures(e);
                            for (let o = 0, u = t.length; o < u; o++) {
                                const f = t[o];
                                n[f.uuid] === void 0 && (n[f.uuid] = a.parse(f)),
                                i[f.uuid] = n[f.uuid]
                            }
                        }
                        return i
                    }
                    parseAnimations(t) {
                        const e = {};
                        if (t !== void 0)
                            for (let n = 0; n < t.length; n++) {
                                const i = t[n]
                                  , a = Wg.parse(i);
                                e[a.uuid] = a
                            }
                        return e
                    }
                    parseImages(t, e) {
                        const n = this
                          , i = {};
                        let a;
                        function o(f) {
                            return n.manager.itemStart(f),
                            a.load(f, function() {
                                n.manager.itemEnd(f)
                            }, void 0, function() {
                                n.manager.itemError(f),
                                n.manager.itemEnd(f)
                            })
                        }
                        function u(f) {
                            if (typeof f == "string") {
                                const d = f;
                                return o(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d)
                            } else
                                return f.data ? {
                                    data: Cd(f.type, f.data),
                                    width: f.width,
                                    height: f.height
                                } : null
                        }
                        if (t !== void 0 && t.length > 0) {
                            a = new Yg(new FM(e)),
                            a.setCrossOrigin(this.crossOrigin);
                            for (let f = 0, d = t.length; f < d; f++) {
                                const p = t[f]
                                  , g = p.url;
                                if (Array.isArray(g)) {
                                    const v = [];
                                    for (let y = 0, S = g.length; y < S; y++) {
                                        const E = g[y]
                                          , w = u(E);
                                        w !== null && (w instanceof HTMLImageElement ? v.push(w) : v.push(new yo(w.data,w.width,w.height)))
                                    }
                                    i[p.uuid] = new iu(v)
                                } else {
                                    const v = u(p.url);
                                    i[p.uuid] = new iu(v)
                                }
                            }
                        }
                        return i
                    }
                    async parseImagesAsync(t) {
                        const e = this
                          , n = {};
                        let i;
                        async function a(o) {
                            if (typeof o == "string") {
                                const u = o
                                  , f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : e.resourcePath + u;
                                return await i.loadAsync(f)
                            } else
                                return o.data ? {
                                    data: Cd(o.type, o.data),
                                    width: o.width,
                                    height: o.height
                                } : null
                        }
                        if (t !== void 0 && t.length > 0) {
                            i = new Yg(this.manager),
                            i.setCrossOrigin(this.crossOrigin);
                            for (let o = 0, u = t.length; o < u; o++) {
                                const f = t[o]
                                  , d = f.url;
                                if (Array.isArray(d)) {
                                    const p = [];
                                    for (let g = 0, v = d.length; g < v; g++) {
                                        const y = d[g]
                                          , S = await a(y);
                                        S !== null && (S instanceof HTMLImageElement ? p.push(S) : p.push(new yo(S.data,S.width,S.height)))
                                    }
                                    n[f.uuid] = new iu(p)
                                } else {
                                    const p = await a(f.url);
                                    n[f.uuid] = new iu(p)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(t, e) {
                        function n(a, o) {
                            return typeof a == "number" ? a : (at("ObjectLoader.parseTexture: Constant should be in numeric form.", a),
                            o[a])
                        }
                        const i = {};
                        if (t !== void 0)
                            for (let a = 0, o = t.length; a < o; a++) {
                                const u = t[a];
                                u.image === void 0 && at('ObjectLoader: No "image" specified for', u.uuid),
                                e[u.image] === void 0 && at("ObjectLoader: Undefined image", u.image);
                                const f = e[u.image]
                                  , d = f.data;
                                let p;
                                Array.isArray(d) ? (p = new Cg,
                                d.length === 6 && (p.needsUpdate = !0)) : (d && d.data ? p = new yo : p = new gs,
                                d && (p.needsUpdate = !0)),
                                p.source = f,
                                p.uuid = u.uuid,
                                u.name !== void 0 && (p.name = u.name),
                                u.mapping !== void 0 && (p.mapping = n(u.mapping, LU)),
                                u.channel !== void 0 && (p.channel = u.channel),
                                u.offset !== void 0 && p.offset.fromArray(u.offset),
                                u.repeat !== void 0 && p.repeat.fromArray(u.repeat),
                                u.center !== void 0 && p.center.fromArray(u.center),
                                u.rotation !== void 0 && (p.rotation = u.rotation),
                                u.wrap !== void 0 && (p.wrapS = n(u.wrap[0], QE),
                                p.wrapT = n(u.wrap[1], QE)),
                                u.format !== void 0 && (p.format = u.format),
                                u.internalFormat !== void 0 && (p.internalFormat = u.internalFormat),
                                u.type !== void 0 && (p.type = u.type),
                                u.colorSpace !== void 0 && (p.colorSpace = u.colorSpace),
                                u.minFilter !== void 0 && (p.minFilter = n(u.minFilter, KE)),
                                u.magFilter !== void 0 && (p.magFilter = n(u.magFilter, KE)),
                                u.anisotropy !== void 0 && (p.anisotropy = u.anisotropy),
                                u.flipY !== void 0 && (p.flipY = u.flipY),
                                u.generateMipmaps !== void 0 && (p.generateMipmaps = u.generateMipmaps),
                                u.premultiplyAlpha !== void 0 && (p.premultiplyAlpha = u.premultiplyAlpha),
                                u.unpackAlignment !== void 0 && (p.unpackAlignment = u.unpackAlignment),
                                u.compareFunction !== void 0 && (p.compareFunction = u.compareFunction),
                                u.userData !== void 0 && (p.userData = u.userData),
                                i[u.uuid] = p
                            }
                        return i
                    }
                    parseObject(t, e, n, i, a) {
                        let o;
                        function u(v) {
                            return e[v] === void 0 && at("ObjectLoader: Undefined geometry", v),
                            e[v]
                        }
                        function f(v) {
                            if (v !== void 0) {
                                if (Array.isArray(v)) {
                                    const y = [];
                                    for (let S = 0, E = v.length; S < E; S++) {
                                        const w = v[S];
                                        n[w] === void 0 && at("ObjectLoader: Undefined material", w),
                                        y.push(n[w])
                                    }
                                    return y
                                }
                                return n[v] === void 0 && at("ObjectLoader: Undefined material", v),
                                n[v]
                            }
                        }
                        function d(v) {
                            return i[v] === void 0 && at("ObjectLoader: Undefined texture", v),
                            i[v]
                        }
                        let p, g;
                        switch (t.type) {
                        case "Scene":
                            o = new iM,
                            t.background !== void 0 && (Number.isInteger(t.background) ? o.background = new ut(t.background) : o.background = d(t.background)),
                            t.environment !== void 0 && (o.environment = d(t.environment)),
                            t.fog !== void 0 && (t.fog.type === "Fog" ? o.fog = new _A(t.fog.color,t.fog.near,t.fog.far) : t.fog.type === "FogExp2" && (o.fog = new vA(t.fog.color,t.fog.density)),
                            t.fog.name !== "" && (o.fog.name = t.fog.name)),
                            t.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = t.backgroundBlurriness),
                            t.backgroundIntensity !== void 0 && (o.backgroundIntensity = t.backgroundIntensity),
                            t.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(t.backgroundRotation),
                            t.environmentIntensity !== void 0 && (o.environmentIntensity = t.environmentIntensity),
                            t.environmentRotation !== void 0 && o.environmentRotation.fromArray(t.environmentRotation);
                            break;
                        case "PerspectiveCamera":
                            o = new _s(t.fov,t.aspect,t.near,t.far),
                            t.focus !== void 0 && (o.focus = t.focus),
                            t.zoom !== void 0 && (o.zoom = t.zoom),
                            t.filmGauge !== void 0 && (o.filmGauge = t.filmGauge),
                            t.filmOffset !== void 0 && (o.filmOffset = t.filmOffset),
                            t.view !== void 0 && (o.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            o = new sp(t.left,t.right,t.top,t.bottom,t.near,t.far),
                            t.zoom !== void 0 && (o.zoom = t.zoom),
                            t.view !== void 0 && (o.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            o = new qE(t.color,t.intensity);
                            break;
                        case "DirectionalLight":
                            o = new kE(t.color,t.intensity),
                            o.target = t.target || "";
                            break;
                        case "PointLight":
                            o = new GE(t.color,t.intensity,t.distance,t.decay);
                            break;
                        case "RectAreaLight":
                            o = new XE(t.color,t.intensity,t.width,t.height);
                            break;
                        case "SpotLight":
                            o = new HE(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),
                            o.target = t.target || "";
                            break;
                        case "HemisphereLight":
                            o = new PE(t.color,t.groundColor,t.intensity);
                            break;
                        case "LightProbe":
                            o = new WE(new kM().fromArray(t.sh),t.intensity);
                            break;
                        case "SkinnedMesh":
                            p = u(t.geometry),
                            g = f(t.material),
                            o = new NA(p,g),
                            t.bindMode !== void 0 && (o.bindMode = t.bindMode),
                            t.bindMatrix !== void 0 && o.bindMatrix.fromArray(t.bindMatrix),
                            t.skeleton !== void 0 && (o.skeleton = t.skeleton);
                            break;
                        case "Mesh":
                            p = u(t.geometry),
                            g = f(t.material),
                            o = new Ji(p,g);
                            break;
                        case "InstancedMesh":
                            p = u(t.geometry),
                            g = f(t.material);
                            const v = t.count
                              , y = t.instanceMatrix
                              , S = t.instanceColor;
                            o = new IA(p,g,v),
                            o.instanceMatrix = new Kd(new Float32Array(y.array),16),
                            S !== void 0 && (o.instanceColor = new Kd(new Float32Array(S.array),S.itemSize));
                            break;
                        case "BatchedMesh":
                            p = u(t.geometry),
                            g = f(t.material),
                            o = new VA(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,g),
                            o.geometry = p,
                            o.perObjectFrustumCulled = t.perObjectFrustumCulled,
                            o.sortObjects = t.sortObjects,
                            o._drawRanges = t.drawRanges,
                            o._reservedRanges = t.reservedRanges,
                            o._geometryInfo = t.geometryInfo.map(E => {
                                let w = null
                                  , A = null;
                                return E.boundingBox !== void 0 && (w = new qs().fromJSON(E.boundingBox)),
                                E.boundingSphere !== void 0 && (A = new As().fromJSON(E.boundingSphere)),
                                {
                                    ...E,
                                    boundingBox: w,
                                    boundingSphere: A
                                }
                            }
                            ),
                            o._instanceInfo = t.instanceInfo,
                            o._availableInstanceIds = t._availableInstanceIds,
                            o._availableGeometryIds = t._availableGeometryIds,
                            o._nextIndexStart = t.nextIndexStart,
                            o._nextVertexStart = t.nextVertexStart,
                            o._geometryCount = t.geometryCount,
                            o._maxInstanceCount = t.maxInstanceCount,
                            o._maxVertexCount = t.maxVertexCount,
                            o._maxIndexCount = t.maxIndexCount,
                            o._geometryInitialized = t.geometryInitialized,
                            o._matricesTexture = d(t.matricesTexture.uuid),
                            o._indirectTexture = d(t.indirectTexture.uuid),
                            t.colorsTexture !== void 0 && (o._colorsTexture = d(t.colorsTexture.uuid)),
                            t.boundingSphere !== void 0 && (o.boundingSphere = new As().fromJSON(t.boundingSphere)),
                            t.boundingBox !== void 0 && (o.boundingBox = new qs().fromJSON(t.boundingBox));
                            break;
                        case "LOD":
                            o = new TA;
                            break;
                        case "Line":
                            o = new du(u(t.geometry),f(t.material));
                            break;
                        case "LineLoop":
                            o = new qA(u(t.geometry),f(t.material));
                            break;
                        case "LineSegments":
                            o = new fl(u(t.geometry),f(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            o = new WA(u(t.geometry),f(t.material));
                            break;
                        case "Sprite":
                            o = new MA(f(t.material));
                            break;
                        case "Group":
                            o = new Wd;
                            break;
                        case "Bone":
                            o = new lM;
                            break;
                        default:
                            o = new zn
                        }
                        if (o.uuid = t.uuid,
                        t.name !== void 0 && (o.name = t.name),
                        t.matrix !== void 0 ? (o.matrix.fromArray(t.matrix),
                        t.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = t.matrixAutoUpdate),
                        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (t.position !== void 0 && o.position.fromArray(t.position),
                        t.rotation !== void 0 && o.rotation.fromArray(t.rotation),
                        t.quaternion !== void 0 && o.quaternion.fromArray(t.quaternion),
                        t.scale !== void 0 && o.scale.fromArray(t.scale)),
                        t.up !== void 0 && o.up.fromArray(t.up),
                        t.castShadow !== void 0 && (o.castShadow = t.castShadow),
                        t.receiveShadow !== void 0 && (o.receiveShadow = t.receiveShadow),
                        t.shadow && (t.shadow.intensity !== void 0 && (o.shadow.intensity = t.shadow.intensity),
                        t.shadow.bias !== void 0 && (o.shadow.bias = t.shadow.bias),
                        t.shadow.normalBias !== void 0 && (o.shadow.normalBias = t.shadow.normalBias),
                        t.shadow.radius !== void 0 && (o.shadow.radius = t.shadow.radius),
                        t.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(t.shadow.mapSize),
                        t.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(t.shadow.camera))),
                        t.visible !== void 0 && (o.visible = t.visible),
                        t.frustumCulled !== void 0 && (o.frustumCulled = t.frustumCulled),
                        t.renderOrder !== void 0 && (o.renderOrder = t.renderOrder),
                        t.userData !== void 0 && (o.userData = t.userData),
                        t.layers !== void 0 && (o.layers.mask = t.layers),
                        t.children !== void 0) {
                            const v = t.children;
                            for (let y = 0; y < v.length; y++)
                                o.add(this.parseObject(v[y], e, n, i, a))
                        }
                        if (t.animations !== void 0) {
                            const v = t.animations;
                            for (let y = 0; y < v.length; y++) {
                                const S = v[y];
                                o.animations.push(a[S])
                            }
                        }
                        if (t.type === "LOD") {
                            t.autoUpdate !== void 0 && (o.autoUpdate = t.autoUpdate);
                            const v = t.levels;
                            for (let y = 0; y < v.length; y++) {
                                const S = v[y]
                                  , E = o.getObjectByProperty("uuid", S.object);
                                E !== void 0 && o.addLevel(E, S.distance, S.hysteresis)
                            }
                        }
                        return o
                    }
                    bindSkeletons(t, e) {
                        Object.keys(e).length !== 0 && t.traverse(function(n) {
                            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                                const i = e[n.skeleton];
                                i === void 0 ? at("ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix)
                            }
                        })
                    }
                    bindLightTargets(t) {
                        t.traverse(function(e) {
                            if (e.isDirectionalLight || e.isSpotLight) {
                                const n = e.target
                                  , i = t.getObjectByProperty("uuid", n);
                                i !== void 0 ? e.target = i : e.target = new zn
                            }
                        })
                    }
                }
                ;
                const LU = {
                    UVMapping: Y_,
                    CubeReflectionMapping: al,
                    CubeRefractionMapping: Jc,
                    EquirectangularReflectionMapping: sg,
                    EquirectangularRefractionMapping: ag,
                    CubeUVReflectionMapping: Md
                }
                  , QE = {
                    RepeatWrapping: rg,
                    ClampToEdgeWrapping: Ia,
                    MirroredRepeatWrapping: og
                }
                  , KE = {
                    NearestFilter: Vi,
                    NearestMipmapNearestFilter: Mx,
                    NearestMipmapLinearFilter: bd,
                    LinearFilter: fi,
                    LinearMipmapNearestFilter: lg,
                    LinearMipmapLinearFilter: rl
                }
                  , XM = new WeakMap;
                var IU = class extends Va {
                    constructor(t) {
                        super(t),
                        this.isImageBitmapLoader = !0,
                        typeof createImageBitmap > "u" && at("ImageBitmapLoader: createImageBitmap() not supported."),
                        typeof fetch > "u" && at("ImageBitmapLoader: fetch() not supported."),
                        this.options = {
                            premultiplyAlpha: "none"
                        },
                        this._abortController = new AbortController
                    }
                    setOptions(t) {
                        return this.options = t,
                        this
                    }
                    load(t, e, n, i) {
                        t === void 0 && (t = ""),
                        this.path !== void 0 && (t = this.path + t),
                        t = this.manager.resolveURL(t);
                        const a = this
                          , o = dl.get(`image-bitmap:${t}`);
                        if (o !== void 0) {
                            if (a.manager.itemStart(t),
                            o.then) {
                                o.then(d => {
                                    if (XM.has(o) === !0)
                                        i && i(XM.get(o)),
                                        a.manager.itemError(t),
                                        a.manager.itemEnd(t);
                                    else
                                        return e && e(d),
                                        a.manager.itemEnd(t),
                                        d
                                }
                                );
                                return
                            }
                            return setTimeout(function() {
                                e && e(o),
                                a.manager.itemEnd(t)
                            }, 0),
                            o
                        }
                        const u = {};
                        u.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                        u.headers = this.requestHeader,
                        u.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
                        const f = fetch(t, u).then(function(d) {
                            return d.blob()
                        }).then(function(d) {
                            return createImageBitmap(d, Object.assign(a.options, {
                                colorSpaceConversion: "none"
                            }))
                        }).then(function(d) {
                            return dl.add(`image-bitmap:${t}`, d),
                            e && e(d),
                            a.manager.itemEnd(t),
                            d
                        }).catch(function(d) {
                            i && i(d),
                            XM.set(f, d),
                            dl.remove(`image-bitmap:${t}`),
                            a.manager.itemError(t),
                            a.manager.itemEnd(t)
                        });
                        dl.add(`image-bitmap:${t}`, f),
                        a.manager.itemStart(t)
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                ;
                let Ny;
                var WM = class {
                    static getContext() {
                        return Ny === void 0 && (Ny = new (window.AudioContext || window.webkitAudioContext)),
                        Ny
                    }
                    static setContext(t) {
                        Ny = t
                    }
                }
                  , zU = class extends Va {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this
                          , o = new uc(this.manager);
                        o.setResponseType("arraybuffer"),
                        o.setPath(this.path),
                        o.setRequestHeader(this.requestHeader),
                        o.setWithCredentials(this.withCredentials),
                        o.load(t, function(f) {
                            try {
                                const d = f.slice(0);
                                WM.getContext().decodeAudioData(d, function(p) {
                                    e(p)
                                }).catch(u)
                            } catch (d) {
                                u(d)
                            }
                        }, n, i);
                        function u(f) {
                            i ? i(f) : Rt(f),
                            a.manager.itemError(t)
                        }
                    }
                }
                ;
                const JE = new jt
                  , $E = new jt
                  , Bh = new jt;
                var BU = class {
                    constructor() {
                        this.type = "StereoCamera",
                        this.aspect = 1,
                        this.eyeSep = .064,
                        this.cameraL = new _s,
                        this.cameraL.layers.enable(1),
                        this.cameraL.matrixAutoUpdate = !1,
                        this.cameraR = new _s,
                        this.cameraR.layers.enable(2),
                        this.cameraR.matrixAutoUpdate = !1,
                        this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(t) {
                        const e = this._cache;
                        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                            e.focus = t.focus,
                            e.fov = t.fov,
                            e.aspect = t.aspect * this.aspect,
                            e.near = t.near,
                            e.far = t.far,
                            e.zoom = t.zoom,
                            e.eyeSep = this.eyeSep,
                            Bh.copy(t.projectionMatrix);
                            const n = e.eyeSep / 2
                              , i = n * e.near / e.focus
                              , a = e.near * Math.tan(Ah * e.fov * .5) / e.zoom;
                            let o, u;
                            $E.elements[12] = -n,
                            JE.elements[12] = n,
                            o = -a * e.aspect + i,
                            u = a * e.aspect + i,
                            Bh.elements[0] = 2 * e.near / (u - o),
                            Bh.elements[8] = (u + o) / (u - o),
                            this.cameraL.projectionMatrix.copy(Bh),
                            o = -a * e.aspect - i,
                            u = a * e.aspect - i,
                            Bh.elements[0] = 2 * e.near / (u - o),
                            Bh.elements[8] = (u + o) / (u - o),
                            this.cameraR.projectionMatrix.copy(Bh)
                        }
                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply($E),
                        this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(JE)
                    }
                }
                  , eC = class extends _s {
                    constructor(t=[]) {
                        super(),
                        this.isArrayCamera = !0,
                        this.isMultiViewCamera = !1,
                        this.cameras = t
                    }
                }
                  , YM = class {
                    constructor(t=!0) {
                        this.autoStart = t,
                        this.startTime = 0,
                        this.oldTime = 0,
                        this.elapsedTime = 0,
                        this.running = !1
                    }
                    start() {
                        this.startTime = performance.now(),
                        this.oldTime = this.startTime,
                        this.elapsedTime = 0,
                        this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(),
                        this.running = !1,
                        this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(),
                        this.elapsedTime
                    }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running)
                            return this.start(),
                            0;
                        if (this.running) {
                            const e = performance.now();
                            t = (e - this.oldTime) / 1e3,
                            this.oldTime = e,
                            this.elapsedTime += t
                        }
                        return t
                    }
                }
                ;
                const Ph = new J
                  , jM = new za
                  , PU = new J
                  , Vh = new J
                  , Fh = new J;
                var VU = class extends zn {
                    constructor() {
                        super(),
                        this.type = "AudioListener",
                        this.context = WM.getContext(),
                        this.gain = this.context.createGain(),
                        this.gain.connect(this.context.destination),
                        this.filter = null,
                        this.timeDelta = 0,
                        this._clock = new YM
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return this.filter !== null && (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination),
                        this.gain.connect(this.context.destination),
                        this.filter = null),
                        this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(t) {
                        return this.filter !== null ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                        this.filter = t,
                        this.gain.connect(this.filter),
                        this.filter.connect(this.context.destination),
                        this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
                        this
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t);
                        const e = this.context.listener;
                        if (this.timeDelta = this._clock.getDelta(),
                        this.matrixWorld.decompose(Ph, jM, PU),
                        Vh.set(0, 0, -1).applyQuaternion(jM),
                        Fh.set(0, 1, 0).applyQuaternion(jM),
                        e.positionX) {
                            const n = this.context.currentTime + this.timeDelta;
                            e.positionX.linearRampToValueAtTime(Ph.x, n),
                            e.positionY.linearRampToValueAtTime(Ph.y, n),
                            e.positionZ.linearRampToValueAtTime(Ph.z, n),
                            e.forwardX.linearRampToValueAtTime(Vh.x, n),
                            e.forwardY.linearRampToValueAtTime(Vh.y, n),
                            e.forwardZ.linearRampToValueAtTime(Vh.z, n),
                            e.upX.linearRampToValueAtTime(Fh.x, n),
                            e.upY.linearRampToValueAtTime(Fh.y, n),
                            e.upZ.linearRampToValueAtTime(Fh.z, n)
                        } else
                            e.setPosition(Ph.x, Ph.y, Ph.z),
                            e.setOrientation(Vh.x, Vh.y, Vh.z, Fh.x, Fh.y, Fh.z)
                    }
                }
                  , tC = class extends zn {
                    constructor(t) {
                        super(),
                        this.type = "Audio",
                        this.listener = t,
                        this.context = t.context,
                        this.gain = this.context.createGain(),
                        this.gain.connect(t.getInput()),
                        this.autoplay = !1,
                        this.buffer = null,
                        this.detune = 0,
                        this.loop = !1,
                        this.loopStart = 0,
                        this.loopEnd = 0,
                        this.offset = 0,
                        this.duration = void 0,
                        this.playbackRate = 1,
                        this.isPlaying = !1,
                        this.hasPlaybackControl = !0,
                        this.source = null,
                        this.sourceType = "empty",
                        this._startedAt = 0,
                        this._progress = 0,
                        this._connected = !1,
                        this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(t) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "audioNode",
                        this.source = t,
                        this.connect(),
                        this
                    }
                    setMediaElementSource(t) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaNode",
                        this.source = this.context.createMediaElementSource(t),
                        this.connect(),
                        this
                    }
                    setMediaStreamSource(t) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaStreamNode",
                        this.source = this.context.createMediaStreamSource(t),
                        this.connect(),
                        this
                    }
                    setBuffer(t) {
                        return this.buffer = t,
                        this.sourceType = "buffer",
                        this.autoplay && this.play(),
                        this
                    }
                    play(t=0) {
                        if (this.isPlaying === !0) {
                            at("Audio: Audio is already playing.");
                            return
                        }
                        if (this.hasPlaybackControl === !1) {
                            at("Audio: this Audio has no playback control.");
                            return
                        }
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer,
                        e.loop = this.loop,
                        e.loopStart = this.loopStart,
                        e.loopEnd = this.loopEnd,
                        e.onended = this.onEnded.bind(this),
                        e.start(this._startedAt, this._progress + this.offset, this.duration),
                        this.isPlaying = !0,
                        this.source = e,
                        this.setDetune(this.detune),
                        this.setPlaybackRate(this.playbackRate),
                        this.connect()
                    }
                    pause() {
                        if (this.hasPlaybackControl === !1) {
                            at("Audio: this Audio has no playback control.");
                            return
                        }
                        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                        this.source.stop(),
                        this.source.onended = null,
                        this.isPlaying = !1),
                        this
                    }
                    stop(t=0) {
                        if (this.hasPlaybackControl === !1) {
                            at("Audio: this Audio has no playback control.");
                            return
                        }
                        return this._progress = 0,
                        this.source !== null && (this.source.stop(this.context.currentTime + t),
                        this.source.onended = null),
                        this.isPlaying = !1,
                        this
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++)
                                this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else
                            this.source.connect(this.getOutput());
                        return this._connected = !0,
                        this
                    }
                    disconnect() {
                        if (this._connected !== !1) {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (let t = 1, e = this.filters.length; t < e; t++)
                                    this.filters[t - 1].disconnect(this.filters[t]);
                                this.filters[this.filters.length - 1].disconnect(this.getOutput())
                            } else
                                this.source.disconnect(this.getOutput());
                            return this._connected = !1,
                            this
                        }
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(t) {
                        return t || (t = []),
                        this._connected === !0 ? (this.disconnect(),
                        this.filters = t.slice(),
                        this.connect()) : this.filters = t.slice(),
                        this
                    }
                    setDetune(t) {
                        return this.detune = t,
                        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                        this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(t) {
                        return this.setFilters(t ? [t] : [])
                    }
                    setPlaybackRate(t) {
                        if (this.hasPlaybackControl === !1) {
                            at("Audio: this Audio has no playback control.");
                            return
                        }
                        return this.playbackRate = t,
                        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                        this
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1,
                        this._progress = 0
                    }
                    getLoop() {
                        return this.hasPlaybackControl === !1 ? (at("Audio: this Audio has no playback control."),
                        !1) : this.loop
                    }
                    setLoop(t) {
                        if (this.hasPlaybackControl === !1) {
                            at("Audio: this Audio has no playback control.");
                            return
                        }
                        return this.loop = t,
                        this.isPlaying === !0 && (this.source.loop = this.loop),
                        this
                    }
                    setLoopStart(t) {
                        return this.loopStart = t,
                        this
                    }
                    setLoopEnd(t) {
                        return this.loopEnd = t,
                        this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
                        this
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        t.sourceType !== "buffer" ? (at("Audio: Audio source type cannot be copied."),
                        this) : (this.autoplay = t.autoplay,
                        this.buffer = t.buffer,
                        this.detune = t.detune,
                        this.loop = t.loop,
                        this.loopStart = t.loopStart,
                        this.loopEnd = t.loopEnd,
                        this.offset = t.offset,
                        this.duration = t.duration,
                        this.playbackRate = t.playbackRate,
                        this.hasPlaybackControl = t.hasPlaybackControl,
                        this.sourceType = t.sourceType,
                        this.filters = t.filters.slice(),
                        this)
                    }
                    clone(t) {
                        return new this.constructor(this.listener).copy(this, t)
                    }
                }
                ;
                const Hh = new J
                  , nC = new za
                  , FU = new J
                  , Gh = new J;
                var HU = class extends tC {
                    constructor(t) {
                        super(t),
                        this.panner = this.context.createPanner(),
                        this.panner.panningModel = "HRTF",
                        this.panner.connect(this.gain)
                    }
                    connect() {
                        return super.connect(),
                        this.panner.connect(this.gain),
                        this
                    }
                    disconnect() {
                        return super.disconnect(),
                        this.panner.disconnect(this.gain),
                        this
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(t) {
                        return this.panner.refDistance = t,
                        this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(t) {
                        return this.panner.rolloffFactor = t,
                        this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(t) {
                        return this.panner.distanceModel = t,
                        this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(t) {
                        return this.panner.maxDistance = t,
                        this
                    }
                    setDirectionalCone(t, e, n) {
                        return this.panner.coneInnerAngle = t,
                        this.panner.coneOuterAngle = e,
                        this.panner.coneOuterGain = n,
                        this
                    }
                    updateMatrixWorld(t) {
                        if (super.updateMatrixWorld(t),
                        this.hasPlaybackControl === !0 && this.isPlaying === !1)
                            return;
                        this.matrixWorld.decompose(Hh, nC, FU),
                        Gh.set(0, 0, 1).applyQuaternion(nC);
                        const e = this.panner;
                        if (e.positionX) {
                            const n = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(Hh.x, n),
                            e.positionY.linearRampToValueAtTime(Hh.y, n),
                            e.positionZ.linearRampToValueAtTime(Hh.z, n),
                            e.orientationX.linearRampToValueAtTime(Gh.x, n),
                            e.orientationY.linearRampToValueAtTime(Gh.y, n),
                            e.orientationZ.linearRampToValueAtTime(Gh.z, n)
                        } else
                            e.setPosition(Hh.x, Hh.y, Hh.z),
                            e.setOrientation(Gh.x, Gh.y, Gh.z)
                    }
                }
                  , GU = class {
                    constructor(t, e=2048) {
                        this.analyser = t.context.createAnalyser(),
                        this.analyser.fftSize = e,
                        this.data = new Uint8Array(this.analyser.frequencyBinCount),
                        t.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data),
                        this.data
                    }
                    getAverageFrequency() {
                        let t = 0;
                        const e = this.getFrequencyData();
                        for (let n = 0; n < e.length; n++)
                            t += e[n];
                        return t / e.length
                    }
                }
                  , iC = class {
                    constructor(t, e, n) {
                        this.binding = t,
                        this.valueSize = n;
                        let i, a, o;
                        switch (e) {
                        case "quaternion":
                            i = this._slerp,
                            a = this._slerpAdditive,
                            o = this._setAdditiveIdentityQuaternion,
                            this.buffer = new Float64Array(n * 6),
                            this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            i = this._select,
                            a = this._select,
                            o = this._setAdditiveIdentityOther,
                            this.buffer = new Array(n * 5);
                            break;
                        default:
                            i = this._lerp,
                            a = this._lerpAdditive,
                            o = this._setAdditiveIdentityNumeric,
                            this.buffer = new Float64Array(n * 5)
                        }
                        this._mixBufferRegion = i,
                        this._mixBufferRegionAdditive = a,
                        this._setIdentity = o,
                        this._origIndex = 3,
                        this._addIndex = 4,
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        this.useCount = 0,
                        this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer
                          , i = this.valueSize
                          , a = t * i + i;
                        let o = this.cumulativeWeight;
                        if (o === 0) {
                            for (let u = 0; u !== i; ++u)
                                n[a + u] = n[u];
                            o = e
                        } else {
                            o += e;
                            const u = e / o;
                            this._mixBufferRegion(n, a, 0, u, i)
                        }
                        this.cumulativeWeight = o
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer
                          , n = this.valueSize
                          , i = n * this._addIndex;
                        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                        this._mixBufferRegionAdditive(e, i, 0, t, n),
                        this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize
                          , n = this.buffer
                          , i = t * e + e
                          , a = this.cumulativeWeight
                          , o = this.cumulativeWeightAdditive
                          , u = this.binding;
                        if (this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        a < 1) {
                            const f = e * this._origIndex;
                            this._mixBufferRegion(n, i, f, 1 - a, e)
                        }
                        o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                        for (let f = e, d = e + e; f !== d; ++f)
                            if (n[f] !== n[f + e]) {
                                u.setValue(n, i);
                                break
                            }
                    }
                    saveOriginalState() {
                        const t = this.binding
                          , e = this.buffer
                          , n = this.valueSize
                          , i = n * this._origIndex;
                        t.getValue(e, i);
                        for (let a = n, o = i; a !== o; ++a)
                            e[a] = e[i + a % n];
                        this._setIdentity(),
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = this.valueSize * 3;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize
                          , e = t + this.valueSize;
                        for (let n = t; n < e; n++)
                            this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(),
                        this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize
                          , e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++)
                            this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, i, a) {
                        if (i >= .5)
                            for (let o = 0; o !== a; ++o)
                                t[e + o] = t[n + o]
                    }
                    _slerp(t, e, n, i) {
                        za.slerpFlat(t, e, t, e, t, n, i)
                    }
                    _slerpAdditive(t, e, n, i, a) {
                        const o = this._workIndex * a;
                        za.multiplyQuaternionsFlat(t, o, t, e, t, n),
                        za.slerpFlat(t, e, t, e, t, o, i)
                    }
                    _lerp(t, e, n, i, a) {
                        const o = 1 - i;
                        for (let u = 0; u !== a; ++u) {
                            const f = e + u;
                            t[f] = t[f] * o + t[n + u] * i
                        }
                    }
                    _lerpAdditive(t, e, n, i, a) {
                        for (let o = 0; o !== a; ++o) {
                            const u = e + o;
                            t[u] = t[u] + t[n + o] * i
                        }
                    }
                }
                ;
                const ZM = "\\[\\]\\.:\\/"
                  , kU = new RegExp("[" + ZM + "]","g")
                  , QM = "[^" + ZM + "]"
                  , qU = "[^" + ZM.replace("\\.", "") + "]"
                  , XU = /((?:WC+[\/:])*)/.source.replace("WC", QM)
                  , WU = /(WCOD+)?/.source.replace("WCOD", qU)
                  , YU = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", QM)
                  , jU = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", QM)
                  , ZU = new RegExp("^" + XU + WU + YU + jU + "$")
                  , QU = ["material", "materials", "bones", "map"];
                var KU = class {
                    constructor(t, e, n) {
                        const i = n || ii.parseTrackName(e);
                        this._targetGroup = t,
                        this._bindings = t.subscribe_(e, i)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_
                          , i = this._bindings[n];
                        i !== void 0 && i.getValue(t, e)
                    }
                    setValue(t, e) {
                        const n = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, a = n.length; i !== a; ++i)
                            n[i].setValue(t, e)
                    }
                    bind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                            t[e].bind()
                    }
                    unbind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                            t[e].unbind()
                    }
                }
                  , ii = class Dp {
                    constructor(e, n, i) {
                        this.path = n,
                        this.parsedPath = i || Dp.parseTrackName(n),
                        this.node = Dp.findNode(e, this.parsedPath.nodeName),
                        this.rootNode = e,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                    static create(e, n, i) {
                        return e && e.isAnimationObjectGroup ? new Dp.Composite(e,n,i) : new Dp(e,n,i)
                    }
                    static sanitizeNodeName(e) {
                        return e.replace(/\s/g, "_").replace(kU, "")
                    }
                    static parseTrackName(e) {
                        const n = ZU.exec(e);
                        if (n === null)
                            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                        const i = {
                            nodeName: n[2],
                            objectName: n[3],
                            objectIndex: n[4],
                            propertyName: n[5],
                            propertyIndex: n[6]
                        }
                          , a = i.nodeName && i.nodeName.lastIndexOf(".");
                        if (a !== void 0 && a !== -1) {
                            const o = i.nodeName.substring(a + 1);
                            QU.indexOf(o) !== -1 && (i.nodeName = i.nodeName.substring(0, a),
                            i.objectName = o)
                        }
                        if (i.propertyName === null || i.propertyName.length === 0)
                            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                        return i
                    }
                    static findNode(e, n) {
                        if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid)
                            return e;
                        if (e.skeleton) {
                            const i = e.skeleton.getBoneByName(n);
                            if (i !== void 0)
                                return i
                        }
                        if (e.children) {
                            const i = function(o) {
                                for (let u = 0; u < o.length; u++) {
                                    const f = o[u];
                                    if (f.name === n || f.uuid === n)
                                        return f;
                                    const d = i(f.children);
                                    if (d)
                                        return d
                                }
                                return null
                            }
                              , a = i(e.children);
                            if (a)
                                return a
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(e, n) {
                        e[n] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(e, n) {
                        const i = this.resolvedProperty;
                        for (let a = 0, o = i.length; a !== o; ++a)
                            e[n++] = i[a]
                    }
                    _getValue_arrayElement(e, n) {
                        e[n] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(e, n) {
                        this.resolvedProperty.toArray(e, n)
                    }
                    _setValue_direct(e, n) {
                        this.targetObject[this.propertyName] = e[n]
                    }
                    _setValue_direct_setNeedsUpdate(e, n) {
                        this.targetObject[this.propertyName] = e[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
                        this.targetObject[this.propertyName] = e[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(e, n) {
                        const i = this.resolvedProperty;
                        for (let a = 0, o = i.length; a !== o; ++a)
                            i[a] = e[n++]
                    }
                    _setValue_array_setNeedsUpdate(e, n) {
                        const i = this.resolvedProperty;
                        for (let a = 0, o = i.length; a !== o; ++a)
                            i[a] = e[n++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
                        const i = this.resolvedProperty;
                        for (let a = 0, o = i.length; a !== o; ++a)
                            i[a] = e[n++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(e, n) {
                        this.resolvedProperty[this.propertyIndex] = e[n]
                    }
                    _setValue_arrayElement_setNeedsUpdate(e, n) {
                        this.resolvedProperty[this.propertyIndex] = e[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
                        this.resolvedProperty[this.propertyIndex] = e[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(e, n) {
                        this.resolvedProperty.fromArray(e, n)
                    }
                    _setValue_fromArray_setNeedsUpdate(e, n) {
                        this.resolvedProperty.fromArray(e, n),
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
                        this.resolvedProperty.fromArray(e, n),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(e, n) {
                        this.bind(),
                        this.getValue(e, n)
                    }
                    _setValue_unbound(e, n) {
                        this.bind(),
                        this.setValue(e, n)
                    }
                    bind() {
                        let e = this.node;
                        const n = this.parsedPath
                          , i = n.objectName
                          , a = n.propertyName;
                        let o = n.propertyIndex;
                        if (e || (e = Dp.findNode(this.rootNode, n.nodeName),
                        this.node = e),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !e) {
                            at("PropertyBinding: No target node found for track: " + this.path + ".");
                            return
                        }
                        if (i) {
                            let p = n.objectIndex;
                            switch (i) {
                            case "materials":
                                if (!e.material) {
                                    Rt("PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.materials) {
                                    Rt("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) {
                                    Rt("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                e = e.skeleton.bones;
                                for (let g = 0; g < e.length; g++)
                                    if (e[g].name === p) {
                                        p = g;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map"in e) {
                                    e = e.map;
                                    break
                                }
                                if (!e.material) {
                                    Rt("PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.map) {
                                    Rt("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                e = e.material.map;
                                break;
                            default:
                                if (e[i] === void 0) {
                                    Rt("PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                e = e[i]
                            }
                            if (p !== void 0) {
                                if (e[p] === void 0) {
                                    Rt("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                    return
                                }
                                e = e[p]
                            }
                        }
                        const u = e[a];
                        if (u === void 0) {
                            const p = n.nodeName;
                            Rt("PropertyBinding: Trying to update property for track: " + p + "." + a + " but it wasn't found.", e);
                            return
                        }
                        let f = this.Versioning.None;
                        this.targetObject = e,
                        e.isMaterial === !0 ? f = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (f = this.Versioning.MatrixWorldNeedsUpdate);
                        let d = this.BindingType.Direct;
                        if (o !== void 0) {
                            if (a === "morphTargetInfluences") {
                                if (!e.geometry) {
                                    Rt("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    return
                                }
                                if (!e.geometry.morphAttributes) {
                                    Rt("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o])
                            }
                            d = this.BindingType.ArrayElement,
                            this.resolvedProperty = u,
                            this.propertyIndex = o
                        } else
                            u.fromArray !== void 0 && u.toArray !== void 0 ? (d = this.BindingType.HasFromToArray,
                            this.resolvedProperty = u) : Array.isArray(u) ? (d = this.BindingType.EntireArray,
                            this.resolvedProperty = u) : this.propertyName = a;
                        this.getValue = this.GetterByBindingType[d],
                        this.setValue = this.SetterByBindingTypeAndVersioning[d][f]
                    }
                    unbind() {
                        this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                }
                ;
                ii.Composite = KU,
                ii.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                ii.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                ii.prototype.GetterByBindingType = [ii.prototype._getValue_direct, ii.prototype._getValue_array, ii.prototype._getValue_arrayElement, ii.prototype._getValue_toArray],
                ii.prototype.SetterByBindingTypeAndVersioning = [[ii.prototype._setValue_direct, ii.prototype._setValue_direct_setNeedsUpdate, ii.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ii.prototype._setValue_array, ii.prototype._setValue_array_setNeedsUpdate, ii.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ii.prototype._setValue_arrayElement, ii.prototype._setValue_arrayElement_setNeedsUpdate, ii.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ii.prototype._setValue_fromArray, ii.prototype._setValue_fromArray_setNeedsUpdate, ii.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
                var JU = class {
                    constructor() {
                        this.isAnimationObjectGroup = !0,
                        this.uuid = ir(),
                        this._objects = Array.prototype.slice.call(arguments),
                        this.nCachedObjects_ = 0;
                        const t = {};
                        this._indicesByUUID = t;
                        for (let n = 0, i = arguments.length; n !== i; ++n)
                            t[arguments[n].uuid] = n;
                        this._paths = [],
                        this._parsedPaths = [],
                        this._bindings = [],
                        this._bindingsIndicesByPath = {};
                        const e = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return e._objects.length
                                },
                                get inUse() {
                                    return this.total - e.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return e._bindings.length
                            }
                        }
                    }
                    add() {
                        const t = this._objects
                          , e = this._indicesByUUID
                          , n = this._paths
                          , i = this._parsedPaths
                          , a = this._bindings
                          , o = a.length;
                        let u, f = t.length, d = this.nCachedObjects_;
                        for (let p = 0, g = arguments.length; p !== g; ++p) {
                            const v = arguments[p]
                              , y = v.uuid;
                            let S = e[y];
                            if (S === void 0) {
                                S = f++,
                                e[y] = S,
                                t.push(v);
                                for (let E = 0, w = o; E !== w; ++E)
                                    a[E].push(new ii(v,n[E],i[E]))
                            } else if (S < d) {
                                u = t[S];
                                const E = --d
                                  , w = t[E];
                                e[w.uuid] = S,
                                t[S] = w,
                                e[y] = E,
                                t[E] = v;
                                for (let A = 0, T = o; A !== T; ++A) {
                                    const R = a[A]
                                      , N = R[E];
                                    let D = R[S];
                                    R[S] = N,
                                    D === void 0 && (D = new ii(v,n[A],i[A])),
                                    R[E] = D
                                }
                            } else
                                t[S] !== u && Rt("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = d
                    }
                    remove() {
                        const t = this._objects
                          , e = this._indicesByUUID
                          , n = this._bindings
                          , i = n.length;
                        let a = this.nCachedObjects_;
                        for (let o = 0, u = arguments.length; o !== u; ++o) {
                            const f = arguments[o]
                              , d = f.uuid
                              , p = e[d];
                            if (p !== void 0 && p >= a) {
                                const g = a++
                                  , v = t[g];
                                e[v.uuid] = p,
                                t[p] = v,
                                e[d] = g,
                                t[g] = f;
                                for (let y = 0, S = i; y !== S; ++y) {
                                    const E = n[y]
                                      , w = E[g]
                                      , A = E[p];
                                    E[p] = w,
                                    E[g] = A
                                }
                            }
                        }
                        this.nCachedObjects_ = a
                    }
                    uncache() {
                        const t = this._objects
                          , e = this._indicesByUUID
                          , n = this._bindings
                          , i = n.length;
                        let a = this.nCachedObjects_
                          , o = t.length;
                        for (let u = 0, f = arguments.length; u !== f; ++u) {
                            const d = arguments[u].uuid
                              , p = e[d];
                            if (p !== void 0)
                                if (delete e[d],
                                p < a) {
                                    const g = --a
                                      , v = t[g]
                                      , y = --o
                                      , S = t[y];
                                    e[v.uuid] = p,
                                    t[p] = v,
                                    e[S.uuid] = g,
                                    t[g] = S,
                                    t.pop();
                                    for (let E = 0, w = i; E !== w; ++E) {
                                        const A = n[E]
                                          , T = A[g]
                                          , R = A[y];
                                        A[p] = T,
                                        A[g] = R,
                                        A.pop()
                                    }
                                } else {
                                    const g = --o
                                      , v = t[g];
                                    g > 0 && (e[v.uuid] = p),
                                    t[p] = v,
                                    t.pop();
                                    for (let y = 0, S = i; y !== S; ++y) {
                                        const E = n[y];
                                        E[p] = E[g],
                                        E.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = a
                    }
                    subscribe_(t, e) {
                        const n = this._bindingsIndicesByPath;
                        let i = n[t];
                        const a = this._bindings;
                        if (i !== void 0)
                            return a[i];
                        const o = this._paths
                          , u = this._parsedPaths
                          , f = this._objects
                          , d = f.length
                          , p = this.nCachedObjects_
                          , g = new Array(d);
                        i = a.length,
                        n[t] = i,
                        o.push(t),
                        u.push(e),
                        a.push(g);
                        for (let v = p, y = f.length; v !== y; ++v) {
                            const S = f[v];
                            g[v] = new ii(S,t,e)
                        }
                        return g
                    }
                    unsubscribe_(t) {
                        const e = this._bindingsIndicesByPath
                          , n = e[t];
                        if (n !== void 0) {
                            const i = this._paths
                              , a = this._parsedPaths
                              , o = this._bindings
                              , u = o.length - 1
                              , f = o[u]
                              , d = t[u];
                            e[d] = n,
                            o[n] = f,
                            o.pop(),
                            a[n] = a[u],
                            a.pop(),
                            i[n] = i[u],
                            i.pop()
                        }
                    }
                }
                  , sC = class {
                    constructor(t, e, n=null, i=e.blendMode) {
                        this._mixer = t,
                        this._clip = e,
                        this._localRoot = n,
                        this.blendMode = i;
                        const a = e.tracks
                          , o = a.length
                          , u = new Array(o)
                          , f = {
                            endingStart: Mh,
                            endingEnd: Mh
                        };
                        for (let d = 0; d !== o; ++d) {
                            const p = a[d].createInterpolant(null);
                            u[d] = p,
                            p.settings = f
                        }
                        this._interpolantSettings = f,
                        this._interpolants = u,
                        this._propertyBindings = new Array(o),
                        this._cacheIndex = null,
                        this._byClipCacheIndex = null,
                        this._timeScaleInterpolant = null,
                        this._weightInterpolant = null,
                        this.loop = I1,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.time = 0,
                        this.timeScale = 1,
                        this._effectiveTimeScale = 1,
                        this.weight = 1,
                        this._effectiveWeight = 1,
                        this.repetitions = 1 / 0,
                        this.paused = !1,
                        this.enabled = !0,
                        this.clampWhenFinished = !1,
                        this.zeroSlopeAtStart = !0,
                        this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this),
                        this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this),
                        this.reset()
                    }
                    reset() {
                        return this.paused = !1,
                        this.enabled = !0,
                        this.time = 0,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(t) {
                        return this._startTime = t,
                        this
                    }
                    setLoop(t, e) {
                        return this.loop = t,
                        this.repetitions = e,
                        this
                    }
                    setEffectiveWeight(t) {
                        return this.weight = t,
                        this._effectiveWeight = this.enabled ? t : 0,
                        this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(t) {
                        return this._scheduleFading(t, 0, 1)
                    }
                    fadeOut(t) {
                        return this._scheduleFading(t, 1, 0)
                    }
                    crossFadeFrom(t, e, n=!1) {
                        if (t.fadeOut(e),
                        this.fadeIn(e),
                        n === !0) {
                            const i = this._clip.duration
                              , a = t._clip.duration
                              , o = a / i
                              , u = i / a;
                            t.warp(1, o, e),
                            this.warp(u, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n=!1) {
                        return t.crossFadeFrom(this, e, n)
                    }
                    stopFading() {
                        const t = this._weightInterpolant;
                        return t !== null && (this._weightInterpolant = null,
                        this._mixer._takeBackControlInterpolant(t)),
                        this
                    }
                    setEffectiveTimeScale(t) {
                        return this.timeScale = t,
                        this._effectiveTimeScale = this.paused ? 0 : t,
                        this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(t) {
                        return this.timeScale = this._clip.duration / t,
                        this.stopWarping()
                    }
                    syncWith(t) {
                        return this.time = t.time,
                        this.timeScale = t.timeScale,
                        this.stopWarping()
                    }
                    halt(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    }
                    warp(t, e, n) {
                        const i = this._mixer
                          , a = i.time
                          , o = this.timeScale;
                        let u = this._timeScaleInterpolant;
                        u === null && (u = i._lendControlInterpolant(),
                        this._timeScaleInterpolant = u);
                        const f = u.parameterPositions
                          , d = u.sampleValues;
                        return f[0] = a,
                        f[1] = a + n,
                        d[0] = t / o,
                        d[1] = e / o,
                        this
                    }
                    stopWarping() {
                        const t = this._timeScaleInterpolant;
                        return t !== null && (this._timeScaleInterpolant = null,
                        this._mixer._takeBackControlInterpolant(t)),
                        this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(t, e, n, i) {
                        if (!this.enabled) {
                            this._updateWeight(t);
                            return
                        }
                        const a = this._startTime;
                        if (a !== null) {
                            const f = (t - a) * n;
                            f < 0 || n === 0 ? e = 0 : (this._startTime = null,
                            e = n * f)
                        }
                        e *= this._updateTimeScale(t);
                        const o = this._updateTime(e)
                          , u = this._updateWeight(t);
                        if (u > 0) {
                            const f = this._interpolants
                              , d = this._propertyBindings;
                            switch (this.blendMode) {
                            case Rx:
                                for (let p = 0, g = f.length; p !== g; ++p)
                                    f[p].evaluate(o),
                                    d[p].accumulateAdditive(u);
                                break;
                            case L0:
                            default:
                                for (let p = 0, g = f.length; p !== g; ++p)
                                    f[p].evaluate(o),
                                    d[p].accumulate(i, u)
                            }
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (n !== null) {
                                const i = n.evaluate(t)[0];
                                e *= i,
                                t > n.parameterPositions[1] && (this.stopFading(),
                                i === 0 && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e,
                        e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            if (n !== null) {
                                const i = n.evaluate(t)[0];
                                e *= i,
                                t > n.parameterPositions[1] && (this.stopWarping(),
                                e === 0 ? this.paused = !0 : this.timeScale = e)
                            }
                        }
                        return this._effectiveTimeScale = e,
                        e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration
                          , n = this.loop;
                        let i = this.time + t
                          , a = this._loopCount;
                        const o = n === z1;
                        if (t === 0)
                            return a === -1 ? i : o && (a & 1) === 1 ? e - i : i;
                        if (n === L1) {
                            a === -1 && (this._loopCount = 0,
                            this._setEndings(!0, !0, !1));
                            e: {
                                if (i >= e)
                                    i = e;
                                else if (i < 0)
                                    i = 0;
                                else {
                                    this.time = i;
                                    break e
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (a === -1 && (t >= 0 ? (a = 0,
                            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
                            i >= e || i < 0) {
                                const u = Math.floor(i / e);
                                i -= e * u,
                                a += Math.abs(u);
                                const f = this.repetitions - a;
                                if (f <= 0)
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    i = t > 0 ? e : 0,
                                    this.time = i,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t > 0 ? 1 : -1
                                    });
                                else {
                                    if (f === 1) {
                                        const d = t < 0;
                                        this._setEndings(d, !d, o)
                                    } else
                                        this._setEndings(!1, !1, o);
                                    this._loopCount = a,
                                    this.time = i,
                                    this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: u
                                    })
                                }
                            } else
                                this.time = i;
                            if (o && (a & 1) === 1)
                                return e - i
                        }
                        return i
                    }
                    _setEndings(t, e, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = bh,
                        i.endingEnd = bh) : (t ? i.endingStart = this.zeroSlopeAtStart ? bh : Mh : i.endingStart = mg,
                        e ? i.endingEnd = this.zeroSlopeAtEnd ? bh : Mh : i.endingEnd = mg)
                    }
                    _scheduleFading(t, e, n) {
                        const i = this._mixer
                          , a = i.time;
                        let o = this._weightInterpolant;
                        o === null && (o = i._lendControlInterpolant(),
                        this._weightInterpolant = o);
                        const u = o.parameterPositions
                          , f = o.sampleValues;
                        return u[0] = a,
                        f[0] = e,
                        u[1] = a + t,
                        f[1] = n,
                        this
                    }
                }
                ;
                const $U = new Float32Array(1);
                var eL = class extends cl {
                    constructor(t) {
                        super(),
                        this._root = t,
                        this._initMemoryManager(),
                        this._accuIndex = 0,
                        this.time = 0,
                        this.timeScale = 1
                    }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root
                          , i = t._clip.tracks
                          , a = i.length
                          , o = t._propertyBindings
                          , u = t._interpolants
                          , f = n.uuid
                          , d = this._bindingsByRootAndName;
                        let p = d[f];
                        p === void 0 && (p = {},
                        d[f] = p);
                        for (let g = 0; g !== a; ++g) {
                            const v = i[g]
                              , y = v.name;
                            let S = p[y];
                            if (S !== void 0)
                                ++S.referenceCount,
                                o[g] = S;
                            else {
                                if (S = o[g],
                                S !== void 0) {
                                    S._cacheIndex === null && (++S.referenceCount,
                                    this._addInactiveBinding(S, f, y));
                                    continue
                                }
                                const E = e && e._propertyBindings[g].binding.parsedPath;
                                S = new iC(ii.create(n, y, E),v.ValueTypeName,v.getValueSize()),
                                ++S.referenceCount,
                                this._addInactiveBinding(S, f, y),
                                o[g] = S
                            }
                            u[g].resultBuffer = S.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (t._cacheIndex === null) {
                                const n = (t._localRoot || this._root).uuid
                                  , i = t._clip.uuid
                                  , a = this._actionsByClip[i];
                                this._bindAction(t, a && a.knownActions[0]),
                                this._addInactiveAction(t, i, n)
                            }
                            const e = t._propertyBindings;
                            for (let n = 0, i = e.length; n !== i; ++n) {
                                const a = e[n];
                                a.useCount++ === 0 && (this._lendBinding(a),
                                a.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let n = 0, i = e.length; n !== i; ++n) {
                                const a = e[n];
                                --a.useCount === 0 && (a.restoreOriginalState(),
                                this._takeBackBinding(a))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [],
                        this._nActiveActions = 0,
                        this._actionsByClip = {},
                        this._bindings = [],
                        this._nActiveBindings = 0,
                        this._bindingsByRootAndName = {},
                        this._controlInterpolants = [],
                        this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(t) {
                        const e = t._cacheIndex;
                        return e !== null && e < this._nActiveActions
                    }
                    _addInactiveAction(t, e, n) {
                        const i = this._actions
                          , a = this._actionsByClip;
                        let o = a[e];
                        if (o === void 0)
                            o = {
                                knownActions: [t],
                                actionByRoot: {}
                            },
                            t._byClipCacheIndex = 0,
                            a[e] = o;
                        else {
                            const u = o.knownActions;
                            t._byClipCacheIndex = u.length,
                            u.push(t)
                        }
                        t._cacheIndex = i.length,
                        i.push(t),
                        o.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions
                          , n = e[e.length - 1]
                          , i = t._cacheIndex;
                        n._cacheIndex = i,
                        e[i] = n,
                        e.pop(),
                        t._cacheIndex = null;
                        const a = t._clip.uuid
                          , o = this._actionsByClip
                          , u = o[a]
                          , f = u.knownActions
                          , d = f[f.length - 1]
                          , p = t._byClipCacheIndex;
                        d._byClipCacheIndex = p,
                        f[p] = d,
                        f.pop(),
                        t._byClipCacheIndex = null;
                        const g = u.actionByRoot
                          , v = (t._localRoot || this._root).uuid;
                        delete g[v],
                        f.length === 0 && delete o[a],
                        this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let n = 0, i = e.length; n !== i; ++n) {
                            const a = e[n];
                            --a.referenceCount === 0 && this._removeInactiveBinding(a)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions
                          , n = t._cacheIndex
                          , i = this._nActiveActions++
                          , a = e[i];
                        t._cacheIndex = i,
                        e[i] = t,
                        a._cacheIndex = n,
                        e[n] = a
                    }
                    _takeBackAction(t) {
                        const e = this._actions
                          , n = t._cacheIndex
                          , i = --this._nActiveActions
                          , a = e[i];
                        t._cacheIndex = i,
                        e[i] = t,
                        a._cacheIndex = n,
                        e[n] = a
                    }
                    _addInactiveBinding(t, e, n) {
                        const i = this._bindingsByRootAndName
                          , a = this._bindings;
                        let o = i[e];
                        o === void 0 && (o = {},
                        i[e] = o),
                        o[n] = t,
                        t._cacheIndex = a.length,
                        a.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings
                          , n = t.binding
                          , i = n.rootNode.uuid
                          , a = n.path
                          , o = this._bindingsByRootAndName
                          , u = o[i]
                          , f = e[e.length - 1]
                          , d = t._cacheIndex;
                        f._cacheIndex = d,
                        e[d] = f,
                        e.pop(),
                        delete u[a],
                        Object.keys(u).length === 0 && delete o[i]
                    }
                    _lendBinding(t) {
                        const e = this._bindings
                          , n = t._cacheIndex
                          , i = this._nActiveBindings++
                          , a = e[i];
                        t._cacheIndex = i,
                        e[i] = t,
                        a._cacheIndex = n,
                        e[n] = a
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings
                          , n = t._cacheIndex
                          , i = --this._nActiveBindings
                          , a = e[i];
                        t._cacheIndex = i,
                        e[i] = t,
                        a._cacheIndex = n,
                        e[n] = a
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants
                          , e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return n === void 0 && (n = new PM(new Float32Array(2),new Float32Array(2),1,$U),
                        n.__cacheIndex = e,
                        t[e] = n),
                        n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants
                          , n = t.__cacheIndex
                          , i = --this._nActiveControlInterpolants
                          , a = e[i];
                        t.__cacheIndex = i,
                        e[i] = t,
                        a.__cacheIndex = n,
                        e[n] = a
                    }
                    clipAction(t, e, n) {
                        const i = e || this._root
                          , a = i.uuid;
                        let o = typeof t == "string" ? Wg.findByName(i, t) : t;
                        const u = o !== null ? o.uuid : t
                          , f = this._actionsByClip[u];
                        let d = null;
                        if (n === void 0 && (o !== null ? n = o.blendMode : n = L0),
                        f !== void 0) {
                            const g = f.actionByRoot[a];
                            if (g !== void 0 && g.blendMode === n)
                                return g;
                            d = f.knownActions[0],
                            o === null && (o = d._clip)
                        }
                        if (o === null)
                            return null;
                        const p = new sC(this,o,e,n);
                        return this._bindAction(p, d),
                        this._addInactiveAction(p, u, a),
                        p
                    }
                    existingAction(t, e) {
                        const n = e || this._root
                          , i = n.uuid
                          , a = typeof t == "string" ? Wg.findByName(n, t) : t
                          , o = a ? a.uuid : t
                          , u = this._actionsByClip[o];
                        return u !== void 0 && u.actionByRoot[i] || null
                    }
                    stopAllAction() {
                        const t = this._actions
                          , e = this._nActiveActions;
                        for (let n = e - 1; n >= 0; --n)
                            t[n].stop();
                        return this
                    }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions
                          , n = this._nActiveActions
                          , i = this.time += t
                          , a = Math.sign(t)
                          , o = this._accuIndex ^= 1;
                        for (let d = 0; d !== n; ++d)
                            e[d]._update(i, t, a, o);
                        const u = this._bindings
                          , f = this._nActiveBindings;
                        for (let d = 0; d !== f; ++d)
                            u[d].apply(o);
                        return this
                    }
                    setTime(t) {
                        this.time = 0;
                        for (let e = 0; e < this._actions.length; e++)
                            this._actions[e].time = 0;
                        return this.update(t)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(t) {
                        const e = this._actions
                          , n = t.uuid
                          , i = this._actionsByClip
                          , a = i[n];
                        if (a !== void 0) {
                            const o = a.knownActions;
                            for (let u = 0, f = o.length; u !== f; ++u) {
                                const d = o[u];
                                this._deactivateAction(d);
                                const p = d._cacheIndex
                                  , g = e[e.length - 1];
                                d._cacheIndex = null,
                                d._byClipCacheIndex = null,
                                g._cacheIndex = p,
                                e[p] = g,
                                e.pop(),
                                this._removeInactiveBindingsForAction(d)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid
                          , n = this._actionsByClip;
                        for (const a in n) {
                            const o = n[a].actionByRoot[e];
                            o !== void 0 && (this._deactivateAction(o),
                            this._removeInactiveAction(o))
                        }
                        const i = this._bindingsByRootAndName[e];
                        if (i !== void 0)
                            for (const a in i) {
                                const o = i[a];
                                o.restoreOriginalState(),
                                this._removeInactiveBinding(o)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        n !== null && (this._deactivateAction(n),
                        this._removeInactiveAction(n))
                    }
                }
                  , tL = class extends Bx {
                    constructor(t=1, e=1, n=1, i={}) {
                        super(t, e, i),
                        this.isRenderTarget3D = !0,
                        this.depth = n,
                        this.texture = new P0(null,t,e,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , nL = class kR {
                    constructor(e) {
                        this.value = e
                    }
                    clone() {
                        return new kR(this.value.clone === void 0 ? this.value : this.value.clone())
                    }
                }
                ;
                let iL = 0;
                var sL = class extends cl {
                    constructor() {
                        super(),
                        this.isUniformsGroup = !0,
                        Object.defineProperty(this, "id", {
                            value: iL++
                        }),
                        this.name = "",
                        this.usage = vg,
                        this.uniforms = []
                    }
                    add(t) {
                        return this.uniforms.push(t),
                        this
                    }
                    remove(t) {
                        const e = this.uniforms.indexOf(t);
                        return e !== -1 && this.uniforms.splice(e, 1),
                        this
                    }
                    setName(t) {
                        return this.name = t,
                        this
                    }
                    setUsage(t) {
                        return this.usage = t,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    copy(t) {
                        this.name = t.name,
                        this.usage = t.usage;
                        const e = t.uniforms;
                        this.uniforms.length = 0;
                        for (let n = 0, i = e.length; n < i; n++) {
                            const a = Array.isArray(e[n]) ? e[n] : [e[n]];
                            for (let o = 0; o < a.length; o++)
                                this.uniforms.push(a[o].clone())
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , aL = class extends iy {
                    constructor(t, e, n=1) {
                        super(t, e),
                        this.isInstancedInterleavedBuffer = !0,
                        this.meshPerAttribute = n
                    }
                    copy(t) {
                        return super.copy(t),
                        this.meshPerAttribute = t.meshPerAttribute,
                        this
                    }
                    clone(t) {
                        const e = super.clone(t);
                        return e.meshPerAttribute = this.meshPerAttribute,
                        e
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.isInstancedInterleavedBuffer = !0,
                        e.meshPerAttribute = this.meshPerAttribute,
                        e
                    }
                }
                  , rL = class {
                    constructor(t, e, n, i, a, o=!1) {
                        this.isGLBufferAttribute = !0,
                        this.name = "",
                        this.buffer = t,
                        this.type = e,
                        this.itemSize = n,
                        this.elementSize = i,
                        this.count = a,
                        this.normalized = o,
                        this.version = 0
                    }
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    }
                    setBuffer(t) {
                        return this.buffer = t,
                        this
                    }
                    setType(t, e) {
                        return this.type = t,
                        this.elementSize = e,
                        this
                    }
                    setItemSize(t) {
                        return this.itemSize = t,
                        this
                    }
                    setCount(t) {
                        return this.count = t,
                        this
                    }
                }
                ;
                const aC = new jt;
                var rC = class {
                    constructor(t, e, n=0, i=1 / 0) {
                        this.ray = new Id(t,e),
                        this.near = n,
                        this.far = i,
                        this.camera = null,
                        this.layers = new Bd,
                        this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(t, e) {
                        this.ray.set(t, e)
                    }
                    setFromCamera(t, e) {
                        e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
                        this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                        this.camera = e) : Rt("Raycaster: Unsupported camera type: " + e.type)
                    }
                    setFromXRController(t) {
                        return aC.identity().extractRotation(t.matrixWorld),
                        this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                        this.ray.direction.set(0, 0, -1).applyMatrix4(aC),
                        this
                    }
                    intersectObject(t, e=!0, n=[]) {
                        return KM(t, this, n, e),
                        n.sort(oC),
                        n
                    }
                    intersectObjects(t, e=!0, n=[]) {
                        for (let i = 0, a = t.length; i < a; i++)
                            KM(t[i], this, n, e);
                        return n.sort(oC),
                        n
                    }
                }
                ;
                function oC(t, e) {
                    return t.distance - e.distance
                }
                function KM(t, e, n, i) {
                    let a = !0;
                    if (t.layers.test(e.layers) && t.raycast(e, n) === !1 && (a = !1),
                    a === !0 && i === !0) {
                        const o = t.children;
                        for (let u = 0, f = o.length; u < f; u++)
                            KM(o[u], e, n, !0)
                    }
                }
                var oL = class {
                    constructor() {
                        this._previousTime = 0,
                        this._currentTime = 0,
                        this._startTime = performance.now(),
                        this._delta = 0,
                        this._elapsed = 0,
                        this._timescale = 1,
                        this._document = null,
                        this._pageVisibilityHandler = null
                    }
                    connect(t) {
                        this._document = t,
                        t.hidden !== void 0 && (this._pageVisibilityHandler = lL.bind(this),
                        t.addEventListener("visibilitychange", this._pageVisibilityHandler, !1))
                    }
                    disconnect() {
                        this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler),
                        this._pageVisibilityHandler = null),
                        this._document = null
                    }
                    getDelta() {
                        return this._delta / 1e3
                    }
                    getElapsed() {
                        return this._elapsed / 1e3
                    }
                    getTimescale() {
                        return this._timescale
                    }
                    setTimescale(t) {
                        return this._timescale = t,
                        this
                    }
                    reset() {
                        return this._currentTime = performance.now() - this._startTime,
                        this
                    }
                    dispose() {
                        this.disconnect()
                    }
                    update(t) {
                        return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime,
                        this._currentTime = (t !== void 0 ? t : performance.now()) - this._startTime,
                        this._delta = (this._currentTime - this._previousTime) * this._timescale,
                        this._elapsed += this._delta),
                        this
                    }
                }
                ;
                function lL() {
                    this._document.hidden === !1 && this.reset()
                }
                var cL = class {
                    constructor(t=1, e=0, n=0) {
                        this.radius = t,
                        this.phi = e,
                        this.theta = n
                    }
                    set(t, e, n) {
                        return this.radius = t,
                        this.phi = e,
                        this.theta = n,
                        this
                    }
                    copy(t) {
                        return this.radius = t.radius,
                        this.phi = t.phi,
                        this.theta = t.theta,
                        this
                    }
                    makeSafe() {
                        return this.phi = Ht(this.phi, 1e-6, Math.PI - 1e-6),
                        this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n),
                        this.radius === 0 ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(t, n),
                        this.phi = Math.acos(Ht(e / this.radius, -1, 1))),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , uL = class {
                    constructor(t=1, e=0, n=0) {
                        this.radius = t,
                        this.theta = e,
                        this.y = n
                    }
                    set(t, e, n) {
                        return this.radius = t,
                        this.theta = e,
                        this.y = n,
                        this
                    }
                    copy(t) {
                        return this.radius = t.radius,
                        this.theta = t.theta,
                        this.y = t.y,
                        this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + n * n),
                        this.theta = Math.atan2(t, n),
                        this.y = e,
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , hL = class qR {
                    constructor(e, n, i, a) {
                        qR.prototype.isMatrix2 = !0,
                        this.elements = [1, 0, 0, 1],
                        e !== void 0 && this.set(e, n, i, a)
                    }
                    identity() {
                        return this.set(1, 0, 0, 1),
                        this
                    }
                    fromArray(e, n=0) {
                        for (let i = 0; i < 4; i++)
                            this.elements[i] = e[i + n];
                        return this
                    }
                    set(e, n, i, a) {
                        const o = this.elements;
                        return o[0] = e,
                        o[2] = n,
                        o[1] = i,
                        o[3] = a,
                        this
                    }
                }
                ;
                const lC = new Ge;
                var fL = class {
                    constructor(t=new Ge(1 / 0,1 / 0), e=new Ge(-1 / 0,-1 / 0)) {
                        this.isBox2 = !0,
                        this.min = t,
                        this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t),
                        this.max.copy(e),
                        this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++)
                            this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = lC.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n),
                        this.max.copy(t).add(n),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min),
                        this.max.copy(t.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0,
                        this.max.x = this.max.y = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(t) {
                        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t),
                        this.max.max(t),
                        this
                    }
                    expandByVector(t) {
                        return this.min.sub(t),
                        this.max.add(t),
                        this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t),
                        this.max.addScalar(t),
                        this
                    }
                    containsPoint(t) {
                        return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    }
                    getParameter(t, e) {
                        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(t) {
                        return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return this.clampPoint(t, lC).distanceTo(t)
                    }
                    intersect(t) {
                        return this.min.max(t.min),
                        this.max.min(t.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(t) {
                        return this.min.min(t.min),
                        this.max.max(t.max),
                        this
                    }
                    translate(t) {
                        return this.min.add(t),
                        this.max.add(t),
                        this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                ;
                const cC = new J
                  , Dy = new J
                  , ap = new J
                  , rp = new J
                  , JM = new J
                  , dL = new J
                  , pL = new J;
                var mL = class {
                    constructor(t=new J, e=new J) {
                        this.start = t,
                        this.end = e
                    }
                    set(t, e) {
                        return this.start.copy(t),
                        this.end.copy(e),
                        this
                    }
                    copy(t) {
                        return this.start.copy(t.start),
                        this.end.copy(t.end),
                        this
                    }
                    getCenter(t) {
                        return t.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(t) {
                        return t.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(t, e) {
                        return this.delta(e).multiplyScalar(t).add(this.start)
                    }
                    closestPointToPointParameter(t, e) {
                        cC.subVectors(t, this.start),
                        Dy.subVectors(this.end, this.start);
                        const n = Dy.dot(Dy);
                        let i = Dy.dot(cC) / n;
                        return e && (i = Ht(i, 0, 1)),
                        i
                    }
                    closestPointToPoint(t, e, n) {
                        const i = this.closestPointToPointParameter(t, e);
                        return this.delta(n).multiplyScalar(i).add(this.start)
                    }
                    distanceSqToLine3(t, e=dL, n=pL) {
                        const i = 10000000000000001e-32;
                        let a, o;
                        const u = this.start
                          , f = t.start
                          , d = this.end
                          , p = t.end;
                        ap.subVectors(d, u),
                        rp.subVectors(p, f),
                        JM.subVectors(u, f);
                        const g = ap.dot(ap)
                          , v = rp.dot(rp)
                          , y = rp.dot(JM);
                        if (g <= i && v <= i)
                            return e.copy(u),
                            n.copy(f),
                            e.sub(n),
                            e.dot(e);
                        if (g <= i)
                            a = 0,
                            o = y / v,
                            o = Ht(o, 0, 1);
                        else {
                            const S = ap.dot(JM);
                            if (v <= i)
                                o = 0,
                                a = Ht(-S / g, 0, 1);
                            else {
                                const E = ap.dot(rp)
                                  , w = g * v - E * E;
                                w !== 0 ? a = Ht((E * y - S * v) / w, 0, 1) : a = 0,
                                o = (E * a + y) / v,
                                o < 0 ? (o = 0,
                                a = Ht(-S / g, 0, 1)) : o > 1 && (o = 1,
                                a = Ht((E - S) / g, 0, 1))
                            }
                        }
                        return e.copy(u).add(ap.multiplyScalar(a)),
                        n.copy(f).add(rp.multiplyScalar(o)),
                        e.sub(n),
                        e.dot(e)
                    }
                    applyMatrix4(t) {
                        return this.start.applyMatrix4(t),
                        this.end.applyMatrix4(t),
                        this
                    }
                    equals(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const uC = new J;
                var gL = class extends zn {
                    constructor(t, e) {
                        super(),
                        this.light = t,
                        this.matrixAutoUpdate = !1,
                        this.color = e,
                        this.type = "SpotLightHelper";
                        const n = new en
                          , i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let a = 0, o = 1, u = 32; a < u; a++,
                        o++) {
                            const f = a / u * Math.PI * 2
                              , d = o / u * Math.PI * 2;
                            i.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1)
                        }
                        n.setAttribute("position", new _t(i,3)),
                        this.cone = new fl(n,new _a({
                            fog: !1,
                            toneMapped: !1
                        })),
                        this.add(this.cone),
                        this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        this.parent ? (this.parent.updateWorldMatrix(!0),
                        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
                        this.matrixWorld.copy(this.light.matrixWorld);
                        const t = this.light.distance ? this.light.distance : 1e3
                          , e = t * Math.tan(this.light.angle);
                        this.cone.scale.set(e, e, t),
                        uC.setFromMatrixPosition(this.light.target.matrixWorld),
                        this.cone.lookAt(uC),
                        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                ;
                const mu = new J
                  , Oy = new jt
                  , $M = new jt;
                var vL = class extends fl {
                    constructor(t) {
                        const e = hC(t)
                          , n = new en
                          , i = []
                          , a = [];
                        for (let d = 0; d < e.length; d++) {
                            const p = e[d];
                            p.parent && p.parent.isBone && (i.push(0, 0, 0),
                            i.push(0, 0, 0),
                            a.push(0, 0, 0),
                            a.push(0, 0, 0))
                        }
                        n.setAttribute("position", new _t(i,3)),
                        n.setAttribute("color", new _t(a,3));
                        const o = new _a({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        });
                        super(n, o),
                        this.isSkeletonHelper = !0,
                        this.type = "SkeletonHelper",
                        this.root = t,
                        this.bones = e,
                        this.matrix = t.matrixWorld,
                        this.matrixAutoUpdate = !1;
                        const u = new ut(255)
                          , f = new ut(65280);
                        this.setColors(u, f)
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones
                          , n = this.geometry
                          , i = n.getAttribute("position");
                        $M.copy(this.root.matrixWorld).invert();
                        for (let a = 0, o = 0; a < e.length; a++) {
                            const u = e[a];
                            u.parent && u.parent.isBone && (Oy.multiplyMatrices($M, u.matrixWorld),
                            mu.setFromMatrixPosition(Oy),
                            i.setXYZ(o, mu.x, mu.y, mu.z),
                            Oy.multiplyMatrices($M, u.parent.matrixWorld),
                            mu.setFromMatrixPosition(Oy),
                            i.setXYZ(o + 1, mu.x, mu.y, mu.z),
                            o += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0,
                        super.updateMatrixWorld(t)
                    }
                    setColors(t, e) {
                        const n = this.geometry.getAttribute("color");
                        for (let i = 0; i < n.count; i += 2)
                            n.setXYZ(i, t.r, t.g, t.b),
                            n.setXYZ(i + 1, e.r, e.g, e.b);
                        return n.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function hC(t) {
                    const e = [];
                    t.isBone === !0 && e.push(t);
                    for (let n = 0; n < t.children.length; n++)
                        e.push(...hC(t.children[n]));
                    return e
                }
                var _L = class extends Ji {
                    constructor(t, e, n) {
                        const i = new DM(e,4,2)
                          , a = new uu({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                        super(i, a),
                        this.light = t,
                        this.color = n,
                        this.type = "PointLightHelper",
                        this.matrix = this.light.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                ;
                const yL = new J
                  , fC = new ut
                  , dC = new ut;
                var SL = class extends zn {
                    constructor(t, e, n) {
                        super(),
                        this.light = t,
                        this.matrix = t.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "HemisphereLightHelper";
                        const i = new NM(e);
                        i.rotateY(Math.PI * .5),
                        this.material = new uu({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }),
                        this.color === void 0 && (this.material.vertexColors = !0);
                        const a = i.getAttribute("position")
                          , o = new Float32Array(a.count * 3);
                        i.setAttribute("color", new Kn(o,3)),
                        this.add(new Ji(i,this.material)),
                        this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                    update() {
                        const t = this.children[0];
                        if (this.color !== void 0)
                            this.material.color.set(this.color);
                        else {
                            const e = t.geometry.getAttribute("color");
                            fC.copy(this.light.color),
                            dC.copy(this.light.groundColor);
                            for (let n = 0, i = e.count; n < i; n++) {
                                const a = n < i / 2 ? fC : dC;
                                e.setXYZ(n, a.r, a.g, a.b)
                            }
                            e.needsUpdate = !0
                        }
                        this.light.updateWorldMatrix(!0, !1),
                        t.lookAt(yL.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                  , xL = class extends fl {
                    constructor(t=10, e=10, n=4473924, i=8947848) {
                        n = new ut(n),
                        i = new ut(i);
                        const a = e / 2
                          , o = t / e
                          , u = t / 2
                          , f = []
                          , d = [];
                        for (let v = 0, y = 0, S = -u; v <= e; v++,
                        S += o) {
                            f.push(-u, 0, S, u, 0, S),
                            f.push(S, 0, -u, S, 0, u);
                            const E = v === a ? n : i;
                            E.toArray(d, y),
                            y += 3,
                            E.toArray(d, y),
                            y += 3,
                            E.toArray(d, y),
                            y += 3,
                            E.toArray(d, y),
                            y += 3
                        }
                        const p = new en;
                        p.setAttribute("position", new _t(f,3)),
                        p.setAttribute("color", new _t(d,3));
                        const g = new _a({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(p, g),
                        this.type = "GridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , ML = class extends fl {
                    constructor(t=10, e=16, n=8, i=64, a=4473924, o=8947848) {
                        a = new ut(a),
                        o = new ut(o);
                        const u = []
                          , f = [];
                        if (e > 1)
                            for (let g = 0; g < e; g++) {
                                const v = g / e * (Math.PI * 2)
                                  , y = Math.sin(v) * t
                                  , S = Math.cos(v) * t;
                                u.push(0, 0, 0),
                                u.push(y, 0, S);
                                const E = g & 1 ? a : o;
                                f.push(E.r, E.g, E.b),
                                f.push(E.r, E.g, E.b)
                            }
                        for (let g = 0; g < n; g++) {
                            const v = g & 1 ? a : o
                              , y = t - t / n * g;
                            for (let S = 0; S < i; S++) {
                                let E = S / i * (Math.PI * 2)
                                  , w = Math.sin(E) * y
                                  , A = Math.cos(E) * y;
                                u.push(w, 0, A),
                                f.push(v.r, v.g, v.b),
                                E = (S + 1) / i * (Math.PI * 2),
                                w = Math.sin(E) * y,
                                A = Math.cos(E) * y,
                                u.push(w, 0, A),
                                f.push(v.r, v.g, v.b)
                            }
                        }
                        const d = new en;
                        d.setAttribute("position", new _t(u,3)),
                        d.setAttribute("color", new _t(f,3));
                        const p = new _a({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(d, p),
                        this.type = "PolarGridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                const pC = new J
                  , Uy = new J
                  , mC = new J;
                var bL = class extends zn {
                    constructor(t, e, n) {
                        super(),
                        this.light = t,
                        this.matrix = t.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "DirectionalLightHelper",
                        e === void 0 && (e = 1);
                        let i = new en;
                        i.setAttribute("position", new _t([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3));
                        const a = new _a({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new du(i,a),
                        this.add(this.lightPlane),
                        i = new en,
                        i.setAttribute("position", new _t([0, 0, 0, 0, 0, 1],3)),
                        this.targetLine = new du(i,a),
                        this.add(this.targetLine),
                        this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(),
                        this.lightPlane.material.dispose(),
                        this.targetLine.geometry.dispose(),
                        this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        pC.setFromMatrixPosition(this.light.matrixWorld),
                        Uy.setFromMatrixPosition(this.light.target.matrixWorld),
                        mC.subVectors(Uy, pC),
                        this.lightPlane.lookAt(Uy),
                        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                        this.targetLine.lookAt(Uy),
                        this.targetLine.scale.z = mC.length()
                    }
                }
                ;
                const Ly = new J
                  , Ni = new ty;
                var TL = class extends fl {
                    constructor(t) {
                        const e = new en
                          , n = new _a({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        })
                          , i = []
                          , a = []
                          , o = {};
                        u("n1", "n2"),
                        u("n2", "n4"),
                        u("n4", "n3"),
                        u("n3", "n1"),
                        u("f1", "f2"),
                        u("f2", "f4"),
                        u("f4", "f3"),
                        u("f3", "f1"),
                        u("n1", "f1"),
                        u("n2", "f2"),
                        u("n3", "f3"),
                        u("n4", "f4"),
                        u("p", "n1"),
                        u("p", "n2"),
                        u("p", "n3"),
                        u("p", "n4"),
                        u("u1", "u2"),
                        u("u2", "u3"),
                        u("u3", "u1"),
                        u("c", "t"),
                        u("p", "c"),
                        u("cn1", "cn2"),
                        u("cn3", "cn4"),
                        u("cf1", "cf2"),
                        u("cf3", "cf4");
                        function u(S, E) {
                            f(S),
                            f(E)
                        }
                        function f(S) {
                            i.push(0, 0, 0),
                            a.push(0, 0, 0),
                            o[S] === void 0 && (o[S] = []),
                            o[S].push(i.length / 3 - 1)
                        }
                        e.setAttribute("position", new _t(i,3)),
                        e.setAttribute("color", new _t(a,3)),
                        super(e, n),
                        this.type = "CameraHelper",
                        this.camera = t,
                        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                        this.matrix = t.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.pointMap = o,
                        this.update();
                        const d = new ut(16755200)
                          , p = new ut(16711680)
                          , g = new ut(43775)
                          , v = new ut(16777215)
                          , y = new ut(3355443);
                        this.setColors(d, p, g, v, y)
                    }
                    setColors(t, e, n, i, a) {
                        const o = this.geometry.getAttribute("color");
                        return o.setXYZ(0, t.r, t.g, t.b),
                        o.setXYZ(1, t.r, t.g, t.b),
                        o.setXYZ(2, t.r, t.g, t.b),
                        o.setXYZ(3, t.r, t.g, t.b),
                        o.setXYZ(4, t.r, t.g, t.b),
                        o.setXYZ(5, t.r, t.g, t.b),
                        o.setXYZ(6, t.r, t.g, t.b),
                        o.setXYZ(7, t.r, t.g, t.b),
                        o.setXYZ(8, t.r, t.g, t.b),
                        o.setXYZ(9, t.r, t.g, t.b),
                        o.setXYZ(10, t.r, t.g, t.b),
                        o.setXYZ(11, t.r, t.g, t.b),
                        o.setXYZ(12, t.r, t.g, t.b),
                        o.setXYZ(13, t.r, t.g, t.b),
                        o.setXYZ(14, t.r, t.g, t.b),
                        o.setXYZ(15, t.r, t.g, t.b),
                        o.setXYZ(16, t.r, t.g, t.b),
                        o.setXYZ(17, t.r, t.g, t.b),
                        o.setXYZ(18, t.r, t.g, t.b),
                        o.setXYZ(19, t.r, t.g, t.b),
                        o.setXYZ(20, t.r, t.g, t.b),
                        o.setXYZ(21, t.r, t.g, t.b),
                        o.setXYZ(22, t.r, t.g, t.b),
                        o.setXYZ(23, t.r, t.g, t.b),
                        o.setXYZ(24, e.r, e.g, e.b),
                        o.setXYZ(25, e.r, e.g, e.b),
                        o.setXYZ(26, e.r, e.g, e.b),
                        o.setXYZ(27, e.r, e.g, e.b),
                        o.setXYZ(28, e.r, e.g, e.b),
                        o.setXYZ(29, e.r, e.g, e.b),
                        o.setXYZ(30, e.r, e.g, e.b),
                        o.setXYZ(31, e.r, e.g, e.b),
                        o.setXYZ(32, n.r, n.g, n.b),
                        o.setXYZ(33, n.r, n.g, n.b),
                        o.setXYZ(34, n.r, n.g, n.b),
                        o.setXYZ(35, n.r, n.g, n.b),
                        o.setXYZ(36, n.r, n.g, n.b),
                        o.setXYZ(37, n.r, n.g, n.b),
                        o.setXYZ(38, i.r, i.g, i.b),
                        o.setXYZ(39, i.r, i.g, i.b),
                        o.setXYZ(40, a.r, a.g, a.b),
                        o.setXYZ(41, a.r, a.g, a.b),
                        o.setXYZ(42, a.r, a.g, a.b),
                        o.setXYZ(43, a.r, a.g, a.b),
                        o.setXYZ(44, a.r, a.g, a.b),
                        o.setXYZ(45, a.r, a.g, a.b),
                        o.setXYZ(46, a.r, a.g, a.b),
                        o.setXYZ(47, a.r, a.g, a.b),
                        o.setXYZ(48, a.r, a.g, a.b),
                        o.setXYZ(49, a.r, a.g, a.b),
                        o.needsUpdate = !0,
                        this
                    }
                    update() {
                        const t = this.geometry
                          , e = this.pointMap
                          , n = 1
                          , i = 1;
                        let a, o;
                        if (Ni.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                        this.camera.reversedDepth === !0)
                            a = 1,
                            o = 0;
                        else if (this.camera.coordinateSystem === nr)
                            a = -1,
                            o = 1;
                        else if (this.camera.coordinateSystem === Ed)
                            a = 0,
                            o = 1;
                        else
                            throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem);
                        Fi("c", e, t, Ni, 0, 0, a),
                        Fi("t", e, t, Ni, 0, 0, o),
                        Fi("n1", e, t, Ni, -n, -i, a),
                        Fi("n2", e, t, Ni, n, -i, a),
                        Fi("n3", e, t, Ni, -n, i, a),
                        Fi("n4", e, t, Ni, n, i, a),
                        Fi("f1", e, t, Ni, -n, -i, o),
                        Fi("f2", e, t, Ni, n, -i, o),
                        Fi("f3", e, t, Ni, -n, i, o),
                        Fi("f4", e, t, Ni, n, i, o),
                        Fi("u1", e, t, Ni, n * .7, i * 1.1, a),
                        Fi("u2", e, t, Ni, -n * .7, i * 1.1, a),
                        Fi("u3", e, t, Ni, 0, i * 2, a),
                        Fi("cf1", e, t, Ni, -n, 0, o),
                        Fi("cf2", e, t, Ni, n, 0, o),
                        Fi("cf3", e, t, Ni, 0, -i, o),
                        Fi("cf4", e, t, Ni, 0, i, o),
                        Fi("cn1", e, t, Ni, -n, 0, a),
                        Fi("cn2", e, t, Ni, n, 0, a),
                        Fi("cn3", e, t, Ni, 0, -i, a),
                        Fi("cn4", e, t, Ni, 0, i, a),
                        t.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function Fi(t, e, n, i, a, o, u) {
                    Ly.set(a, o, u).unproject(i);
                    const f = e[t];
                    if (f !== void 0) {
                        const d = n.getAttribute("position");
                        for (let p = 0, g = f.length; p < g; p++)
                            d.setXYZ(f[p], Ly.x, Ly.y, Ly.z)
                    }
                }
                const Iy = new qs;
                var AL = class extends fl {
                    constructor(t, e=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , i = new Float32Array(24)
                          , a = new en;
                        a.setIndex(new Kn(n,1)),
                        a.setAttribute("position", new Kn(i,3)),
                        super(a, new _a({
                            color: e,
                            toneMapped: !1
                        })),
                        this.object = t,
                        this.type = "BoxHelper",
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    update() {
                        if (this.object !== void 0 && Iy.setFromObject(this.object),
                        Iy.isEmpty())
                            return;
                        const t = Iy.min
                          , e = Iy.max
                          , n = this.geometry.attributes.position
                          , i = n.array;
                        i[0] = e.x,
                        i[1] = e.y,
                        i[2] = e.z,
                        i[3] = t.x,
                        i[4] = e.y,
                        i[5] = e.z,
                        i[6] = t.x,
                        i[7] = t.y,
                        i[8] = e.z,
                        i[9] = e.x,
                        i[10] = t.y,
                        i[11] = e.z,
                        i[12] = e.x,
                        i[13] = e.y,
                        i[14] = t.z,
                        i[15] = t.x,
                        i[16] = e.y,
                        i[17] = t.z,
                        i[18] = t.x,
                        i[19] = t.y,
                        i[20] = t.z,
                        i[21] = e.x,
                        i[22] = t.y,
                        i[23] = t.z,
                        n.needsUpdate = !0,
                        this.geometry.computeBoundingSphere()
                    }
                    setFromObject(t) {
                        return this.object = t,
                        this.update(),
                        this
                    }
                    copy(t, e) {
                        return super.copy(t, e),
                        this.object = t.object,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , EL = class extends fl {
                    constructor(t, e=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
                          , a = new en;
                        a.setIndex(new Kn(n,1)),
                        a.setAttribute("position", new _t(i,3)),
                        super(a, new _a({
                            color: e,
                            toneMapped: !1
                        })),
                        this.box = t,
                        this.type = "Box3Helper",
                        this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(t) {
                        const e = this.box;
                        e.isEmpty() || (e.getCenter(this.position),
                        e.getSize(this.scale),
                        this.scale.multiplyScalar(.5),
                        super.updateMatrixWorld(t))
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , CL = class extends du {
                    constructor(t, e=1, n=16776960) {
                        const i = n
                          , a = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
                          , o = new en;
                        o.setAttribute("position", new _t(a,3)),
                        o.computeBoundingSphere(),
                        super(o, new _a({
                            color: i,
                            toneMapped: !1
                        })),
                        this.type = "PlaneHelper",
                        this.plane = t,
                        this.size = e;
                        const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
                          , f = new en;
                        f.setAttribute("position", new _t(u,3)),
                        f.computeBoundingSphere(),
                        this.add(new Ji(f,new uu({
                            color: i,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(t) {
                        this.position.set(0, 0, 0),
                        this.scale.set(.5 * this.size, .5 * this.size, 1),
                        this.lookAt(this.plane.normal),
                        this.translateZ(-this.plane.constant),
                        super.updateMatrixWorld(t)
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose(),
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                }
                ;
                const gC = new J;
                let zy, eb;
                var wL = class extends zn {
                    constructor(t=new J(0,0,1), e=new J(0,0,0), n=1, i=16776960, a=n * .2, o=a * .2) {
                        super(),
                        this.type = "ArrowHelper",
                        zy === void 0 && (zy = new en,
                        zy.setAttribute("position", new _t([0, 0, 0, 0, 1, 0],3)),
                        eb = new vM(.5,1,5,1),
                        eb.translate(0, -.5, 0)),
                        this.position.copy(e),
                        this.line = new du(zy,new _a({
                            color: i,
                            toneMapped: !1
                        })),
                        this.line.matrixAutoUpdate = !1,
                        this.add(this.line),
                        this.cone = new Ji(eb,new uu({
                            color: i,
                            toneMapped: !1
                        })),
                        this.cone.matrixAutoUpdate = !1,
                        this.add(this.cone),
                        this.setDirection(t),
                        this.setLength(n, a, o)
                    }
                    setDirection(t) {
                        if (t.y > .99999)
                            this.quaternion.set(0, 0, 0, 1);
                        else if (t.y < -.99999)
                            this.quaternion.set(1, 0, 0, 0);
                        else {
                            gC.set(t.z, 0, -t.x).normalize();
                            const e = Math.acos(t.y);
                            this.quaternion.setFromAxisAngle(gC, e)
                        }
                    }
                    setLength(t, e=t * .2, n=e * .2) {
                        this.line.scale.set(1, Math.max(1e-4, t - e), 1),
                        this.line.updateMatrix(),
                        this.cone.scale.set(n, e, n),
                        this.cone.position.y = t,
                        this.cone.updateMatrix()
                    }
                    setColor(t) {
                        this.line.material.color.set(t),
                        this.cone.material.color.set(t)
                    }
                    copy(t) {
                        return super.copy(t, !1),
                        this.line.copy(t.line),
                        this.cone.copy(t.cone),
                        this
                    }
                    dispose() {
                        this.line.geometry.dispose(),
                        this.line.material.dispose(),
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                }
                  , RL = class extends fl {
                    constructor(t=1) {
                        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]
                          , n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
                          , i = new en;
                        i.setAttribute("position", new _t(e,3)),
                        i.setAttribute("color", new _t(n,3));
                        const a = new _a({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(i, a),
                        this.type = "AxesHelper"
                    }
                    setColors(t, e, n) {
                        const i = new ut
                          , a = this.geometry.attributes.color.array;
                        return i.set(t),
                        i.toArray(a, 0),
                        i.toArray(a, 3),
                        i.set(e),
                        i.toArray(a, 6),
                        i.toArray(a, 9),
                        i.set(n),
                        i.toArray(a, 12),
                        i.toArray(a, 15),
                        this.geometry.attributes.color.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , NL = class {
                    constructor() {
                        this.type = "ShapePath",
                        this.color = new ut,
                        this.subPaths = [],
                        this.currentPath = null
                    }
                    moveTo(t, e) {
                        return this.currentPath = new Ey,
                        this.subPaths.push(this.currentPath),
                        this.currentPath.moveTo(t, e),
                        this
                    }
                    lineTo(t, e) {
                        return this.currentPath.lineTo(t, e),
                        this
                    }
                    quadraticCurveTo(t, e, n, i) {
                        return this.currentPath.quadraticCurveTo(t, e, n, i),
                        this
                    }
                    bezierCurveTo(t, e, n, i, a, o) {
                        return this.currentPath.bezierCurveTo(t, e, n, i, a, o),
                        this
                    }
                    splineThru(t) {
                        return this.currentPath.splineThru(t),
                        this
                    }
                    toShapes(t) {
                        function e(A) {
                            const T = [];
                            for (let R = 0, N = A.length; R < N; R++) {
                                const D = A[R]
                                  , U = new Oh;
                                U.curves = D.curves,
                                T.push(U)
                            }
                            return T
                        }
                        function n(A, T) {
                            const R = T.length;
                            let N = !1;
                            for (let D = R - 1, U = 0; U < R; D = U++) {
                                let z = T[D]
                                  , I = T[U]
                                  , V = I.x - z.x
                                  , B = I.y - z.y;
                                if (Math.abs(B) > Number.EPSILON) {
                                    if (B < 0 && (z = T[U],
                                    V = -V,
                                    I = T[D],
                                    B = -B),
                                    A.y < z.y || A.y > I.y)
                                        continue;
                                    if (A.y === z.y) {
                                        if (A.x === z.x)
                                            return !0
                                    } else {
                                        const P = B * (A.x - z.x) - V * (A.y - z.y);
                                        if (P === 0)
                                            return !0;
                                        if (P < 0)
                                            continue;
                                        N = !N
                                    }
                                } else {
                                    if (A.y !== z.y)
                                        continue;
                                    if (I.x <= A.x && A.x <= z.x || z.x <= A.x && A.x <= I.x)
                                        return !0
                                }
                            }
                            return N
                        }
                        const i = lc.isClockWise
                          , a = this.subPaths;
                        if (a.length === 0)
                            return [];
                        let o, u, f;
                        const d = [];
                        if (a.length === 1)
                            return u = a[0],
                            f = new Oh,
                            f.curves = u.curves,
                            d.push(f),
                            d;
                        let p = !i(a[0].getPoints());
                        p = t ? !p : p;
                        const g = []
                          , v = [];
                        let y = [], S = 0, E;
                        v[S] = void 0,
                        y[S] = [];
                        for (let A = 0, T = a.length; A < T; A++)
                            u = a[A],
                            E = u.getPoints(),
                            o = i(E),
                            o = t ? !o : o,
                            o ? (!p && v[S] && S++,
                            v[S] = {
                                s: new Oh,
                                p: E
                            },
                            v[S].s.curves = u.curves,
                            p && S++,
                            y[S] = []) : y[S].push({
                                h: u,
                                p: E[0]
                            });
                        if (!v[0])
                            return e(a);
                        if (v.length > 1) {
                            let A = !1
                              , T = 0;
                            for (let R = 0, N = v.length; R < N; R++)
                                g[R] = [];
                            for (let R = 0, N = v.length; R < N; R++) {
                                const D = y[R];
                                for (let U = 0; U < D.length; U++) {
                                    const z = D[U];
                                    let I = !0;
                                    for (let V = 0; V < v.length; V++)
                                        n(z.p, v[V].p) && (R !== V && T++,
                                        I ? (I = !1,
                                        g[V].push(z)) : A = !0);
                                    I && g[R].push(z)
                                }
                            }
                            T > 0 && A === !1 && (y = g)
                        }
                        let w;
                        for (let A = 0, T = v.length; A < T; A++) {
                            f = v[A].s,
                            d.push(f),
                            w = y[A];
                            for (let R = 0, N = w.length; R < N; R++)
                                f.holes.push(w[R].h)
                        }
                        return d
                    }
                }
                  , DL = class extends cl {
                    constructor(t, e=null) {
                        super(),
                        this.object = t,
                        this.domElement = e,
                        this.enabled = !0,
                        this.state = -1,
                        this.keys = {},
                        this.mouseButtons = {
                            LEFT: null,
                            MIDDLE: null,
                            RIGHT: null
                        },
                        this.touches = {
                            ONE: null,
                            TWO: null
                        }
                    }
                    connect(t) {
                        if (t === void 0) {
                            at("Controls: connect() now requires an element.");
                            return
                        }
                        this.domElement !== null && this.disconnect(),
                        this.domElement = t
                    }
                    disconnect() {}
                    dispose() {}
                    update() {}
                }
                ;
                function OL(t, e) {
                    const n = t.image && t.image.width ? t.image.width / t.image.height : 1;
                    return n > e ? (t.repeat.x = 1,
                    t.repeat.y = n / e,
                    t.offset.x = 0,
                    t.offset.y = (1 - t.repeat.y) / 2) : (t.repeat.x = e / n,
                    t.repeat.y = 1,
                    t.offset.x = (1 - t.repeat.x) / 2,
                    t.offset.y = 0),
                    t
                }
                function UL(t, e) {
                    const n = t.image && t.image.width ? t.image.width / t.image.height : 1;
                    return n > e ? (t.repeat.x = e / n,
                    t.repeat.y = 1,
                    t.offset.x = (1 - t.repeat.x) / 2,
                    t.offset.y = 0) : (t.repeat.x = 1,
                    t.repeat.y = n / e,
                    t.offset.x = 0,
                    t.offset.y = (1 - t.repeat.y) / 2),
                    t
                }
                function LL(t) {
                    return t.repeat.x = 1,
                    t.repeat.y = 1,
                    t.offset.x = 0,
                    t.offset.y = 0,
                    t
                }
                function tb(t, e, n, i) {
                    const a = IL(i);
                    switch (n) {
                    case Cx:
                        return t * e;
                    case K_:
                        return t * e / a.components * a.byteLength;
                    case cg:
                        return t * e / a.components * a.byteLength;
                    case xh:
                        return t * e * 2 / a.components * a.byteLength;
                    case J_:
                        return t * e * 2 / a.components * a.byteLength;
                    case wx:
                        return t * e * 3 / a.components * a.byteLength;
                    case Hs:
                        return t * e * 4 / a.components * a.byteLength;
                    case $_:
                        return t * e * 4 / a.components * a.byteLength;
                    case ug:
                    case hg:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
                    case fg:
                    case dg:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                    case t0:
                    case i0:
                        return Math.max(t, 16) * Math.max(e, 8) / 4;
                    case e0:
                    case n0:
                        return Math.max(t, 8) * Math.max(e, 8) / 2;
                    case s0:
                    case a0:
                    case o0:
                    case l0:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
                    case r0:
                    case c0:
                    case u0:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                    case h0:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                    case f0:
                        return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16;
                    case d0:
                        return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16;
                    case p0:
                        return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16;
                    case m0:
                        return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16;
                    case g0:
                        return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16;
                    case v0:
                        return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16;
                    case _0:
                        return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16;
                    case y0:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16;
                    case S0:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16;
                    case x0:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16;
                    case M0:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16;
                    case b0:
                        return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16;
                    case T0:
                        return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16;
                    case A0:
                    case E0:
                    case C0:
                        return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
                    case w0:
                    case R0:
                        return Math.ceil(t / 4) * Math.ceil(e / 4) * 8;
                    case N0:
                    case D0:
                        return Math.ceil(t / 4) * Math.ceil(e / 4) * 16
                    }
                    throw new Error(`Unable to determine texture byte length for ${n} format.`)
                }
                function IL(t) {
                    switch (t) {
                    case da:
                    case bx:
                        return {
                            byteLength: 1,
                            components: 1
                        };
                    case Td:
                    case Tx:
                    case ol:
                        return {
                            byteLength: 2,
                            components: 1
                        };
                    case Z_:
                    case Q_:
                        return {
                            byteLength: 2,
                            components: 4
                        };
                    case Ir:
                    case j_:
                    case pa:
                        return {
                            byteLength: 4,
                            components: 1
                        };
                    case Ax:
                    case Ex:
                        return {
                            byteLength: 4,
                            components: 3
                        }
                    }
                    throw new Error(`Unknown texture type ${t}.`)
                }
                var zL = class {
                    static contain(t, e) {
                        return OL(t, e)
                    }
                    static cover(t, e) {
                        return UL(t, e)
                    }
                    static fill(t) {
                        return LL(t)
                    }
                    static getByteLength(t, e, n, i) {
                        return tb(t, e, n, i)
                    }
                }
                ;
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                    detail: {
                        revision: z_
                    }
                })),
                typeof window < "u" && (window.__THREE__ ? at("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = z_);
                var BL = RN({
                    ACESFilmicToneMapping: () => W_,
                    AddEquation: () => Kc,
                    AddOperation: () => O1,
                    AdditiveAnimationBlendMode: () => Rx,
                    AdditiveBlending: () => fx,
                    AgXToneMapping: () => yx,
                    AlphaFormat: () => Cx,
                    AlwaysCompare: () => q1,
                    AlwaysDepth: () => F_,
                    AlwaysStencilFunc: () => Nx,
                    AmbientLight: () => qE,
                    AnimationAction: () => sC,
                    AnimationClip: () => Wg,
                    AnimationLoader: () => AU,
                    AnimationMixer: () => eL,
                    AnimationObjectGroup: () => JU,
                    AnimationUtils: () => xU,
                    ArcCurve: () => eE,
                    ArrayCamera: () => eC,
                    ArrowHelper: () => wL,
                    AttachedBindMode: () => xx,
                    Audio: () => tC,
                    AudioAnalyser: () => GU,
                    AudioContext: () => WM,
                    AudioListener: () => VU,
                    AudioLoader: () => zU,
                    AxesHelper: () => RL,
                    BackSide: () => fa,
                    BasicDepthPacking: () => B1,
                    BasicShadowMap: () => f1,
                    BatchedMesh: () => VA,
                    Bone: () => lM,
                    BooleanKeyframeTrack: () => Ih,
                    Box2: () => fL,
                    Box3: () => qs,
                    Box3Helper: () => EL,
                    BoxGeometry: () => Eg,
                    BoxHelper: () => AL,
                    BufferAttribute: () => Kn,
                    BufferGeometry: () => en,
                    BufferGeometryLoader: () => ZE,
                    ByteType: () => bx,
                    Cache: () => dl,
                    Camera: () => ty,
                    CameraHelper: () => TL,
                    CanvasTexture: () => qO,
                    CapsuleGeometry: () => QA,
                    CatmullRomCurve3: () => tE,
                    CineonToneMapping: () => vx,
                    CircleGeometry: () => KA,
                    ClampToEdgeWrapping: () => Ia,
                    Clock: () => YM,
                    Color: () => ut,
                    ColorKeyframeTrack: () => VM,
                    ColorManagement: () => xn,
                    CompressedArrayTexture: () => GO,
                    CompressedCubeTexture: () => kO,
                    CompressedTexture: () => yy,
                    CompressedTextureLoader: () => EU,
                    ConeGeometry: () => vM,
                    ConstantAlphaFactor: () => R1,
                    ConstantColorFactor: () => C1,
                    Controls: () => DL,
                    CubeCamera: () => gA,
                    CubeDepthTexture: () => ZA,
                    CubeReflectionMapping: () => al,
                    CubeRefractionMapping: () => Jc,
                    CubeTexture: () => Cg,
                    CubeTextureLoader: () => CU,
                    CubeUVReflectionMapping: () => Md,
                    CubicBezierCurve: () => bM,
                    CubicBezierCurve3: () => iE,
                    CubicInterpolant: () => LE,
                    CullFaceBack: () => hx,
                    CullFaceFront: () => h1,
                    CullFaceFrontBack: () => XN,
                    CullFaceNone: () => u1,
                    Curve: () => So,
                    CurvePath: () => aE,
                    CustomBlending: () => d1,
                    CustomToneMapping: () => _x,
                    CylinderGeometry: () => gM,
                    Cylindrical: () => uL,
                    Data3DTexture: () => P0,
                    DataArrayTexture: () => B0,
                    DataTexture: () => yo,
                    DataTextureLoader: () => wU,
                    DataUtils: () => dO,
                    DecrementStencilOp: () => cD,
                    DecrementWrapStencilOp: () => hD,
                    DefaultLoadingManager: () => BE,
                    DepthFormat: () => ll,
                    DepthStencilFormat: () => $c,
                    DepthTexture: () => ep,
                    DetachedBindMode: () => U1,
                    DirectionalLight: () => kE,
                    DirectionalLightHelper: () => bL,
                    DiscreteInterpolant: () => IE,
                    DodecahedronGeometry: () => JA,
                    DoubleSide: () => il,
                    DstAlphaFactor: () => M1,
                    DstColorFactor: () => T1,
                    DynamicCopyUsage: () => ED,
                    DynamicDrawUsage: () => SD,
                    DynamicReadUsage: () => bD,
                    EdgesGeometry: () => $A,
                    EllipseCurve: () => by,
                    EqualCompare: () => H1,
                    EqualDepth: () => G_,
                    EqualStencilFunc: () => mD,
                    EquirectangularReflectionMapping: () => sg,
                    EquirectangularRefractionMapping: () => ag,
                    Euler: () => vo,
                    EventDispatcher: () => cl,
                    ExternalTexture: () => mM,
                    ExtrudeGeometry: () => dE,
                    FileLoader: () => uc,
                    Float16BufferAttribute: () => SO,
                    Float32BufferAttribute: () => _t,
                    FloatType: () => pa,
                    Fog: () => _A,
                    FogExp2: () => vA,
                    FramebufferTexture: () => HO,
                    FrontSide: () => $l,
                    Frustum: () => $d,
                    FrustumArray: () => zA,
                    GLBufferAttribute: () => rL,
                    GLSL1: () => wD,
                    GLSL3: () => Dx,
                    GreaterCompare: () => G1,
                    GreaterDepth: () => q_,
                    GreaterEqualCompare: () => z0,
                    GreaterEqualDepth: () => k_,
                    GreaterEqualStencilFunc: () => yD,
                    GreaterStencilFunc: () => vD,
                    GridHelper: () => xL,
                    Group: () => Wd,
                    HalfFloatType: () => ol,
                    HemisphereLight: () => PE,
                    HemisphereLightHelper: () => SL,
                    IcosahedronGeometry: () => pE,
                    ImageBitmapLoader: () => IU,
                    ImageLoader: () => Yg,
                    ImageUtils: () => $1,
                    IncrementStencilOp: () => lD,
                    IncrementWrapStencilOp: () => uD,
                    InstancedBufferAttribute: () => Kd,
                    InstancedBufferGeometry: () => jE,
                    InstancedInterleavedBuffer: () => aL,
                    InstancedMesh: () => IA,
                    Int16BufferAttribute: () => _O,
                    Int32BufferAttribute: () => yO,
                    Int8BufferAttribute: () => mO,
                    IntType: () => j_,
                    InterleavedBuffer: () => iy,
                    InterleavedBufferAttribute: () => wg,
                    Interpolant: () => Gg,
                    InterpolateDiscrete: () => pg,
                    InterpolateLinear: () => O0,
                    InterpolateSmooth: () => U0,
                    InterpolationSamplingMode: () => DD,
                    InterpolationSamplingType: () => ND,
                    InvertStencilOp: () => fD,
                    KeepStencilOp: () => Th,
                    KeyframeTrack: () => Pr,
                    LOD: () => TA,
                    LatheGeometry: () => mE,
                    Layers: () => Bd,
                    LessCompare: () => F1,
                    LessDepth: () => H_,
                    LessEqualCompare: () => I0,
                    LessEqualDepth: () => Sh,
                    LessEqualStencilFunc: () => gD,
                    LessStencilFunc: () => pD,
                    Light: () => pu,
                    LightProbe: () => WE,
                    Line: () => du,
                    Line3: () => mL,
                    LineBasicMaterial: () => _a,
                    LineCurve: () => TM,
                    LineCurve3: () => sE,
                    LineDashedMaterial: () => OE,
                    LineLoop: () => qA,
                    LineSegments: () => fl,
                    LinearFilter: () => fi,
                    LinearInterpolant: () => PM,
                    LinearMipMapLinearFilter: () => ZN,
                    LinearMipMapNearestFilter: () => jN,
                    LinearMipmapLinearFilter: () => rl,
                    LinearMipmapNearestFilter: () => lg,
                    LinearSRGBColorSpace: () => tu,
                    LinearToneMapping: () => mx,
                    LinearTransfer: () => gg,
                    Loader: () => Va,
                    LoaderUtils: () => qM,
                    LoadingManager: () => FM,
                    LoopOnce: () => L1,
                    LoopPingPong: () => z1,
                    LoopRepeat: () => I1,
                    MOUSE: () => kN,
                    Material: () => Ws,
                    MaterialLoader: () => YE,
                    MathUtils: () => JD,
                    Matrix2: () => hL,
                    Matrix3: () => sn,
                    Matrix4: () => jt,
                    MaxEquation: () => v1,
                    Mesh: () => Ji,
                    MeshBasicMaterial: () => uu,
                    MeshDepthMaterial: () => LM,
                    MeshDistanceMaterial: () => IM,
                    MeshLambertMaterial: () => NE,
                    MeshMatcapMaterial: () => DE,
                    MeshNormalMaterial: () => RE,
                    MeshPhongMaterial: () => CE,
                    MeshPhysicalMaterial: () => EE,
                    MeshStandardMaterial: () => UM,
                    MeshToonMaterial: () => wE,
                    MinEquation: () => g1,
                    MirroredRepeatWrapping: () => og,
                    MixOperation: () => D1,
                    MultiplyBlending: () => px,
                    MultiplyOperation: () => ig,
                    NearestFilter: () => Vi,
                    NearestMipMapLinearFilter: () => YN,
                    NearestMipMapNearestFilter: () => WN,
                    NearestMipmapLinearFilter: () => bd,
                    NearestMipmapNearestFilter: () => Mx,
                    NeutralToneMapping: () => Sx,
                    NeverCompare: () => V1,
                    NeverDepth: () => V_,
                    NeverStencilFunc: () => dD,
                    NoBlending: () => sl,
                    NoColorSpace: () => ec,
                    NoNormalPacking: () => iD,
                    NoToneMapping: () => Lr,
                    NormalAnimationBlendMode: () => L0,
                    NormalBlending: () => yh,
                    NormalGAPacking: () => aD,
                    NormalRGPacking: () => sD,
                    NotEqualCompare: () => k1,
                    NotEqualDepth: () => X_,
                    NotEqualStencilFunc: () => _D,
                    NumberKeyframeTrack: () => kg,
                    Object3D: () => zn,
                    ObjectLoader: () => UU,
                    ObjectSpaceNormalMap: () => P1,
                    OctahedronGeometry: () => NM,
                    OneFactor: () => y1,
                    OneMinusConstantAlphaFactor: () => N1,
                    OneMinusConstantColorFactor: () => w1,
                    OneMinusDstAlphaFactor: () => b1,
                    OneMinusDstColorFactor: () => A1,
                    OneMinusSrcAlphaFactor: () => P_,
                    OneMinusSrcColorFactor: () => x1,
                    OrthographicCamera: () => sp,
                    PCFShadowMap: () => xd,
                    PCFSoftShadowMap: () => ng,
                    PMREMGenerator: () => rb,
                    Path: () => Ey,
                    PerspectiveCamera: () => _s,
                    Plane: () => fu,
                    PlaneGeometry: () => Ry,
                    PlaneHelper: () => CL,
                    PointLight: () => GE,
                    PointLightHelper: () => _L,
                    Points: () => WA,
                    PointsMaterial: () => dM,
                    PolarGridHelper: () => ML,
                    PolyhedronGeometry: () => tp,
                    PositionalAudio: () => HU,
                    PropertyBinding: () => ii,
                    PropertyMixer: () => iC,
                    QuadraticBezierCurve: () => AM,
                    QuadraticBezierCurve3: () => EM,
                    Quaternion: () => za,
                    QuaternionKeyframeTrack: () => qg,
                    QuaternionLinearInterpolant: () => zE,
                    R11_EAC_Format: () => o0,
                    RED_GREEN_RGTC2_Format: () => N0,
                    RED_RGTC1_Format: () => w0,
                    REVISION: () => z_,
                    RG11_EAC_Format: () => c0,
                    RGBADepthPacking: () => eD,
                    RGBAFormat: () => Hs,
                    RGBAIntegerFormat: () => $_,
                    RGBA_ASTC_10x10_Format: () => M0,
                    RGBA_ASTC_10x5_Format: () => y0,
                    RGBA_ASTC_10x6_Format: () => S0,
                    RGBA_ASTC_10x8_Format: () => x0,
                    RGBA_ASTC_12x10_Format: () => b0,
                    RGBA_ASTC_12x12_Format: () => T0,
                    RGBA_ASTC_4x4_Format: () => h0,
                    RGBA_ASTC_5x4_Format: () => f0,
                    RGBA_ASTC_5x5_Format: () => d0,
                    RGBA_ASTC_6x5_Format: () => p0,
                    RGBA_ASTC_6x6_Format: () => m0,
                    RGBA_ASTC_8x5_Format: () => g0,
                    RGBA_ASTC_8x6_Format: () => v0,
                    RGBA_ASTC_8x8_Format: () => _0,
                    RGBA_BPTC_Format: () => A0,
                    RGBA_ETC2_EAC_Format: () => r0,
                    RGBA_PVRTC_2BPPV1_Format: () => i0,
                    RGBA_PVRTC_4BPPV1_Format: () => n0,
                    RGBA_S3TC_DXT1_Format: () => hg,
                    RGBA_S3TC_DXT3_Format: () => fg,
                    RGBA_S3TC_DXT5_Format: () => dg,
                    RGBDepthPacking: () => tD,
                    RGBFormat: () => wx,
                    RGBIntegerFormat: () => QN,
                    RGB_BPTC_SIGNED_Format: () => E0,
                    RGB_BPTC_UNSIGNED_Format: () => C0,
                    RGB_ETC1_Format: () => s0,
                    RGB_ETC2_Format: () => a0,
                    RGB_PVRTC_2BPPV1_Format: () => t0,
                    RGB_PVRTC_4BPPV1_Format: () => e0,
                    RGB_S3TC_DXT1_Format: () => ug,
                    RGDepthPacking: () => nD,
                    RGFormat: () => xh,
                    RGIntegerFormat: () => J_,
                    RawShaderMaterial: () => OM,
                    Ray: () => Id,
                    Raycaster: () => rC,
                    RectAreaLight: () => XE,
                    RedFormat: () => K_,
                    RedIntegerFormat: () => cg,
                    ReinhardToneMapping: () => gx,
                    RenderTarget: () => Bx,
                    RenderTarget3D: () => tL,
                    RepeatWrapping: () => rg,
                    ReplaceStencilOp: () => oD,
                    ReverseSubtractEquation: () => m1,
                    RingGeometry: () => gE,
                    SIGNED_R11_EAC_Format: () => l0,
                    SIGNED_RED_GREEN_RGTC2_Format: () => D0,
                    SIGNED_RED_RGTC1_Format: () => R0,
                    SIGNED_RG11_EAC_Format: () => u0,
                    SRGBColorSpace: () => Gs,
                    SRGBTransfer: () => Vn,
                    Scene: () => iM,
                    ShaderChunk: () => an,
                    ShaderLib: () => xo,
                    ShaderMaterial: () => Br,
                    ShadowMaterial: () => AE,
                    Shape: () => Oh,
                    ShapeGeometry: () => vE,
                    ShapePath: () => NL,
                    ShapeUtils: () => lc,
                    ShortType: () => Tx,
                    Skeleton: () => OA,
                    SkeletonHelper: () => vL,
                    SkinnedMesh: () => NA,
                    Source: () => iu,
                    Sphere: () => As,
                    SphereGeometry: () => DM,
                    Spherical: () => cL,
                    SphericalHarmonics3: () => kM,
                    SplineCurve: () => CM,
                    SpotLight: () => HE,
                    SpotLightHelper: () => gL,
                    Sprite: () => MA,
                    SpriteMaterial: () => sM,
                    SrcAlphaFactor: () => B_,
                    SrcAlphaSaturateFactor: () => E1,
                    SrcColorFactor: () => S1,
                    StaticCopyUsage: () => AD,
                    StaticDrawUsage: () => vg,
                    StaticReadUsage: () => MD,
                    StereoCamera: () => BU,
                    StreamCopyUsage: () => CD,
                    StreamDrawUsage: () => xD,
                    StreamReadUsage: () => TD,
                    StringKeyframeTrack: () => zh,
                    SubtractEquation: () => p1,
                    SubtractiveBlending: () => dx,
                    TOUCH: () => qN,
                    TangentSpaceNormalMap: () => eu,
                    TetrahedronGeometry: () => _E,
                    Texture: () => gs,
                    TextureLoader: () => RU,
                    TextureUtils: () => zL,
                    Timer: () => oL,
                    TimestampQuery: () => RD,
                    TorusGeometry: () => yE,
                    TorusKnotGeometry: () => SE,
                    Triangle: () => lu,
                    TriangleFanDrawMode: () => $N,
                    TriangleStripDrawMode: () => JN,
                    TrianglesDrawMode: () => KN,
                    TubeGeometry: () => xE,
                    UVMapping: () => Y_,
                    Uint16BufferAttribute: () => Jx,
                    Uint32BufferAttribute: () => $x,
                    Uint8BufferAttribute: () => gO,
                    Uint8ClampedBufferAttribute: () => vO,
                    Uniform: () => nL,
                    UniformsGroup: () => sL,
                    UniformsLib: () => rt,
                    UniformsUtils: () => dA,
                    UnsignedByteType: () => da,
                    UnsignedInt101111Type: () => Ex,
                    UnsignedInt248Type: () => Ad,
                    UnsignedInt5999Type: () => Ax,
                    UnsignedIntType: () => Ir,
                    UnsignedShort4444Type: () => Z_,
                    UnsignedShort5551Type: () => Q_,
                    UnsignedShortType: () => Td,
                    VSMShadowMap: () => _h,
                    Vector2: () => Ge,
                    Vector3: () => J,
                    Vector4: () => di,
                    VectorKeyframeTrack: () => Xg,
                    VideoFrameTexture: () => FO,
                    VideoTexture: () => jA,
                    WebGL3DRenderTarget: () => iO,
                    WebGLArrayRenderTarget: () => nO,
                    WebGLCoordinateSystem: () => nr,
                    WebGLCubeRenderTarget: () => nM,
                    WebGLRenderTarget: () => sr,
                    WebGLRenderer: () => XC,
                    WebGLUtils: () => qC,
                    WebGPUCoordinateSystem: () => Ed,
                    WebXRController: () => ny,
                    WireframeGeometry: () => ME,
                    WrapAroundEnding: () => mg,
                    ZeroCurvatureEnding: () => Mh,
                    ZeroFactor: () => _1,
                    ZeroSlopeEnding: () => bh,
                    ZeroStencilOp: () => rD,
                    createCanvasElement: () => Y1,
                    error: () => Rt,
                    getConsoleFunction: () => LD,
                    log: () => yg,
                    setConsoleFunction: () => UD,
                    warn: () => at,
                    warnOnce: () => wd
                });
                function vC() {
                    let t = null
                      , e = !1
                      , n = null
                      , i = null;
                    function a(o, u) {
                        n(o, u),
                        i = t.requestAnimationFrame(a)
                    }
                    return {
                        start: function() {
                            e !== !0 && n !== null && (i = t.requestAnimationFrame(a),
                            e = !0)
                        },
                        stop: function() {
                            t.cancelAnimationFrame(i),
                            e = !1
                        },
                        setAnimationLoop: function(o) {
                            n = o
                        },
                        setContext: function(o) {
                            t = o
                        }
                    }
                }
                function PL(t) {
                    const e = new WeakMap;
                    function n(f, d) {
                        const p = f.array
                          , g = f.usage
                          , v = p.byteLength
                          , y = t.createBuffer();
                        t.bindBuffer(d, y),
                        t.bufferData(d, p, g),
                        f.onUploadCallback();
                        let S;
                        if (p instanceof Float32Array)
                            S = t.FLOAT;
                        else if (typeof Float16Array < "u" && p instanceof Float16Array)
                            S = t.HALF_FLOAT;
                        else if (p instanceof Uint16Array)
                            f.isFloat16BufferAttribute ? S = t.HALF_FLOAT : S = t.UNSIGNED_SHORT;
                        else if (p instanceof Int16Array)
                            S = t.SHORT;
                        else if (p instanceof Uint32Array)
                            S = t.UNSIGNED_INT;
                        else if (p instanceof Int32Array)
                            S = t.INT;
                        else if (p instanceof Int8Array)
                            S = t.BYTE;
                        else if (p instanceof Uint8Array)
                            S = t.UNSIGNED_BYTE;
                        else if (p instanceof Uint8ClampedArray)
                            S = t.UNSIGNED_BYTE;
                        else
                            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + p);
                        return {
                            buffer: y,
                            type: S,
                            bytesPerElement: p.BYTES_PER_ELEMENT,
                            version: f.version,
                            size: v
                        }
                    }
                    function i(f, d, p) {
                        const g = d.array
                          , v = d.updateRanges;
                        if (t.bindBuffer(p, f),
                        v.length === 0)
                            t.bufferSubData(p, 0, g);
                        else {
                            v.sort( (S, E) => S.start - E.start);
                            let y = 0;
                            for (let S = 1; S < v.length; S++) {
                                const E = v[y]
                                  , w = v[S];
                                w.start <= E.start + E.count + 1 ? E.count = Math.max(E.count, w.start + w.count - E.start) : (++y,
                                v[y] = w)
                            }
                            v.length = y + 1;
                            for (let S = 0, E = v.length; S < E; S++) {
                                const w = v[S];
                                t.bufferSubData(p, w.start * g.BYTES_PER_ELEMENT, g, w.start, w.count)
                            }
                            d.clearUpdateRanges()
                        }
                        d.onUploadCallback()
                    }
                    function a(f) {
                        return f.isInterleavedBufferAttribute && (f = f.data),
                        e.get(f)
                    }
                    function o(f) {
                        f.isInterleavedBufferAttribute && (f = f.data);
                        const d = e.get(f);
                        d && (t.deleteBuffer(d.buffer),
                        e.delete(f))
                    }
                    function u(f, d) {
                        if (f.isInterleavedBufferAttribute && (f = f.data),
                        f.isGLBufferAttribute) {
                            const g = e.get(f);
                            (!g || g.version < f.version) && e.set(f, {
                                buffer: f.buffer,
                                type: f.type,
                                bytesPerElement: f.elementSize,
                                version: f.version
                            });
                            return
                        }
                        const p = e.get(f);
                        if (p === void 0)
                            e.set(f, n(f, d));
                        else if (p.version < f.version) {
                            if (p.size !== f.array.byteLength)
                                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            i(p.buffer, f, d),
                            p.version = f.version
                        }
                    }
                    return {
                        get: a,
                        remove: o,
                        update: u
                    }
                }
                const an = {
                    alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
                    alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
                    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
                    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    alphatest_fragment: `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
                    alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
                    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
                    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
                    batching_pars_vertex: `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
                    batching_vertex: `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
                    begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
                    beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
                    bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
                    iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
                    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
                    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
                    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
                    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
                    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
                    color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
                    color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
                    color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
                    color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
                    common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
                    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
                    defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
                    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
                    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
                    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
                    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
                    envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
                    envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,
                    envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
                    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
                    envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
                    envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
                    fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
                    fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
                    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
                    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
                    gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
                    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
                    lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
                    lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
                    lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
                    lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
                    lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
                    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
                    lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
                    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.metalness = metalnessFactor;
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = vec3( 0.04 );
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
                    lights_physical_pars_fragment: `uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	vec3 diffuseContribution;
	vec3 specularColor;
	vec3 specularColorBlended;
	float roughness;
	float metalness;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
		vec3 iridescenceFresnelDielectric;
		vec3 iridescenceFresnelMetallic;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return v;
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColorBlended;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float rInv = 1.0 / ( roughness + 0.1 );
	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;
	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;
	float DG = exp( a * dotNV + b );
	return saturate( DG );
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;
	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;
	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
 
 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
 
 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );
 
 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );
 
 		irradiance *= sheenEnergyComp;
 
 	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		diffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectDiffuse += diffuse;
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;
 	#endif
	vec3 singleScatteringDielectric = vec3( 0.0 );
	vec3 multiScatteringDielectric = vec3( 0.0 );
	vec3 singleScatteringMetallic = vec3( 0.0 );
	vec3 multiScatteringMetallic = vec3( 0.0 );
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#endif
	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );
	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );
	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;
	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	vec3 indirectSpecular = radiance * singleScattering;
	indirectSpecular += multiScattering * cosineWeightedIrradiance;
	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		indirectSpecular *= sheenEnergyComp;
		indirectDiffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectSpecular += indirectSpecular;
	reflectedLight.indirectDiffuse += indirectDiffuse;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
                    lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );
		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
                    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
                    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
                    logdepthbuf_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
                    logdepthbuf_pars_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_pars_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
                    map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
                    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
                    map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
                    map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
                    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
                    morphinstance_vertex: `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
                    morphcolor_vertex: `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
                    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
                    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
                    normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
                    normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
                    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
                    clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
                    clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
                    clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
                    iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
                    opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
                    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
                    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
                    project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
                    dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
                    dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
                    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
                    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
                    shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#else
			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#endif
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#else
			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#endif
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#elif defined( SHADOWMAP_TYPE_BASIC )
			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#endif
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float interleavedGradientNoise( vec2 position ) {
			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );
		}
		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {
			const float goldenAngle = 2.399963229728653;
			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );
			float theta = float( sampleIndex ) * goldenAngle + phi;
			return vec2( cos( theta ), sin( theta ) ) * r;
		}
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
				float radius = shadowRadius * texelSize.x;
				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
				shadow = (
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )
				) * 0.2;
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#elif defined( SHADOWMAP_TYPE_VSM )
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;
				float mean = distribution.x;
				float variance = distribution.y * distribution.y;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					float hard_shadow = step( mean, shadowCoord.z );
				#else
					float hard_shadow = step( shadowCoord.z, mean );
				#endif
				if ( hard_shadow == 1.0 ) {
					shadow = 1.0;
				} else {
					variance = max( variance, 0.0000001 );
					float d = shadowCoord.z - mean;
					float p_max = variance / ( variance + d * d );
					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );
					shadow = max( hard_shadow, p_max );
				}
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#else
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				float depth = texture2D( shadowMap, shadowCoord.xy ).r;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					shadow = step( depth, shadowCoord.z );
				#else
					shadow = step( shadowCoord.z, depth );
				#endif
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#if defined( SHADOWMAP_TYPE_PCF )
	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float texelSize = shadowRadius / shadowMapSize.x;
			vec3 absDir = abs( bd3D );
			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );
			tangent = normalize( cross( bd3D, tangent ) );
			vec3 bitangent = cross( bd3D, tangent );
			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
			shadow = (
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )
			) * 0.2;
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#elif defined( SHADOWMAP_TYPE_BASIC )
	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float depth = textureCube( shadowMap, bd3D ).r;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadow = step( depth, dp );
			#else
				shadow = step( dp, depth );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#endif
	#endif
#endif`,
                    shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
                    shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
                    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
                    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
                    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
                    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
                    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
                    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
                    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
                    tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
                    tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
                    transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
                    transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
                    uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
                    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
                    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                    background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
                    distance_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                    distance_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );
}`,
                    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                    meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
                    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                    meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
 
		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;
 
 	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
                    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
                }
                  , rt = {
                    common: {
                        diffuse: {
                            value: new ut(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new sn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new sn
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new sn
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new sn
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        },
                        dfgLUT: {
                            value: null
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new sn
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new sn
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new sn
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new sn
                        },
                        normalScale: {
                            value: new Ge(1,1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new sn
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new sn
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new sn
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new sn
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new ut(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new ut(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new sn
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new sn
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new ut(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Ge(.5,.5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new sn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new sn
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                }
                  , xo = {
                    basic: {
                        uniforms: ga([rt.common, rt.specularmap, rt.envmap, rt.aomap, rt.lightmap, rt.fog]),
                        vertexShader: an.meshbasic_vert,
                        fragmentShader: an.meshbasic_frag
                    },
                    lambert: {
                        uniforms: ga([rt.common, rt.specularmap, rt.envmap, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.fog, rt.lights, {
                            emissive: {
                                value: new ut(0)
                            }
                        }]),
                        vertexShader: an.meshlambert_vert,
                        fragmentShader: an.meshlambert_frag
                    },
                    phong: {
                        uniforms: ga([rt.common, rt.specularmap, rt.envmap, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.fog, rt.lights, {
                            emissive: {
                                value: new ut(0)
                            },
                            specular: {
                                value: new ut(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: an.meshphong_vert,
                        fragmentShader: an.meshphong_frag
                    },
                    standard: {
                        uniforms: ga([rt.common, rt.envmap, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.roughnessmap, rt.metalnessmap, rt.fog, rt.lights, {
                            emissive: {
                                value: new ut(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: an.meshphysical_vert,
                        fragmentShader: an.meshphysical_frag
                    },
                    toon: {
                        uniforms: ga([rt.common, rt.aomap, rt.lightmap, rt.emissivemap, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.gradientmap, rt.fog, rt.lights, {
                            emissive: {
                                value: new ut(0)
                            }
                        }]),
                        vertexShader: an.meshtoon_vert,
                        fragmentShader: an.meshtoon_frag
                    },
                    matcap: {
                        uniforms: ga([rt.common, rt.bumpmap, rt.normalmap, rt.displacementmap, rt.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: an.meshmatcap_vert,
                        fragmentShader: an.meshmatcap_frag
                    },
                    points: {
                        uniforms: ga([rt.points, rt.fog]),
                        vertexShader: an.points_vert,
                        fragmentShader: an.points_frag
                    },
                    dashed: {
                        uniforms: ga([rt.common, rt.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: an.linedashed_vert,
                        fragmentShader: an.linedashed_frag
                    },
                    depth: {
                        uniforms: ga([rt.common, rt.displacementmap]),
                        vertexShader: an.depth_vert,
                        fragmentShader: an.depth_frag
                    },
                    normal: {
                        uniforms: ga([rt.common, rt.bumpmap, rt.normalmap, rt.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: an.meshnormal_vert,
                        fragmentShader: an.meshnormal_frag
                    },
                    sprite: {
                        uniforms: ga([rt.sprite, rt.fog]),
                        vertexShader: an.sprite_vert,
                        fragmentShader: an.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new sn
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: an.background_vert,
                        fragmentShader: an.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new sn
                            }
                        },
                        vertexShader: an.backgroundCube_vert,
                        fragmentShader: an.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: an.cube_vert,
                        fragmentShader: an.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: an.equirect_vert,
                        fragmentShader: an.equirect_frag
                    },
                    distance: {
                        uniforms: ga([rt.common, rt.displacementmap, {
                            referencePosition: {
                                value: new J
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: an.distance_vert,
                        fragmentShader: an.distance_frag
                    },
                    shadow: {
                        uniforms: ga([rt.lights, rt.fog, {
                            color: {
                                value: new ut(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: an.shadow_vert,
                        fragmentShader: an.shadow_frag
                    }
                };
                xo.physical = {
                    uniforms: ga([xo.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatMapTransform: {
                            value: new sn
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        clearcoatNormalMapTransform: {
                            value: new sn
                        },
                        clearcoatNormalScale: {
                            value: new Ge(1,1)
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatRoughnessMapTransform: {
                            value: new sn
                        },
                        dispersion: {
                            value: 0
                        },
                        iridescence: {
                            value: 0
                        },
                        iridescenceMap: {
                            value: null
                        },
                        iridescenceMapTransform: {
                            value: new sn
                        },
                        iridescenceIOR: {
                            value: 1.3
                        },
                        iridescenceThicknessMinimum: {
                            value: 100
                        },
                        iridescenceThicknessMaximum: {
                            value: 400
                        },
                        iridescenceThicknessMap: {
                            value: null
                        },
                        iridescenceThicknessMapTransform: {
                            value: new sn
                        },
                        sheen: {
                            value: 0
                        },
                        sheenColor: {
                            value: new ut(0)
                        },
                        sheenColorMap: {
                            value: null
                        },
                        sheenColorMapTransform: {
                            value: new sn
                        },
                        sheenRoughness: {
                            value: 1
                        },
                        sheenRoughnessMap: {
                            value: null
                        },
                        sheenRoughnessMapTransform: {
                            value: new sn
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionMapTransform: {
                            value: new sn
                        },
                        transmissionSamplerSize: {
                            value: new Ge
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        thicknessMapTransform: {
                            value: new sn
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new ut(0)
                        },
                        specularColor: {
                            value: new ut(1,1,1)
                        },
                        specularColorMap: {
                            value: null
                        },
                        specularColorMapTransform: {
                            value: new sn
                        },
                        specularIntensity: {
                            value: 1
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularIntensityMapTransform: {
                            value: new sn
                        },
                        anisotropyVector: {
                            value: new Ge
                        },
                        anisotropyMap: {
                            value: null
                        },
                        anisotropyMapTransform: {
                            value: new sn
                        }
                    }]),
                    vertexShader: an.meshphysical_vert,
                    fragmentShader: an.meshphysical_frag
                };
                const By = {
                    r: 0,
                    b: 0,
                    g: 0
                }
                  , kh = new vo
                  , VL = new jt;
                function FL(t, e, n, i, a, o, u) {
                    const f = new ut(0);
                    let d = o === !0 ? 0 : 1, p, g, v = null, y = 0, S = null;
                    function E(N) {
                        let D = N.isScene === !0 ? N.background : null;
                        return D && D.isTexture && (D = (N.backgroundBlurriness > 0 ? n : e).get(D)),
                        D
                    }
                    function w(N) {
                        let D = !1;
                        const U = E(N);
                        U === null ? T(f, d) : U && U.isColor && (T(U, 1),
                        D = !0);
                        const z = t.xr.getEnvironmentBlendMode();
                        z === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, u) : z === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, u),
                        (t.autoClear || D) && (i.buffers.depth.setTest(!0),
                        i.buffers.depth.setMask(!0),
                        i.buffers.color.setMask(!0),
                        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil))
                    }
                    function A(N, D) {
                        const U = E(D);
                        U && (U.isCubeTexture || U.mapping === Md) ? (g === void 0 && (g = new Ji(new Eg(1,1,1),new Br({
                            name: "BackgroundCubeMaterial",
                            uniforms: kd(xo.backgroundCube.uniforms),
                            vertexShader: xo.backgroundCube.vertexShader,
                            fragmentShader: xo.backgroundCube.fragmentShader,
                            side: fa,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        g.geometry.deleteAttribute("normal"),
                        g.geometry.deleteAttribute("uv"),
                        g.onBeforeRender = function(z, I, V) {
                            this.matrixWorld.copyPosition(V.matrixWorld)
                        }
                        ,
                        Object.defineProperty(g.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        a.update(g)),
                        kh.copy(D.backgroundRotation),
                        kh.x *= -1,
                        kh.y *= -1,
                        kh.z *= -1,
                        U.isCubeTexture && U.isRenderTargetTexture === !1 && (kh.y *= -1,
                        kh.z *= -1),
                        g.material.uniforms.envMap.value = U,
                        g.material.uniforms.flipEnvMap.value = U.isCubeTexture && U.isRenderTargetTexture === !1 ? -1 : 1,
                        g.material.uniforms.backgroundBlurriness.value = D.backgroundBlurriness,
                        g.material.uniforms.backgroundIntensity.value = D.backgroundIntensity,
                        g.material.uniforms.backgroundRotation.value.setFromMatrix4(VL.makeRotationFromEuler(kh)),
                        g.material.toneMapped = xn.getTransfer(U.colorSpace) !== Vn,
                        (v !== U || y !== U.version || S !== t.toneMapping) && (g.material.needsUpdate = !0,
                        v = U,
                        y = U.version,
                        S = t.toneMapping),
                        g.layers.enableAll(),
                        N.unshift(g, g.geometry, g.material, 0, 0, null)) : U && U.isTexture && (p === void 0 && (p = new Ji(new Ry(2,2),new Br({
                            name: "BackgroundMaterial",
                            uniforms: kd(xo.background.uniforms),
                            vertexShader: xo.background.vertexShader,
                            fragmentShader: xo.background.fragmentShader,
                            side: $l,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        p.geometry.deleteAttribute("normal"),
                        Object.defineProperty(p.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        a.update(p)),
                        p.material.uniforms.t2D.value = U,
                        p.material.uniforms.backgroundIntensity.value = D.backgroundIntensity,
                        p.material.toneMapped = xn.getTransfer(U.colorSpace) !== Vn,
                        U.matrixAutoUpdate === !0 && U.updateMatrix(),
                        p.material.uniforms.uvTransform.value.copy(U.matrix),
                        (v !== U || y !== U.version || S !== t.toneMapping) && (p.material.needsUpdate = !0,
                        v = U,
                        y = U.version,
                        S = t.toneMapping),
                        p.layers.enableAll(),
                        N.unshift(p, p.geometry, p.material, 0, 0, null))
                    }
                    function T(N, D) {
                        N.getRGB(By, fA(t)),
                        i.buffers.color.setClear(By.r, By.g, By.b, D, u)
                    }
                    function R() {
                        g !== void 0 && (g.geometry.dispose(),
                        g.material.dispose(),
                        g = void 0),
                        p !== void 0 && (p.geometry.dispose(),
                        p.material.dispose(),
                        p = void 0)
                    }
                    return {
                        getClearColor: function() {
                            return f
                        },
                        setClearColor: function(N, D=1) {
                            f.set(N),
                            d = D,
                            T(f, d)
                        },
                        getClearAlpha: function() {
                            return d
                        },
                        setClearAlpha: function(N) {
                            d = N,
                            T(f, d)
                        },
                        render: w,
                        addToRenderList: A,
                        dispose: R
                    }
                }
                function HL(t, e) {
                    const n = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                      , i = {}
                      , a = y(null);
                    let o = a
                      , u = !1;
                    function f(P, G, K, ee, te) {
                        let oe = !1;
                        const q = v(ee, K, G);
                        o !== q && (o = q,
                        p(o.object)),
                        oe = S(P, ee, K, te),
                        oe && E(P, ee, K, te),
                        te !== null && e.update(te, t.ELEMENT_ARRAY_BUFFER),
                        (oe || u) && (u = !1,
                        D(P, G, K, ee),
                        te !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(te).buffer))
                    }
                    function d() {
                        return t.createVertexArray()
                    }
                    function p(P) {
                        return t.bindVertexArray(P)
                    }
                    function g(P) {
                        return t.deleteVertexArray(P)
                    }
                    function v(P, G, K) {
                        const ee = K.wireframe === !0;
                        let te = i[P.id];
                        te === void 0 && (te = {},
                        i[P.id] = te);
                        let oe = te[G.id];
                        oe === void 0 && (oe = {},
                        te[G.id] = oe);
                        let q = oe[ee];
                        return q === void 0 && (q = y(d()),
                        oe[ee] = q),
                        q
                    }
                    function y(P) {
                        const G = []
                          , K = []
                          , ee = [];
                        for (let te = 0; te < n; te++)
                            G[te] = 0,
                            K[te] = 0,
                            ee[te] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: G,
                            enabledAttributes: K,
                            attributeDivisors: ee,
                            object: P,
                            attributes: {},
                            index: null
                        }
                    }
                    function S(P, G, K, ee) {
                        const te = o.attributes
                          , oe = G.attributes;
                        let q = 0;
                        const F = K.getAttributes();
                        for (const X in F)
                            if (F[X].location >= 0) {
                                const $ = te[X];
                                let ne = oe[X];
                                if (ne === void 0 && (X === "instanceMatrix" && P.instanceMatrix && (ne = P.instanceMatrix),
                                X === "instanceColor" && P.instanceColor && (ne = P.instanceColor)),
                                $ === void 0 || $.attribute !== ne || ne && $.data !== ne.data)
                                    return !0;
                                q++
                            }
                        return o.attributesNum !== q || o.index !== ee
                    }
                    function E(P, G, K, ee) {
                        const te = {}
                          , oe = G.attributes;
                        let q = 0;
                        const F = K.getAttributes();
                        for (const X in F)
                            if (F[X].location >= 0) {
                                let $ = oe[X];
                                $ === void 0 && (X === "instanceMatrix" && P.instanceMatrix && ($ = P.instanceMatrix),
                                X === "instanceColor" && P.instanceColor && ($ = P.instanceColor));
                                const ne = {};
                                ne.attribute = $,
                                $ && $.data && (ne.data = $.data),
                                te[X] = ne,
                                q++
                            }
                        o.attributes = te,
                        o.attributesNum = q,
                        o.index = ee
                    }
                    function w() {
                        const P = o.newAttributes;
                        for (let G = 0, K = P.length; G < K; G++)
                            P[G] = 0
                    }
                    function A(P) {
                        T(P, 0)
                    }
                    function T(P, G) {
                        const K = o.newAttributes
                          , ee = o.enabledAttributes
                          , te = o.attributeDivisors;
                        K[P] = 1,
                        ee[P] === 0 && (t.enableVertexAttribArray(P),
                        ee[P] = 1),
                        te[P] !== G && (t.vertexAttribDivisor(P, G),
                        te[P] = G)
                    }
                    function R() {
                        const P = o.newAttributes
                          , G = o.enabledAttributes;
                        for (let K = 0, ee = G.length; K < ee; K++)
                            G[K] !== P[K] && (t.disableVertexAttribArray(K),
                            G[K] = 0)
                    }
                    function N(P, G, K, ee, te, oe, q) {
                        q === !0 ? t.vertexAttribIPointer(P, G, K, te, oe) : t.vertexAttribPointer(P, G, K, ee, te, oe)
                    }
                    function D(P, G, K, ee) {
                        w();
                        const te = ee.attributes
                          , oe = K.getAttributes()
                          , q = G.defaultAttributeValues;
                        for (const F in oe) {
                            const X = oe[F];
                            if (X.location >= 0) {
                                let $ = te[F];
                                if ($ === void 0 && (F === "instanceMatrix" && P.instanceMatrix && ($ = P.instanceMatrix),
                                F === "instanceColor" && P.instanceColor && ($ = P.instanceColor)),
                                $ !== void 0) {
                                    const ne = $.normalized
                                      , ce = $.itemSize
                                      , k = e.get($);
                                    if (k === void 0)
                                        continue;
                                    const pe = k.buffer
                                      , Ae = k.type
                                      , ie = k.bytesPerElement
                                      , Me = Ae === t.INT || Ae === t.UNSIGNED_INT || $.gpuType === j_;
                                    if ($.isInterleavedBufferAttribute) {
                                        const we = $.data
                                          , Te = we.stride
                                          , Je = $.offset;
                                        if (we.isInstancedInterleavedBuffer) {
                                            for (let Ze = 0; Ze < X.locationSize; Ze++)
                                                T(X.location + Ze, we.meshPerAttribute);
                                            P.isInstancedMesh !== !0 && ee._maxInstanceCount === void 0 && (ee._maxInstanceCount = we.meshPerAttribute * we.count)
                                        } else
                                            for (let Ze = 0; Ze < X.locationSize; Ze++)
                                                A(X.location + Ze);
                                        t.bindBuffer(t.ARRAY_BUFFER, pe);
                                        for (let Ze = 0; Ze < X.locationSize; Ze++)
                                            N(X.location + Ze, ce / X.locationSize, Ae, ne, Te * ie, (Je + ce / X.locationSize * Ze) * ie, Me)
                                    } else {
                                        if ($.isInstancedBufferAttribute) {
                                            for (let we = 0; we < X.locationSize; we++)
                                                T(X.location + we, $.meshPerAttribute);
                                            P.isInstancedMesh !== !0 && ee._maxInstanceCount === void 0 && (ee._maxInstanceCount = $.meshPerAttribute * $.count)
                                        } else
                                            for (let we = 0; we < X.locationSize; we++)
                                                A(X.location + we);
                                        t.bindBuffer(t.ARRAY_BUFFER, pe);
                                        for (let we = 0; we < X.locationSize; we++)
                                            N(X.location + we, ce / X.locationSize, Ae, ne, ce * ie, ce / X.locationSize * we * ie, Me)
                                    }
                                } else if (q !== void 0) {
                                    const ne = q[F];
                                    if (ne !== void 0)
                                        switch (ne.length) {
                                        case 2:
                                            t.vertexAttrib2fv(X.location, ne);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(X.location, ne);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(X.location, ne);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(X.location, ne)
                                        }
                                }
                            }
                        }
                        R()
                    }
                    function U() {
                        V();
                        for (const P in i) {
                            const G = i[P];
                            for (const K in G) {
                                const ee = G[K];
                                for (const te in ee)
                                    g(ee[te].object),
                                    delete ee[te];
                                delete G[K]
                            }
                            delete i[P]
                        }
                    }
                    function z(P) {
                        if (i[P.id] === void 0)
                            return;
                        const G = i[P.id];
                        for (const K in G) {
                            const ee = G[K];
                            for (const te in ee)
                                g(ee[te].object),
                                delete ee[te];
                            delete G[K]
                        }
                        delete i[P.id]
                    }
                    function I(P) {
                        for (const G in i) {
                            const K = i[G];
                            if (K[P.id] === void 0)
                                continue;
                            const ee = K[P.id];
                            for (const te in ee)
                                g(ee[te].object),
                                delete ee[te];
                            delete K[P.id]
                        }
                    }
                    function V() {
                        B(),
                        u = !0,
                        o !== a && (o = a,
                        p(o.object))
                    }
                    function B() {
                        a.geometry = null,
                        a.program = null,
                        a.wireframe = !1
                    }
                    return {
                        setup: f,
                        reset: V,
                        resetDefaultState: B,
                        dispose: U,
                        releaseStatesOfGeometry: z,
                        releaseStatesOfProgram: I,
                        initAttributes: w,
                        enableAttribute: A,
                        disableUnusedAttributes: R
                    }
                }
                function GL(t, e, n) {
                    let i;
                    function a(p) {
                        i = p
                    }
                    function o(p, g) {
                        t.drawArrays(i, p, g),
                        n.update(g, i, 1)
                    }
                    function u(p, g, v) {
                        v !== 0 && (t.drawArraysInstanced(i, p, g, v),
                        n.update(g, i, v))
                    }
                    function f(p, g, v) {
                        if (v === 0)
                            return;
                        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, p, 0, g, 0, v);
                        let y = 0;
                        for (let S = 0; S < v; S++)
                            y += g[S];
                        n.update(y, i, 1)
                    }
                    function d(p, g, v, y) {
                        if (v === 0)
                            return;
                        const S = e.get("WEBGL_multi_draw");
                        if (S === null)
                            for (let E = 0; E < p.length; E++)
                                u(p[E], g[E], y[E]);
                        else {
                            S.multiDrawArraysInstancedWEBGL(i, p, 0, g, 0, y, 0, v);
                            let E = 0;
                            for (let w = 0; w < v; w++)
                                E += g[w] * y[w];
                            n.update(E, i, 1)
                        }
                    }
                    this.setMode = a,
                    this.render = o,
                    this.renderInstances = u,
                    this.renderMultiDraw = f,
                    this.renderMultiDrawInstances = d
                }
                function kL(t, e, n, i) {
                    let a;
                    function o() {
                        if (a !== void 0)
                            return a;
                        if (e.has("EXT_texture_filter_anisotropic") === !0) {
                            const I = e.get("EXT_texture_filter_anisotropic");
                            a = t.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else
                            a = 0;
                        return a
                    }
                    function u(I) {
                        return !(I !== Hs && i.convert(I) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT))
                    }
                    function f(I) {
                        const V = I === ol && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
                        return !(I !== da && i.convert(I) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) && I !== pa && !V)
                    }
                    function d(I) {
                        if (I === "highp") {
                            if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                                return "highp";
                            I = "mediump"
                        }
                        return I === "mediump" && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                    }
                    let p = n.precision !== void 0 ? n.precision : "highp";
                    const g = d(p);
                    g !== p && (at("WebGLRenderer:", p, "not supported, using", g, "instead."),
                    p = g);
                    const v = n.logarithmicDepthBuffer === !0
                      , y = n.reversedDepthBuffer === !0 && e.has("EXT_clip_control")
                      , S = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                      , E = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                      , w = t.getParameter(t.MAX_TEXTURE_SIZE)
                      , A = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
                      , T = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                      , R = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
                      , N = t.getParameter(t.MAX_VARYING_VECTORS)
                      , D = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
                      , U = t.getParameter(t.MAX_SAMPLES)
                      , z = t.getParameter(t.SAMPLES);
                    return {
                        isWebGL2: !0,
                        getMaxAnisotropy: o,
                        getMaxPrecision: d,
                        textureFormatReadable: u,
                        textureTypeReadable: f,
                        precision: p,
                        logarithmicDepthBuffer: v,
                        reversedDepthBuffer: y,
                        maxTextures: S,
                        maxVertexTextures: E,
                        maxTextureSize: w,
                        maxCubemapSize: A,
                        maxAttributes: T,
                        maxVertexUniforms: R,
                        maxVaryings: N,
                        maxFragmentUniforms: D,
                        maxSamples: U,
                        samples: z
                    }
                }
                function qL(t) {
                    const e = this;
                    let n = null
                      , i = 0
                      , a = !1
                      , o = !1;
                    const u = new fu
                      , f = new sn
                      , d = {
                        value: null,
                        needsUpdate: !1
                    };
                    this.uniform = d,
                    this.numPlanes = 0,
                    this.numIntersection = 0,
                    this.init = function(v, y) {
                        const S = v.length !== 0 || y || i !== 0 || a;
                        return a = y,
                        i = v.length,
                        S
                    }
                    ,
                    this.beginShadows = function() {
                        o = !0,
                        g(null)
                    }
                    ,
                    this.endShadows = function() {
                        o = !1
                    }
                    ,
                    this.setGlobalState = function(v, y) {
                        n = g(v, y, 0)
                    }
                    ,
                    this.setState = function(v, y, S) {
                        const E = v.clippingPlanes
                          , w = v.clipIntersection
                          , A = v.clipShadows
                          , T = t.get(v);
                        if (!a || E === null || E.length === 0 || o && !A)
                            o ? g(null) : p();
                        else {
                            const R = o ? 0 : i
                              , N = R * 4;
                            let D = T.clippingState || null;
                            d.value = D,
                            D = g(E, y, N, S);
                            for (let U = 0; U !== N; ++U)
                                D[U] = n[U];
                            T.clippingState = D,
                            this.numIntersection = w ? this.numPlanes : 0,
                            this.numPlanes += R
                        }
                    }
                    ;
                    function p() {
                        d.value !== n && (d.value = n,
                        d.needsUpdate = i > 0),
                        e.numPlanes = i,
                        e.numIntersection = 0
                    }
                    function g(v, y, S, E) {
                        const w = v !== null ? v.length : 0;
                        let A = null;
                        if (w !== 0) {
                            if (A = d.value,
                            E !== !0 || A === null) {
                                const T = S + w * 4
                                  , R = y.matrixWorldInverse;
                                f.getNormalMatrix(R),
                                (A === null || A.length < T) && (A = new Float32Array(T));
                                for (let N = 0, D = S; N !== w; ++N,
                                D += 4)
                                    u.copy(v[N]).applyMatrix4(R, f),
                                    u.normal.toArray(A, D),
                                    A[D + 3] = u.constant
                            }
                            d.value = A,
                            d.needsUpdate = !0
                        }
                        return e.numPlanes = w,
                        e.numIntersection = 0,
                        A
                    }
                }
                function XL(t) {
                    let e = new WeakMap;
                    function n(u, f) {
                        return f === sg ? u.mapping = al : f === ag && (u.mapping = Jc),
                        u
                    }
                    function i(u) {
                        if (u && u.isTexture) {
                            const f = u.mapping;
                            if (f === sg || f === ag)
                                if (e.has(u)) {
                                    const d = e.get(u).texture;
                                    return n(d, u.mapping)
                                } else {
                                    const d = u.image;
                                    if (d && d.height > 0) {
                                        const p = new nM(d.height);
                                        return p.fromEquirectangularTexture(t, u),
                                        e.set(u, p),
                                        u.addEventListener("dispose", a),
                                        n(p.texture, u.mapping)
                                    } else
                                        return null
                                }
                        }
                        return u
                    }
                    function a(u) {
                        const f = u.target;
                        f.removeEventListener("dispose", a);
                        const d = e.get(f);
                        d !== void 0 && (e.delete(f),
                        d.dispose())
                    }
                    function o() {
                        e = new WeakMap
                    }
                    return {
                        get: i,
                        dispose: o
                    }
                }
                const gu = 4
                  , _C = [.125, .215, .35, .446, .526, .582]
                  , qh = 20
                  , WL = 256
                  , jg = new sp
                  , yC = new ut;
                let nb = null
                  , ib = 0
                  , sb = 0
                  , ab = !1;
                const YL = new J;
                var rb = class {
                    constructor(t) {
                        this._renderer = t,
                        this._pingPongRenderTarget = null,
                        this._lodMax = 0,
                        this._cubeSize = 0,
                        this._sizeLods = [],
                        this._sigmas = [],
                        this._lodMeshes = [],
                        this._backgroundBox = null,
                        this._cubemapMaterial = null,
                        this._equirectMaterial = null,
                        this._blurMaterial = null,
                        this._ggxMaterial = null
                    }
                    fromScene(t, e=0, n=.1, i=100, a={}) {
                        const {size: o=256, position: u=YL} = a;
                        nb = this._renderer.getRenderTarget(),
                        ib = this._renderer.getActiveCubeFace(),
                        sb = this._renderer.getActiveMipmapLevel(),
                        ab = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1,
                        this._setSize(o);
                        const f = this._allocateTargets();
                        return f.depthBuffer = !0,
                        this._sceneToCubeUV(t, n, i, f, u),
                        e > 0 && this._blur(f, 0, 0, e),
                        this._applyPMREM(f),
                        this._cleanup(f),
                        f
                    }
                    fromEquirectangular(t, e=null) {
                        return this._fromTexture(t, e)
                    }
                    fromCubemap(t, e=null) {
                        return this._fromTexture(t, e)
                    }
                    compileCubemapShader() {
                        this._cubemapMaterial === null && (this._cubemapMaterial = MC(),
                        this._compileMaterial(this._cubemapMaterial))
                    }
                    compileEquirectangularShader() {
                        this._equirectMaterial === null && (this._equirectMaterial = xC(),
                        this._compileMaterial(this._equirectMaterial))
                    }
                    dispose() {
                        this._dispose(),
                        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                        this._equirectMaterial !== null && this._equirectMaterial.dispose(),
                        this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(),
                        this._backgroundBox.material.dispose())
                    }
                    _setSize(t) {
                        this._lodMax = Math.floor(Math.log2(t)),
                        this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        this._blurMaterial !== null && this._blurMaterial.dispose(),
                        this._ggxMaterial !== null && this._ggxMaterial.dispose(),
                        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                        for (let t = 0; t < this._lodMeshes.length; t++)
                            this._lodMeshes[t].geometry.dispose()
                    }
                    _cleanup(t) {
                        this._renderer.setRenderTarget(nb, ib, sb),
                        this._renderer.xr.enabled = ab,
                        t.scissorTest = !1,
                        op(t, 0, 0, t.width, t.height)
                    }
                    _fromTexture(t, e) {
                        t.mapping === al || t.mapping === Jc ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4),
                        nb = this._renderer.getRenderTarget(),
                        ib = this._renderer.getActiveCubeFace(),
                        sb = this._renderer.getActiveMipmapLevel(),
                        ab = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1;
                        const n = e || this._allocateTargets();
                        return this._textureToCubeUV(t, n),
                        this._applyPMREM(n),
                        this._cleanup(n),
                        n
                    }
                    _allocateTargets() {
                        const t = 3 * Math.max(this._cubeSize, 112)
                          , e = 4 * this._cubeSize
                          , n = {
                            magFilter: fi,
                            minFilter: fi,
                            generateMipmaps: !1,
                            type: ol,
                            format: Hs,
                            colorSpace: tu,
                            depthBuffer: !1
                        }
                          , i = SC(t, e, n);
                        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                            this._pingPongRenderTarget !== null && this._dispose(),
                            this._pingPongRenderTarget = SC(t, e, n);
                            const {_lodMax: a} = this;
                            ({lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas} = jL(a)),
                            this._blurMaterial = QL(a, t, e),
                            this._ggxMaterial = ZL(a, t, e)
                        }
                        return i
                    }
                    _compileMaterial(t) {
                        const e = new Ji(new en,t);
                        this._renderer.compile(e, jg)
                    }
                    _sceneToCubeUV(t, e, n, i, a) {
                        const o = new _s(90,1,e,n)
                          , u = [1, -1, 1, 1, 1, 1]
                          , f = [1, 1, 1, -1, -1, -1]
                          , d = this._renderer
                          , p = d.autoClear
                          , g = d.toneMapping;
                        d.getClearColor(yC),
                        d.toneMapping = Lr,
                        d.autoClear = !1,
                        d.state.buffers.depth.getReversed() && (d.setRenderTarget(i),
                        d.clearDepth(),
                        d.setRenderTarget(null)),
                        this._backgroundBox === null && (this._backgroundBox = new Ji(new Eg,new uu({
                            name: "PMREM.Background",
                            side: fa,
                            depthWrite: !1,
                            depthTest: !1
                        })));
                        const v = this._backgroundBox
                          , y = v.material;
                        let S = !1;
                        const E = t.background;
                        E ? E.isColor && (y.color.copy(E),
                        t.background = null,
                        S = !0) : (y.color.copy(yC),
                        S = !0);
                        for (let w = 0; w < 6; w++) {
                            const A = w % 3;
                            A === 0 ? (o.up.set(0, u[w], 0),
                            o.position.set(a.x, a.y, a.z),
                            o.lookAt(a.x + f[w], a.y, a.z)) : A === 1 ? (o.up.set(0, 0, u[w]),
                            o.position.set(a.x, a.y, a.z),
                            o.lookAt(a.x, a.y + f[w], a.z)) : (o.up.set(0, u[w], 0),
                            o.position.set(a.x, a.y, a.z),
                            o.lookAt(a.x, a.y, a.z + f[w]));
                            const T = this._cubeSize;
                            op(i, A * T, w > 2 ? T : 0, T, T),
                            d.setRenderTarget(i),
                            S && d.render(v, o),
                            d.render(t, o)
                        }
                        d.toneMapping = g,
                        d.autoClear = p,
                        t.background = E
                    }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer
                          , i = t.mapping === al || t.mapping === Jc;
                        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = MC()),
                        this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = xC());
                        const a = i ? this._cubemapMaterial : this._equirectMaterial
                          , o = this._lodMeshes[0];
                        o.material = a;
                        const u = a.uniforms;
                        u.envMap.value = t;
                        const f = this._cubeSize;
                        op(e, 0, 0, 3 * f, 2 * f),
                        n.setRenderTarget(e),
                        n.render(o, jg)
                    }
                    _applyPMREM(t) {
                        const e = this._renderer
                          , n = e.autoClear;
                        e.autoClear = !1;
                        const i = this._lodMeshes.length;
                        for (let a = 1; a < i; a++)
                            this._applyGGXFilter(t, a - 1, a);
                        e.autoClear = n
                    }
                    _applyGGXFilter(t, e, n) {
                        const i = this._renderer
                          , a = this._pingPongRenderTarget
                          , o = this._ggxMaterial
                          , u = this._lodMeshes[n];
                        u.material = o;
                        const f = o.uniforms
                          , d = n / (this._lodMeshes.length - 1)
                          , p = e / (this._lodMeshes.length - 1)
                          , g = Math.sqrt(d * d - p * p) * (0 + d * 1.25)
                          , {_lodMax: v} = this
                          , y = this._sizeLods[n]
                          , S = 3 * y * (n > v - gu ? n - v + gu : 0)
                          , E = 4 * (this._cubeSize - y);
                        f.envMap.value = t.texture,
                        f.roughness.value = g,
                        f.mipInt.value = v - e,
                        op(a, S, E, 3 * y, 2 * y),
                        i.setRenderTarget(a),
                        i.render(u, jg),
                        f.envMap.value = a.texture,
                        f.roughness.value = 0,
                        f.mipInt.value = v - n,
                        op(t, S, E, 3 * y, 2 * y),
                        i.setRenderTarget(t),
                        i.render(u, jg)
                    }
                    _blur(t, e, n, i, a) {
                        const o = this._pingPongRenderTarget;
                        this._halfBlur(t, o, e, n, i, "latitudinal", a),
                        this._halfBlur(o, t, n, n, i, "longitudinal", a)
                    }
                    _halfBlur(t, e, n, i, a, o, u) {
                        const f = this._renderer
                          , d = this._blurMaterial;
                        o !== "latitudinal" && o !== "longitudinal" && Rt("blur direction must be either latitudinal or longitudinal!");
                        const p = 3
                          , g = this._lodMeshes[i];
                        g.material = d;
                        const v = d.uniforms
                          , y = this._sizeLods[n] - 1
                          , S = isFinite(a) ? Math.PI / (2 * y) : 2 * Math.PI / (2 * qh - 1)
                          , E = a / S
                          , w = isFinite(a) ? 1 + Math.floor(p * E) : qh;
                        w > qh && at(`sigmaRadians, ${a}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${qh}`);
                        const A = [];
                        let T = 0;
                        for (let D = 0; D < qh; ++D) {
                            const U = D / E
                              , z = Math.exp(-U * U / 2);
                            A.push(z),
                            D === 0 ? T += z : D < w && (T += 2 * z)
                        }
                        for (let D = 0; D < A.length; D++)
                            A[D] = A[D] / T;
                        v.envMap.value = t.texture,
                        v.samples.value = w,
                        v.weights.value = A,
                        v.latitudinal.value = o === "latitudinal",
                        u && (v.poleAxis.value = u);
                        const {_lodMax: R} = this;
                        v.dTheta.value = S,
                        v.mipInt.value = R - n;
                        const N = this._sizeLods[i];
                        op(e, 3 * N * (i > R - gu ? i - R + gu : 0), 4 * (this._cubeSize - N), 3 * N, 2 * N),
                        f.setRenderTarget(e),
                        f.render(g, jg)
                    }
                }
                ;
                function jL(t) {
                    const e = []
                      , n = []
                      , i = [];
                    let a = t;
                    const o = t - gu + 1 + _C.length;
                    for (let u = 0; u < o; u++) {
                        const f = Math.pow(2, a);
                        e.push(f);
                        let d = 1 / f;
                        u > t - gu ? d = _C[u - t + gu - 1] : u === 0 && (d = 0),
                        n.push(d);
                        const p = 1 / (f - 2)
                          , g = -p
                          , v = 1 + p
                          , y = [g, g, v, g, v, v, g, g, v, v, g, v]
                          , S = 6
                          , E = 6
                          , w = 3
                          , A = 2
                          , T = 1
                          , R = new Float32Array(w * E * S)
                          , N = new Float32Array(A * E * S)
                          , D = new Float32Array(T * E * S);
                        for (let z = 0; z < S; z++) {
                            const I = z % 3 * 2 / 3 - 1
                              , V = z > 2 ? 0 : -1
                              , B = [I, V, 0, I + 2 / 3, V, 0, I + 2 / 3, V + 1, 0, I, V, 0, I + 2 / 3, V + 1, 0, I, V + 1, 0];
                            R.set(B, w * E * z),
                            N.set(y, A * E * z);
                            const P = [z, z, z, z, z, z];
                            D.set(P, T * E * z)
                        }
                        const U = new en;
                        U.setAttribute("position", new Kn(R,w)),
                        U.setAttribute("uv", new Kn(N,A)),
                        U.setAttribute("faceIndex", new Kn(D,T)),
                        i.push(new Ji(U,null)),
                        a > gu && a--
                    }
                    return {
                        lodMeshes: i,
                        sizeLods: e,
                        sigmas: n
                    }
                }
                function SC(t, e, n) {
                    const i = new sr(t,e,n);
                    return i.texture.mapping = Md,
                    i.texture.name = "PMREM.cubeUv",
                    i.scissorTest = !0,
                    i
                }
                function op(t, e, n, i, a) {
                    t.viewport.set(e, n, i, a),
                    t.scissor.set(e, n, i, a)
                }
                function ZL(t, e, n) {
                    return new Br({
                        name: "PMREMGGXConvolution",
                        defines: {
                            GGX_SAMPLES: WL,
                            CUBEUV_TEXEL_WIDTH: 1 / e,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${t}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            roughness: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            }
                        },
                        vertexShader: Py(),
                        fragmentShader: `

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,
                        blending: sl,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function QL(t, e, n) {
                    const i = new Float32Array(qh)
                      , a = new J(0,1,0);
                    return new Br({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: qh,
                            CUBEUV_TEXEL_WIDTH: 1 / e,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${t}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: i
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: a
                            }
                        },
                        vertexShader: Py(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                        blending: sl,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function xC() {
                    return new Br({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            }
                        },
                        vertexShader: Py(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                        blending: sl,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function MC() {
                    return new Br({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            }
                        },
                        vertexShader: Py(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                        blending: sl,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function Py() {
                    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                }
                function KL(t) {
                    let e = new WeakMap
                      , n = null;
                    function i(f) {
                        if (f && f.isTexture) {
                            const d = f.mapping
                              , p = d === sg || d === ag
                              , g = d === al || d === Jc;
                            if (p || g) {
                                let v = e.get(f);
                                const y = v !== void 0 ? v.texture.pmremVersion : 0;
                                if (f.isRenderTargetTexture && f.pmremVersion !== y)
                                    return n === null && (n = new rb(t)),
                                    v = p ? n.fromEquirectangular(f, v) : n.fromCubemap(f, v),
                                    v.texture.pmremVersion = f.pmremVersion,
                                    e.set(f, v),
                                    v.texture;
                                if (v !== void 0)
                                    return v.texture;
                                {
                                    const S = f.image;
                                    return p && S && S.height > 0 || g && S && a(S) ? (n === null && (n = new rb(t)),
                                    v = p ? n.fromEquirectangular(f) : n.fromCubemap(f),
                                    v.texture.pmremVersion = f.pmremVersion,
                                    e.set(f, v),
                                    f.addEventListener("dispose", o),
                                    v.texture) : null
                                }
                            }
                        }
                        return f
                    }
                    function a(f) {
                        let d = 0;
                        const p = 6;
                        for (let g = 0; g < p; g++)
                            f[g] !== void 0 && d++;
                        return d === p
                    }
                    function o(f) {
                        const d = f.target;
                        d.removeEventListener("dispose", o);
                        const p = e.get(d);
                        p !== void 0 && (e.delete(d),
                        p.dispose())
                    }
                    function u() {
                        e = new WeakMap,
                        n !== null && (n.dispose(),
                        n = null)
                    }
                    return {
                        get: i,
                        dispose: u
                    }
                }
                function JL(t) {
                    const e = {};
                    function n(i) {
                        if (e[i] !== void 0)
                            return e[i];
                        const a = t.getExtension(i);
                        return e[i] = a,
                        a
                    }
                    return {
                        has: function(i) {
                            return n(i) !== null
                        },
                        init: function() {
                            n("EXT_color_buffer_float"),
                            n("WEBGL_clip_cull_distance"),
                            n("OES_texture_float_linear"),
                            n("EXT_color_buffer_half_float"),
                            n("WEBGL_multisampled_render_to_texture"),
                            n("WEBGL_render_shared_exponent")
                        },
                        get: function(i) {
                            const a = n(i);
                            return a === null && wd("WebGLRenderer: " + i + " extension not supported."),
                            a
                        }
                    }
                }
                function $L(t, e, n, i) {
                    const a = {}
                      , o = new WeakMap;
                    function u(v) {
                        const y = v.target;
                        y.index !== null && e.remove(y.index);
                        for (const E in y.attributes)
                            e.remove(y.attributes[E]);
                        y.removeEventListener("dispose", u),
                        delete a[y.id];
                        const S = o.get(y);
                        S && (e.remove(S),
                        o.delete(y)),
                        i.releaseStatesOfGeometry(y),
                        y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount,
                        n.memory.geometries--
                    }
                    function f(v, y) {
                        return a[y.id] === !0 || (y.addEventListener("dispose", u),
                        a[y.id] = !0,
                        n.memory.geometries++),
                        y
                    }
                    function d(v) {
                        const y = v.attributes;
                        for (const S in y)
                            e.update(y[S], t.ARRAY_BUFFER)
                    }
                    function p(v) {
                        const y = []
                          , S = v.index
                          , E = v.attributes.position;
                        let w = 0;
                        if (S !== null) {
                            const R = S.array;
                            w = S.version;
                            for (let N = 0, D = R.length; N < D; N += 3) {
                                const U = R[N + 0]
                                  , z = R[N + 1]
                                  , I = R[N + 2];
                                y.push(U, z, z, I, I, U)
                            }
                        } else if (E !== void 0) {
                            const R = E.array;
                            w = E.version;
                            for (let N = 0, D = R.length / 3 - 1; N < D; N += 3) {
                                const U = N + 0
                                  , z = N + 1
                                  , I = N + 2;
                                y.push(U, z, z, I, I, U)
                            }
                        } else
                            return;
                        const A = new (X1(y) ? $x : Jx)(y,1);
                        A.version = w;
                        const T = o.get(v);
                        T && e.remove(T),
                        o.set(v, A)
                    }
                    function g(v) {
                        const y = o.get(v);
                        if (y) {
                            const S = v.index;
                            S !== null && y.version < S.version && p(v)
                        } else
                            p(v);
                        return o.get(v)
                    }
                    return {
                        get: f,
                        update: d,
                        getWireframeAttribute: g
                    }
                }
                function e4(t, e, n) {
                    let i;
                    function a(y) {
                        i = y
                    }
                    let o, u;
                    function f(y) {
                        o = y.type,
                        u = y.bytesPerElement
                    }
                    function d(y, S) {
                        t.drawElements(i, S, o, y * u),
                        n.update(S, i, 1)
                    }
                    function p(y, S, E) {
                        E !== 0 && (t.drawElementsInstanced(i, S, o, y * u, E),
                        n.update(S, i, E))
                    }
                    function g(y, S, E) {
                        if (E === 0)
                            return;
                        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, S, 0, o, y, 0, E);
                        let w = 0;
                        for (let A = 0; A < E; A++)
                            w += S[A];
                        n.update(w, i, 1)
                    }
                    function v(y, S, E, w) {
                        if (E === 0)
                            return;
                        const A = e.get("WEBGL_multi_draw");
                        if (A === null)
                            for (let T = 0; T < y.length; T++)
                                p(y[T] / u, S[T], w[T]);
                        else {
                            A.multiDrawElementsInstancedWEBGL(i, S, 0, o, y, 0, w, 0, E);
                            let T = 0;
                            for (let R = 0; R < E; R++)
                                T += S[R] * w[R];
                            n.update(T, i, 1)
                        }
                    }
                    this.setMode = a,
                    this.setIndex = f,
                    this.render = d,
                    this.renderInstances = p,
                    this.renderMultiDraw = g,
                    this.renderMultiDrawInstances = v
                }
                function t4(t) {
                    const e = {
                        geometries: 0,
                        textures: 0
                    }
                      , n = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    function i(o, u, f) {
                        switch (n.calls++,
                        u) {
                        case t.TRIANGLES:
                            n.triangles += f * (o / 3);
                            break;
                        case t.LINES:
                            n.lines += f * (o / 2);
                            break;
                        case t.LINE_STRIP:
                            n.lines += f * (o - 1);
                            break;
                        case t.LINE_LOOP:
                            n.lines += f * o;
                            break;
                        case t.POINTS:
                            n.points += f * o;
                            break;
                        default:
                            Rt("WebGLInfo: Unknown draw mode:", u);
                            break
                        }
                    }
                    function a() {
                        n.calls = 0,
                        n.triangles = 0,
                        n.points = 0,
                        n.lines = 0
                    }
                    return {
                        memory: e,
                        render: n,
                        programs: null,
                        autoReset: !0,
                        reset: a,
                        update: i
                    }
                }
                function n4(t, e, n) {
                    const i = new WeakMap
                      , a = new di;
                    function o(u, f, d) {
                        const p = u.morphTargetInfluences
                          , g = f.morphAttributes.position || f.morphAttributes.normal || f.morphAttributes.color
                          , v = g !== void 0 ? g.length : 0;
                        let y = i.get(f);
                        if (y === void 0 || y.count !== v) {
                            let P = function() {
                                V.dispose(),
                                i.delete(f),
                                f.removeEventListener("dispose", P)
                            };
                            var S = P;
                            y !== void 0 && y.texture.dispose();
                            const E = f.morphAttributes.position !== void 0
                              , w = f.morphAttributes.normal !== void 0
                              , A = f.morphAttributes.color !== void 0
                              , T = f.morphAttributes.position || []
                              , R = f.morphAttributes.normal || []
                              , N = f.morphAttributes.color || [];
                            let D = 0;
                            E === !0 && (D = 1),
                            w === !0 && (D = 2),
                            A === !0 && (D = 3);
                            let U = f.attributes.position.count * D
                              , z = 1;
                            U > e.maxTextureSize && (z = Math.ceil(U / e.maxTextureSize),
                            U = e.maxTextureSize);
                            const I = new Float32Array(U * z * 4 * v)
                              , V = new B0(I,U,z,v);
                            V.type = pa,
                            V.needsUpdate = !0;
                            const B = D * 4;
                            for (let G = 0; G < v; G++) {
                                const K = T[G]
                                  , ee = R[G]
                                  , te = N[G]
                                  , oe = U * z * 4 * G;
                                for (let q = 0; q < K.count; q++) {
                                    const F = q * B;
                                    E === !0 && (a.fromBufferAttribute(K, q),
                                    I[oe + F + 0] = a.x,
                                    I[oe + F + 1] = a.y,
                                    I[oe + F + 2] = a.z,
                                    I[oe + F + 3] = 0),
                                    w === !0 && (a.fromBufferAttribute(ee, q),
                                    I[oe + F + 4] = a.x,
                                    I[oe + F + 5] = a.y,
                                    I[oe + F + 6] = a.z,
                                    I[oe + F + 7] = 0),
                                    A === !0 && (a.fromBufferAttribute(te, q),
                                    I[oe + F + 8] = a.x,
                                    I[oe + F + 9] = a.y,
                                    I[oe + F + 10] = a.z,
                                    I[oe + F + 11] = te.itemSize === 4 ? a.w : 1)
                                }
                            }
                            y = {
                                count: v,
                                texture: V,
                                size: new Ge(U,z)
                            },
                            i.set(f, y),
                            f.addEventListener("dispose", P)
                        }
                        if (u.isInstancedMesh === !0 && u.morphTexture !== null)
                            d.getUniforms().setValue(t, "morphTexture", u.morphTexture, n);
                        else {
                            let E = 0;
                            for (let A = 0; A < p.length; A++)
                                E += p[A];
                            const w = f.morphTargetsRelative ? 1 : 1 - E;
                            d.getUniforms().setValue(t, "morphTargetBaseInfluence", w),
                            d.getUniforms().setValue(t, "morphTargetInfluences", p)
                        }
                        d.getUniforms().setValue(t, "morphTargetsTexture", y.texture, n),
                        d.getUniforms().setValue(t, "morphTargetsTextureSize", y.size)
                    }
                    return {
                        update: o
                    }
                }
                function i4(t, e, n, i) {
                    let a = new WeakMap;
                    function o(d) {
                        const p = i.render.frame
                          , g = d.geometry
                          , v = e.get(d, g);
                        if (a.get(v) !== p && (e.update(v),
                        a.set(v, p)),
                        d.isInstancedMesh && (d.hasEventListener("dispose", f) === !1 && d.addEventListener("dispose", f),
                        a.get(d) !== p && (n.update(d.instanceMatrix, t.ARRAY_BUFFER),
                        d.instanceColor !== null && n.update(d.instanceColor, t.ARRAY_BUFFER),
                        a.set(d, p))),
                        d.isSkinnedMesh) {
                            const y = d.skeleton;
                            a.get(y) !== p && (y.update(),
                            a.set(y, p))
                        }
                        return v
                    }
                    function u() {
                        a = new WeakMap
                    }
                    function f(d) {
                        const p = d.target;
                        p.removeEventListener("dispose", f),
                        n.remove(p.instanceMatrix),
                        p.instanceColor !== null && n.remove(p.instanceColor)
                    }
                    return {
                        update: o,
                        dispose: u
                    }
                }
                const s4 = {
                    [mx]: "LINEAR_TONE_MAPPING",
                    [gx]: "REINHARD_TONE_MAPPING",
                    [vx]: "CINEON_TONE_MAPPING",
                    [W_]: "ACES_FILMIC_TONE_MAPPING",
                    [yx]: "AGX_TONE_MAPPING",
                    [Sx]: "NEUTRAL_TONE_MAPPING",
                    [_x]: "CUSTOM_TONE_MAPPING"
                };
                function a4(t, e, n, i, a) {
                    const o = new sr(e,n,{
                        type: t,
                        depthBuffer: i,
                        stencilBuffer: a
                    })
                      , u = new sr(e,n,{
                        type: ol,
                        depthBuffer: !1,
                        stencilBuffer: !1
                    })
                      , f = new en;
                    f.setAttribute("position", new _t([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
                    f.setAttribute("uv", new _t([0, 2, 0, 0, 2, 0],2));
                    const d = new OM({
                        uniforms: {
                            tDiffuse: {
                                value: null
                            }
                        },
                        vertexShader: `
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`,
                        fragmentShader: `
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`,
                        depthTest: !1,
                        depthWrite: !1
                    })
                      , p = new Ji(f,d)
                      , g = new sp(-1,1,1,-1,0,1);
                    let v = null, y = null, S = !1, E, w = null, A = [], T = !1;
                    this.setSize = function(R, N) {
                        o.setSize(R, N),
                        u.setSize(R, N);
                        for (let D = 0; D < A.length; D++) {
                            const U = A[D];
                            U.setSize && U.setSize(R, N)
                        }
                    }
                    ,
                    this.setEffects = function(R) {
                        A = R,
                        T = A.length > 0 && A[0].isRenderPass === !0;
                        const N = o.width
                          , D = o.height;
                        for (let U = 0; U < A.length; U++) {
                            const z = A[U];
                            z.setSize && z.setSize(N, D)
                        }
                    }
                    ,
                    this.begin = function(R, N) {
                        if (S || R.toneMapping === Lr && A.length === 0)
                            return !1;
                        if (w = N,
                        N !== null) {
                            const D = N.width
                              , U = N.height;
                            (o.width !== D || o.height !== U) && this.setSize(D, U)
                        }
                        return T === !1 && R.setRenderTarget(o),
                        E = R.toneMapping,
                        R.toneMapping = Lr,
                        !0
                    }
                    ,
                    this.hasRenderPass = function() {
                        return T
                    }
                    ,
                    this.end = function(R, N) {
                        R.toneMapping = E,
                        S = !0;
                        let D = o
                          , U = u;
                        for (let z = 0; z < A.length; z++) {
                            const I = A[z];
                            if (I.enabled !== !1 && (I.render(R, U, D, N),
                            I.needsSwap !== !1)) {
                                const V = D;
                                D = U,
                                U = V
                            }
                        }
                        if (v !== R.outputColorSpace || y !== R.toneMapping) {
                            v = R.outputColorSpace,
                            y = R.toneMapping,
                            d.defines = {},
                            xn.getTransfer(v) === Vn && (d.defines.SRGB_TRANSFER = "");
                            const z = s4[y];
                            z && (d.defines[z] = ""),
                            d.needsUpdate = !0
                        }
                        d.uniforms.tDiffuse.value = D.texture,
                        R.setRenderTarget(w),
                        R.render(p, g),
                        w = null,
                        S = !1
                    }
                    ,
                    this.isCompositing = function() {
                        return S
                    }
                    ,
                    this.dispose = function() {
                        o.dispose(),
                        u.dispose(),
                        f.dispose(),
                        d.dispose()
                    }
                }
                const bC = new gs
                  , ob = new ep(1,1)
                  , TC = new B0
                  , AC = new P0
                  , EC = new Cg
                  , CC = []
                  , wC = []
                  , RC = new Float32Array(16)
                  , NC = new Float32Array(9)
                  , DC = new Float32Array(4);
                function lp(t, e, n) {
                    const i = t[0];
                    if (i <= 0 || i > 0)
                        return t;
                    const a = e * n;
                    let o = CC[a];
                    if (o === void 0 && (o = new Float32Array(a),
                    CC[a] = o),
                    e !== 0) {
                        i.toArray(o, 0);
                        for (let u = 1, f = 0; u !== e; ++u)
                            f += n,
                            t[u].toArray(o, f)
                    }
                    return o
                }
                function rs(t, e) {
                    if (t.length !== e.length)
                        return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n])
                            return !1;
                    return !0
                }
                function os(t, e) {
                    for (let n = 0, i = e.length; n < i; n++)
                        t[n] = e[n]
                }
                function Vy(t, e) {
                    let n = wC[e];
                    n === void 0 && (n = new Int32Array(e),
                    wC[e] = n);
                    for (let i = 0; i !== e; ++i)
                        n[i] = t.allocateTextureUnit();
                    return n
                }
                function r4(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e),
                    n[0] = e)
                }
                function o4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y),
                        n[0] = e.x,
                        n[1] = e.y);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform2fv(this.addr, e),
                        os(n, e)
                    }
                }
                function l4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z),
                        n[0] = e.x,
                        n[1] = e.y,
                        n[2] = e.z);
                    else if (e.r !== void 0)
                        (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b),
                        n[0] = e.r,
                        n[1] = e.g,
                        n[2] = e.b);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform3fv(this.addr, e),
                        os(n, e)
                    }
                }
                function c4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                        n[0] = e.x,
                        n[1] = e.y,
                        n[2] = e.z,
                        n[3] = e.w);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform4fv(this.addr, e),
                        os(n, e)
                    }
                }
                function u4(t, e) {
                    const n = this.cache
                      , i = e.elements;
                    if (i === void 0) {
                        if (rs(n, e))
                            return;
                        t.uniformMatrix2fv(this.addr, !1, e),
                        os(n, e)
                    } else {
                        if (rs(n, i))
                            return;
                        DC.set(i),
                        t.uniformMatrix2fv(this.addr, !1, DC),
                        os(n, i)
                    }
                }
                function h4(t, e) {
                    const n = this.cache
                      , i = e.elements;
                    if (i === void 0) {
                        if (rs(n, e))
                            return;
                        t.uniformMatrix3fv(this.addr, !1, e),
                        os(n, e)
                    } else {
                        if (rs(n, i))
                            return;
                        NC.set(i),
                        t.uniformMatrix3fv(this.addr, !1, NC),
                        os(n, i)
                    }
                }
                function f4(t, e) {
                    const n = this.cache
                      , i = e.elements;
                    if (i === void 0) {
                        if (rs(n, e))
                            return;
                        t.uniformMatrix4fv(this.addr, !1, e),
                        os(n, e)
                    } else {
                        if (rs(n, i))
                            return;
                        RC.set(i),
                        t.uniformMatrix4fv(this.addr, !1, RC),
                        os(n, i)
                    }
                }
                function d4(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e),
                    n[0] = e)
                }
                function p4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y),
                        n[0] = e.x,
                        n[1] = e.y);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform2iv(this.addr, e),
                        os(n, e)
                    }
                }
                function m4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z),
                        n[0] = e.x,
                        n[1] = e.y,
                        n[2] = e.z);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform3iv(this.addr, e),
                        os(n, e)
                    }
                }
                function g4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
                        n[0] = e.x,
                        n[1] = e.y,
                        n[2] = e.z,
                        n[3] = e.w);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform4iv(this.addr, e),
                        os(n, e)
                    }
                }
                function v4(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e),
                    n[0] = e)
                }
                function _4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y),
                        n[0] = e.x,
                        n[1] = e.y);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform2uiv(this.addr, e),
                        os(n, e)
                    }
                }
                function y4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z),
                        n[0] = e.x,
                        n[1] = e.y,
                        n[2] = e.z);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform3uiv(this.addr, e),
                        os(n, e)
                    }
                }
                function S4(t, e) {
                    const n = this.cache;
                    if (e.x !== void 0)
                        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
                        n[0] = e.x,
                        n[1] = e.y,
                        n[2] = e.z,
                        n[3] = e.w);
                    else {
                        if (rs(n, e))
                            return;
                        t.uniform4uiv(this.addr, e),
                        os(n, e)
                    }
                }
                function x4(t, e, n) {
                    const i = this.cache
                      , a = n.allocateTextureUnit();
                    i[0] !== a && (t.uniform1i(this.addr, a),
                    i[0] = a);
                    let o;
                    this.type === t.SAMPLER_2D_SHADOW ? (ob.compareFunction = n.isReversedDepthBuffer() ? z0 : I0,
                    o = ob) : o = bC,
                    n.setTexture2D(e || o, a)
                }
                function M4(t, e, n) {
                    const i = this.cache
                      , a = n.allocateTextureUnit();
                    i[0] !== a && (t.uniform1i(this.addr, a),
                    i[0] = a),
                    n.setTexture3D(e || AC, a)
                }
                function b4(t, e, n) {
                    const i = this.cache
                      , a = n.allocateTextureUnit();
                    i[0] !== a && (t.uniform1i(this.addr, a),
                    i[0] = a),
                    n.setTextureCube(e || EC, a)
                }
                function T4(t, e, n) {
                    const i = this.cache
                      , a = n.allocateTextureUnit();
                    i[0] !== a && (t.uniform1i(this.addr, a),
                    i[0] = a),
                    n.setTexture2DArray(e || TC, a)
                }
                function A4(t) {
                    switch (t) {
                    case 5126:
                        return r4;
                    case 35664:
                        return o4;
                    case 35665:
                        return l4;
                    case 35666:
                        return c4;
                    case 35674:
                        return u4;
                    case 35675:
                        return h4;
                    case 35676:
                        return f4;
                    case 5124:
                    case 35670:
                        return d4;
                    case 35667:
                    case 35671:
                        return p4;
                    case 35668:
                    case 35672:
                        return m4;
                    case 35669:
                    case 35673:
                        return g4;
                    case 5125:
                        return v4;
                    case 36294:
                        return _4;
                    case 36295:
                        return y4;
                    case 36296:
                        return S4;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return x4;
                    case 35679:
                    case 36299:
                    case 36307:
                        return M4;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return b4;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return T4
                    }
                }
                function E4(t, e) {
                    t.uniform1fv(this.addr, e)
                }
                function C4(t, e) {
                    const n = lp(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }
                function w4(t, e) {
                    const n = lp(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }
                function R4(t, e) {
                    const n = lp(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }
                function N4(t, e) {
                    const n = lp(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }
                function D4(t, e) {
                    const n = lp(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }
                function O4(t, e) {
                    const n = lp(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }
                function U4(t, e) {
                    t.uniform1iv(this.addr, e)
                }
                function L4(t, e) {
                    t.uniform2iv(this.addr, e)
                }
                function I4(t, e) {
                    t.uniform3iv(this.addr, e)
                }
                function z4(t, e) {
                    t.uniform4iv(this.addr, e)
                }
                function B4(t, e) {
                    t.uniform1uiv(this.addr, e)
                }
                function P4(t, e) {
                    t.uniform2uiv(this.addr, e)
                }
                function V4(t, e) {
                    t.uniform3uiv(this.addr, e)
                }
                function F4(t, e) {
                    t.uniform4uiv(this.addr, e)
                }
                function H4(t, e, n) {
                    const i = this.cache
                      , a = e.length
                      , o = Vy(n, a);
                    rs(i, o) || (t.uniform1iv(this.addr, o),
                    os(i, o));
                    let u;
                    this.type === t.SAMPLER_2D_SHADOW ? u = ob : u = bC;
                    for (let f = 0; f !== a; ++f)
                        n.setTexture2D(e[f] || u, o[f])
                }
                function G4(t, e, n) {
                    const i = this.cache
                      , a = e.length
                      , o = Vy(n, a);
                    rs(i, o) || (t.uniform1iv(this.addr, o),
                    os(i, o));
                    for (let u = 0; u !== a; ++u)
                        n.setTexture3D(e[u] || AC, o[u])
                }
                function k4(t, e, n) {
                    const i = this.cache
                      , a = e.length
                      , o = Vy(n, a);
                    rs(i, o) || (t.uniform1iv(this.addr, o),
                    os(i, o));
                    for (let u = 0; u !== a; ++u)
                        n.setTextureCube(e[u] || EC, o[u])
                }
                function q4(t, e, n) {
                    const i = this.cache
                      , a = e.length
                      , o = Vy(n, a);
                    rs(i, o) || (t.uniform1iv(this.addr, o),
                    os(i, o));
                    for (let u = 0; u !== a; ++u)
                        n.setTexture2DArray(e[u] || TC, o[u])
                }
                function X4(t) {
                    switch (t) {
                    case 5126:
                        return E4;
                    case 35664:
                        return C4;
                    case 35665:
                        return w4;
                    case 35666:
                        return R4;
                    case 35674:
                        return N4;
                    case 35675:
                        return D4;
                    case 35676:
                        return O4;
                    case 5124:
                    case 35670:
                        return U4;
                    case 35667:
                    case 35671:
                        return L4;
                    case 35668:
                    case 35672:
                        return I4;
                    case 35669:
                    case 35673:
                        return z4;
                    case 5125:
                        return B4;
                    case 36294:
                        return P4;
                    case 36295:
                        return V4;
                    case 36296:
                        return F4;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return H4;
                    case 35679:
                    case 36299:
                    case 36307:
                        return G4;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return k4;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return q4
                    }
                }
                var W4 = class {
                    constructor(t, e, n) {
                        this.id = t,
                        this.addr = n,
                        this.cache = [],
                        this.type = e.type,
                        this.setValue = A4(e.type)
                    }
                }
                  , Y4 = class {
                    constructor(t, e, n) {
                        this.id = t,
                        this.addr = n,
                        this.cache = [],
                        this.type = e.type,
                        this.size = e.size,
                        this.setValue = X4(e.type)
                    }
                }
                  , j4 = class {
                    constructor(t) {
                        this.id = t,
                        this.seq = [],
                        this.map = {}
                    }
                    setValue(t, e, n) {
                        const i = this.seq;
                        for (let a = 0, o = i.length; a !== o; ++a) {
                            const u = i[a];
                            u.setValue(t, e[u.id], n)
                        }
                    }
                }
                ;
                const lb = /(\w+)(\])?(\[|\.)?/g;
                function OC(t, e) {
                    t.seq.push(e),
                    t.map[e.id] = e
                }
                function Z4(t, e, n) {
                    const i = t.name
                      , a = i.length;
                    for (lb.lastIndex = 0; ; ) {
                        const o = lb.exec(i)
                          , u = lb.lastIndex;
                        let f = o[1];
                        const d = o[2] === "]"
                          , p = o[3];
                        if (d && (f = f | 0),
                        p === void 0 || p === "[" && u + 2 === a) {
                            OC(n, p === void 0 ? new W4(f,t,e) : new Y4(f,t,e));
                            break
                        } else {
                            let g = n.map[f];
                            g === void 0 && (g = new j4(f),
                            OC(n, g)),
                            n = g
                        }
                    }
                }
                var Fy = class {
                    constructor(t, e) {
                        this.seq = [],
                        this.map = {};
                        const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                        for (let o = 0; o < n; ++o) {
                            const u = t.getActiveUniform(e, o);
                            Z4(u, t.getUniformLocation(e, u.name), this)
                        }
                        const i = []
                          , a = [];
                        for (const o of this.seq)
                            o.type === t.SAMPLER_2D_SHADOW || o.type === t.SAMPLER_CUBE_SHADOW || o.type === t.SAMPLER_2D_ARRAY_SHADOW ? i.push(o) : a.push(o);
                        i.length > 0 && (this.seq = i.concat(a))
                    }
                    setValue(t, e, n, i) {
                        const a = this.map[e];
                        a !== void 0 && a.setValue(t, n, i)
                    }
                    setOptional(t, e, n) {
                        const i = e[n];
                        i !== void 0 && this.setValue(t, n, i)
                    }
                    static upload(t, e, n, i) {
                        for (let a = 0, o = e.length; a !== o; ++a) {
                            const u = e[a]
                              , f = n[u.id];
                            f.needsUpdate !== !1 && u.setValue(t, f.value, i)
                        }
                    }
                    static seqWithValue(t, e) {
                        const n = [];
                        for (let i = 0, a = t.length; i !== a; ++i) {
                            const o = t[i];
                            o.id in e && n.push(o)
                        }
                        return n
                    }
                }
                ;
                function UC(t, e, n) {
                    const i = t.createShader(e);
                    return t.shaderSource(i, n),
                    t.compileShader(i),
                    i
                }
                const Q4 = 37297;
                let K4 = 0;
                function J4(t, e) {
                    const n = t.split(`
`)
                      , i = []
                      , a = Math.max(e - 6, 0)
                      , o = Math.min(e + 6, n.length);
                    for (let u = a; u < o; u++) {
                        const f = u + 1;
                        i.push(`${f === e ? ">" : " "} ${f}: ${n[u]}`)
                    }
                    return i.join(`
`)
                }
                const LC = new sn;
                function $4(t) {
                    xn._getMatrix(LC, xn.workingColorSpace, t);
                    const e = `mat3( ${LC.elements.map(n => n.toFixed(4))} )`;
                    switch (xn.getTransfer(t)) {
                    case gg:
                        return [e, "LinearTransferOETF"];
                    case Vn:
                        return [e, "sRGBTransferOETF"];
                    default:
                        return at("WebGLProgram: Unsupported color space: ", t),
                        [e, "LinearTransferOETF"]
                    }
                }
                function IC(t, e, n) {
                    const i = t.getShaderParameter(e, t.COMPILE_STATUS)
                      , a = (t.getShaderInfoLog(e) || "").trim();
                    if (i && a === "")
                        return "";
                    const o = /ERROR: 0:(\d+)/.exec(a);
                    if (o) {
                        const u = parseInt(o[1]);
                        return n.toUpperCase() + `

` + a + `

` + J4(t.getShaderSource(e), u)
                    } else
                        return a
                }
                function eI(t, e) {
                    const n = $4(e);
                    return [`vec4 ${t}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
                }
                const tI = {
                    [mx]: "Linear",
                    [gx]: "Reinhard",
                    [vx]: "Cineon",
                    [W_]: "ACESFilmic",
                    [yx]: "AgX",
                    [Sx]: "Neutral",
                    [_x]: "Custom"
                };
                function nI(t, e) {
                    const n = tI[e];
                    return n === void 0 ? (at("WebGLProgram: Unsupported toneMapping:", e),
                    "vec3 " + t + "( vec3 color ) { return LinearToneMapping( color ); }") : "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }
                const Hy = new J;
                function iI() {
                    return xn.getLuminanceCoefficients(Hy),
                    ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${Hy.x.toFixed(4)}, ${Hy.y.toFixed(4)}, ${Hy.z.toFixed(4)} );`, "	return dot( weights, rgb );", "}"].join(`
`)
                }
                function sI(t) {
                    return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Zg).join(`
`)
                }
                function aI(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        i !== !1 && e.push("#define " + n + " " + i)
                    }
                    return e.join(`
`)
                }
                function rI(t, e) {
                    const n = {}
                      , i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let a = 0; a < i; a++) {
                        const o = t.getActiveAttrib(e, a)
                          , u = o.name;
                        let f = 1;
                        o.type === t.FLOAT_MAT2 && (f = 2),
                        o.type === t.FLOAT_MAT3 && (f = 3),
                        o.type === t.FLOAT_MAT4 && (f = 4),
                        n[u] = {
                            type: o.type,
                            location: t.getAttribLocation(e, u),
                            locationSize: f
                        }
                    }
                    return n
                }
                function Zg(t) {
                    return t !== ""
                }
                function zC(t, e) {
                    const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
                    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                }
                function BC(t, e) {
                    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                }
                const oI = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function cb(t) {
                    return t.replace(oI, cI)
                }
                const lI = new Map;
                function cI(t, e) {
                    let n = an[e];
                    if (n === void 0) {
                        const i = lI.get(e);
                        if (i !== void 0)
                            n = an[i],
                            at('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
                        else
                            throw new Error("Can not resolve #include <" + e + ">")
                    }
                    return cb(n)
                }
                const uI = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function PC(t) {
                    return t.replace(uI, hI)
                }
                function hI(t, e, n, i) {
                    let a = "";
                    for (let o = parseInt(e); o < parseInt(n); o++)
                        a += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
                    return a
                }
                function VC(t) {
                    let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`;
                    return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`),
                    e
                }
                const fI = {
                    [xd]: "SHADOWMAP_TYPE_PCF",
                    [_h]: "SHADOWMAP_TYPE_VSM"
                };
                function dI(t) {
                    return fI[t.shadowMapType] || "SHADOWMAP_TYPE_BASIC"
                }
                const pI = {
                    [al]: "ENVMAP_TYPE_CUBE",
                    [Jc]: "ENVMAP_TYPE_CUBE",
                    [Md]: "ENVMAP_TYPE_CUBE_UV"
                };
                function mI(t) {
                    return t.envMap === !1 ? "ENVMAP_TYPE_CUBE" : pI[t.envMapMode] || "ENVMAP_TYPE_CUBE"
                }
                const gI = {
                    [Jc]: "ENVMAP_MODE_REFRACTION"
                };
                function vI(t) {
                    return t.envMap === !1 ? "ENVMAP_MODE_REFLECTION" : gI[t.envMapMode] || "ENVMAP_MODE_REFLECTION"
                }
                const _I = {
                    [ig]: "ENVMAP_BLENDING_MULTIPLY",
                    [D1]: "ENVMAP_BLENDING_MIX",
                    [O1]: "ENVMAP_BLENDING_ADD"
                };
                function yI(t) {
                    return t.envMap === !1 ? "ENVMAP_BLENDING_NONE" : _I[t.combine] || "ENVMAP_BLENDING_NONE"
                }
                function SI(t) {
                    const e = t.envMapCubeUVHeight;
                    if (e === null)
                        return null;
                    const n = Math.log2(e) - 2
                      , i = 1 / e;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }
                function xI(t, e, n, i) {
                    const a = t.getContext()
                      , o = n.defines;
                    let u = n.vertexShader
                      , f = n.fragmentShader;
                    const d = dI(n)
                      , p = mI(n)
                      , g = vI(n)
                      , v = yI(n)
                      , y = SI(n)
                      , S = sI(n)
                      , E = aI(o)
                      , w = a.createProgram();
                    let A, T, R = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
                    n.isRawShaderMaterial ? (A = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E].filter(Zg).join(`
`),
                    A.length > 0 && (A += `
`),
                    T = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E].filter(Zg).join(`
`),
                    T.length > 0 && (T += `
`)) : (A = [VC(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + g : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Zg).join(`
`),
                    T = [VC(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + g : "", n.envMap ? "#define " + v : "", y ? "#define CUBEUV_TEXEL_WIDTH " + y.texelWidth : "", y ? "#define CUBEUV_TEXEL_HEIGHT " + y.texelHeight : "", y ? "#define CUBEUV_MAX_MIP " + y.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Lr ? "#define TONE_MAPPING" : "", n.toneMapping !== Lr ? an.tonemapping_pars_fragment : "", n.toneMapping !== Lr ? nI("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", an.colorspace_pars_fragment, eI("linearToOutputTexel", n.outputColorSpace), iI(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(Zg).join(`
`)),
                    u = cb(u),
                    u = zC(u, n),
                    u = BC(u, n),
                    f = cb(f),
                    f = zC(f, n),
                    f = BC(f, n),
                    u = PC(u),
                    f = PC(f),
                    n.isRawShaderMaterial !== !0 && (R = `#version 300 es
`,
                    A = [S, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + A,
                    T = ["#define varying in", n.glslVersion === Dx ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Dx ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + T);
                    const N = R + A + u
                      , D = R + T + f
                      , U = UC(a, a.VERTEX_SHADER, N)
                      , z = UC(a, a.FRAGMENT_SHADER, D);
                    a.attachShader(w, U),
                    a.attachShader(w, z),
                    n.index0AttributeName !== void 0 ? a.bindAttribLocation(w, 0, n.index0AttributeName) : n.morphTargets === !0 && a.bindAttribLocation(w, 0, "position"),
                    a.linkProgram(w);
                    function I(G) {
                        if (t.debug.checkShaderErrors) {
                            const K = a.getProgramInfoLog(w) || ""
                              , ee = a.getShaderInfoLog(U) || ""
                              , te = a.getShaderInfoLog(z) || ""
                              , oe = K.trim()
                              , q = ee.trim()
                              , F = te.trim();
                            let X = !0
                              , $ = !0;
                            if (a.getProgramParameter(w, a.LINK_STATUS) === !1)
                                if (X = !1,
                                typeof t.debug.onShaderError == "function")
                                    t.debug.onShaderError(a, w, U, z);
                                else {
                                    const ne = IC(a, U, "vertex")
                                      , ce = IC(a, z, "fragment");
                                    Rt("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(w, a.VALIDATE_STATUS) + `

Material Name: ` + G.name + `
Material Type: ` + G.type + `

Program Info Log: ` + oe + `
` + ne + `
` + ce)
                                }
                            else
                                oe !== "" ? at("WebGLProgram: Program Info Log:", oe) : (q === "" || F === "") && ($ = !1);
                            $ && (G.diagnostics = {
                                runnable: X,
                                programLog: oe,
                                vertexShader: {
                                    log: q,
                                    prefix: A
                                },
                                fragmentShader: {
                                    log: F,
                                    prefix: T
                                }
                            })
                        }
                        a.deleteShader(U),
                        a.deleteShader(z),
                        V = new Fy(a,w),
                        B = rI(a, w)
                    }
                    let V;
                    this.getUniforms = function() {
                        return V === void 0 && I(this),
                        V
                    }
                    ;
                    let B;
                    this.getAttributes = function() {
                        return B === void 0 && I(this),
                        B
                    }
                    ;
                    let P = n.rendererExtensionParallelShaderCompile === !1;
                    return this.isReady = function() {
                        return P === !1 && (P = a.getProgramParameter(w, Q4)),
                        P
                    }
                    ,
                    this.destroy = function() {
                        i.releaseStatesOfProgram(this),
                        a.deleteProgram(w),
                        this.program = void 0
                    }
                    ,
                    this.type = n.shaderType,
                    this.name = n.shaderName,
                    this.id = K4++,
                    this.cacheKey = e,
                    this.usedTimes = 1,
                    this.program = w,
                    this.vertexShader = U,
                    this.fragmentShader = z,
                    this
                }
                let MI = 0;
                var bI = class {
                    constructor() {
                        this.shaderCache = new Map,
                        this.materialCache = new Map
                    }
                    update(t) {
                        const e = t.vertexShader
                          , n = t.fragmentShader
                          , i = this._getShaderStage(e)
                          , a = this._getShaderStage(n)
                          , o = this._getShaderCacheForMaterial(t);
                        return o.has(i) === !1 && (o.add(i),
                        i.usedTimes++),
                        o.has(a) === !1 && (o.add(a),
                        a.usedTimes++),
                        this
                    }
                    remove(t) {
                        const e = this.materialCache.get(t);
                        for (const n of e)
                            n.usedTimes--,
                            n.usedTimes === 0 && this.shaderCache.delete(n.code);
                        return this.materialCache.delete(t),
                        this
                    }
                    getVertexShaderID(t) {
                        return this._getShaderStage(t.vertexShader).id
                    }
                    getFragmentShaderID(t) {
                        return this._getShaderStage(t.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear(),
                        this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(t) {
                        const e = this.materialCache;
                        let n = e.get(t);
                        return n === void 0 && (n = new Set,
                        e.set(t, n)),
                        n
                    }
                    _getShaderStage(t) {
                        const e = this.shaderCache;
                        let n = e.get(t);
                        return n === void 0 && (n = new TI(t),
                        e.set(t, n)),
                        n
                    }
                }
                  , TI = class {
                    constructor(t) {
                        this.id = MI++,
                        this.code = t,
                        this.usedTimes = 0
                    }
                }
                ;
                function AI(t, e, n, i, a, o, u) {
                    const f = new Bd
                      , d = new bI
                      , p = new Set
                      , g = []
                      , v = new Map
                      , y = a.logarithmicDepthBuffer;
                    let S = a.precision;
                    const E = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distance",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                    function w(B) {
                        return p.add(B),
                        B === 0 ? "uv" : `uv${B}`
                    }
                    function A(B, P, G, K, ee) {
                        const te = K.fog
                          , oe = ee.geometry
                          , q = B.isMeshStandardMaterial ? K.environment : null
                          , F = (B.isMeshStandardMaterial ? n : e).get(B.envMap || q)
                          , X = F && F.mapping === Md ? F.image.height : null
                          , $ = E[B.type];
                        B.precision !== null && (S = a.getMaxPrecision(B.precision),
                        S !== B.precision && at("WebGLProgram.getParameters:", B.precision, "not supported, using", S, "instead."));
                        const ne = oe.morphAttributes.position || oe.morphAttributes.normal || oe.morphAttributes.color
                          , ce = ne !== void 0 ? ne.length : 0;
                        let k = 0;
                        oe.morphAttributes.position !== void 0 && (k = 1),
                        oe.morphAttributes.normal !== void 0 && (k = 2),
                        oe.morphAttributes.color !== void 0 && (k = 3);
                        let pe, Ae, ie, Me;
                        if ($) {
                            const pn = xo[$];
                            pe = pn.vertexShader,
                            Ae = pn.fragmentShader
                        } else
                            pe = B.vertexShader,
                            Ae = B.fragmentShader,
                            d.update(B),
                            ie = d.getVertexShaderID(B),
                            Me = d.getFragmentShaderID(B);
                        const we = t.getRenderTarget()
                          , Te = t.state.buffers.depth.getReversed()
                          , Je = ee.isInstancedMesh === !0
                          , Ze = ee.isBatchedMesh === !0
                          , Ct = !!B.map
                          , bt = !!B.matcap
                          , Ue = !!F
                          , ve = !!B.aoMap
                          , Ce = !!B.lightMap
                          , qe = !!B.bumpMap
                          , Q = !!B.normalMap
                          , Ke = !!B.displacementMap
                          , Ve = !!B.emissiveMap
                          , ft = !!B.metalnessMap
                          , ke = !!B.roughnessMap
                          , Nt = B.anisotropy > 0
                          , Z = B.clearcoat > 0
                          , H = B.dispersion > 0
                          , he = B.iridescence > 0
                          , Le = B.sheen > 0
                          , He = B.transmission > 0
                          , Oe = Nt && !!B.anisotropyMap
                          , pt = Z && !!B.clearcoatMap
                          , et = Z && !!B.clearcoatNormalMap
                          , xt = Z && !!B.clearcoatRoughnessMap
                          , Dt = he && !!B.iridescenceMap
                          , je = he && !!B.iridescenceThicknessMap
                          , Xe = Le && !!B.sheenColorMap
                          , nt = Le && !!B.sheenRoughnessMap
                          , ot = !!B.specularMap
                          , tt = !!B.specularColorMap
                          , Gt = !!B.specularIntensityMap
                          , le = He && !!B.transmissionMap
                          , it = He && !!B.thicknessMap
                          , Qe = !!B.gradientMap
                          , dt = !!B.alphaMap
                          , We = B.alphaTest > 0
                          , De = !!B.alphaHash
                          , mt = !!B.extensions;
                        let Tt = Lr;
                        B.toneMapped && (we === null || we.isXRRenderTarget === !0) && (Tt = t.toneMapping);
                        const si = {
                            shaderID: $,
                            shaderType: B.type,
                            shaderName: B.name,
                            vertexShader: pe,
                            fragmentShader: Ae,
                            defines: B.defines,
                            customVertexShaderID: ie,
                            customFragmentShaderID: Me,
                            isRawShaderMaterial: B.isRawShaderMaterial === !0,
                            glslVersion: B.glslVersion,
                            precision: S,
                            batching: Ze,
                            batchingColor: Ze && ee._colorsTexture !== null,
                            instancing: Je,
                            instancingColor: Je && ee.instanceColor !== null,
                            instancingMorph: Je && ee.morphTexture !== null,
                            outputColorSpace: we === null ? t.outputColorSpace : we.isXRRenderTarget === !0 ? we.texture.colorSpace : tu,
                            alphaToCoverage: !!B.alphaToCoverage,
                            map: Ct,
                            matcap: bt,
                            envMap: Ue,
                            envMapMode: Ue && F.mapping,
                            envMapCubeUVHeight: X,
                            aoMap: ve,
                            lightMap: Ce,
                            bumpMap: qe,
                            normalMap: Q,
                            displacementMap: Ke,
                            emissiveMap: Ve,
                            normalMapObjectSpace: Q && B.normalMapType === P1,
                            normalMapTangentSpace: Q && B.normalMapType === eu,
                            metalnessMap: ft,
                            roughnessMap: ke,
                            anisotropy: Nt,
                            anisotropyMap: Oe,
                            clearcoat: Z,
                            clearcoatMap: pt,
                            clearcoatNormalMap: et,
                            clearcoatRoughnessMap: xt,
                            dispersion: H,
                            iridescence: he,
                            iridescenceMap: Dt,
                            iridescenceThicknessMap: je,
                            sheen: Le,
                            sheenColorMap: Xe,
                            sheenRoughnessMap: nt,
                            specularMap: ot,
                            specularColorMap: tt,
                            specularIntensityMap: Gt,
                            transmission: He,
                            transmissionMap: le,
                            thicknessMap: it,
                            gradientMap: Qe,
                            opaque: B.transparent === !1 && B.blending === yh && B.alphaToCoverage === !1,
                            alphaMap: dt,
                            alphaTest: We,
                            alphaHash: De,
                            combine: B.combine,
                            mapUv: Ct && w(B.map.channel),
                            aoMapUv: ve && w(B.aoMap.channel),
                            lightMapUv: Ce && w(B.lightMap.channel),
                            bumpMapUv: qe && w(B.bumpMap.channel),
                            normalMapUv: Q && w(B.normalMap.channel),
                            displacementMapUv: Ke && w(B.displacementMap.channel),
                            emissiveMapUv: Ve && w(B.emissiveMap.channel),
                            metalnessMapUv: ft && w(B.metalnessMap.channel),
                            roughnessMapUv: ke && w(B.roughnessMap.channel),
                            anisotropyMapUv: Oe && w(B.anisotropyMap.channel),
                            clearcoatMapUv: pt && w(B.clearcoatMap.channel),
                            clearcoatNormalMapUv: et && w(B.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: xt && w(B.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: Dt && w(B.iridescenceMap.channel),
                            iridescenceThicknessMapUv: je && w(B.iridescenceThicknessMap.channel),
                            sheenColorMapUv: Xe && w(B.sheenColorMap.channel),
                            sheenRoughnessMapUv: nt && w(B.sheenRoughnessMap.channel),
                            specularMapUv: ot && w(B.specularMap.channel),
                            specularColorMapUv: tt && w(B.specularColorMap.channel),
                            specularIntensityMapUv: Gt && w(B.specularIntensityMap.channel),
                            transmissionMapUv: le && w(B.transmissionMap.channel),
                            thicknessMapUv: it && w(B.thicknessMap.channel),
                            alphaMapUv: dt && w(B.alphaMap.channel),
                            vertexTangents: !!oe.attributes.tangent && (Q || Nt),
                            vertexColors: B.vertexColors,
                            vertexAlphas: B.vertexColors === !0 && !!oe.attributes.color && oe.attributes.color.itemSize === 4,
                            pointsUvs: ee.isPoints === !0 && !!oe.attributes.uv && (Ct || dt),
                            fog: !!te,
                            useFog: B.fog === !0,
                            fogExp2: !!te && te.isFogExp2,
                            flatShading: B.flatShading === !0 && B.wireframe === !1,
                            sizeAttenuation: B.sizeAttenuation === !0,
                            logarithmicDepthBuffer: y,
                            reversedDepthBuffer: Te,
                            skinning: ee.isSkinnedMesh === !0,
                            morphTargets: oe.morphAttributes.position !== void 0,
                            morphNormals: oe.morphAttributes.normal !== void 0,
                            morphColors: oe.morphAttributes.color !== void 0,
                            morphTargetsCount: ce,
                            morphTextureStride: k,
                            numDirLights: P.directional.length,
                            numPointLights: P.point.length,
                            numSpotLights: P.spot.length,
                            numSpotLightMaps: P.spotLightMap.length,
                            numRectAreaLights: P.rectArea.length,
                            numHemiLights: P.hemi.length,
                            numDirLightShadows: P.directionalShadowMap.length,
                            numPointLightShadows: P.pointShadowMap.length,
                            numSpotLightShadows: P.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
                            numLightProbes: P.numLightProbes,
                            numClippingPlanes: u.numPlanes,
                            numClipIntersection: u.numIntersection,
                            dithering: B.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && G.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: Tt,
                            decodeVideoTexture: Ct && B.map.isVideoTexture === !0 && xn.getTransfer(B.map.colorSpace) === Vn,
                            decodeVideoTextureEmissive: Ve && B.emissiveMap.isVideoTexture === !0 && xn.getTransfer(B.emissiveMap.colorSpace) === Vn,
                            premultipliedAlpha: B.premultipliedAlpha,
                            doubleSided: B.side === il,
                            flipSided: B.side === fa,
                            useDepthPacking: B.depthPacking >= 0,
                            depthPacking: B.depthPacking || 0,
                            index0AttributeName: B.index0AttributeName,
                            extensionClipCullDistance: mt && B.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (mt && B.extensions.multiDraw === !0 || Ze) && i.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: B.customProgramCacheKey()
                        };
                        return si.vertexUv1s = p.has(1),
                        si.vertexUv2s = p.has(2),
                        si.vertexUv3s = p.has(3),
                        p.clear(),
                        si
                    }
                    function T(B) {
                        const P = [];
                        if (B.shaderID ? P.push(B.shaderID) : (P.push(B.customVertexShaderID),
                        P.push(B.customFragmentShaderID)),
                        B.defines !== void 0)
                            for (const G in B.defines)
                                P.push(G),
                                P.push(B.defines[G]);
                        return B.isRawShaderMaterial === !1 && (R(P, B),
                        N(P, B),
                        P.push(t.outputColorSpace)),
                        P.push(B.customProgramCacheKey),
                        P.join()
                    }
                    function R(B, P) {
                        B.push(P.precision),
                        B.push(P.outputColorSpace),
                        B.push(P.envMapMode),
                        B.push(P.envMapCubeUVHeight),
                        B.push(P.mapUv),
                        B.push(P.alphaMapUv),
                        B.push(P.lightMapUv),
                        B.push(P.aoMapUv),
                        B.push(P.bumpMapUv),
                        B.push(P.normalMapUv),
                        B.push(P.displacementMapUv),
                        B.push(P.emissiveMapUv),
                        B.push(P.metalnessMapUv),
                        B.push(P.roughnessMapUv),
                        B.push(P.anisotropyMapUv),
                        B.push(P.clearcoatMapUv),
                        B.push(P.clearcoatNormalMapUv),
                        B.push(P.clearcoatRoughnessMapUv),
                        B.push(P.iridescenceMapUv),
                        B.push(P.iridescenceThicknessMapUv),
                        B.push(P.sheenColorMapUv),
                        B.push(P.sheenRoughnessMapUv),
                        B.push(P.specularMapUv),
                        B.push(P.specularColorMapUv),
                        B.push(P.specularIntensityMapUv),
                        B.push(P.transmissionMapUv),
                        B.push(P.thicknessMapUv),
                        B.push(P.combine),
                        B.push(P.fogExp2),
                        B.push(P.sizeAttenuation),
                        B.push(P.morphTargetsCount),
                        B.push(P.morphAttributeCount),
                        B.push(P.numDirLights),
                        B.push(P.numPointLights),
                        B.push(P.numSpotLights),
                        B.push(P.numSpotLightMaps),
                        B.push(P.numHemiLights),
                        B.push(P.numRectAreaLights),
                        B.push(P.numDirLightShadows),
                        B.push(P.numPointLightShadows),
                        B.push(P.numSpotLightShadows),
                        B.push(P.numSpotLightShadowsWithMaps),
                        B.push(P.numLightProbes),
                        B.push(P.shadowMapType),
                        B.push(P.toneMapping),
                        B.push(P.numClippingPlanes),
                        B.push(P.numClipIntersection),
                        B.push(P.depthPacking)
                    }
                    function N(B, P) {
                        f.disableAll(),
                        P.instancing && f.enable(0),
                        P.instancingColor && f.enable(1),
                        P.instancingMorph && f.enable(2),
                        P.matcap && f.enable(3),
                        P.envMap && f.enable(4),
                        P.normalMapObjectSpace && f.enable(5),
                        P.normalMapTangentSpace && f.enable(6),
                        P.clearcoat && f.enable(7),
                        P.iridescence && f.enable(8),
                        P.alphaTest && f.enable(9),
                        P.vertexColors && f.enable(10),
                        P.vertexAlphas && f.enable(11),
                        P.vertexUv1s && f.enable(12),
                        P.vertexUv2s && f.enable(13),
                        P.vertexUv3s && f.enable(14),
                        P.vertexTangents && f.enable(15),
                        P.anisotropy && f.enable(16),
                        P.alphaHash && f.enable(17),
                        P.batching && f.enable(18),
                        P.dispersion && f.enable(19),
                        P.batchingColor && f.enable(20),
                        P.gradientMap && f.enable(21),
                        B.push(f.mask),
                        f.disableAll(),
                        P.fog && f.enable(0),
                        P.useFog && f.enable(1),
                        P.flatShading && f.enable(2),
                        P.logarithmicDepthBuffer && f.enable(3),
                        P.reversedDepthBuffer && f.enable(4),
                        P.skinning && f.enable(5),
                        P.morphTargets && f.enable(6),
                        P.morphNormals && f.enable(7),
                        P.morphColors && f.enable(8),
                        P.premultipliedAlpha && f.enable(9),
                        P.shadowMapEnabled && f.enable(10),
                        P.doubleSided && f.enable(11),
                        P.flipSided && f.enable(12),
                        P.useDepthPacking && f.enable(13),
                        P.dithering && f.enable(14),
                        P.transmission && f.enable(15),
                        P.sheen && f.enable(16),
                        P.opaque && f.enable(17),
                        P.pointsUvs && f.enable(18),
                        P.decodeVideoTexture && f.enable(19),
                        P.decodeVideoTextureEmissive && f.enable(20),
                        P.alphaToCoverage && f.enable(21),
                        B.push(f.mask)
                    }
                    function D(B) {
                        const P = E[B.type];
                        let G;
                        if (P) {
                            const K = xo[P];
                            G = dA.clone(K.uniforms)
                        } else
                            G = B.uniforms;
                        return G
                    }
                    function U(B, P) {
                        let G = v.get(P);
                        return G !== void 0 ? ++G.usedTimes : (G = new xI(t,P,B,o),
                        g.push(G),
                        v.set(P, G)),
                        G
                    }
                    function z(B) {
                        if (--B.usedTimes === 0) {
                            const P = g.indexOf(B);
                            g[P] = g[g.length - 1],
                            g.pop(),
                            v.delete(B.cacheKey),
                            B.destroy()
                        }
                    }
                    function I(B) {
                        d.remove(B)
                    }
                    function V() {
                        d.dispose()
                    }
                    return {
                        getParameters: A,
                        getProgramCacheKey: T,
                        getUniforms: D,
                        acquireProgram: U,
                        releaseProgram: z,
                        releaseShaderCache: I,
                        programs: g,
                        dispose: V
                    }
                }
                function EI() {
                    let t = new WeakMap;
                    function e(u) {
                        return t.has(u)
                    }
                    function n(u) {
                        let f = t.get(u);
                        return f === void 0 && (f = {},
                        t.set(u, f)),
                        f
                    }
                    function i(u) {
                        t.delete(u)
                    }
                    function a(u, f, d) {
                        t.get(u)[f] = d
                    }
                    function o() {
                        t = new WeakMap
                    }
                    return {
                        has: e,
                        get: n,
                        remove: i,
                        update: a,
                        dispose: o
                    }
                }
                function CI(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                }
                function FC(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                }
                function HC() {
                    const t = [];
                    let e = 0;
                    const n = []
                      , i = []
                      , a = [];
                    function o() {
                        e = 0,
                        n.length = 0,
                        i.length = 0,
                        a.length = 0
                    }
                    function u(v, y, S, E, w, A) {
                        let T = t[e];
                        return T === void 0 ? (T = {
                            id: v.id,
                            object: v,
                            geometry: y,
                            material: S,
                            groupOrder: E,
                            renderOrder: v.renderOrder,
                            z: w,
                            group: A
                        },
                        t[e] = T) : (T.id = v.id,
                        T.object = v,
                        T.geometry = y,
                        T.material = S,
                        T.groupOrder = E,
                        T.renderOrder = v.renderOrder,
                        T.z = w,
                        T.group = A),
                        e++,
                        T
                    }
                    function f(v, y, S, E, w, A) {
                        const T = u(v, y, S, E, w, A);
                        S.transmission > 0 ? i.push(T) : S.transparent === !0 ? a.push(T) : n.push(T)
                    }
                    function d(v, y, S, E, w, A) {
                        const T = u(v, y, S, E, w, A);
                        S.transmission > 0 ? i.unshift(T) : S.transparent === !0 ? a.unshift(T) : n.unshift(T)
                    }
                    function p(v, y) {
                        n.length > 1 && n.sort(v || CI),
                        i.length > 1 && i.sort(y || FC),
                        a.length > 1 && a.sort(y || FC)
                    }
                    function g() {
                        for (let v = e, y = t.length; v < y; v++) {
                            const S = t[v];
                            if (S.id === null)
                                break;
                            S.id = null,
                            S.object = null,
                            S.geometry = null,
                            S.material = null,
                            S.group = null
                        }
                    }
                    return {
                        opaque: n,
                        transmissive: i,
                        transparent: a,
                        init: o,
                        push: f,
                        unshift: d,
                        finish: g,
                        sort: p
                    }
                }
                function wI() {
                    let t = new WeakMap;
                    function e(i, a) {
                        const o = t.get(i);
                        let u;
                        return o === void 0 ? (u = new HC,
                        t.set(i, [u])) : a >= o.length ? (u = new HC,
                        o.push(u)) : u = o[a],
                        u
                    }
                    function n() {
                        t = new WeakMap
                    }
                    return {
                        get: e,
                        dispose: n
                    }
                }
                function RI() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (t[e.id] !== void 0)
                                return t[e.id];
                            let n;
                            switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new J,
                                    color: new ut
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new J,
                                    direction: new J,
                                    color: new ut,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new J,
                                    color: new ut,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new J,
                                    skyColor: new ut,
                                    groundColor: new ut
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new ut,
                                    position: new J,
                                    halfWidth: new J,
                                    halfHeight: new J
                                };
                                break
                            }
                            return t[e.id] = n,
                            n
                        }
                    }
                }
                function NI() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (t[e.id] !== void 0)
                                return t[e.id];
                            let n;
                            switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Ge
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Ge
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Ge,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break
                            }
                            return t[e.id] = n,
                            n
                        }
                    }
                }
                let DI = 0;
                function OI(t, e) {
                    return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
                }
                function UI(t) {
                    const e = new RI
                      , n = NI()
                      , i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                    for (let p = 0; p < 9; p++)
                        i.probe.push(new J);
                    const a = new J
                      , o = new jt
                      , u = new jt;
                    function f(p) {
                        let g = 0
                          , v = 0
                          , y = 0;
                        for (let B = 0; B < 9; B++)
                            i.probe[B].set(0, 0, 0);
                        let S = 0
                          , E = 0
                          , w = 0
                          , A = 0
                          , T = 0
                          , R = 0
                          , N = 0
                          , D = 0
                          , U = 0
                          , z = 0
                          , I = 0;
                        p.sort(OI);
                        for (let B = 0, P = p.length; B < P; B++) {
                            const G = p[B]
                              , K = G.color
                              , ee = G.intensity
                              , te = G.distance;
                            let oe = null;
                            if (G.shadow && G.shadow.map && (G.shadow.map.texture.format === xh ? oe = G.shadow.map.texture : oe = G.shadow.map.depthTexture || G.shadow.map.texture),
                            G.isAmbientLight)
                                g += K.r * ee,
                                v += K.g * ee,
                                y += K.b * ee;
                            else if (G.isLightProbe) {
                                for (let q = 0; q < 9; q++)
                                    i.probe[q].addScaledVector(G.sh.coefficients[q], ee);
                                I++
                            } else if (G.isDirectionalLight) {
                                const q = e.get(G);
                                if (q.color.copy(G.color).multiplyScalar(G.intensity),
                                G.castShadow) {
                                    const F = G.shadow
                                      , X = n.get(G);
                                    X.shadowIntensity = F.intensity,
                                    X.shadowBias = F.bias,
                                    X.shadowNormalBias = F.normalBias,
                                    X.shadowRadius = F.radius,
                                    X.shadowMapSize = F.mapSize,
                                    i.directionalShadow[S] = X,
                                    i.directionalShadowMap[S] = oe,
                                    i.directionalShadowMatrix[S] = G.shadow.matrix,
                                    R++
                                }
                                i.directional[S] = q,
                                S++
                            } else if (G.isSpotLight) {
                                const q = e.get(G);
                                q.position.setFromMatrixPosition(G.matrixWorld),
                                q.color.copy(K).multiplyScalar(ee),
                                q.distance = te,
                                q.coneCos = Math.cos(G.angle),
                                q.penumbraCos = Math.cos(G.angle * (1 - G.penumbra)),
                                q.decay = G.decay,
                                i.spot[w] = q;
                                const F = G.shadow;
                                if (G.map && (i.spotLightMap[U] = G.map,
                                U++,
                                F.updateMatrices(G),
                                G.castShadow && z++),
                                i.spotLightMatrix[w] = F.matrix,
                                G.castShadow) {
                                    const X = n.get(G);
                                    X.shadowIntensity = F.intensity,
                                    X.shadowBias = F.bias,
                                    X.shadowNormalBias = F.normalBias,
                                    X.shadowRadius = F.radius,
                                    X.shadowMapSize = F.mapSize,
                                    i.spotShadow[w] = X,
                                    i.spotShadowMap[w] = oe,
                                    D++
                                }
                                w++
                            } else if (G.isRectAreaLight) {
                                const q = e.get(G);
                                q.color.copy(K).multiplyScalar(ee),
                                q.halfWidth.set(G.width * .5, 0, 0),
                                q.halfHeight.set(0, G.height * .5, 0),
                                i.rectArea[A] = q,
                                A++
                            } else if (G.isPointLight) {
                                const q = e.get(G);
                                if (q.color.copy(G.color).multiplyScalar(G.intensity),
                                q.distance = G.distance,
                                q.decay = G.decay,
                                G.castShadow) {
                                    const F = G.shadow
                                      , X = n.get(G);
                                    X.shadowIntensity = F.intensity,
                                    X.shadowBias = F.bias,
                                    X.shadowNormalBias = F.normalBias,
                                    X.shadowRadius = F.radius,
                                    X.shadowMapSize = F.mapSize,
                                    X.shadowCameraNear = F.camera.near,
                                    X.shadowCameraFar = F.camera.far,
                                    i.pointShadow[E] = X,
                                    i.pointShadowMap[E] = oe,
                                    i.pointShadowMatrix[E] = G.shadow.matrix,
                                    N++
                                }
                                i.point[E] = q,
                                E++
                            } else if (G.isHemisphereLight) {
                                const q = e.get(G);
                                q.skyColor.copy(G.color).multiplyScalar(ee),
                                q.groundColor.copy(G.groundColor).multiplyScalar(ee),
                                i.hemi[T] = q,
                                T++
                            }
                        }
                        A > 0 && (t.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = rt.LTC_FLOAT_1,
                        i.rectAreaLTC2 = rt.LTC_FLOAT_2) : (i.rectAreaLTC1 = rt.LTC_HALF_1,
                        i.rectAreaLTC2 = rt.LTC_HALF_2)),
                        i.ambient[0] = g,
                        i.ambient[1] = v,
                        i.ambient[2] = y;
                        const V = i.hash;
                        (V.directionalLength !== S || V.pointLength !== E || V.spotLength !== w || V.rectAreaLength !== A || V.hemiLength !== T || V.numDirectionalShadows !== R || V.numPointShadows !== N || V.numSpotShadows !== D || V.numSpotMaps !== U || V.numLightProbes !== I) && (i.directional.length = S,
                        i.spot.length = w,
                        i.rectArea.length = A,
                        i.point.length = E,
                        i.hemi.length = T,
                        i.directionalShadow.length = R,
                        i.directionalShadowMap.length = R,
                        i.pointShadow.length = N,
                        i.pointShadowMap.length = N,
                        i.spotShadow.length = D,
                        i.spotShadowMap.length = D,
                        i.directionalShadowMatrix.length = R,
                        i.pointShadowMatrix.length = N,
                        i.spotLightMatrix.length = D + U - z,
                        i.spotLightMap.length = U,
                        i.numSpotLightShadowsWithMaps = z,
                        i.numLightProbes = I,
                        V.directionalLength = S,
                        V.pointLength = E,
                        V.spotLength = w,
                        V.rectAreaLength = A,
                        V.hemiLength = T,
                        V.numDirectionalShadows = R,
                        V.numPointShadows = N,
                        V.numSpotShadows = D,
                        V.numSpotMaps = U,
                        V.numLightProbes = I,
                        i.version = DI++)
                    }
                    function d(p, g) {
                        let v = 0
                          , y = 0
                          , S = 0
                          , E = 0
                          , w = 0;
                        const A = g.matrixWorldInverse;
                        for (let T = 0, R = p.length; T < R; T++) {
                            const N = p[T];
                            if (N.isDirectionalLight) {
                                const D = i.directional[v];
                                D.direction.setFromMatrixPosition(N.matrixWorld),
                                a.setFromMatrixPosition(N.target.matrixWorld),
                                D.direction.sub(a),
                                D.direction.transformDirection(A),
                                v++
                            } else if (N.isSpotLight) {
                                const D = i.spot[S];
                                D.position.setFromMatrixPosition(N.matrixWorld),
                                D.position.applyMatrix4(A),
                                D.direction.setFromMatrixPosition(N.matrixWorld),
                                a.setFromMatrixPosition(N.target.matrixWorld),
                                D.direction.sub(a),
                                D.direction.transformDirection(A),
                                S++
                            } else if (N.isRectAreaLight) {
                                const D = i.rectArea[E];
                                D.position.setFromMatrixPosition(N.matrixWorld),
                                D.position.applyMatrix4(A),
                                u.identity(),
                                o.copy(N.matrixWorld),
                                o.premultiply(A),
                                u.extractRotation(o),
                                D.halfWidth.set(N.width * .5, 0, 0),
                                D.halfHeight.set(0, N.height * .5, 0),
                                D.halfWidth.applyMatrix4(u),
                                D.halfHeight.applyMatrix4(u),
                                E++
                            } else if (N.isPointLight) {
                                const D = i.point[y];
                                D.position.setFromMatrixPosition(N.matrixWorld),
                                D.position.applyMatrix4(A),
                                y++
                            } else if (N.isHemisphereLight) {
                                const D = i.hemi[w];
                                D.direction.setFromMatrixPosition(N.matrixWorld),
                                D.direction.transformDirection(A),
                                w++
                            }
                        }
                    }
                    return {
                        setup: f,
                        setupView: d,
                        state: i
                    }
                }
                function GC(t) {
                    const e = new UI(t)
                      , n = []
                      , i = [];
                    function a(g) {
                        p.camera = g,
                        n.length = 0,
                        i.length = 0
                    }
                    function o(g) {
                        n.push(g)
                    }
                    function u(g) {
                        i.push(g)
                    }
                    function f() {
                        e.setup(n)
                    }
                    function d(g) {
                        e.setupView(n, g)
                    }
                    const p = {
                        lightsArray: n,
                        shadowsArray: i,
                        camera: null,
                        lights: e,
                        transmissionRenderTarget: {}
                    };
                    return {
                        init: a,
                        state: p,
                        setupLights: f,
                        setupLightsView: d,
                        pushLight: o,
                        pushShadow: u
                    }
                }
                function LI(t) {
                    let e = new WeakMap;
                    function n(a, o=0) {
                        const u = e.get(a);
                        let f;
                        return u === void 0 ? (f = new GC(t),
                        e.set(a, [f])) : o >= u.length ? (f = new GC(t),
                        u.push(f)) : f = u[o],
                        f
                    }
                    function i() {
                        e = new WeakMap
                    }
                    return {
                        get: n,
                        dispose: i
                    }
                }
                const II = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
                  , zI = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );
	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );
}`
                  , BI = [new J(1,0,0), new J(-1,0,0), new J(0,1,0), new J(0,-1,0), new J(0,0,1), new J(0,0,-1)]
                  , PI = [new J(0,-1,0), new J(0,-1,0), new J(0,0,1), new J(0,0,-1), new J(0,-1,0), new J(0,-1,0)]
                  , kC = new jt
                  , Qg = new J
                  , ub = new J;
                function VI(t, e, n) {
                    let i = new $d;
                    const a = new Ge
                      , o = new Ge
                      , u = new di
                      , f = new LM
                      , d = new IM
                      , p = {}
                      , g = n.maxTextureSize
                      , v = {
                        [$l]: fa,
                        [fa]: $l,
                        [il]: il
                    }
                      , y = new Br({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Ge
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: II,
                        fragmentShader: zI
                    })
                      , S = y.clone();
                    S.defines.HORIZONTAL_PASS = 1;
                    const E = new en;
                    E.setAttribute("position", new Kn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                    const w = new Ji(E,y)
                      , A = this;
                    this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = xd;
                    let T = this.type;
                    this.render = function(z, I, V) {
                        if (A.enabled === !1 || A.autoUpdate === !1 && A.needsUpdate === !1 || z.length === 0)
                            return;
                        z.type === ng && (at("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead."),
                        z.type = xd);
                        const B = t.getRenderTarget()
                          , P = t.getActiveCubeFace()
                          , G = t.getActiveMipmapLevel()
                          , K = t.state;
                        K.setBlending(sl),
                        K.buffers.depth.getReversed() === !0 ? K.buffers.color.setClear(0, 0, 0, 0) : K.buffers.color.setClear(1, 1, 1, 1),
                        K.buffers.depth.setTest(!0),
                        K.setScissorTest(!1);
                        const ee = T !== this.type;
                        ee && I.traverse(function(te) {
                            te.material && (Array.isArray(te.material) ? te.material.forEach(oe => oe.needsUpdate = !0) : te.material.needsUpdate = !0)
                        });
                        for (let te = 0, oe = z.length; te < oe; te++) {
                            const q = z[te]
                              , F = q.shadow;
                            if (F === void 0) {
                                at("WebGLShadowMap:", q, "has no shadow.");
                                continue
                            }
                            if (F.autoUpdate === !1 && F.needsUpdate === !1)
                                continue;
                            a.copy(F.mapSize);
                            const X = F.getFrameExtents();
                            if (a.multiply(X),
                            o.copy(F.mapSize),
                            (a.x > g || a.y > g) && (a.x > g && (o.x = Math.floor(g / X.x),
                            a.x = o.x * X.x,
                            F.mapSize.x = o.x),
                            a.y > g && (o.y = Math.floor(g / X.y),
                            a.y = o.y * X.y,
                            F.mapSize.y = o.y)),
                            F.map === null || ee === !0) {
                                if (F.map !== null && (F.map.depthTexture !== null && (F.map.depthTexture.dispose(),
                                F.map.depthTexture = null),
                                F.map.dispose()),
                                this.type === _h) {
                                    if (q.isPointLight) {
                                        at("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");
                                        continue
                                    }
                                    F.map = new sr(a.x,a.y,{
                                        format: xh,
                                        type: ol,
                                        minFilter: fi,
                                        magFilter: fi,
                                        generateMipmaps: !1
                                    }),
                                    F.map.texture.name = q.name + ".shadowMap",
                                    F.map.depthTexture = new ep(a.x,a.y,pa),
                                    F.map.depthTexture.name = q.name + ".shadowMapDepth",
                                    F.map.depthTexture.format = ll,
                                    F.map.depthTexture.compareFunction = null,
                                    F.map.depthTexture.minFilter = Vi,
                                    F.map.depthTexture.magFilter = Vi
                                } else {
                                    q.isPointLight ? (F.map = new nM(a.x),
                                    F.map.depthTexture = new ZA(a.x,Ir)) : (F.map = new sr(a.x,a.y),
                                    F.map.depthTexture = new ep(a.x,a.y,Ir)),
                                    F.map.depthTexture.name = q.name + ".shadowMap",
                                    F.map.depthTexture.format = ll;
                                    const ne = t.state.buffers.depth.getReversed();
                                    this.type === xd ? (F.map.depthTexture.compareFunction = ne ? z0 : I0,
                                    F.map.depthTexture.minFilter = fi,
                                    F.map.depthTexture.magFilter = fi) : (F.map.depthTexture.compareFunction = null,
                                    F.map.depthTexture.minFilter = Vi,
                                    F.map.depthTexture.magFilter = Vi)
                                }
                                F.camera.updateProjectionMatrix()
                            }
                            const $ = F.map.isWebGLCubeRenderTarget ? 6 : 1;
                            for (let ne = 0; ne < $; ne++) {
                                if (F.map.isWebGLCubeRenderTarget)
                                    t.setRenderTarget(F.map, ne),
                                    t.clear();
                                else {
                                    ne === 0 && (t.setRenderTarget(F.map),
                                    t.clear());
                                    const ce = F.getViewport(ne);
                                    u.set(o.x * ce.x, o.y * ce.y, o.x * ce.z, o.y * ce.w),
                                    K.viewport(u)
                                }
                                if (q.isPointLight) {
                                    const ce = F.camera
                                      , k = F.matrix
                                      , pe = q.distance || ce.far;
                                    pe !== ce.far && (ce.far = pe,
                                    ce.updateProjectionMatrix()),
                                    Qg.setFromMatrixPosition(q.matrixWorld),
                                    ce.position.copy(Qg),
                                    ub.copy(ce.position),
                                    ub.add(BI[ne]),
                                    ce.up.copy(PI[ne]),
                                    ce.lookAt(ub),
                                    ce.updateMatrixWorld(),
                                    k.makeTranslation(-Qg.x, -Qg.y, -Qg.z),
                                    kC.multiplyMatrices(ce.projectionMatrix, ce.matrixWorldInverse),
                                    F._frustum.setFromProjectionMatrix(kC, ce.coordinateSystem, ce.reversedDepth)
                                } else
                                    F.updateMatrices(q);
                                i = F.getFrustum(),
                                D(I, V, F.camera, q, this.type)
                            }
                            F.isPointLightShadow !== !0 && this.type === _h && R(F, V),
                            F.needsUpdate = !1
                        }
                        T = this.type,
                        A.needsUpdate = !1,
                        t.setRenderTarget(B, P, G)
                    }
                    ;
                    function R(z, I) {
                        const V = e.update(w);
                        y.defines.VSM_SAMPLES !== z.blurSamples && (y.defines.VSM_SAMPLES = z.blurSamples,
                        S.defines.VSM_SAMPLES = z.blurSamples,
                        y.needsUpdate = !0,
                        S.needsUpdate = !0),
                        z.mapPass === null && (z.mapPass = new sr(a.x,a.y,{
                            format: xh,
                            type: ol
                        })),
                        y.uniforms.shadow_pass.value = z.map.depthTexture,
                        y.uniforms.resolution.value = z.mapSize,
                        y.uniforms.radius.value = z.radius,
                        t.setRenderTarget(z.mapPass),
                        t.clear(),
                        t.renderBufferDirect(I, null, V, y, w, null),
                        S.uniforms.shadow_pass.value = z.mapPass.texture,
                        S.uniforms.resolution.value = z.mapSize,
                        S.uniforms.radius.value = z.radius,
                        t.setRenderTarget(z.map),
                        t.clear(),
                        t.renderBufferDirect(I, null, V, S, w, null)
                    }
                    function N(z, I, V, B) {
                        let P = null;
                        const G = V.isPointLight === !0 ? z.customDistanceMaterial : z.customDepthMaterial;
                        if (G !== void 0)
                            P = G;
                        else if (P = V.isPointLight === !0 ? d : f,
                        t.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0 || I.alphaToCoverage === !0) {
                            const K = P.uuid
                              , ee = I.uuid;
                            let te = p[K];
                            te === void 0 && (te = {},
                            p[K] = te);
                            let oe = te[ee];
                            oe === void 0 && (oe = P.clone(),
                            te[ee] = oe,
                            I.addEventListener("dispose", U)),
                            P = oe
                        }
                        if (P.visible = I.visible,
                        P.wireframe = I.wireframe,
                        B === _h ? P.side = I.shadowSide !== null ? I.shadowSide : I.side : P.side = I.shadowSide !== null ? I.shadowSide : v[I.side],
                        P.alphaMap = I.alphaMap,
                        P.alphaTest = I.alphaToCoverage === !0 ? .5 : I.alphaTest,
                        P.map = I.map,
                        P.clipShadows = I.clipShadows,
                        P.clippingPlanes = I.clippingPlanes,
                        P.clipIntersection = I.clipIntersection,
                        P.displacementMap = I.displacementMap,
                        P.displacementScale = I.displacementScale,
                        P.displacementBias = I.displacementBias,
                        P.wireframeLinewidth = I.wireframeLinewidth,
                        P.linewidth = I.linewidth,
                        V.isPointLight === !0 && P.isMeshDistanceMaterial === !0) {
                            const K = t.properties.get(P);
                            K.light = V
                        }
                        return P
                    }
                    function D(z, I, V, B, P) {
                        if (z.visible === !1)
                            return;
                        if (z.layers.test(I.layers) && (z.isMesh || z.isLine || z.isPoints) && (z.castShadow || z.receiveShadow && P === _h) && (!z.frustumCulled || i.intersectsObject(z))) {
                            z.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse, z.matrixWorld);
                            const K = e.update(z)
                              , ee = z.material;
                            if (Array.isArray(ee)) {
                                const te = K.groups;
                                for (let oe = 0, q = te.length; oe < q; oe++) {
                                    const F = te[oe]
                                      , X = ee[F.materialIndex];
                                    if (X && X.visible) {
                                        const $ = N(z, X, B, P);
                                        z.onBeforeShadow(t, z, I, V, K, $, F),
                                        t.renderBufferDirect(V, null, K, $, z, F),
                                        z.onAfterShadow(t, z, I, V, K, $, F)
                                    }
                                }
                            } else if (ee.visible) {
                                const te = N(z, ee, B, P);
                                z.onBeforeShadow(t, z, I, V, K, te, null),
                                t.renderBufferDirect(V, null, K, te, z, null),
                                z.onAfterShadow(t, z, I, V, K, te, null)
                            }
                        }
                        const G = z.children;
                        for (let K = 0, ee = G.length; K < ee; K++)
                            D(G[K], I, V, B, P)
                    }
                    function U(z) {
                        z.target.removeEventListener("dispose", U);
                        for (const I in p) {
                            const V = p[I]
                              , B = z.target.uuid;
                            B in V && (V[B].dispose(),
                            delete V[B])
                        }
                    }
                }
                const FI = {
                    [V_]: F_,
                    [H_]: q_,
                    [G_]: X_,
                    [Sh]: k_,
                    [F_]: V_,
                    [q_]: H_,
                    [X_]: G_,
                    [k_]: Sh
                };
                function HI(t, e) {
                    function n() {
                        let le = !1;
                        const it = new di;
                        let Qe = null;
                        const dt = new di(0,0,0,0);
                        return {
                            setMask: function(We) {
                                Qe !== We && !le && (t.colorMask(We, We, We, We),
                                Qe = We)
                            },
                            setLocked: function(We) {
                                le = We
                            },
                            setClear: function(We, De, mt, Tt, si) {
                                si === !0 && (We *= Tt,
                                De *= Tt,
                                mt *= Tt),
                                it.set(We, De, mt, Tt),
                                dt.equals(it) === !1 && (t.clearColor(We, De, mt, Tt),
                                dt.copy(it))
                            },
                            reset: function() {
                                le = !1,
                                Qe = null,
                                dt.set(-1, 0, 0, 0)
                            }
                        }
                    }
                    function i() {
                        let le = !1
                          , it = !1
                          , Qe = null
                          , dt = null
                          , We = null;
                        return {
                            setReversed: function(De) {
                                if (it !== De) {
                                    const mt = e.get("EXT_clip_control");
                                    De ? mt.clipControlEXT(mt.LOWER_LEFT_EXT, mt.ZERO_TO_ONE_EXT) : mt.clipControlEXT(mt.LOWER_LEFT_EXT, mt.NEGATIVE_ONE_TO_ONE_EXT),
                                    it = De;
                                    const Tt = We;
                                    We = null,
                                    this.setClear(Tt)
                                }
                            },
                            getReversed: function() {
                                return it
                            },
                            setTest: function(De) {
                                De ? we(t.DEPTH_TEST) : Te(t.DEPTH_TEST)
                            },
                            setMask: function(De) {
                                Qe !== De && !le && (t.depthMask(De),
                                Qe = De)
                            },
                            setFunc: function(De) {
                                if (it && (De = FI[De]),
                                dt !== De) {
                                    switch (De) {
                                    case V_:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case F_:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case H_:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case Sh:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case G_:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case k_:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case q_:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case X_:
                                        t.depthFunc(t.NOTEQUAL);
                                        break;
                                    default:
                                        t.depthFunc(t.LEQUAL)
                                    }
                                    dt = De
                                }
                            },
                            setLocked: function(De) {
                                le = De
                            },
                            setClear: function(De) {
                                We !== De && (it && (De = 1 - De),
                                t.clearDepth(De),
                                We = De)
                            },
                            reset: function() {
                                le = !1,
                                Qe = null,
                                dt = null,
                                We = null,
                                it = !1
                            }
                        }
                    }
                    function a() {
                        let le = !1
                          , it = null
                          , Qe = null
                          , dt = null
                          , We = null
                          , De = null
                          , mt = null
                          , Tt = null
                          , si = null;
                        return {
                            setTest: function(pn) {
                                le || (pn ? we(t.STENCIL_TEST) : Te(t.STENCIL_TEST))
                            },
                            setMask: function(pn) {
                                it !== pn && !le && (t.stencilMask(pn),
                                it = pn)
                            },
                            setFunc: function(pn, cs, ys) {
                                (Qe !== pn || dt !== cs || We !== ys) && (t.stencilFunc(pn, cs, ys),
                                Qe = pn,
                                dt = cs,
                                We = ys)
                            },
                            setOp: function(pn, cs, ys) {
                                (De !== pn || mt !== cs || Tt !== ys) && (t.stencilOp(pn, cs, ys),
                                De = pn,
                                mt = cs,
                                Tt = ys)
                            },
                            setLocked: function(pn) {
                                le = pn
                            },
                            setClear: function(pn) {
                                si !== pn && (t.clearStencil(pn),
                                si = pn)
                            },
                            reset: function() {
                                le = !1,
                                it = null,
                                Qe = null,
                                dt = null,
                                We = null,
                                De = null,
                                mt = null,
                                Tt = null,
                                si = null
                            }
                        }
                    }
                    const o = new n
                      , u = new i
                      , f = new a
                      , d = new WeakMap
                      , p = new WeakMap;
                    let g = {}
                      , v = {}
                      , y = new WeakMap
                      , S = []
                      , E = null
                      , w = !1
                      , A = null
                      , T = null
                      , R = null
                      , N = null
                      , D = null
                      , U = null
                      , z = null
                      , I = new ut(0,0,0)
                      , V = 0
                      , B = !1
                      , P = null
                      , G = null
                      , K = null
                      , ee = null
                      , te = null;
                    const oe = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    let q = !1
                      , F = 0;
                    const X = t.getParameter(t.VERSION);
                    X.indexOf("WebGL") !== -1 ? (F = parseFloat(/^WebGL (\d)/.exec(X)[1]),
                    q = F >= 1) : X.indexOf("OpenGL ES") !== -1 && (F = parseFloat(/^OpenGL ES (\d)/.exec(X)[1]),
                    q = F >= 2);
                    let $ = null
                      , ne = {};
                    const ce = t.getParameter(t.SCISSOR_BOX)
                      , k = t.getParameter(t.VIEWPORT)
                      , pe = new di().fromArray(ce)
                      , Ae = new di().fromArray(k);
                    function ie(le, it, Qe, dt) {
                        const We = new Uint8Array(4)
                          , De = t.createTexture();
                        t.bindTexture(le, De),
                        t.texParameteri(le, t.TEXTURE_MIN_FILTER, t.NEAREST),
                        t.texParameteri(le, t.TEXTURE_MAG_FILTER, t.NEAREST);
                        for (let mt = 0; mt < Qe; mt++)
                            le === t.TEXTURE_3D || le === t.TEXTURE_2D_ARRAY ? t.texImage3D(it, 0, t.RGBA, 1, 1, dt, 0, t.RGBA, t.UNSIGNED_BYTE, We) : t.texImage2D(it + mt, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, We);
                        return De
                    }
                    const Me = {};
                    Me[t.TEXTURE_2D] = ie(t.TEXTURE_2D, t.TEXTURE_2D, 1),
                    Me[t.TEXTURE_CUBE_MAP] = ie(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                    Me[t.TEXTURE_2D_ARRAY] = ie(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1),
                    Me[t.TEXTURE_3D] = ie(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1),
                    o.setClear(0, 0, 0, 1),
                    u.setClear(1),
                    f.setClear(0),
                    we(t.DEPTH_TEST),
                    u.setFunc(Sh),
                    qe(!1),
                    Q(hx),
                    we(t.CULL_FACE),
                    ve(sl);
                    function we(le) {
                        g[le] !== !0 && (t.enable(le),
                        g[le] = !0)
                    }
                    function Te(le) {
                        g[le] !== !1 && (t.disable(le),
                        g[le] = !1)
                    }
                    function Je(le, it) {
                        return v[le] !== it ? (t.bindFramebuffer(le, it),
                        v[le] = it,
                        le === t.DRAW_FRAMEBUFFER && (v[t.FRAMEBUFFER] = it),
                        le === t.FRAMEBUFFER && (v[t.DRAW_FRAMEBUFFER] = it),
                        !0) : !1
                    }
                    function Ze(le, it) {
                        let Qe = S
                          , dt = !1;
                        if (le) {
                            Qe = y.get(it),
                            Qe === void 0 && (Qe = [],
                            y.set(it, Qe));
                            const We = le.textures;
                            if (Qe.length !== We.length || Qe[0] !== t.COLOR_ATTACHMENT0) {
                                for (let De = 0, mt = We.length; De < mt; De++)
                                    Qe[De] = t.COLOR_ATTACHMENT0 + De;
                                Qe.length = We.length,
                                dt = !0
                            }
                        } else
                            Qe[0] !== t.BACK && (Qe[0] = t.BACK,
                            dt = !0);
                        dt && t.drawBuffers(Qe)
                    }
                    function Ct(le) {
                        return E !== le ? (t.useProgram(le),
                        E = le,
                        !0) : !1
                    }
                    const bt = {
                        [Kc]: t.FUNC_ADD,
                        [p1]: t.FUNC_SUBTRACT,
                        [m1]: t.FUNC_REVERSE_SUBTRACT
                    };
                    bt[g1] = t.MIN,
                    bt[v1] = t.MAX;
                    const Ue = {
                        [_1]: t.ZERO,
                        [y1]: t.ONE,
                        [S1]: t.SRC_COLOR,
                        [B_]: t.SRC_ALPHA,
                        [E1]: t.SRC_ALPHA_SATURATE,
                        [T1]: t.DST_COLOR,
                        [M1]: t.DST_ALPHA,
                        [x1]: t.ONE_MINUS_SRC_COLOR,
                        [P_]: t.ONE_MINUS_SRC_ALPHA,
                        [A1]: t.ONE_MINUS_DST_COLOR,
                        [b1]: t.ONE_MINUS_DST_ALPHA,
                        [C1]: t.CONSTANT_COLOR,
                        [w1]: t.ONE_MINUS_CONSTANT_COLOR,
                        [R1]: t.CONSTANT_ALPHA,
                        [N1]: t.ONE_MINUS_CONSTANT_ALPHA
                    };
                    function ve(le, it, Qe, dt, We, De, mt, Tt, si, pn) {
                        if (le === sl) {
                            w === !0 && (Te(t.BLEND),
                            w = !1);
                            return
                        }
                        if (w === !1 && (we(t.BLEND),
                        w = !0),
                        le !== d1) {
                            if (le !== A || pn !== B) {
                                if ((T !== Kc || D !== Kc) && (t.blendEquation(t.FUNC_ADD),
                                T = Kc,
                                D = Kc),
                                pn)
                                    switch (le) {
                                    case yh:
                                        t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case fx:
                                        t.blendFunc(t.ONE, t.ONE);
                                        break;
                                    case dx:
                                        t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                        break;
                                    case px:
                                        t.blendFuncSeparate(t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ZERO, t.ONE);
                                        break;
                                    default:
                                        Rt("WebGLState: Invalid blending: ", le);
                                        break
                                    }
                                else
                                    switch (le) {
                                    case yh:
                                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case fx:
                                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE, t.ONE, t.ONE);
                                        break;
                                    case dx:
                                        Rt("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                                        break;
                                    case px:
                                        Rt("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                                        break;
                                    default:
                                        Rt("WebGLState: Invalid blending: ", le);
                                        break
                                    }
                                R = null,
                                N = null,
                                U = null,
                                z = null,
                                I.set(0, 0, 0),
                                V = 0,
                                A = le,
                                B = pn
                            }
                            return
                        }
                        We = We || it,
                        De = De || Qe,
                        mt = mt || dt,
                        (it !== T || We !== D) && (t.blendEquationSeparate(bt[it], bt[We]),
                        T = it,
                        D = We),
                        (Qe !== R || dt !== N || De !== U || mt !== z) && (t.blendFuncSeparate(Ue[Qe], Ue[dt], Ue[De], Ue[mt]),
                        R = Qe,
                        N = dt,
                        U = De,
                        z = mt),
                        (Tt.equals(I) === !1 || si !== V) && (t.blendColor(Tt.r, Tt.g, Tt.b, si),
                        I.copy(Tt),
                        V = si),
                        A = le,
                        B = !1
                    }
                    function Ce(le, it) {
                        le.side === il ? Te(t.CULL_FACE) : we(t.CULL_FACE);
                        let Qe = le.side === fa;
                        it && (Qe = !Qe),
                        qe(Qe),
                        le.blending === yh && le.transparent === !1 ? ve(sl) : ve(le.blending, le.blendEquation, le.blendSrc, le.blendDst, le.blendEquationAlpha, le.blendSrcAlpha, le.blendDstAlpha, le.blendColor, le.blendAlpha, le.premultipliedAlpha),
                        u.setFunc(le.depthFunc),
                        u.setTest(le.depthTest),
                        u.setMask(le.depthWrite),
                        o.setMask(le.colorWrite);
                        const dt = le.stencilWrite;
                        f.setTest(dt),
                        dt && (f.setMask(le.stencilWriteMask),
                        f.setFunc(le.stencilFunc, le.stencilRef, le.stencilFuncMask),
                        f.setOp(le.stencilFail, le.stencilZFail, le.stencilZPass)),
                        Ve(le.polygonOffset, le.polygonOffsetFactor, le.polygonOffsetUnits),
                        le.alphaToCoverage === !0 ? we(t.SAMPLE_ALPHA_TO_COVERAGE) : Te(t.SAMPLE_ALPHA_TO_COVERAGE)
                    }
                    function qe(le) {
                        P !== le && (le ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                        P = le)
                    }
                    function Q(le) {
                        le !== u1 ? (we(t.CULL_FACE),
                        le !== G && (le === hx ? t.cullFace(t.BACK) : le === h1 ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Te(t.CULL_FACE),
                        G = le
                    }
                    function Ke(le) {
                        le !== K && (q && t.lineWidth(le),
                        K = le)
                    }
                    function Ve(le, it, Qe) {
                        le ? (we(t.POLYGON_OFFSET_FILL),
                        (ee !== it || te !== Qe) && (t.polygonOffset(it, Qe),
                        ee = it,
                        te = Qe)) : Te(t.POLYGON_OFFSET_FILL)
                    }
                    function ft(le) {
                        le ? we(t.SCISSOR_TEST) : Te(t.SCISSOR_TEST)
                    }
                    function ke(le) {
                        le === void 0 && (le = t.TEXTURE0 + oe - 1),
                        $ !== le && (t.activeTexture(le),
                        $ = le)
                    }
                    function Nt(le, it, Qe) {
                        Qe === void 0 && ($ === null ? Qe = t.TEXTURE0 + oe - 1 : Qe = $);
                        let dt = ne[Qe];
                        dt === void 0 && (dt = {
                            type: void 0,
                            texture: void 0
                        },
                        ne[Qe] = dt),
                        (dt.type !== le || dt.texture !== it) && ($ !== Qe && (t.activeTexture(Qe),
                        $ = Qe),
                        t.bindTexture(le, it || Me[le]),
                        dt.type = le,
                        dt.texture = it)
                    }
                    function Z() {
                        const le = ne[$];
                        le !== void 0 && le.type !== void 0 && (t.bindTexture(le.type, null),
                        le.type = void 0,
                        le.texture = void 0)
                    }
                    function H() {
                        try {
                            t.compressedTexImage2D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function he() {
                        try {
                            t.compressedTexImage3D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function Le() {
                        try {
                            t.texSubImage2D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function He() {
                        try {
                            t.texSubImage3D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function Oe() {
                        try {
                            t.compressedTexSubImage2D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function pt() {
                        try {
                            t.compressedTexSubImage3D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function et() {
                        try {
                            t.texStorage2D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function xt() {
                        try {
                            t.texStorage3D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function Dt() {
                        try {
                            t.texImage2D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function je() {
                        try {
                            t.texImage3D(...arguments)
                        } catch (le) {
                            Rt("WebGLState:", le)
                        }
                    }
                    function Xe(le) {
                        pe.equals(le) === !1 && (t.scissor(le.x, le.y, le.z, le.w),
                        pe.copy(le))
                    }
                    function nt(le) {
                        Ae.equals(le) === !1 && (t.viewport(le.x, le.y, le.z, le.w),
                        Ae.copy(le))
                    }
                    function ot(le, it) {
                        let Qe = p.get(it);
                        Qe === void 0 && (Qe = new WeakMap,
                        p.set(it, Qe));
                        let dt = Qe.get(le);
                        dt === void 0 && (dt = t.getUniformBlockIndex(it, le.name),
                        Qe.set(le, dt))
                    }
                    function tt(le, it) {
                        const Qe = p.get(it).get(le);
                        d.get(it) !== Qe && (t.uniformBlockBinding(it, Qe, le.__bindingPointIndex),
                        d.set(it, Qe))
                    }
                    function Gt() {
                        t.disable(t.BLEND),
                        t.disable(t.CULL_FACE),
                        t.disable(t.DEPTH_TEST),
                        t.disable(t.POLYGON_OFFSET_FILL),
                        t.disable(t.SCISSOR_TEST),
                        t.disable(t.STENCIL_TEST),
                        t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                        t.blendEquation(t.FUNC_ADD),
                        t.blendFunc(t.ONE, t.ZERO),
                        t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                        t.blendColor(0, 0, 0, 0),
                        t.colorMask(!0, !0, !0, !0),
                        t.clearColor(0, 0, 0, 0),
                        t.depthMask(!0),
                        t.depthFunc(t.LESS),
                        u.setReversed(!1),
                        t.clearDepth(1),
                        t.stencilMask(4294967295),
                        t.stencilFunc(t.ALWAYS, 0, 4294967295),
                        t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                        t.clearStencil(0),
                        t.cullFace(t.BACK),
                        t.frontFace(t.CCW),
                        t.polygonOffset(0, 0),
                        t.activeTexture(t.TEXTURE0),
                        t.bindFramebuffer(t.FRAMEBUFFER, null),
                        t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                        t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                        t.useProgram(null),
                        t.lineWidth(1),
                        t.scissor(0, 0, t.canvas.width, t.canvas.height),
                        t.viewport(0, 0, t.canvas.width, t.canvas.height),
                        g = {},
                        $ = null,
                        ne = {},
                        v = {},
                        y = new WeakMap,
                        S = [],
                        E = null,
                        w = !1,
                        A = null,
                        T = null,
                        R = null,
                        N = null,
                        D = null,
                        U = null,
                        z = null,
                        I = new ut(0,0,0),
                        V = 0,
                        B = !1,
                        P = null,
                        G = null,
                        K = null,
                        ee = null,
                        te = null,
                        pe.set(0, 0, t.canvas.width, t.canvas.height),
                        Ae.set(0, 0, t.canvas.width, t.canvas.height),
                        o.reset(),
                        u.reset(),
                        f.reset()
                    }
                    return {
                        buffers: {
                            color: o,
                            depth: u,
                            stencil: f
                        },
                        enable: we,
                        disable: Te,
                        bindFramebuffer: Je,
                        drawBuffers: Ze,
                        useProgram: Ct,
                        setBlending: ve,
                        setMaterial: Ce,
                        setFlipSided: qe,
                        setCullFace: Q,
                        setLineWidth: Ke,
                        setPolygonOffset: Ve,
                        setScissorTest: ft,
                        activeTexture: ke,
                        bindTexture: Nt,
                        unbindTexture: Z,
                        compressedTexImage2D: H,
                        compressedTexImage3D: he,
                        texImage2D: Dt,
                        texImage3D: je,
                        updateUBOMapping: ot,
                        uniformBlockBinding: tt,
                        texStorage2D: et,
                        texStorage3D: xt,
                        texSubImage2D: Le,
                        texSubImage3D: He,
                        compressedTexSubImage2D: Oe,
                        compressedTexSubImage3D: pt,
                        scissor: Xe,
                        viewport: nt,
                        reset: Gt
                    }
                }
                function GI(t, e, n, i, a, o, u) {
                    const f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
                      , d = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
                      , p = new Ge
                      , g = new WeakMap;
                    let v;
                    const y = new WeakMap;
                    let S = !1;
                    try {
                        S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
                    } catch {}
                    function E(Z, H) {
                        return S ? new OffscreenCanvas(Z,H) : _g("canvas")
                    }
                    function w(Z, H, he) {
                        let Le = 1;
                        const He = Nt(Z);
                        if ((He.width > he || He.height > he) && (Le = he / Math.max(He.width, He.height)),
                        Le < 1)
                            if (typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Z instanceof ImageBitmap || typeof VideoFrame < "u" && Z instanceof VideoFrame) {
                                const Oe = Math.floor(Le * He.width)
                                  , pt = Math.floor(Le * He.height);
                                v === void 0 && (v = E(Oe, pt));
                                const et = H ? E(Oe, pt) : v;
                                return et.width = Oe,
                                et.height = pt,
                                et.getContext("2d").drawImage(Z, 0, 0, Oe, pt),
                                at("WebGLRenderer: Texture has been resized from (" + He.width + "x" + He.height + ") to (" + Oe + "x" + pt + ")."),
                                et
                            } else
                                return "data"in Z && at("WebGLRenderer: Image in DataTexture is too big (" + He.width + "x" + He.height + ")."),
                                Z;
                        return Z
                    }
                    function A(Z) {
                        return Z.generateMipmaps
                    }
                    function T(Z) {
                        t.generateMipmap(Z)
                    }
                    function R(Z) {
                        return Z.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : Z.isWebGL3DRenderTarget ? t.TEXTURE_3D : Z.isWebGLArrayRenderTarget || Z.isCompressedArrayTexture ? t.TEXTURE_2D_ARRAY : t.TEXTURE_2D
                    }
                    function N(Z, H, he, Le, He=!1) {
                        if (Z !== null) {
                            if (t[Z] !== void 0)
                                return t[Z];
                            at("WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Z + "'")
                        }
                        let Oe = H;
                        if (H === t.RED && (he === t.FLOAT && (Oe = t.R32F),
                        he === t.HALF_FLOAT && (Oe = t.R16F),
                        he === t.UNSIGNED_BYTE && (Oe = t.R8)),
                        H === t.RED_INTEGER && (he === t.UNSIGNED_BYTE && (Oe = t.R8UI),
                        he === t.UNSIGNED_SHORT && (Oe = t.R16UI),
                        he === t.UNSIGNED_INT && (Oe = t.R32UI),
                        he === t.BYTE && (Oe = t.R8I),
                        he === t.SHORT && (Oe = t.R16I),
                        he === t.INT && (Oe = t.R32I)),
                        H === t.RG && (he === t.FLOAT && (Oe = t.RG32F),
                        he === t.HALF_FLOAT && (Oe = t.RG16F),
                        he === t.UNSIGNED_BYTE && (Oe = t.RG8)),
                        H === t.RG_INTEGER && (he === t.UNSIGNED_BYTE && (Oe = t.RG8UI),
                        he === t.UNSIGNED_SHORT && (Oe = t.RG16UI),
                        he === t.UNSIGNED_INT && (Oe = t.RG32UI),
                        he === t.BYTE && (Oe = t.RG8I),
                        he === t.SHORT && (Oe = t.RG16I),
                        he === t.INT && (Oe = t.RG32I)),
                        H === t.RGB_INTEGER && (he === t.UNSIGNED_BYTE && (Oe = t.RGB8UI),
                        he === t.UNSIGNED_SHORT && (Oe = t.RGB16UI),
                        he === t.UNSIGNED_INT && (Oe = t.RGB32UI),
                        he === t.BYTE && (Oe = t.RGB8I),
                        he === t.SHORT && (Oe = t.RGB16I),
                        he === t.INT && (Oe = t.RGB32I)),
                        H === t.RGBA_INTEGER && (he === t.UNSIGNED_BYTE && (Oe = t.RGBA8UI),
                        he === t.UNSIGNED_SHORT && (Oe = t.RGBA16UI),
                        he === t.UNSIGNED_INT && (Oe = t.RGBA32UI),
                        he === t.BYTE && (Oe = t.RGBA8I),
                        he === t.SHORT && (Oe = t.RGBA16I),
                        he === t.INT && (Oe = t.RGBA32I)),
                        H === t.RGB && (he === t.UNSIGNED_INT_5_9_9_9_REV && (Oe = t.RGB9_E5),
                        he === t.UNSIGNED_INT_10F_11F_11F_REV && (Oe = t.R11F_G11F_B10F)),
                        H === t.RGBA) {
                            const pt = He ? gg : xn.getTransfer(Le);
                            he === t.FLOAT && (Oe = t.RGBA32F),
                            he === t.HALF_FLOAT && (Oe = t.RGBA16F),
                            he === t.UNSIGNED_BYTE && (Oe = pt === Vn ? t.SRGB8_ALPHA8 : t.RGBA8),
                            he === t.UNSIGNED_SHORT_4_4_4_4 && (Oe = t.RGBA4),
                            he === t.UNSIGNED_SHORT_5_5_5_1 && (Oe = t.RGB5_A1)
                        }
                        return (Oe === t.R16F || Oe === t.R32F || Oe === t.RG16F || Oe === t.RG32F || Oe === t.RGBA16F || Oe === t.RGBA32F) && e.get("EXT_color_buffer_float"),
                        Oe
                    }
                    function D(Z, H) {
                        let he;
                        return Z ? H === null || H === Ir || H === Ad ? he = t.DEPTH24_STENCIL8 : H === pa ? he = t.DEPTH32F_STENCIL8 : H === Td && (he = t.DEPTH24_STENCIL8,
                        at("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : H === null || H === Ir || H === Ad ? he = t.DEPTH_COMPONENT24 : H === pa ? he = t.DEPTH_COMPONENT32F : H === Td && (he = t.DEPTH_COMPONENT16),
                        he
                    }
                    function U(Z, H) {
                        return A(Z) === !0 || Z.isFramebufferTexture && Z.minFilter !== Vi && Z.minFilter !== fi ? Math.log2(Math.max(H.width, H.height)) + 1 : Z.mipmaps !== void 0 && Z.mipmaps.length > 0 ? Z.mipmaps.length : Z.isCompressedTexture && Array.isArray(Z.image) ? H.mipmaps.length : 1
                    }
                    function z(Z) {
                        const H = Z.target;
                        H.removeEventListener("dispose", z),
                        V(H),
                        H.isVideoTexture && g.delete(H)
                    }
                    function I(Z) {
                        const H = Z.target;
                        H.removeEventListener("dispose", I),
                        P(H)
                    }
                    function V(Z) {
                        const H = i.get(Z);
                        if (H.__webglInit === void 0)
                            return;
                        const he = Z.source
                          , Le = y.get(he);
                        if (Le) {
                            const He = Le[H.__cacheKey];
                            He.usedTimes--,
                            He.usedTimes === 0 && B(Z),
                            Object.keys(Le).length === 0 && y.delete(he)
                        }
                        i.remove(Z)
                    }
                    function B(Z) {
                        const H = i.get(Z);
                        t.deleteTexture(H.__webglTexture);
                        const he = Z.source
                          , Le = y.get(he);
                        delete Le[H.__cacheKey],
                        u.memory.textures--
                    }
                    function P(Z) {
                        const H = i.get(Z);
                        if (Z.depthTexture && (Z.depthTexture.dispose(),
                        i.remove(Z.depthTexture)),
                        Z.isWebGLCubeRenderTarget)
                            for (let Le = 0; Le < 6; Le++) {
                                if (Array.isArray(H.__webglFramebuffer[Le]))
                                    for (let He = 0; He < H.__webglFramebuffer[Le].length; He++)
                                        t.deleteFramebuffer(H.__webglFramebuffer[Le][He]);
                                else
                                    t.deleteFramebuffer(H.__webglFramebuffer[Le]);
                                H.__webglDepthbuffer && t.deleteRenderbuffer(H.__webglDepthbuffer[Le])
                            }
                        else {
                            if (Array.isArray(H.__webglFramebuffer))
                                for (let Le = 0; Le < H.__webglFramebuffer.length; Le++)
                                    t.deleteFramebuffer(H.__webglFramebuffer[Le]);
                            else
                                t.deleteFramebuffer(H.__webglFramebuffer);
                            if (H.__webglDepthbuffer && t.deleteRenderbuffer(H.__webglDepthbuffer),
                            H.__webglMultisampledFramebuffer && t.deleteFramebuffer(H.__webglMultisampledFramebuffer),
                            H.__webglColorRenderbuffer)
                                for (let Le = 0; Le < H.__webglColorRenderbuffer.length; Le++)
                                    H.__webglColorRenderbuffer[Le] && t.deleteRenderbuffer(H.__webglColorRenderbuffer[Le]);
                            H.__webglDepthRenderbuffer && t.deleteRenderbuffer(H.__webglDepthRenderbuffer)
                        }
                        const he = Z.textures;
                        for (let Le = 0, He = he.length; Le < He; Le++) {
                            const Oe = i.get(he[Le]);
                            Oe.__webglTexture && (t.deleteTexture(Oe.__webglTexture),
                            u.memory.textures--),
                            i.remove(he[Le])
                        }
                        i.remove(Z)
                    }
                    let G = 0;
                    function K() {
                        G = 0
                    }
                    function ee() {
                        const Z = G;
                        return Z >= a.maxTextures && at("WebGLTextures: Trying to use " + Z + " texture units while this GPU supports only " + a.maxTextures),
                        G += 1,
                        Z
                    }
                    function te(Z) {
                        const H = [];
                        return H.push(Z.wrapS),
                        H.push(Z.wrapT),
                        H.push(Z.wrapR || 0),
                        H.push(Z.magFilter),
                        H.push(Z.minFilter),
                        H.push(Z.anisotropy),
                        H.push(Z.internalFormat),
                        H.push(Z.format),
                        H.push(Z.type),
                        H.push(Z.generateMipmaps),
                        H.push(Z.premultiplyAlpha),
                        H.push(Z.flipY),
                        H.push(Z.unpackAlignment),
                        H.push(Z.colorSpace),
                        H.join()
                    }
                    function oe(Z, H) {
                        const he = i.get(Z);
                        if (Z.isVideoTexture && ft(Z),
                        Z.isRenderTargetTexture === !1 && Z.isExternalTexture !== !0 && Z.version > 0 && he.__version !== Z.version) {
                            const Le = Z.image;
                            if (Le === null)
                                at("WebGLRenderer: Texture marked for update but no image data found.");
                            else if (Le.complete === !1)
                                at("WebGLRenderer: Texture marked for update but image is incomplete");
                            else {
                                Me(he, Z, H);
                                return
                            }
                        } else
                            Z.isExternalTexture && (he.__webglTexture = Z.sourceTexture ? Z.sourceTexture : null);
                        n.bindTexture(t.TEXTURE_2D, he.__webglTexture, t.TEXTURE0 + H)
                    }
                    function q(Z, H) {
                        const he = i.get(Z);
                        if (Z.isRenderTargetTexture === !1 && Z.version > 0 && he.__version !== Z.version) {
                            Me(he, Z, H);
                            return
                        } else
                            Z.isExternalTexture && (he.__webglTexture = Z.sourceTexture ? Z.sourceTexture : null);
                        n.bindTexture(t.TEXTURE_2D_ARRAY, he.__webglTexture, t.TEXTURE0 + H)
                    }
                    function F(Z, H) {
                        const he = i.get(Z);
                        if (Z.isRenderTargetTexture === !1 && Z.version > 0 && he.__version !== Z.version) {
                            Me(he, Z, H);
                            return
                        }
                        n.bindTexture(t.TEXTURE_3D, he.__webglTexture, t.TEXTURE0 + H)
                    }
                    function X(Z, H) {
                        const he = i.get(Z);
                        if (Z.isCubeDepthTexture !== !0 && Z.version > 0 && he.__version !== Z.version) {
                            we(he, Z, H);
                            return
                        }
                        n.bindTexture(t.TEXTURE_CUBE_MAP, he.__webglTexture, t.TEXTURE0 + H)
                    }
                    const $ = {
                        [rg]: t.REPEAT,
                        [Ia]: t.CLAMP_TO_EDGE,
                        [og]: t.MIRRORED_REPEAT
                    }
                      , ne = {
                        [Vi]: t.NEAREST,
                        [Mx]: t.NEAREST_MIPMAP_NEAREST,
                        [bd]: t.NEAREST_MIPMAP_LINEAR,
                        [fi]: t.LINEAR,
                        [lg]: t.LINEAR_MIPMAP_NEAREST,
                        [rl]: t.LINEAR_MIPMAP_LINEAR
                    }
                      , ce = {
                        [V1]: t.NEVER,
                        [q1]: t.ALWAYS,
                        [F1]: t.LESS,
                        [I0]: t.LEQUAL,
                        [H1]: t.EQUAL,
                        [z0]: t.GEQUAL,
                        [G1]: t.GREATER,
                        [k1]: t.NOTEQUAL
                    };
                    function k(Z, H) {
                        if (H.type === pa && e.has("OES_texture_float_linear") === !1 && (H.magFilter === fi || H.magFilter === lg || H.magFilter === bd || H.magFilter === rl || H.minFilter === fi || H.minFilter === lg || H.minFilter === bd || H.minFilter === rl) && at("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                        t.texParameteri(Z, t.TEXTURE_WRAP_S, $[H.wrapS]),
                        t.texParameteri(Z, t.TEXTURE_WRAP_T, $[H.wrapT]),
                        (Z === t.TEXTURE_3D || Z === t.TEXTURE_2D_ARRAY) && t.texParameteri(Z, t.TEXTURE_WRAP_R, $[H.wrapR]),
                        t.texParameteri(Z, t.TEXTURE_MAG_FILTER, ne[H.magFilter]),
                        t.texParameteri(Z, t.TEXTURE_MIN_FILTER, ne[H.minFilter]),
                        H.compareFunction && (t.texParameteri(Z, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
                        t.texParameteri(Z, t.TEXTURE_COMPARE_FUNC, ce[H.compareFunction])),
                        e.has("EXT_texture_filter_anisotropic") === !0) {
                            if (H.magFilter === Vi || H.minFilter !== bd && H.minFilter !== rl || H.type === pa && e.has("OES_texture_float_linear") === !1)
                                return;
                            if (H.anisotropy > 1 || i.get(H).__currentAnisotropy) {
                                const he = e.get("EXT_texture_filter_anisotropic");
                                t.texParameterf(Z, he.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(H.anisotropy, a.getMaxAnisotropy())),
                                i.get(H).__currentAnisotropy = H.anisotropy
                            }
                        }
                    }
                    function pe(Z, H) {
                        let he = !1;
                        Z.__webglInit === void 0 && (Z.__webglInit = !0,
                        H.addEventListener("dispose", z));
                        const Le = H.source;
                        let He = y.get(Le);
                        He === void 0 && (He = {},
                        y.set(Le, He));
                        const Oe = te(H);
                        if (Oe !== Z.__cacheKey) {
                            He[Oe] === void 0 && (He[Oe] = {
                                texture: t.createTexture(),
                                usedTimes: 0
                            },
                            u.memory.textures++,
                            he = !0),
                            He[Oe].usedTimes++;
                            const pt = He[Z.__cacheKey];
                            pt !== void 0 && (He[Z.__cacheKey].usedTimes--,
                            pt.usedTimes === 0 && B(H)),
                            Z.__cacheKey = Oe,
                            Z.__webglTexture = He[Oe].texture
                        }
                        return he
                    }
                    function Ae(Z, H, he) {
                        return Math.floor(Math.floor(Z / he) / H)
                    }
                    function ie(Z, H, he, Le) {
                        const Oe = Z.updateRanges;
                        if (Oe.length === 0)
                            n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, H.width, H.height, he, Le, H.data);
                        else {
                            Oe.sort( (je, Xe) => je.start - Xe.start);
                            let pt = 0;
                            for (let je = 1; je < Oe.length; je++) {
                                const Xe = Oe[pt]
                                  , nt = Oe[je]
                                  , ot = Xe.start + Xe.count
                                  , tt = Ae(nt.start, H.width, 4)
                                  , Gt = Ae(Xe.start, H.width, 4);
                                nt.start <= ot + 1 && tt === Gt && Ae(nt.start + nt.count - 1, H.width, 4) === tt ? Xe.count = Math.max(Xe.count, nt.start + nt.count - Xe.start) : (++pt,
                                Oe[pt] = nt)
                            }
                            Oe.length = pt + 1;
                            const et = t.getParameter(t.UNPACK_ROW_LENGTH)
                              , xt = t.getParameter(t.UNPACK_SKIP_PIXELS)
                              , Dt = t.getParameter(t.UNPACK_SKIP_ROWS);
                            t.pixelStorei(t.UNPACK_ROW_LENGTH, H.width);
                            for (let je = 0, Xe = Oe.length; je < Xe; je++) {
                                const nt = Oe[je]
                                  , ot = Math.floor(nt.start / 4)
                                  , tt = Math.ceil(nt.count / 4)
                                  , Gt = ot % H.width
                                  , le = Math.floor(ot / H.width)
                                  , it = tt
                                  , Qe = 1;
                                t.pixelStorei(t.UNPACK_SKIP_PIXELS, Gt),
                                t.pixelStorei(t.UNPACK_SKIP_ROWS, le),
                                n.texSubImage2D(t.TEXTURE_2D, 0, Gt, le, it, Qe, he, Le, H.data)
                            }
                            Z.clearUpdateRanges(),
                            t.pixelStorei(t.UNPACK_ROW_LENGTH, et),
                            t.pixelStorei(t.UNPACK_SKIP_PIXELS, xt),
                            t.pixelStorei(t.UNPACK_SKIP_ROWS, Dt)
                        }
                    }
                    function Me(Z, H, he) {
                        let Le = t.TEXTURE_2D;
                        (H.isDataArrayTexture || H.isCompressedArrayTexture) && (Le = t.TEXTURE_2D_ARRAY),
                        H.isData3DTexture && (Le = t.TEXTURE_3D);
                        const He = pe(Z, H)
                          , Oe = H.source;
                        n.bindTexture(Le, Z.__webglTexture, t.TEXTURE0 + he);
                        const pt = i.get(Oe);
                        if (Oe.version !== pt.__version || He === !0) {
                            n.activeTexture(t.TEXTURE0 + he);
                            const et = xn.getPrimaries(xn.workingColorSpace)
                              , xt = H.colorSpace === ec ? null : xn.getPrimaries(H.colorSpace)
                              , Dt = H.colorSpace === ec || et === xt ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, H.flipY),
                            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha),
                            t.pixelStorei(t.UNPACK_ALIGNMENT, H.unpackAlignment),
                            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Dt);
                            let je = w(H.image, !1, a.maxTextureSize);
                            je = ke(H, je);
                            const Xe = o.convert(H.format, H.colorSpace)
                              , nt = o.convert(H.type);
                            let ot = N(H.internalFormat, Xe, nt, H.colorSpace, H.isVideoTexture);
                            k(Le, H);
                            let tt;
                            const Gt = H.mipmaps
                              , le = H.isVideoTexture !== !0
                              , it = pt.__version === void 0 || He === !0
                              , Qe = Oe.dataReady
                              , dt = U(H, je);
                            if (H.isDepthTexture)
                                ot = D(H.format === $c, H.type),
                                it && (le ? n.texStorage2D(t.TEXTURE_2D, 1, ot, je.width, je.height) : n.texImage2D(t.TEXTURE_2D, 0, ot, je.width, je.height, 0, Xe, nt, null));
                            else if (H.isDataTexture)
                                if (Gt.length > 0) {
                                    le && it && n.texStorage2D(t.TEXTURE_2D, dt, ot, Gt[0].width, Gt[0].height);
                                    for (let We = 0, De = Gt.length; We < De; We++)
                                        tt = Gt[We],
                                        le ? Qe && n.texSubImage2D(t.TEXTURE_2D, We, 0, 0, tt.width, tt.height, Xe, nt, tt.data) : n.texImage2D(t.TEXTURE_2D, We, ot, tt.width, tt.height, 0, Xe, nt, tt.data);
                                    H.generateMipmaps = !1
                                } else
                                    le ? (it && n.texStorage2D(t.TEXTURE_2D, dt, ot, je.width, je.height),
                                    Qe && ie(H, je, Xe, nt)) : n.texImage2D(t.TEXTURE_2D, 0, ot, je.width, je.height, 0, Xe, nt, je.data);
                            else if (H.isCompressedTexture)
                                if (H.isCompressedArrayTexture) {
                                    le && it && n.texStorage3D(t.TEXTURE_2D_ARRAY, dt, ot, Gt[0].width, Gt[0].height, je.depth);
                                    for (let We = 0, De = Gt.length; We < De; We++)
                                        if (tt = Gt[We],
                                        H.format !== Hs)
                                            if (Xe !== null)
                                                if (le) {
                                                    if (Qe)
                                                        if (H.layerUpdates.size > 0) {
                                                            const mt = tb(tt.width, tt.height, H.format, H.type);
                                                            for (const Tt of H.layerUpdates) {
                                                                const si = tt.data.subarray(Tt * mt / tt.data.BYTES_PER_ELEMENT, (Tt + 1) * mt / tt.data.BYTES_PER_ELEMENT);
                                                                n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, We, 0, 0, Tt, tt.width, tt.height, 1, Xe, si)
                                                            }
                                                            H.clearLayerUpdates()
                                                        } else
                                                            n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, We, 0, 0, 0, tt.width, tt.height, je.depth, Xe, tt.data)
                                                } else
                                                    n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, We, ot, tt.width, tt.height, je.depth, 0, tt.data, 0, 0);
                                            else
                                                at("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                        else
                                            le ? Qe && n.texSubImage3D(t.TEXTURE_2D_ARRAY, We, 0, 0, 0, tt.width, tt.height, je.depth, Xe, nt, tt.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, We, ot, tt.width, tt.height, je.depth, 0, Xe, nt, tt.data)
                                } else {
                                    le && it && n.texStorage2D(t.TEXTURE_2D, dt, ot, Gt[0].width, Gt[0].height);
                                    for (let We = 0, De = Gt.length; We < De; We++)
                                        tt = Gt[We],
                                        H.format !== Hs ? Xe !== null ? le ? Qe && n.compressedTexSubImage2D(t.TEXTURE_2D, We, 0, 0, tt.width, tt.height, Xe, tt.data) : n.compressedTexImage2D(t.TEXTURE_2D, We, ot, tt.width, tt.height, 0, tt.data) : at("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : le ? Qe && n.texSubImage2D(t.TEXTURE_2D, We, 0, 0, tt.width, tt.height, Xe, nt, tt.data) : n.texImage2D(t.TEXTURE_2D, We, ot, tt.width, tt.height, 0, Xe, nt, tt.data)
                                }
                            else if (H.isDataArrayTexture)
                                if (le) {
                                    if (it && n.texStorage3D(t.TEXTURE_2D_ARRAY, dt, ot, je.width, je.height, je.depth),
                                    Qe)
                                        if (H.layerUpdates.size > 0) {
                                            const We = tb(je.width, je.height, H.format, H.type);
                                            for (const De of H.layerUpdates) {
                                                const mt = je.data.subarray(De * We / je.data.BYTES_PER_ELEMENT, (De + 1) * We / je.data.BYTES_PER_ELEMENT);
                                                n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, De, je.width, je.height, 1, Xe, nt, mt)
                                            }
                                            H.clearLayerUpdates()
                                        } else
                                            n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, je.width, je.height, je.depth, Xe, nt, je.data)
                                } else
                                    n.texImage3D(t.TEXTURE_2D_ARRAY, 0, ot, je.width, je.height, je.depth, 0, Xe, nt, je.data);
                            else if (H.isData3DTexture)
                                le ? (it && n.texStorage3D(t.TEXTURE_3D, dt, ot, je.width, je.height, je.depth),
                                Qe && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, je.width, je.height, je.depth, Xe, nt, je.data)) : n.texImage3D(t.TEXTURE_3D, 0, ot, je.width, je.height, je.depth, 0, Xe, nt, je.data);
                            else if (H.isFramebufferTexture) {
                                if (it)
                                    if (le)
                                        n.texStorage2D(t.TEXTURE_2D, dt, ot, je.width, je.height);
                                    else {
                                        let We = je.width
                                          , De = je.height;
                                        for (let mt = 0; mt < dt; mt++)
                                            n.texImage2D(t.TEXTURE_2D, mt, ot, We, De, 0, Xe, nt, null),
                                            We >>= 1,
                                            De >>= 1
                                    }
                            } else if (Gt.length > 0) {
                                if (le && it) {
                                    const We = Nt(Gt[0]);
                                    n.texStorage2D(t.TEXTURE_2D, dt, ot, We.width, We.height)
                                }
                                for (let We = 0, De = Gt.length; We < De; We++)
                                    tt = Gt[We],
                                    le ? Qe && n.texSubImage2D(t.TEXTURE_2D, We, 0, 0, Xe, nt, tt) : n.texImage2D(t.TEXTURE_2D, We, ot, Xe, nt, tt);
                                H.generateMipmaps = !1
                            } else if (le) {
                                if (it) {
                                    const We = Nt(je);
                                    n.texStorage2D(t.TEXTURE_2D, dt, ot, We.width, We.height)
                                }
                                Qe && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, Xe, nt, je)
                            } else
                                n.texImage2D(t.TEXTURE_2D, 0, ot, Xe, nt, je);
                            A(H) && T(Le),
                            pt.__version = Oe.version,
                            H.onUpdate && H.onUpdate(H)
                        }
                        Z.__version = H.version
                    }
                    function we(Z, H, he) {
                        if (H.image.length !== 6)
                            return;
                        const Le = pe(Z, H)
                          , He = H.source;
                        n.bindTexture(t.TEXTURE_CUBE_MAP, Z.__webglTexture, t.TEXTURE0 + he);
                        const Oe = i.get(He);
                        if (He.version !== Oe.__version || Le === !0) {
                            n.activeTexture(t.TEXTURE0 + he);
                            const pt = xn.getPrimaries(xn.workingColorSpace)
                              , et = H.colorSpace === ec ? null : xn.getPrimaries(H.colorSpace)
                              , xt = H.colorSpace === ec || pt === et ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, H.flipY),
                            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha),
                            t.pixelStorei(t.UNPACK_ALIGNMENT, H.unpackAlignment),
                            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, xt);
                            const Dt = H.isCompressedTexture || H.image[0].isCompressedTexture
                              , je = H.image[0] && H.image[0].isDataTexture
                              , Xe = [];
                            for (let De = 0; De < 6; De++)
                                !Dt && !je ? Xe[De] = w(H.image[De], !0, a.maxCubemapSize) : Xe[De] = je ? H.image[De].image : H.image[De],
                                Xe[De] = ke(H, Xe[De]);
                            const nt = Xe[0]
                              , ot = o.convert(H.format, H.colorSpace)
                              , tt = o.convert(H.type)
                              , Gt = N(H.internalFormat, ot, tt, H.colorSpace)
                              , le = H.isVideoTexture !== !0
                              , it = Oe.__version === void 0 || Le === !0
                              , Qe = He.dataReady;
                            let dt = U(H, nt);
                            k(t.TEXTURE_CUBE_MAP, H);
                            let We;
                            if (Dt) {
                                le && it && n.texStorage2D(t.TEXTURE_CUBE_MAP, dt, Gt, nt.width, nt.height);
                                for (let De = 0; De < 6; De++) {
                                    We = Xe[De].mipmaps;
                                    for (let mt = 0; mt < We.length; mt++) {
                                        const Tt = We[mt];
                                        H.format !== Hs ? ot !== null ? le ? Qe && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt, 0, 0, Tt.width, Tt.height, ot, Tt.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt, Gt, Tt.width, Tt.height, 0, Tt.data) : at("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : le ? Qe && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt, 0, 0, Tt.width, Tt.height, ot, tt, Tt.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt, Gt, Tt.width, Tt.height, 0, ot, tt, Tt.data)
                                    }
                                }
                            } else {
                                if (We = H.mipmaps,
                                le && it) {
                                    We.length > 0 && dt++;
                                    const De = Nt(Xe[0]);
                                    n.texStorage2D(t.TEXTURE_CUBE_MAP, dt, Gt, De.width, De.height)
                                }
                                for (let De = 0; De < 6; De++)
                                    if (je) {
                                        le ? Qe && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, 0, 0, Xe[De].width, Xe[De].height, ot, tt, Xe[De].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, Gt, Xe[De].width, Xe[De].height, 0, ot, tt, Xe[De].data);
                                        for (let mt = 0; mt < We.length; mt++) {
                                            const Tt = We[mt].image[De].image;
                                            le ? Qe && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt + 1, 0, 0, Tt.width, Tt.height, ot, tt, Tt.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt + 1, Gt, Tt.width, Tt.height, 0, ot, tt, Tt.data)
                                        }
                                    } else {
                                        le ? Qe && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, 0, 0, ot, tt, Xe[De]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, Gt, ot, tt, Xe[De]);
                                        for (let mt = 0; mt < We.length; mt++) {
                                            const Tt = We[mt];
                                            le ? Qe && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt + 1, 0, 0, ot, tt, Tt.image[De]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + De, mt + 1, Gt, ot, tt, Tt.image[De])
                                        }
                                    }
                            }
                            A(H) && T(t.TEXTURE_CUBE_MAP),
                            Oe.__version = He.version,
                            H.onUpdate && H.onUpdate(H)
                        }
                        Z.__version = H.version
                    }
                    function Te(Z, H, he, Le, He, Oe) {
                        const pt = o.convert(he.format, he.colorSpace)
                          , et = o.convert(he.type)
                          , xt = N(he.internalFormat, pt, et, he.colorSpace)
                          , Dt = i.get(H)
                          , je = i.get(he);
                        if (je.__renderTarget = H,
                        !Dt.__hasExternalTextures) {
                            const Xe = Math.max(1, H.width >> Oe)
                              , nt = Math.max(1, H.height >> Oe);
                            He === t.TEXTURE_3D || He === t.TEXTURE_2D_ARRAY ? n.texImage3D(He, Oe, xt, Xe, nt, H.depth, 0, pt, et, null) : n.texImage2D(He, Oe, xt, Xe, nt, 0, pt, et, null)
                        }
                        n.bindFramebuffer(t.FRAMEBUFFER, Z),
                        Ve(H) ? f.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, Le, He, je.__webglTexture, 0, Ke(H)) : (He === t.TEXTURE_2D || He >= t.TEXTURE_CUBE_MAP_POSITIVE_X && He <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, Le, He, je.__webglTexture, Oe),
                        n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                    function Je(Z, H, he) {
                        if (t.bindRenderbuffer(t.RENDERBUFFER, Z),
                        H.depthBuffer) {
                            const Le = H.depthTexture
                              , He = Le && Le.isDepthTexture ? Le.type : null
                              , Oe = D(H.stencilBuffer, He)
                              , pt = H.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                            Ve(H) ? f.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Ke(H), Oe, H.width, H.height) : he ? t.renderbufferStorageMultisample(t.RENDERBUFFER, Ke(H), Oe, H.width, H.height) : t.renderbufferStorage(t.RENDERBUFFER, Oe, H.width, H.height),
                            t.framebufferRenderbuffer(t.FRAMEBUFFER, pt, t.RENDERBUFFER, Z)
                        } else {
                            const Le = H.textures;
                            for (let He = 0; He < Le.length; He++) {
                                const Oe = Le[He]
                                  , pt = o.convert(Oe.format, Oe.colorSpace)
                                  , et = o.convert(Oe.type)
                                  , xt = N(Oe.internalFormat, pt, et, Oe.colorSpace);
                                Ve(H) ? f.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Ke(H), xt, H.width, H.height) : he ? t.renderbufferStorageMultisample(t.RENDERBUFFER, Ke(H), xt, H.width, H.height) : t.renderbufferStorage(t.RENDERBUFFER, xt, H.width, H.height)
                            }
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null)
                    }
                    function Ze(Z, H, he) {
                        const Le = H.isWebGLCubeRenderTarget === !0;
                        if (n.bindFramebuffer(t.FRAMEBUFFER, Z),
                        !(H.depthTexture && H.depthTexture.isDepthTexture))
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        const He = i.get(H.depthTexture);
                        if (He.__renderTarget = H,
                        (!He.__webglTexture || H.depthTexture.image.width !== H.width || H.depthTexture.image.height !== H.height) && (H.depthTexture.image.width = H.width,
                        H.depthTexture.image.height = H.height,
                        H.depthTexture.needsUpdate = !0),
                        Le) {
                            if (He.__webglInit === void 0 && (He.__webglInit = !0,
                            H.depthTexture.addEventListener("dispose", z)),
                            He.__webglTexture === void 0) {
                                He.__webglTexture = t.createTexture(),
                                n.bindTexture(t.TEXTURE_CUBE_MAP, He.__webglTexture),
                                k(t.TEXTURE_CUBE_MAP, H.depthTexture);
                                const Dt = o.convert(H.depthTexture.format)
                                  , je = o.convert(H.depthTexture.type);
                                let Xe;
                                H.depthTexture.format === ll ? Xe = t.DEPTH_COMPONENT24 : H.depthTexture.format === $c && (Xe = t.DEPTH24_STENCIL8);
                                for (let nt = 0; nt < 6; nt++)
                                    t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + nt, 0, Xe, H.width, H.height, 0, Dt, je, null)
                            }
                        } else
                            oe(H.depthTexture, 0);
                        const Oe = He.__webglTexture
                          , pt = Ke(H)
                          , et = Le ? t.TEXTURE_CUBE_MAP_POSITIVE_X + he : t.TEXTURE_2D
                          , xt = H.depthTexture.format === $c ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                        if (H.depthTexture.format === ll)
                            Ve(H) ? f.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, xt, et, Oe, 0, pt) : t.framebufferTexture2D(t.FRAMEBUFFER, xt, et, Oe, 0);
                        else if (H.depthTexture.format === $c)
                            Ve(H) ? f.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, xt, et, Oe, 0, pt) : t.framebufferTexture2D(t.FRAMEBUFFER, xt, et, Oe, 0);
                        else
                            throw new Error("Unknown depthTexture format")
                    }
                    function Ct(Z) {
                        const H = i.get(Z)
                          , he = Z.isWebGLCubeRenderTarget === !0;
                        if (H.__boundDepthTexture !== Z.depthTexture) {
                            const Le = Z.depthTexture;
                            if (H.__depthDisposeCallback && H.__depthDisposeCallback(),
                            Le) {
                                const He = () => {
                                    delete H.__boundDepthTexture,
                                    delete H.__depthDisposeCallback,
                                    Le.removeEventListener("dispose", He)
                                }
                                ;
                                Le.addEventListener("dispose", He),
                                H.__depthDisposeCallback = He
                            }
                            H.__boundDepthTexture = Le
                        }
                        if (Z.depthTexture && !H.__autoAllocateDepthBuffer)
                            if (he)
                                for (let Le = 0; Le < 6; Le++)
                                    Ze(H.__webglFramebuffer[Le], Z, Le);
                            else {
                                const Le = Z.texture.mipmaps;
                                Le && Le.length > 0 ? Ze(H.__webglFramebuffer[0], Z, 0) : Ze(H.__webglFramebuffer, Z, 0)
                            }
                        else if (he) {
                            H.__webglDepthbuffer = [];
                            for (let Le = 0; Le < 6; Le++)
                                if (n.bindFramebuffer(t.FRAMEBUFFER, H.__webglFramebuffer[Le]),
                                H.__webglDepthbuffer[Le] === void 0)
                                    H.__webglDepthbuffer[Le] = t.createRenderbuffer(),
                                    Je(H.__webglDepthbuffer[Le], Z, !1);
                                else {
                                    const He = Z.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                                      , Oe = H.__webglDepthbuffer[Le];
                                    t.bindRenderbuffer(t.RENDERBUFFER, Oe),
                                    t.framebufferRenderbuffer(t.FRAMEBUFFER, He, t.RENDERBUFFER, Oe)
                                }
                        } else {
                            const Le = Z.texture.mipmaps;
                            if (Le && Le.length > 0 ? n.bindFramebuffer(t.FRAMEBUFFER, H.__webglFramebuffer[0]) : n.bindFramebuffer(t.FRAMEBUFFER, H.__webglFramebuffer),
                            H.__webglDepthbuffer === void 0)
                                H.__webglDepthbuffer = t.createRenderbuffer(),
                                Je(H.__webglDepthbuffer, Z, !1);
                            else {
                                const He = Z.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                                  , Oe = H.__webglDepthbuffer;
                                t.bindRenderbuffer(t.RENDERBUFFER, Oe),
                                t.framebufferRenderbuffer(t.FRAMEBUFFER, He, t.RENDERBUFFER, Oe)
                            }
                        }
                        n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                    function bt(Z, H, he) {
                        const Le = i.get(Z);
                        H !== void 0 && Te(Le.__webglFramebuffer, Z, Z.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0),
                        he !== void 0 && Ct(Z)
                    }
                    function Ue(Z) {
                        const H = Z.texture
                          , he = i.get(Z)
                          , Le = i.get(H);
                        Z.addEventListener("dispose", I);
                        const He = Z.textures
                          , Oe = Z.isWebGLCubeRenderTarget === !0
                          , pt = He.length > 1;
                        if (pt || (Le.__webglTexture === void 0 && (Le.__webglTexture = t.createTexture()),
                        Le.__version = H.version,
                        u.memory.textures++),
                        Oe) {
                            he.__webglFramebuffer = [];
                            for (let et = 0; et < 6; et++)
                                if (H.mipmaps && H.mipmaps.length > 0) {
                                    he.__webglFramebuffer[et] = [];
                                    for (let xt = 0; xt < H.mipmaps.length; xt++)
                                        he.__webglFramebuffer[et][xt] = t.createFramebuffer()
                                } else
                                    he.__webglFramebuffer[et] = t.createFramebuffer()
                        } else {
                            if (H.mipmaps && H.mipmaps.length > 0) {
                                he.__webglFramebuffer = [];
                                for (let et = 0; et < H.mipmaps.length; et++)
                                    he.__webglFramebuffer[et] = t.createFramebuffer()
                            } else
                                he.__webglFramebuffer = t.createFramebuffer();
                            if (pt)
                                for (let et = 0, xt = He.length; et < xt; et++) {
                                    const Dt = i.get(He[et]);
                                    Dt.__webglTexture === void 0 && (Dt.__webglTexture = t.createTexture(),
                                    u.memory.textures++)
                                }
                            if (Z.samples > 0 && Ve(Z) === !1) {
                                he.__webglMultisampledFramebuffer = t.createFramebuffer(),
                                he.__webglColorRenderbuffer = [],
                                n.bindFramebuffer(t.FRAMEBUFFER, he.__webglMultisampledFramebuffer);
                                for (let et = 0; et < He.length; et++) {
                                    const xt = He[et];
                                    he.__webglColorRenderbuffer[et] = t.createRenderbuffer(),
                                    t.bindRenderbuffer(t.RENDERBUFFER, he.__webglColorRenderbuffer[et]);
                                    const Dt = o.convert(xt.format, xt.colorSpace)
                                      , je = o.convert(xt.type)
                                      , Xe = N(xt.internalFormat, Dt, je, xt.colorSpace, Z.isXRRenderTarget === !0)
                                      , nt = Ke(Z);
                                    t.renderbufferStorageMultisample(t.RENDERBUFFER, nt, Xe, Z.width, Z.height),
                                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + et, t.RENDERBUFFER, he.__webglColorRenderbuffer[et])
                                }
                                t.bindRenderbuffer(t.RENDERBUFFER, null),
                                Z.depthBuffer && (he.__webglDepthRenderbuffer = t.createRenderbuffer(),
                                Je(he.__webglDepthRenderbuffer, Z, !0)),
                                n.bindFramebuffer(t.FRAMEBUFFER, null)
                            }
                        }
                        if (Oe) {
                            n.bindTexture(t.TEXTURE_CUBE_MAP, Le.__webglTexture),
                            k(t.TEXTURE_CUBE_MAP, H);
                            for (let et = 0; et < 6; et++)
                                if (H.mipmaps && H.mipmaps.length > 0)
                                    for (let xt = 0; xt < H.mipmaps.length; xt++)
                                        Te(he.__webglFramebuffer[et][xt], Z, H, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + et, xt);
                                else
                                    Te(he.__webglFramebuffer[et], Z, H, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + et, 0);
                            A(H) && T(t.TEXTURE_CUBE_MAP),
                            n.unbindTexture()
                        } else if (pt) {
                            for (let et = 0, xt = He.length; et < xt; et++) {
                                const Dt = He[et]
                                  , je = i.get(Dt);
                                let Xe = t.TEXTURE_2D;
                                (Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) && (Xe = Z.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
                                n.bindTexture(Xe, je.__webglTexture),
                                k(Xe, Dt),
                                Te(he.__webglFramebuffer, Z, Dt, t.COLOR_ATTACHMENT0 + et, Xe, 0),
                                A(Dt) && T(Xe)
                            }
                            n.unbindTexture()
                        } else {
                            let et = t.TEXTURE_2D;
                            if ((Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) && (et = Z.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
                            n.bindTexture(et, Le.__webglTexture),
                            k(et, H),
                            H.mipmaps && H.mipmaps.length > 0)
                                for (let xt = 0; xt < H.mipmaps.length; xt++)
                                    Te(he.__webglFramebuffer[xt], Z, H, t.COLOR_ATTACHMENT0, et, xt);
                            else
                                Te(he.__webglFramebuffer, Z, H, t.COLOR_ATTACHMENT0, et, 0);
                            A(H) && T(et),
                            n.unbindTexture()
                        }
                        Z.depthBuffer && Ct(Z)
                    }
                    function ve(Z) {
                        const H = Z.textures;
                        for (let he = 0, Le = H.length; he < Le; he++) {
                            const He = H[he];
                            if (A(He)) {
                                const Oe = R(Z)
                                  , pt = i.get(He).__webglTexture;
                                n.bindTexture(Oe, pt),
                                T(Oe),
                                n.unbindTexture()
                            }
                        }
                    }
                    const Ce = []
                      , qe = [];
                    function Q(Z) {
                        if (Z.samples > 0) {
                            if (Ve(Z) === !1) {
                                const H = Z.textures
                                  , he = Z.width
                                  , Le = Z.height;
                                let He = t.COLOR_BUFFER_BIT;
                                const Oe = Z.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                                  , pt = i.get(Z)
                                  , et = H.length > 1;
                                if (et)
                                    for (let Dt = 0; Dt < H.length; Dt++)
                                        n.bindFramebuffer(t.FRAMEBUFFER, pt.__webglMultisampledFramebuffer),
                                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Dt, t.RENDERBUFFER, null),
                                        n.bindFramebuffer(t.FRAMEBUFFER, pt.__webglFramebuffer),
                                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Dt, t.TEXTURE_2D, null, 0);
                                n.bindFramebuffer(t.READ_FRAMEBUFFER, pt.__webglMultisampledFramebuffer);
                                const xt = Z.texture.mipmaps;
                                xt && xt.length > 0 ? n.bindFramebuffer(t.DRAW_FRAMEBUFFER, pt.__webglFramebuffer[0]) : n.bindFramebuffer(t.DRAW_FRAMEBUFFER, pt.__webglFramebuffer);
                                for (let Dt = 0; Dt < H.length; Dt++) {
                                    if (Z.resolveDepthBuffer && (Z.depthBuffer && (He |= t.DEPTH_BUFFER_BIT),
                                    Z.stencilBuffer && Z.resolveStencilBuffer && (He |= t.STENCIL_BUFFER_BIT)),
                                    et) {
                                        t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, pt.__webglColorRenderbuffer[Dt]);
                                        const je = i.get(H[Dt]).__webglTexture;
                                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, je, 0)
                                    }
                                    t.blitFramebuffer(0, 0, he, Le, 0, 0, he, Le, He, t.NEAREST),
                                    d === !0 && (Ce.length = 0,
                                    qe.length = 0,
                                    Ce.push(t.COLOR_ATTACHMENT0 + Dt),
                                    Z.depthBuffer && Z.resolveDepthBuffer === !1 && (Ce.push(Oe),
                                    qe.push(Oe),
                                    t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, qe)),
                                    t.invalidateFramebuffer(t.READ_FRAMEBUFFER, Ce))
                                }
                                if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                                et)
                                    for (let Dt = 0; Dt < H.length; Dt++) {
                                        n.bindFramebuffer(t.FRAMEBUFFER, pt.__webglMultisampledFramebuffer),
                                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Dt, t.RENDERBUFFER, pt.__webglColorRenderbuffer[Dt]);
                                        const je = i.get(H[Dt]).__webglTexture;
                                        n.bindFramebuffer(t.FRAMEBUFFER, pt.__webglFramebuffer),
                                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Dt, t.TEXTURE_2D, je, 0)
                                    }
                                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, pt.__webglMultisampledFramebuffer)
                            } else if (Z.depthBuffer && Z.resolveDepthBuffer === !1 && d) {
                                const H = Z.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [H])
                            }
                        }
                    }
                    function Ke(Z) {
                        return Math.min(a.maxSamples, Z.samples)
                    }
                    function Ve(Z) {
                        const H = i.get(Z);
                        return Z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && H.__useRenderToTexture !== !1
                    }
                    function ft(Z) {
                        const H = u.render.frame;
                        g.get(Z) !== H && (g.set(Z, H),
                        Z.update())
                    }
                    function ke(Z, H) {
                        const he = Z.colorSpace
                          , Le = Z.format
                          , He = Z.type;
                        return Z.isCompressedTexture === !0 || Z.isVideoTexture === !0 || he !== tu && he !== ec && (xn.getTransfer(he) === Vn ? (Le !== Hs || He !== da) && at("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : Rt("WebGLTextures: Unsupported texture color space:", he)),
                        H
                    }
                    function Nt(Z) {
                        return typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement ? (p.width = Z.naturalWidth || Z.width,
                        p.height = Z.naturalHeight || Z.height) : typeof VideoFrame < "u" && Z instanceof VideoFrame ? (p.width = Z.displayWidth,
                        p.height = Z.displayHeight) : (p.width = Z.width,
                        p.height = Z.height),
                        p
                    }
                    this.allocateTextureUnit = ee,
                    this.resetTextureUnits = K,
                    this.setTexture2D = oe,
                    this.setTexture2DArray = q,
                    this.setTexture3D = F,
                    this.setTextureCube = X,
                    this.rebindTextures = bt,
                    this.setupRenderTarget = Ue,
                    this.updateRenderTargetMipmap = ve,
                    this.updateMultisampleRenderTarget = Q,
                    this.setupDepthRenderbuffer = Ct,
                    this.setupFrameBufferTexture = Te,
                    this.useMultisampledRTT = Ve,
                    this.isReversedDepthBuffer = function() {
                        return n.buffers.depth.getReversed()
                    }
                }
                function qC(t, e) {
                    function n(i, a=ec) {
                        let o;
                        const u = xn.getTransfer(a);
                        if (i === da)
                            return t.UNSIGNED_BYTE;
                        if (i === Z_)
                            return t.UNSIGNED_SHORT_4_4_4_4;
                        if (i === Q_)
                            return t.UNSIGNED_SHORT_5_5_5_1;
                        if (i === Ax)
                            return t.UNSIGNED_INT_5_9_9_9_REV;
                        if (i === Ex)
                            return t.UNSIGNED_INT_10F_11F_11F_REV;
                        if (i === bx)
                            return t.BYTE;
                        if (i === Tx)
                            return t.SHORT;
                        if (i === Td)
                            return t.UNSIGNED_SHORT;
                        if (i === j_)
                            return t.INT;
                        if (i === Ir)
                            return t.UNSIGNED_INT;
                        if (i === pa)
                            return t.FLOAT;
                        if (i === ol)
                            return t.HALF_FLOAT;
                        if (i === Cx)
                            return t.ALPHA;
                        if (i === wx)
                            return t.RGB;
                        if (i === Hs)
                            return t.RGBA;
                        if (i === ll)
                            return t.DEPTH_COMPONENT;
                        if (i === $c)
                            return t.DEPTH_STENCIL;
                        if (i === K_)
                            return t.RED;
                        if (i === cg)
                            return t.RED_INTEGER;
                        if (i === xh)
                            return t.RG;
                        if (i === J_)
                            return t.RG_INTEGER;
                        if (i === $_)
                            return t.RGBA_INTEGER;
                        if (i === ug || i === hg || i === fg || i === dg)
                            if (u === Vn)
                                if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                                o !== null) {
                                    if (i === ug)
                                        return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (i === hg)
                                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (i === fg)
                                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (i === dg)
                                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                } else
                                    return null;
                            else if (o = e.get("WEBGL_compressed_texture_s3tc"),
                            o !== null) {
                                if (i === ug)
                                    return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (i === hg)
                                    return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (i === fg)
                                    return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (i === dg)
                                    return o.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } else
                                return null;
                        if (i === e0 || i === t0 || i === n0 || i === i0)
                            if (o = e.get("WEBGL_compressed_texture_pvrtc"),
                            o !== null) {
                                if (i === e0)
                                    return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (i === t0)
                                    return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (i === n0)
                                    return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (i === i0)
                                    return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            } else
                                return null;
                        if (i === s0 || i === a0 || i === r0 || i === o0 || i === l0 || i === c0 || i === u0)
                            if (o = e.get("WEBGL_compressed_texture_etc"),
                            o !== null) {
                                if (i === s0 || i === a0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
                                if (i === r0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
                                if (i === o0)
                                    return o.COMPRESSED_R11_EAC;
                                if (i === l0)
                                    return o.COMPRESSED_SIGNED_R11_EAC;
                                if (i === c0)
                                    return o.COMPRESSED_RG11_EAC;
                                if (i === u0)
                                    return o.COMPRESSED_SIGNED_RG11_EAC
                            } else
                                return null;
                        if (i === h0 || i === f0 || i === d0 || i === p0 || i === m0 || i === g0 || i === v0 || i === _0 || i === y0 || i === S0 || i === x0 || i === M0 || i === b0 || i === T0)
                            if (o = e.get("WEBGL_compressed_texture_astc"),
                            o !== null) {
                                if (i === h0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (i === f0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (i === d0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (i === p0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (i === m0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (i === g0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (i === v0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (i === _0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (i === y0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (i === S0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (i === x0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (i === M0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (i === b0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (i === T0)
                                    return u === Vn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR
                            } else
                                return null;
                        if (i === A0 || i === E0 || i === C0)
                            if (o = e.get("EXT_texture_compression_bptc"),
                            o !== null) {
                                if (i === A0)
                                    return u === Vn ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (i === E0)
                                    return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (i === C0)
                                    return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            } else
                                return null;
                        if (i === w0 || i === R0 || i === N0 || i === D0)
                            if (o = e.get("EXT_texture_compression_rgtc"),
                            o !== null) {
                                if (i === w0)
                                    return o.COMPRESSED_RED_RGTC1_EXT;
                                if (i === R0)
                                    return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (i === N0)
                                    return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (i === D0)
                                    return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            } else
                                return null;
                        return i === Ad ? t.UNSIGNED_INT_24_8 : t[i] !== void 0 ? t[i] : null
                    }
                    return {
                        convert: n
                    }
                }
                const kI = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
                  , qI = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
                var XI = class {
                    constructor() {
                        this.texture = null,
                        this.mesh = null,
                        this.depthNear = 0,
                        this.depthFar = 0
                    }
                    init(t, e) {
                        if (this.texture === null) {
                            const n = new mM(t.texture);
                            (t.depthNear !== e.depthNear || t.depthFar !== e.depthFar) && (this.depthNear = t.depthNear,
                            this.depthFar = t.depthFar),
                            this.texture = n
                        }
                    }
                    getMesh(t) {
                        if (this.texture !== null && this.mesh === null) {
                            const e = t.cameras[0].viewport
                              , n = new Br({
                                vertexShader: kI,
                                fragmentShader: qI,
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: e.z
                                    },
                                    depthHeight: {
                                        value: e.w
                                    }
                                }
                            });
                            this.mesh = new Ji(new Ry(20,20),n)
                        }
                        return this.mesh
                    }
                    reset() {
                        this.texture = null,
                        this.mesh = null
                    }
                    getDepthTexture() {
                        return this.texture
                    }
                }
                  , WI = class extends cl {
                    constructor(t, e) {
                        super();
                        const n = this;
                        let i = null
                          , a = 1
                          , o = null
                          , u = "local-floor"
                          , f = 1
                          , d = null
                          , p = null
                          , g = null
                          , v = null
                          , y = null
                          , S = null;
                        const E = typeof XRWebGLBinding < "u"
                          , w = new XI
                          , A = {}
                          , T = e.getContextAttributes();
                        let R = null
                          , N = null;
                        const D = []
                          , U = []
                          , z = new Ge;
                        let I = null;
                        const V = new _s;
                        V.viewport = new di;
                        const B = new _s;
                        B.viewport = new di;
                        const P = [V, B]
                          , G = new eC;
                        let K = null
                          , ee = null;
                        this.cameraAutoUpdate = !0,
                        this.enabled = !1,
                        this.isPresenting = !1,
                        this.getController = function(ie) {
                            let Me = D[ie];
                            return Me === void 0 && (Me = new ny,
                            D[ie] = Me),
                            Me.getTargetRaySpace()
                        }
                        ,
                        this.getControllerGrip = function(ie) {
                            let Me = D[ie];
                            return Me === void 0 && (Me = new ny,
                            D[ie] = Me),
                            Me.getGripSpace()
                        }
                        ,
                        this.getHand = function(ie) {
                            let Me = D[ie];
                            return Me === void 0 && (Me = new ny,
                            D[ie] = Me),
                            Me.getHandSpace()
                        }
                        ;
                        function te(ie) {
                            const Me = U.indexOf(ie.inputSource);
                            if (Me === -1)
                                return;
                            const we = D[Me];
                            we !== void 0 && (we.update(ie.inputSource, ie.frame, d || o),
                            we.dispatchEvent({
                                type: ie.type,
                                data: ie.inputSource
                            }))
                        }
                        function oe() {
                            i.removeEventListener("select", te),
                            i.removeEventListener("selectstart", te),
                            i.removeEventListener("selectend", te),
                            i.removeEventListener("squeeze", te),
                            i.removeEventListener("squeezestart", te),
                            i.removeEventListener("squeezeend", te),
                            i.removeEventListener("end", oe),
                            i.removeEventListener("inputsourceschange", q);
                            for (let ie = 0; ie < D.length; ie++) {
                                const Me = U[ie];
                                Me !== null && (U[ie] = null,
                                D[ie].disconnect(Me))
                            }
                            K = null,
                            ee = null,
                            w.reset();
                            for (const ie in A)
                                delete A[ie];
                            t.setRenderTarget(R),
                            y = null,
                            v = null,
                            g = null,
                            i = null,
                            N = null,
                            Ae.stop(),
                            n.isPresenting = !1,
                            t.setPixelRatio(I),
                            t.setSize(z.width, z.height, !1),
                            n.dispatchEvent({
                                type: "sessionend"
                            })
                        }
                        this.setFramebufferScaleFactor = function(ie) {
                            a = ie,
                            n.isPresenting === !0 && at("WebXRManager: Cannot change framebuffer scale while presenting.")
                        }
                        ,
                        this.setReferenceSpaceType = function(ie) {
                            u = ie,
                            n.isPresenting === !0 && at("WebXRManager: Cannot change reference space type while presenting.")
                        }
                        ,
                        this.getReferenceSpace = function() {
                            return d || o
                        }
                        ,
                        this.setReferenceSpace = function(ie) {
                            d = ie
                        }
                        ,
                        this.getBaseLayer = function() {
                            return v !== null ? v : y
                        }
                        ,
                        this.getBinding = function() {
                            return g === null && E && (g = new XRWebGLBinding(i,e)),
                            g
                        }
                        ,
                        this.getFrame = function() {
                            return S
                        }
                        ,
                        this.getSession = function() {
                            return i
                        }
                        ,
                        this.setSession = async function(ie) {
                            if (i = ie,
                            i !== null) {
                                if (R = t.getRenderTarget(),
                                i.addEventListener("select", te),
                                i.addEventListener("selectstart", te),
                                i.addEventListener("selectend", te),
                                i.addEventListener("squeeze", te),
                                i.addEventListener("squeezestart", te),
                                i.addEventListener("squeezeend", te),
                                i.addEventListener("end", oe),
                                i.addEventListener("inputsourceschange", q),
                                T.xrCompatible !== !0 && await e.makeXRCompatible(),
                                I = t.getPixelRatio(),
                                t.getSize(z),
                                E && "createProjectionLayer"in XRWebGLBinding.prototype) {
                                    let Me = null
                                      , we = null
                                      , Te = null;
                                    T.depth && (Te = T.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24,
                                    Me = T.stencil ? $c : ll,
                                    we = T.stencil ? Ad : Ir);
                                    const Je = {
                                        colorFormat: e.RGBA8,
                                        depthFormat: Te,
                                        scaleFactor: a
                                    };
                                    g = this.getBinding(),
                                    v = g.createProjectionLayer(Je),
                                    i.updateRenderState({
                                        layers: [v]
                                    }),
                                    t.setPixelRatio(1),
                                    t.setSize(v.textureWidth, v.textureHeight, !1),
                                    N = new sr(v.textureWidth,v.textureHeight,{
                                        format: Hs,
                                        type: da,
                                        depthTexture: new ep(v.textureWidth,v.textureHeight,we,void 0,void 0,void 0,void 0,void 0,void 0,Me),
                                        stencilBuffer: T.stencil,
                                        colorSpace: t.outputColorSpace,
                                        samples: T.antialias ? 4 : 0,
                                        resolveDepthBuffer: v.ignoreDepthValues === !1,
                                        resolveStencilBuffer: v.ignoreDepthValues === !1
                                    })
                                } else {
                                    const Me = {
                                        antialias: T.antialias,
                                        alpha: !0,
                                        depth: T.depth,
                                        stencil: T.stencil,
                                        framebufferScaleFactor: a
                                    };
                                    y = new XRWebGLLayer(i,e,Me),
                                    i.updateRenderState({
                                        baseLayer: y
                                    }),
                                    t.setPixelRatio(1),
                                    t.setSize(y.framebufferWidth, y.framebufferHeight, !1),
                                    N = new sr(y.framebufferWidth,y.framebufferHeight,{
                                        format: Hs,
                                        type: da,
                                        colorSpace: t.outputColorSpace,
                                        stencilBuffer: T.stencil,
                                        resolveDepthBuffer: y.ignoreDepthValues === !1,
                                        resolveStencilBuffer: y.ignoreDepthValues === !1
                                    })
                                }
                                N.isXRRenderTarget = !0,
                                this.setFoveation(f),
                                d = null,
                                o = await i.requestReferenceSpace(u),
                                Ae.setContext(i),
                                Ae.start(),
                                n.isPresenting = !0,
                                n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        }
                        ,
                        this.getEnvironmentBlendMode = function() {
                            if (i !== null)
                                return i.environmentBlendMode
                        }
                        ,
                        this.getDepthTexture = function() {
                            return w.getDepthTexture()
                        }
                        ;
                        function q(ie) {
                            for (let Me = 0; Me < ie.removed.length; Me++) {
                                const we = ie.removed[Me]
                                  , Te = U.indexOf(we);
                                Te >= 0 && (U[Te] = null,
                                D[Te].disconnect(we))
                            }
                            for (let Me = 0; Me < ie.added.length; Me++) {
                                const we = ie.added[Me];
                                let Te = U.indexOf(we);
                                if (Te === -1) {
                                    for (let Ze = 0; Ze < D.length; Ze++)
                                        if (Ze >= U.length) {
                                            U.push(we),
                                            Te = Ze;
                                            break
                                        } else if (U[Ze] === null) {
                                            U[Ze] = we,
                                            Te = Ze;
                                            break
                                        }
                                    if (Te === -1)
                                        break
                                }
                                const Je = D[Te];
                                Je && Je.connect(we)
                            }
                        }
                        const F = new J
                          , X = new J;
                        function $(ie, Me, we) {
                            F.setFromMatrixPosition(Me.matrixWorld),
                            X.setFromMatrixPosition(we.matrixWorld);
                            const Te = F.distanceTo(X)
                              , Je = Me.projectionMatrix.elements
                              , Ze = we.projectionMatrix.elements
                              , Ct = Je[14] / (Je[10] - 1)
                              , bt = Je[14] / (Je[10] + 1)
                              , Ue = (Je[9] + 1) / Je[5]
                              , ve = (Je[9] - 1) / Je[5]
                              , Ce = (Je[8] - 1) / Je[0]
                              , qe = (Ze[8] + 1) / Ze[0]
                              , Q = Ct * Ce
                              , Ke = Ct * qe
                              , Ve = Te / (-Ce + qe)
                              , ft = Ve * -Ce;
                            if (Me.matrixWorld.decompose(ie.position, ie.quaternion, ie.scale),
                            ie.translateX(ft),
                            ie.translateZ(Ve),
                            ie.matrixWorld.compose(ie.position, ie.quaternion, ie.scale),
                            ie.matrixWorldInverse.copy(ie.matrixWorld).invert(),
                            Je[10] === -1)
                                ie.projectionMatrix.copy(Me.projectionMatrix),
                                ie.projectionMatrixInverse.copy(Me.projectionMatrixInverse);
                            else {
                                const ke = Ct + Ve
                                  , Nt = bt + Ve
                                  , Z = Q - ft
                                  , H = Ke + (Te - ft)
                                  , he = Ue * bt / Nt * ke
                                  , Le = ve * bt / Nt * ke;
                                ie.projectionMatrix.makePerspective(Z, H, he, Le, ke, Nt),
                                ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert()
                            }
                        }
                        function ne(ie, Me) {
                            Me === null ? ie.matrixWorld.copy(ie.matrix) : ie.matrixWorld.multiplyMatrices(Me.matrixWorld, ie.matrix),
                            ie.matrixWorldInverse.copy(ie.matrixWorld).invert()
                        }
                        this.updateCamera = function(ie) {
                            if (i === null)
                                return;
                            let Me = ie.near
                              , we = ie.far;
                            w.texture !== null && (w.depthNear > 0 && (Me = w.depthNear),
                            w.depthFar > 0 && (we = w.depthFar)),
                            G.near = B.near = V.near = Me,
                            G.far = B.far = V.far = we,
                            (K !== G.near || ee !== G.far) && (i.updateRenderState({
                                depthNear: G.near,
                                depthFar: G.far
                            }),
                            K = G.near,
                            ee = G.far),
                            G.layers.mask = ie.layers.mask | 6,
                            V.layers.mask = G.layers.mask & 3,
                            B.layers.mask = G.layers.mask & 5;
                            const Te = ie.parent
                              , Je = G.cameras;
                            ne(G, Te);
                            for (let Ze = 0; Ze < Je.length; Ze++)
                                ne(Je[Ze], Te);
                            Je.length === 2 ? $(G, V, B) : G.projectionMatrix.copy(V.projectionMatrix),
                            ce(ie, G, Te)
                        }
                        ;
                        function ce(ie, Me, we) {
                            we === null ? ie.matrix.copy(Me.matrixWorld) : (ie.matrix.copy(we.matrixWorld),
                            ie.matrix.invert(),
                            ie.matrix.multiply(Me.matrixWorld)),
                            ie.matrix.decompose(ie.position, ie.quaternion, ie.scale),
                            ie.updateMatrixWorld(!0),
                            ie.projectionMatrix.copy(Me.projectionMatrix),
                            ie.projectionMatrixInverse.copy(Me.projectionMatrixInverse),
                            ie.isPerspectiveCamera && (ie.fov = Rd * 2 * Math.atan(1 / ie.projectionMatrix.elements[5]),
                            ie.zoom = 1)
                        }
                        this.getCamera = function() {
                            return G
                        }
                        ,
                        this.getFoveation = function() {
                            if (!(v === null && y === null))
                                return f
                        }
                        ,
                        this.setFoveation = function(ie) {
                            f = ie,
                            v !== null && (v.fixedFoveation = ie),
                            y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = ie)
                        }
                        ,
                        this.hasDepthSensing = function() {
                            return w.texture !== null
                        }
                        ,
                        this.getDepthSensingMesh = function() {
                            return w.getMesh(G)
                        }
                        ,
                        this.getCameraTexture = function(ie) {
                            return A[ie]
                        }
                        ;
                        let k = null;
                        function pe(ie, Me) {
                            if (p = Me.getViewerPose(d || o),
                            S = Me,
                            p !== null) {
                                const we = p.views;
                                y !== null && (t.setRenderTargetFramebuffer(N, y.framebuffer),
                                t.setRenderTarget(N));
                                let Te = !1;
                                we.length !== G.cameras.length && (G.cameras.length = 0,
                                Te = !0);
                                for (let Ze = 0; Ze < we.length; Ze++) {
                                    const Ct = we[Ze];
                                    let bt = null;
                                    if (y !== null)
                                        bt = y.getViewport(Ct);
                                    else {
                                        const ve = g.getViewSubImage(v, Ct);
                                        bt = ve.viewport,
                                        Ze === 0 && (t.setRenderTargetTextures(N, ve.colorTexture, ve.depthStencilTexture),
                                        t.setRenderTarget(N))
                                    }
                                    let Ue = P[Ze];
                                    Ue === void 0 && (Ue = new _s,
                                    Ue.layers.enable(Ze),
                                    Ue.viewport = new di,
                                    P[Ze] = Ue),
                                    Ue.matrix.fromArray(Ct.transform.matrix),
                                    Ue.matrix.decompose(Ue.position, Ue.quaternion, Ue.scale),
                                    Ue.projectionMatrix.fromArray(Ct.projectionMatrix),
                                    Ue.projectionMatrixInverse.copy(Ue.projectionMatrix).invert(),
                                    Ue.viewport.set(bt.x, bt.y, bt.width, bt.height),
                                    Ze === 0 && (G.matrix.copy(Ue.matrix),
                                    G.matrix.decompose(G.position, G.quaternion, G.scale)),
                                    Te === !0 && G.cameras.push(Ue)
                                }
                                const Je = i.enabledFeatures;
                                if (Je && Je.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && E) {
                                    g = n.getBinding();
                                    const Ze = g.getDepthInformation(we[0]);
                                    Ze && Ze.isValid && Ze.texture && w.init(Ze, i.renderState)
                                }
                                if (Je && Je.includes("camera-access") && E) {
                                    t.state.unbindTexture(),
                                    g = n.getBinding();
                                    for (let Ze = 0; Ze < we.length; Ze++) {
                                        const Ct = we[Ze].camera;
                                        if (Ct) {
                                            let bt = A[Ct];
                                            bt || (bt = new mM,
                                            A[Ct] = bt);
                                            const Ue = g.getCameraImage(Ct);
                                            bt.sourceTexture = Ue
                                        }
                                    }
                                }
                            }
                            for (let we = 0; we < D.length; we++) {
                                const Te = U[we]
                                  , Je = D[we];
                                Te !== null && Je !== void 0 && Je.update(Te, Me, d || o)
                            }
                            k && k(ie, Me),
                            Me.detectedPlanes && n.dispatchEvent({
                                type: "planesdetected",
                                data: Me
                            }),
                            S = null
                        }
                        const Ae = new vC;
                        Ae.setAnimationLoop(pe),
                        this.setAnimationLoop = function(ie) {
                            k = ie
                        }
                        ,
                        this.dispose = function() {}
                    }
                }
                ;
                const Xh = new vo
                  , YI = new jt;
                function jI(t, e) {
                    function n(A, T) {
                        A.matrixAutoUpdate === !0 && A.updateMatrix(),
                        T.value.copy(A.matrix)
                    }
                    function i(A, T) {
                        T.color.getRGB(A.fogColor.value, fA(t)),
                        T.isFog ? (A.fogNear.value = T.near,
                        A.fogFar.value = T.far) : T.isFogExp2 && (A.fogDensity.value = T.density)
                    }
                    function a(A, T, R, N, D) {
                        T.isMeshBasicMaterial || T.isMeshLambertMaterial ? o(A, T) : T.isMeshToonMaterial ? (o(A, T),
                        v(A, T)) : T.isMeshPhongMaterial ? (o(A, T),
                        g(A, T)) : T.isMeshStandardMaterial ? (o(A, T),
                        y(A, T),
                        T.isMeshPhysicalMaterial && S(A, T, D)) : T.isMeshMatcapMaterial ? (o(A, T),
                        E(A, T)) : T.isMeshDepthMaterial ? o(A, T) : T.isMeshDistanceMaterial ? (o(A, T),
                        w(A, T)) : T.isMeshNormalMaterial ? o(A, T) : T.isLineBasicMaterial ? (u(A, T),
                        T.isLineDashedMaterial && f(A, T)) : T.isPointsMaterial ? d(A, T, R, N) : T.isSpriteMaterial ? p(A, T) : T.isShadowMaterial ? (A.color.value.copy(T.color),
                        A.opacity.value = T.opacity) : T.isShaderMaterial && (T.uniformsNeedUpdate = !1)
                    }
                    function o(A, T) {
                        A.opacity.value = T.opacity,
                        T.color && A.diffuse.value.copy(T.color),
                        T.emissive && A.emissive.value.copy(T.emissive).multiplyScalar(T.emissiveIntensity),
                        T.map && (A.map.value = T.map,
                        n(T.map, A.mapTransform)),
                        T.alphaMap && (A.alphaMap.value = T.alphaMap,
                        n(T.alphaMap, A.alphaMapTransform)),
                        T.bumpMap && (A.bumpMap.value = T.bumpMap,
                        n(T.bumpMap, A.bumpMapTransform),
                        A.bumpScale.value = T.bumpScale,
                        T.side === fa && (A.bumpScale.value *= -1)),
                        T.normalMap && (A.normalMap.value = T.normalMap,
                        n(T.normalMap, A.normalMapTransform),
                        A.normalScale.value.copy(T.normalScale),
                        T.side === fa && A.normalScale.value.negate()),
                        T.displacementMap && (A.displacementMap.value = T.displacementMap,
                        n(T.displacementMap, A.displacementMapTransform),
                        A.displacementScale.value = T.displacementScale,
                        A.displacementBias.value = T.displacementBias),
                        T.emissiveMap && (A.emissiveMap.value = T.emissiveMap,
                        n(T.emissiveMap, A.emissiveMapTransform)),
                        T.specularMap && (A.specularMap.value = T.specularMap,
                        n(T.specularMap, A.specularMapTransform)),
                        T.alphaTest > 0 && (A.alphaTest.value = T.alphaTest);
                        const R = e.get(T)
                          , N = R.envMap
                          , D = R.envMapRotation;
                        N && (A.envMap.value = N,
                        Xh.copy(D),
                        Xh.x *= -1,
                        Xh.y *= -1,
                        Xh.z *= -1,
                        N.isCubeTexture && N.isRenderTargetTexture === !1 && (Xh.y *= -1,
                        Xh.z *= -1),
                        A.envMapRotation.value.setFromMatrix4(YI.makeRotationFromEuler(Xh)),
                        A.flipEnvMap.value = N.isCubeTexture && N.isRenderTargetTexture === !1 ? -1 : 1,
                        A.reflectivity.value = T.reflectivity,
                        A.ior.value = T.ior,
                        A.refractionRatio.value = T.refractionRatio),
                        T.lightMap && (A.lightMap.value = T.lightMap,
                        A.lightMapIntensity.value = T.lightMapIntensity,
                        n(T.lightMap, A.lightMapTransform)),
                        T.aoMap && (A.aoMap.value = T.aoMap,
                        A.aoMapIntensity.value = T.aoMapIntensity,
                        n(T.aoMap, A.aoMapTransform))
                    }
                    function u(A, T) {
                        A.diffuse.value.copy(T.color),
                        A.opacity.value = T.opacity,
                        T.map && (A.map.value = T.map,
                        n(T.map, A.mapTransform))
                    }
                    function f(A, T) {
                        A.dashSize.value = T.dashSize,
                        A.totalSize.value = T.dashSize + T.gapSize,
                        A.scale.value = T.scale
                    }
                    function d(A, T, R, N) {
                        A.diffuse.value.copy(T.color),
                        A.opacity.value = T.opacity,
                        A.size.value = T.size * R,
                        A.scale.value = N * .5,
                        T.map && (A.map.value = T.map,
                        n(T.map, A.uvTransform)),
                        T.alphaMap && (A.alphaMap.value = T.alphaMap,
                        n(T.alphaMap, A.alphaMapTransform)),
                        T.alphaTest > 0 && (A.alphaTest.value = T.alphaTest)
                    }
                    function p(A, T) {
                        A.diffuse.value.copy(T.color),
                        A.opacity.value = T.opacity,
                        A.rotation.value = T.rotation,
                        T.map && (A.map.value = T.map,
                        n(T.map, A.mapTransform)),
                        T.alphaMap && (A.alphaMap.value = T.alphaMap,
                        n(T.alphaMap, A.alphaMapTransform)),
                        T.alphaTest > 0 && (A.alphaTest.value = T.alphaTest)
                    }
                    function g(A, T) {
                        A.specular.value.copy(T.specular),
                        A.shininess.value = Math.max(T.shininess, 1e-4)
                    }
                    function v(A, T) {
                        T.gradientMap && (A.gradientMap.value = T.gradientMap)
                    }
                    function y(A, T) {
                        A.metalness.value = T.metalness,
                        T.metalnessMap && (A.metalnessMap.value = T.metalnessMap,
                        n(T.metalnessMap, A.metalnessMapTransform)),
                        A.roughness.value = T.roughness,
                        T.roughnessMap && (A.roughnessMap.value = T.roughnessMap,
                        n(T.roughnessMap, A.roughnessMapTransform)),
                        T.envMap && (A.envMapIntensity.value = T.envMapIntensity)
                    }
                    function S(A, T, R) {
                        A.ior.value = T.ior,
                        T.sheen > 0 && (A.sheenColor.value.copy(T.sheenColor).multiplyScalar(T.sheen),
                        A.sheenRoughness.value = T.sheenRoughness,
                        T.sheenColorMap && (A.sheenColorMap.value = T.sheenColorMap,
                        n(T.sheenColorMap, A.sheenColorMapTransform)),
                        T.sheenRoughnessMap && (A.sheenRoughnessMap.value = T.sheenRoughnessMap,
                        n(T.sheenRoughnessMap, A.sheenRoughnessMapTransform))),
                        T.clearcoat > 0 && (A.clearcoat.value = T.clearcoat,
                        A.clearcoatRoughness.value = T.clearcoatRoughness,
                        T.clearcoatMap && (A.clearcoatMap.value = T.clearcoatMap,
                        n(T.clearcoatMap, A.clearcoatMapTransform)),
                        T.clearcoatRoughnessMap && (A.clearcoatRoughnessMap.value = T.clearcoatRoughnessMap,
                        n(T.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)),
                        T.clearcoatNormalMap && (A.clearcoatNormalMap.value = T.clearcoatNormalMap,
                        n(T.clearcoatNormalMap, A.clearcoatNormalMapTransform),
                        A.clearcoatNormalScale.value.copy(T.clearcoatNormalScale),
                        T.side === fa && A.clearcoatNormalScale.value.negate())),
                        T.dispersion > 0 && (A.dispersion.value = T.dispersion),
                        T.iridescence > 0 && (A.iridescence.value = T.iridescence,
                        A.iridescenceIOR.value = T.iridescenceIOR,
                        A.iridescenceThicknessMinimum.value = T.iridescenceThicknessRange[0],
                        A.iridescenceThicknessMaximum.value = T.iridescenceThicknessRange[1],
                        T.iridescenceMap && (A.iridescenceMap.value = T.iridescenceMap,
                        n(T.iridescenceMap, A.iridescenceMapTransform)),
                        T.iridescenceThicknessMap && (A.iridescenceThicknessMap.value = T.iridescenceThicknessMap,
                        n(T.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))),
                        T.transmission > 0 && (A.transmission.value = T.transmission,
                        A.transmissionSamplerMap.value = R.texture,
                        A.transmissionSamplerSize.value.set(R.width, R.height),
                        T.transmissionMap && (A.transmissionMap.value = T.transmissionMap,
                        n(T.transmissionMap, A.transmissionMapTransform)),
                        A.thickness.value = T.thickness,
                        T.thicknessMap && (A.thicknessMap.value = T.thicknessMap,
                        n(T.thicknessMap, A.thicknessMapTransform)),
                        A.attenuationDistance.value = T.attenuationDistance,
                        A.attenuationColor.value.copy(T.attenuationColor)),
                        T.anisotropy > 0 && (A.anisotropyVector.value.set(T.anisotropy * Math.cos(T.anisotropyRotation), T.anisotropy * Math.sin(T.anisotropyRotation)),
                        T.anisotropyMap && (A.anisotropyMap.value = T.anisotropyMap,
                        n(T.anisotropyMap, A.anisotropyMapTransform))),
                        A.specularIntensity.value = T.specularIntensity,
                        A.specularColor.value.copy(T.specularColor),
                        T.specularColorMap && (A.specularColorMap.value = T.specularColorMap,
                        n(T.specularColorMap, A.specularColorMapTransform)),
                        T.specularIntensityMap && (A.specularIntensityMap.value = T.specularIntensityMap,
                        n(T.specularIntensityMap, A.specularIntensityMapTransform))
                    }
                    function E(A, T) {
                        T.matcap && (A.matcap.value = T.matcap)
                    }
                    function w(A, T) {
                        const R = e.get(T).light;
                        A.referencePosition.value.setFromMatrixPosition(R.matrixWorld),
                        A.nearDistance.value = R.shadow.camera.near,
                        A.farDistance.value = R.shadow.camera.far
                    }
                    return {
                        refreshFogUniforms: i,
                        refreshMaterialUniforms: a
                    }
                }
                function ZI(t, e, n, i) {
                    let a = {}
                      , o = {}
                      , u = [];
                    const f = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);
                    function d(R, N) {
                        const D = N.program;
                        i.uniformBlockBinding(R, D)
                    }
                    function p(R, N) {
                        let D = a[R.id];
                        D === void 0 && (E(R),
                        D = g(R),
                        a[R.id] = D,
                        R.addEventListener("dispose", A));
                        const U = N.program;
                        i.updateUBOMapping(R, U);
                        const z = e.render.frame;
                        o[R.id] !== z && (y(R),
                        o[R.id] = z)
                    }
                    function g(R) {
                        const N = v();
                        R.__bindingPointIndex = N;
                        const D = t.createBuffer()
                          , U = R.__size
                          , z = R.usage;
                        return t.bindBuffer(t.UNIFORM_BUFFER, D),
                        t.bufferData(t.UNIFORM_BUFFER, U, z),
                        t.bindBuffer(t.UNIFORM_BUFFER, null),
                        t.bindBufferBase(t.UNIFORM_BUFFER, N, D),
                        D
                    }
                    function v() {
                        for (let R = 0; R < f; R++)
                            if (u.indexOf(R) === -1)
                                return u.push(R),
                                R;
                        return Rt("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                        0
                    }
                    function y(R) {
                        const N = a[R.id]
                          , D = R.uniforms
                          , U = R.__cache;
                        t.bindBuffer(t.UNIFORM_BUFFER, N);
                        for (let z = 0, I = D.length; z < I; z++) {
                            const V = Array.isArray(D[z]) ? D[z] : [D[z]];
                            for (let B = 0, P = V.length; B < P; B++) {
                                const G = V[B];
                                if (S(G, z, B, U) === !0) {
                                    const K = G.__offset
                                      , ee = Array.isArray(G.value) ? G.value : [G.value];
                                    let te = 0;
                                    for (let oe = 0; oe < ee.length; oe++) {
                                        const q = ee[oe]
                                          , F = w(q);
                                        typeof q == "number" || typeof q == "boolean" ? (G.__data[0] = q,
                                        t.bufferSubData(t.UNIFORM_BUFFER, K + te, G.__data)) : q.isMatrix3 ? (G.__data[0] = q.elements[0],
                                        G.__data[1] = q.elements[1],
                                        G.__data[2] = q.elements[2],
                                        G.__data[3] = 0,
                                        G.__data[4] = q.elements[3],
                                        G.__data[5] = q.elements[4],
                                        G.__data[6] = q.elements[5],
                                        G.__data[7] = 0,
                                        G.__data[8] = q.elements[6],
                                        G.__data[9] = q.elements[7],
                                        G.__data[10] = q.elements[8],
                                        G.__data[11] = 0) : (q.toArray(G.__data, te),
                                        te += F.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    t.bufferSubData(t.UNIFORM_BUFFER, K, G.__data)
                                }
                            }
                        }
                        t.bindBuffer(t.UNIFORM_BUFFER, null)
                    }
                    function S(R, N, D, U) {
                        const z = R.value
                          , I = N + "_" + D;
                        if (U[I] === void 0)
                            return typeof z == "number" || typeof z == "boolean" ? U[I] = z : U[I] = z.clone(),
                            !0;
                        {
                            const V = U[I];
                            if (typeof z == "number" || typeof z == "boolean") {
                                if (V !== z)
                                    return U[I] = z,
                                    !0
                            } else if (V.equals(z) === !1)
                                return V.copy(z),
                                !0
                        }
                        return !1
                    }
                    function E(R) {
                        const N = R.uniforms;
                        let D = 0;
                        const U = 16;
                        for (let I = 0, V = N.length; I < V; I++) {
                            const B = Array.isArray(N[I]) ? N[I] : [N[I]];
                            for (let P = 0, G = B.length; P < G; P++) {
                                const K = B[P]
                                  , ee = Array.isArray(K.value) ? K.value : [K.value];
                                for (let te = 0, oe = ee.length; te < oe; te++) {
                                    const q = ee[te]
                                      , F = w(q)
                                      , X = D % U
                                      , $ = X % F.boundary
                                      , ne = X + $;
                                    D += $,
                                    ne !== 0 && U - ne < F.storage && (D += U - ne),
                                    K.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT),
                                    K.__offset = D,
                                    D += F.storage
                                }
                            }
                        }
                        const z = D % U;
                        return z > 0 && (D += U - z),
                        R.__size = D,
                        R.__cache = {},
                        this
                    }
                    function w(R) {
                        const N = {
                            boundary: 0,
                            storage: 0
                        };
                        return typeof R == "number" || typeof R == "boolean" ? (N.boundary = 4,
                        N.storage = 4) : R.isVector2 ? (N.boundary = 8,
                        N.storage = 8) : R.isVector3 || R.isColor ? (N.boundary = 16,
                        N.storage = 12) : R.isVector4 ? (N.boundary = 16,
                        N.storage = 16) : R.isMatrix3 ? (N.boundary = 48,
                        N.storage = 48) : R.isMatrix4 ? (N.boundary = 64,
                        N.storage = 64) : R.isTexture ? at("WebGLRenderer: Texture samplers can not be part of an uniforms group.") : at("WebGLRenderer: Unsupported uniform value type.", R),
                        N
                    }
                    function A(R) {
                        const N = R.target;
                        N.removeEventListener("dispose", A);
                        const D = u.indexOf(N.__bindingPointIndex);
                        u.splice(D, 1),
                        t.deleteBuffer(a[N.id]),
                        delete a[N.id],
                        delete o[N.id]
                    }
                    function T() {
                        for (const R in a)
                            t.deleteBuffer(a[R]);
                        u = [],
                        a = {},
                        o = {}
                    }
                    return {
                        bind: d,
                        update: p,
                        dispose: T
                    }
                }
                const QI = new Uint16Array([12469, 15057, 12620, 14925, 13266, 14620, 13807, 14376, 14323, 13990, 14545, 13625, 14713, 13328, 14840, 12882, 14931, 12528, 14996, 12233, 15039, 11829, 15066, 11525, 15080, 11295, 15085, 10976, 15082, 10705, 15073, 10495, 13880, 14564, 13898, 14542, 13977, 14430, 14158, 14124, 14393, 13732, 14556, 13410, 14702, 12996, 14814, 12596, 14891, 12291, 14937, 11834, 14957, 11489, 14958, 11194, 14943, 10803, 14921, 10506, 14893, 10278, 14858, 9960, 14484, 14039, 14487, 14025, 14499, 13941, 14524, 13740, 14574, 13468, 14654, 13106, 14743, 12678, 14818, 12344, 14867, 11893, 14889, 11509, 14893, 11180, 14881, 10751, 14852, 10428, 14812, 10128, 14765, 9754, 14712, 9466, 14764, 13480, 14764, 13475, 14766, 13440, 14766, 13347, 14769, 13070, 14786, 12713, 14816, 12387, 14844, 11957, 14860, 11549, 14868, 11215, 14855, 10751, 14825, 10403, 14782, 10044, 14729, 9651, 14666, 9352, 14599, 9029, 14967, 12835, 14966, 12831, 14963, 12804, 14954, 12723, 14936, 12564, 14917, 12347, 14900, 11958, 14886, 11569, 14878, 11247, 14859, 10765, 14828, 10401, 14784, 10011, 14727, 9600, 14660, 9289, 14586, 8893, 14508, 8533, 15111, 12234, 15110, 12234, 15104, 12216, 15092, 12156, 15067, 12010, 15028, 11776, 14981, 11500, 14942, 11205, 14902, 10752, 14861, 10393, 14812, 9991, 14752, 9570, 14682, 9252, 14603, 8808, 14519, 8445, 14431, 8145, 15209, 11449, 15208, 11451, 15202, 11451, 15190, 11438, 15163, 11384, 15117, 11274, 15055, 10979, 14994, 10648, 14932, 10343, 14871, 9936, 14803, 9532, 14729, 9218, 14645, 8742, 14556, 8381, 14461, 8020, 14365, 7603, 15273, 10603, 15272, 10607, 15267, 10619, 15256, 10631, 15231, 10614, 15182, 10535, 15118, 10389, 15042, 10167, 14963, 9787, 14883, 9447, 14800, 9115, 14710, 8665, 14615, 8318, 14514, 7911, 14411, 7507, 14279, 7198, 15314, 9675, 15313, 9683, 15309, 9712, 15298, 9759, 15277, 9797, 15229, 9773, 15166, 9668, 15084, 9487, 14995, 9274, 14898, 8910, 14800, 8539, 14697, 8234, 14590, 7790, 14479, 7409, 14367, 7067, 14178, 6621, 15337, 8619, 15337, 8631, 15333, 8677, 15325, 8769, 15305, 8871, 15264, 8940, 15202, 8909, 15119, 8775, 15022, 8565, 14916, 8328, 14804, 8009, 14688, 7614, 14569, 7287, 14448, 6888, 14321, 6483, 14088, 6171, 15350, 7402, 15350, 7419, 15347, 7480, 15340, 7613, 15322, 7804, 15287, 7973, 15229, 8057, 15148, 8012, 15046, 7846, 14933, 7611, 14810, 7357, 14682, 7069, 14552, 6656, 14421, 6316, 14251, 5948, 14007, 5528, 15356, 5942, 15356, 5977, 15353, 6119, 15348, 6294, 15332, 6551, 15302, 6824, 15249, 7044, 15171, 7122, 15070, 7050, 14949, 6861, 14818, 6611, 14679, 6349, 14538, 6067, 14398, 5651, 14189, 5311, 13935, 4958, 15359, 4123, 15359, 4153, 15356, 4296, 15353, 4646, 15338, 5160, 15311, 5508, 15263, 5829, 15188, 6042, 15088, 6094, 14966, 6001, 14826, 5796, 14678, 5543, 14527, 5287, 14377, 4985, 14133, 4586, 13869, 4257, 15360, 1563, 15360, 1642, 15358, 2076, 15354, 2636, 15341, 3350, 15317, 4019, 15273, 4429, 15203, 4732, 15105, 4911, 14981, 4932, 14836, 4818, 14679, 4621, 14517, 4386, 14359, 4156, 14083, 3795, 13808, 3437, 15360, 122, 15360, 137, 15358, 285, 15355, 636, 15344, 1274, 15322, 2177, 15281, 2765, 15215, 3223, 15120, 3451, 14995, 3569, 14846, 3567, 14681, 3466, 14511, 3305, 14344, 3121, 14037, 2800, 13753, 2467, 15360, 0, 15360, 1, 15359, 21, 15355, 89, 15346, 253, 15325, 479, 15287, 796, 15225, 1148, 15133, 1492, 15008, 1749, 14856, 1882, 14685, 1886, 14506, 1783, 14324, 1608, 13996, 1398, 13702, 1183]);
                let pl = null;
                function KI() {
                    return pl === null && (pl = new yo(QI,16,16,xh,ol),
                    pl.name = "DFG_LUT",
                    pl.minFilter = fi,
                    pl.magFilter = fi,
                    pl.wrapS = Ia,
                    pl.wrapT = Ia,
                    pl.generateMipmaps = !1,
                    pl.needsUpdate = !0),
                    pl
                }
                var XC = class {
                    constructor(t={}) {
                        const {canvas: e=Y1(), context: n=null, depth: i=!0, stencil: a=!1, alpha: o=!1, antialias: u=!1, premultipliedAlpha: f=!0, preserveDrawingBuffer: d=!1, powerPreference: p="default", failIfMajorPerformanceCaveat: g=!1, reversedDepthBuffer: v=!1, outputBufferType: y=da} = t;
                        this.isWebGLRenderer = !0;
                        let S;
                        if (n !== null) {
                            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                            S = n.getContextAttributes().alpha
                        } else
                            S = o;
                        const E = y
                          , w = new Set([$_, J_, cg])
                          , A = new Set([da, Ir, Td, Ad, Z_, Q_])
                          , T = new Uint32Array(4)
                          , R = new Int32Array(4);
                        let N = null
                          , D = null;
                        const U = []
                          , z = [];
                        let I = null;
                        this.domElement = e,
                        this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        },
                        this.autoClear = !0,
                        this.autoClearColor = !0,
                        this.autoClearDepth = !0,
                        this.autoClearStencil = !0,
                        this.sortObjects = !0,
                        this.clippingPlanes = [],
                        this.localClippingEnabled = !1,
                        this.toneMapping = Lr,
                        this.toneMappingExposure = 1,
                        this.transmissionResolutionScale = 1;
                        const V = this;
                        let B = !1;
                        this._outputColorSpace = Gs;
                        let P = 0
                          , G = 0
                          , K = null
                          , ee = -1
                          , te = null;
                        const oe = new di
                          , q = new di;
                        let F = null;
                        const X = new ut(0);
                        let $ = 0
                          , ne = e.width
                          , ce = e.height
                          , k = 1
                          , pe = null
                          , Ae = null;
                        const ie = new di(0,0,ne,ce)
                          , Me = new di(0,0,ne,ce);
                        let we = !1;
                        const Te = new $d;
                        let Je = !1
                          , Ze = !1;
                        const Ct = new jt
                          , bt = new J
                          , Ue = new di
                          , ve = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };
                        let Ce = !1;
                        function qe() {
                            return K === null ? k : 1
                        }
                        let Q = n;
                        function Ke(Y, ue) {
                            return e.getContext(Y, ue)
                        }
                        try {
                            const Y = {
                                alpha: !0,
                                depth: i,
                                stencil: a,
                                antialias: u,
                                premultipliedAlpha: f,
                                preserveDrawingBuffer: d,
                                powerPreference: p,
                                failIfMajorPerformanceCaveat: g
                            };
                            if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${z_}`),
                            e.addEventListener("webglcontextlost", mt, !1),
                            e.addEventListener("webglcontextrestored", Tt, !1),
                            e.addEventListener("webglcontextcreationerror", si, !1),
                            Q === null) {
                                const ue = "webgl2";
                                if (Q = Ke(ue, Y),
                                Q === null)
                                    throw Ke(ue) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                            }
                        } catch (Y) {
                            throw Rt("WebGLRenderer: " + Y.message),
                            Y
                        }
                        let Ve, ft, ke, Nt, Z, H, he, Le, He, Oe, pt, et, xt, Dt, je, Xe, nt, ot, tt, Gt, le, it, Qe, dt;
                        function We() {
                            Ve = new JL(Q),
                            Ve.init(),
                            it = new qC(Q,Ve),
                            ft = new kL(Q,Ve,t,it),
                            ke = new HI(Q,Ve),
                            ft.reversedDepthBuffer && v && ke.buffers.depth.setReversed(!0),
                            Nt = new t4(Q),
                            Z = new EI,
                            H = new GI(Q,Ve,ke,Z,ft,it,Nt),
                            he = new XL(V),
                            Le = new KL(V),
                            He = new PL(Q),
                            Qe = new HL(Q,He),
                            Oe = new $L(Q,He,Nt,Qe),
                            pt = new i4(Q,Oe,He,Nt),
                            tt = new n4(Q,ft,H),
                            Xe = new qL(Z),
                            et = new AI(V,he,Le,Ve,ft,Qe,Xe),
                            xt = new jI(V,Z),
                            Dt = new wI,
                            je = new LI(Ve),
                            ot = new FL(V,he,Le,ke,pt,S,f),
                            nt = new VI(V,pt,ft),
                            dt = new ZI(Q,Nt,ft,ke),
                            Gt = new GL(Q,Ve,Nt),
                            le = new e4(Q,Ve,Nt),
                            Nt.programs = et.programs,
                            V.capabilities = ft,
                            V.extensions = Ve,
                            V.properties = Z,
                            V.renderLists = Dt,
                            V.shadowMap = nt,
                            V.state = ke,
                            V.info = Nt
                        }
                        We(),
                        E !== da && (I = new a4(E,e.width,e.height,i,a));
                        const De = new WI(V,Q);
                        this.xr = De,
                        this.getContext = function() {
                            return Q
                        }
                        ,
                        this.getContextAttributes = function() {
                            return Q.getContextAttributes()
                        }
                        ,
                        this.forceContextLoss = function() {
                            const Y = Ve.get("WEBGL_lose_context");
                            Y && Y.loseContext()
                        }
                        ,
                        this.forceContextRestore = function() {
                            const Y = Ve.get("WEBGL_lose_context");
                            Y && Y.restoreContext()
                        }
                        ,
                        this.getPixelRatio = function() {
                            return k
                        }
                        ,
                        this.setPixelRatio = function(Y) {
                            Y !== void 0 && (k = Y,
                            this.setSize(ne, ce, !1))
                        }
                        ,
                        this.getSize = function(Y) {
                            return Y.set(ne, ce)
                        }
                        ,
                        this.setSize = function(Y, ue, _e=!0) {
                            if (De.isPresenting) {
                                at("WebGLRenderer: Can't change size while VR device is presenting.");
                                return
                            }
                            ne = Y,
                            ce = ue,
                            e.width = Math.floor(Y * k),
                            e.height = Math.floor(ue * k),
                            _e === !0 && (e.style.width = Y + "px",
                            e.style.height = ue + "px"),
                            I !== null && I.setSize(e.width, e.height),
                            this.setViewport(0, 0, Y, ue)
                        }
                        ,
                        this.getDrawingBufferSize = function(Y) {
                            return Y.set(ne * k, ce * k).floor()
                        }
                        ,
                        this.setDrawingBufferSize = function(Y, ue, _e) {
                            ne = Y,
                            ce = ue,
                            k = _e,
                            e.width = Math.floor(Y * _e),
                            e.height = Math.floor(ue * _e),
                            this.setViewport(0, 0, Y, ue)
                        }
                        ,
                        this.setEffects = function(Y) {
                            if (E === da) {
                                console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.");
                                return
                            }
                            if (Y) {
                                for (let ue = 0; ue < Y.length; ue++)
                                    if (Y[ue].isOutputPass === !0) {
                                        console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");
                                        break
                                    }
                            }
                            I.setEffects(Y || [])
                        }
                        ,
                        this.getCurrentViewport = function(Y) {
                            return Y.copy(oe)
                        }
                        ,
                        this.getViewport = function(Y) {
                            return Y.copy(ie)
                        }
                        ,
                        this.setViewport = function(Y, ue, _e, Se) {
                            Y.isVector4 ? ie.set(Y.x, Y.y, Y.z, Y.w) : ie.set(Y, ue, _e, Se),
                            ke.viewport(oe.copy(ie).multiplyScalar(k).round())
                        }
                        ,
                        this.getScissor = function(Y) {
                            return Y.copy(Me)
                        }
                        ,
                        this.setScissor = function(Y, ue, _e, Se) {
                            Y.isVector4 ? Me.set(Y.x, Y.y, Y.z, Y.w) : Me.set(Y, ue, _e, Se),
                            ke.scissor(q.copy(Me).multiplyScalar(k).round())
                        }
                        ,
                        this.getScissorTest = function() {
                            return we
                        }
                        ,
                        this.setScissorTest = function(Y) {
                            ke.setScissorTest(we = Y)
                        }
                        ,
                        this.setOpaqueSort = function(Y) {
                            pe = Y
                        }
                        ,
                        this.setTransparentSort = function(Y) {
                            Ae = Y
                        }
                        ,
                        this.getClearColor = function(Y) {
                            return Y.copy(ot.getClearColor())
                        }
                        ,
                        this.setClearColor = function() {
                            ot.setClearColor(...arguments)
                        }
                        ,
                        this.getClearAlpha = function() {
                            return ot.getClearAlpha()
                        }
                        ,
                        this.setClearAlpha = function() {
                            ot.setClearAlpha(...arguments)
                        }
                        ,
                        this.clear = function(Y=!0, ue=!0, _e=!0) {
                            let Se = 0;
                            if (Y) {
                                let me = !1;
                                if (K !== null) {
                                    const Ye = K.texture.format;
                                    me = w.has(Ye)
                                }
                                if (me) {
                                    const Ye = K.texture.type
                                      , st = A.has(Ye)
                                      , vt = ot.getClearColor()
                                      , ht = ot.getClearAlpha()
                                      , It = vt.r
                                      , Vt = vt.g
                                      , wt = vt.b;
                                    st ? (T[0] = It,
                                    T[1] = Vt,
                                    T[2] = wt,
                                    T[3] = ht,
                                    Q.clearBufferuiv(Q.COLOR, 0, T)) : (R[0] = It,
                                    R[1] = Vt,
                                    R[2] = wt,
                                    R[3] = ht,
                                    Q.clearBufferiv(Q.COLOR, 0, R))
                                } else
                                    Se |= Q.COLOR_BUFFER_BIT
                            }
                            ue && (Se |= Q.DEPTH_BUFFER_BIT),
                            _e && (Se |= Q.STENCIL_BUFFER_BIT,
                            this.state.buffers.stencil.setMask(4294967295)),
                            Q.clear(Se)
                        }
                        ,
                        this.clearColor = function() {
                            this.clear(!0, !1, !1)
                        }
                        ,
                        this.clearDepth = function() {
                            this.clear(!1, !0, !1)
                        }
                        ,
                        this.clearStencil = function() {
                            this.clear(!1, !1, !0)
                        }
                        ,
                        this.dispose = function() {
                            e.removeEventListener("webglcontextlost", mt, !1),
                            e.removeEventListener("webglcontextrestored", Tt, !1),
                            e.removeEventListener("webglcontextcreationerror", si, !1),
                            ot.dispose(),
                            Dt.dispose(),
                            je.dispose(),
                            Z.dispose(),
                            he.dispose(),
                            Le.dispose(),
                            pt.dispose(),
                            Qe.dispose(),
                            dt.dispose(),
                            et.dispose(),
                            De.dispose(),
                            De.removeEventListener("sessionstart", Ml),
                            De.removeEventListener("sessionend", ba),
                            Ta.stop()
                        }
                        ;
                        function mt(Y) {
                            Y.preventDefault(),
                            yg("WebGLRenderer: Context Lost."),
                            B = !0
                        }
                        function Tt() {
                            yg("WebGLRenderer: Context Restored."),
                            B = !1;
                            const Y = Nt.autoReset
                              , ue = nt.enabled
                              , _e = nt.autoUpdate
                              , Se = nt.needsUpdate
                              , me = nt.type;
                            We(),
                            Nt.autoReset = Y,
                            nt.enabled = ue,
                            nt.autoUpdate = _e,
                            nt.needsUpdate = Se,
                            nt.type = me
                        }
                        function si(Y) {
                            Rt("WebGLRenderer: A WebGL context could not be created. Reason: ", Y.statusMessage)
                        }
                        function pn(Y) {
                            const ue = Y.target;
                            ue.removeEventListener("dispose", pn),
                            cs(ue)
                        }
                        function cs(Y) {
                            ys(Y),
                            Z.remove(Y)
                        }
                        function ys(Y) {
                            const ue = Z.get(Y).programs;
                            ue !== void 0 && (ue.forEach(function(_e) {
                                et.releaseProgram(_e)
                            }),
                            Y.isShaderMaterial && et.releaseShaderCache(Y))
                        }
                        this.renderBufferDirect = function(Y, ue, _e, Se, me, Ye) {
                            ue === null && (ue = ve);
                            const st = me.isMesh && me.matrixWorld.determinant() < 0
                              , vt = Op(Y, ue, _e, Se, me);
                            ke.setMaterial(Se, st);
                            let ht = _e.index
                              , It = 1;
                            if (Se.wireframe === !0) {
                                if (ht = Oe.getWireframeAttribute(_e),
                                ht === void 0)
                                    return;
                                It = 2
                            }
                            const Vt = _e.drawRange
                              , wt = _e.attributes.position;
                            let tn = Vt.start * It
                              , rn = (Vt.start + Vt.count) * It;
                            Ye !== null && (tn = Math.max(tn, Ye.start * It),
                            rn = Math.min(rn, (Ye.start + Ye.count) * It)),
                            ht !== null ? (tn = Math.max(tn, 0),
                            rn = Math.min(rn, ht.count)) : wt != null && (tn = Math.max(tn, 0),
                            rn = Math.min(rn, wt.count));
                            const cn = rn - tn;
                            if (cn < 0 || cn === 1 / 0)
                                return;
                            Qe.setup(me, Se, vt, _e, ht);
                            let $n, vn = Gt;
                            if (ht !== null && ($n = He.get(ht),
                            vn = le,
                            vn.setIndex($n)),
                            me.isMesh)
                                Se.wireframe === !0 ? (ke.setLineWidth(Se.wireframeLinewidth * qe()),
                                vn.setMode(Q.LINES)) : vn.setMode(Q.TRIANGLES);
                            else if (me.isLine) {
                                let At = Se.linewidth;
                                At === void 0 && (At = 1),
                                ke.setLineWidth(At * qe()),
                                me.isLineSegments ? vn.setMode(Q.LINES) : me.isLineLoop ? vn.setMode(Q.LINE_LOOP) : vn.setMode(Q.LINE_STRIP)
                            } else
                                me.isPoints ? vn.setMode(Q.POINTS) : me.isSprite && vn.setMode(Q.TRIANGLES);
                            if (me.isBatchedMesh)
                                if (me._multiDrawInstances !== null)
                                    wd("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                                    vn.renderMultiDrawInstances(me._multiDrawStarts, me._multiDrawCounts, me._multiDrawCount, me._multiDrawInstances);
                                else if (Ve.get("WEBGL_multi_draw"))
                                    vn.renderMultiDraw(me._multiDrawStarts, me._multiDrawCounts, me._multiDrawCount);
                                else {
                                    const At = me._multiDrawStarts
                                      , Hn = me._multiDrawCounts
                                      , un = me._multiDrawCount
                                      , Ns = ht ? He.get(ht).bytesPerElement : 1
                                      , Ti = Z.get(Se).currentProgram.getUniforms();
                                    for (let qi = 0; qi < un; qi++)
                                        Ti.setValue(Q, "_gl_DrawID", qi),
                                        vn.render(At[qi] / Ns, Hn[qi])
                                }
                            else if (me.isInstancedMesh)
                                vn.renderInstances(tn, cn, me.count);
                            else if (_e.isInstancedBufferGeometry) {
                                const At = _e._maxInstanceCount !== void 0 ? _e._maxInstanceCount : 1 / 0
                                  , Hn = Math.min(_e.instanceCount, At);
                                vn.renderInstances(tn, cn, Hn)
                            } else
                                vn.render(tn, cn)
                        }
                        ;
                        function Tu(Y, ue, _e) {
                            Y.transparent === !0 && Y.side === il && Y.forceSinglePass === !1 ? (Y.side = fa,
                            Y.needsUpdate = !0,
                            Aa(Y, ue, _e),
                            Y.side = $l,
                            Y.needsUpdate = !0,
                            Aa(Y, ue, _e),
                            Y.side = il) : Aa(Y, ue, _e)
                        }
                        this.compile = function(Y, ue, _e=null) {
                            _e === null && (_e = Y),
                            D = je.get(_e),
                            D.init(ue),
                            z.push(D),
                            _e.traverseVisible(function(me) {
                                me.isLight && me.layers.test(ue.layers) && (D.pushLight(me),
                                me.castShadow && D.pushShadow(me))
                            }),
                            Y !== _e && Y.traverseVisible(function(me) {
                                me.isLight && me.layers.test(ue.layers) && (D.pushLight(me),
                                me.castShadow && D.pushShadow(me))
                            }),
                            D.setupLights();
                            const Se = new Set;
                            return Y.traverse(function(me) {
                                if (!(me.isMesh || me.isPoints || me.isLine || me.isSprite))
                                    return;
                                const Ye = me.material;
                                if (Ye)
                                    if (Array.isArray(Ye))
                                        for (let st = 0; st < Ye.length; st++) {
                                            const vt = Ye[st];
                                            Tu(vt, _e, me),
                                            Se.add(vt)
                                        }
                                    else
                                        Tu(Ye, _e, me),
                                        Se.add(Ye)
                            }),
                            D = z.pop(),
                            Se
                        }
                        ,
                        this.compileAsync = function(Y, ue, _e=null) {
                            const Se = this.compile(Y, ue, _e);
                            return new Promise(me => {
                                function Ye() {
                                    if (Se.forEach(function(st) {
                                        Z.get(st).currentProgram.isReady() && Se.delete(st)
                                    }),
                                    Se.size === 0) {
                                        me(Y);
                                        return
                                    }
                                    setTimeout(Ye, 10)
                                }
                                Ve.get("KHR_parallel_shader_compile") !== null ? Ye() : setTimeout(Ye, 10)
                            }
                            )
                        }
                        ;
                        let xl = null;
                        function vc(Y) {
                            xl && xl(Y)
                        }
                        function Ml() {
                            Ta.stop()
                        }
                        function ba() {
                            Ta.start()
                        }
                        const Ta = new vC;
                        Ta.setAnimationLoop(vc),
                        typeof self < "u" && Ta.setContext(self),
                        this.setAnimationLoop = function(Y) {
                            xl = Y,
                            De.setAnimationLoop(Y),
                            Y === null ? Ta.stop() : Ta.start()
                        }
                        ,
                        De.addEventListener("sessionstart", Ml),
                        De.addEventListener("sessionend", ba),
                        this.render = function(Y, ue) {
                            if (ue !== void 0 && ue.isCamera !== !0) {
                                Rt("WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                return
                            }
                            if (B === !0)
                                return;
                            const _e = De.enabled === !0 && De.isPresenting === !0
                              , Se = I !== null && (K === null || _e) && I.begin(V, K);
                            if (Y.matrixWorldAutoUpdate === !0 && Y.updateMatrixWorld(),
                            ue.parent === null && ue.matrixWorldAutoUpdate === !0 && ue.updateMatrixWorld(),
                            De.enabled === !0 && De.isPresenting === !0 && (I === null || I.isCompositing() === !1) && (De.cameraAutoUpdate === !0 && De.updateCamera(ue),
                            ue = De.getCamera()),
                            Y.isScene === !0 && Y.onBeforeRender(V, Y, ue, K),
                            D = je.get(Y, z.length),
                            D.init(ue),
                            z.push(D),
                            Ct.multiplyMatrices(ue.projectionMatrix, ue.matrixWorldInverse),
                            Te.setFromProjectionMatrix(Ct, nr, ue.reversedDepth),
                            Ze = this.localClippingEnabled,
                            Je = Xe.init(this.clippingPlanes, Ze),
                            N = Dt.get(Y, U.length),
                            N.init(),
                            U.push(N),
                            De.enabled === !0 && De.isPresenting === !0) {
                                const Ye = V.xr.getDepthSensingMesh();
                                Ye !== null && Ks(Ye, ue, -1 / 0, V.sortObjects)
                            }
                            Ks(Y, ue, 0, V.sortObjects),
                            N.finish(),
                            V.sortObjects === !0 && N.sort(pe, Ae),
                            Ce = De.enabled === !1 || De.isPresenting === !1 || De.hasDepthSensing() === !1,
                            Ce && ot.addToRenderList(N, Y),
                            this.info.render.frame++,
                            Je === !0 && Xe.beginShadows();
                            const me = D.state.shadowsArray;
                            if (nt.render(me, Y, ue),
                            Je === !0 && Xe.endShadows(),
                            this.info.autoReset === !0 && this.info.reset(),
                            (Se && I.hasRenderPass()) === !1) {
                                const Ye = N.opaque
                                  , st = N.transmissive;
                                if (D.setupLights(),
                                ue.isArrayCamera) {
                                    const vt = ue.cameras;
                                    if (st.length > 0)
                                        for (let ht = 0, It = vt.length; ht < It; ht++) {
                                            const Vt = vt[ht];
                                            Rs(Ye, st, Y, Vt)
                                        }
                                    Ce && ot.render(Y);
                                    for (let ht = 0, It = vt.length; ht < It; ht++) {
                                        const Vt = vt[ht];
                                        Js(N, Y, Vt, Vt.viewport)
                                    }
                                } else
                                    st.length > 0 && Rs(Ye, st, Y, ue),
                                    Ce && ot.render(Y),
                                    Js(N, Y, ue)
                            }
                            K !== null && G === 0 && (H.updateMultisampleRenderTarget(K),
                            H.updateRenderTargetMipmap(K)),
                            Se && I.end(V),
                            Y.isScene === !0 && Y.onAfterRender(V, Y, ue),
                            Qe.resetDefaultState(),
                            ee = -1,
                            te = null,
                            z.pop(),
                            z.length > 0 ? (D = z[z.length - 1],
                            Je === !0 && Xe.setGlobalState(V.clippingPlanes, D.state.camera)) : D = null,
                            U.pop(),
                            U.length > 0 ? N = U[U.length - 1] : N = null
                        }
                        ;
                        function Ks(Y, ue, _e, Se) {
                            if (Y.visible === !1)
                                return;
                            if (Y.layers.test(ue.layers)) {
                                if (Y.isGroup)
                                    _e = Y.renderOrder;
                                else if (Y.isLOD)
                                    Y.autoUpdate === !0 && Y.update(ue);
                                else if (Y.isLight)
                                    D.pushLight(Y),
                                    Y.castShadow && D.pushShadow(Y);
                                else if (Y.isSprite) {
                                    if (!Y.frustumCulled || Te.intersectsSprite(Y)) {
                                        Se && Ue.setFromMatrixPosition(Y.matrixWorld).applyMatrix4(Ct);
                                        const Ye = pt.update(Y)
                                          , st = Y.material;
                                        st.visible && N.push(Y, Ye, st, _e, Ue.z, null)
                                    }
                                } else if ((Y.isMesh || Y.isLine || Y.isPoints) && (!Y.frustumCulled || Te.intersectsObject(Y))) {
                                    const Ye = pt.update(Y)
                                      , st = Y.material;
                                    if (Se && (Y.boundingSphere !== void 0 ? (Y.boundingSphere === null && Y.computeBoundingSphere(),
                                    Ue.copy(Y.boundingSphere.center)) : (Ye.boundingSphere === null && Ye.computeBoundingSphere(),
                                    Ue.copy(Ye.boundingSphere.center)),
                                    Ue.applyMatrix4(Y.matrixWorld).applyMatrix4(Ct)),
                                    Array.isArray(st)) {
                                        const vt = Ye.groups;
                                        for (let ht = 0, It = vt.length; ht < It; ht++) {
                                            const Vt = vt[ht]
                                              , wt = st[Vt.materialIndex];
                                            wt && wt.visible && N.push(Y, Ye, wt, _e, Ue.z, Vt)
                                        }
                                    } else
                                        st.visible && N.push(Y, Ye, st, _e, Ue.z, null)
                                }
                            }
                            const me = Y.children;
                            for (let Ye = 0, st = me.length; Ye < st; Ye++)
                                Ks(me[Ye], ue, _e, Se)
                        }
                        function Js(Y, ue, _e, Se) {
                            const {opaque: me, transmissive: Ye, transparent: st} = Y;
                            D.setupLightsView(_e),
                            Je === !0 && Xe.setGlobalState(V.clippingPlanes, _e),
                            Se && ke.viewport(oe.copy(Se)),
                            me.length > 0 && Zt(me, ue, _e),
                            Ye.length > 0 && Zt(Ye, ue, _e),
                            st.length > 0 && Zt(st, ue, _e),
                            ke.buffers.depth.setTest(!0),
                            ke.buffers.depth.setMask(!0),
                            ke.buffers.color.setMask(!0),
                            ke.setPolygonOffset(!1)
                        }
                        function Rs(Y, ue, _e, Se) {
                            if ((_e.isScene === !0 ? _e.overrideMaterial : null) !== null)
                                return;
                            if (D.state.transmissionRenderTarget[Se.id] === void 0) {
                                const wt = Ve.has("EXT_color_buffer_half_float") || Ve.has("EXT_color_buffer_float");
                                D.state.transmissionRenderTarget[Se.id] = new sr(1,1,{
                                    generateMipmaps: !0,
                                    type: wt ? ol : da,
                                    minFilter: rl,
                                    samples: ft.samples,
                                    stencilBuffer: a,
                                    resolveDepthBuffer: !1,
                                    resolveStencilBuffer: !1,
                                    colorSpace: xn.workingColorSpace
                                })
                            }
                            const me = D.state.transmissionRenderTarget[Se.id]
                              , Ye = Se.viewport || oe;
                            me.setSize(Ye.z * V.transmissionResolutionScale, Ye.w * V.transmissionResolutionScale);
                            const st = V.getRenderTarget()
                              , vt = V.getActiveCubeFace()
                              , ht = V.getActiveMipmapLevel();
                            V.setRenderTarget(me),
                            V.getClearColor(X),
                            $ = V.getClearAlpha(),
                            $ < 1 && V.setClearColor(16777215, .5),
                            V.clear(),
                            Ce && ot.render(_e);
                            const It = V.toneMapping;
                            V.toneMapping = Lr;
                            const Vt = Se.viewport;
                            if (Se.viewport !== void 0 && (Se.viewport = void 0),
                            D.setupLightsView(Se),
                            Je === !0 && Xe.setGlobalState(V.clippingPlanes, Se),
                            Zt(Y, _e, Se),
                            H.updateMultisampleRenderTarget(me),
                            H.updateRenderTargetMipmap(me),
                            Ve.has("WEBGL_multisampled_render_to_texture") === !1) {
                                let wt = !1;
                                for (let tn = 0, rn = ue.length; tn < rn; tn++) {
                                    const {object: cn, geometry: $n, material: vn, group: At} = ue[tn];
                                    if (vn.side === il && cn.layers.test(Se.layers)) {
                                        const Hn = vn.side;
                                        vn.side = fa,
                                        vn.needsUpdate = !0,
                                        Oi(cn, _e, Se, $n, vn, At),
                                        vn.side = Hn,
                                        vn.needsUpdate = !0,
                                        wt = !0
                                    }
                                }
                                wt === !0 && (H.updateMultisampleRenderTarget(me),
                                H.updateRenderTargetMipmap(me))
                            }
                            V.setRenderTarget(st, vt, ht),
                            V.setClearColor(X, $),
                            Vt !== void 0 && (Se.viewport = Vt),
                            V.toneMapping = It
                        }
                        function Zt(Y, ue, _e) {
                            const Se = ue.isScene === !0 ? ue.overrideMaterial : null;
                            for (let me = 0, Ye = Y.length; me < Ye; me++) {
                                const st = Y[me]
                                  , {object: vt, geometry: ht, group: It} = st;
                                let Vt = st.material;
                                Vt.allowOverride === !0 && Se !== null && (Vt = Se),
                                vt.layers.test(_e.layers) && Oi(vt, ue, _e, ht, Vt, It)
                            }
                        }
                        function Oi(Y, ue, _e, Se, me, Ye) {
                            Y.onBeforeRender(V, ue, _e, Se, me, Ye),
                            Y.modelViewMatrix.multiplyMatrices(_e.matrixWorldInverse, Y.matrixWorld),
                            Y.normalMatrix.getNormalMatrix(Y.modelViewMatrix),
                            me.onBeforeRender(V, ue, _e, Se, Y, Ye),
                            me.transparent === !0 && me.side === il && me.forceSinglePass === !1 ? (me.side = fa,
                            me.needsUpdate = !0,
                            V.renderBufferDirect(_e, ue, Se, me, Y, Ye),
                            me.side = $l,
                            me.needsUpdate = !0,
                            V.renderBufferDirect(_e, ue, Se, me, Y, Ye),
                            me.side = il) : V.renderBufferDirect(_e, ue, Se, me, Y, Ye),
                            Y.onAfterRender(V, ue, _e, Se, me, Ye)
                        }
                        function Aa(Y, ue, _e) {
                            ue.isScene !== !0 && (ue = ve);
                            const Se = Z.get(Y)
                              , me = D.state.lights
                              , Ye = D.state.shadowsArray
                              , st = me.state.version
                              , vt = et.getParameters(Y, me.state, Ye, ue, _e)
                              , ht = et.getProgramCacheKey(vt);
                            let It = Se.programs;
                            Se.environment = Y.isMeshStandardMaterial ? ue.environment : null,
                            Se.fog = ue.fog,
                            Se.envMap = (Y.isMeshStandardMaterial ? Le : he).get(Y.envMap || Se.environment),
                            Se.envMapRotation = Se.environment !== null && Y.envMap === null ? ue.environmentRotation : Y.envMapRotation,
                            It === void 0 && (Y.addEventListener("dispose", pn),
                            It = new Map,
                            Se.programs = It);
                            let Vt = It.get(ht);
                            if (Vt !== void 0) {
                                if (Se.currentProgram === Vt && Se.lightsStateVersion === st)
                                    return Au(Y, vt),
                                    Vt
                            } else
                                vt.uniforms = et.getUniforms(Y),
                                Y.onBeforeCompile(vt, V),
                                Vt = et.acquireProgram(vt, ht),
                                It.set(ht, Vt),
                                Se.uniforms = vt.uniforms;
                            const wt = Se.uniforms;
                            return (!Y.isShaderMaterial && !Y.isRawShaderMaterial || Y.clipping === !0) && (wt.clippingPlanes = Xe.uniform),
                            Au(Y, vt),
                            Se.needsLights = Gr(Y),
                            Se.lightsStateVersion = st,
                            Se.needsLights && (wt.ambientLightColor.value = me.state.ambient,
                            wt.lightProbe.value = me.state.probe,
                            wt.directionalLights.value = me.state.directional,
                            wt.directionalLightShadows.value = me.state.directionalShadow,
                            wt.spotLights.value = me.state.spot,
                            wt.spotLightShadows.value = me.state.spotShadow,
                            wt.rectAreaLights.value = me.state.rectArea,
                            wt.ltc_1.value = me.state.rectAreaLTC1,
                            wt.ltc_2.value = me.state.rectAreaLTC2,
                            wt.pointLights.value = me.state.point,
                            wt.pointLightShadows.value = me.state.pointShadow,
                            wt.hemisphereLights.value = me.state.hemi,
                            wt.directionalShadowMap.value = me.state.directionalShadowMap,
                            wt.directionalShadowMatrix.value = me.state.directionalShadowMatrix,
                            wt.spotShadowMap.value = me.state.spotShadowMap,
                            wt.spotLightMatrix.value = me.state.spotLightMatrix,
                            wt.spotLightMap.value = me.state.spotLightMap,
                            wt.pointShadowMap.value = me.state.pointShadowMap,
                            wt.pointShadowMatrix.value = me.state.pointShadowMatrix),
                            Se.currentProgram = Vt,
                            Se.uniformsList = null,
                            Vt
                        }
                        function bl(Y) {
                            if (Y.uniformsList === null) {
                                const ue = Y.currentProgram.getUniforms();
                                Y.uniformsList = Fy.seqWithValue(ue.seq, Y.uniforms)
                            }
                            return Y.uniformsList
                        }
                        function Au(Y, ue) {
                            const _e = Z.get(Y);
                            _e.outputColorSpace = ue.outputColorSpace,
                            _e.batching = ue.batching,
                            _e.batchingColor = ue.batchingColor,
                            _e.instancing = ue.instancing,
                            _e.instancingColor = ue.instancingColor,
                            _e.instancingMorph = ue.instancingMorph,
                            _e.skinning = ue.skinning,
                            _e.morphTargets = ue.morphTargets,
                            _e.morphNormals = ue.morphNormals,
                            _e.morphColors = ue.morphColors,
                            _e.morphTargetsCount = ue.morphTargetsCount,
                            _e.numClippingPlanes = ue.numClippingPlanes,
                            _e.numIntersection = ue.numClipIntersection,
                            _e.vertexAlphas = ue.vertexAlphas,
                            _e.vertexTangents = ue.vertexTangents,
                            _e.toneMapping = ue.toneMapping
                        }
                        function Op(Y, ue, _e, Se, me) {
                            ue.isScene !== !0 && (ue = ve),
                            H.resetTextureUnits();
                            const Ye = ue.fog
                              , st = Se.isMeshStandardMaterial ? ue.environment : null
                              , vt = K === null ? V.outputColorSpace : K.isXRRenderTarget === !0 ? K.texture.colorSpace : tu
                              , ht = (Se.isMeshStandardMaterial ? Le : he).get(Se.envMap || st)
                              , It = Se.vertexColors === !0 && !!_e.attributes.color && _e.attributes.color.itemSize === 4
                              , Vt = !!_e.attributes.tangent && (!!Se.normalMap || Se.anisotropy > 0)
                              , wt = !!_e.morphAttributes.position
                              , tn = !!_e.morphAttributes.normal
                              , rn = !!_e.morphAttributes.color;
                            let cn = Lr;
                            Se.toneMapped && (K === null || K.isXRRenderTarget === !0) && (cn = V.toneMapping);
                            const $n = _e.morphAttributes.position || _e.morphAttributes.normal || _e.morphAttributes.color
                              , vn = $n !== void 0 ? $n.length : 0
                              , At = Z.get(Se)
                              , Hn = D.state.lights;
                            if (Je === !0 && (Ze === !0 || Y !== te)) {
                                const ei = Y === te && Se.id === ee;
                                Xe.setState(Se, Y, ei)
                            }
                            let un = !1;
                            Se.version === At.__version ? (At.needsLights && At.lightsStateVersion !== Hn.state.version || At.outputColorSpace !== vt || me.isBatchedMesh && At.batching === !1 || !me.isBatchedMesh && At.batching === !0 || me.isBatchedMesh && At.batchingColor === !0 && me.colorTexture === null || me.isBatchedMesh && At.batchingColor === !1 && me.colorTexture !== null || me.isInstancedMesh && At.instancing === !1 || !me.isInstancedMesh && At.instancing === !0 || me.isSkinnedMesh && At.skinning === !1 || !me.isSkinnedMesh && At.skinning === !0 || me.isInstancedMesh && At.instancingColor === !0 && me.instanceColor === null || me.isInstancedMesh && At.instancingColor === !1 && me.instanceColor !== null || me.isInstancedMesh && At.instancingMorph === !0 && me.morphTexture === null || me.isInstancedMesh && At.instancingMorph === !1 && me.morphTexture !== null || At.envMap !== ht || Se.fog === !0 && At.fog !== Ye || At.numClippingPlanes !== void 0 && (At.numClippingPlanes !== Xe.numPlanes || At.numIntersection !== Xe.numIntersection) || At.vertexAlphas !== It || At.vertexTangents !== Vt || At.morphTargets !== wt || At.morphNormals !== tn || At.morphColors !== rn || At.toneMapping !== cn || At.morphTargetsCount !== vn) && (un = !0) : (un = !0,
                            At.__version = Se.version);
                            let Ns = At.currentProgram;
                            un === !0 && (Ns = Aa(Se, ue, me));
                            let Ti = !1
                              , qi = !1
                              , kr = !1;
                            const wn = Ns.getUniforms()
                              , Si = At.uniforms;
                            if (ke.useProgram(Ns.program) && (Ti = !0,
                            qi = !0,
                            kr = !0),
                            Se.id !== ee && (ee = Se.id,
                            qi = !0),
                            Ti || te !== Y) {
                                ke.buffers.depth.getReversed() && Y.reversedDepth !== !0 && (Y._reversedDepth = !0,
                                Y.updateProjectionMatrix()),
                                wn.setValue(Q, "projectionMatrix", Y.projectionMatrix),
                                wn.setValue(Q, "viewMatrix", Y.matrixWorldInverse);
                                const ei = wn.map.cameraPosition;
                                ei !== void 0 && ei.setValue(Q, bt.setFromMatrixPosition(Y.matrixWorld)),
                                ft.logarithmicDepthBuffer && wn.setValue(Q, "logDepthBufFC", 2 / (Math.log(Y.far + 1) / Math.LN2)),
                                (Se.isMeshPhongMaterial || Se.isMeshToonMaterial || Se.isMeshLambertMaterial || Se.isMeshBasicMaterial || Se.isMeshStandardMaterial || Se.isShaderMaterial) && wn.setValue(Q, "isOrthographic", Y.isOrthographicCamera === !0),
                                te !== Y && (te = Y,
                                qi = !0,
                                kr = !0)
                            }
                            if (At.needsLights && (Hn.state.directionalShadowMap.length > 0 && wn.setValue(Q, "directionalShadowMap", Hn.state.directionalShadowMap, H),
                            Hn.state.spotShadowMap.length > 0 && wn.setValue(Q, "spotShadowMap", Hn.state.spotShadowMap, H),
                            Hn.state.pointShadowMap.length > 0 && wn.setValue(Q, "pointShadowMap", Hn.state.pointShadowMap, H)),
                            me.isSkinnedMesh) {
                                wn.setOptional(Q, me, "bindMatrix"),
                                wn.setOptional(Q, me, "bindMatrixInverse");
                                const ei = me.skeleton;
                                ei && (ei.boneTexture === null && ei.computeBoneTexture(),
                                wn.setValue(Q, "boneTexture", ei.boneTexture, H))
                            }
                            me.isBatchedMesh && (wn.setOptional(Q, me, "batchingTexture"),
                            wn.setValue(Q, "batchingTexture", me._matricesTexture, H),
                            wn.setOptional(Q, me, "batchingIdTexture"),
                            wn.setValue(Q, "batchingIdTexture", me._indirectTexture, H),
                            wn.setOptional(Q, me, "batchingColorTexture"),
                            me._colorsTexture !== null && wn.setValue(Q, "batchingColorTexture", me._colorsTexture, H));
                            const us = _e.morphAttributes;
                            if ((us.position !== void 0 || us.normal !== void 0 || us.color !== void 0) && tt.update(me, _e, Ns),
                            (qi || At.receiveShadow !== me.receiveShadow) && (At.receiveShadow = me.receiveShadow,
                            wn.setValue(Q, "receiveShadow", me.receiveShadow)),
                            Se.isMeshGouraudMaterial && Se.envMap !== null && (Si.envMap.value = ht,
                            Si.flipEnvMap.value = ht.isCubeTexture && ht.isRenderTargetTexture === !1 ? -1 : 1),
                            Se.isMeshStandardMaterial && Se.envMap === null && ue.environment !== null && (Si.envMapIntensity.value = ue.environmentIntensity),
                            Si.dfgLUT !== void 0 && (Si.dfgLUT.value = KI()),
                            qi && (wn.setValue(Q, "toneMappingExposure", V.toneMappingExposure),
                            At.needsLights && _c(Si, kr),
                            Ye && Se.fog === !0 && xt.refreshFogUniforms(Si, Ye),
                            xt.refreshMaterialUniforms(Si, Se, k, ce, D.state.transmissionRenderTarget[Y.id]),
                            Fy.upload(Q, bl(At), Si, H)),
                            Se.isShaderMaterial && Se.uniformsNeedUpdate === !0 && (Fy.upload(Q, bl(At), Si, H),
                            Se.uniformsNeedUpdate = !1),
                            Se.isSpriteMaterial && wn.setValue(Q, "center", me.center),
                            wn.setValue(Q, "modelViewMatrix", me.modelViewMatrix),
                            wn.setValue(Q, "normalMatrix", me.normalMatrix),
                            wn.setValue(Q, "modelMatrix", me.matrixWorld),
                            Se.isShaderMaterial || Se.isRawShaderMaterial) {
                                const ei = Se.uniformsGroups;
                                for (let Ui = 0, wo = ei.length; Ui < wo; Ui++) {
                                    const $s = ei[Ui];
                                    dt.update($s, Ns),
                                    dt.bind($s, Ns)
                                }
                            }
                            return Ns
                        }
                        function _c(Y, ue) {
                            Y.ambientLightColor.needsUpdate = ue,
                            Y.lightProbe.needsUpdate = ue,
                            Y.directionalLights.needsUpdate = ue,
                            Y.directionalLightShadows.needsUpdate = ue,
                            Y.pointLights.needsUpdate = ue,
                            Y.pointLightShadows.needsUpdate = ue,
                            Y.spotLights.needsUpdate = ue,
                            Y.spotLightShadows.needsUpdate = ue,
                            Y.rectAreaLights.needsUpdate = ue,
                            Y.hemisphereLights.needsUpdate = ue
                        }
                        function Gr(Y) {
                            return Y.isMeshLambertMaterial || Y.isMeshToonMaterial || Y.isMeshPhongMaterial || Y.isMeshStandardMaterial || Y.isShadowMaterial || Y.isShaderMaterial && Y.lights === !0
                        }
                        this.getActiveCubeFace = function() {
                            return P
                        }
                        ,
                        this.getActiveMipmapLevel = function() {
                            return G
                        }
                        ,
                        this.getRenderTarget = function() {
                            return K
                        }
                        ,
                        this.setRenderTargetTextures = function(Y, ue, _e) {
                            const Se = Z.get(Y);
                            Se.__autoAllocateDepthBuffer = Y.resolveDepthBuffer === !1,
                            Se.__autoAllocateDepthBuffer === !1 && (Se.__useRenderToTexture = !1),
                            Z.get(Y.texture).__webglTexture = ue,
                            Z.get(Y.depthTexture).__webglTexture = Se.__autoAllocateDepthBuffer ? void 0 : _e,
                            Se.__hasExternalTextures = !0
                        }
                        ,
                        this.setRenderTargetFramebuffer = function(Y, ue) {
                            const _e = Z.get(Y);
                            _e.__webglFramebuffer = ue,
                            _e.__useDefaultFramebuffer = ue === void 0
                        }
                        ;
                        const Tl = Q.createFramebuffer();
                        this.setRenderTarget = function(Y, ue=0, _e=0) {
                            K = Y,
                            P = ue,
                            G = _e;
                            let Se = null
                              , me = !1
                              , Ye = !1;
                            if (Y) {
                                const st = Z.get(Y);
                                if (st.__useDefaultFramebuffer !== void 0) {
                                    ke.bindFramebuffer(Q.FRAMEBUFFER, st.__webglFramebuffer),
                                    oe.copy(Y.viewport),
                                    q.copy(Y.scissor),
                                    F = Y.scissorTest,
                                    ke.viewport(oe),
                                    ke.scissor(q),
                                    ke.setScissorTest(F),
                                    ee = -1;
                                    return
                                } else if (st.__webglFramebuffer === void 0)
                                    H.setupRenderTarget(Y);
                                else if (st.__hasExternalTextures)
                                    H.rebindTextures(Y, Z.get(Y.texture).__webglTexture, Z.get(Y.depthTexture).__webglTexture);
                                else if (Y.depthBuffer) {
                                    const It = Y.depthTexture;
                                    if (st.__boundDepthTexture !== It) {
                                        if (It !== null && Z.has(It) && (Y.width !== It.image.width || Y.height !== It.image.height))
                                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                        H.setupDepthRenderbuffer(Y)
                                    }
                                }
                                const vt = Y.texture;
                                (vt.isData3DTexture || vt.isDataArrayTexture || vt.isCompressedArrayTexture) && (Ye = !0);
                                const ht = Z.get(Y).__webglFramebuffer;
                                Y.isWebGLCubeRenderTarget ? (Array.isArray(ht[ue]) ? Se = ht[ue][_e] : Se = ht[ue],
                                me = !0) : Y.samples > 0 && H.useMultisampledRTT(Y) === !1 ? Se = Z.get(Y).__webglMultisampledFramebuffer : Array.isArray(ht) ? Se = ht[_e] : Se = ht,
                                oe.copy(Y.viewport),
                                q.copy(Y.scissor),
                                F = Y.scissorTest
                            } else
                                oe.copy(ie).multiplyScalar(k).floor(),
                                q.copy(Me).multiplyScalar(k).floor(),
                                F = we;
                            if (_e !== 0 && (Se = Tl),
                            ke.bindFramebuffer(Q.FRAMEBUFFER, Se) && ke.drawBuffers(Y, Se),
                            ke.viewport(oe),
                            ke.scissor(q),
                            ke.setScissorTest(F),
                            me) {
                                const st = Z.get(Y.texture);
                                Q.framebufferTexture2D(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Q.TEXTURE_CUBE_MAP_POSITIVE_X + ue, st.__webglTexture, _e)
                            } else if (Ye) {
                                const st = ue;
                                for (let vt = 0; vt < Y.textures.length; vt++) {
                                    const ht = Z.get(Y.textures[vt]);
                                    Q.framebufferTextureLayer(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0 + vt, ht.__webglTexture, _e, st)
                                }
                            } else if (Y !== null && _e !== 0) {
                                const st = Z.get(Y.texture);
                                Q.framebufferTexture2D(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Q.TEXTURE_2D, st.__webglTexture, _e)
                            }
                            ee = -1
                        }
                        ,
                        this.readRenderTargetPixels = function(Y, ue, _e, Se, me, Ye, st, vt=0) {
                            if (!(Y && Y.isWebGLRenderTarget)) {
                                Rt("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                return
                            }
                            let ht = Z.get(Y).__webglFramebuffer;
                            if (Y.isWebGLCubeRenderTarget && st !== void 0 && (ht = ht[st]),
                            ht) {
                                ke.bindFramebuffer(Q.FRAMEBUFFER, ht);
                                try {
                                    const It = Y.textures[vt]
                                      , Vt = It.format
                                      , wt = It.type;
                                    if (!ft.textureFormatReadable(Vt)) {
                                        Rt("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                        return
                                    }
                                    if (!ft.textureTypeReadable(wt)) {
                                        Rt("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        return
                                    }
                                    ue >= 0 && ue <= Y.width - Se && _e >= 0 && _e <= Y.height - me && (Y.textures.length > 1 && Q.readBuffer(Q.COLOR_ATTACHMENT0 + vt),
                                    Q.readPixels(ue, _e, Se, me, it.convert(Vt), it.convert(wt), Ye))
                                } finally {
                                    const It = K !== null ? Z.get(K).__webglFramebuffer : null;
                                    ke.bindFramebuffer(Q.FRAMEBUFFER, It)
                                }
                            }
                        }
                        ,
                        this.readRenderTargetPixelsAsync = async function(Y, ue, _e, Se, me, Ye, st, vt=0) {
                            if (!(Y && Y.isWebGLRenderTarget))
                                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                            let ht = Z.get(Y).__webglFramebuffer;
                            if (Y.isWebGLCubeRenderTarget && st !== void 0 && (ht = ht[st]),
                            ht)
                                if (ue >= 0 && ue <= Y.width - Se && _e >= 0 && _e <= Y.height - me) {
                                    ke.bindFramebuffer(Q.FRAMEBUFFER, ht);
                                    const It = Y.textures[vt]
                                      , Vt = It.format
                                      , wt = It.type;
                                    if (!ft.textureFormatReadable(Vt))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                    if (!ft.textureTypeReadable(wt))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                    const tn = Q.createBuffer();
                                    Q.bindBuffer(Q.PIXEL_PACK_BUFFER, tn),
                                    Q.bufferData(Q.PIXEL_PACK_BUFFER, Ye.byteLength, Q.STREAM_READ),
                                    Y.textures.length > 1 && Q.readBuffer(Q.COLOR_ATTACHMENT0 + vt),
                                    Q.readPixels(ue, _e, Se, me, it.convert(Vt), it.convert(wt), 0);
                                    const rn = K !== null ? Z.get(K).__webglFramebuffer : null;
                                    ke.bindFramebuffer(Q.FRAMEBUFFER, rn);
                                    const cn = Q.fenceSync(Q.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                    return Q.flush(),
                                    await ID(Q, cn, 4),
                                    Q.bindBuffer(Q.PIXEL_PACK_BUFFER, tn),
                                    Q.getBufferSubData(Q.PIXEL_PACK_BUFFER, 0, Ye),
                                    Q.deleteBuffer(tn),
                                    Q.deleteSync(cn),
                                    Ye
                                } else
                                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                        ,
                        this.copyFramebufferToTexture = function(Y, ue=null, _e=0) {
                            const Se = Math.pow(2, -_e)
                              , me = Math.floor(Y.image.width * Se)
                              , Ye = Math.floor(Y.image.height * Se)
                              , st = ue !== null ? ue.x : 0
                              , vt = ue !== null ? ue.y : 0;
                            H.setTexture2D(Y, 0),
                            Q.copyTexSubImage2D(Q.TEXTURE_2D, _e, 0, 0, st, vt, me, Ye),
                            ke.unbindTexture()
                        }
                        ;
                        const yi = Q.createFramebuffer()
                          , Fn = Q.createFramebuffer();
                        this.copyTextureToTexture = function(Y, ue, _e=null, Se=null, me=0, Ye=null) {
                            Ye === null && (me !== 0 ? (wd("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                            Ye = me,
                            me = 0) : Ye = 0);
                            let st, vt, ht, It, Vt, wt, tn, rn, cn;
                            const $n = Y.isCompressedTexture ? Y.mipmaps[Ye] : Y.image;
                            if (_e !== null)
                                st = _e.max.x - _e.min.x,
                                vt = _e.max.y - _e.min.y,
                                ht = _e.isBox3 ? _e.max.z - _e.min.z : 1,
                                It = _e.min.x,
                                Vt = _e.min.y,
                                wt = _e.isBox3 ? _e.min.z : 0;
                            else {
                                const us = Math.pow(2, -me);
                                st = Math.floor($n.width * us),
                                vt = Math.floor($n.height * us),
                                Y.isDataArrayTexture ? ht = $n.depth : Y.isData3DTexture ? ht = Math.floor($n.depth * us) : ht = 1,
                                It = 0,
                                Vt = 0,
                                wt = 0
                            }
                            Se !== null ? (tn = Se.x,
                            rn = Se.y,
                            cn = Se.z) : (tn = 0,
                            rn = 0,
                            cn = 0);
                            const vn = it.convert(ue.format)
                              , At = it.convert(ue.type);
                            let Hn;
                            ue.isData3DTexture ? (H.setTexture3D(ue, 0),
                            Hn = Q.TEXTURE_3D) : ue.isDataArrayTexture || ue.isCompressedArrayTexture ? (H.setTexture2DArray(ue, 0),
                            Hn = Q.TEXTURE_2D_ARRAY) : (H.setTexture2D(ue, 0),
                            Hn = Q.TEXTURE_2D),
                            Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL, ue.flipY),
                            Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ue.premultiplyAlpha),
                            Q.pixelStorei(Q.UNPACK_ALIGNMENT, ue.unpackAlignment);
                            const un = Q.getParameter(Q.UNPACK_ROW_LENGTH)
                              , Ns = Q.getParameter(Q.UNPACK_IMAGE_HEIGHT)
                              , Ti = Q.getParameter(Q.UNPACK_SKIP_PIXELS)
                              , qi = Q.getParameter(Q.UNPACK_SKIP_ROWS)
                              , kr = Q.getParameter(Q.UNPACK_SKIP_IMAGES);
                            Q.pixelStorei(Q.UNPACK_ROW_LENGTH, $n.width),
                            Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT, $n.height),
                            Q.pixelStorei(Q.UNPACK_SKIP_PIXELS, It),
                            Q.pixelStorei(Q.UNPACK_SKIP_ROWS, Vt),
                            Q.pixelStorei(Q.UNPACK_SKIP_IMAGES, wt);
                            const wn = Y.isDataArrayTexture || Y.isData3DTexture
                              , Si = ue.isDataArrayTexture || ue.isData3DTexture;
                            if (Y.isDepthTexture) {
                                const us = Z.get(Y)
                                  , ei = Z.get(ue)
                                  , Ui = Z.get(us.__renderTarget)
                                  , wo = Z.get(ei.__renderTarget);
                                ke.bindFramebuffer(Q.READ_FRAMEBUFFER, Ui.__webglFramebuffer),
                                ke.bindFramebuffer(Q.DRAW_FRAMEBUFFER, wo.__webglFramebuffer);
                                for (let $s = 0; $s < ht; $s++)
                                    wn && (Q.framebufferTextureLayer(Q.READ_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Z.get(Y).__webglTexture, me, wt + $s),
                                    Q.framebufferTextureLayer(Q.DRAW_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Z.get(ue).__webglTexture, Ye, cn + $s)),
                                    Q.blitFramebuffer(It, Vt, st, vt, tn, rn, st, vt, Q.DEPTH_BUFFER_BIT, Q.NEAREST);
                                ke.bindFramebuffer(Q.READ_FRAMEBUFFER, null),
                                ke.bindFramebuffer(Q.DRAW_FRAMEBUFFER, null)
                            } else if (me !== 0 || Y.isRenderTargetTexture || Z.has(Y)) {
                                const us = Z.get(Y)
                                  , ei = Z.get(ue);
                                ke.bindFramebuffer(Q.READ_FRAMEBUFFER, yi),
                                ke.bindFramebuffer(Q.DRAW_FRAMEBUFFER, Fn);
                                for (let Ui = 0; Ui < ht; Ui++)
                                    wn ? Q.framebufferTextureLayer(Q.READ_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, us.__webglTexture, me, wt + Ui) : Q.framebufferTexture2D(Q.READ_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Q.TEXTURE_2D, us.__webglTexture, me),
                                    Si ? Q.framebufferTextureLayer(Q.DRAW_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, ei.__webglTexture, Ye, cn + Ui) : Q.framebufferTexture2D(Q.DRAW_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Q.TEXTURE_2D, ei.__webglTexture, Ye),
                                    me !== 0 ? Q.blitFramebuffer(It, Vt, st, vt, tn, rn, st, vt, Q.COLOR_BUFFER_BIT, Q.NEAREST) : Si ? Q.copyTexSubImage3D(Hn, Ye, tn, rn, cn + Ui, It, Vt, st, vt) : Q.copyTexSubImage2D(Hn, Ye, tn, rn, It, Vt, st, vt);
                                ke.bindFramebuffer(Q.READ_FRAMEBUFFER, null),
                                ke.bindFramebuffer(Q.DRAW_FRAMEBUFFER, null)
                            } else
                                Si ? Y.isDataTexture || Y.isData3DTexture ? Q.texSubImage3D(Hn, Ye, tn, rn, cn, st, vt, ht, vn, At, $n.data) : ue.isCompressedArrayTexture ? Q.compressedTexSubImage3D(Hn, Ye, tn, rn, cn, st, vt, ht, vn, $n.data) : Q.texSubImage3D(Hn, Ye, tn, rn, cn, st, vt, ht, vn, At, $n) : Y.isDataTexture ? Q.texSubImage2D(Q.TEXTURE_2D, Ye, tn, rn, st, vt, vn, At, $n.data) : Y.isCompressedTexture ? Q.compressedTexSubImage2D(Q.TEXTURE_2D, Ye, tn, rn, $n.width, $n.height, vn, $n.data) : Q.texSubImage2D(Q.TEXTURE_2D, Ye, tn, rn, st, vt, vn, At, $n);
                            Q.pixelStorei(Q.UNPACK_ROW_LENGTH, un),
                            Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT, Ns),
                            Q.pixelStorei(Q.UNPACK_SKIP_PIXELS, Ti),
                            Q.pixelStorei(Q.UNPACK_SKIP_ROWS, qi),
                            Q.pixelStorei(Q.UNPACK_SKIP_IMAGES, kr),
                            Ye === 0 && ue.generateMipmaps && Q.generateMipmap(Hn),
                            ke.unbindTexture()
                        }
                        ,
                        this.initRenderTarget = function(Y) {
                            Z.get(Y).__webglFramebuffer === void 0 && H.setupRenderTarget(Y)
                        }
                        ,
                        this.initTexture = function(Y) {
                            Y.isCubeTexture ? H.setTextureCube(Y, 0) : Y.isData3DTexture ? H.setTexture3D(Y, 0) : Y.isDataArrayTexture || Y.isCompressedArrayTexture ? H.setTexture2DArray(Y, 0) : H.setTexture2D(Y, 0),
                            ke.unbindTexture()
                        }
                        ,
                        this.resetState = function() {
                            P = 0,
                            G = 0,
                            K = null,
                            ke.reset(),
                            Qe.reset()
                        }
                        ,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    get coordinateSystem() {
                        return nr
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(t) {
                        this._outputColorSpace = t;
                        const e = this.getContext();
                        e.drawingBufferColorSpace = xn._getDrawingBufferColorSpace(t),
                        e.unpackColorSpace = xn._getUnpackColorSpace()
                    }
                }
                ;
                var JI = ln((t => {
                    var e = Sd();
                    function n(y, S) {
                        return y === S && (y !== 0 || 1 / y === 1 / S) || y !== y && S !== S
                    }
                    var i = typeof Object.is == "function" ? Object.is : n
                      , a = e.useState
                      , o = e.useEffect
                      , u = e.useLayoutEffect
                      , f = e.useDebugValue;
                    function d(y, S) {
                        var E = S()
                          , w = a({
                            inst: {
                                value: E,
                                getSnapshot: S
                            }
                        })
                          , A = w[0].inst
                          , T = w[1];
                        return u(function() {
                            A.value = E,
                            A.getSnapshot = S,
                            p(A) && T({
                                inst: A
                            })
                        }, [y, E, S]),
                        o(function() {
                            return p(A) && T({
                                inst: A
                            }),
                            y(function() {
                                p(A) && T({
                                    inst: A
                                })
                            })
                        }, [y]),
                        f(E),
                        E
                    }
                    function p(y) {
                        var S = y.getSnapshot;
                        y = y.value;
                        try {
                            var E = S();
                            return !i(y, E)
                        } catch {
                            return !0
                        }
                    }
                    function g(y, S) {
                        return S()
                    }
                    var v = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? g : d;
                    t.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v
                }
                ))
                  , $I = ln(( (t, e) => {
                    e.exports = JI()
                }
                ));
                var ez = ln((t => {
                    var e = Sd()
                      , n = $I();
                    function i(g, v) {
                        return g === v && (g !== 0 || 1 / g === 1 / v) || g !== g && v !== v
                    }
                    var a = typeof Object.is == "function" ? Object.is : i
                      , o = n.useSyncExternalStore
                      , u = e.useRef
                      , f = e.useEffect
                      , d = e.useMemo
                      , p = e.useDebugValue;
                    t.useSyncExternalStoreWithSelector = function(g, v, y, S, E) {
                        var w = u(null);
                        if (w.current === null) {
                            var A = {
                                hasValue: !1,
                                value: null
                            };
                            w.current = A
                        } else
                            A = w.current;
                        w = d(function() {
                            function R(I) {
                                if (!N) {
                                    if (N = !0,
                                    D = I,
                                    I = S(I),
                                    E !== void 0 && A.hasValue) {
                                        var V = A.value;
                                        if (E(V, I))
                                            return U = V
                                    }
                                    return U = I
                                }
                                if (V = U,
                                a(D, I))
                                    return V;
                                var B = S(I);
                                return E !== void 0 && E(V, B) ? (D = I,
                                V) : (D = I,
                                U = B)
                            }
                            var N = !1, D, U, z = y === void 0 ? null : y;
                            return [function() {
                                return R(v())
                            }
                            , z === null ? void 0 : function() {
                                return R(z())
                            }
                            ]
                        }, [v, y, S, E]);
                        var T = o(g, w[0], w[1]);
                        return f(function() {
                            A.hasValue = !0,
                            A.value = T
                        }, [T]),
                        p(T),
                        T
                    }
                }
                ))
                  , tz = ln(( (t, e) => {
                    e.exports = ez()
                }
                ))
                  , nz = tg(tz(), 1);
                const WC = t => {
                    let e;
                    const n = new Set
                      , i = (p, g) => {
                        const v = typeof p == "function" ? p(e) : p;
                        if (!Object.is(v, e)) {
                            const y = e;
                            e = g ?? (typeof v != "object" || v === null) ? v : Object.assign({}, e, v),
                            n.forEach(S => S(e, y))
                        }
                    }
                      , a = () => e
                      , f = {
                        setState: i,
                        getState: a,
                        getInitialState: () => d,
                        subscribe: p => (n.add(p),
                        () => n.delete(p))
                    }
                      , d = e = t(i, a, f);
                    return f
                }
                  , iz = (t => t ? WC(t) : WC)
                  , {useSyncExternalStoreWithSelector: sz} = nz.default
                  , az = t => t;
                function rz(t, e=az, n) {
                    const i = sz(t.subscribe, t.getState, t.getInitialState, e, n);
                    return gt.useDebugValue(i),
                    i
                }
                const YC = (t, e) => {
                    const n = iz(t)
                      , i = (a, o=e) => rz(n, a, o);
                    return Object.assign(i, n),
                    i
                }
                  , oz = ( (t, e) => t ? YC(t, e) : YC)
                  , lz = t => typeof t == "object" && typeof t.then == "function"
                  , Wh = [];
                function jC(t, e, n= (i, a) => i === a) {
                    if (t === e)
                        return !0;
                    if (!t || !e)
                        return !1;
                    const i = t.length;
                    if (e.length !== i)
                        return !1;
                    for (let a = 0; a < i; a++)
                        if (!n(t[a], e[a]))
                            return !1;
                    return !0
                }
                function ZC(t, e=null, n=!1, i={}) {
                    e === null && (e = [t]);
                    for (const o of Wh)
                        if (jC(e, o.keys, o.equal)) {
                            if (n)
                                return;
                            if (Object.prototype.hasOwnProperty.call(o, "error"))
                                throw o.error;
                            if (Object.prototype.hasOwnProperty.call(o, "response"))
                                return i.lifespan && i.lifespan > 0 && (o.timeout && clearTimeout(o.timeout),
                                o.timeout = setTimeout(o.remove, i.lifespan)),
                                o.response;
                            if (!n)
                                throw o.promise
                        }
                    const a = {
                        keys: e,
                        equal: i.equal,
                        remove: () => {
                            const o = Wh.indexOf(a);
                            o !== -1 && Wh.splice(o, 1)
                        }
                        ,
                        promise: (lz(t) ? t : t(...e)).then(o => {
                            a.response = o,
                            i.lifespan && i.lifespan > 0 && (a.timeout = setTimeout(a.remove, i.lifespan))
                        }
                        ).catch(o => a.error = o)
                    };
                    if (Wh.push(a),
                    !n)
                        throw a.promise
                }
                const cz = (t, e, n) => ZC(t, e, !1, n)
                  , uz = (t, e, n) => {
                    ZC(t, e, !0, n)
                }
                  , hz = t => {
                    if (t === void 0 || t.length === 0)
                        Wh.splice(0, Wh.length);
                    else {
                        const e = Wh.find(n => jC(t, n.keys, n.equal));
                        e && e.remove()
                    }
                }
                ;
                var fz = ln((t => {
                    function e(q, F) {
                        var X = q.length;
                        q.push(F);
                        e: for (; 0 < X; ) {
                            var $ = X - 1 >>> 1
                              , ne = q[$];
                            if (0 < a(ne, F))
                                q[$] = F,
                                q[X] = ne,
                                X = $;
                            else
                                break e
                        }
                    }
                    function n(q) {
                        return q.length === 0 ? null : q[0]
                    }
                    function i(q) {
                        if (q.length === 0)
                            return null;
                        var F = q[0]
                          , X = q.pop();
                        if (X !== F) {
                            q[0] = X;
                            e: for (var $ = 0, ne = q.length, ce = ne >>> 1; $ < ce; ) {
                                var k = 2 * ($ + 1) - 1
                                  , pe = q[k]
                                  , Ae = k + 1
                                  , ie = q[Ae];
                                if (0 > a(pe, X))
                                    Ae < ne && 0 > a(ie, pe) ? (q[$] = ie,
                                    q[Ae] = X,
                                    $ = Ae) : (q[$] = pe,
                                    q[k] = X,
                                    $ = k);
                                else if (Ae < ne && 0 > a(ie, X))
                                    q[$] = ie,
                                    q[Ae] = X,
                                    $ = Ae;
                                else
                                    break e
                            }
                        }
                        return F
                    }
                    function a(q, F) {
                        var X = q.sortIndex - F.sortIndex;
                        return X !== 0 ? X : q.id - F.id
                    }
                    if (t.unstable_now = void 0,
                    typeof performance == "object" && typeof performance.now == "function") {
                        var o = performance;
                        t.unstable_now = function() {
                            return o.now()
                        }
                    } else {
                        var u = Date
                          , f = u.now();
                        t.unstable_now = function() {
                            return u.now() - f
                        }
                    }
                    var d = []
                      , p = []
                      , g = 1
                      , v = null
                      , y = 3
                      , S = !1
                      , E = !1
                      , w = !1
                      , A = typeof setTimeout == "function" ? setTimeout : null
                      , T = typeof clearTimeout == "function" ? clearTimeout : null
                      , R = typeof setImmediate < "u" ? setImmediate : null;
                    function N(q) {
                        for (var F = n(p); F !== null; ) {
                            if (F.callback === null)
                                i(p);
                            else if (F.startTime <= q)
                                i(p),
                                F.sortIndex = F.expirationTime,
                                e(d, F);
                            else
                                break;
                            F = n(p)
                        }
                    }
                    function D(q) {
                        if (w = !1,
                        N(q),
                        !E)
                            if (n(d) !== null)
                                E = !0,
                                te();
                            else {
                                var F = n(p);
                                F !== null && oe(D, F.startTime - q)
                            }
                    }
                    var U = !1
                      , z = -1
                      , I = 5
                      , V = -1;
                    function B() {
                        return !(t.unstable_now() - V < I)
                    }
                    function P() {
                        if (U) {
                            var q = t.unstable_now();
                            V = q;
                            var F = !0;
                            try {
                                e: {
                                    E = !1,
                                    w && (w = !1,
                                    T(z),
                                    z = -1),
                                    S = !0;
                                    var X = y;
                                    try {
                                        t: {
                                            for (N(q),
                                            v = n(d); v !== null && !(v.expirationTime > q && B()); ) {
                                                var $ = v.callback;
                                                if (typeof $ == "function") {
                                                    v.callback = null,
                                                    y = v.priorityLevel;
                                                    var ne = $(v.expirationTime <= q);
                                                    if (q = t.unstable_now(),
                                                    typeof ne == "function") {
                                                        v.callback = ne,
                                                        N(q),
                                                        F = !0;
                                                        break t
                                                    }
                                                    v === n(d) && i(d),
                                                    N(q)
                                                } else
                                                    i(d);
                                                v = n(d)
                                            }
                                            if (v !== null)
                                                F = !0;
                                            else {
                                                var ce = n(p);
                                                ce !== null && oe(D, ce.startTime - q),
                                                F = !1
                                            }
                                        }
                                        break e
                                    } finally {
                                        v = null,
                                        y = X,
                                        S = !1
                                    }
                                    F = void 0
                                }
                            } finally {
                                F ? G() : U = !1
                            }
                        }
                    }
                    var G;
                    if (typeof R == "function")
                        G = function() {
                            R(P)
                        }
                        ;
                    else if (typeof MessageChannel < "u") {
                        var K = new MessageChannel
                          , ee = K.port2;
                        K.port1.onmessage = P,
                        G = function() {
                            ee.postMessage(null)
                        }
                    } else
                        G = function() {
                            A(P, 0)
                        }
                        ;
                    function te() {
                        U || (U = !0,
                        G())
                    }
                    function oe(q, F) {
                        z = A(function() {
                            q(t.unstable_now())
                        }, F)
                    }
                    t.unstable_IdlePriority = 5,
                    t.unstable_ImmediatePriority = 1,
                    t.unstable_LowPriority = 4,
                    t.unstable_NormalPriority = 3,
                    t.unstable_Profiling = null,
                    t.unstable_UserBlockingPriority = 2,
                    t.unstable_cancelCallback = function(q) {
                        q.callback = null
                    }
                    ,
                    t.unstable_continueExecution = function() {
                        E || S || (E = !0,
                        te())
                    }
                    ,
                    t.unstable_forceFrameRate = function(q) {
                        0 > q || 125 < q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < q ? Math.floor(1e3 / q) : 5
                    }
                    ,
                    t.unstable_getCurrentPriorityLevel = function() {
                        return y
                    }
                    ,
                    t.unstable_getFirstCallbackNode = function() {
                        return n(d)
                    }
                    ,
                    t.unstable_next = function(q) {
                        switch (y) {
                        case 1:
                        case 2:
                        case 3:
                            var F = 3;
                            break;
                        default:
                            F = y
                        }
                        var X = y;
                        y = F;
                        try {
                            return q()
                        } finally {
                            y = X
                        }
                    }
                    ,
                    t.unstable_pauseExecution = function() {}
                    ,
                    t.unstable_requestPaint = function() {}
                    ,
                    t.unstable_runWithPriority = function(q, F) {
                        switch (q) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            q = 3
                        }
                        var X = y;
                        y = q;
                        try {
                            return F()
                        } finally {
                            y = X
                        }
                    }
                    ,
                    t.unstable_scheduleCallback = function(q, F, X) {
                        var $ = t.unstable_now();
                        switch (typeof X == "object" && X !== null ? (X = X.delay,
                        X = typeof X == "number" && 0 < X ? $ + X : $) : X = $,
                        q) {
                        case 1:
                            var ne = -1;
                            break;
                        case 2:
                            ne = 250;
                            break;
                        case 5:
                            ne = 1073741823;
                            break;
                        case 4:
                            ne = 1e4;
                            break;
                        default:
                            ne = 5e3
                        }
                        return ne = X + ne,
                        q = {
                            id: g++,
                            callback: F,
                            priorityLevel: q,
                            startTime: X,
                            expirationTime: ne,
                            sortIndex: -1
                        },
                        X > $ ? (q.sortIndex = X,
                        e(p, q),
                        n(d) === null && q === n(p) && (w ? (T(z),
                        z = -1) : w = !0,
                        oe(D, X - $))) : (q.sortIndex = ne,
                        e(d, q),
                        E || S || (E = !0,
                        te())),
                        q
                    }
                    ,
                    t.unstable_shouldYield = B,
                    t.unstable_wrapCallback = function(q) {
                        var F = y;
                        return function() {
                            var X = y;
                            y = F;
                            try {
                                return q.apply(this, arguments)
                            } finally {
                                y = X
                            }
                        }
                    }
                }
                ))
                  , hb = ln(( (t, e) => {
                    e.exports = fz()
                }
                ));
                var dz = ln(( (t, e) => {
                    e.exports = function(n) {
                        function i(l, c, _, M) {
                            return new Uf(l,c,_,M)
                        }
                        function a() {}
                        function o(l) {
                            var c = "https://react.dev/errors/" + l;
                            if (1 < arguments.length) {
                                c += "?args[]=" + encodeURIComponent(arguments[1]);
                                for (var _ = 2; _ < arguments.length; _++)
                                    c += "&args[]=" + encodeURIComponent(arguments[_])
                            }
                            return "Minified React error #" + l + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                        }
                        function u(l) {
                            return l === null || typeof l != "object" ? null : (l = qo && l[qo] || l["@@iterator"],
                            typeof l == "function" ? l : null)
                        }
                        function f(l) {
                            if (l == null)
                                return null;
                            if (typeof l == "function")
                                return l.$$typeof === Vv ? null : l.displayName || l.name || null;
                            if (typeof l == "string")
                                return l;
                            switch (l) {
                            case Jr:
                                return "Fragment";
                            case Kr:
                                return "Portal";
                            case Vf:
                                return "Profiler";
                            case um:
                                return "StrictMode";
                            case ko:
                                return "Suspense";
                            case Fl:
                                return "SuspenseList"
                            }
                            if (typeof l == "object")
                                switch (l.$$typeof) {
                                case $r:
                                    return (l.displayName || "Context") + ".Provider";
                                case Go:
                                    return (l._context.displayName || "Context") + ".Consumer";
                                case Ff:
                                    var c = l.render;
                                    return l = l.displayName,
                                    l || (l = c.displayName || c.name || "",
                                    l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"),
                                    l;
                                case Cc:
                                    return c = l.displayName || null,
                                    c !== null ? c : f(l.type) || "Memo";
                                case Ca:
                                    c = l._payload,
                                    l = l._init;
                                    try {
                                        return f(l(c))
                                    } catch {}
                                }
                            return null
                        }
                        function d(l) {
                            if (ju === void 0)
                                try {
                                    throw Error()
                                } catch (_) {
                                    var c = _.stack.trim().match(/\n( *(at )?)/);
                                    ju = c && c[1] || "",
                                    Hf = -1 < _.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < _.stack.indexOf("@") ? "@unknown:0:0" : ""
                                }
                            return `
` + ju + l + Hf
                        }
                        function p(l, c) {
                            if (!l || eo)
                                return "";
                            eo = !0;
                            var _ = Error.prepareStackTrace;
                            Error.prepareStackTrace = void 0;
                            try {
                                var M = {
                                    DetermineComponentFrameRoot: function() {
                                        try {
                                            if (c) {
                                                var lt = function() {
                                                    throw Error()
                                                };
                                                if (Object.defineProperty(lt.prototype, "props", {
                                                    set: function() {
                                                        throw Error()
                                                    }
                                                }),
                                                typeof Reflect == "object" && Reflect.construct) {
                                                    try {
                                                        Reflect.construct(lt, [])
                                                    } catch (Yt) {
                                                        var ct = Yt
                                                    }
                                                    Reflect.construct(l, [], lt)
                                                } else {
                                                    try {
                                                        lt.call()
                                                    } catch (Yt) {
                                                        ct = Yt
                                                    }
                                                    l.call(lt.prototype)
                                                }
                                            } else {
                                                try {
                                                    throw Error()
                                                } catch (Yt) {
                                                    ct = Yt
                                                }
                                                (lt = l()) && typeof lt.catch == "function" && lt.catch(function() {})
                                            }
                                        } catch (Yt) {
                                            if (Yt && ct && typeof Yt.stack == "string")
                                                return [Yt.stack, ct.stack]
                                        }
                                        return [null, null]
                                    }
                                };
                                M.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                                var C = Object.getOwnPropertyDescriptor(M.DetermineComponentFrameRoot, "name");
                                C && C.configurable && Object.defineProperty(M.DetermineComponentFrameRoot, "name", {
                                    value: "DetermineComponentFrameRoot"
                                });
                                var O = M.DetermineComponentFrameRoot()
                                  , j = O[0]
                                  , se = O[1];
                                if (j && se) {
                                    var ge = j.split(`
`)
                                      , Ie = se.split(`
`);
                                    for (C = M = 0; M < ge.length && !ge[M].includes("DetermineComponentFrameRoot"); )
                                        M++;
                                    for (; C < Ie.length && !Ie[C].includes("DetermineComponentFrameRoot"); )
                                        C++;
                                    if (M === ge.length || C === Ie.length)
                                        for (M = ge.length - 1,
                                        C = Ie.length - 1; 1 <= M && 0 <= C && ge[M] !== Ie[C]; )
                                            C--;
                                    for (; 1 <= M && 0 <= C; M--,
                                    C--)
                                        if (ge[M] !== Ie[C]) {
                                            if (M !== 1 || C !== 1)
                                                do
                                                    if (M--,
                                                    C--,
                                                    0 > C || ge[M] !== Ie[C]) {
                                                        var $e = `
` + ge[M].replace(" at new ", " at ");
                                                        return l.displayName && $e.includes("<anonymous>") && ($e = $e.replace("<anonymous>", l.displayName)),
                                                        $e
                                                    }
                                                while (1 <= M && 0 <= C);
                                            break
                                        }
                                }
                            } finally {
                                eo = !1,
                                Error.prepareStackTrace = _
                            }
                            return (_ = l ? l.displayName || l.name : "") ? d(_) : ""
                        }
                        function g(l) {
                            switch (l.tag) {
                            case 26:
                            case 27:
                            case 5:
                                return d(l.type);
                            case 16:
                                return d("Lazy");
                            case 13:
                                return d("Suspense");
                            case 19:
                                return d("SuspenseList");
                            case 0:
                            case 15:
                                return l = p(l.type, !1),
                                l;
                            case 11:
                                return l = p(l.type.render, !1),
                                l;
                            case 1:
                                return l = p(l.type, !0),
                                l;
                            default:
                                return ""
                            }
                        }
                        function v(l) {
                            try {
                                var c = "";
                                do
                                    c += g(l),
                                    l = l.return;
                                while (l);
                                return c
                            } catch (_) {
                                return `
Error generating stack: ` + _.message + `
` + _.stack
                            }
                        }
                        function y(l) {
                            var c = l
                              , _ = l;
                            if (l.alternate)
                                for (; c.return; )
                                    c = c.return;
                            else {
                                l = c;
                                do
                                    c = l,
                                    (c.flags & 4098) !== 0 && (_ = c.return),
                                    l = c.return;
                                while (l)
                            }
                            return c.tag === 3 ? _ : null
                        }
                        function S(l) {
                            if (y(l) !== l)
                                throw Error(o(188))
                        }
                        function E(l) {
                            var c = l.alternate;
                            if (!c) {
                                if (c = y(l),
                                c === null)
                                    throw Error(o(188));
                                return c !== l ? null : l
                            }
                            for (var _ = l, M = c; ; ) {
                                var C = _.return;
                                if (C === null)
                                    break;
                                var O = C.alternate;
                                if (O === null) {
                                    if (M = C.return,
                                    M !== null) {
                                        _ = M;
                                        continue
                                    }
                                    break
                                }
                                if (C.child === O.child) {
                                    for (O = C.child; O; ) {
                                        if (O === _)
                                            return S(C),
                                            l;
                                        if (O === M)
                                            return S(C),
                                            c;
                                        O = O.sibling
                                    }
                                    throw Error(o(188))
                                }
                                if (_.return !== M.return)
                                    _ = C,
                                    M = O;
                                else {
                                    for (var j = !1, se = C.child; se; ) {
                                        if (se === _) {
                                            j = !0,
                                            _ = C,
                                            M = O;
                                            break
                                        }
                                        if (se === M) {
                                            j = !0,
                                            M = C,
                                            _ = O;
                                            break
                                        }
                                        se = se.sibling
                                    }
                                    if (!j) {
                                        for (se = O.child; se; ) {
                                            if (se === _) {
                                                j = !0,
                                                _ = O,
                                                M = C;
                                                break
                                            }
                                            if (se === M) {
                                                j = !0,
                                                M = O,
                                                _ = C;
                                                break
                                            }
                                            se = se.sibling
                                        }
                                        if (!j)
                                            throw Error(o(189))
                                    }
                                }
                                if (_.alternate !== M)
                                    throw Error(o(190))
                            }
                            if (_.tag !== 3)
                                throw Error(o(188));
                            return _.stateNode.current === _ ? l : c
                        }
                        function w(l) {
                            var c = l.tag;
                            if (c === 5 || c === 26 || c === 27 || c === 6)
                                return l;
                            for (l = l.child; l !== null; ) {
                                if (c = w(l),
                                c !== null)
                                    return c;
                                l = l.sibling
                            }
                            return null
                        }
                        function A(l) {
                            var c = l.tag;
                            if (c === 5 || c === 26 || c === 27 || c === 6)
                                return l;
                            for (l = l.child; l !== null; ) {
                                if (l.tag !== 4 && (c = A(l),
                                c !== null))
                                    return c;
                                l = l.sibling
                            }
                            return null
                        }
                        function T(l) {
                            return {
                                current: l
                            }
                        }
                        function R(l) {
                            0 > Ra || (l.current = ed[Ra],
                            ed[Ra] = null,
                            Ra--)
                        }
                        function N(l, c) {
                            Ra++,
                            ed[Ra] = l.current,
                            l.current = c
                        }
                        function D(l) {
                            return l >>>= 0,
                            l === 0 ? 32 : 31 - (zS(l) / td | 0) | 0
                        }
                        function U(l) {
                            var c = l & 42;
                            if (c !== 0)
                                return c;
                            switch (l & -l) {
                            case 1:
                                return 1;
                            case 2:
                                return 2;
                            case 4:
                                return 4;
                            case 8:
                                return 8;
                            case 16:
                                return 16;
                            case 32:
                                return 32;
                            case 64:
                                return 64;
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return l & 4194176;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                return l & 62914560;
                            case 67108864:
                                return 67108864;
                            case 134217728:
                                return 134217728;
                            case 268435456:
                                return 268435456;
                            case 536870912:
                                return 536870912;
                            case 1073741824:
                                return 0;
                            default:
                                return l
                            }
                        }
                        function z(l, c) {
                            var _ = l.pendingLanes;
                            if (_ === 0)
                                return 0;
                            var M = 0
                              , C = l.suspendedLanes
                              , O = l.pingedLanes
                              , j = l.warmLanes;
                            l = l.finishedLanes !== 0;
                            var se = _ & 134217727;
                            return se !== 0 ? (_ = se & ~C,
                            _ !== 0 ? M = U(_) : (O &= se,
                            O !== 0 ? M = U(O) : l || (j = se & ~j,
                            j !== 0 && (M = U(j))))) : (se = _ & ~C,
                            se !== 0 ? M = U(se) : O !== 0 ? M = U(O) : l || (j = _ & ~j,
                            j !== 0 && (M = U(j)))),
                            M === 0 ? 0 : c !== 0 && c !== M && (c & C) === 0 && (C = M & -M,
                            j = c & -c,
                            C >= j || C === 32 && (j & 4194176) !== 0) ? c : M
                        }
                        function I(l, c) {
                            return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & c) === 0
                        }
                        function V(l, c) {
                            switch (l) {
                            case 1:
                            case 2:
                            case 4:
                            case 8:
                                return c + 250;
                            case 16:
                            case 32:
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return c + 5e3;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                return -1;
                            case 67108864:
                            case 134217728:
                            case 268435456:
                            case 536870912:
                            case 1073741824:
                                return -1;
                            default:
                                return -1
                            }
                        }
                        function B() {
                            var l = oh;
                            return oh <<= 1,
                            (oh & 4194176) === 0 && (oh = 128),
                            l
                        }
                        function P() {
                            var l = Lc;
                            return Lc <<= 1,
                            (Lc & 62914560) === 0 && (Lc = 4194304),
                            l
                        }
                        function G(l) {
                            for (var c = [], _ = 0; 31 > _; _++)
                                c.push(l);
                            return c
                        }
                        function K(l, c) {
                            l.pendingLanes |= c,
                            c !== 268435456 && (l.suspendedLanes = 0,
                            l.pingedLanes = 0,
                            l.warmLanes = 0)
                        }
                        function ee(l, c, _, M, C, O) {
                            var j = l.pendingLanes;
                            l.pendingLanes = _,
                            l.suspendedLanes = 0,
                            l.pingedLanes = 0,
                            l.warmLanes = 0,
                            l.expiredLanes &= _,
                            l.entangledLanes &= _,
                            l.errorRecoveryDisabledLanes &= _,
                            l.shellSuspendCounter = 0;
                            var se = l.entanglements
                              , ge = l.expirationTimes
                              , Ie = l.hiddenUpdates;
                            for (_ = j & ~_; 0 < _; ) {
                                var $e = 31 - ia(_)
                                  , lt = 1 << $e;
                                se[$e] = 0,
                                ge[$e] = -1;
                                var ct = Ie[$e];
                                if (ct !== null)
                                    for (Ie[$e] = null,
                                    $e = 0; $e < ct.length; $e++) {
                                        var Yt = ct[$e];
                                        Yt !== null && (Yt.lane &= -536870913)
                                    }
                                _ &= ~lt
                            }
                            M !== 0 && te(l, M, 0),
                            O !== 0 && C === 0 && l.tag !== 0 && (l.suspendedLanes |= O & ~(j & ~c))
                        }
                        function te(l, c, _) {
                            l.pendingLanes |= c,
                            l.suspendedLanes &= ~c;
                            var M = 31 - ia(c);
                            l.entangledLanes |= c,
                            l.entanglements[M] = l.entanglements[M] | 1073741824 | _ & 4194218
                        }
                        function oe(l, c) {
                            var _ = l.entangledLanes |= c;
                            for (l = l.entanglements; _; ) {
                                var M = 31 - ia(_)
                                  , C = 1 << M;
                                C & c | l[M] & c && (l[M] |= c),
                                _ &= ~C
                            }
                        }
                        function q(l) {
                            return l &= -l,
                            2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                        }
                        function F(l) {
                            if (ps && typeof ps.onCommitFiberRoot == "function")
                                try {
                                    ps.onCommitFiberRoot(Ic, l, void 0, (l.current.flags & 128) === 128)
                                } catch {}
                        }
                        function X(l) {
                            if (typeof d_ == "function" && ch(l),
                            ps && typeof ps.setStrictMode == "function")
                                try {
                                    ps.setStrictMode(Ic, l)
                                } catch {}
                        }
                        function $(l, c) {
                            return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c
                        }
                        function ne(l, c) {
                            if (typeof l == "object" && l !== null) {
                                var _ = p_.get(l);
                                return _ !== void 0 ? _ : (c = {
                                    value: l,
                                    source: c,
                                    stack: v(c)
                                },
                                p_.set(l, c),
                                c)
                            }
                            return {
                                value: l,
                                source: c,
                                stack: v(c)
                            }
                        }
                        function ce(l, c) {
                            ao[Wo++] = hh,
                            ao[Wo++] = uh,
                            uh = l,
                            hh = c
                        }
                        function k(l, c, _) {
                            sa[zs++] = Qa,
                            sa[zs++] = Mr,
                            sa[zs++] = ro,
                            ro = l;
                            var M = Qa;
                            l = Mr;
                            var C = 32 - ia(M) - 1;
                            M &= ~(1 << C),
                            _ += 1;
                            var O = 32 - ia(c) + C;
                            if (30 < O) {
                                var j = C - C % 5;
                                O = (M & (1 << j) - 1).toString(32),
                                M >>= j,
                                C -= j,
                                Qa = 1 << 32 - ia(c) + C | _ << C | M,
                                Mr = O + l
                            } else
                                Qa = 1 << O | _ << C | M,
                                Mr = l
                        }
                        function pe(l) {
                            l.return !== null && (ce(l, 1),
                            k(l, 1, 0))
                        }
                        function Ae(l) {
                            for (; l === uh; )
                                uh = ao[--Wo],
                                ao[Wo] = null,
                                hh = ao[--Wo],
                                ao[Wo] = null;
                            for (; l === ro; )
                                ro = sa[--zs],
                                sa[zs] = null,
                                Mr = sa[--zs],
                                sa[zs] = null,
                                Qa = sa[--zs],
                                sa[zs] = null
                        }
                        function ie(l, c) {
                            N(br, c),
                            N(Yo, l),
                            N(Bi, null),
                            l = Qu(c),
                            R(Bi),
                            N(Bi, l)
                        }
                        function Me() {
                            R(Bi),
                            R(Yo),
                            R(br)
                        }
                        function we(l) {
                            l.memoizedState !== null && N(fh, l);
                            var c = Bi.current
                              , _ = Fv(c, l.type);
                            c !== _ && (N(Yo, l),
                            N(Bi, _))
                        }
                        function Te(l) {
                            Yo.current === l && (R(Bi),
                            R(Yo)),
                            fh.current === l && (R(fh),
                            xr ? io._currentValue = Gn : io._currentValue2 = Gn)
                        }
                        function Je(l) {
                            throw ve(ne(Error(o(418, "")), l)),
                            sd
                        }
                        function Ze(l, c) {
                            if (!Tn)
                                throw Error(o(175));
                            n_(l.stateNode, l.type, l.memoizedProps, c, l) || Je(l)
                        }
                        function Ct(l) {
                            for (ss = l.return; ss; )
                                switch (ss.tag) {
                                case 3:
                                case 27:
                                    Tr = !0;
                                    return;
                                case 5:
                                case 13:
                                    Tr = !1;
                                    return;
                                default:
                                    ss = ss.return
                                }
                        }
                        function bt(l) {
                            if (!Tn || l !== ss)
                                return !1;
                            if (!Jt)
                                return Ct(l),
                                Jt = !0,
                                !1;
                            var c = !1;
                            if (is ? l.tag !== 3 && l.tag !== 27 && (l.tag !== 5 || Nm(l.type) && !Rc(l.type, l.memoizedProps)) && (c = !0) : l.tag !== 3 && (l.tag !== 5 || Nm(l.type) && !Rc(l.type, l.memoizedProps)) && (c = !0),
                            c && as && Je(l),
                            Ct(l),
                            l.tag === 13) {
                                if (!Tn)
                                    throw Error(o(316));
                                if (l = l.memoizedState,
                                l = l !== null ? l.dehydrated : null,
                                !l)
                                    throw Error(o(317));
                                as = wm(l)
                            } else
                                as = ss ? ih(l.stateNode) : null;
                            return !0
                        }
                        function Ue() {
                            Tn && (as = ss = null,
                            Jt = !1)
                        }
                        function ve(l) {
                            aa === null ? aa = [l] : aa.push(l)
                        }
                        function Ce() {
                            for (var l = jo, c = ad = jo = 0; c < l; ) {
                                var _ = wi[c];
                                wi[c++] = null;
                                var M = wi[c];
                                wi[c++] = null;
                                var C = wi[c];
                                wi[c++] = null;
                                var O = wi[c];
                                if (wi[c++] = null,
                                M !== null && C !== null) {
                                    var j = M.pending;
                                    j === null ? C.next = C : (C.next = j.next,
                                    j.next = C),
                                    M.pending = C
                                }
                                O !== 0 && Ve(_, C, O)
                            }
                        }
                        function qe(l, c, _, M) {
                            wi[jo++] = l,
                            wi[jo++] = c,
                            wi[jo++] = _,
                            wi[jo++] = M,
                            ad |= M,
                            l.lanes |= M,
                            l = l.alternate,
                            l !== null && (l.lanes |= M)
                        }
                        function Q(l, c, _, M) {
                            return qe(l, c, _, M),
                            ft(l)
                        }
                        function Ke(l, c) {
                            return qe(l, null, null, c),
                            ft(l)
                        }
                        function Ve(l, c, _) {
                            l.lanes |= _;
                            var M = l.alternate;
                            M !== null && (M.lanes |= _);
                            for (var C = !1, O = l.return; O !== null; )
                                O.childLanes |= _,
                                M = O.alternate,
                                M !== null && (M.childLanes |= _),
                                O.tag === 22 && (l = O.stateNode,
                                l === null || l._visibility & 1 || (C = !0)),
                                l = O,
                                O = O.return;
                            C && c !== null && l.tag === 3 && (O = l.stateNode,
                            C = 31 - ia(_),
                            O = O.hiddenUpdates,
                            l = O[C],
                            l === null ? O[C] = [c] : l.push(c),
                            c.lane = _ | 536870912)
                        }
                        function ft(l) {
                            if (50 < Hc)
                                throw Hc = 0,
                                md = null,
                                Error(o(185));
                            for (var c = l.return; c !== null; )
                                l = c,
                                c = l.return;
                            return l.tag === 3 ? l.stateNode : null
                        }
                        function ke(l) {
                            l !== Ar && l.next === null && (Ar === null ? kl = Ar = l : Ar = Ar.next = l),
                            rd = !0,
                            kn || (kn = !0,
                            He(Z))
                        }
                        function Nt(l, c) {
                            if (!Gm && rd) {
                                Gm = !0;
                                do
                                    for (var _ = !1, M = kl; M !== null; ) {
                                        if (!c)
                                            if (l !== 0) {
                                                var C = M.pendingLanes;
                                                if (C === 0)
                                                    var O = 0;
                                                else {
                                                    var j = M.suspendedLanes
                                                      , se = M.pingedLanes;
                                                    O = (1 << 31 - ia(42 | l) + 1) - 1,
                                                    O &= C & ~(j & ~se),
                                                    O = O & 201326677 ? O & 201326677 | 1 : O ? O | 2 : 0
                                                }
                                                O !== 0 && (_ = !0,
                                                Le(M, O))
                                            } else
                                                O = mn,
                                                O = z(M, M === Nn ? O : 0),
                                                (O & 3) === 0 || I(M, O) || (_ = !0,
                                                Le(M, O));
                                        M = M.next
                                    }
                                while (_);
                                Gm = !1
                            }
                        }
                        function Z() {
                            rd = kn = !1;
                            var l = 0;
                            ql !== 0 && (Wf() && (l = ql),
                            ql = 0);
                            for (var c = Rn(), _ = null, M = kl; M !== null; ) {
                                var C = M.next
                                  , O = H(M, c);
                                O === 0 ? (M.next = null,
                                _ === null ? kl = C : _.next = C,
                                C === null && (Ar = _)) : (_ = M,
                                (l !== 0 || (O & 3) !== 0) && (rd = !0)),
                                M = C
                            }
                            Nt(l, !1)
                        }
                        function H(l, c) {
                            for (var _ = l.suspendedLanes, M = l.pingedLanes, C = l.expirationTimes, O = l.pendingLanes & -62914561; 0 < O; ) {
                                var j = 31 - ia(O)
                                  , se = 1 << j
                                  , ge = C[j];
                                ge === -1 ? ((se & _) === 0 || (se & M) !== 0) && (C[j] = V(se, c)) : ge <= c && (l.expiredLanes |= se),
                                O &= ~se
                            }
                            if (c = Nn,
                            _ = mn,
                            _ = z(l, l === c ? _ : 0),
                            M = l.callbackNode,
                            _ === 0 || l === c && Ln === 2 || l.cancelPendingCommit !== null)
                                return M !== null && M !== null && nd(M),
                                l.callbackNode = null,
                                l.callbackPriority = 0;
                            if ((_ & 3) === 0 || I(l, _)) {
                                if (c = _ & -_,
                                c === l.callbackPriority)
                                    return c;
                                switch (M !== null && nd(M),
                                q(_)) {
                                case 2:
                                case 8:
                                    _ = h_;
                                    break;
                                case 32:
                                    _ = id;
                                    break;
                                case 268435456:
                                    _ = f_;
                                    break;
                                default:
                                    _ = id
                                }
                                return M = he.bind(null, l),
                                _ = lh(_, M),
                                l.callbackPriority = c,
                                l.callbackNode = _,
                                c
                            }
                            return M !== null && M !== null && nd(M),
                            l.callbackPriority = 2,
                            l.callbackNode = null,
                            2
                        }
                        function he(l, c) {
                            var _ = l.callbackNode;
                            if (xs() && l.callbackNode !== _)
                                return null;
                            var M = mn;
                            return M = z(l, l === Nn ? M : 0),
                            M === 0 ? null : (ta(l, M, c),
                            H(l, Rn()),
                            l.callbackNode != null && l.callbackNode === _ ? he.bind(null, l) : null)
                        }
                        function Le(l, c) {
                            if (xs())
                                return null;
                            ta(l, c, !0)
                        }
                        function He(l) {
                            Gv ? kv(function() {
                                (bn & 6) !== 0 ? lh(ji, l) : l()
                            }) : lh(ji, l)
                        }
                        function Oe() {
                            return ql === 0 && (ql = B()),
                            ql
                        }
                        function pt(l, c) {
                            if (oo === null) {
                                var _ = oo = [];
                                Er = 0,
                                Xl = Oe(),
                                Wl = {
                                    status: "pending",
                                    value: void 0,
                                    then: function(M) {
                                        _.push(M)
                                    }
                                }
                            }
                            return Er++,
                            c.then(et, et),
                            c
                        }
                        function et() {
                            if (--Er === 0 && oo !== null) {
                                Wl !== null && (Wl.status = "fulfilled");
                                var l = oo;
                                oo = null,
                                Xl = 0,
                                Wl = null;
                                for (var c = 0; c < l.length; c++)
                                    (0,
                                    l[c])()
                            }
                        }
                        function xt(l, c) {
                            var _ = []
                              , M = {
                                status: "pending",
                                value: null,
                                reason: null,
                                then: function(C) {
                                    _.push(C)
                                }
                            };
                            return l.then(function() {
                                M.status = "fulfilled",
                                M.value = c;
                                for (var C = 0; C < _.length; C++)
                                    (0,
                                    _[C])(c)
                            }, function(C) {
                                for (M.status = "rejected",
                                M.reason = C,
                                C = 0; C < _.length; C++)
                                    (0,
                                    _[C])(void 0)
                            }),
                            M
                        }
                        function Dt(l) {
                            l.updateQueue = {
                                baseState: l.memoizedState,
                                firstBaseUpdate: null,
                                lastBaseUpdate: null,
                                shared: {
                                    pending: null,
                                    lanes: 0,
                                    hiddenCallbacks: null
                                },
                                callbacks: null
                            }
                        }
                        function je(l, c) {
                            l = l.updateQueue,
                            c.updateQueue === l && (c.updateQueue = {
                                baseState: l.baseState,
                                firstBaseUpdate: l.firstBaseUpdate,
                                lastBaseUpdate: l.lastBaseUpdate,
                                shared: l.shared,
                                callbacks: null
                            })
                        }
                        function Xe(l) {
                            return {
                                lane: l,
                                tag: 0,
                                payload: null,
                                callback: null,
                                next: null
                            }
                        }
                        function nt(l, c, _) {
                            var M = l.updateQueue;
                            if (M === null)
                                return null;
                            if (M = M.shared,
                            (bn & 2) !== 0) {
                                var C = M.pending;
                                return C === null ? c.next = c : (c.next = C.next,
                                C.next = c),
                                M.pending = c,
                                c = ft(l),
                                Ve(l, null, _),
                                c
                            }
                            return qe(l, M, c, _),
                            ft(l)
                        }
                        function ot(l, c, _) {
                            if (c = c.updateQueue,
                            c !== null && (c = c.shared,
                            (_ & 4194176) !== 0)) {
                                var M = c.lanes;
                                M &= l.pendingLanes,
                                _ |= M,
                                c.lanes = _,
                                oe(l, _)
                            }
                        }
                        function tt(l, c) {
                            var _ = l.updateQueue
                              , M = l.alternate;
                            if (M !== null && (M = M.updateQueue,
                            _ === M)) {
                                var C = null
                                  , O = null;
                                if (_ = _.firstBaseUpdate,
                                _ !== null) {
                                    do {
                                        var j = {
                                            lane: _.lane,
                                            tag: _.tag,
                                            payload: _.payload,
                                            callback: null,
                                            next: null
                                        };
                                        O === null ? C = O = j : O = O.next = j,
                                        _ = _.next
                                    } while (_ !== null);
                                    O === null ? C = O = c : O = O.next = c
                                } else
                                    C = O = c;
                                _ = {
                                    baseState: M.baseState,
                                    firstBaseUpdate: C,
                                    lastBaseUpdate: O,
                                    shared: M.shared,
                                    callbacks: M.callbacks
                                },
                                l.updateQueue = _;
                                return
                            }
                            l = _.lastBaseUpdate,
                            l === null ? _.firstBaseUpdate = c : l.next = c,
                            _.lastBaseUpdate = c
                        }
                        function Gt() {
                            if (Da) {
                                var l = Wl;
                                if (l !== null)
                                    throw l
                            }
                        }
                        function le(l, c, _, M) {
                            Da = !1;
                            var C = l.updateQueue;
                            Na = !1;
                            var O = C.firstBaseUpdate
                              , j = C.lastBaseUpdate
                              , se = C.shared.pending;
                            if (se !== null) {
                                C.shared.pending = null;
                                var ge = se
                                  , Ie = ge.next;
                                ge.next = null,
                                j === null ? O = Ie : j.next = Ie,
                                j = ge;
                                var $e = l.alternate;
                                $e !== null && ($e = $e.updateQueue,
                                se = $e.lastBaseUpdate,
                                se !== j && (se === null ? $e.firstBaseUpdate = Ie : se.next = Ie,
                                $e.lastBaseUpdate = ge))
                            }
                            if (O !== null) {
                                var lt = C.baseState;
                                j = 0,
                                $e = Ie = ge = null,
                                se = O;
                                do {
                                    var ct = se.lane & -536870913
                                      , Yt = ct !== se.lane;
                                    if (Yt ? (mn & ct) === ct : (M & ct) === ct) {
                                        ct !== 0 && ct === Xl && (Da = !0),
                                        $e !== null && ($e = $e.next = {
                                            lane: 0,
                                            tag: se.tag,
                                            payload: se.payload,
                                            callback: null,
                                            next: null
                                        });
                                        e: {
                                            var ha = l
                                              , Gc = se;
                                            ct = c;
                                            var nl = _;
                                            switch (Gc.tag) {
                                            case 1:
                                                if (ha = Gc.payload,
                                                typeof ha == "function") {
                                                    lt = ha.call(nl, lt, ct);
                                                    break e
                                                }
                                                lt = ha;
                                                break e;
                                            case 3:
                                                ha.flags = ha.flags & -65537 | 128;
                                            case 0:
                                                if (ha = Gc.payload,
                                                ct = typeof ha == "function" ? ha.call(nl, lt, ct) : ha,
                                                ct == null)
                                                    break e;
                                                lt = Pf({}, lt, ct);
                                                break e;
                                            case 2:
                                                Na = !0
                                            }
                                        }
                                        ct = se.callback,
                                        ct !== null && (l.flags |= 64,
                                        Yt && (l.flags |= 8192),
                                        Yt = C.callbacks,
                                        Yt === null ? C.callbacks = [ct] : Yt.push(ct))
                                    } else
                                        Yt = {
                                            lane: ct,
                                            tag: se.tag,
                                            payload: se.payload,
                                            callback: se.callback,
                                            next: null
                                        },
                                        $e === null ? (Ie = $e = Yt,
                                        ge = lt) : $e = $e.next = Yt,
                                        j |= ct;
                                    if (se = se.next,
                                    se === null) {
                                        if (se = C.shared.pending,
                                        se === null)
                                            break;
                                        Yt = se,
                                        se = Yt.next,
                                        Yt.next = null,
                                        C.lastBaseUpdate = Yt,
                                        C.shared.pending = null
                                    }
                                } while (!0);
                                $e === null && (ge = lt),
                                C.baseState = ge,
                                C.firstBaseUpdate = Ie,
                                C.lastBaseUpdate = $e,
                                O === null && (C.shared.lanes = 0),
                                ua |= j,
                                l.lanes = j,
                                l.memoizedState = lt
                            }
                        }
                        function it(l, c) {
                            if (typeof l != "function")
                                throw Error(o(191, l));
                            l.call(c)
                        }
                        function Qe(l, c) {
                            var _ = l.callbacks;
                            if (_ !== null)
                                for (l.callbacks = null,
                                l = 0; l < _.length; l++)
                                    it(_[l], c)
                        }
                        function dt(l, c) {
                            if (Is(l, c))
                                return !0;
                            if (typeof l != "object" || l === null || typeof c != "object" || c === null)
                                return !1;
                            var _ = Object.keys(l)
                              , M = Object.keys(c);
                            if (_.length !== M.length)
                                return !1;
                            for (M = 0; M < _.length; M++) {
                                var C = _[M];
                                if (!m_.call(c, C) || !Is(l[C], c[C]))
                                    return !1
                            }
                            return !0
                        }
                        function We(l) {
                            return l = l.status,
                            l === "fulfilled" || l === "rejected"
                        }
                        function De() {}
                        function mt(l, c, _) {
                            switch (_ = l[_],
                            _ === void 0 ? l.push(c) : _ !== c && (c.then(De, De),
                            c = _),
                            c.status) {
                            case "fulfilled":
                                return c.value;
                            case "rejected":
                                throw l = c.reason,
                                l === Yl ? Error(o(483)) : l;
                            default:
                                if (typeof c.status == "string")
                                    c.then(De, De);
                                else {
                                    if (l = Nn,
                                    l !== null && 100 < l.shellSuspendCounter)
                                        throw Error(o(482));
                                    l = c,
                                    l.status = "pending",
                                    l.then(function(M) {
                                        if (c.status === "pending") {
                                            var C = c;
                                            C.status = "fulfilled",
                                            C.value = M
                                        }
                                    }, function(M) {
                                        if (c.status === "pending") {
                                            var C = c;
                                            C.status = "rejected",
                                            C.reason = M
                                        }
                                    })
                                }
                                switch (c.status) {
                                case "fulfilled":
                                    return c.value;
                                case "rejected":
                                    throw l = c.reason,
                                    l === Yl ? Error(o(483)) : l
                                }
                                throw Zo = c,
                                Yl
                            }
                        }
                        function Tt() {
                            if (Zo === null)
                                throw Error(o(459));
                            var l = Zo;
                            return Zo = null,
                            l
                        }
                        function si(l) {
                            var c = Bc;
                            return Bc += 1,
                            lo === null && (lo = []),
                            mt(lo, l, c)
                        }
                        function pn(l, c) {
                            c = c.props.ref,
                            l.ref = c !== void 0 ? c : null
                        }
                        function cs(l, c) {
                            throw c.$$typeof === Ac ? Error(o(525)) : (l = Object.prototype.toString.call(c),
                            Error(o(31, l === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : l)))
                        }
                        function ys(l) {
                            var c = l._init;
                            return c(l._payload)
                        }
                        function Tu(l) {
                            function c(xe, fe) {
                                if (l) {
                                    var Re = xe.deletions;
                                    Re === null ? (xe.deletions = [fe],
                                    xe.flags |= 16) : Re.push(fe)
                                }
                            }
                            function _(xe, fe) {
                                if (!l)
                                    return null;
                                for (; fe !== null; )
                                    c(xe, fe),
                                    fe = fe.sibling;
                                return null
                            }
                            function M(xe) {
                                for (var fe = new Map; xe !== null; )
                                    xe.key !== null ? fe.set(xe.key, xe) : fe.set(xe.index, xe),
                                    xe = xe.sibling;
                                return fe
                            }
                            function C(xe, fe) {
                                return xe = Ho(xe, fe),
                                xe.index = 0,
                                xe.sibling = null,
                                xe
                            }
                            function O(xe, fe, Re) {
                                return xe.index = Re,
                                l ? (Re = xe.alternate,
                                Re !== null ? (Re = Re.index,
                                Re < fe ? (xe.flags |= 33554434,
                                fe) : Re) : (xe.flags |= 33554434,
                                fe)) : (xe.flags |= 1048576,
                                fe)
                            }
                            function j(xe) {
                                return l && xe.alternate === null && (xe.flags |= 33554434),
                                xe
                            }
                            function se(xe, fe, Re, Be) {
                                return fe === null || fe.tag !== 6 ? (fe = Il(Re, xe.mode, Be),
                                fe.return = xe,
                                fe) : (fe = C(fe, Re),
                                fe.return = xe,
                                fe)
                            }
                            function ge(xe, fe, Re, Be) {
                                var Et = Re.type;
                                return Et === Jr ? $e(xe, fe, Re.props.children, Be, Re.key) : fe !== null && (fe.elementType === Et || typeof Et == "object" && Et !== null && Et.$$typeof === Ca && ys(Et) === fe.type) ? (fe = C(fe, Re.props),
                                pn(fe, Re),
                                fe.return = xe,
                                fe) : (fe = If(Re.type, Re.key, Re.props, null, xe.mode, Be),
                                pn(fe, Re),
                                fe.return = xe,
                                fe)
                            }
                            function Ie(xe, fe, Re, Be) {
                                return fe === null || fe.tag !== 4 || fe.stateNode.containerInfo !== Re.containerInfo || fe.stateNode.implementation !== Re.implementation ? (fe = zl(Re, xe.mode, Be),
                                fe.return = xe,
                                fe) : (fe = C(fe, Re.children || []),
                                fe.return = xe,
                                fe)
                            }
                            function $e(xe, fe, Re, Be, Et) {
                                return fe === null || fe.tag !== 7 ? (fe = Yn(Re, xe.mode, Be, Et),
                                fe.return = xe,
                                fe) : (fe = C(fe, Re),
                                fe.return = xe,
                                fe)
                            }
                            function lt(xe, fe, Re) {
                                if (typeof fe == "string" && fe !== "" || typeof fe == "number" || typeof fe == "bigint")
                                    return fe = Il("" + fe, xe.mode, Re),
                                    fe.return = xe,
                                    fe;
                                if (typeof fe == "object" && fe !== null) {
                                    switch (fe.$$typeof) {
                                    case Ec:
                                        return Re = If(fe.type, fe.key, fe.props, null, xe.mode, Re),
                                        pn(Re, fe),
                                        Re.return = xe,
                                        Re;
                                    case Kr:
                                        return fe = zl(fe, xe.mode, Re),
                                        fe.return = xe,
                                        fe;
                                    case Ca:
                                        var Be = fe._init;
                                        return fe = Be(fe._payload),
                                        lt(xe, fe, Re)
                                    }
                                    if (Sr(fe) || u(fe))
                                        return fe = Yn(fe, xe.mode, Re, null),
                                        fe.return = xe,
                                        fe;
                                    if (typeof fe.then == "function")
                                        return lt(xe, si(fe), Re);
                                    if (fe.$$typeof === $r)
                                        return lt(xe, Lo(xe, fe), Re);
                                    cs(xe, fe)
                                }
                                return null
                            }
                            function ct(xe, fe, Re, Be) {
                                var Et = fe !== null ? fe.key : null;
                                if (typeof Re == "string" && Re !== "" || typeof Re == "number" || typeof Re == "bigint")
                                    return Et !== null ? null : se(xe, fe, "" + Re, Be);
                                if (typeof Re == "object" && Re !== null) {
                                    switch (Re.$$typeof) {
                                    case Ec:
                                        return Re.key === Et ? ge(xe, fe, Re, Be) : null;
                                    case Kr:
                                        return Re.key === Et ? Ie(xe, fe, Re, Be) : null;
                                    case Ca:
                                        return Et = Re._init,
                                        Re = Et(Re._payload),
                                        ct(xe, fe, Re, Be)
                                    }
                                    if (Sr(Re) || u(Re))
                                        return Et !== null ? null : $e(xe, fe, Re, Be, null);
                                    if (typeof Re.then == "function")
                                        return ct(xe, fe, si(Re), Be);
                                    if (Re.$$typeof === $r)
                                        return ct(xe, fe, Lo(xe, Re), Be);
                                    cs(xe, Re)
                                }
                                return null
                            }
                            function Yt(xe, fe, Re, Be, Et) {
                                if (typeof Be == "string" && Be !== "" || typeof Be == "number" || typeof Be == "bigint")
                                    return xe = xe.get(Re) || null,
                                    se(fe, xe, "" + Be, Et);
                                if (typeof Be == "object" && Be !== null) {
                                    switch (Be.$$typeof) {
                                    case Ec:
                                        return xe = xe.get(Be.key === null ? Re : Be.key) || null,
                                        ge(fe, xe, Be, Et);
                                    case Kr:
                                        return xe = xe.get(Be.key === null ? Re : Be.key) || null,
                                        Ie(fe, xe, Be, Et);
                                    case Ca:
                                        var ni = Be._init;
                                        return Be = ni(Be._payload),
                                        Yt(xe, fe, Re, Be, Et)
                                    }
                                    if (Sr(Be) || u(Be))
                                        return xe = xe.get(Re) || null,
                                        $e(fe, xe, Be, Et, null);
                                    if (typeof Be.then == "function")
                                        return Yt(xe, fe, Re, si(Be), Et);
                                    if (Be.$$typeof === $r)
                                        return Yt(xe, fe, Re, Lo(fe, Be), Et);
                                    cs(fe, Be)
                                }
                                return null
                            }
                            function ha(xe, fe, Re, Be) {
                                for (var Et = null, ni = null, Ft = fe, En = fe = 0, Qi = null; Ft !== null && En < Re.length; En++) {
                                    Ft.index > En ? (Qi = Ft,
                                    Ft = null) : Qi = Ft.sibling;
                                    var Cn = ct(xe, Ft, Re[En], Be);
                                    if (Cn === null) {
                                        Ft === null && (Ft = Qi);
                                        break
                                    }
                                    l && Ft && Cn.alternate === null && c(xe, Ft),
                                    fe = O(Cn, fe, En),
                                    ni === null ? Et = Cn : ni.sibling = Cn,
                                    ni = Cn,
                                    Ft = Qi
                                }
                                if (En === Re.length)
                                    return _(xe, Ft),
                                    Jt && ce(xe, En),
                                    Et;
                                if (Ft === null) {
                                    for (; En < Re.length; En++)
                                        Ft = lt(xe, Re[En], Be),
                                        Ft !== null && (fe = O(Ft, fe, En),
                                        ni === null ? Et = Ft : ni.sibling = Ft,
                                        ni = Ft);
                                    return Jt && ce(xe, En),
                                    Et
                                }
                                for (Ft = M(Ft); En < Re.length; En++)
                                    Qi = Yt(Ft, xe, En, Re[En], Be),
                                    Qi !== null && (l && Qi.alternate !== null && Ft.delete(Qi.key === null ? En : Qi.key),
                                    fe = O(Qi, fe, En),
                                    ni === null ? Et = Qi : ni.sibling = Qi,
                                    ni = Qi);
                                return l && Ft.forEach(function(tr) {
                                    return c(xe, tr)
                                }),
                                Jt && ce(xe, En),
                                Et
                            }
                            function Gc(xe, fe, Re, Be) {
                                if (Re == null)
                                    throw Error(o(151));
                                for (var Et = null, ni = null, Ft = fe, En = fe = 0, Qi = null, Cn = Re.next(); Ft !== null && !Cn.done; En++,
                                Cn = Re.next()) {
                                    Ft.index > En ? (Qi = Ft,
                                    Ft = null) : Qi = Ft.sibling;
                                    var tr = ct(xe, Ft, Cn.value, Be);
                                    if (tr === null) {
                                        Ft === null && (Ft = Qi);
                                        break
                                    }
                                    l && Ft && tr.alternate === null && c(xe, Ft),
                                    fe = O(tr, fe, En),
                                    ni === null ? Et = tr : ni.sibling = tr,
                                    ni = tr,
                                    Ft = Qi
                                }
                                if (Cn.done)
                                    return _(xe, Ft),
                                    Jt && ce(xe, En),
                                    Et;
                                if (Ft === null) {
                                    for (; !Cn.done; En++,
                                    Cn = Re.next())
                                        Cn = lt(xe, Cn.value, Be),
                                        Cn !== null && (fe = O(Cn, fe, En),
                                        ni === null ? Et = Cn : ni.sibling = Cn,
                                        ni = Cn);
                                    return Jt && ce(xe, En),
                                    Et
                                }
                                for (Ft = M(Ft); !Cn.done; En++,
                                Cn = Re.next())
                                    Cn = Yt(Ft, xe, En, Cn.value, Be),
                                    Cn !== null && (l && Cn.alternate !== null && Ft.delete(Cn.key === null ? En : Cn.key),
                                    fe = O(Cn, fe, En),
                                    ni === null ? Et = Cn : ni.sibling = Cn,
                                    ni = Cn);
                                return l && Ft.forEach(function(kc) {
                                    return c(xe, kc)
                                }),
                                Jt && ce(xe, En),
                                Et
                            }
                            function nl(xe, fe, Re, Be) {
                                if (typeof Re == "object" && Re !== null && Re.type === Jr && Re.key === null && (Re = Re.props.children),
                                typeof Re == "object" && Re !== null) {
                                    switch (Re.$$typeof) {
                                    case Ec:
                                        e: {
                                            for (var Et = Re.key; fe !== null; ) {
                                                if (fe.key === Et) {
                                                    if (Et = Re.type,
                                                    Et === Jr) {
                                                        if (fe.tag === 7) {
                                                            _(xe, fe.sibling),
                                                            Be = C(fe, Re.props.children),
                                                            Be.return = xe,
                                                            xe = Be;
                                                            break e
                                                        }
                                                    } else if (fe.elementType === Et || typeof Et == "object" && Et !== null && Et.$$typeof === Ca && ys(Et) === fe.type) {
                                                        _(xe, fe.sibling),
                                                        Be = C(fe, Re.props),
                                                        pn(Be, Re),
                                                        Be.return = xe,
                                                        xe = Be;
                                                        break e
                                                    }
                                                    _(xe, fe);
                                                    break
                                                } else
                                                    c(xe, fe);
                                                fe = fe.sibling
                                            }
                                            Re.type === Jr ? (Be = Yn(Re.props.children, xe.mode, Be, Re.key),
                                            Be.return = xe,
                                            xe = Be) : (Be = If(Re.type, Re.key, Re.props, null, xe.mode, Be),
                                            pn(Be, Re),
                                            Be.return = xe,
                                            xe = Be)
                                        }
                                        return j(xe);
                                    case Kr:
                                        e: {
                                            for (Et = Re.key; fe !== null; ) {
                                                if (fe.key === Et)
                                                    if (fe.tag === 4 && fe.stateNode.containerInfo === Re.containerInfo && fe.stateNode.implementation === Re.implementation) {
                                                        _(xe, fe.sibling),
                                                        Be = C(fe, Re.children || []),
                                                        Be.return = xe,
                                                        xe = Be;
                                                        break e
                                                    } else {
                                                        _(xe, fe);
                                                        break
                                                    }
                                                else
                                                    c(xe, fe);
                                                fe = fe.sibling
                                            }
                                            Be = zl(Re, xe.mode, Be),
                                            Be.return = xe,
                                            xe = Be
                                        }
                                        return j(xe);
                                    case Ca:
                                        return Et = Re._init,
                                        Re = Et(Re._payload),
                                        nl(xe, fe, Re, Be)
                                    }
                                    if (Sr(Re))
                                        return ha(xe, fe, Re, Be);
                                    if (u(Re)) {
                                        if (Et = u(Re),
                                        typeof Et != "function")
                                            throw Error(o(150));
                                        return Re = Et.call(Re),
                                        Gc(xe, fe, Re, Be)
                                    }
                                    if (typeof Re.then == "function")
                                        return nl(xe, fe, si(Re), Be);
                                    if (Re.$$typeof === $r)
                                        return nl(xe, fe, Lo(xe, Re), Be);
                                    cs(xe, Re)
                                }
                                return typeof Re == "string" && Re !== "" || typeof Re == "number" || typeof Re == "bigint" ? (Re = "" + Re,
                                fe !== null && fe.tag === 6 ? (_(xe, fe.sibling),
                                Be = C(fe, Re),
                                Be.return = xe,
                                xe = Be) : (_(xe, fe),
                                Be = Il(Re, xe.mode, Be),
                                Be.return = xe,
                                xe = Be),
                                j(xe)) : _(xe, fe)
                            }
                            return function(xe, fe, Re, Be) {
                                try {
                                    Bc = 0;
                                    var Et = nl(xe, fe, Re, Be);
                                    return lo = null,
                                    Et
                                } catch (Ft) {
                                    if (Ft === Yl)
                                        throw Ft;
                                    var ni = i(29, Ft, null, xe.mode);
                                    return ni.lanes = Be,
                                    ni.return = xe,
                                    ni
                                }
                            }
                        }
                        function xl(l, c) {
                            l = qn,
                            N(dh, l),
                            N(Qo, c),
                            qn = l | c.baseLanes
                        }
                        function vc() {
                            N(dh, qn),
                            N(Qo, Qo.current)
                        }
                        function Ml() {
                            qn = dh.current,
                            R(Qo),
                            R(dh)
                        }
                        function ba(l) {
                            var c = l.alternate;
                            N(Ri, Ri.current & 1),
                            N(Un, l),
                            Cr === null && (c === null || Qo.current !== null || c.memoizedState !== null) && (Cr = l)
                        }
                        function Ta(l) {
                            if (l.tag === 22) {
                                if (N(Ri, Ri.current),
                                N(Un, l),
                                Cr === null) {
                                    var c = l.alternate;
                                    c !== null && c.memoizedState !== null && (Cr = l)
                                }
                            } else
                                Ks(l)
                        }
                        function Ks() {
                            N(Ri, Ri.current),
                            N(Un, Un.current)
                        }
                        function Js(l) {
                            R(Un),
                            Cr === l && (Cr = null),
                            R(Ri)
                        }
                        function Rs(l) {
                            for (var c = l; c !== null; ) {
                                if (c.tag === 13) {
                                    var _ = c.memoizedState;
                                    if (_ !== null && (_ = _.dehydrated,
                                    _ === null || Qf(_) || Kf(_)))
                                        return c
                                } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
                                    if ((c.flags & 128) !== 0)
                                        return c
                                } else if (c.child !== null) {
                                    c.child.return = c,
                                    c = c.child;
                                    continue
                                }
                                if (c === l)
                                    break;
                                for (; c.sibling === null; ) {
                                    if (c.return === null || c.return === l)
                                        return null;
                                    c = c.return
                                }
                                c.sibling.return = c.return,
                                c = c.sibling
                            }
                            return null
                        }
                        function Zt() {
                            throw Error(o(321))
                        }
                        function Oi(l, c) {
                            if (c === null)
                                return !1;
                            for (var _ = 0; _ < c.length && _ < l.length; _++)
                                if (!Is(l[_], c[_]))
                                    return !1;
                            return !0
                        }
                        function Aa(l, c, _, M, C, O) {
                            return co = O,
                            St = c,
                            c.memoizedState = null,
                            c.updateQueue = null,
                            c.lanes = 0,
                            zt.H = l === null || l.memoizedState === null ? $o : ms,
                            Ko = !1,
                            O = _(M, C),
                            Ko = !1,
                            jl && (O = Au(c, _, M, C)),
                            bl(l),
                            O
                        }
                        function bl(l) {
                            zt.H = ui;
                            var c = Qt !== null && Qt.next !== null;
                            if (co = 0,
                            Bn = Qt = St = null,
                            ph = !1,
                            Jo = 0,
                            Pi = null,
                            c)
                                throw Error(o(300));
                            l === null || Pn || (l = l.dependencies,
                            l !== null && zu(l) && (Pn = !0))
                        }
                        function Au(l, c, _, M) {
                            St = l;
                            var C = 0;
                            do {
                                if (jl && (Pi = null),
                                Jo = 0,
                                jl = !1,
                                25 <= C)
                                    throw Error(o(301));
                                if (C += 1,
                                Bn = Qt = null,
                                l.updateQueue != null) {
                                    var O = l.updateQueue;
                                    O.lastEffect = null,
                                    O.events = null,
                                    O.stores = null,
                                    O.memoCache != null && (O.memoCache.index = 0)
                                }
                                zt.H = ra,
                                O = c(_, M)
                            } while (jl);
                            return O
                        }
                        function Op() {
                            var l = zt.H
                              , c = l.useState()[0];
                            return c = typeof c.then == "function" ? Y(c) : c,
                            l = l.useState()[0],
                            (Qt !== null ? Qt.memoizedState : null) !== l && (St.flags |= 1024),
                            c
                        }
                        function _c() {
                            var l = ld !== 0;
                            return ld = 0,
                            l
                        }
                        function Gr(l, c, _) {
                            c.updateQueue = l.updateQueue,
                            c.flags &= -2053,
                            l.lanes &= ~_
                        }
                        function Tl(l) {
                            if (ph) {
                                for (l = l.memoizedState; l !== null; ) {
                                    var c = l.queue;
                                    c !== null && (c.pending = null),
                                    l = l.next
                                }
                                ph = !1
                            }
                            co = 0,
                            Bn = Qt = St = null,
                            jl = !1,
                            Jo = ld = 0,
                            Pi = null
                        }
                        function yi() {
                            var l = {
                                memoizedState: null,
                                baseState: null,
                                baseQueue: null,
                                queue: null,
                                next: null
                            };
                            return Bn === null ? St.memoizedState = Bn = l : Bn = Bn.next = l,
                            Bn
                        }
                        function Fn() {
                            if (Qt === null) {
                                var l = St.alternate;
                                l = l !== null ? l.memoizedState : null
                            } else
                                l = Qt.next;
                            var c = Bn === null ? St.memoizedState : Bn.next;
                            if (c !== null)
                                Bn = c,
                                Qt = l;
                            else {
                                if (l === null)
                                    throw St.alternate === null ? Error(o(467)) : Error(o(310));
                                Qt = l,
                                l = {
                                    memoizedState: Qt.memoizedState,
                                    baseState: Qt.baseState,
                                    baseQueue: Qt.baseQueue,
                                    queue: Qt.queue,
                                    next: null
                                },
                                Bn === null ? St.memoizedState = Bn = l : Bn = Bn.next = l
                            }
                            return Bn
                        }
                        function Y(l) {
                            var c = Jo;
                            return Jo += 1,
                            Pi === null && (Pi = []),
                            l = mt(Pi, l, c),
                            c = St,
                            (Bn === null ? c.memoizedState : Bn.next) === null && (c = c.alternate,
                            zt.H = c === null || c.memoizedState === null ? $o : ms),
                            l
                        }
                        function ue(l) {
                            if (l !== null && typeof l == "object") {
                                if (typeof l.then == "function")
                                    return Y(l);
                                if (l.$$typeof === $r)
                                    return Ai(l)
                            }
                            throw Error(o(438, String(l)))
                        }
                        function _e(l) {
                            var c = null
                              , _ = St.updateQueue;
                            if (_ !== null && (c = _.memoCache),
                            c == null) {
                                var M = St.alternate;
                                M !== null && (M = M.updateQueue,
                                M !== null && (M = M.memoCache,
                                M != null && (c = {
                                    data: M.data.map(function(C) {
                                        return C.slice()
                                    }),
                                    index: 0
                                })))
                            }
                            if (c ??= {
                                data: [],
                                index: 0
                            },
                            _ === null && (_ = cd(),
                            St.updateQueue = _),
                            _.memoCache = c,
                            _ = c.data[c.index],
                            _ === void 0)
                                for (_ = c.data[c.index] = Array(l),
                                M = 0; M < l; M++)
                                    _[M] = Pv;
                            return c.index++,
                            _
                        }
                        function Se(l, c) {
                            return typeof c == "function" ? c(l) : c
                        }
                        function me(l) {
                            return Ye(Fn(), Qt, l)
                        }
                        function Ye(l, c, _) {
                            var M = l.queue;
                            if (M === null)
                                throw Error(o(311));
                            M.lastRenderedReducer = _;
                            var C = l.baseQueue
                              , O = M.pending;
                            if (O !== null) {
                                if (C !== null) {
                                    var j = C.next;
                                    C.next = O.next,
                                    O.next = j
                                }
                                c.baseQueue = C = O,
                                M.pending = null
                            }
                            if (O = l.baseState,
                            C === null)
                                l.memoizedState = O;
                            else {
                                c = C.next;
                                var se = j = null
                                  , ge = null
                                  , Ie = c
                                  , $e = !1;
                                do {
                                    var lt = Ie.lane & -536870913;
                                    if (lt !== Ie.lane ? (mn & lt) === lt : (co & lt) === lt) {
                                        var ct = Ie.revertLane;
                                        if (ct === 0)
                                            ge !== null && (ge = ge.next = {
                                                lane: 0,
                                                revertLane: 0,
                                                action: Ie.action,
                                                hasEagerState: Ie.hasEagerState,
                                                eagerState: Ie.eagerState,
                                                next: null
                                            }),
                                            lt === Xl && ($e = !0);
                                        else if ((co & ct) === ct) {
                                            Ie = Ie.next,
                                            ct === Xl && ($e = !0);
                                            continue
                                        } else
                                            lt = {
                                                lane: 0,
                                                revertLane: Ie.revertLane,
                                                action: Ie.action,
                                                hasEagerState: Ie.hasEagerState,
                                                eagerState: Ie.eagerState,
                                                next: null
                                            },
                                            ge === null ? (se = ge = lt,
                                            j = O) : ge = ge.next = lt,
                                            St.lanes |= ct,
                                            ua |= ct;
                                        lt = Ie.action,
                                        Ko && _(O, lt),
                                        O = Ie.hasEagerState ? Ie.eagerState : _(O, lt)
                                    } else
                                        ct = {
                                            lane: lt,
                                            revertLane: Ie.revertLane,
                                            action: Ie.action,
                                            hasEagerState: Ie.hasEagerState,
                                            eagerState: Ie.eagerState,
                                            next: null
                                        },
                                        ge === null ? (se = ge = ct,
                                        j = O) : ge = ge.next = ct,
                                        St.lanes |= lt,
                                        ua |= lt;
                                    Ie = Ie.next
                                } while (Ie !== null && Ie !== c);
                                if (ge === null ? j = O : ge.next = se,
                                !Is(O, l.memoizedState) && (Pn = !0,
                                $e && (_ = Wl,
                                _ !== null)))
                                    throw _;
                                l.memoizedState = O,
                                l.baseState = j,
                                l.baseQueue = ge,
                                M.lastRenderedState = O
                            }
                            return C === null && (M.lanes = 0),
                            [l.memoizedState, M.dispatch]
                        }
                        function st(l) {
                            var c = Fn()
                              , _ = c.queue;
                            if (_ === null)
                                throw Error(o(311));
                            _.lastRenderedReducer = l;
                            var M = _.dispatch
                              , C = _.pending
                              , O = c.memoizedState;
                            if (C !== null) {
                                _.pending = null;
                                var j = C = C.next;
                                do
                                    O = l(O, j.action),
                                    j = j.next;
                                while (j !== C);
                                Is(O, c.memoizedState) || (Pn = !0),
                                c.memoizedState = O,
                                c.baseQueue === null && (c.baseState = O),
                                _.lastRenderedState = O
                            }
                            return [O, M]
                        }
                        function vt(l, c, _) {
                            var M = St
                              , C = Fn()
                              , O = Jt;
                            if (O) {
                                if (_ === void 0)
                                    throw Error(o(407));
                                _ = _()
                            } else
                                _ = c();
                            var j = !Is((Qt || C).memoizedState, _);
                            if (j && (C.memoizedState = _,
                            Pn = !0),
                            C = C.queue,
                            Eu(Vt.bind(null, M, C, l), [l]),
                            C.getSnapshot !== c || j || Bn !== null && Bn.memoizedState.tag & 1) {
                                if (M.flags |= 2048,
                                ei(9, It.bind(null, M, C, _, c), {
                                    destroy: void 0
                                }, null),
                                Nn === null)
                                    throw Error(o(349));
                                O || (co & 60) !== 0 || ht(M, c, _)
                            }
                            return _
                        }
                        function ht(l, c, _) {
                            l.flags |= 16384,
                            l = {
                                getSnapshot: c,
                                value: _
                            },
                            c = St.updateQueue,
                            c === null ? (c = cd(),
                            St.updateQueue = c,
                            c.stores = [l]) : (_ = c.stores,
                            _ === null ? c.stores = [l] : _.push(l))
                        }
                        function It(l, c, _, M) {
                            c.value = _,
                            c.getSnapshot = M,
                            wt(c) && tn(l)
                        }
                        function Vt(l, c, _) {
                            return _(function() {
                                wt(c) && tn(l)
                            })
                        }
                        function wt(l) {
                            var c = l.getSnapshot;
                            l = l.value;
                            try {
                                var _ = c();
                                return !Is(l, _)
                            } catch {
                                return !0
                            }
                        }
                        function tn(l) {
                            var c = Ke(l, 2);
                            c !== null && Ii(c, l, 2)
                        }
                        function rn(l) {
                            var c = yi();
                            if (typeof l == "function") {
                                var _ = l;
                                if (l = _(),
                                Ko) {
                                    X(!0);
                                    try {
                                        _()
                                    } finally {
                                        X(!1)
                                    }
                                }
                            }
                            return c.memoizedState = c.baseState = l,
                            c.queue = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: Se,
                                lastRenderedState: l
                            },
                            c
                        }
                        function cn(l, c, _, M) {
                            return l.baseState = _,
                            Ye(l, Qt, typeof M == "function" ? M : Se)
                        }
                        function $n(l, c, _, M, C) {
                            if (Cl(l))
                                throw Error(o(485));
                            if (l = c.action,
                            l !== null) {
                                var O = {
                                    payload: C,
                                    action: l,
                                    next: null,
                                    isTransition: !0,
                                    status: "pending",
                                    value: null,
                                    reason: null,
                                    listeners: [],
                                    then: function(j) {
                                        O.listeners.push(j)
                                    }
                                };
                                zt.T !== null ? _(!0) : O.isTransition = !1,
                                M(O),
                                _ = c.pending,
                                _ === null ? (O.next = c.pending = O,
                                vn(c, O)) : (O.next = _.next,
                                c.pending = _.next = O)
                            }
                        }
                        function vn(l, c) {
                            var _ = c.action
                              , M = c.payload
                              , C = l.state;
                            if (c.isTransition) {
                                var O = zt.T
                                  , j = {};
                                zt.T = j;
                                try {
                                    var se = _(C, M)
                                      , ge = zt.S;
                                    ge !== null && ge(j, se),
                                    At(l, c, se)
                                } catch (Ie) {
                                    un(l, c, Ie)
                                } finally {
                                    zt.T = O
                                }
                            } else
                                try {
                                    O = _(C, M),
                                    At(l, c, O)
                                } catch (Ie) {
                                    un(l, c, Ie)
                                }
                        }
                        function At(l, c, _) {
                            _ !== null && typeof _ == "object" && typeof _.then == "function" ? _.then(function(M) {
                                Hn(l, c, M)
                            }, function(M) {
                                return un(l, c, M)
                            }) : Hn(l, c, _)
                        }
                        function Hn(l, c, _) {
                            c.status = "fulfilled",
                            c.value = _,
                            Ns(c),
                            l.state = _,
                            c = l.pending,
                            c !== null && (_ = c.next,
                            _ === c ? l.pending = null : (_ = _.next,
                            c.next = _,
                            vn(l, _)))
                        }
                        function un(l, c, _) {
                            var M = l.pending;
                            if (l.pending = null,
                            M !== null) {
                                M = M.next;
                                do
                                    c.status = "rejected",
                                    c.reason = _,
                                    Ns(c),
                                    c = c.next;
                                while (c !== M)
                            }
                            l.action = null
                        }
                        function Ns(l) {
                            l = l.listeners;
                            for (var c = 0; c < l.length; c++)
                                (0,
                                l[c])()
                        }
                        function Ti(l, c) {
                            return c
                        }
                        function qi(l, c) {
                            if (Jt) {
                                var _ = Nn.formState;
                                if (_ !== null) {
                                    e: {
                                        var M = St;
                                        if (Jt) {
                                            if (as) {
                                                var C = Dc(as, Tr);
                                                if (C) {
                                                    as = ih(C),
                                                    M = Jv(C);
                                                    break e
                                                }
                                            }
                                            Je(M)
                                        }
                                        M = !1
                                    }
                                    M && (c = _[0])
                                }
                            }
                            _ = yi(),
                            _.memoizedState = _.baseState = c,
                            M = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: Ti,
                                lastRenderedState: c
                            },
                            _.queue = M,
                            _ = hf.bind(null, St, M),
                            M.dispatch = _,
                            M = rn(!1);
                            var O = ff.bind(null, St, !1, M.queue);
                            return M = yi(),
                            C = {
                                state: c,
                                dispatch: null,
                                action: l,
                                pending: null
                            },
                            M.queue = C,
                            _ = $n.bind(null, St, C, O, _),
                            C.dispatch = _,
                            M.memoizedState = l,
                            [c, _, !1]
                        }
                        function kr(l) {
                            return wn(Fn(), Qt, l)
                        }
                        function wn(l, c, _) {
                            c = Ye(l, c, Ti)[0],
                            l = me(Se)[0],
                            c = typeof c == "object" && c !== null && typeof c.then == "function" ? Y(c) : c;
                            var M = Fn()
                              , C = M.queue
                              , O = C.dispatch;
                            return _ !== M.memoizedState && (St.flags |= 2048,
                            ei(9, Si.bind(null, C, _), {
                                destroy: void 0
                            }, null)),
                            [c, O, l]
                        }
                        function Si(l, c) {
                            l.action = c
                        }
                        function us(l) {
                            var c = Fn()
                              , _ = Qt;
                            if (_ !== null)
                                return wn(c, _, l);
                            Fn(),
                            c = c.memoizedState,
                            _ = Fn();
                            var M = _.queue.dispatch;
                            return _.memoizedState = l,
                            [c, M, !1]
                        }
                        function ei(l, c, _, M) {
                            return l = {
                                tag: l,
                                create: c,
                                inst: _,
                                deps: M,
                                next: null
                            },
                            c = St.updateQueue,
                            c === null && (c = cd(),
                            St.updateQueue = c),
                            _ = c.lastEffect,
                            _ === null ? c.lastEffect = l.next = l : (M = _.next,
                            _.next = l,
                            l.next = M,
                            c.lastEffect = l),
                            l
                        }
                        function Ui() {
                            return Fn().memoizedState
                        }
                        function wo(l, c, _, M) {
                            var C = yi();
                            St.flags |= l,
                            C.memoizedState = ei(1 | c, _, {
                                destroy: void 0
                            }, M === void 0 ? null : M)
                        }
                        function $s(l, c, _, M) {
                            var C = Fn();
                            M = M === void 0 ? null : M;
                            var O = C.memoizedState.inst;
                            Qt !== null && M !== null && Oi(M, Qt.memoizedState.deps) ? C.memoizedState = ei(c, _, O, M) : (St.flags |= l,
                            C.memoizedState = ei(1 | c, _, O, M))
                        }
                        function Up(l, c) {
                            wo(8390656, 8, l, c)
                        }
                        function Eu(l, c) {
                            $s(2048, 8, l, c)
                        }
                        function mv(l, c) {
                            return $s(4, 2, l, c)
                        }
                        function gv(l, c) {
                            return $s(4, 4, l, c)
                        }
                        function Cu(l, c) {
                            if (typeof c == "function") {
                                l = l();
                                var _ = c(l);
                                return function() {
                                    typeof _ == "function" ? _() : c(null)
                                }
                            }
                            if (c != null)
                                return l = l(),
                                c.current = l,
                                function() {
                                    c.current = null
                                }
                        }
                        function ur(l, c, _) {
                            _ = _ != null ? _.concat([l]) : null,
                            $s(4, 4, Cu.bind(null, c, l), _)
                        }
                        function wu() {}
                        function lf(l, c) {
                            var _ = Fn();
                            c = c === void 0 ? null : c;
                            var M = _.memoizedState;
                            return c !== null && Oi(c, M[1]) ? M[0] : (_.memoizedState = [l, c],
                            l)
                        }
                        function Al(l, c) {
                            var _ = Fn();
                            c = c === void 0 ? null : c;
                            var M = _.memoizedState;
                            if (c !== null && Oi(c, M[1]))
                                return M[0];
                            if (M = l(),
                            Ko) {
                                X(!0);
                                try {
                                    l()
                                } finally {
                                    X(!1)
                                }
                            }
                            return _.memoizedState = [M, c],
                            M
                        }
                        function Ro(l, c, _) {
                            return _ === void 0 || (co & 1073741824) !== 0 ? l.memoizedState = c : (l.memoizedState = _,
                            l = Xu(),
                            St.lanes |= l,
                            ua |= l,
                            _)
                        }
                        function Lp(l, c, _, M) {
                            return Is(_, c) ? _ : Qo.current !== null ? (l = Ro(l, _, M),
                            Is(l, c) || (Pn = !0),
                            l) : (co & 42) === 0 ? (Pn = !0,
                            l.memoizedState = _) : (l = Xu(),
                            St.lanes |= l,
                            ua |= l,
                            c)
                        }
                        function cf(l, c, _, M, C) {
                            var O = yn();
                            Ot(O !== 0 && 8 > O ? O : 8);
                            var j = zt.T
                              , se = {};
                            zt.T = se,
                            ff(l, !1, c, _);
                            try {
                                var ge = C()
                                  , Ie = zt.S;
                                Ie !== null && Ie(se, ge),
                                ge !== null && typeof ge == "object" && typeof ge.then == "function" ? Do(l, c, xt(ge, M), Xi(l)) : Do(l, c, M, Xi(l))
                            } catch ($e) {
                                Do(l, c, {
                                    then: function() {},
                                    status: "rejected",
                                    reason: $e
                                }, Xi())
                            } finally {
                                Ot(O),
                                zt.T = j
                            }
                        }
                        function Ip(l) {
                            var c = l.memoizedState;
                            if (c !== null)
                                return c;
                            c = {
                                memoizedState: Gn,
                                baseState: Gn,
                                baseQueue: null,
                                queue: {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: Se,
                                    lastRenderedState: Gn
                                },
                                next: null
                            };
                            var _ = {};
                            return c.next = {
                                memoizedState: _,
                                baseState: _,
                                baseQueue: null,
                                queue: {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: Se,
                                    lastRenderedState: _
                                },
                                next: null
                            },
                            l.memoizedState = c,
                            l = l.alternate,
                            l !== null && (l.memoizedState = c),
                            c
                        }
                        function El() {
                            return Ai(io)
                        }
                        function hr() {
                            return Fn().memoizedState
                        }
                        function uf() {
                            return Fn().memoizedState
                        }
                        function Ru(l) {
                            for (var c = l.return; c !== null; ) {
                                switch (c.tag) {
                                case 24:
                                case 3:
                                    var _ = Xi();
                                    l = Xe(_);
                                    var M = nt(c, l, _);
                                    M !== null && (Ii(M, c, _),
                                    ot(M, c, _)),
                                    c = {
                                        cache: Sc()
                                    },
                                    l.payload = c;
                                    return
                                }
                                c = c.return
                            }
                        }
                        function No(l, c, _) {
                            var M = Xi();
                            _ = {
                                lane: M,
                                revertLane: 0,
                                action: _,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            },
                            Cl(l) ? Nu(c, _) : (_ = Q(l, c, _, M),
                            _ !== null && (Ii(_, l, M),
                            zp(_, c, M)))
                        }
                        function hf(l, c, _) {
                            Do(l, c, _, Xi())
                        }
                        function Do(l, c, _, M) {
                            var C = {
                                lane: M,
                                revertLane: 0,
                                action: _,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            };
                            if (Cl(l))
                                Nu(c, C);
                            else {
                                var O = l.alternate;
                                if (l.lanes === 0 && (O === null || O.lanes === 0) && (O = c.lastRenderedReducer,
                                O !== null))
                                    try {
                                        var j = c.lastRenderedState
                                          , se = O(j, _);
                                        if (C.hasEagerState = !0,
                                        C.eagerState = se,
                                        Is(se, j))
                                            return qe(l, c, C, 0),
                                            Nn === null && Ce(),
                                            !1
                                    } catch {}
                                if (_ = Q(l, c, C, M),
                                _ !== null)
                                    return Ii(_, l, M),
                                    zp(_, c, M),
                                    !0
                            }
                            return !1
                        }
                        function ff(l, c, _, M) {
                            if (M = {
                                lane: 2,
                                revertLane: Oe(),
                                action: M,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            },
                            Cl(l)) {
                                if (c)
                                    throw Error(o(479))
                            } else
                                c = Q(l, _, M, 2),
                                c !== null && Ii(c, l, 2)
                        }
                        function Cl(l) {
                            var c = l.alternate;
                            return l === St || c !== null && c === St
                        }
                        function Nu(l, c) {
                            jl = ph = !0;
                            var _ = l.pending;
                            _ === null ? c.next = c : (c.next = _.next,
                            _.next = c),
                            l.pending = c
                        }
                        function zp(l, c, _) {
                            if ((_ & 4194176) !== 0) {
                                var M = c.lanes;
                                M &= l.pendingLanes,
                                _ |= M,
                                c.lanes = _,
                                oe(l, _)
                            }
                        }
                        function hs(l, c, _, M) {
                            c = l.memoizedState,
                            _ = _(M, c),
                            _ = _ == null ? c : Pf({}, c, _),
                            l.memoizedState = _,
                            l.lanes === 0 && (l.updateQueue.baseState = _)
                        }
                        function Oo(l, c, _, M, C, O, j) {
                            return l = l.stateNode,
                            typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(M, O, j) : c.prototype && c.prototype.isPureReactComponent ? !dt(_, M) || !dt(C, O) : !0
                        }
                        function Du(l, c, _, M) {
                            l = c.state,
                            typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(_, M),
                            typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(_, M),
                            c.state !== l && Ja.enqueueReplaceState(c, c.state, null)
                        }
                        function ka(l, c) {
                            var _ = c;
                            if ("ref"in c) {
                                _ = {};
                                for (var M in c)
                                    M !== "ref" && (_[M] = c[M])
                            }
                            if (l = l.defaultProps) {
                                _ === c && (_ = Pf({}, _));
                                for (var C in l)
                                    _[C] === void 0 && (_[C] = l[C])
                            }
                            return _
                        }
                        function df(l, c) {
                            try {
                                var _ = l.onUncaughtError;
                                _(c.value, {
                                    componentStack: c.stack
                                })
                            } catch (M) {
                                setTimeout(function() {
                                    throw M
                                })
                            }
                        }
                        function pf(l, c, _) {
                            try {
                                var M = l.onCaughtError;
                                M(_.value, {
                                    componentStack: _.stack,
                                    errorBoundary: c.tag === 1 ? c.stateNode : null
                                })
                            } catch (C) {
                                setTimeout(function() {
                                    throw C
                                })
                            }
                        }
                        function Ou(l, c, _) {
                            return _ = Xe(_),
                            _.tag = 3,
                            _.payload = {
                                element: null
                            },
                            _.callback = function() {
                                df(l, c)
                            }
                            ,
                            _
                        }
                        function yc(l) {
                            return l = Xe(l),
                            l.tag = 3,
                            l
                        }
                        function Uu(l, c, _, M) {
                            var C = _.type.getDerivedStateFromError;
                            if (typeof C == "function") {
                                var O = M.value;
                                l.payload = function() {
                                    return C(O)
                                }
                                ,
                                l.callback = function() {
                                    pf(c, _, M)
                                }
                            }
                            var j = _.stateNode;
                            j !== null && typeof j.componentDidCatch == "function" && (l.callback = function() {
                                pf(c, _, M),
                                typeof C != "function" && (po === null ? po = new Set([this]) : po.add(this));
                                var se = M.stack;
                                this.componentDidCatch(M.value, {
                                    componentStack: se !== null ? se : ""
                                })
                            }
                            )
                        }
                        function vv(l, c, _, M, C) {
                            if (_.flags |= 32768,
                            M !== null && typeof M == "object" && typeof M.then == "function") {
                                if (c = _.alternate,
                                c !== null && Iu(c, _, C, !0),
                                _ = Un.current,
                                _ !== null) {
                                    switch (_.tag) {
                                    case 13:
                                        return Cr === null ? hn() : _.alternate === null && In === 0 && (In = 3),
                                        _.flags &= -257,
                                        _.flags |= 65536,
                                        _.lanes = C,
                                        M === zc ? _.flags |= 16384 : (c = _.updateQueue,
                                        c === null ? _.updateQueue = new Set([M]) : c.add(M),
                                        Wu(l, M, C)),
                                        !1;
                                    case 22:
                                        return _.flags |= 65536,
                                        M === zc ? _.flags |= 16384 : (c = _.updateQueue,
                                        c === null ? (c = {
                                            transitions: null,
                                            markerInstances: null,
                                            retryQueue: new Set([M])
                                        },
                                        _.updateQueue = c) : (_ = c.retryQueue,
                                        _ === null ? c.retryQueue = new Set([M]) : _.add(M)),
                                        Wu(l, M, C)),
                                        !1
                                    }
                                    throw Error(o(435, _.tag))
                                }
                                return Wu(l, M, C),
                                hn(),
                                !1
                            }
                            if (Jt)
                                return c = Un.current,
                                c !== null ? ((c.flags & 65536) === 0 && (c.flags |= 256),
                                c.flags |= 65536,
                                c.lanes = C,
                                M !== sd && (l = Error(o(422), {
                                    cause: M
                                }),
                                ve(ne(l, _)))) : (M !== sd && (c = Error(o(423), {
                                    cause: M
                                }),
                                ve(ne(c, _))),
                                l = l.current.alternate,
                                l.flags |= 65536,
                                C &= -C,
                                l.lanes |= C,
                                M = ne(M, _),
                                C = Ou(l.stateNode, M, C),
                                tt(l, C),
                                In !== 4 && (In = 2)),
                                !1;
                            var O = Error(o(520), {
                                cause: M
                            });
                            if (O = ne(O, _),
                            fo === null ? fo = [O] : fo.push(O),
                            In !== 4 && (In = 2),
                            c === null)
                                return !0;
                            M = ne(M, _),
                            _ = c;
                            do {
                                switch (_.tag) {
                                case 3:
                                    return _.flags |= 65536,
                                    l = C & -C,
                                    _.lanes |= l,
                                    l = Ou(_.stateNode, M, l),
                                    tt(_, l),
                                    !1;
                                case 1:
                                    if (c = _.type,
                                    O = _.stateNode,
                                    (_.flags & 128) === 0 && (typeof c.getDerivedStateFromError == "function" || O !== null && typeof O.componentDidCatch == "function" && (po === null || !po.has(O))))
                                        return _.flags |= 65536,
                                        C &= -C,
                                        _.lanes |= C,
                                        C = yc(C),
                                        Uu(C, l, _, M),
                                        tt(_, C),
                                        !1
                                }
                                _ = _.return
                            } while (_ !== null);
                            return !1
                        }
                        function ts(l, c, _, M) {
                            c.child = l === null ? Mi(c, null, _, M) : Ms(c, l.child, _, M)
                        }
                        function mf(l, c, _, M, C) {
                            _ = _.render;
                            var O = c.ref;
                            if ("ref"in M) {
                                var j = {};
                                for (var se in M)
                                    se !== "ref" && (j[se] = M[se])
                            } else
                                j = M;
                            return Uo(c),
                            M = Aa(l, c, _, j, O, C),
                            se = _c(),
                            l !== null && !Pn ? (Gr(l, c, C),
                            fr(l, c, C)) : (Jt && se && pe(c),
                            c.flags |= 1,
                            ts(l, c, M, C),
                            c.child)
                        }
                        function _v(l, c, _, M, C) {
                            if (l === null) {
                                var O = _.type;
                                return typeof O == "function" && !Lf(O) && O.defaultProps === void 0 && _.compare === null ? (c.tag = 15,
                                c.type = O,
                                yv(l, c, O, M, C)) : (l = If(_.type, null, M, c, c.mode, C),
                                l.ref = c.ref,
                                l.return = c,
                                c.child = l)
                            }
                            if (O = l.child,
                            !yf(l, C)) {
                                var j = O.memoizedProps;
                                if (_ = _.compare,
                                _ = _ !== null ? _ : dt,
                                _(j, M) && l.ref === c.ref)
                                    return fr(l, c, C)
                            }
                            return c.flags |= 1,
                            l = Ho(O, M),
                            l.ref = c.ref,
                            l.return = c,
                            c.child = l
                        }
                        function yv(l, c, _, M, C) {
                            if (l !== null) {
                                var O = l.memoizedProps;
                                if (dt(O, M) && l.ref === c.ref)
                                    if (Pn = !1,
                                    c.pendingProps = M = O,
                                    yf(l, C))
                                        (l.flags & 131072) !== 0 && (Pn = !0);
                                    else
                                        return c.lanes = l.lanes,
                                        fr(l, c, C)
                            }
                            return Pp(l, c, _, M, C)
                        }
                        function Bp(l, c, _) {
                            var M = c.pendingProps
                              , C = M.children
                              , O = (c.stateNode._pendingVisibility & 2) !== 0
                              , j = l !== null ? l.memoizedState : null;
                            if (Lu(l, c),
                            M.mode === "hidden" || O) {
                                if ((c.flags & 128) !== 0) {
                                    if (M = j !== null ? j.baseLanes | _ : _,
                                    l !== null) {
                                        for (C = c.child = l.child,
                                        O = 0; C !== null; )
                                            O = O | C.lanes | C.childLanes,
                                            C = C.sibling;
                                        c.childLanes = O & ~M
                                    } else
                                        c.childLanes = 0,
                                        c.child = null;
                                    return Sv(l, c, M, _)
                                }
                                if ((_ & 536870912) !== 0)
                                    c.memoizedState = {
                                        baseLanes: 0,
                                        cachePool: null
                                    },
                                    l !== null && Mc(c, j !== null ? j.cachePool : null),
                                    j !== null ? xl(c, j) : vc(),
                                    Ta(c);
                                else
                                    return c.lanes = c.childLanes = 536870912,
                                    Sv(l, c, j !== null ? j.baseLanes | _ : _, _)
                            } else
                                j !== null ? (Mc(c, j.cachePool),
                                xl(c, j),
                                Ks(c),
                                c.memoizedState = null) : (l !== null && Mc(c, null),
                                vc(),
                                Ks(c));
                            return ts(l, c, C, _),
                            c.child
                        }
                        function Sv(l, c, _, M) {
                            var C = Sf();
                            return C = C === null ? null : {
                                parent: xr ? jn._currentValue : jn._currentValue2,
                                pool: C
                            },
                            c.memoizedState = {
                                baseLanes: _,
                                cachePool: C
                            },
                            l !== null && Mc(c, null),
                            vc(),
                            Ta(c),
                            l !== null && Iu(l, c, M, !0),
                            null
                        }
                        function Lu(l, c) {
                            var _ = c.ref;
                            if (_ === null)
                                l !== null && l.ref !== null && (c.flags |= 2097664);
                            else {
                                if (typeof _ != "function" && typeof _ != "object")
                                    throw Error(o(284));
                                (l === null || l.ref !== _) && (c.flags |= 2097664)
                            }
                        }
                        function Pp(l, c, _, M, C) {
                            return Uo(c),
                            _ = Aa(l, c, _, M, void 0, C),
                            M = _c(),
                            l !== null && !Pn ? (Gr(l, c, C),
                            fr(l, c, C)) : (Jt && M && pe(c),
                            c.flags |= 1,
                            ts(l, c, _, C),
                            c.child)
                        }
                        function xv(l, c, _, M, C, O) {
                            return Uo(c),
                            c.updateQueue = null,
                            _ = Au(c, M, _, C),
                            bl(l),
                            M = _c(),
                            l !== null && !Pn ? (Gr(l, c, O),
                            fr(l, c, O)) : (Jt && M && pe(c),
                            c.flags |= 1,
                            ts(l, c, _, O),
                            c.child)
                        }
                        function gf(l, c, _, M, C) {
                            if (Uo(c),
                            c.stateNode === null) {
                                var O = Uc
                                  , j = _.contextType;
                                typeof j == "object" && j !== null && (O = Ai(j)),
                                O = new _(M,O),
                                c.memoizedState = O.state !== null && O.state !== void 0 ? O.state : null,
                                O.updater = Ja,
                                c.stateNode = O,
                                O._reactInternals = c,
                                O = c.stateNode,
                                O.props = M,
                                O.state = c.memoizedState,
                                O.refs = {},
                                Dt(c),
                                j = _.contextType,
                                O.context = typeof j == "object" && j !== null ? Ai(j) : Uc,
                                O.state = c.memoizedState,
                                j = _.getDerivedStateFromProps,
                                typeof j == "function" && (hs(c, _, j, M),
                                O.state = c.memoizedState),
                                typeof _.getDerivedStateFromProps == "function" || typeof O.getSnapshotBeforeUpdate == "function" || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (j = O.state,
                                typeof O.componentWillMount == "function" && O.componentWillMount(),
                                typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount(),
                                j !== O.state && Ja.enqueueReplaceState(O, O.state, null),
                                le(c, M, O, C),
                                Gt(),
                                O.state = c.memoizedState),
                                typeof O.componentDidMount == "function" && (c.flags |= 4194308),
                                M = !0
                            } else if (l === null) {
                                O = c.stateNode;
                                var se = c.memoizedProps
                                  , ge = ka(_, se);
                                O.props = ge;
                                var Ie = O.context
                                  , $e = _.contextType;
                                j = Uc,
                                typeof $e == "object" && $e !== null && (j = Ai($e));
                                var lt = _.getDerivedStateFromProps;
                                $e = typeof lt == "function" || typeof O.getSnapshotBeforeUpdate == "function",
                                se = c.pendingProps !== se,
                                $e || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (se || Ie !== j) && Du(c, O, M, j),
                                Na = !1;
                                var ct = c.memoizedState;
                                O.state = ct,
                                le(c, M, O, C),
                                Gt(),
                                Ie = c.memoizedState,
                                se || ct !== Ie || Na ? (typeof lt == "function" && (hs(c, _, lt, M),
                                Ie = c.memoizedState),
                                (ge = Na || Oo(c, _, ge, M, ct, Ie, j)) ? ($e || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (typeof O.componentWillMount == "function" && O.componentWillMount(),
                                typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount()),
                                typeof O.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof O.componentDidMount == "function" && (c.flags |= 4194308),
                                c.memoizedProps = M,
                                c.memoizedState = Ie),
                                O.props = M,
                                O.state = Ie,
                                O.context = j,
                                M = ge) : (typeof O.componentDidMount == "function" && (c.flags |= 4194308),
                                M = !1)
                            } else {
                                O = c.stateNode,
                                je(l, c),
                                j = c.memoizedProps,
                                $e = ka(_, j),
                                O.props = $e,
                                lt = c.pendingProps,
                                ct = O.context,
                                Ie = _.contextType,
                                ge = Uc,
                                typeof Ie == "object" && Ie !== null && (ge = Ai(Ie)),
                                se = _.getDerivedStateFromProps,
                                (Ie = typeof se == "function" || typeof O.getSnapshotBeforeUpdate == "function") || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (j !== lt || ct !== ge) && Du(c, O, M, ge),
                                Na = !1,
                                ct = c.memoizedState,
                                O.state = ct,
                                le(c, M, O, C),
                                Gt();
                                var Yt = c.memoizedState;
                                j !== lt || ct !== Yt || Na || l !== null && l.dependencies !== null && zu(l.dependencies) ? (typeof se == "function" && (hs(c, _, se, M),
                                Yt = c.memoizedState),
                                ($e = Na || Oo(c, _, $e, M, ct, Yt, ge) || l !== null && l.dependencies !== null && zu(l.dependencies)) ? (Ie || typeof O.UNSAFE_componentWillUpdate != "function" && typeof O.componentWillUpdate != "function" || (typeof O.componentWillUpdate == "function" && O.componentWillUpdate(M, Yt, ge),
                                typeof O.UNSAFE_componentWillUpdate == "function" && O.UNSAFE_componentWillUpdate(M, Yt, ge)),
                                typeof O.componentDidUpdate == "function" && (c.flags |= 4),
                                typeof O.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof O.componentDidUpdate != "function" || j === l.memoizedProps && ct === l.memoizedState || (c.flags |= 4),
                                typeof O.getSnapshotBeforeUpdate != "function" || j === l.memoizedProps && ct === l.memoizedState || (c.flags |= 1024),
                                c.memoizedProps = M,
                                c.memoizedState = Yt),
                                O.props = M,
                                O.state = Yt,
                                O.context = ge,
                                M = $e) : (typeof O.componentDidUpdate != "function" || j === l.memoizedProps && ct === l.memoizedState || (c.flags |= 4),
                                typeof O.getSnapshotBeforeUpdate != "function" || j === l.memoizedProps && ct === l.memoizedState || (c.flags |= 1024),
                                M = !1)
                            }
                            return O = M,
                            Lu(l, c),
                            M = (c.flags & 128) !== 0,
                            O || M ? (O = c.stateNode,
                            _ = M && typeof _.getDerivedStateFromError != "function" ? null : O.render(),
                            c.flags |= 1,
                            l !== null && M ? (c.child = Ms(c, l.child, null, C),
                            c.child = Ms(c, null, _, C)) : ts(l, c, _, C),
                            c.memoizedState = O.state,
                            l = c.child) : l = fr(l, c, C),
                            l
                        }
                        function Mv(l, c, _, M) {
                            return Ue(),
                            c.flags |= 256,
                            ts(l, c, _, M),
                            c.child
                        }
                        function vf(l) {
                            return {
                                baseLanes: l,
                                cachePool: xf()
                            }
                        }
                        function Vp(l, c, _) {
                            return l = l !== null ? l.childLanes & ~_ : 0,
                            c && (l |= Ps),
                            l
                        }
                        function bv(l, c, _) {
                            var M = c.pendingProps, C = !1, O = (c.flags & 128) !== 0, j;
                            if ((j = O) || (j = l !== null && l.memoizedState === null ? !1 : (Ri.current & 2) !== 0),
                            j && (C = !0,
                            c.flags &= -129),
                            j = (c.flags & 32) !== 0,
                            c.flags &= -33,
                            l === null) {
                                if (Jt) {
                                    if (C ? ba(c) : Ks(c),
                                    Jt) {
                                        var se = as, ge;
                                        (ge = se) && (se = t_(se, Tr),
                                        se !== null ? (c.memoizedState = {
                                            dehydrated: se,
                                            treeContext: ro !== null ? {
                                                id: Qa,
                                                overflow: Mr
                                            } : null,
                                            retryLane: 536870912
                                        },
                                        ge = i(18, null, null, 0),
                                        ge.stateNode = se,
                                        ge.return = c,
                                        c.child = ge,
                                        ss = c,
                                        as = null,
                                        ge = !0) : ge = !1),
                                        ge || Je(c)
                                    }
                                    if (se = c.memoizedState,
                                    se !== null && (se = se.dehydrated,
                                    se !== null))
                                        return Kf(se) ? c.lanes = 16 : c.lanes = 536870912,
                                        null;
                                    Js(c)
                                }
                                return se = M.children,
                                M = M.fallback,
                                C ? (Ks(c),
                                C = c.mode,
                                se = Hp({
                                    mode: "hidden",
                                    children: se
                                }, C),
                                M = Yn(M, C, _, null),
                                se.return = c,
                                M.return = c,
                                se.sibling = M,
                                c.child = se,
                                C = c.child,
                                C.memoizedState = vf(_),
                                C.childLanes = Vp(l, j, _),
                                c.memoizedState = fd,
                                M) : (ba(c),
                                Fp(c, se))
                            }
                            if (ge = l.memoizedState,
                            ge !== null && (se = ge.dehydrated,
                            se !== null)) {
                                if (O)
                                    c.flags & 256 ? (ba(c),
                                    c.flags &= -257,
                                    c = Gp(l, c, _)) : c.memoizedState !== null ? (Ks(c),
                                    c.child = l.child,
                                    c.flags |= 128,
                                    c = null) : (Ks(c),
                                    C = M.fallback,
                                    se = c.mode,
                                    M = Hp({
                                        mode: "visible",
                                        children: M.children
                                    }, se),
                                    C = Yn(C, se, _, null),
                                    C.flags |= 2,
                                    M.return = c,
                                    C.return = c,
                                    M.sibling = C,
                                    c.child = M,
                                    Ms(c, l.child, null, _),
                                    M = c.child,
                                    M.memoizedState = vf(_),
                                    M.childLanes = Vp(l, j, _),
                                    c.memoizedState = fd,
                                    c = C);
                                else if (ba(c),
                                Kf(se))
                                    j = OS(se).digest,
                                    M = Error(o(419)),
                                    M.stack = "",
                                    M.digest = j,
                                    ve({
                                        value: M,
                                        source: null,
                                        stack: null
                                    }),
                                    c = Gp(l, c, _);
                                else if (Pn || Iu(l, c, _, !1),
                                j = (_ & l.childLanes) !== 0,
                                Pn || j) {
                                    if (j = Nn,
                                    j !== null) {
                                        if (M = _ & -_,
                                        (M & 42) !== 0)
                                            M = 1;
                                        else
                                            switch (M) {
                                            case 2:
                                                M = 1;
                                                break;
                                            case 8:
                                                M = 4;
                                                break;
                                            case 32:
                                                M = 16;
                                                break;
                                            case 128:
                                            case 256:
                                            case 512:
                                            case 1024:
                                            case 2048:
                                            case 4096:
                                            case 8192:
                                            case 16384:
                                            case 32768:
                                            case 65536:
                                            case 131072:
                                            case 262144:
                                            case 524288:
                                            case 1048576:
                                            case 2097152:
                                            case 4194304:
                                            case 8388608:
                                            case 16777216:
                                            case 33554432:
                                                M = 64;
                                                break;
                                            case 268435456:
                                                M = 134217728;
                                                break;
                                            default:
                                                M = 0
                                            }
                                        if (M = (M & (j.suspendedLanes | _)) !== 0 ? 0 : M,
                                        M !== 0 && M !== ge.retryLane)
                                            throw ge.retryLane = M,
                                            Ke(l, M),
                                            Ii(j, l, M),
                                            hd
                                    }
                                    Qf(se) || hn(),
                                    c = Gp(l, c, _)
                                } else
                                    Qf(se) ? (c.flags |= 128,
                                    c.child = l.child,
                                    c = Of.bind(null, l),
                                    Kv(se, c),
                                    c = null) : (l = ge.treeContext,
                                    Tn && (as = Cm(se),
                                    ss = c,
                                    Jt = !0,
                                    aa = null,
                                    Tr = !1,
                                    l !== null && (sa[zs++] = Qa,
                                    sa[zs++] = Mr,
                                    sa[zs++] = ro,
                                    Qa = l.id,
                                    Mr = l.overflow,
                                    ro = c)),
                                    c = Fp(c, M.children),
                                    c.flags |= 4096);
                                return c
                            }
                            return C ? (Ks(c),
                            C = M.fallback,
                            se = c.mode,
                            ge = l.child,
                            O = ge.sibling,
                            M = Ho(ge, {
                                mode: "hidden",
                                children: M.children
                            }),
                            M.subtreeFlags = ge.subtreeFlags & 31457280,
                            O !== null ? C = Ho(O, C) : (C = Yn(C, se, _, null),
                            C.flags |= 2),
                            C.return = c,
                            M.return = c,
                            M.sibling = C,
                            c.child = M,
                            M = C,
                            C = c.child,
                            se = l.child.memoizedState,
                            se === null ? se = vf(_) : (ge = se.cachePool,
                            ge !== null ? (O = xr ? jn._currentValue : jn._currentValue2,
                            ge = ge.parent !== O ? {
                                parent: O,
                                pool: O
                            } : ge) : ge = xf(),
                            se = {
                                baseLanes: se.baseLanes | _,
                                cachePool: ge
                            }),
                            C.memoizedState = se,
                            C.childLanes = Vp(l, j, _),
                            c.memoizedState = fd,
                            M) : (ba(c),
                            _ = l.child,
                            l = _.sibling,
                            _ = Ho(_, {
                                mode: "visible",
                                children: M.children
                            }),
                            _.return = c,
                            _.sibling = null,
                            l !== null && (j = c.deletions,
                            j === null ? (c.deletions = [l],
                            c.flags |= 16) : j.push(l)),
                            c.child = _,
                            c.memoizedState = null,
                            _)
                        }
                        function Fp(l, c) {
                            return c = Hp({
                                mode: "visible",
                                children: c
                            }, l.mode),
                            c.return = l,
                            l.child = c
                        }
                        function Hp(l, c) {
                            return zf(l, c, 0, null)
                        }
                        function Gp(l, c, _) {
                            return Ms(c, l.child, null, _),
                            l = Fp(c, c.pendingProps.children),
                            l.flags |= 2,
                            c.memoizedState = null,
                            l
                        }
                        function _f(l, c, _) {
                            l.lanes |= c;
                            var M = l.alternate;
                            M !== null && (M.lanes |= c),
                            qp(l.return, c, _)
                        }
                        function wl(l, c, _, M, C) {
                            var O = l.memoizedState;
                            O === null ? l.memoizedState = {
                                isBackwards: c,
                                rendering: null,
                                renderingStartTime: 0,
                                last: M,
                                tail: _,
                                tailMode: C
                            } : (O.isBackwards = c,
                            O.rendering = null,
                            O.renderingStartTime = 0,
                            O.last = M,
                            O.tail = _,
                            O.tailMode = C)
                        }
                        function Tv(l, c, _) {
                            var M = c.pendingProps
                              , C = M.revealOrder
                              , O = M.tail;
                            if (ts(l, c, M.children, _),
                            M = Ri.current,
                            (M & 2) !== 0)
                                M = M & 1 | 2,
                                c.flags |= 128;
                            else {
                                if (l !== null && (l.flags & 128) !== 0)
                                    e: for (l = c.child; l !== null; ) {
                                        if (l.tag === 13)
                                            l.memoizedState !== null && _f(l, _, c);
                                        else if (l.tag === 19)
                                            _f(l, _, c);
                                        else if (l.child !== null) {
                                            l.child.return = l,
                                            l = l.child;
                                            continue
                                        }
                                        if (l === c)
                                            break e;
                                        for (; l.sibling === null; ) {
                                            if (l.return === null || l.return === c)
                                                break e;
                                            l = l.return
                                        }
                                        l.sibling.return = l.return,
                                        l = l.sibling
                                    }
                                M &= 1
                            }
                            switch (N(Ri, M),
                            C) {
                            case "forwards":
                                for (_ = c.child,
                                C = null; _ !== null; )
                                    l = _.alternate,
                                    l !== null && Rs(l) === null && (C = _),
                                    _ = _.sibling;
                                _ = C,
                                _ === null ? (C = c.child,
                                c.child = null) : (C = _.sibling,
                                _.sibling = null),
                                wl(c, !1, C, _, O);
                                break;
                            case "backwards":
                                for (_ = null,
                                C = c.child,
                                c.child = null; C !== null; ) {
                                    if (l = C.alternate,
                                    l !== null && Rs(l) === null) {
                                        c.child = C;
                                        break
                                    }
                                    l = C.sibling,
                                    C.sibling = _,
                                    _ = C,
                                    C = l
                                }
                                wl(c, !0, _, null, O);
                                break;
                            case "together":
                                wl(c, !1, null, null, void 0);
                                break;
                            default:
                                c.memoizedState = null
                            }
                            return c.child
                        }
                        function fr(l, c, _) {
                            if (l !== null && (c.dependencies = l.dependencies),
                            ua |= c.lanes,
                            (_ & c.childLanes) === 0)
                                if (l !== null) {
                                    if (Iu(l, c, _, !1),
                                    (_ & c.childLanes) === 0)
                                        return null
                                } else
                                    return null;
                            if (l !== null && c.child !== l.child)
                                throw Error(o(153));
                            if (c.child !== null) {
                                for (l = c.child,
                                _ = Ho(l, l.pendingProps),
                                c.child = _,
                                _.return = c; l.sibling !== null; )
                                    l = l.sibling,
                                    _ = _.sibling = Ho(l, l.pendingProps),
                                    _.return = c;
                                _.sibling = null
                            }
                            return c.child
                        }
                        function yf(l, c) {
                            return (l.lanes & c) !== 0 ? !0 : (l = l.dependencies,
                            !!(l !== null && zu(l)))
                        }
                        function Av(l, c, _) {
                            switch (c.tag) {
                            case 3:
                                ie(c, c.stateNode.containerInfo),
                                qr(c, jn, l.memoizedState.cache),
                                Ue();
                                break;
                            case 27:
                            case 5:
                                we(c);
                                break;
                            case 4:
                                ie(c, c.stateNode.containerInfo);
                                break;
                            case 10:
                                qr(c, c.type, c.memoizedProps.value);
                                break;
                            case 13:
                                var M = c.memoizedState;
                                if (M !== null)
                                    return M.dehydrated !== null ? (ba(c),
                                    c.flags |= 128,
                                    null) : (_ & c.child.childLanes) !== 0 ? bv(l, c, _) : (ba(c),
                                    l = fr(l, c, _),
                                    l !== null ? l.sibling : null);
                                ba(c);
                                break;
                            case 19:
                                var C = (l.flags & 128) !== 0;
                                if (M = (_ & c.childLanes) !== 0,
                                M || (Iu(l, c, _, !1),
                                M = (_ & c.childLanes) !== 0),
                                C) {
                                    if (M)
                                        return Tv(l, c, _);
                                    c.flags |= 128
                                }
                                if (C = c.memoizedState,
                                C !== null && (C.rendering = null,
                                C.tail = null,
                                C.lastEffect = null),
                                N(Ri, Ri.current),
                                M)
                                    break;
                                return null;
                            case 22:
                            case 23:
                                return c.lanes = 0,
                                Bp(l, c, _);
                            case 24:
                                qr(c, jn, l.memoizedState.cache)
                            }
                            return fr(l, c, _)
                        }
                        function kp(l, c, _) {
                            if (l !== null)
                                if (l.memoizedProps !== c.pendingProps)
                                    Pn = !0;
                                else {
                                    if (!yf(l, _) && (c.flags & 128) === 0)
                                        return Pn = !1,
                                        Av(l, c, _);
                                    Pn = (l.flags & 131072) !== 0
                                }
                            else
                                Pn = !1,
                                Jt && (c.flags & 1048576) !== 0 && k(c, hh, c.index);
                            switch (c.lanes = 0,
                            c.tag) {
                            case 16:
                                e: {
                                    l = c.pendingProps;
                                    var M = c.elementType
                                      , C = M._init;
                                    if (M = C(M._payload),
                                    c.type = M,
                                    typeof M == "function")
                                        Lf(M) ? (l = ka(M, l),
                                        c.tag = 1,
                                        c = gf(null, c, M, l, _)) : (c.tag = 0,
                                        c = Pp(null, c, M, l, _));
                                    else {
                                        if (M != null) {
                                            if (C = M.$$typeof,
                                            C === Ff) {
                                                c.tag = 11,
                                                c = mf(null, c, M, l, _);
                                                break e
                                            } else if (C === Cc) {
                                                c.tag = 14,
                                                c = _v(null, c, M, l, _);
                                                break e
                                            }
                                        }
                                        throw c = f(M) || M,
                                        Error(o(306, c, ""))
                                    }
                                }
                                return c;
                            case 0:
                                return Pp(l, c, c.type, c.pendingProps, _);
                            case 1:
                                return M = c.type,
                                C = ka(M, c.pendingProps),
                                gf(l, c, M, C, _);
                            case 3:
                                e: {
                                    if (ie(c, c.stateNode.containerInfo),
                                    l === null)
                                        throw Error(o(387));
                                    var O = c.pendingProps;
                                    C = c.memoizedState,
                                    M = C.element,
                                    je(l, c),
                                    le(c, O, null, _);
                                    var j = c.memoizedState;
                                    if (O = j.cache,
                                    qr(c, jn, O),
                                    O !== C.cache && Xp(c, [jn], _, !0),
                                    Gt(),
                                    O = j.element,
                                    Tn && C.isDehydrated)
                                        if (C = {
                                            element: O,
                                            isDehydrated: !1,
                                            cache: j.cache
                                        },
                                        c.updateQueue.baseState = C,
                                        c.memoizedState = C,
                                        c.flags & 256) {
                                            c = Mv(l, c, O, _);
                                            break e
                                        } else if (O !== M) {
                                            M = ne(Error(o(424)), c),
                                            ve(M),
                                            c = Mv(l, c, O, _);
                                            break e
                                        } else
                                            for (Tn && (as = $v(c.stateNode.containerInfo),
                                            ss = c,
                                            Jt = !0,
                                            aa = null,
                                            Tr = !0),
                                            _ = Mi(c, null, O, _),
                                            c.child = _; _; )
                                                _.flags = _.flags & -3 | 4096,
                                                _ = _.sibling;
                                    else {
                                        if (Ue(),
                                        O === M) {
                                            c = fr(l, c, _);
                                            break e
                                        }
                                        ts(l, c, O, _)
                                    }
                                    c = c.child
                                }
                                return c;
                            case 26:
                                if (na)
                                    return Lu(l, c),
                                    l === null ? (_ = Um(c.type, null, c.pendingProps, null)) ? c.memoizedState = _ : Jt || (c.stateNode = zm(c.type, c.pendingProps, br.current, c)) : c.memoizedState = Um(c.type, l.memoizedProps, c.pendingProps, l.memoizedState),
                                    null;
                            case 27:
                                if (is)
                                    return we(c),
                                    l === null && is && Jt && (M = c.stateNode = $f(c.type, c.pendingProps, br.current, Bi.current, !1),
                                    ss = c,
                                    Tr = !0,
                                    as = sh(M)),
                                    M = c.pendingProps.children,
                                    l !== null || Jt ? ts(l, c, M, _) : c.child = Ms(c, null, M, _),
                                    Lu(l, c),
                                    c.child;
                            case 5:
                                return l === null && Jt && (LS(c.type, c.pendingProps, Bi.current),
                                (C = M = as) && (M = US(M, c.type, c.pendingProps, Tr),
                                M !== null ? (c.stateNode = M,
                                ss = c,
                                as = sh(M),
                                Tr = !1,
                                C = !0) : C = !1),
                                C || Je(c)),
                                we(c),
                                C = c.type,
                                O = c.pendingProps,
                                j = l !== null ? l.memoizedProps : null,
                                M = O.children,
                                Rc(C, O) ? M = null : j !== null && Rc(C, j) && (c.flags |= 32),
                                c.memoizedState !== null && (C = Aa(l, c, Op, null, null, _),
                                xr ? io._currentValue = C : io._currentValue2 = C),
                                Lu(l, c),
                                ts(l, c, M, _),
                                c.child;
                            case 6:
                                return l === null && Jt && (Dm(c.pendingProps, Bi.current),
                                (l = _ = as) && (_ = e_(_, c.pendingProps, Tr),
                                _ !== null ? (c.stateNode = _,
                                ss = c,
                                as = null,
                                l = !0) : l = !1),
                                l || Je(c)),
                                null;
                            case 13:
                                return bv(l, c, _);
                            case 4:
                                return ie(c, c.stateNode.containerInfo),
                                M = c.pendingProps,
                                l === null ? c.child = Ms(c, null, M, _) : ts(l, c, M, _),
                                c.child;
                            case 11:
                                return mf(l, c, c.type, c.pendingProps, _);
                            case 7:
                                return ts(l, c, c.pendingProps, _),
                                c.child;
                            case 8:
                                return ts(l, c, c.pendingProps.children, _),
                                c.child;
                            case 12:
                                return ts(l, c, c.pendingProps.children, _),
                                c.child;
                            case 10:
                                return M = c.pendingProps,
                                qr(c, c.type, M.value),
                                ts(l, c, M.children, _),
                                c.child;
                            case 9:
                                return C = c.type._context,
                                M = c.pendingProps.children,
                                Uo(c),
                                C = Ai(C),
                                M = M(C),
                                c.flags |= 1,
                                ts(l, c, M, _),
                                c.child;
                            case 14:
                                return _v(l, c, c.type, c.pendingProps, _);
                            case 15:
                                return yv(l, c, c.type, c.pendingProps, _);
                            case 19:
                                return Tv(l, c, _);
                            case 22:
                                return Bp(l, c, _);
                            case 24:
                                return Uo(c),
                                M = Ai(jn),
                                l === null ? (C = Sf(),
                                C === null && (C = Nn,
                                O = Sc(),
                                C.pooledCache = O,
                                O.refCount++,
                                O !== null && (C.pooledCacheLanes |= _),
                                C = O),
                                c.memoizedState = {
                                    parent: M,
                                    cache: C
                                },
                                Dt(c),
                                qr(c, jn, C)) : ((l.lanes & _) !== 0 && (je(l, c),
                                le(c, null, null, _),
                                Gt()),
                                C = l.memoizedState,
                                O = c.memoizedState,
                                C.parent !== M ? (C = {
                                    parent: M,
                                    cache: M
                                },
                                c.memoizedState = C,
                                c.lanes === 0 && (c.memoizedState = c.updateQueue.baseState = C),
                                qr(c, jn, M)) : (M = O.cache,
                                qr(c, jn, M),
                                M !== C.cache && Xp(c, [jn], _, !0))),
                                ts(l, c, c.pendingProps.children, _),
                                c.child;
                            case 29:
                                throw c.pendingProps
                            }
                            throw Error(o(156, c.tag))
                        }
                        function qr(l, c, _) {
                            xr ? (N(uo, c._currentValue),
                            c._currentValue = _) : (N(uo, c._currentValue2),
                            c._currentValue2 = _)
                        }
                        function Ds(l) {
                            var c = uo.current;
                            xr ? l._currentValue = c : l._currentValue2 = c,
                            R(uo)
                        }
                        function qp(l, c, _) {
                            for (; l !== null; ) {
                                var M = l.alternate;
                                if ((l.childLanes & c) !== c ? (l.childLanes |= c,
                                M !== null && (M.childLanes |= c)) : M !== null && (M.childLanes & c) !== c && (M.childLanes |= c),
                                l === _)
                                    break;
                                l = l.return
                            }
                        }
                        function Xp(l, c, _, M) {
                            var C = l.child;
                            for (C !== null && (C.return = l); C !== null; ) {
                                var O = C.dependencies;
                                if (O !== null) {
                                    var j = C.child;
                                    O = O.firstContext;
                                    e: for (; O !== null; ) {
                                        var se = O;
                                        O = C;
                                        for (var ge = 0; ge < c.length; ge++)
                                            if (se.context === c[ge]) {
                                                O.lanes |= _,
                                                se = O.alternate,
                                                se !== null && (se.lanes |= _),
                                                qp(O.return, _, l),
                                                M || (j = null);
                                                break e
                                            }
                                        O = se.next
                                    }
                                } else if (C.tag === 18) {
                                    if (j = C.return,
                                    j === null)
                                        throw Error(o(341));
                                    j.lanes |= _,
                                    O = j.alternate,
                                    O !== null && (O.lanes |= _),
                                    qp(j, _, l),
                                    j = null
                                } else
                                    j = C.child;
                                if (j !== null)
                                    j.return = C;
                                else
                                    for (j = C; j !== null; ) {
                                        if (j === l) {
                                            j = null;
                                            break
                                        }
                                        if (C = j.sibling,
                                        C !== null) {
                                            C.return = j.return,
                                            j = C;
                                            break
                                        }
                                        j = j.return
                                    }
                                C = j
                            }
                        }
                        function Iu(l, c, _, M) {
                            l = null;
                            for (var C = c, O = !1; C !== null; ) {
                                if (!O) {
                                    if ((C.flags & 524288) !== 0)
                                        O = !0;
                                    else if ((C.flags & 262144) !== 0)
                                        break
                                }
                                if (C.tag === 10) {
                                    var j = C.alternate;
                                    if (j === null)
                                        throw Error(o(387));
                                    if (j = j.memoizedProps,
                                    j !== null) {
                                        var se = C.type;
                                        Is(C.pendingProps.value, j.value) || (l !== null ? l.push(se) : l = [se])
                                    }
                                } else if (C === fh.current) {
                                    if (j = C.alternate,
                                    j === null)
                                        throw Error(o(387));
                                    j.memoizedState.memoizedState !== C.memoizedState.memoizedState && (l !== null ? l.push(io) : l = [io])
                                }
                                C = C.return
                            }
                            l !== null && Xp(c, l, _, M),
                            c.flags |= 262144
                        }
                        function zu(l) {
                            for (l = l.firstContext; l !== null; ) {
                                var c = l.context;
                                if (!Is(xr ? c._currentValue : c._currentValue2, l.memoizedValue))
                                    return !0;
                                l = l.next
                            }
                            return !1
                        }
                        function Uo(l) {
                            $a = l,
                            oa = null,
                            l = l.dependencies,
                            l !== null && (l.firstContext = null)
                        }
                        function Ai(l) {
                            return Ev($a, l)
                        }
                        function Lo(l, c) {
                            return $a === null && Uo(l),
                            Ev(l, c)
                        }
                        function Ev(l, c) {
                            var _ = xr ? c._currentValue : c._currentValue2;
                            if (c = {
                                context: c,
                                memoizedValue: _,
                                next: null
                            },
                            oa === null) {
                                if (l === null)
                                    throw Error(o(308));
                                oa = c,
                                l.dependencies = {
                                    lanes: 0,
                                    firstContext: c
                                },
                                l.flags |= 524288
                            } else
                                oa = oa.next = c;
                            return _
                        }
                        function Sc() {
                            return {
                                controller: new Pc,
                                data: new Map,
                                refCount: 0
                            }
                        }
                        function xc(l) {
                            l.refCount--,
                            l.refCount === 0 && g_(v_, function() {
                                l.controller.abort()
                            })
                        }
                        function Sf() {
                            var l = wr.current;
                            return l !== null ? l : Nn.pooledCache
                        }
                        function Mc(l, c) {
                            c === null ? N(wr, wr.current) : N(wr, c.pool)
                        }
                        function xf() {
                            var l = Sf();
                            return l === null ? null : {
                                parent: xr ? jn._currentValue : jn._currentValue2,
                                pool: l
                            }
                        }
                        function Os(l) {
                            l.flags |= 4
                        }
                        function Wp(l, c) {
                            if (l !== null && l.child === c.child)
                                return !1;
                            if ((c.flags & 16) !== 0)
                                return !0;
                            for (l = c.child; l !== null; ) {
                                if ((l.flags & 13878) !== 0 || (l.subtreeFlags & 13878) !== 0)
                                    return !0;
                                l = l.sibling
                            }
                            return !1
                        }
                        function Mf(l, c, _, M) {
                            if (ci)
                                for (_ = c.child; _ !== null; ) {
                                    if (_.tag === 5 || _.tag === 6)
                                        qf(l, _.stateNode);
                                    else if (!(_.tag === 4 || is && _.tag === 27) && _.child !== null) {
                                        _.child.return = _,
                                        _ = _.child;
                                        continue
                                    }
                                    if (_ === c)
                                        break;
                                    for (; _.sibling === null; ) {
                                        if (_.return === null || _.return === c)
                                            return;
                                        _ = _.return
                                    }
                                    _.sibling.return = _.return,
                                    _ = _.sibling
                                }
                            else if (Ei)
                                for (var C = c.child; C !== null; ) {
                                    if (C.tag === 5) {
                                        var O = C.stateNode;
                                        _ && M && (O = Am(O, C.type, C.memoizedProps)),
                                        qf(l, O)
                                    } else if (C.tag === 6)
                                        O = C.stateNode,
                                        _ && M && (O = Em(O, C.memoizedProps)),
                                        qf(l, O);
                                    else if (C.tag !== 4) {
                                        if (C.tag === 22 && C.memoizedState !== null)
                                            O = C.child,
                                            O !== null && (O.return = C),
                                            Mf(l, C, !0, !0);
                                        else if (C.child !== null) {
                                            C.child.return = C,
                                            C = C.child;
                                            continue
                                        }
                                    }
                                    if (C === c)
                                        break;
                                    for (; C.sibling === null; ) {
                                        if (C.return === null || C.return === c)
                                            return;
                                        C = C.return
                                    }
                                    C.sibling.return = C.return,
                                    C = C.sibling
                                }
                        }
                        function Cv(l, c, _, M) {
                            if (Ei)
                                for (var C = c.child; C !== null; ) {
                                    if (C.tag === 5) {
                                        var O = C.stateNode;
                                        _ && M && (O = Am(O, C.type, C.memoizedProps)),
                                        Mm(l, O)
                                    } else if (C.tag === 6)
                                        O = C.stateNode,
                                        _ && M && (O = Em(O, C.memoizedProps)),
                                        Mm(l, O);
                                    else if (C.tag !== 4) {
                                        if (C.tag === 22 && C.memoizedState !== null)
                                            O = C.child,
                                            O !== null && (O.return = C),
                                            Cv(l, C, !(C.memoizedProps !== null && C.memoizedProps.mode === "manual"), !0);
                                        else if (C.child !== null) {
                                            C.child.return = C,
                                            C = C.child;
                                            continue
                                        }
                                    }
                                    if (C === c)
                                        break;
                                    for (; C.sibling === null; ) {
                                        if (C.return === null || C.return === c)
                                            return;
                                        C = C.return
                                    }
                                    C.sibling.return = C.return,
                                    C = C.sibling
                                }
                        }
                        function wv(l, c) {
                            if (Ei && Wp(l, c)) {
                                l = c.stateNode;
                                var _ = l.containerInfo
                                  , M = xm();
                                Cv(M, c, !1, !1),
                                l.pendingChildren = M,
                                Os(c),
                                bm(_, M)
                            }
                        }
                        function Yp(l, c, _, M) {
                            if (ci)
                                l.memoizedProps !== M && Os(c);
                            else if (Ei) {
                                var C = l.stateNode
                                  , O = l.memoizedProps;
                                if ((l = Wp(l, c)) || O !== M) {
                                    var j = Bi.current;
                                    O = Qv(C, _, O, M, !l, null),
                                    O === C ? c.stateNode = C : (Xf(O, _, M, j) && Os(c),
                                    c.stateNode = O,
                                    l ? Mf(O, c, !1, !1) : Os(c))
                                } else
                                    c.stateNode = C
                            }
                        }
                        function jp(l, c, _) {
                            if (Hl(c, _)) {
                                if (l.flags |= 16777216,
                                !$u(c, _))
                                    if (tm())
                                        l.flags |= 8192;
                                    else
                                        throw Zo = zc,
                                        od
                            } else
                                l.flags &= -16777217
                        }
                        function Rv(l, c) {
                            if (c_(c)) {
                                if (l.flags |= 16777216,
                                !Bm(c))
                                    if (tm())
                                        l.flags |= 8192;
                                    else
                                        throw Zo = zc,
                                        od
                            } else
                                l.flags &= -16777217
                        }
                        function fs(l, c) {
                            c !== null && (l.flags |= 4),
                            l.flags & 16384 && (c = l.tag !== 22 ? P() : 536870912,
                            l.lanes |= c,
                            Ql |= c)
                        }
                        function Xr(l, c) {
                            if (!Jt)
                                switch (l.tailMode) {
                                case "hidden":
                                    c = l.tail;
                                    for (var _ = null; c !== null; )
                                        c.alternate !== null && (_ = c),
                                        c = c.sibling;
                                    _ === null ? l.tail = null : _.sibling = null;
                                    break;
                                case "collapsed":
                                    _ = l.tail;
                                    for (var M = null; _ !== null; )
                                        _.alternate !== null && (M = _),
                                        _ = _.sibling;
                                    M === null ? c || l.tail === null ? l.tail = null : l.tail.sibling = null : M.sibling = null
                                }
                        }
                        function ai(l) {
                            var c = l.alternate !== null && l.alternate.child === l.child
                              , _ = 0
                              , M = 0;
                            if (c)
                                for (var C = l.child; C !== null; )
                                    _ |= C.lanes | C.childLanes,
                                    M |= C.subtreeFlags & 31457280,
                                    M |= C.flags & 31457280,
                                    C.return = l,
                                    C = C.sibling;
                            else
                                for (C = l.child; C !== null; )
                                    _ |= C.lanes | C.childLanes,
                                    M |= C.subtreeFlags,
                                    M |= C.flags,
                                    C.return = l,
                                    C = C.sibling;
                            return l.subtreeFlags |= M,
                            l.childLanes = _,
                            c
                        }
                        function Nv(l, c, _) {
                            var M = c.pendingProps;
                            switch (Ae(c),
                            c.tag) {
                            case 16:
                            case 15:
                            case 0:
                            case 11:
                            case 7:
                            case 8:
                            case 12:
                            case 9:
                            case 14:
                                return ai(c),
                                null;
                            case 1:
                                return ai(c),
                                null;
                            case 3:
                                return _ = c.stateNode,
                                M = null,
                                l !== null && (M = l.memoizedState.cache),
                                c.memoizedState.cache !== M && (c.flags |= 2048),
                                Ds(jn),
                                Me(),
                                _.pendingContext && (_.context = _.pendingContext,
                                _.pendingContext = null),
                                (l === null || l.child === null) && (bt(c) ? Os(c) : l === null || l.memoizedState.isDehydrated && (c.flags & 256) === 0 || (c.flags |= 1024,
                                aa !== null && (Us(aa),
                                aa = null))),
                                wv(l, c),
                                ai(c),
                                null;
                            case 26:
                                if (na) {
                                    _ = c.type;
                                    var C = c.memoizedState;
                                    return l === null ? (Os(c),
                                    C !== null ? (ai(c),
                                    Rv(c, C)) : (ai(c),
                                    jp(c, _, M))) : C ? C !== l.memoizedState ? (Os(c),
                                    ai(c),
                                    Rv(c, C)) : (ai(c),
                                    c.flags &= -16777217) : (ci ? l.memoizedProps !== M && Os(c) : Yp(l, c, _, M),
                                    ai(c),
                                    jp(c, _, M)),
                                    null
                                }
                            case 27:
                                if (is) {
                                    if (Te(c),
                                    _ = br.current,
                                    C = c.type,
                                    l !== null && c.stateNode != null)
                                        ci ? l.memoizedProps !== M && Os(c) : Yp(l, c, C, M);
                                    else {
                                        if (!M) {
                                            if (c.stateNode === null)
                                                throw Error(o(166));
                                            return ai(c),
                                            null
                                        }
                                        l = Bi.current,
                                        bt(c) ? Ze(c, l) : (l = $f(C, M, _, l, !0),
                                        c.stateNode = l,
                                        Os(c))
                                    }
                                    return ai(c),
                                    null
                                }
                            case 5:
                                if (Te(c),
                                _ = c.type,
                                l !== null && c.stateNode != null)
                                    Yp(l, c, _, M);
                                else {
                                    if (!M) {
                                        if (c.stateNode === null)
                                            throw Error(o(166));
                                        return ai(c),
                                        null
                                    }
                                    l = Bi.current,
                                    bt(c) ? Ze(c, l) : (C = kf(_, M, br.current, l, c),
                                    Mf(C, c, !1, !1),
                                    c.stateNode = C,
                                    Xf(C, _, M, l) && Os(c))
                                }
                                return ai(c),
                                jp(c, c.type, c.pendingProps),
                                null;
                            case 6:
                                if (l && c.stateNode != null)
                                    _ = l.memoizedProps,
                                    ci ? _ !== M && Os(c) : Ei && (_ !== M ? (c.stateNode = Ls(M, br.current, Bi.current, c),
                                    Os(c)) : c.stateNode = l.stateNode);
                                else {
                                    if (typeof M != "string" && c.stateNode === null)
                                        throw Error(o(166));
                                    if (l = br.current,
                                    _ = Bi.current,
                                    bt(c)) {
                                        if (!Tn)
                                            throw Error(o(176));
                                        if (l = c.stateNode,
                                        _ = c.memoizedProps,
                                        M = null,
                                        C = ss,
                                        C !== null)
                                            switch (C.tag) {
                                            case 27:
                                            case 5:
                                                M = C.memoizedProps
                                            }
                                        i_(l, _, c, M) || Je(c)
                                    } else
                                        c.stateNode = Ls(M, l, _, c)
                                }
                                return ai(c),
                                null;
                            case 13:
                                if (M = c.memoizedState,
                                l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
                                    if (C = bt(c),
                                    M !== null && M.dehydrated !== null) {
                                        if (l === null) {
                                            if (!C)
                                                throw Error(o(318));
                                            if (!Tn)
                                                throw Error(o(344));
                                            if (C = c.memoizedState,
                                            C = C !== null ? C.dehydrated : null,
                                            !C)
                                                throw Error(o(317));
                                            s_(C, c)
                                        } else
                                            Ue(),
                                            (c.flags & 128) === 0 && (c.memoizedState = null),
                                            c.flags |= 4;
                                        ai(c),
                                        C = !1
                                    } else
                                        aa !== null && (Us(aa),
                                        aa = null),
                                        C = !0;
                                    if (!C)
                                        return c.flags & 256 ? (Js(c),
                                        c) : (Js(c),
                                        null)
                                }
                                if (Js(c),
                                (c.flags & 128) !== 0)
                                    return c.lanes = _,
                                    c;
                                if (_ = M !== null,
                                l = l !== null && l.memoizedState !== null,
                                _) {
                                    M = c.child,
                                    C = null,
                                    M.alternate !== null && M.alternate.memoizedState !== null && M.alternate.memoizedState.cachePool !== null && (C = M.alternate.memoizedState.cachePool.pool);
                                    var O = null;
                                    M.memoizedState !== null && M.memoizedState.cachePool !== null && (O = M.memoizedState.cachePool.pool),
                                    O !== C && (M.flags |= 2048)
                                }
                                return _ !== l && _ && (c.child.flags |= 8192),
                                fs(c, c.updateQueue),
                                ai(c),
                                null;
                            case 4:
                                return Me(),
                                wv(l, c),
                                l === null && no(c.stateNode.containerInfo),
                                ai(c),
                                null;
                            case 10:
                                return Ds(c.type),
                                ai(c),
                                null;
                            case 19:
                                if (R(Ri),
                                C = c.memoizedState,
                                C === null)
                                    return ai(c),
                                    null;
                                if (M = (c.flags & 128) !== 0,
                                O = C.rendering,
                                O === null)
                                    if (M)
                                        Xr(C, !1);
                                    else {
                                        if (In !== 0 || l !== null && (l.flags & 128) !== 0)
                                            for (l = c.child; l !== null; ) {
                                                if (O = Rs(l),
                                                O !== null) {
                                                    for (c.flags |= 128,
                                                    Xr(C, !1),
                                                    l = O.updateQueue,
                                                    c.updateQueue = l,
                                                    fs(c, l),
                                                    c.subtreeFlags = 0,
                                                    l = _,
                                                    _ = c.child; _ !== null; )
                                                        Iv(_, l),
                                                        _ = _.sibling;
                                                    return N(Ri, Ri.current & 1 | 2),
                                                    c.child
                                                }
                                                l = l.sibling
                                            }
                                        C.tail !== null && Rn() > Zi && (c.flags |= 128,
                                        M = !0,
                                        Xr(C, !1),
                                        c.lanes = 4194304)
                                    }
                                else {
                                    if (!M)
                                        if (l = Rs(O),
                                        l !== null) {
                                            if (c.flags |= 128,
                                            M = !0,
                                            l = l.updateQueue,
                                            c.updateQueue = l,
                                            fs(c, l),
                                            Xr(C, !0),
                                            C.tail === null && C.tailMode === "hidden" && !O.alternate && !Jt)
                                                return ai(c),
                                                null
                                        } else
                                            2 * Rn() - C.renderingStartTime > Zi && _ !== 536870912 && (c.flags |= 128,
                                            M = !0,
                                            Xr(C, !1),
                                            c.lanes = 4194304);
                                    C.isBackwards ? (O.sibling = c.child,
                                    c.child = O) : (l = C.last,
                                    l !== null ? l.sibling = O : c.child = O,
                                    C.last = O)
                                }
                                return C.tail !== null ? (c = C.tail,
                                C.rendering = c,
                                C.tail = c.sibling,
                                C.renderingStartTime = Rn(),
                                c.sibling = null,
                                l = Ri.current,
                                N(Ri, M ? l & 1 | 2 : l & 1),
                                c) : (ai(c),
                                null);
                            case 22:
                            case 23:
                                return Js(c),
                                Ml(),
                                M = c.memoizedState !== null,
                                l !== null ? l.memoizedState !== null !== M && (c.flags |= 8192) : M && (c.flags |= 8192),
                                M ? (_ & 536870912) !== 0 && (c.flags & 128) === 0 && (ai(c),
                                c.subtreeFlags & 6 && (c.flags |= 8192)) : ai(c),
                                _ = c.updateQueue,
                                _ !== null && fs(c, _.retryQueue),
                                _ = null,
                                l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (_ = l.memoizedState.cachePool.pool),
                                M = null,
                                c.memoizedState !== null && c.memoizedState.cachePool !== null && (M = c.memoizedState.cachePool.pool),
                                M !== _ && (c.flags |= 2048),
                                l !== null && R(wr),
                                null;
                            case 24:
                                return _ = null,
                                l !== null && (_ = l.memoizedState.cache),
                                c.memoizedState.cache !== _ && (c.flags |= 2048),
                                Ds(jn),
                                ai(c),
                                null;
                            case 25:
                                return null
                            }
                            throw Error(o(156, c.tag))
                        }
                        function Dv(l, c) {
                            switch (Ae(c),
                            c.tag) {
                            case 1:
                                return l = c.flags,
                                l & 65536 ? (c.flags = l & -65537 | 128,
                                c) : null;
                            case 3:
                                return Ds(jn),
                                Me(),
                                l = c.flags,
                                (l & 65536) !== 0 && (l & 128) === 0 ? (c.flags = l & -65537 | 128,
                                c) : null;
                            case 26:
                            case 27:
                            case 5:
                                return Te(c),
                                null;
                            case 13:
                                if (Js(c),
                                l = c.memoizedState,
                                l !== null && l.dehydrated !== null) {
                                    if (c.alternate === null)
                                        throw Error(o(340));
                                    Ue()
                                }
                                return l = c.flags,
                                l & 65536 ? (c.flags = l & -65537 | 128,
                                c) : null;
                            case 19:
                                return R(Ri),
                                null;
                            case 4:
                                return Me(),
                                null;
                            case 10:
                                return Ds(c.type),
                                null;
                            case 22:
                            case 23:
                                return Js(c),
                                Ml(),
                                l !== null && R(wr),
                                l = c.flags,
                                l & 65536 ? (c.flags = l & -65537 | 128,
                                c) : null;
                            case 24:
                                return Ds(jn),
                                null;
                            case 25:
                                return null;
                            default:
                                return null
                            }
                        }
                        function Zp(l, c) {
                            switch (Ae(c),
                            c.tag) {
                            case 3:
                                Ds(jn),
                                Me();
                                break;
                            case 26:
                            case 27:
                            case 5:
                                Te(c);
                                break;
                            case 4:
                                Me();
                                break;
                            case 13:
                                Js(c);
                                break;
                            case 19:
                                R(Ri);
                                break;
                            case 10:
                                Ds(c.type);
                                break;
                            case 22:
                            case 23:
                                Js(c),
                                Ml(),
                                l !== null && R(wr);
                                break;
                            case 24:
                                Ds(jn)
                            }
                        }
                        function Rl(l, c) {
                            try {
                                var _ = c.updateQueue
                                  , M = _ !== null ? _.lastEffect : null;
                                if (M !== null) {
                                    var C = M.next;
                                    _ = C;
                                    do {
                                        if ((_.tag & l) === l) {
                                            M = void 0;
                                            var O = _.create
                                              , j = _.inst;
                                            M = O(),
                                            j.destroy = M
                                        }
                                        _ = _.next
                                    } while (_ !== C)
                                }
                            } catch (se) {
                                fn(c, c.return, se)
                            }
                        }
                        function Io(l, c, _) {
                            try {
                                var M = c.updateQueue
                                  , C = M !== null ? M.lastEffect : null;
                                if (C !== null) {
                                    var O = C.next;
                                    M = O;
                                    do {
                                        if ((M.tag & l) === l) {
                                            var j = M.inst
                                              , se = j.destroy;
                                            if (se !== void 0) {
                                                j.destroy = void 0,
                                                C = c;
                                                var ge = _;
                                                try {
                                                    se()
                                                } catch (Ie) {
                                                    fn(C, ge, Ie)
                                                }
                                            }
                                        }
                                        M = M.next
                                    } while (M !== O)
                                }
                            } catch (Ie) {
                                fn(c, c.return, Ie)
                            }
                        }
                        function Nl(l) {
                            var c = l.updateQueue;
                            if (c !== null) {
                                var _ = l.stateNode;
                                try {
                                    Qe(c, _)
                                } catch (M) {
                                    fn(l, l.return, M)
                                }
                            }
                        }
                        function bf(l, c, _) {
                            _.props = ka(l.type, l.memoizedProps),
                            _.state = l.memoizedState;
                            try {
                                _.componentWillUnmount()
                            } catch (M) {
                                fn(l, c, M)
                            }
                        }
                        function qa(l, c) {
                            try {
                                var _ = l.ref;
                                if (_ !== null) {
                                    var M = l.stateNode;
                                    switch (l.tag) {
                                    case 26:
                                    case 27:
                                    case 5:
                                        var C = to(M);
                                        break;
                                    default:
                                        C = M
                                    }
                                    typeof _ == "function" ? l.refCleanup = _(C) : _.current = C
                                }
                            } catch (O) {
                                fn(l, c, O)
                            }
                        }
                        function Ss(l, c) {
                            var _ = l.ref
                              , M = l.refCleanup;
                            if (_ !== null)
                                if (typeof M == "function")
                                    try {
                                        M()
                                    } catch (C) {
                                        fn(l, c, C)
                                    } finally {
                                        l.refCleanup = null,
                                        l = l.alternate,
                                        l != null && (l.refCleanup = null)
                                    }
                                else if (typeof _ == "function")
                                    try {
                                        _(null)
                                    } catch (C) {
                                        fn(l, c, C)
                                    }
                                else
                                    _.current = null
                        }
                        function Qp(l) {
                            var c = l.type
                              , _ = l.memoizedProps
                              , M = l.stateNode;
                            try {
                                Zf(M, c, _, l)
                            } catch (C) {
                                fn(l, l.return, C)
                            }
                        }
                        function zo(l, c, _) {
                            try {
                                vm(l.stateNode, l.type, _, c, l)
                            } catch (M) {
                                fn(l, l.return, M)
                            }
                        }
                        function Dl(l) {
                            return l.tag === 5 || l.tag === 3 || (na ? l.tag === 26 : !1) || (is ? l.tag === 27 : !1) || l.tag === 4
                        }
                        function Bu(l) {
                            e: for (; ; ) {
                                for (; l.sibling === null; ) {
                                    if (l.return === null || Dl(l.return))
                                        return null;
                                    l = l.return
                                }
                                for (l.sibling.return = l.return,
                                l = l.sibling; l.tag !== 5 && l.tag !== 6 && (!is || l.tag !== 27) && l.tag !== 18; ) {
                                    if (l.flags & 2 || l.child === null || l.tag === 4)
                                        continue e;
                                    l.child.return = l,
                                    l = l.child
                                }
                                if (!(l.flags & 2))
                                    return l.stateNode
                            }
                        }
                        function Tf(l, c, _) {
                            var M = l.tag;
                            if (M === 5 || M === 6)
                                l = l.stateNode,
                                c ? qv(_, l, c) : gm(_, l);
                            else if (!(M === 4 || is && M === 27) && (l = l.child,
                            l !== null))
                                for (Tf(l, c, _),
                                l = l.sibling; l !== null; )
                                    Tf(l, c, _),
                                    l = l.sibling
                        }
                        function dr(l, c, _) {
                            var M = l.tag;
                            if (M === 5 || M === 6)
                                l = l.stateNode,
                                c ? _m(_, l, c) : jf(_, l);
                            else if (!(M === 4 || is && M === 27) && (l = l.child,
                            l !== null))
                                for (dr(l, c, _),
                                l = l.sibling; l !== null; )
                                    dr(l, c, _),
                                    l = l.sibling
                        }
                        function Kp(l, c, _) {
                            l = l.containerInfo;
                            try {
                                Tm(l, _)
                            } catch (M) {
                                fn(c, c.return, M)
                            }
                        }
                        function Ov(l, c) {
                            for (Hv(l.containerInfo),
                            qt = c; qt !== null; )
                                if (l = qt,
                                c = l.child,
                                (l.subtreeFlags & 1028) !== 0 && c !== null)
                                    c.return = l,
                                    qt = c;
                                else
                                    for (; qt !== null; ) {
                                        l = qt;
                                        var _ = l.alternate;
                                        switch (c = l.flags,
                                        l.tag) {
                                        case 0:
                                            break;
                                        case 11:
                                        case 15:
                                            break;
                                        case 1:
                                            if ((c & 1024) !== 0 && _ !== null) {
                                                c = void 0;
                                                var M = l
                                                  , C = _.memoizedProps;
                                                _ = _.memoizedState;
                                                var O = M.stateNode;
                                                try {
                                                    var j = ka(M.type, C, M.elementType === M.type);
                                                    c = O.getSnapshotBeforeUpdate(j, _),
                                                    O.__reactInternalSnapshotBeforeUpdate = c
                                                } catch (se) {
                                                    fn(M, M.return, se)
                                                }
                                            }
                                            break;
                                        case 3:
                                            (c & 1024) !== 0 && ci && DS(l.stateNode.containerInfo);
                                            break;
                                        case 5:
                                        case 26:
                                        case 27:
                                        case 6:
                                        case 4:
                                        case 17:
                                            break;
                                        default:
                                            if ((c & 1024) !== 0)
                                                throw Error(o(163))
                                        }
                                        if (c = l.sibling,
                                        c !== null) {
                                            c.return = l.return,
                                            qt = c;
                                            break
                                        }
                                        qt = l.return
                                    }
                            return j = on,
                            on = !1,
                            j
                        }
                        function Jp(l, c, _) {
                            var M = _.flags;
                            switch (_.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Wa(l, _),
                                M & 4 && Rl(5, _);
                                break;
                            case 1:
                                if (Wa(l, _),
                                M & 4)
                                    if (l = _.stateNode,
                                    c === null)
                                        try {
                                            l.componentDidMount()
                                        } catch (se) {
                                            fn(_, _.return, se)
                                        }
                                    else {
                                        var C = ka(_.type, c.memoizedProps);
                                        c = c.memoizedState;
                                        try {
                                            l.componentDidUpdate(C, c, l.__reactInternalSnapshotBeforeUpdate)
                                        } catch (se) {
                                            fn(_, _.return, se)
                                        }
                                    }
                                M & 64 && Nl(_),
                                M & 512 && qa(_, _.return);
                                break;
                            case 3:
                                if (Wa(l, _),
                                M & 64 && (M = _.updateQueue,
                                M !== null)) {
                                    if (l = null,
                                    _.child !== null)
                                        switch (_.child.tag) {
                                        case 27:
                                        case 5:
                                            l = to(_.child.stateNode);
                                            break;
                                        case 1:
                                            l = _.child.stateNode
                                        }
                                    try {
                                        Qe(M, l)
                                    } catch (se) {
                                        fn(_, _.return, se)
                                    }
                                }
                                break;
                            case 26:
                                if (na) {
                                    Wa(l, _),
                                    M & 512 && qa(_, _.return);
                                    break
                                }
                            case 27:
                            case 5:
                                Wa(l, _),
                                c === null && M & 4 && Qp(_),
                                M & 512 && qa(_, _.return);
                                break;
                            case 12:
                                Wa(l, _);
                                break;
                            case 13:
                                Wa(l, _),
                                M & 4 && em(l, _);
                                break;
                            case 22:
                                if (C = _.memoizedState !== null || Rr,
                                !C) {
                                    c = c !== null && c.memoizedState !== null || mi;
                                    var O = Rr
                                      , j = mi;
                                    Rr = C,
                                    (mi = c) && !j ? Ya(l, _, (_.subtreeFlags & 8772) !== 0) : Wa(l, _),
                                    Rr = O,
                                    mi = j
                                }
                                M & 512 && (_.memoizedProps.mode === "manual" ? qa(_, _.return) : Ss(_, _.return));
                                break;
                            default:
                                Wa(l, _)
                            }
                        }
                        function Uv(l) {
                            var c = l.alternate;
                            c !== null && (l.alternate = null,
                            Uv(c)),
                            l.child = null,
                            l.deletions = null,
                            l.sibling = null,
                            l.tag === 5 && (c = l.stateNode,
                            c !== null && Nc(c)),
                            l.stateNode = null,
                            l.return = null,
                            l.dependencies = null,
                            l.memoizedProps = null,
                            l.memoizedState = null,
                            l.pendingProps = null,
                            l.stateNode = null,
                            l.updateQueue = null
                        }
                        function Xa(l, c, _) {
                            for (_ = _.child; _ !== null; )
                                $p(l, c, _),
                                _ = _.sibling
                        }
                        function $p(l, c, _) {
                            if (ps && typeof ps.onCommitFiberUnmount == "function")
                                try {
                                    ps.onCommitFiberUnmount(Ic, _)
                                } catch {}
                            switch (_.tag) {
                            case 26:
                                if (na) {
                                    mi || Ss(_, c),
                                    Xa(l, c, _),
                                    _.memoizedState ? l_(_.memoizedState) : _.stateNode && Oc(_.stateNode);
                                    break
                                }
                            case 27:
                                if (is) {
                                    mi || Ss(_, c);
                                    var M = Ut
                                      , C = Kt;
                                    Ut = _.stateNode,
                                    Xa(l, c, _),
                                    Vm(_.stateNode),
                                    Ut = M,
                                    Kt = C;
                                    break
                                }
                            case 5:
                                mi || Ss(_, c);
                            case 6:
                                if (ci) {
                                    if (M = Ut,
                                    C = Kt,
                                    Ut = null,
                                    Xa(l, c, _),
                                    Ut = M,
                                    Kt = C,
                                    Ut !== null)
                                        if (Kt)
                                            try {
                                                Wv(Ut, _.stateNode)
                                            } catch (O) {
                                                fn(_, c, O)
                                            }
                                        else
                                            try {
                                                Xv(Ut, _.stateNode)
                                            } catch (O) {
                                                fn(_, c, O)
                                            }
                                } else
                                    Xa(l, c, _);
                                break;
                            case 18:
                                ci && Ut !== null && (Kt ? o_(Ut, _.stateNode) : Rm(Ut, _.stateNode));
                                break;
                            case 4:
                                ci ? (M = Ut,
                                C = Kt,
                                Ut = _.stateNode.containerInfo,
                                Kt = !0,
                                Xa(l, c, _),
                                Ut = M,
                                Kt = C) : (Ei && Kp(_.stateNode, _, xm()),
                                Xa(l, c, _));
                                break;
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                mi || Io(2, _, c),
                                mi || Io(4, _, c),
                                Xa(l, c, _);
                                break;
                            case 1:
                                mi || (Ss(_, c),
                                M = _.stateNode,
                                typeof M.componentWillUnmount == "function" && bf(_, c, M)),
                                Xa(l, c, _);
                                break;
                            case 21:
                                Xa(l, c, _);
                                break;
                            case 22:
                                mi || Ss(_, c),
                                mi = (M = mi) || _.memoizedState !== null,
                                Xa(l, c, _),
                                mi = M;
                                break;
                            default:
                                Xa(l, c, _)
                            }
                        }
                        function em(l, c) {
                            if (Tn && c.memoizedState === null && (l = c.alternate,
                            l !== null && (l = l.memoizedState,
                            l !== null && (l = l.dehydrated,
                            l !== null))))
                                try {
                                    r_(l)
                                } catch (_) {
                                    fn(c, c.return, _)
                                }
                        }
                        function Lv(l) {
                            switch (l.tag) {
                            case 13:
                            case 19:
                                var c = l.stateNode;
                                return c === null && (c = l.stateNode = new An),
                                c;
                            case 22:
                                return l = l.stateNode,
                                c = l._retryCache,
                                c === null && (c = l._retryCache = new An),
                                c;
                            default:
                                throw Error(o(435, l.tag))
                            }
                        }
                        function Pu(l, c) {
                            var _ = Lv(l);
                            c.forEach(function(M) {
                                var C = Ll.bind(null, l, M);
                                _.has(M) || (_.add(M),
                                M.then(C, C))
                            })
                        }
                        function ri(l, c) {
                            var _ = c.deletions;
                            if (_ !== null)
                                for (var M = 0; M < _.length; M++) {
                                    var C = _[M]
                                      , O = l
                                      , j = c;
                                    if (ci) {
                                        var se = j;
                                        e: for (; se !== null; ) {
                                            switch (se.tag) {
                                            case 27:
                                            case 5:
                                                Ut = se.stateNode,
                                                Kt = !1;
                                                break e;
                                            case 3:
                                                Ut = se.stateNode.containerInfo,
                                                Kt = !0;
                                                break e;
                                            case 4:
                                                Ut = se.stateNode.containerInfo,
                                                Kt = !0;
                                                break e
                                            }
                                            se = se.return
                                        }
                                        if (Ut === null)
                                            throw Error(o(160));
                                        $p(O, j, C),
                                        Ut = null,
                                        Kt = !1
                                    } else
                                        $p(O, j, C);
                                    O = C.alternate,
                                    O !== null && (O.return = null),
                                    C.return = null
                                }
                            if (c.subtreeFlags & 13878)
                                for (c = c.child; c !== null; )
                                    Vu(c, l),
                                    c = c.sibling
                        }
                        function Vu(l, c) {
                            var _ = l.alternate
                              , M = l.flags;
                            switch (l.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                ri(c, l),
                                oi(l),
                                M & 4 && (Io(3, l, l.return),
                                Rl(3, l),
                                Io(5, l, l.return));
                                break;
                            case 1:
                                ri(c, l),
                                oi(l),
                                M & 512 && (mi || _ === null || Ss(_, _.return)),
                                M & 64 && Rr && (l = l.updateQueue,
                                l !== null && (M = l.callbacks,
                                M !== null && (_ = l.shared.hiddenCallbacks,
                                l.shared.hiddenCallbacks = _ === null ? M : _.concat(M))));
                                break;
                            case 26:
                                if (na) {
                                    var C = hi;
                                    ri(c, l),
                                    oi(l),
                                    M & 512 && (mi || _ === null || Ss(_, _.return)),
                                    M & 4 && (M = _ !== null ? _.memoizedState : null,
                                    c = l.memoizedState,
                                    _ === null ? c === null ? l.stateNode === null ? l.stateNode = IS(C, l.type, l.memoizedProps, l) : Im(C, l.type, l.stateNode) : l.stateNode = Lm(C, c, l.memoizedProps) : M !== c ? (M === null ? _.stateNode !== null && Oc(_.stateNode) : l_(M),
                                    c === null ? Im(C, l.type, l.stateNode) : Lm(C, c, l.memoizedProps)) : c === null && l.stateNode !== null && zo(l, l.memoizedProps, _.memoizedProps));
                                    break
                                }
                            case 27:
                                if (is && M & 4 && l.alternate === null) {
                                    C = l.stateNode;
                                    var O = l.memoizedProps;
                                    try {
                                        u_(C),
                                        Pm(l.type, O, C, l)
                                    } catch ($e) {
                                        fn(l, l.return, $e)
                                    }
                                }
                            case 5:
                                if (ri(c, l),
                                oi(l),
                                M & 512 && (mi || _ === null || Ss(_, _.return)),
                                ci) {
                                    if (l.flags & 32) {
                                        c = l.stateNode;
                                        try {
                                            ym(c)
                                        } catch ($e) {
                                            fn(l, l.return, $e)
                                        }
                                    }
                                    M & 4 && l.stateNode != null && (c = l.memoizedProps,
                                    zo(l, c, _ !== null ? _.memoizedProps : c)),
                                    M & 1024 && (qm = !0)
                                }
                                break;
                            case 6:
                                if (ri(c, l),
                                oi(l),
                                M & 4 && ci) {
                                    if (l.stateNode === null)
                                        throw Error(o(162));
                                    M = l.memoizedProps,
                                    _ = _ !== null ? _.memoizedProps : M,
                                    c = l.stateNode;
                                    try {
                                        so(c, _, M)
                                    } catch ($e) {
                                        fn(l, l.return, $e)
                                    }
                                }
                                break;
                            case 3:
                                if (na ? (Jf(),
                                C = hi,
                                hi = ah(c.containerInfo),
                                ri(c, l),
                                hi = C) : ri(c, l),
                                oi(l),
                                M & 4) {
                                    if (ci && Tn && _ !== null && _.memoizedState.isDehydrated)
                                        try {
                                            a_(c.containerInfo)
                                        } catch ($e) {
                                            fn(l, l.return, $e)
                                        }
                                    if (Ei) {
                                        M = c.containerInfo,
                                        _ = c.pendingChildren;
                                        try {
                                            Tm(M, _)
                                        } catch ($e) {
                                            fn(l, l.return, $e)
                                        }
                                    }
                                }
                                qm && (qm = !1,
                                Ol(l));
                                break;
                            case 4:
                                na ? (_ = hi,
                                hi = ah(l.stateNode.containerInfo),
                                ri(c, l),
                                oi(l),
                                hi = _) : (ri(c, l),
                                oi(l)),
                                M & 4 && Ei && Kp(l.stateNode, l, l.stateNode.pendingChildren);
                                break;
                            case 12:
                                ri(c, l),
                                oi(l);
                                break;
                            case 13:
                                ri(c, l),
                                oi(l),
                                l.child.flags & 8192 && l.memoizedState !== null != (_ !== null && _.memoizedState !== null) && (dd = Rn()),
                                M & 4 && (M = l.updateQueue,
                                M !== null && (l.updateQueue = null,
                                Pu(l, M)));
                                break;
                            case 22:
                                M & 512 && (mi || _ === null || Ss(_, _.return)),
                                C = l.memoizedState !== null;
                                var j = _ !== null && _.memoizedState !== null
                                  , se = Rr
                                  , ge = mi;
                                if (Rr = se || C,
                                mi = ge || j,
                                ri(c, l),
                                mi = ge,
                                Rr = se,
                                oi(l),
                                c = l.stateNode,
                                c._current = l,
                                c._visibility &= -3,
                                c._visibility |= c._pendingVisibility & 2,
                                M & 8192 && (c._visibility = C ? c._visibility & -2 : c._visibility | 1,
                                C && (c = Rr || mi,
                                _ === null || j || c || Wr(l)),
                                ci && (l.memoizedProps === null || l.memoizedProps.mode !== "manual"))) {
                                    e: if (_ = null,
                                    ci)
                                        for (c = l; ; ) {
                                            if (c.tag === 5 || na && c.tag === 26 || is && c.tag === 27) {
                                                if (_ === null) {
                                                    j = _ = c;
                                                    try {
                                                        O = j.stateNode,
                                                        C ? Yv(O) : Sm(j.stateNode, j.memoizedProps)
                                                    } catch ($e) {
                                                        fn(j, j.return, $e)
                                                    }
                                                }
                                            } else if (c.tag === 6) {
                                                if (_ === null) {
                                                    j = c;
                                                    try {
                                                        var Ie = j.stateNode;
                                                        C ? jv(Ie) : Zv(Ie, j.memoizedProps)
                                                    } catch ($e) {
                                                        fn(j, j.return, $e)
                                                    }
                                                }
                                            } else if ((c.tag !== 22 && c.tag !== 23 || c.memoizedState === null || c === l) && c.child !== null) {
                                                c.child.return = c,
                                                c = c.child;
                                                continue
                                            }
                                            if (c === l)
                                                break e;
                                            for (; c.sibling === null; ) {
                                                if (c.return === null || c.return === l)
                                                    break e;
                                                _ === c && (_ = null),
                                                c = c.return
                                            }
                                            _ === c && (_ = null),
                                            c.sibling.return = c.return,
                                            c = c.sibling
                                        }
                                }
                                M & 4 && (M = l.updateQueue,
                                M !== null && (_ = M.retryQueue,
                                _ !== null && (M.retryQueue = null,
                                Pu(l, _))));
                                break;
                            case 19:
                                ri(c, l),
                                oi(l),
                                M & 4 && (M = l.updateQueue,
                                M !== null && (l.updateQueue = null,
                                Pu(l, M)));
                                break;
                            case 21:
                                break;
                            default:
                                ri(c, l),
                                oi(l)
                            }
                        }
                        function oi(l) {
                            var c = l.flags;
                            if (c & 2) {
                                try {
                                    if (ci && (!is || l.tag !== 27)) {
                                        e: {
                                            for (var _ = l.return; _ !== null; ) {
                                                if (Dl(_)) {
                                                    var M = _;
                                                    break e
                                                }
                                                _ = _.return
                                            }
                                            throw Error(o(160))
                                        }
                                        switch (M.tag) {
                                        case 27:
                                            if (is) {
                                                var C = M.stateNode;
                                                dr(l, Bu(l), C);
                                                break
                                            }
                                        case 5:
                                            var O = M.stateNode;
                                            M.flags & 32 && (ym(O),
                                            M.flags &= -33),
                                            dr(l, Bu(l), O);
                                            break;
                                        case 3:
                                        case 4:
                                            var j = M.stateNode.containerInfo;
                                            Tf(l, Bu(l), j);
                                            break;
                                        default:
                                            throw Error(o(161))
                                        }
                                    }
                                } catch (se) {
                                    fn(l, l.return, se)
                                }
                                l.flags &= -3
                            }
                            c & 4096 && (l.flags &= -4097)
                        }
                        function Ol(l) {
                            if (l.subtreeFlags & 1024)
                                for (l = l.child; l !== null; ) {
                                    var c = l;
                                    Ol(c),
                                    c.tag === 5 && c.flags & 1024 && fm(c.stateNode),
                                    l = l.sibling
                                }
                        }
                        function Wa(l, c) {
                            if (c.subtreeFlags & 8772)
                                for (c = c.child; c !== null; )
                                    Jp(l, c.alternate, c),
                                    c = c.sibling
                        }
                        function Wr(l) {
                            for (l = l.child; l !== null; ) {
                                var c = l;
                                switch (c.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Io(4, c, c.return),
                                    Wr(c);
                                    break;
                                case 1:
                                    Ss(c, c.return);
                                    var _ = c.stateNode;
                                    typeof _.componentWillUnmount == "function" && bf(c, c.return, _),
                                    Wr(c);
                                    break;
                                case 26:
                                case 27:
                                case 5:
                                    Ss(c, c.return),
                                    Wr(c);
                                    break;
                                case 22:
                                    Ss(c, c.return),
                                    c.memoizedState === null && Wr(c);
                                    break;
                                default:
                                    Wr(c)
                                }
                                l = l.sibling
                            }
                        }
                        function Ya(l, c, _) {
                            for (_ = _ && (c.subtreeFlags & 8772) !== 0,
                            c = c.child; c !== null; ) {
                                var M = c.alternate
                                  , C = l
                                  , O = c
                                  , j = O.flags;
                                switch (O.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ya(C, O, _),
                                    Rl(4, O);
                                    break;
                                case 1:
                                    if (Ya(C, O, _),
                                    M = O,
                                    C = M.stateNode,
                                    typeof C.componentDidMount == "function")
                                        try {
                                            C.componentDidMount()
                                        } catch (Ie) {
                                            fn(M, M.return, Ie)
                                        }
                                    if (M = O,
                                    C = M.updateQueue,
                                    C !== null) {
                                        var se = M.stateNode;
                                        try {
                                            var ge = C.shared.hiddenCallbacks;
                                            if (ge !== null)
                                                for (C.shared.hiddenCallbacks = null,
                                                C = 0; C < ge.length; C++)
                                                    it(ge[C], se)
                                        } catch (Ie) {
                                            fn(M, M.return, Ie)
                                        }
                                    }
                                    _ && j & 64 && Nl(O),
                                    qa(O, O.return);
                                    break;
                                case 26:
                                case 27:
                                case 5:
                                    Ya(C, O, _),
                                    _ && M === null && j & 4 && Qp(O),
                                    qa(O, O.return);
                                    break;
                                case 12:
                                    Ya(C, O, _);
                                    break;
                                case 13:
                                    Ya(C, O, _),
                                    _ && j & 4 && em(C, O);
                                    break;
                                case 22:
                                    O.memoizedState === null && Ya(C, O, _),
                                    qa(O, O.return);
                                    break;
                                default:
                                    Ya(C, O, _)
                                }
                                c = c.sibling
                            }
                        }
                        function Fu(l, c) {
                            var _ = null;
                            l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (_ = l.memoizedState.cachePool.pool),
                            l = null,
                            c.memoizedState !== null && c.memoizedState.cachePool !== null && (l = c.memoizedState.cachePool.pool),
                            l !== _ && (l != null && l.refCount++,
                            _ != null && xc(_))
                        }
                        function Yr(l, c) {
                            l = null,
                            c.alternate !== null && (l = c.alternate.memoizedState.cache),
                            c = c.memoizedState.cache,
                            c !== l && (c.refCount++,
                            l != null && xc(l))
                        }
                        function jr(l, c, _, M) {
                            if (c.subtreeFlags & 10256)
                                for (c = c.child; c !== null; )
                                    Hu(l, c, _, M),
                                    c = c.sibling
                        }
                        function Hu(l, c, _, M) {
                            var C = c.flags;
                            switch (c.tag) {
                            case 0:
                            case 11:
                            case 15:
                                jr(l, c, _, M),
                                C & 2048 && Rl(9, c);
                                break;
                            case 3:
                                jr(l, c, _, M),
                                C & 2048 && (l = null,
                                c.alternate !== null && (l = c.alternate.memoizedState.cache),
                                c = c.memoizedState.cache,
                                c !== l && (c.refCount++,
                                l != null && xc(l)));
                                break;
                            case 12:
                                if (C & 2048) {
                                    jr(l, c, _, M),
                                    l = c.stateNode;
                                    try {
                                        var O = c.memoizedProps
                                          , j = O.id
                                          , se = O.onPostCommit;
                                        typeof se == "function" && se(j, c.alternate === null ? "mount" : "update", l.passiveEffectDuration, -0)
                                    } catch (ge) {
                                        fn(c, c.return, ge)
                                    }
                                } else
                                    jr(l, c, _, M);
                                break;
                            case 23:
                                break;
                            case 22:
                                O = c.stateNode,
                                c.memoizedState !== null ? O._visibility & 4 ? jr(l, c, _, M) : Gu(l, c) : O._visibility & 4 ? jr(l, c, _, M) : (O._visibility |= 4,
                                ja(l, c, _, M, (c.subtreeFlags & 10256) !== 0)),
                                C & 2048 && Fu(c.alternate, c);
                                break;
                            case 24:
                                jr(l, c, _, M),
                                C & 2048 && Yr(c.alternate, c);
                                break;
                            default:
                                jr(l, c, _, M)
                            }
                        }
                        function ja(l, c, _, M, C) {
                            for (C = C && (c.subtreeFlags & 10256) !== 0,
                            c = c.child; c !== null; ) {
                                var O = l
                                  , j = c
                                  , se = _
                                  , ge = M
                                  , Ie = j.flags;
                                switch (j.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ja(O, j, se, ge, C),
                                    Rl(8, j);
                                    break;
                                case 23:
                                    break;
                                case 22:
                                    var $e = j.stateNode;
                                    j.memoizedState !== null ? $e._visibility & 4 ? ja(O, j, se, ge, C) : Gu(O, j) : ($e._visibility |= 4,
                                    ja(O, j, se, ge, C)),
                                    C && Ie & 2048 && Fu(j.alternate, j);
                                    break;
                                case 24:
                                    ja(O, j, se, ge, C),
                                    C && Ie & 2048 && Yr(j.alternate, j);
                                    break;
                                default:
                                    ja(O, j, se, ge, C)
                                }
                                c = c.sibling
                            }
                        }
                        function Gu(l, c) {
                            if (c.subtreeFlags & 10256)
                                for (c = c.child; c !== null; ) {
                                    var _ = l
                                      , M = c
                                      , C = M.flags;
                                    switch (M.tag) {
                                    case 22:
                                        Gu(_, M),
                                        C & 2048 && Fu(M.alternate, M);
                                        break;
                                    case 24:
                                        Gu(_, M),
                                        C & 2048 && Yr(M.alternate, M);
                                        break;
                                    default:
                                        Gu(_, M)
                                    }
                                    c = c.sibling
                                }
                        }
                        function Li(l) {
                            if (l.subtreeFlags & la)
                                for (l = l.child; l !== null; )
                                    Af(l),
                                    l = l.sibling
                        }
                        function Af(l) {
                            switch (l.tag) {
                            case 26:
                                Li(l),
                                l.flags & la && (l.memoizedState !== null ? rh(hi, l.memoizedState, l.memoizedProps) : Gl(l.type, l.memoizedProps));
                                break;
                            case 5:
                                Li(l),
                                l.flags & la && Gl(l.type, l.memoizedProps);
                                break;
                            case 3:
                            case 4:
                                if (na) {
                                    var c = hi;
                                    hi = ah(l.stateNode.containerInfo),
                                    Li(l),
                                    hi = c
                                } else
                                    Li(l);
                                break;
                            case 22:
                                l.memoizedState === null && (c = l.alternate,
                                c !== null && c.memoizedState !== null ? (c = la,
                                la = 16777216,
                                Li(l),
                                la = c) : Li(l));
                                break;
                            default:
                                Li(l)
                            }
                        }
                        function pr(l) {
                            var c = l.alternate;
                            if (c !== null && (l = c.child,
                            l !== null)) {
                                c.child = null;
                                do
                                    c = l.sibling,
                                    l.sibling = null,
                                    l = c;
                                while (l !== null)
                            }
                        }
                        function bc(l) {
                            var c = l.deletions;
                            if ((l.flags & 16) !== 0) {
                                if (c !== null)
                                    for (var _ = 0; _ < c.length; _++) {
                                        var M = c[_];
                                        qt = M,
                                        Ef(M, l)
                                    }
                                pr(l)
                            }
                            if (l.subtreeFlags & 10256)
                                for (l = l.child; l !== null; )
                                    ku(l),
                                    l = l.sibling
                        }
                        function ku(l) {
                            switch (l.tag) {
                            case 0:
                            case 11:
                            case 15:
                                bc(l),
                                l.flags & 2048 && Io(9, l, l.return);
                                break;
                            case 3:
                                bc(l);
                                break;
                            case 12:
                                bc(l);
                                break;
                            case 22:
                                var c = l.stateNode;
                                l.memoizedState !== null && c._visibility & 4 && (l.return === null || l.return.tag !== 13) ? (c._visibility &= -5,
                                mr(l)) : bc(l);
                                break;
                            default:
                                bc(l)
                            }
                        }
                        function mr(l) {
                            var c = l.deletions;
                            if ((l.flags & 16) !== 0) {
                                if (c !== null)
                                    for (var _ = 0; _ < c.length; _++) {
                                        var M = c[_];
                                        qt = M,
                                        Ef(M, l)
                                    }
                                pr(l)
                            }
                            for (l = l.child; l !== null; ) {
                                switch (c = l,
                                c.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Io(8, c, c.return),
                                    mr(c);
                                    break;
                                case 22:
                                    _ = c.stateNode,
                                    _._visibility & 4 && (_._visibility &= -5,
                                    mr(c));
                                    break;
                                default:
                                    mr(c)
                                }
                                l = l.sibling
                            }
                        }
                        function Ef(l, c) {
                            for (; qt !== null; ) {
                                var _ = qt;
                                switch (_.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Io(8, _, c);
                                    break;
                                case 23:
                                case 22:
                                    if (_.memoizedState !== null && _.memoizedState.cachePool !== null) {
                                        var M = _.memoizedState.cachePool.pool;
                                        M != null && M.refCount++
                                    }
                                    break;
                                case 24:
                                    xc(_.memoizedState.cache)
                                }
                                if (M = _.child,
                                M !== null)
                                    M.return = _,
                                    qt = M;
                                else
                                    e: for (_ = l; qt !== null; ) {
                                        M = qt;
                                        var C = M.sibling
                                          , O = M.return;
                                        if (Uv(M),
                                        M === _) {
                                            qt = null;
                                            break e
                                        }
                                        if (C !== null) {
                                            C.return = O,
                                            qt = C;
                                            break e
                                        }
                                        qt = O
                                    }
                            }
                        }
                        function Cf(l) {
                            var c = Ju(l);
                            if (c != null) {
                                if (typeof c.memoizedProps["data-testname"] != "string")
                                    throw Error(o(364));
                                return c
                            }
                            if (l = dm(l),
                            l === null)
                                throw Error(o(362));
                            return l.stateNode.current
                        }
                        function qu(l, c) {
                            var _ = l.tag;
                            switch (c.$$typeof) {
                            case Fc:
                                if (l.type === c.value)
                                    return !0;
                                break;
                            case Oa:
                                e: {
                                    for (c = c.value,
                                    l = [l, 0],
                                    _ = 0; _ < l.length; ) {
                                        var M = l[_++]
                                          , C = M.tag
                                          , O = l[_++]
                                          , j = c[O];
                                        if (C !== 5 && C !== 26 && C !== 27 || !zi(M)) {
                                            for (; j != null && qu(M, j); )
                                                O++,
                                                j = c[O];
                                            if (O === c.length) {
                                                c = !0;
                                                break e
                                            } else
                                                for (M = M.child; M !== null; )
                                                    l.push(M, O),
                                                    M = M.sibling
                                        }
                                    }
                                    c = !1
                                }
                                return c;
                            case ti:
                                if ((_ === 5 || _ === 26 || _ === 27) && xi(l.stateNode, c.value))
                                    return !0;
                                break;
                            case Nr:
                                if ((_ === 5 || _ === 6 || _ === 26 || _ === 27) && (l = mm(l),
                                l !== null && 0 <= l.indexOf(c.value)))
                                    return !0;
                                break;
                            case er:
                                if ((_ === 5 || _ === 26 || _ === 27) && (l = l.memoizedProps["data-testname"],
                                typeof l == "string" && l.toLowerCase() === c.value.toLowerCase()))
                                    return !0;
                                break;
                            default:
                                throw Error(o(365))
                            }
                            return !1
                        }
                        function wf(l) {
                            switch (l.$$typeof) {
                            case Fc:
                                return "<" + (f(l.value) || "Unknown") + ">";
                            case Oa:
                                return ":has(" + (wf(l) || "") + ")";
                            case ti:
                                return '[role="' + l.value + '"]';
                            case Nr:
                                return '"' + l.value + '"';
                            case er:
                                return '[data-testname="' + l.value + '"]';
                            default:
                                throw Error(o(365))
                            }
                        }
                        function ea(l, c) {
                            var _ = [];
                            l = [l, 0];
                            for (var M = 0; M < l.length; ) {
                                var C = l[M++]
                                  , O = C.tag
                                  , j = l[M++]
                                  , se = c[j];
                                if (O !== 5 && O !== 26 && O !== 27 || !zi(C)) {
                                    for (; se != null && qu(C, se); )
                                        j++,
                                        se = c[j];
                                    if (j === c.length)
                                        _.push(C);
                                    else
                                        for (C = C.child; C !== null; )
                                            l.push(C, j),
                                            C = C.sibling
                                }
                            }
                            return _
                        }
                        function Bo(l, c) {
                            if (!th)
                                throw Error(o(363));
                            l = Cf(l),
                            l = ea(l, c),
                            c = [],
                            l = Array.from(l);
                            for (var _ = 0; _ < l.length; ) {
                                var M = l[_++]
                                  , C = M.tag;
                                if (C === 5 || C === 26 || C === 27)
                                    zi(M) || c.push(M.stateNode);
                                else
                                    for (M = M.child; M !== null; )
                                        l.push(M),
                                        M = M.sibling
                            }
                            return c
                        }
                        function Xi() {
                            if ((bn & 2) !== 0 && mn !== 0)
                                return mn & -mn;
                            if (zt.T !== null) {
                                var l = Xl;
                                return l !== 0 ? l : Oe()
                            }
                            return Ci()
                        }
                        function Xu() {
                            Ps === 0 && (Ps = (mn & 536870912) === 0 || Jt ? B() : 536870912);
                            var l = Un.current;
                            return l !== null && (l.flags |= 32),
                            Ps
                        }
                        function Ii(l, c, _) {
                            (l === Nn && Ln === 2 || l.cancelPendingCommit !== null) && (Po(l, 0),
                            Wi(l, mn, Ps, !1)),
                            K(l, _),
                            ((bn & 2) === 0 || l !== Nn) && (l === Nn && ((bn & 2) === 0 && (bs |= _),
                            In === 4 && Wi(l, mn, Ps, !1)),
                            ke(l))
                        }
                        function ta(l, c, _) {
                            if ((bn & 6) !== 0)
                                throw Error(o(327));
                            var M = !_ && (c & 60) === 0 && (c & l.expiredLanes) === 0 || I(l, c)
                              , C = M ? nm(l, c) : _r(l, c, !0)
                              , O = M;
                            do {
                                if (C === 0) {
                                    ho && !M && Wi(l, c, 0, !1);
                                    break
                                } else if (C === 6)
                                    Wi(l, c, 0, !Ua);
                                else {
                                    if (_ = l.current.alternate,
                                    O && !gr(_)) {
                                        C = _r(l, c, !1),
                                        O = !1;
                                        continue
                                    }
                                    if (C === 2) {
                                        if (O = c,
                                        l.errorRecoveryDisabledLanes & O)
                                            var j = 0;
                                        else
                                            j = l.pendingLanes & -536870913,
                                            j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
                                        if (j !== 0) {
                                            c = j;
                                            e: {
                                                var se = l;
                                                C = fo;
                                                var ge = Tn && se.current.memoizedState.isDehydrated;
                                                if (ge && (Po(se, j).flags |= 256),
                                                j = _r(se, j, !1),
                                                j !== 2) {
                                                    if (Dr && !ge) {
                                                        se.errorRecoveryDisabledLanes |= O,
                                                        bs |= O,
                                                        C = 4;
                                                        break e
                                                    }
                                                    O = La,
                                                    La = C,
                                                    O !== null && Us(O)
                                                }
                                                C = j
                                            }
                                            if (O = !1,
                                            C !== 2)
                                                continue
                                        }
                                    }
                                    if (C === 1) {
                                        Po(l, 0),
                                        Wi(l, c, 0, !0);
                                        break
                                    }
                                    e: {
                                        switch (M = l,
                                        C) {
                                        case 0:
                                        case 1:
                                            throw Error(o(345));
                                        case 4:
                                            if ((c & 4194176) === c) {
                                                Wi(M, c, Ps, !Ua);
                                                break e
                                            }
                                            break;
                                        case 2:
                                            La = null;
                                            break;
                                        case 3:
                                        case 5:
                                            break;
                                        default:
                                            throw Error(o(329))
                                        }
                                        if (M.finishedWork = _,
                                        M.finishedLanes = c,
                                        (c & 62914560) === c && (O = dd + 300 - Rn(),
                                        10 < O)) {
                                            if (Wi(M, c, Ps, !Ua),
                                            z(M, 0) !== 0)
                                                break e;
                                            M.timeoutHandle = wa(Zr.bind(null, M, _, La, gh, Vs, c, Ps, bs, Ql, Ua, 2, -0, 0), O);
                                            break e
                                        }
                                        Zr(M, _, La, gh, Vs, c, Ps, bs, Ql, Ua, 0, -0, 0)
                                    }
                                }
                                break
                            } while (!0);
                            ke(l)
                        }
                        function Us(l) {
                            La === null ? La = l : La.push.apply(La, l)
                        }
                        function Zr(l, c, _, M, C, O, j, se, ge, Ie, $e, lt, ct) {
                            var Yt = c.subtreeFlags;
                            if ((Yt & 8192 || (Yt & 16785408) === 16785408) && (eh(),
                            Af(c),
                            c = NS(),
                            c !== null)) {
                                l.cancelPendingCommit = c(Tc.bind(null, l, _, M, C, j, se, ge, 1, lt, ct)),
                                Wi(l, O, j, !Ie);
                                return
                            }
                            Tc(l, _, M, C, j, se, ge, $e, lt, ct)
                        }
                        function gr(l) {
                            for (var c = l; ; ) {
                                var _ = c.tag;
                                if ((_ === 0 || _ === 11 || _ === 15) && c.flags & 16384 && (_ = c.updateQueue,
                                _ !== null && (_ = _.stores,
                                _ !== null)))
                                    for (var M = 0; M < _.length; M++) {
                                        var C = _[M]
                                          , O = C.getSnapshot;
                                        C = C.value;
                                        try {
                                            if (!Is(O(), C))
                                                return !1
                                        } catch {
                                            return !1
                                        }
                                    }
                                if (_ = c.child,
                                c.subtreeFlags & 16384 && _ !== null)
                                    _.return = c,
                                    c = _;
                                else {
                                    if (c === l)
                                        break;
                                    for (; c.sibling === null; ) {
                                        if (c.return === null || c.return === l)
                                            return !0;
                                        c = c.return
                                    }
                                    c.sibling.return = c.return,
                                    c = c.sibling
                                }
                            }
                            return !0
                        }
                        function Wi(l, c, _, M) {
                            c &= ~mh,
                            c &= ~bs,
                            l.suspendedLanes |= c,
                            l.pingedLanes &= ~c,
                            M && (l.warmLanes |= c),
                            M = l.expirationTimes;
                            for (var C = c; 0 < C; ) {
                                var O = 31 - ia(C)
                                  , j = 1 << O;
                                M[O] = -1,
                                C &= ~j
                            }
                            _ !== 0 && te(l, _, c)
                        }
                        function vr() {
                            return (bn & 6) === 0 ? (Nt(0, !1),
                            !1) : !0
                        }
                        function Rf() {
                            if (Bt !== null) {
                                if (Ln === 0)
                                    var l = Bt.return;
                                else
                                    l = Bt,
                                    oa = $a = null,
                                    Tl(l),
                                    lo = null,
                                    Bc = 0,
                                    l = Bt;
                                for (; l !== null; )
                                    Zp(l.alternate, l),
                                    l = l.return;
                                Bt = null
                            }
                        }
                        function Po(l, c) {
                            l.finishedWork = null,
                            l.finishedLanes = 0;
                            var _ = l.timeoutHandle;
                            _ !== Ku && (l.timeoutHandle = Ku,
                            Xo(_)),
                            _ = l.cancelPendingCommit,
                            _ !== null && (l.cancelPendingCommit = null,
                            _()),
                            Rf(),
                            Nn = l,
                            Bt = _ = Ho(l.current, null),
                            mn = c,
                            Ln = 0,
                            Bs = null,
                            Ua = !1,
                            ho = I(l, c),
                            Dr = !1,
                            Ql = Ps = mh = bs = ua = In = 0,
                            La = fo = null,
                            Vs = !1,
                            (c & 8) !== 0 && (c |= c & 32);
                            var M = l.entangledLanes;
                            if (M !== 0)
                                for (l = l.entanglements,
                                M &= c; 0 < M; ) {
                                    var C = 31 - ia(M)
                                      , O = 1 << C;
                                    c |= l[C],
                                    M &= ~O
                                }
                            return qn = c,
                            Ce(),
                            _
                        }
                        function Nf(l, c) {
                            St = null,
                            zt.H = ui,
                            c === Yl ? (c = Tt(),
                            Ln = 3) : c === od ? (c = Tt(),
                            Ln = 4) : Ln = c === hd ? 8 : c !== null && typeof c == "object" && typeof c.then == "function" ? 6 : 1,
                            Bs = c,
                            Bt === null && (In = 1,
                            df(l, ne(c, l.current)))
                        }
                        function tm() {
                            var l = Un.current;
                            return l === null ? !0 : (mn & 4194176) === mn ? Cr === null : (mn & 62914560) === mn || (mn & 536870912) !== 0 ? l === Cr : !1
                        }
                        function Yi() {
                            var l = zt.H;
                            return zt.H = ui,
                            l === null ? ui : l
                        }
                        function Wn() {
                            var l = zt.A;
                            return zt.A = Vc,
                            l
                        }
                        function hn() {
                            In = 4,
                            Ua || (mn & 4194176) !== mn && Un.current !== null || (ho = !0),
                            (ua & 134217727) === 0 && (bs & 134217727) === 0 || Nn === null || Wi(Nn, mn, Ps, !1)
                        }
                        function _r(l, c, _) {
                            var M = bn;
                            bn |= 2;
                            var C = Yi()
                              , O = Wn();
                            (Nn !== l || mn !== c) && (gh = null,
                            Po(l, c)),
                            c = !1;
                            var j = In;
                            e: do
                                try {
                                    if (Ln !== 0 && Bt !== null) {
                                        var se = Bt
                                          , ge = Bs;
                                        switch (Ln) {
                                        case 8:
                                            Rf(),
                                            j = 6;
                                            break e;
                                        case 3:
                                        case 2:
                                        case 6:
                                            Un.current === null && (c = !0);
                                            var Ie = Ln;
                                            if (Ln = 0,
                                            Bs = null,
                                            Za(l, se, ge, Ie),
                                            _ && ho) {
                                                j = 0;
                                                break e
                                            }
                                            break;
                                        default:
                                            Ie = Ln,
                                            Ln = 0,
                                            Bs = null,
                                            Za(l, se, ge, Ie)
                                        }
                                    }
                                    Ea(),
                                    j = In;
                                    break
                                } catch ($e) {
                                    Nf(l, $e)
                                }
                            while (!0);
                            return c && l.shellSuspendCounter++,
                            oa = $a = null,
                            bn = M,
                            zt.H = C,
                            zt.A = O,
                            Bt === null && (Nn = null,
                            mn = 0,
                            Ce()),
                            j
                        }
                        function Ea() {
                            for (; Bt !== null; )
                                im(Bt)
                        }
                        function nm(l, c) {
                            var _ = bn;
                            bn |= 2;
                            var M = Yi()
                              , C = Wn();
                            Nn !== l || mn !== c ? (gh = null,
                            Zi = Rn() + 500,
                            Po(l, c)) : ho = I(l, c);
                            e: do
                                try {
                                    if (Ln !== 0 && Bt !== null) {
                                        c = Bt;
                                        var O = Bs;
                                        t: switch (Ln) {
                                        case 1:
                                            Ln = 0,
                                            Bs = null,
                                            Za(l, c, O, 1);
                                            break;
                                        case 2:
                                            if (We(O)) {
                                                Ln = 0,
                                                Bs = null,
                                                sm(c);
                                                break
                                            }
                                            c = function() {
                                                Ln === 2 && Nn === l && (Ln = 7),
                                                ke(l)
                                            }
                                            ,
                                            O.then(c, c);
                                            break e;
                                        case 3:
                                            Ln = 7;
                                            break e;
                                        case 4:
                                            Ln = 5;
                                            break e;
                                        case 7:
                                            We(O) ? (Ln = 0,
                                            Bs = null,
                                            sm(c)) : (Ln = 0,
                                            Bs = null,
                                            Za(l, c, O, 7));
                                            break;
                                        case 5:
                                            var j = null;
                                            switch (Bt.tag) {
                                            case 26:
                                                j = Bt.memoizedState;
                                            case 5:
                                            case 27:
                                                var se = Bt
                                                  , ge = se.type
                                                  , Ie = se.pendingProps;
                                                if (j ? Bm(j) : $u(ge, Ie)) {
                                                    Ln = 0,
                                                    Bs = null;
                                                    var $e = se.sibling;
                                                    if ($e !== null)
                                                        Bt = $e;
                                                    else {
                                                        var lt = se.return;
                                                        lt !== null ? (Bt = lt,
                                                        yr(lt)) : Bt = null
                                                    }
                                                    break t
                                                }
                                            }
                                            Ln = 0,
                                            Bs = null,
                                            Za(l, c, O, 5);
                                            break;
                                        case 6:
                                            Ln = 0,
                                            Bs = null,
                                            Za(l, c, O, 6);
                                            break;
                                        case 8:
                                            Rf(),
                                            In = 6;
                                            break e;
                                        default:
                                            throw Error(o(462))
                                        }
                                    }
                                    Vo();
                                    break
                                } catch (ct) {
                                    Nf(l, ct)
                                }
                            while (!0);
                            return oa = $a = null,
                            zt.H = M,
                            zt.A = C,
                            bn = _,
                            Bt !== null ? 0 : (Nn = null,
                            mn = 0,
                            Ce(),
                            In)
                        }
                        function Vo() {
                            for (; Bt !== null && !BS(); )
                                im(Bt)
                        }
                        function im(l) {
                            var c = kp(l.alternate, l, qn);
                            l.memoizedProps = l.pendingProps,
                            c === null ? yr(l) : Bt = c
                        }
                        function sm(l) {
                            var c = l
                              , _ = c.alternate;
                            switch (c.tag) {
                            case 15:
                            case 0:
                                c = xv(_, c, c.pendingProps, c.type, void 0, mn);
                                break;
                            case 11:
                                c = xv(_, c, c.pendingProps, c.type.render, c.ref, mn);
                                break;
                            case 5:
                                Tl(c);
                            default:
                                Zp(_, c),
                                c = Bt = Iv(c, qn),
                                c = kp(_, c, qn)
                            }
                            l.memoizedProps = l.pendingProps,
                            c === null ? yr(l) : Bt = c
                        }
                        function Za(l, c, _, M) {
                            oa = $a = null,
                            Tl(c),
                            lo = null,
                            Bc = 0;
                            var C = c.return;
                            try {
                                if (vv(l, C, c, _, mn)) {
                                    In = 1,
                                    df(l, ne(_, l.current)),
                                    Bt = null;
                                    return
                                }
                            } catch (O) {
                                if (C !== null)
                                    throw Bt = C,
                                    O;
                                In = 1,
                                df(l, ne(_, l.current)),
                                Bt = null;
                                return
                            }
                            c.flags & 32768 ? (Jt || M === 1 ? l = !0 : ho || (mn & 536870912) !== 0 ? l = !1 : (Ua = l = !0,
                            (M === 2 || M === 3 || M === 6) && (M = Un.current,
                            M !== null && M.tag === 13 && (M.flags |= 16384))),
                            Df(c, l)) : yr(c)
                        }
                        function yr(l) {
                            var c = l;
                            do {
                                if ((c.flags & 32768) !== 0) {
                                    Df(c, Ua);
                                    return
                                }
                                l = c.return;
                                var _ = Nv(c.alternate, c, qn);
                                if (_ !== null) {
                                    Bt = _;
                                    return
                                }
                                if (c = c.sibling,
                                c !== null) {
                                    Bt = c;
                                    return
                                }
                                Bt = c = l
                            } while (c !== null);
                            In === 0 && (In = 5)
                        }
                        function Df(l, c) {
                            do {
                                var _ = Dv(l.alternate, l);
                                if (_ !== null) {
                                    _.flags &= 32767,
                                    Bt = _;
                                    return
                                }
                                if (_ = l.return,
                                _ !== null && (_.flags |= 32768,
                                _.subtreeFlags = 0,
                                _.deletions = null),
                                !c && (l = l.sibling,
                                l !== null)) {
                                    Bt = l;
                                    return
                                }
                                Bt = l = _
                            } while (l !== null);
                            In = 6,
                            Bt = null
                        }
                        function Tc(l, c, _, M, C, O, j, se, ge, Ie) {
                            var $e = zt.T
                              , lt = yn();
                            try {
                                Ot(2),
                                zt.T = null,
                                am(l, c, _, M, lt, C, O, j, se, ge, Ie)
                            } finally {
                                zt.T = $e,
                                Ot(lt)
                            }
                        }
                        function am(l, c, _, M, C, O, j, se) {
                            do
                                xs();
                            while (Fs !== null);
                            if ((bn & 6) !== 0)
                                throw Error(o(327));
                            var ge = l.finishedWork;
                            if (M = l.finishedLanes,
                            ge === null)
                                return null;
                            if (l.finishedWork = null,
                            l.finishedLanes = 0,
                            ge === l.current)
                                throw Error(o(177));
                            l.callbackNode = null,
                            l.callbackPriority = 0,
                            l.cancelPendingCommit = null;
                            var Ie = ge.lanes | ge.childLanes;
                            if (Ie |= ad,
                            ee(l, M, Ie, O, j, se),
                            l === Nn && (Bt = Nn = null,
                            mn = 0),
                            (ge.subtreeFlags & 10256) === 0 && (ge.flags & 10256) === 0 || pd || (pd = !0,
                            vh = Ie,
                            tl = _,
                            ns(id, function() {
                                return xs(!0),
                                null
                            })),
                            _ = (ge.flags & 15990) !== 0,
                            (ge.subtreeFlags & 15990) !== 0 || _ ? (_ = zt.T,
                            zt.T = null,
                            O = yn(),
                            Ot(2),
                            j = bn,
                            bn |= 4,
                            Ov(l, ge),
                            Vu(ge, l),
                            wc(l.containerInfo),
                            l.current = ge,
                            Jp(l, ge.alternate, ge),
                            Hm(),
                            bn = j,
                            Ot(O),
                            zt.T = _) : l.current = ge,
                            pd ? (pd = !1,
                            Fs = l,
                            el = M) : Fo(l, Ie),
                            Ie = l.pendingLanes,
                            Ie === 0 && (po = null),
                            F(ge.stateNode, C),
                            ke(l),
                            c !== null)
                                for (C = l.onRecoverableError,
                                ge = 0; ge < c.length; ge++)
                                    Ie = c[ge],
                                    C(Ie.value, {
                                        componentStack: Ie.stack
                                    });
                            return (el & 3) !== 0 && xs(),
                            Ie = l.pendingLanes,
                            (M & 4194218) !== 0 && (Ie & 42) !== 0 ? l === md ? Hc++ : (Hc = 0,
                            md = l) : Hc = 0,
                            Nt(0, !1),
                            null
                        }
                        function Fo(l, c) {
                            (l.pooledCacheLanes &= c) === 0 && (c = l.pooledCache,
                            c != null && (l.pooledCache = null,
                            xc(c)))
                        }
                        function xs() {
                            if (Fs !== null) {
                                var l = Fs
                                  , c = vh;
                                vh = 0;
                                var _ = q(el)
                                  , M = 32 > _ ? 32 : _;
                                _ = zt.T;
                                var C = yn();
                                try {
                                    if (Ot(M),
                                    zt.T = null,
                                    Fs === null)
                                        var O = !1;
                                    else {
                                        M = tl,
                                        tl = null;
                                        var j = Fs
                                          , se = el;
                                        if (Fs = null,
                                        el = 0,
                                        (bn & 6) !== 0)
                                            throw Error(o(331));
                                        var ge = bn;
                                        if (bn |= 4,
                                        ku(j.current),
                                        Hu(j, j.current, se, M),
                                        bn = ge,
                                        Nt(0, !1),
                                        ps && typeof ps.onPostCommitFiberRoot == "function")
                                            try {
                                                ps.onPostCommitFiberRoot(Ic, j)
                                            } catch {}
                                        O = !0
                                    }
                                    return O
                                } finally {
                                    Ot(C),
                                    zt.T = _,
                                    Fo(l, c)
                                }
                            }
                            return !1
                        }
                        function Qr(l, c, _) {
                            c = ne(_, c),
                            c = Ou(l.stateNode, c, 2),
                            l = nt(l, c, 2),
                            l !== null && (K(l, 2),
                            ke(l))
                        }
                        function fn(l, c, _) {
                            if (l.tag === 3)
                                Qr(l, l, _);
                            else
                                for (; c !== null; ) {
                                    if (c.tag === 3) {
                                        Qr(c, l, _);
                                        break
                                    } else if (c.tag === 1) {
                                        var M = c.stateNode;
                                        if (typeof c.type.getDerivedStateFromError == "function" || typeof M.componentDidCatch == "function" && (po === null || !po.has(M))) {
                                            l = ne(_, l),
                                            _ = yc(2),
                                            M = nt(c, _, 2),
                                            M !== null && (Uu(_, M, c, l),
                                            K(M, 2),
                                            ke(M));
                                            break
                                        }
                                    }
                                    c = c.return
                                }
                        }
                        function Wu(l, c, _) {
                            var M = l.pingCache;
                            if (M === null) {
                                M = l.pingCache = new ca;
                                var C = new Set;
                                M.set(c, C)
                            } else
                                C = M.get(c),
                                C === void 0 && (C = new Set,
                                M.set(c, C));
                            C.has(_) || (Dr = !0,
                            C.add(_),
                            l = rm.bind(null, l, c, _),
                            c.then(l, l))
                        }
                        function rm(l, c, _) {
                            var M = l.pingCache;
                            M !== null && M.delete(c),
                            l.pingedLanes |= l.suspendedLanes & _,
                            l.warmLanes &= ~_,
                            Nn === l && (mn & _) === _ && (In === 4 || In === 3 && (mn & 62914560) === mn && 300 > Rn() - dd ? (bn & 2) === 0 && Po(l, 0) : mh |= _,
                            Ql === mn && (Ql = 0)),
                            ke(l)
                        }
                        function Ul(l, c) {
                            c === 0 && (c = P()),
                            l = Ke(l, c),
                            l !== null && (K(l, c),
                            ke(l))
                        }
                        function Of(l) {
                            var c = l.memoizedState
                              , _ = 0;
                            c !== null && (_ = c.retryLane),
                            Ul(l, _)
                        }
                        function Ll(l, c) {
                            var _ = 0;
                            switch (l.tag) {
                            case 13:
                                var M = l.stateNode
                                  , C = l.memoizedState;
                                C !== null && (_ = C.retryLane);
                                break;
                            case 19:
                                M = l.stateNode;
                                break;
                            case 22:
                                M = l.stateNode._retryCache;
                                break;
                            default:
                                throw Error(o(314))
                            }
                            M !== null && M.delete(c),
                            Ul(l, _)
                        }
                        function ns(l, c) {
                            return lh(l, c)
                        }
                        function Uf(l, c, _, M) {
                            this.tag = l,
                            this.key = _,
                            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                            this.index = 0,
                            this.refCleanup = this.ref = null,
                            this.pendingProps = c,
                            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                            this.mode = M,
                            this.subtreeFlags = this.flags = 0,
                            this.deletions = null,
                            this.childLanes = this.lanes = 0,
                            this.alternate = null
                        }
                        function Lf(l) {
                            return l = l.prototype,
                            !(!l || !l.isReactComponent)
                        }
                        function Ho(l, c) {
                            var _ = l.alternate;
                            return _ === null ? (_ = i(l.tag, c, l.key, l.mode),
                            _.elementType = l.elementType,
                            _.type = l.type,
                            _.stateNode = l.stateNode,
                            _.alternate = l,
                            l.alternate = _) : (_.pendingProps = c,
                            _.type = l.type,
                            _.flags = 0,
                            _.subtreeFlags = 0,
                            _.deletions = null),
                            _.flags = l.flags & 31457280,
                            _.childLanes = l.childLanes,
                            _.lanes = l.lanes,
                            _.child = l.child,
                            _.memoizedProps = l.memoizedProps,
                            _.memoizedState = l.memoizedState,
                            _.updateQueue = l.updateQueue,
                            c = l.dependencies,
                            _.dependencies = c === null ? null : {
                                lanes: c.lanes,
                                firstContext: c.firstContext
                            },
                            _.sibling = l.sibling,
                            _.index = l.index,
                            _.ref = l.ref,
                            _.refCleanup = l.refCleanup,
                            _
                        }
                        function Iv(l, c) {
                            l.flags &= 31457282;
                            var _ = l.alternate;
                            return _ === null ? (l.childLanes = 0,
                            l.lanes = c,
                            l.child = null,
                            l.subtreeFlags = 0,
                            l.memoizedProps = null,
                            l.memoizedState = null,
                            l.updateQueue = null,
                            l.dependencies = null,
                            l.stateNode = null) : (l.childLanes = _.childLanes,
                            l.lanes = _.lanes,
                            l.child = _.child,
                            l.subtreeFlags = 0,
                            l.deletions = null,
                            l.memoizedProps = _.memoizedProps,
                            l.memoizedState = _.memoizedState,
                            l.updateQueue = _.updateQueue,
                            l.type = _.type,
                            c = _.dependencies,
                            l.dependencies = c === null ? null : {
                                lanes: c.lanes,
                                firstContext: c.firstContext
                            }),
                            l
                        }
                        function If(l, c, _, M, C, O) {
                            var j = 0;
                            if (M = l,
                            typeof l == "function")
                                Lf(l) && (j = 1);
                            else if (typeof l == "string")
                                j = na && is ? Om(l, _, Bi.current) ? 26 : Fm(l) ? 27 : 5 : na ? Om(l, _, Bi.current) ? 26 : 5 : is && Fm(l) ? 27 : 5;
                            else
                                e: switch (l) {
                                case Jr:
                                    return Yn(_.children, C, O, c);
                                case um:
                                    j = 8,
                                    C |= 24;
                                    break;
                                case Vf:
                                    return l = i(12, _, c, C | 2),
                                    l.elementType = Vf,
                                    l.lanes = O,
                                    l;
                                case ko:
                                    return l = i(13, _, c, C),
                                    l.elementType = ko,
                                    l.lanes = O,
                                    l;
                                case Fl:
                                    return l = i(19, _, c, C),
                                    l.elementType = Fl,
                                    l.lanes = O,
                                    l;
                                case Yu:
                                    return zf(_, C, O, c);
                                default:
                                    if (typeof l == "object" && l !== null)
                                        switch (l.$$typeof) {
                                        case Vl:
                                        case $r:
                                            j = 10;
                                            break e;
                                        case Go:
                                            j = 9;
                                            break e;
                                        case Ff:
                                            j = 11;
                                            break e;
                                        case Cc:
                                            j = 14;
                                            break e;
                                        case Ca:
                                            j = 16,
                                            M = null;
                                            break e
                                        }
                                    j = 29,
                                    _ = Error(o(130, l === null ? "null" : typeof l, "")),
                                    M = null
                                }
                            return c = i(j, _, c, C),
                            c.elementType = l,
                            c.type = M,
                            c.lanes = O,
                            c
                        }
                        function Yn(l, c, _, M) {
                            return l = i(7, l, M, c),
                            l.lanes = _,
                            l
                        }
                        function zf(l, c, _, M) {
                            l = i(22, l, M, c),
                            l.elementType = Yu,
                            l.lanes = _;
                            var C = {
                                _visibility: 1,
                                _pendingVisibility: 1,
                                _pendingMarkers: null,
                                _retryCache: null,
                                _transitions: null,
                                _current: null,
                                detach: function() {
                                    var O = C._current;
                                    if (O === null)
                                        throw Error(o(456));
                                    if ((C._pendingVisibility & 2) === 0) {
                                        var j = Ke(O, 2);
                                        j !== null && (C._pendingVisibility |= 2,
                                        Ii(j, O, 2))
                                    }
                                },
                                attach: function() {
                                    var O = C._current;
                                    if (O === null)
                                        throw Error(o(456));
                                    if ((C._pendingVisibility & 2) !== 0) {
                                        var j = Ke(O, 2);
                                        j !== null && (C._pendingVisibility &= -3,
                                        Ii(j, O, 2))
                                    }
                                }
                            };
                            return l.stateNode = C,
                            l
                        }
                        function Il(l, c, _) {
                            return l = i(6, l, null, c),
                            l.lanes = _,
                            l
                        }
                        function zl(l, c, _) {
                            return c = i(4, l.children !== null ? l.children : [], l.key, c),
                            c.lanes = _,
                            c.stateNode = {
                                containerInfo: l.containerInfo,
                                pendingChildren: null,
                                implementation: l.implementation
                            },
                            c
                        }
                        function om(l, c, _, M, C, O, j, se) {
                            this.tag = 1,
                            this.containerInfo = l,
                            this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                            this.timeoutHandle = Ku,
                            this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                            this.callbackPriority = 0,
                            this.expirationTimes = G(-1),
                            this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                            this.entanglements = G(0),
                            this.hiddenUpdates = G(null),
                            this.identifierPrefix = M,
                            this.onUncaughtError = C,
                            this.onCaughtError = O,
                            this.onRecoverableError = j,
                            this.pooledCache = null,
                            this.pooledCacheLanes = 0,
                            this.formState = se,
                            this.incompleteTransitions = new Map
                        }
                        function Bl(l, c, _, M, C, O, j, se, ge, Ie, $e, lt) {
                            return l = new om(l,c,_,j,se,ge,Ie,lt),
                            c = 1,
                            O === !0 && (c |= 24),
                            O = i(3, null, null, c),
                            l.current = O,
                            O.stateNode = l,
                            c = Sc(),
                            c.refCount++,
                            l.pooledCache = c,
                            c.refCount++,
                            O.memoizedState = {
                                element: M,
                                isDehydrated: _,
                                cache: c
                            },
                            Dt(O),
                            l
                        }
                        function Pl(l) {
                            return l ? (l = Uc,
                            l) : Uc
                        }
                        function zv(l) {
                            var c = l._reactInternals;
                            if (c === void 0)
                                throw typeof l.render == "function" ? Error(o(188)) : (l = Object.keys(l).join(","),
                                Error(o(268, l)));
                            return l = E(c),
                            l = l !== null ? w(l) : null,
                            l === null ? null : to(l.stateNode)
                        }
                        function lm(l, c, _, M, C, O) {
                            C = Pl(C),
                            M.context === null ? M.context = C : M.pendingContext = C,
                            M = Xe(c),
                            M.payload = {
                                element: _
                            },
                            O = O === void 0 ? null : O,
                            O !== null && (M.callback = O),
                            _ = nt(l, M, c),
                            _ !== null && (Ii(_, l, c),
                            ot(_, l, c))
                        }
                        function Bv(l, c) {
                            if (l = l.memoizedState,
                            l !== null && l.dehydrated !== null) {
                                var _ = l.retryLane;
                                l.retryLane = _ !== 0 && _ < c ? _ : c
                            }
                        }
                        function Bf(l, c) {
                            Bv(l, c),
                            (l = l.alternate) && Bv(l, c)
                        }
                        var Wt = {}, cm = Sd(), ds = hb(), Pf = Object.assign, Ac = Symbol.for("react.element"), Ec = Symbol.for("react.transitional.element"), Kr = Symbol.for("react.portal"), Jr = Symbol.for("react.fragment"), um = Symbol.for("react.strict_mode"), Vf = Symbol.for("react.profiler"), Vl = Symbol.for("react.provider"), Go = Symbol.for("react.consumer"), $r = Symbol.for("react.context"), Ff = Symbol.for("react.forward_ref"), ko = Symbol.for("react.suspense"), Fl = Symbol.for("react.suspense_list"), Cc = Symbol.for("react.memo"), Ca = Symbol.for("react.lazy"), Yu = Symbol.for("react.offscreen"), Pv = Symbol.for("react.memo_cache_sentinel"), qo = Symbol.iterator, Vv = Symbol.for("react.client.reference"), zt = cm.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ju, Hf, eo = !1, Sr = Array.isArray, Zu = n.rendererVersion, hm = n.rendererPackageName, Gf = n.extraDevToolsConfig, to = n.getPublicInstance, Qu = n.getRootHostContext, Fv = n.getChildHostContext, Hv = n.prepareForCommit, wc = n.resetAfterCommit, kf = n.createInstance, qf = n.appendInitialChild, Xf = n.finalizeInitialChildren, Rc = n.shouldSetTextContent, Ls = n.createTextInstance, wa = n.scheduleTimeout, Xo = n.cancelTimeout, Ku = n.noTimeout, xr = n.isPrimaryRenderer;
                        n.warnsIfNotActing;
                        var ci = n.supportsMutation
                          , Ei = n.supportsPersistence
                          , Tn = n.supportsHydration
                          , Ju = n.getInstanceFromNode;
                        n.beforeActiveInstanceBlur,
                        n.afterActiveInstanceBlur;
                        var no = n.preparePortalMount;
                        n.prepareScopeUpdate,
                        n.getInstanceFromScope;
                        var Ot = n.setCurrentUpdatePriority
                          , yn = n.getCurrentUpdatePriority
                          , Ci = n.resolveUpdatePriority;
                        n.resolveEventType,
                        n.resolveEventTimeStamp;
                        var Wf = n.shouldAttemptEagerTransition
                          , Nc = n.detachDeletedInstance;
                        n.requestPostPaintCallback;
                        var Hl = n.maySuspendCommit
                          , $u = n.preloadInstance
                          , eh = n.startSuspendingCommit
                          , Gl = n.suspendInstance
                          , NS = n.waitForCommitToBeReady
                          , Gn = n.NotPendingTransition
                          , io = n.HostTransitionContext
                          , fm = n.resetFormInstance;
                        n.bindToConsole;
                        var Gv = n.supportsMicrotasks
                          , kv = n.scheduleMicrotask
                          , th = n.supportsTestSelectors
                          , dm = n.findFiberRoot
                          , pm = n.getBoundingRect
                          , mm = n.getTextContent
                          , zi = n.isHiddenSubtree
                          , xi = n.matchAccessibilityRole
                          , Yf = n.setFocusIfFocusable
                          , nh = n.setupIntersectionObserver
                          , jf = n.appendChild
                          , gm = n.appendChildToContainer
                          , so = n.commitTextUpdate
                          , Zf = n.commitMount
                          , vm = n.commitUpdate
                          , _m = n.insertBefore
                          , qv = n.insertInContainerBefore
                          , Xv = n.removeChild
                          , Wv = n.removeChildFromContainer
                          , ym = n.resetTextContent
                          , Yv = n.hideInstance
                          , jv = n.hideTextInstance
                          , Sm = n.unhideInstance
                          , Zv = n.unhideTextInstance
                          , DS = n.clearContainer
                          , Qv = n.cloneInstance
                          , xm = n.createContainerChildSet
                          , Mm = n.appendChildToContainerChildSet
                          , bm = n.finalizeContainerChildren
                          , Tm = n.replaceContainerChildren
                          , Am = n.cloneHiddenInstance
                          , Em = n.cloneHiddenTextInstance
                          , Qf = n.isSuspenseInstancePending
                          , Kf = n.isSuspenseInstanceFallback
                          , OS = n.getSuspenseInstanceFallbackErrorDetails
                          , Kv = n.registerSuspenseInstanceRetry
                          , Dc = n.canHydrateFormStateMarker
                          , Jv = n.isFormStateMarkerMatching
                          , ih = n.getNextHydratableSibling
                          , sh = n.getFirstHydratableChild
                          , $v = n.getFirstHydratableChildWithinContainer
                          , Cm = n.getFirstHydratableChildWithinSuspenseInstance
                          , US = n.canHydrateInstance
                          , e_ = n.canHydrateTextInstance
                          , t_ = n.canHydrateSuspenseInstance
                          , n_ = n.hydrateInstance
                          , i_ = n.hydrateTextInstance
                          , s_ = n.hydrateSuspenseInstance
                          , wm = n.getNextHydratableInstanceAfterSuspenseInstance
                          , a_ = n.commitHydratedContainer
                          , r_ = n.commitHydratedSuspenseInstance
                          , Rm = n.clearSuspenseBoundary
                          , o_ = n.clearSuspenseBoundaryFromContainer
                          , Nm = n.shouldDeleteUnhydratedTailInstances;
                        n.diffHydratedPropsForDevWarnings,
                        n.diffHydratedTextForDevWarnings,
                        n.describeHydratableInstanceForDevWarnings;
                        var LS = n.validateHydratableInstance
                          , Dm = n.validateHydratableTextInstance
                          , na = n.supportsResources
                          , Om = n.isHostHoistableType
                          , ah = n.getHoistableRoot
                          , Um = n.getResource
                          , Lm = n.acquireResource
                          , l_ = n.releaseResource
                          , IS = n.hydrateHoistable
                          , Im = n.mountHoistable
                          , Oc = n.unmountHoistable
                          , zm = n.createHoistableInstance
                          , Jf = n.prepareToCommitHoistables
                          , c_ = n.mayResourceSuspendCommit
                          , Bm = n.preloadResource
                          , rh = n.suspendResource
                          , is = n.supportsSingletons
                          , $f = n.resolveSingletonInstance
                          , u_ = n.clearSingleton
                          , Pm = n.acquireSingletonInstance
                          , Vm = n.releaseSingletonInstance
                          , Fm = n.isHostSingletonType
                          , ed = []
                          , Ra = -1
                          , Uc = {}
                          , ia = Math.clz32 ? Math.clz32 : D
                          , zS = Math.log
                          , td = Math.LN2
                          , oh = 128
                          , Lc = 4194304
                          , lh = ds.unstable_scheduleCallback
                          , nd = ds.unstable_cancelCallback
                          , BS = ds.unstable_shouldYield
                          , Hm = ds.unstable_requestPaint
                          , Rn = ds.unstable_now
                          , ji = ds.unstable_ImmediatePriority
                          , h_ = ds.unstable_UserBlockingPriority
                          , id = ds.unstable_NormalPriority
                          , f_ = ds.unstable_IdlePriority
                          , d_ = ds.log
                          , ch = ds.unstable_setDisableYieldValue
                          , Ic = null
                          , ps = null
                          , Is = typeof Object.is == "function" ? Object.is : $
                          , p_ = new WeakMap
                          , ao = []
                          , Wo = 0
                          , uh = null
                          , hh = 0
                          , sa = []
                          , zs = 0
                          , ro = null
                          , Qa = 1
                          , Mr = ""
                          , Bi = T(null)
                          , Yo = T(null)
                          , br = T(null)
                          , fh = T(null)
                          , ss = null
                          , as = null
                          , Jt = !1
                          , aa = null
                          , Tr = !1
                          , sd = Error(o(519))
                          , wi = []
                          , jo = 0
                          , ad = 0
                          , kl = null
                          , Ar = null
                          , kn = !1
                          , rd = !1
                          , Gm = !1
                          , ql = 0
                          , oo = null
                          , Er = 0
                          , Xl = 0
                          , Wl = null
                          , Na = !1
                          , Da = !1
                          , m_ = Object.prototype.hasOwnProperty
                          , Yl = Error(o(460))
                          , od = Error(o(474))
                          , zc = {
                            then: function() {}
                        }
                          , Zo = null
                          , lo = null
                          , Bc = 0
                          , Ms = Tu(!0)
                          , Mi = Tu(!1)
                          , Qo = T(null)
                          , dh = T(0)
                          , Un = T(null)
                          , Cr = null
                          , Ri = T(0)
                          , co = 0
                          , St = null
                          , Qt = null
                          , Bn = null
                          , ph = !1
                          , jl = !1
                          , Ko = !1
                          , ld = 0
                          , Jo = 0
                          , Pi = null
                          , Ka = 0
                          , cd = function() {
                            return {
                                lastEffect: null,
                                events: null,
                                stores: null,
                                memoCache: null
                            }
                        }
                          , ui = {
                            readContext: Ai,
                            use: ue,
                            useCallback: Zt,
                            useContext: Zt,
                            useEffect: Zt,
                            useImperativeHandle: Zt,
                            useLayoutEffect: Zt,
                            useInsertionEffect: Zt,
                            useMemo: Zt,
                            useReducer: Zt,
                            useRef: Zt,
                            useState: Zt,
                            useDebugValue: Zt,
                            useDeferredValue: Zt,
                            useTransition: Zt,
                            useSyncExternalStore: Zt,
                            useId: Zt
                        };
                        ui.useCacheRefresh = Zt,
                        ui.useMemoCache = Zt,
                        ui.useHostTransitionStatus = Zt,
                        ui.useFormState = Zt,
                        ui.useActionState = Zt,
                        ui.useOptimistic = Zt;
                        var $o = {
                            readContext: Ai,
                            use: ue,
                            useCallback: function(l, c) {
                                return yi().memoizedState = [l, c === void 0 ? null : c],
                                l
                            },
                            useContext: Ai,
                            useEffect: Up,
                            useImperativeHandle: function(l, c, _) {
                                _ = _ != null ? _.concat([l]) : null,
                                wo(4194308, 4, Cu.bind(null, c, l), _)
                            },
                            useLayoutEffect: function(l, c) {
                                return wo(4194308, 4, l, c)
                            },
                            useInsertionEffect: function(l, c) {
                                wo(4, 2, l, c)
                            },
                            useMemo: function(l, c) {
                                var _ = yi();
                                c = c === void 0 ? null : c;
                                var M = l();
                                if (Ko) {
                                    X(!0);
                                    try {
                                        l()
                                    } finally {
                                        X(!1)
                                    }
                                }
                                return _.memoizedState = [M, c],
                                M
                            },
                            useReducer: function(l, c, _) {
                                var M = yi();
                                if (_ !== void 0) {
                                    var C = _(c);
                                    if (Ko) {
                                        X(!0);
                                        try {
                                            _(c)
                                        } finally {
                                            X(!1)
                                        }
                                    }
                                } else
                                    C = c;
                                return M.memoizedState = M.baseState = C,
                                l = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: l,
                                    lastRenderedState: C
                                },
                                M.queue = l,
                                l = l.dispatch = No.bind(null, St, l),
                                [M.memoizedState, l]
                            },
                            useRef: function(l) {
                                var c = yi();
                                return l = {
                                    current: l
                                },
                                c.memoizedState = l
                            },
                            useState: function(l) {
                                l = rn(l);
                                var c = l.queue
                                  , _ = hf.bind(null, St, c);
                                return c.dispatch = _,
                                [l.memoizedState, _]
                            },
                            useDebugValue: wu,
                            useDeferredValue: function(l, c) {
                                return Ro(yi(), l, c)
                            },
                            useTransition: function() {
                                var l = rn(!1);
                                return l = cf.bind(null, St, l.queue, !0, !1),
                                yi().memoizedState = l,
                                [!1, l]
                            },
                            useSyncExternalStore: function(l, c, _) {
                                var M = St
                                  , C = yi();
                                if (Jt) {
                                    if (_ === void 0)
                                        throw Error(o(407));
                                    _ = _()
                                } else {
                                    if (_ = c(),
                                    Nn === null)
                                        throw Error(o(349));
                                    (mn & 60) !== 0 || ht(M, c, _)
                                }
                                C.memoizedState = _;
                                var O = {
                                    value: _,
                                    getSnapshot: c
                                };
                                return C.queue = O,
                                Up(Vt.bind(null, M, O, l), [l]),
                                M.flags |= 2048,
                                ei(9, It.bind(null, M, O, _, c), {
                                    destroy: void 0
                                }, null),
                                _
                            },
                            useId: function() {
                                var l = yi()
                                  , c = Nn.identifierPrefix;
                                if (Jt) {
                                    var _ = Mr
                                      , M = Qa;
                                    _ = (M & ~(1 << 32 - ia(M) - 1)).toString(32) + _,
                                    c = ":" + c + "R" + _,
                                    _ = ld++,
                                    0 < _ && (c += "H" + _.toString(32)),
                                    c += ":"
                                } else
                                    _ = Ka++,
                                    c = ":" + c + "r" + _.toString(32) + ":";
                                return l.memoizedState = c
                            },
                            useCacheRefresh: function() {
                                return yi().memoizedState = Ru.bind(null, St)
                            }
                        };
                        $o.useMemoCache = _e,
                        $o.useHostTransitionStatus = El,
                        $o.useFormState = qi,
                        $o.useActionState = qi,
                        $o.useOptimistic = function(l) {
                            var c = yi();
                            c.memoizedState = c.baseState = l;
                            var _ = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: null,
                                lastRenderedState: null
                            };
                            return c.queue = _,
                            c = ff.bind(null, St, !0, _),
                            _.dispatch = c,
                            [l, c]
                        }
                        ;
                        var ms = {
                            readContext: Ai,
                            use: ue,
                            useCallback: lf,
                            useContext: Ai,
                            useEffect: Eu,
                            useImperativeHandle: ur,
                            useInsertionEffect: mv,
                            useLayoutEffect: gv,
                            useMemo: Al,
                            useReducer: me,
                            useRef: Ui,
                            useState: function() {
                                return me(Se)
                            },
                            useDebugValue: wu,
                            useDeferredValue: function(l, c) {
                                return Lp(Fn(), Qt.memoizedState, l, c)
                            },
                            useTransition: function() {
                                var l = me(Se)[0]
                                  , c = Fn().memoizedState;
                                return [typeof l == "boolean" ? l : Y(l), c]
                            },
                            useSyncExternalStore: vt,
                            useId: hr
                        };
                        ms.useCacheRefresh = uf,
                        ms.useMemoCache = _e,
                        ms.useHostTransitionStatus = El,
                        ms.useFormState = kr,
                        ms.useActionState = kr,
                        ms.useOptimistic = function(l, c) {
                            return cn(Fn(), Qt, l, c)
                        }
                        ;
                        var ra = {
                            readContext: Ai,
                            use: ue,
                            useCallback: lf,
                            useContext: Ai,
                            useEffect: Eu,
                            useImperativeHandle: ur,
                            useInsertionEffect: mv,
                            useLayoutEffect: gv,
                            useMemo: Al,
                            useReducer: st,
                            useRef: Ui,
                            useState: function() {
                                return st(Se)
                            },
                            useDebugValue: wu,
                            useDeferredValue: function(l, c) {
                                var _ = Fn();
                                return Qt === null ? Ro(_, l, c) : Lp(_, Qt.memoizedState, l, c)
                            },
                            useTransition: function() {
                                var l = st(Se)[0]
                                  , c = Fn().memoizedState;
                                return [typeof l == "boolean" ? l : Y(l), c]
                            },
                            useSyncExternalStore: vt,
                            useId: hr
                        };
                        ra.useCacheRefresh = uf,
                        ra.useMemoCache = _e,
                        ra.useHostTransitionStatus = El,
                        ra.useFormState = us,
                        ra.useActionState = us,
                        ra.useOptimistic = function(l, c) {
                            var _ = Fn();
                            return Qt !== null ? cn(_, Qt, l, c) : (_.baseState = l,
                            [l, _.queue.dispatch])
                        }
                        ;
                        var Ja = {
                            isMounted: function(l) {
                                return (l = l._reactInternals) ? y(l) === l : !1
                            },
                            enqueueSetState: function(l, c, _) {
                                l = l._reactInternals;
                                var M = Xi()
                                  , C = Xe(M);
                                C.payload = c,
                                _ != null && (C.callback = _),
                                c = nt(l, C, M),
                                c !== null && (Ii(c, l, M),
                                ot(c, l, M))
                            },
                            enqueueReplaceState: function(l, c, _) {
                                l = l._reactInternals;
                                var M = Xi()
                                  , C = Xe(M);
                                C.tag = 1,
                                C.payload = c,
                                _ != null && (C.callback = _),
                                c = nt(l, C, M),
                                c !== null && (Ii(c, l, M),
                                ot(c, l, M))
                            },
                            enqueueForceUpdate: function(l, c) {
                                l = l._reactInternals;
                                var _ = Xi()
                                  , M = Xe(_);
                                M.tag = 2,
                                c != null && (M.callback = c),
                                c = nt(l, M, _),
                                c !== null && (Ii(c, l, _),
                                ot(c, l, _))
                            }
                        }
                          , ud = typeof reportError == "function" ? reportError : function(l) {
                            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                var c = new window.ErrorEvent("error",{
                                    bubbles: !0,
                                    cancelable: !0,
                                    message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
                                    error: l
                                });
                                if (!window.dispatchEvent(c))
                                    return
                            } else if (typeof process == "object" && typeof process.emit == "function") {
                                process.emit("uncaughtException", l);
                                return
                            }
                            console.error(l)
                        }
                          , hd = Error(o(461))
                          , Pn = !1
                          , fd = {
                            dehydrated: null,
                            treeContext: null,
                            retryLane: 0
                        }
                          , uo = T(null)
                          , $a = null
                          , oa = null
                          , Pc = typeof AbortController < "u" ? AbortController : function() {
                            var l = []
                              , c = this.signal = {
                                aborted: !1,
                                addEventListener: function(_, M) {
                                    l.push(M)
                                }
                            };
                            this.abort = function() {
                                c.aborted = !0,
                                l.forEach(function(_) {
                                    return _()
                                })
                            }
                        }
                          , g_ = ds.unstable_scheduleCallback
                          , v_ = ds.unstable_NormalPriority
                          , jn = {
                            $$typeof: $r,
                            Consumer: null,
                            Provider: null,
                            _currentValue: null,
                            _currentValue2: null,
                            _threadCount: 0
                        }
                          , km = zt.S;
                        zt.S = function(l, c) {
                            typeof c == "object" && c !== null && typeof c.then == "function" && pt(l, c),
                            km !== null && km(l, c)
                        }
                        ;
                        var wr = T(null)
                          , Rr = !1
                          , mi = !1
                          , qm = !1
                          , An = typeof WeakSet == "function" ? WeakSet : Set
                          , qt = null
                          , on = !1
                          , Ut = null
                          , Kt = !1
                          , hi = null
                          , la = 8192
                          , Vc = {
                            getCacheForType: function(l) {
                                var c = Ai(jn)
                                  , _ = c.data.get(l);
                                return _ === void 0 && (_ = l(),
                                c.data.set(l, _)),
                                _
                            }
                        }
                          , Fc = 0
                          , Oa = 1
                          , ti = 2
                          , er = 3
                          , Nr = 4;
                        if (typeof Symbol == "function" && Symbol.for) {
                            var Zl = Symbol.for;
                            Fc = Zl("selector.component"),
                            Oa = Zl("selector.has_pseudo_class"),
                            ti = Zl("selector.role"),
                            er = Zl("selector.test_id"),
                            Nr = Zl("selector.text")
                        }
                        var ca = typeof WeakMap == "function" ? WeakMap : Map
                          , bn = 0
                          , Nn = null
                          , Bt = null
                          , mn = 0
                          , Ln = 0
                          , Bs = null
                          , Ua = !1
                          , ho = !1
                          , Dr = !1
                          , qn = 0
                          , In = 0
                          , ua = 0
                          , bs = 0
                          , mh = 0
                          , Ps = 0
                          , Ql = 0
                          , fo = null
                          , La = null
                          , Vs = !1
                          , dd = 0
                          , Zi = 1 / 0
                          , gh = null
                          , po = null
                          , pd = !1
                          , Fs = null
                          , el = 0
                          , vh = 0
                          , tl = null
                          , Hc = 0
                          , md = null;
                        return Wt.attemptContinuousHydration = function(l) {
                            if (l.tag === 13) {
                                var c = Ke(l, 67108864);
                                c !== null && Ii(c, l, 67108864),
                                Bf(l, 67108864)
                            }
                        }
                        ,
                        Wt.attemptHydrationAtCurrentPriority = function(l) {
                            if (l.tag === 13) {
                                var c = Xi()
                                  , _ = Ke(l, c);
                                _ !== null && Ii(_, l, c),
                                Bf(l, c)
                            }
                        }
                        ,
                        Wt.attemptSynchronousHydration = function(l) {
                            switch (l.tag) {
                            case 3:
                                if (l = l.stateNode,
                                l.current.memoizedState.isDehydrated) {
                                    var c = U(l.pendingLanes);
                                    if (c !== 0) {
                                        for (l.pendingLanes |= 2,
                                        l.entangledLanes |= 2; c; ) {
                                            var _ = 1 << 31 - ia(c);
                                            l.entanglements[1] |= _,
                                            c &= ~_
                                        }
                                        ke(l),
                                        (bn & 6) === 0 && (Zi = Rn() + 500,
                                        Nt(0, !1))
                                    }
                                }
                                break;
                            case 13:
                                c = Ke(l, 2),
                                c !== null && Ii(c, l, 2),
                                vr(),
                                Bf(l, 2)
                            }
                        }
                        ,
                        Wt.batchedUpdates = function(l, c) {
                            return l(c)
                        }
                        ,
                        Wt.createComponentSelector = function(l) {
                            return {
                                $$typeof: Fc,
                                value: l
                            }
                        }
                        ,
                        Wt.createContainer = function(l, c, _, M, C, O, j, se, ge, Ie) {
                            return Bl(l, c, !1, null, _, M, O, j, se, ge, Ie, null)
                        }
                        ,
                        Wt.createHasPseudoClassSelector = function(l) {
                            return {
                                $$typeof: Oa,
                                value: l
                            }
                        }
                        ,
                        Wt.createHydrationContainer = function(l, c, _, M, C, O, j, se, ge, Ie, $e, lt, ct) {
                            return l = Bl(_, M, !0, l, C, O, se, ge, Ie, $e, lt, ct),
                            l.context = Pl(null),
                            _ = l.current,
                            M = Xi(),
                            C = Xe(M),
                            C.callback = c ?? null,
                            nt(_, C, M),
                            l.current.lanes = M,
                            K(l, M),
                            ke(l),
                            l
                        }
                        ,
                        Wt.createPortal = function(l, c, _) {
                            var M = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                            return {
                                $$typeof: Kr,
                                key: M == null ? null : "" + M,
                                children: l,
                                containerInfo: c,
                                implementation: _
                            }
                        }
                        ,
                        Wt.createRoleSelector = function(l) {
                            return {
                                $$typeof: ti,
                                value: l
                            }
                        }
                        ,
                        Wt.createTestNameSelector = function(l) {
                            return {
                                $$typeof: er,
                                value: l
                            }
                        }
                        ,
                        Wt.createTextSelector = function(l) {
                            return {
                                $$typeof: Nr,
                                value: l
                            }
                        }
                        ,
                        Wt.defaultOnCaughtError = function(l) {
                            console.error(l)
                        }
                        ,
                        Wt.defaultOnRecoverableError = function(l) {
                            ud(l)
                        }
                        ,
                        Wt.defaultOnUncaughtError = function(l) {
                            ud(l)
                        }
                        ,
                        Wt.deferredUpdates = function(l) {
                            var c = zt.T
                              , _ = yn();
                            try {
                                return Ot(32),
                                zt.T = null,
                                l()
                            } finally {
                                Ot(_),
                                zt.T = c
                            }
                        }
                        ,
                        Wt.discreteUpdates = function(l, c, _, M, C) {
                            var O = zt.T
                              , j = yn();
                            try {
                                return Ot(2),
                                zt.T = null,
                                l(c, _, M, C)
                            } finally {
                                Ot(j),
                                zt.T = O,
                                bn === 0 && (Zi = Rn() + 500)
                            }
                        }
                        ,
                        Wt.findAllNodes = Bo,
                        Wt.findBoundingRects = function(l, c) {
                            if (!th)
                                throw Error(o(363));
                            c = Bo(l, c),
                            l = [];
                            for (var _ = 0; _ < c.length; _++)
                                l.push(pm(c[_]));
                            for (c = l.length - 1; 0 < c; c--) {
                                _ = l[c];
                                for (var M = _.x, C = M + _.width, O = _.y, j = O + _.height, se = c - 1; 0 <= se; se--)
                                    if (c !== se) {
                                        var ge = l[se]
                                          , Ie = ge.x
                                          , $e = Ie + ge.width
                                          , lt = ge.y
                                          , ct = lt + ge.height;
                                        if (M >= Ie && O >= lt && C <= $e && j <= ct) {
                                            l.splice(c, 1);
                                            break
                                        } else if (M !== Ie || _.width !== ge.width || ct < O || lt > j) {
                                            if (!(O !== lt || _.height !== ge.height || $e < M || Ie > C)) {
                                                Ie > M && (ge.width += Ie - M,
                                                ge.x = M),
                                                $e < C && (ge.width = C - Ie),
                                                l.splice(c, 1);
                                                break
                                            }
                                        } else {
                                            lt > O && (ge.height += lt - O,
                                            ge.y = O),
                                            ct < j && (ge.height = j - lt),
                                            l.splice(c, 1);
                                            break
                                        }
                                    }
                            }
                            return l
                        }
                        ,
                        Wt.findHostInstance = zv,
                        Wt.findHostInstanceWithNoPortals = function(l) {
                            return l = E(l),
                            l = l !== null ? A(l) : null,
                            l === null ? null : to(l.stateNode)
                        }
                        ,
                        Wt.findHostInstanceWithWarning = function(l) {
                            return zv(l)
                        }
                        ,
                        Wt.flushPassiveEffects = xs,
                        Wt.flushSyncFromReconciler = function(l) {
                            var c = bn;
                            bn |= 1;
                            var _ = zt.T
                              , M = yn();
                            try {
                                if (Ot(2),
                                zt.T = null,
                                l)
                                    return l()
                            } finally {
                                Ot(M),
                                zt.T = _,
                                bn = c,
                                (bn & 6) === 0 && Nt(0, !1)
                            }
                        }
                        ,
                        Wt.flushSyncWork = vr,
                        Wt.focusWithin = function(l, c) {
                            if (!th)
                                throw Error(o(363));
                            for (l = Cf(l),
                            c = ea(l, c),
                            c = Array.from(c),
                            l = 0; l < c.length; ) {
                                var _ = c[l++]
                                  , M = _.tag;
                                if (!zi(_)) {
                                    if ((M === 5 || M === 26 || M === 27) && Yf(_.stateNode))
                                        return !0;
                                    for (_ = _.child; _ !== null; )
                                        c.push(_),
                                        _ = _.sibling
                                }
                            }
                            return !1
                        }
                        ,
                        Wt.getFindAllNodesFailureDescription = function(l, c) {
                            if (!th)
                                throw Error(o(363));
                            var _ = 0
                              , M = [];
                            l = [Cf(l), 0];
                            for (var C = 0; C < l.length; ) {
                                var O = l[C++]
                                  , j = O.tag
                                  , se = l[C++]
                                  , ge = c[se];
                                if ((j !== 5 && j !== 26 && j !== 27 || !zi(O)) && (qu(O, ge) && (M.push(wf(ge)),
                                se++,
                                se > _ && (_ = se)),
                                se < c.length))
                                    for (O = O.child; O !== null; )
                                        l.push(O, se),
                                        O = O.sibling
                            }
                            if (_ < c.length) {
                                for (l = []; _ < c.length; _++)
                                    l.push(wf(c[_]));
                                return `findAllNodes was able to match part of the selector:
  ` + (M.join(" > ") + `

No matching component was found for:
  `) + l.join(" > ")
                            }
                            return null
                        }
                        ,
                        Wt.getPublicRootInstance = function(l) {
                            if (l = l.current,
                            !l.child)
                                return null;
                            switch (l.child.tag) {
                            case 27:
                            case 5:
                                return to(l.child.stateNode);
                            default:
                                return l.child.stateNode
                            }
                        }
                        ,
                        Wt.injectIntoDevTools = function() {
                            var l = {
                                bundleType: 0,
                                version: Zu,
                                rendererPackageName: hm,
                                currentDispatcherRef: zt,
                                findFiberByHostInstance: Ju,
                                reconcilerVersion: "19.0.0"
                            };
                            if (Gf !== null && (l.rendererConfig = Gf),
                            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
                                l = !1;
                            else {
                                var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                                if (c.isDisabled || !c.supportsFiber)
                                    l = !0;
                                else {
                                    try {
                                        Ic = c.inject(l),
                                        ps = c
                                    } catch {}
                                    l = !!c.checkDCE
                                }
                            }
                            return l
                        }
                        ,
                        Wt.isAlreadyRendering = function() {
                            return !1
                        }
                        ,
                        Wt.observeVisibleRects = function(l, c, _, M) {
                            if (!th)
                                throw Error(o(363));
                            l = Bo(l, c);
                            var C = nh(l, _, M).disconnect;
                            return {
                                disconnect: function() {
                                    C()
                                }
                            }
                        }
                        ,
                        Wt.shouldError = function() {
                            return null
                        }
                        ,
                        Wt.shouldSuspend = function() {
                            return !1
                        }
                        ,
                        Wt.startHostTransition = function(l, c, _, M) {
                            if (l.tag !== 5)
                                throw Error(o(476));
                            var C = Ip(l).queue;
                            cf(l, C, c, Gn, _ === null ? a : function() {
                                var O = Ip(l).next.queue;
                                return Do(l, O, {}, Xi()),
                                _(M)
                            }
                            )
                        }
                        ,
                        Wt.updateContainer = function(l, c, _, M) {
                            var C = c.current
                              , O = Xi();
                            return lm(C, O, l, c, _, M),
                            O
                        }
                        ,
                        Wt.updateContainerSync = function(l, c, _, M) {
                            return c.tag === 0 && xs(),
                            lm(c.current, 2, l, c, _, M),
                            2
                        }
                        ,
                        Wt
                    }
                    ,
                    e.exports.default = e.exports,
                    Object.defineProperty(e.exports, "__esModule", {
                        value: !0
                    })
                }
                ))
                  , QC = ln(( (t, e) => {
                    e.exports = dz()
                }
                ));
                var pz = ln((t => {
                    var e = Symbol.for("react.transitional.element")
                      , n = Symbol.for("react.fragment");
                    function i(a, o, u) {
                        var f = null;
                        if (u !== void 0 && (f = "" + u),
                        o.key !== void 0 && (f = "" + o.key),
                        "key"in o) {
                            u = {};
                            for (var d in o)
                                d !== "key" && (u[d] = o[d])
                        } else
                            u = o;
                        return o = u.ref,
                        {
                            $$typeof: e,
                            type: a,
                            key: f,
                            ref: o !== void 0 ? o : null,
                            props: u
                        }
                    }
                    t.jsx = i,
                    t.jsxs = i
                }
                ))
                  , mz = ln(( (t, e) => {
                    e.exports = pz()
                }
                ))
                  , gn = tg(mz())
                  , gz = tg(QC())
                  , KC = hb();
                const s8 = ( () => {
                    var t, e;
                    return typeof window < "u" && (((t = window.document) == null ? void 0 : t.createElement) || ((e = window.navigator) == null ? void 0 : e.product) === "ReactNative")
                }
                )() ? gt.useLayoutEffect : gt.useEffect;
                function fb(t, e, n) {
                    if (!t)
                        return;
                    if (n(t) === !0)
                        return t;
                    let i = e ? t.return : t.child;
                    for (; i; ) {
                        const a = fb(i, e, n);
                        if (a)
                            return a;
                        i = e ? null : i.sibling
                    }
                }
                function JC(t) {
                    try {
                        return Object.defineProperties(t, {
                            _currentRenderer: {
                                get() {
                                    return null
                                },
                                set() {}
                            },
                            _currentRenderer2: {
                                get() {
                                    return null
                                },
                                set() {}
                            }
                        })
                    } catch {
                        return t
                    }
                }
                const db = JC(gt.createContext(null));
                var $C = class extends gt.Component {
                    render() {
                        return gt.createElement(db.Provider, {
                            value: this._reactInternals
                        }, this.props.children)
                    }
                }
                ;
                function e2() {
                    const t = gt.useContext(db);
                    if (t === null)
                        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
                    const e = gt.useId();
                    return gt.useMemo( () => {
                        for (const n of [t, t?.alternate]) {
                            if (!n)
                                continue;
                            const i = fb(n, !1, a => {
                                let o = a.memoizedState;
                                for (; o; ) {
                                    if (o.memoizedState === e)
                                        return !0;
                                    o = o.next
                                }
                            }
                            );
                            if (i)
                                return i
                        }
                    }
                    , [t, e])
                }
                const vz = Symbol.for("react.context")
                  , _z = t => t !== null && typeof t == "object" && "$$typeof"in t && t.$$typeof === vz;
                function yz() {
                    const t = e2()
                      , [e] = gt.useState( () => new Map);
                    e.clear();
                    let n = t;
                    for (; n; ) {
                        const i = n.type;
                        _z(i) && i !== db && !e.has(i) && e.set(i, gt.use(JC(i))),
                        n = n.return
                    }
                    return e
                }
                function Sz() {
                    const t = yz();
                    return gt.useMemo( () => Array.from(t.keys()).reduce( (e, n) => i => gt.createElement(e, null, gt.createElement(n.Provider, {
                        ...i,
                        value: t.get(n)
                    })), e => gt.createElement($C, {
                        ...e
                    })), [t])
                }
                function t2(t) {
                    let e = t.root;
                    for (; e.getState().previousRoot; )
                        e = e.getState().previousRoot;
                    return e
                }
                const a8 = gt.act
                  , n2 = t => t && t.isOrthographicCamera
                  , xz = t => t && t.hasOwnProperty("current")
                  , Mz = t => t != null && (typeof t == "string" || typeof t == "number" || t.isColor)
                  , Kg = ( (t, e) => typeof window < "u" && (((t = window.document) == null ? void 0 : t.createElement) || ((e = window.navigator) == null ? void 0 : e.product) === "ReactNative"))() ? gt.useLayoutEffect : gt.useEffect;
                function i2(t) {
                    const e = gt.useRef(t);
                    return Kg( () => {
                        e.current = t
                    }
                    , [t]),
                    e
                }
                function bz() {
                    const t = e2()
                      , e = Sz();
                    return gt.useMemo( () => ({children: n}) => (0,
                    gn.jsx)(fb(t, !0, i => i.type === gt.StrictMode) ? gt.StrictMode : gt.Fragment, {
                        children: (0,
                        gn.jsx)(e, {
                            children: n
                        })
                    }), [t, e])
                }
                function Tz({set: t}) {
                    return Kg( () => (t(new Promise( () => null)),
                    () => t(!1)), [t]),
                    null
                }
                const Az = (t => (t = class extends gt.Component {
                    constructor(...n) {
                        super(...n),
                        this.state = {
                            error: !1
                        }
                    }
                    componentDidCatch(n) {
                        this.props.set(n)
                    }
                    render() {
                        return this.state.error ? null : this.props.children
                    }
                }
                ,
                t.getDerivedStateFromError = () => ({
                    error: !0
                }),
                t))();
                function s2(t) {
                    var e;
                    const n = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
                    return Array.isArray(t) ? Math.min(Math.max(t[0], n), t[1]) : t
                }
                function cp(t) {
                    var e;
                    return (e = t.__r3f) == null ? void 0 : e.root.getState()
                }
                const gi = {
                    obj: t => t === Object(t) && !gi.arr(t) && typeof t != "function",
                    fun: t => typeof t == "function",
                    str: t => typeof t == "string",
                    num: t => typeof t == "number",
                    boo: t => typeof t == "boolean",
                    und: t => t === void 0,
                    nul: t => t === null,
                    arr: t => Array.isArray(t),
                    equ(t, e, {arrays: n="shallow", objects: i="reference", strict: a=!0}={}) {
                        if (typeof t != typeof e || !!t != !!e)
                            return !1;
                        if (gi.str(t) || gi.num(t) || gi.boo(t))
                            return t === e;
                        const o = gi.obj(t);
                        if (o && i === "reference")
                            return t === e;
                        const u = gi.arr(t);
                        if (u && n === "reference")
                            return t === e;
                        if ((u || o) && t === e)
                            return !0;
                        let f;
                        for (f in t)
                            if (!(f in e))
                                return !1;
                        if (o && n === "shallow" && i === "shallow") {
                            for (f in a ? e : t)
                                if (!gi.equ(t[f], e[f], {
                                    strict: a,
                                    objects: "reference"
                                }))
                                    return !1
                        } else
                            for (f in a ? e : t)
                                if (t[f] !== e[f])
                                    return !1;
                        if (gi.und(f)) {
                            if (u && t.length === 0 && e.length === 0 || o && Object.keys(t).length === 0 && Object.keys(e).length === 0)
                                return !0;
                            if (t !== e)
                                return !1
                        }
                        return !0
                    }
                };
                function Ez(t) {
                    const e = {
                        nodes: {},
                        materials: {},
                        meshes: {}
                    };
                    return t && t.traverse(n => {
                        n.name && (e.nodes[n.name] = n),
                        n.material && !e.materials[n.material.name] && (e.materials[n.material.name] = n.material),
                        n.isMesh && !e.meshes[n.name] && (e.meshes[n.name] = n)
                    }
                    ),
                    e
                }
                function Cz(t) {
                    t.type !== "Scene" && (t.dispose == null || t.dispose());
                    for (const e in t) {
                        const n = t[e];
                        n?.type !== "Scene" && (n == null || n.dispose == null || n.dispose())
                    }
                }
                const a2 = ["children", "key", "ref"];
                function wz(t) {
                    const e = {};
                    for (const n in t)
                        a2.includes(n) || (e[n] = t[n]);
                    return e
                }
                function Gy(t, e, n, i) {
                    const a = t;
                    let o = a?.__r3f;
                    return o || (o = {
                        root: e,
                        type: n,
                        parent: null,
                        children: [],
                        props: wz(i),
                        object: a,
                        eventCount: 0,
                        handlers: {},
                        isHidden: !1
                    },
                    a && (a.__r3f = o)),
                    o
                }
                function Jg(t, e) {
                    if (!e.includes("-"))
                        return {
                            root: t,
                            key: e,
                            target: t[e]
                        };
                    if (e in t)
                        return {
                            root: t,
                            key: e,
                            target: t[e]
                        };
                    let n = t;
                    const i = e.split("-");
                    for (const a of i) {
                        if (typeof n != "object" || n === null) {
                            if (n !== void 0) {
                                const o = i.slice(i.indexOf(a)).join("-");
                                return {
                                    root: n,
                                    key: o,
                                    target: void 0
                                }
                            }
                            return {
                                root: t,
                                key: e,
                                target: void 0
                            }
                        }
                        e = a,
                        t = n,
                        n = n[e]
                    }
                    return {
                        root: t,
                        key: e,
                        target: n
                    }
                }
                const r2 = /-\d+$/;
                function ky(t, e) {
                    if (gi.str(e.props.attach)) {
                        if (r2.test(e.props.attach)) {
                            const a = e.props.attach.replace(r2, "")
                              , {root: o, key: u} = Jg(t.object, a);
                            Array.isArray(o[u]) || (o[u] = [])
                        }
                        const {root: n, key: i} = Jg(t.object, e.props.attach);
                        e.previousAttach = n[i],
                        n[i] = e.object
                    } else
                        gi.fun(e.props.attach) && (e.previousAttach = e.props.attach(t.object, e.object))
                }
                function qy(t, e) {
                    if (gi.str(e.props.attach)) {
                        const {root: n, key: i} = Jg(t.object, e.props.attach)
                          , a = e.previousAttach;
                        a === void 0 ? delete n[i] : n[i] = a
                    } else
                        e.previousAttach == null || e.previousAttach(t.object, e.object);
                    delete e.previousAttach
                }
                const pb = [...a2, "args", "dispose", "attach", "object", "onUpdate", "dispose"]
                  , o2 = new Map;
                function Rz(t) {
                    let e = o2.get(t.constructor);
                    try {
                        e || (e = new t.constructor,
                        o2.set(t.constructor, e))
                    } catch {}
                    return e
                }
                function Nz(t, e) {
                    const n = {};
                    for (const i in e)
                        if (!pb.includes(i) && !gi.equ(e[i], t.props[i])) {
                            n[i] = e[i];
                            for (const a in e)
                                a.startsWith(`${i}-`) && (n[a] = e[a])
                        }
                    for (const i in t.props) {
                        if (pb.includes(i) || e.hasOwnProperty(i))
                            continue;
                        const {root: a, key: o} = Jg(t.object, i);
                        if (a.constructor && a.constructor.length === 0) {
                            const u = Rz(a);
                            gi.und(u) || (n[o] = u[o])
                        } else
                            n[o] = 0
                    }
                    return n
                }
                const Dz = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"]
                  , Oz = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
                function vu(t, e) {
                    var n;
                    const i = t.__r3f
                      , a = i && t2(i).getState()
                      , o = i?.eventCount;
                    for (const f in e) {
                        let d = e[f];
                        if (pb.includes(f))
                            continue;
                        if (i && Oz.test(f)) {
                            typeof d == "function" ? i.handlers[f] = d : delete i.handlers[f],
                            i.eventCount = Object.keys(i.handlers).length;
                            continue
                        }
                        if (d === void 0)
                            continue;
                        let {root: p, key: g, target: v} = Jg(t, f);
                        if (v === void 0 && (typeof p != "object" || p === null))
                            throw Error(`R3F: Cannot set "${f}". Ensure it is an object before setting "${g}".`);
                        if (v instanceof Bd && d instanceof Bd)
                            v.mask = d.mask;
                        else if (v instanceof ut && Mz(d))
                            v.set(d);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && typeof v.copy == "function" && d != null && d.constructor && v.constructor === d.constructor)
                            v.copy(d);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && Array.isArray(d))
                            typeof v.fromArray == "function" ? v.fromArray(d) : v.set(...d);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && typeof d == "number")
                            typeof v.setScalar == "function" ? v.setScalar(d) : v.set(d);
                        else {
                            var u;
                            p[g] = d,
                            a && !a.linear && Dz.includes(g) && (u = p[g]) != null && u.isTexture && p[g].format === Hs && p[g].type === da && (p[g].colorSpace = Gs)
                        }
                    }
                    if (i != null && i.parent && a != null && a.internal && (n = i.object) != null && n.isObject3D && o !== i.eventCount) {
                        const f = i.object
                          , d = a.internal.interaction.indexOf(f);
                        d > -1 && a.internal.interaction.splice(d, 1),
                        i.eventCount && f.raycast !== null && a.internal.interaction.push(f)
                    }
                    return i && i.props.attach === void 0 && (i.object.isBufferGeometry ? i.props.attach = "geometry" : i.object.isMaterial && (i.props.attach = "material")),
                    i && up(i),
                    t
                }
                function up(t) {
                    var e;
                    if (!t.parent)
                        return;
                    t.props.onUpdate == null || t.props.onUpdate(t.object);
                    const n = (e = t.root) == null || e.getState == null ? void 0 : e.getState();
                    n && n.internal.frames === 0 && n.invalidate()
                }
                function Uz(t, e) {
                    t.manual || (n2(t) ? (t.left = e.width / -2,
                    t.right = e.width / 2,
                    t.top = e.height / 2,
                    t.bottom = e.height / -2) : t.aspect = e.width / e.height,
                    t.updateProjectionMatrix())
                }
                const ya = t => t?.isObject3D;
                function Xy(t) {
                    return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId
                }
                function l2(t, e, n, i) {
                    const a = n.get(e);
                    a && (n.delete(e),
                    n.size === 0 && (t.delete(i),
                    a.target.releasePointerCapture(i)))
                }
                function Lz(t, e) {
                    const {internal: n} = t.getState();
                    n.interaction = n.interaction.filter(i => i !== e),
                    n.initialHits = n.initialHits.filter(i => i !== e),
                    n.hovered.forEach( (i, a) => {
                        (i.eventObject === e || i.object === e) && n.hovered.delete(a)
                    }
                    ),
                    n.capturedMap.forEach( (i, a) => {
                        l2(n.capturedMap, e, i, a)
                    }
                    )
                }
                function Iz(t) {
                    function e(d) {
                        const {internal: p} = t.getState()
                          , g = d.offsetX - p.initialClick[0]
                          , v = d.offsetY - p.initialClick[1];
                        return Math.round(Math.sqrt(g * g + v * v))
                    }
                    function n(d) {
                        return d.filter(p => ["Move", "Over", "Enter", "Out", "Leave"].some(g => {
                            var v;
                            return (v = p.__r3f) == null ? void 0 : v.handlers["onPointer" + g]
                        }
                        ))
                    }
                    function i(d, p) {
                        const g = t.getState()
                          , v = new Set
                          , y = []
                          , S = p ? p(g.internal.interaction) : g.internal.interaction;
                        for (let T = 0; T < S.length; T++) {
                            const R = cp(S[T]);
                            R && (R.raycaster.camera = void 0)
                        }
                        g.previousRoot || g.events.compute == null || g.events.compute(d, g);
                        function E(T) {
                            const R = cp(T);
                            if (!R || !R.events.enabled || R.raycaster.camera === null)
                                return [];
                            if (R.raycaster.camera === void 0) {
                                var N;
                                R.events.compute == null || R.events.compute(d, R, (N = R.previousRoot) == null ? void 0 : N.getState()),
                                R.raycaster.camera === void 0 && (R.raycaster.camera = null)
                            }
                            return R.raycaster.camera ? R.raycaster.intersectObject(T, !0) : []
                        }
                        let w = S.flatMap(E).sort( (T, R) => {
                            const N = cp(T.object)
                              , D = cp(R.object);
                            return !N || !D ? T.distance - R.distance : D.events.priority - N.events.priority || T.distance - R.distance
                        }
                        ).filter(T => {
                            const R = Xy(T);
                            return v.has(R) ? !1 : (v.add(R),
                            !0)
                        }
                        );
                        g.events.filter && (w = g.events.filter(w, g));
                        for (const T of w) {
                            let R = T.object;
                            for (; R; ) {
                                var A;
                                (A = R.__r3f) != null && A.eventCount && y.push({
                                    ...T,
                                    eventObject: R
                                }),
                                R = R.parent
                            }
                        }
                        if ("pointerId"in d && g.internal.capturedMap.has(d.pointerId))
                            for (let T of g.internal.capturedMap.get(d.pointerId).values())
                                v.has(Xy(T.intersection)) || y.push(T.intersection);
                        return y
                    }
                    function a(d, p, g, v) {
                        if (d.length) {
                            const y = {
                                stopped: !1
                            };
                            for (const S of d) {
                                let E = cp(S.object);
                                if (E || S.object.traverseAncestors(w => {
                                    const A = cp(w);
                                    if (A)
                                        return E = A,
                                        !1
                                }
                                ),
                                E) {
                                    const {raycaster: w, pointer: A, camera: T, internal: R} = E
                                      , N = new J(A.x,A.y,0).unproject(T)
                                      , D = B => {
                                        var P, G;
                                        return (P = (G = R.capturedMap.get(B)) == null ? void 0 : G.has(S.eventObject)) != null ? P : !1
                                    }
                                      , U = B => {
                                        const P = {
                                            intersection: S,
                                            target: p.target
                                        };
                                        R.capturedMap.has(B) ? R.capturedMap.get(B).set(S.eventObject, P) : R.capturedMap.set(B, new Map([[S.eventObject, P]])),
                                        p.target.setPointerCapture(B)
                                    }
                                      , z = B => {
                                        const P = R.capturedMap.get(B);
                                        P && l2(R.capturedMap, S.eventObject, P, B)
                                    }
                                    ;
                                    let I = {};
                                    for (let B in p) {
                                        let P = p[B];
                                        typeof P != "function" && (I[B] = P)
                                    }
                                    let V = {
                                        ...S,
                                        ...I,
                                        pointer: A,
                                        intersections: d,
                                        stopped: y.stopped,
                                        delta: g,
                                        unprojectedPoint: N,
                                        ray: w.ray,
                                        camera: T,
                                        stopPropagation() {
                                            const B = "pointerId"in p && R.capturedMap.get(p.pointerId);
                                            (!B || B.has(S.eventObject)) && (V.stopped = y.stopped = !0,
                                            R.hovered.size && Array.from(R.hovered.values()).find(P => P.eventObject === S.eventObject) && o([...d.slice(0, d.indexOf(S)), S]))
                                        },
                                        target: {
                                            hasPointerCapture: D,
                                            setPointerCapture: U,
                                            releasePointerCapture: z
                                        },
                                        currentTarget: {
                                            hasPointerCapture: D,
                                            setPointerCapture: U,
                                            releasePointerCapture: z
                                        },
                                        nativeEvent: p
                                    };
                                    if (v(V),
                                    y.stopped === !0)
                                        break
                                }
                            }
                        }
                        return d
                    }
                    function o(d) {
                        const {internal: p} = t.getState();
                        for (const g of p.hovered.values())
                            if (!d.length || !d.find(v => v.object === g.object && v.index === g.index && v.instanceId === g.instanceId)) {
                                const v = g.eventObject.__r3f;
                                if (p.hovered.delete(Xy(g)),
                                v != null && v.eventCount) {
                                    const y = v.handlers
                                      , S = {
                                        ...g,
                                        intersections: d
                                    };
                                    y.onPointerOut == null || y.onPointerOut(S),
                                    y.onPointerLeave == null || y.onPointerLeave(S)
                                }
                            }
                    }
                    function u(d, p) {
                        for (let g = 0; g < p.length; g++) {
                            const v = p[g].__r3f;
                            v == null || v.handlers.onPointerMissed == null || v.handlers.onPointerMissed(d)
                        }
                    }
                    function f(d) {
                        switch (d) {
                        case "onPointerLeave":
                        case "onPointerCancel":
                            return () => o([]);
                        case "onLostPointerCapture":
                            return p => {
                                const {internal: g} = t.getState();
                                "pointerId"in p && g.capturedMap.has(p.pointerId) && requestAnimationFrame( () => {
                                    g.capturedMap.has(p.pointerId) && (g.capturedMap.delete(p.pointerId),
                                    o([]))
                                }
                                )
                            }
                        }
                        return function(g) {
                            const {onPointerMissed: v, internal: y} = t.getState();
                            y.lastEvent.current = g;
                            const S = d === "onPointerMove"
                              , E = d === "onClick" || d === "onContextMenu" || d === "onDoubleClick"
                              , w = i(g, S ? n : void 0)
                              , A = E ? e(g) : 0;
                            d === "onPointerDown" && (y.initialClick = [g.offsetX, g.offsetY],
                            y.initialHits = w.map(R => R.eventObject)),
                            E && !w.length && A <= 2 && (u(g, y.interaction),
                            v && v(g)),
                            S && o(w);
                            function T(R) {
                                const N = R.eventObject
                                  , D = N.__r3f;
                                if (!(D != null && D.eventCount))
                                    return;
                                const U = D.handlers;
                                if (S) {
                                    if (U.onPointerOver || U.onPointerEnter || U.onPointerOut || U.onPointerLeave) {
                                        const z = Xy(R)
                                          , I = y.hovered.get(z);
                                        I ? I.stopped && R.stopPropagation() : (y.hovered.set(z, R),
                                        U.onPointerOver == null || U.onPointerOver(R),
                                        U.onPointerEnter == null || U.onPointerEnter(R))
                                    }
                                    U.onPointerMove == null || U.onPointerMove(R)
                                } else {
                                    const z = U[d];
                                    z ? (!E || y.initialHits.includes(N)) && (u(g, y.interaction.filter(I => !y.initialHits.includes(I))),
                                    z(R)) : E && y.initialHits.includes(N) && u(g, y.interaction.filter(I => !y.initialHits.includes(I)))
                                }
                            }
                            a(w, g, A, T)
                        }
                    }
                    return {
                        handlePointer: f
                    }
                }
                const c2 = t => !!(t != null && t.render)
                  , u2 = gt.createContext(null)
                  , zz = (t, e) => {
                    const n = oz( (f, d) => {
                        const p = new J
                          , g = new J
                          , v = new J;
                        function y(A=d().camera, T=g, R=d().size) {
                            const {width: N, height: D, top: U, left: z} = R
                              , I = N / D;
                            T.isVector3 ? v.copy(T) : v.set(...T);
                            const V = A.getWorldPosition(p).distanceTo(v);
                            if (n2(A))
                                return {
                                    width: N / A.zoom,
                                    height: D / A.zoom,
                                    top: U,
                                    left: z,
                                    factor: 1,
                                    distance: V,
                                    aspect: I
                                };
                            {
                                const B = A.fov * Math.PI / 180
                                  , P = 2 * Math.tan(B / 2) * V
                                  , G = P * (N / D);
                                return {
                                    width: G,
                                    height: P,
                                    top: U,
                                    left: z,
                                    factor: N / G,
                                    distance: V,
                                    aspect: I
                                }
                            }
                        }
                        let S;
                        const E = A => f(T => ({
                            performance: {
                                ...T.performance,
                                current: A
                            }
                        }))
                          , w = new Ge;
                        return {
                            set: f,
                            get: d,
                            gl: null,
                            camera: null,
                            raycaster: null,
                            events: {
                                priority: 1,
                                enabled: !0,
                                connected: !1
                            },
                            scene: null,
                            xr: null,
                            invalidate: (A=1) => t(d(), A),
                            advance: (A, T) => e(A, T, d()),
                            legacy: !1,
                            linear: !1,
                            flat: !1,
                            controls: null,
                            clock: new YM,
                            pointer: w,
                            mouse: w,
                            frameloop: "always",
                            onPointerMissed: void 0,
                            performance: {
                                current: 1,
                                min: .5,
                                max: 1,
                                debounce: 200,
                                regress: () => {
                                    const A = d();
                                    S && clearTimeout(S),
                                    A.performance.current !== A.performance.min && E(A.performance.min),
                                    S = setTimeout( () => E(d().performance.max), A.performance.debounce)
                                }
                            },
                            size: {
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0
                            },
                            viewport: {
                                initialDpr: 0,
                                dpr: 0,
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0,
                                aspect: 0,
                                distance: 0,
                                factor: 0,
                                getCurrentViewport: y
                            },
                            setEvents: A => f(T => ({
                                ...T,
                                events: {
                                    ...T.events,
                                    ...A
                                }
                            })),
                            setSize: (A, T, R=0, N=0) => {
                                const D = d().camera
                                  , U = {
                                    width: A,
                                    height: T,
                                    top: R,
                                    left: N
                                };
                                f(z => ({
                                    size: U,
                                    viewport: {
                                        ...z.viewport,
                                        ...y(D, g, U)
                                    }
                                }))
                            }
                            ,
                            setDpr: A => f(T => {
                                const R = s2(A);
                                return {
                                    viewport: {
                                        ...T.viewport,
                                        dpr: R,
                                        initialDpr: T.viewport.initialDpr || R
                                    }
                                }
                            }
                            ),
                            setFrameloop: (A="always") => {
                                const T = d().clock;
                                T.stop(),
                                T.elapsedTime = 0,
                                A !== "never" && (T.start(),
                                T.elapsedTime = 0),
                                f( () => ({
                                    frameloop: A
                                }))
                            }
                            ,
                            previousRoot: void 0,
                            internal: {
                                interaction: [],
                                hovered: new Map,
                                subscribers: [],
                                initialClick: [0, 0],
                                initialHits: [],
                                capturedMap: new Map,
                                lastEvent: gt.createRef(),
                                active: !1,
                                frames: 0,
                                priority: 0,
                                subscribe: (A, T, R) => {
                                    const N = d().internal;
                                    return N.priority = N.priority + (T > 0 ? 1 : 0),
                                    N.subscribers.push({
                                        ref: A,
                                        priority: T,
                                        store: R
                                    }),
                                    N.subscribers = N.subscribers.sort( (D, U) => D.priority - U.priority),
                                    () => {
                                        const D = d().internal;
                                        D != null && D.subscribers && (D.priority = D.priority - (T > 0 ? 1 : 0),
                                        D.subscribers = D.subscribers.filter(U => U.ref !== A))
                                    }
                                }
                            }
                        }
                    }
                    )
                      , i = n.getState();
                    let a = i.size
                      , o = i.viewport.dpr
                      , u = i.camera;
                    return n.subscribe( () => {
                        const {camera: f, size: d, viewport: p, gl: g, set: v} = n.getState();
                        if (d.width !== a.width || d.height !== a.height || p.dpr !== o) {
                            a = d,
                            o = p.dpr,
                            Uz(f, d),
                            p.dpr > 0 && g.setPixelRatio(p.dpr);
                            const y = typeof HTMLCanvasElement < "u" && g.domElement instanceof HTMLCanvasElement;
                            g.setSize(d.width, d.height, y)
                        }
                        f !== u && (u = f,
                        v(y => ({
                            viewport: {
                                ...y.viewport,
                                ...y.viewport.getCurrentViewport(f)
                            }
                        })))
                    }
                    ),
                    n.subscribe(f => t(f)),
                    n
                }
                ;
                function h2() {
                    const t = gt.useContext(u2);
                    if (!t)
                        throw new Error("R3F: Hooks can only be used within the Canvas component!");
                    return t
                }
                function f2(t=n => n, e) {
                    return h2()(t, e)
                }
                function mb(t, e=0) {
                    const n = h2()
                      , i = n.getState().internal.subscribe
                      , a = i2(t);
                    return Kg( () => i(a, e, n), [e, i, n]),
                    null
                }
                const d2 = new WeakMap
                  , Bz = t => {
                    var e;
                    return typeof t == "function" && (t == null || (e = t.prototype) == null ? void 0 : e.constructor) === t
                }
                ;
                function p2(t, e) {
                    return function(n, ...i) {
                        let a;
                        return Bz(n) ? (a = d2.get(n),
                        a || (a = new n,
                        d2.set(n, a))) : a = n,
                        t && t(a),
                        Promise.all(i.map(o => new Promise( (u, f) => a.load(o, d => {
                            ya(d?.scene) && Object.assign(d, Ez(d.scene)),
                            u(d)
                        }
                        , e, d => f(new Error(`Could not load ${o}: ${d?.message}`))))))
                    }
                }
                function m2(t, e, n, i) {
                    const a = Array.isArray(e) ? e : [e]
                      , o = cz(p2(n, i), [t, ...a], {
                        equal: gi.equ
                    });
                    return Array.isArray(e) ? o : o[0]
                }
                m2.preload = function(t, e, n) {
                    const i = Array.isArray(e) ? e : [e];
                    return uz(p2(n), [t, ...i])
                }
                ,
                m2.clear = function(t, e) {
                    return hz([t, ...Array.isArray(e) ? e : [e]])
                }
                ;
                var Pz = {
                    name: "@react-three/fiber",
                    version: "9.4.2",
                    description: "A React renderer for Threejs",
                    keywords: ["react", "renderer", "fiber", "three", "threejs"],
                    author: "Paul Henschel (https://github.com/drcmda)",
                    license: "MIT",
                    maintainers: ["Josh Ellis (https://github.com/joshuaellis)", "Cody Bennett (https://github.com/codyjasonbennett)", "Kris Baumgarter (https://github.com/krispya)"],
                    bugs: {
                        url: "https://github.com/pmndrs/react-three-fiber/issues"
                    },
                    homepage: "https://github.com/pmndrs/react-three-fiber#readme",
                    repository: {
                        type: "git",
                        url: "git+https://github.com/pmndrs/react-three-fiber.git"
                    },
                    collective: {
                        type: "opencollective",
                        url: "https://opencollective.com/react-three-fiber"
                    },
                    main: "dist/react-three-fiber.cjs.js",
                    module: "dist/react-three-fiber.esm.js",
                    types: "dist/react-three-fiber.cjs.d.ts",
                    "react-native": "native/dist/react-three-fiber-native.cjs.js",
                    sideEffects: !1,
                    preconstruct: {
                        entrypoints: ["index.tsx", "native.tsx"]
                    },
                    scripts: {
                        prebuild: "cp ../../readme.md readme.md"
                    },
                    dependencies: {
                        "@babel/runtime": "^7.17.8",
                        "@types/react-reconciler": "^0.32.0",
                        "@types/webxr": "*",
                        "base64-js": "^1.5.1",
                        buffer: "^6.0.3",
                        "its-fine": "^2.0.0",
                        "react-reconciler": "^0.31.0",
                        "react-use-measure": "^2.1.7",
                        scheduler: "^0.25.0",
                        "suspend-react": "^0.1.3",
                        "use-sync-external-store": "^1.4.0",
                        zustand: "^5.0.3"
                    },
                    peerDependencies: {
                        expo: ">=43.0",
                        "expo-asset": ">=8.4",
                        "expo-file-system": ">=11.0",
                        "expo-gl": ">=11.0",
                        react: "^19.0.0",
                        "react-dom": "^19.0.0",
                        "react-native": ">=0.78",
                        three: ">=0.156"
                    },
                    peerDependenciesMeta: {
                        "react-dom": {
                            optional: !0
                        },
                        "react-native": {
                            optional: !0
                        },
                        expo: {
                            optional: !0
                        },
                        "expo-asset": {
                            optional: !0
                        },
                        "expo-file-system": {
                            optional: !0
                        },
                        "expo-gl": {
                            optional: !0
                        }
                    }
                };
                function Vz(t) {
                    const e = (0,
                    gz.default)(t);
                    return e.injectIntoDevTools(),
                    e
                }
                const g2 = 0
                  , hp = {}
                  , Fz = /^three(?=[A-Z])/
                  , Wy = t => `${t[0].toUpperCase()}${t.slice(1)}`;
                let Hz = 0;
                const Gz = t => typeof t == "function";
                function kz(t) {
                    if (Gz(t)) {
                        const e = `${Hz++}`;
                        return hp[e] = t,
                        e
                    } else
                        Object.assign(hp, t)
                }
                function v2(t, e) {
                    const n = Wy(t)
                      , i = hp[n];
                    if (t !== "primitive" && !i)
                        throw new Error(`R3F: ${n} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
                    if (t === "primitive" && !e.object)
                        throw new Error("R3F: Primitives without 'object' are invalid!");
                    if (e.args !== void 0 && !Array.isArray(e.args))
                        throw new Error("R3F: The args prop must be an array!")
                }
                function qz(t, e, n) {
                    var i;
                    return t = Wy(t)in hp ? t : t.replace(Fz, ""),
                    v2(t, e),
                    t === "primitive" && (i = e.object) != null && i.__r3f && delete e.object.__r3f,
                    Gy(e.object, n, t, e)
                }
                function Xz(t) {
                    if (!t.isHidden) {
                        var e;
                        t.props.attach && (e = t.parent) != null && e.object ? qy(t.parent, t) : ya(t.object) && (t.object.visible = !1),
                        t.isHidden = !0,
                        up(t)
                    }
                }
                function _2(t) {
                    if (t.isHidden) {
                        var e;
                        t.props.attach && (e = t.parent) != null && e.object ? ky(t.parent, t) : ya(t.object) && t.props.visible !== !1 && (t.object.visible = !0),
                        t.isHidden = !1,
                        up(t)
                    }
                }
                function gb(t, e, n) {
                    const i = e.root.getState();
                    if (!(!t.parent && t.object !== i.scene)) {
                        if (!e.object) {
                            var a, o;
                            const u = hp[Wy(e.type)];
                            e.object = (a = e.props.object) != null ? a : new u(...(o = e.props.args) != null ? o : []),
                            e.object.__r3f = e
                        }
                        if (vu(e.object, e.props),
                        e.props.attach)
                            ky(t, e);
                        else if (ya(e.object) && ya(t.object)) {
                            const u = t.object.children.indexOf(n?.object);
                            if (n && u !== -1) {
                                const f = t.object.children.indexOf(e.object);
                                if (f !== -1) {
                                    t.object.children.splice(f, 1);
                                    const d = f < u ? u - 1 : u;
                                    t.object.children.splice(d, 0, e.object)
                                } else
                                    e.object.parent = t.object,
                                    t.object.children.splice(u, 0, e.object),
                                    e.object.dispatchEvent({
                                        type: "added"
                                    }),
                                    t.object.dispatchEvent({
                                        type: "childadded",
                                        child: e.object
                                    })
                            } else
                                t.object.add(e.object)
                        }
                        for (const u of e.children)
                            gb(e, u);
                        up(e)
                    }
                }
                function vb(t, e) {
                    e && (e.parent = t,
                    t.children.push(e),
                    gb(t, e))
                }
                function y2(t, e, n) {
                    if (!e || !n)
                        return;
                    e.parent = t;
                    const i = t.children.indexOf(n);
                    i !== -1 ? t.children.splice(i, 0, e) : t.children.push(e),
                    gb(t, e, n)
                }
                function S2(t) {
                    if (typeof t.dispose == "function") {
                        const e = () => {
                            try {
                                t.dispose()
                            } catch {}
                        }
                        ;
                        typeof IS_REACT_ACT_ENVIRONMENT < "u" ? e() : (0,
                        KC.unstable_scheduleCallback)(KC.unstable_IdlePriority, e)
                    }
                }
                function _b(t, e, n) {
                    if (!e)
                        return;
                    e.parent = null;
                    const i = t.children.indexOf(e);
                    i !== -1 && t.children.splice(i, 1),
                    e.props.attach ? qy(t, e) : ya(e.object) && ya(t.object) && (t.object.remove(e.object),
                    Lz(t2(e), e.object));
                    const a = e.props.dispose !== null && n !== !1;
                    for (let o = e.children.length - 1; o >= 0; o--) {
                        const u = e.children[o];
                        _b(e, u, a)
                    }
                    e.children.length = 0,
                    delete e.object.__r3f,
                    a && e.type !== "primitive" && e.object.type !== "Scene" && S2(e.object),
                    n === void 0 && up(e)
                }
                function Wz(t, e) {
                    for (const n of [t, t.alternate])
                        if (n !== null)
                            if (typeof n.ref == "function") {
                                n.refCleanup == null || n.refCleanup();
                                const i = n.ref(e);
                                typeof i == "function" && (n.refCleanup = i)
                            } else
                                n.ref && (n.ref.current = e)
                }
                const Yy = [];
                function Yz() {
                    for (const [n] of Yy) {
                        const i = n.parent;
                        if (i) {
                            n.props.attach ? qy(i, n) : ya(n.object) && ya(i.object) && i.object.remove(n.object);
                            for (const a of n.children)
                                a.props.attach ? qy(n, a) : ya(a.object) && ya(n.object) && n.object.remove(a.object)
                        }
                        n.isHidden && _2(n),
                        n.object.__r3f && delete n.object.__r3f,
                        n.type !== "primitive" && S2(n.object)
                    }
                    for (const [n,i,a] of Yy) {
                        n.props = i;
                        const o = n.parent;
                        if (o) {
                            var t, e;
                            const u = hp[Wy(n.type)];
                            n.object = (t = n.props.object) != null ? t : new u(...(e = n.props.args) != null ? e : []),
                            n.object.__r3f = n,
                            Wz(a, n.object),
                            vu(n.object, n.props),
                            n.props.attach ? ky(o, n) : ya(n.object) && ya(o.object) && o.object.add(n.object);
                            for (const f of n.children)
                                f.props.attach ? ky(n, f) : ya(f.object) && ya(n.object) && n.object.add(f.object);
                            up(n)
                        }
                    }
                    Yy.length = 0
                }
                const yb = () => {}
                  , x2 = {};
                let jy = g2;
                const jz = 0
                  , Zz = 4
                  , Sb = Vz({
                    isPrimaryRenderer: !1,
                    warnsIfNotActing: !1,
                    supportsMutation: !0,
                    supportsPersistence: !1,
                    supportsHydration: !1,
                    createInstance: qz,
                    removeChild: _b,
                    appendChild: vb,
                    appendInitialChild: vb,
                    insertBefore: y2,
                    appendChildToContainer(t, e) {
                        const n = t.getState().scene.__r3f;
                        !e || !n || vb(n, e)
                    },
                    removeChildFromContainer(t, e) {
                        const n = t.getState().scene.__r3f;
                        !e || !n || _b(n, e)
                    },
                    insertInContainerBefore(t, e, n) {
                        const i = t.getState().scene.__r3f;
                        !e || !n || !i || y2(i, e, n)
                    },
                    getRootHostContext: () => x2,
                    getChildHostContext: () => x2,
                    commitUpdate(t, e, n, i, a) {
                        var o, u, f;
                        v2(e, i);
                        let d = !1;
                        if ((t.type === "primitive" && n.object !== i.object || ((o = i.args) == null ? void 0 : o.length) !== ((u = n.args) == null ? void 0 : u.length) || (f = i.args) != null && f.some( (p, g) => {
                            var v;
                            return p !== ((v = n.args) == null ? void 0 : v[g])
                        }
                        )) && (d = !0),
                        d)
                            Yy.push([t, {
                                ...i
                            }, a]);
                        else {
                            const p = Nz(t, i);
                            Object.keys(p).length && (Object.assign(t.props, p),
                            vu(t.object, p))
                        }
                        (a.sibling === null || (a.flags & Zz) === jz) && Yz()
                    },
                    finalizeInitialChildren: () => !1,
                    commitMount() {},
                    getPublicInstance: t => t?.object,
                    prepareForCommit: () => null,
                    preparePortalMount: t => Gy(t.getState().scene, t, "", {}),
                    resetAfterCommit: () => {}
                    ,
                    shouldSetTextContent: () => !1,
                    clearContainer: () => !1,
                    hideInstance: Xz,
                    unhideInstance: _2,
                    createTextInstance: yb,
                    hideTextInstance: yb,
                    unhideTextInstance: yb,
                    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
                    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
                    noTimeout: -1,
                    getInstanceFromNode: () => null,
                    beforeActiveInstanceBlur() {},
                    afterActiveInstanceBlur() {},
                    detachDeletedInstance() {},
                    prepareScopeUpdate() {},
                    getInstanceFromScope: () => null,
                    shouldAttemptEagerTransition: () => !1,
                    trackSchedulerEvent: () => {}
                    ,
                    resolveEventType: () => null,
                    resolveEventTimeStamp: () => -1.1,
                    requestPostPaintCallback() {},
                    maySuspendCommit: () => !1,
                    preloadInstance: () => !0,
                    startSuspendingCommit() {},
                    suspendInstance() {},
                    waitForCommitToBeReady: () => null,
                    NotPendingTransition: null,
                    HostTransitionContext: gt.createContext(null),
                    setCurrentUpdatePriority(t) {
                        jy = t
                    },
                    getCurrentUpdatePriority() {
                        return jy
                    },
                    resolveUpdatePriority() {
                        var t;
                        if (jy !== g2)
                            return jy;
                        switch (typeof window < "u" && ((t = window.event) == null ? void 0 : t.type)) {
                        case "click":
                        case "contextmenu":
                        case "dblclick":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                            return I_.DiscreteEventPriority;
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerenter":
                        case "pointerleave":
                        case "wheel":
                            return I_.ContinuousEventPriority;
                        default:
                            return I_.DefaultEventPriority
                        }
                    },
                    resetFormInstance() {},
                    rendererPackageName: "@react-three/fiber",
                    rendererVersion: Pz.version
                })
                  , Yh = new Map
                  , fp = {
                    objects: "shallow",
                    strict: !1
                };
                function Qz(t, e) {
                    if (!e && typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && t.parentElement) {
                        const {width: n, height: i, top: a, left: o} = t.parentElement.getBoundingClientRect();
                        return {
                            width: n,
                            height: i,
                            top: a,
                            left: o
                        }
                    } else if (!e && typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas)
                        return {
                            width: t.width,
                            height: t.height,
                            top: 0,
                            left: 0
                        };
                    return {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        ...e
                    }
                }
                function Kz(t) {
                    const e = Yh.get(t)
                      , n = e?.fiber
                      , i = e?.store;
                    e && console.warn("R3F.createRoot should only be called once!");
                    const a = typeof reportError == "function" ? reportError : console.error
                      , o = i || zz(Cb, A2)
                      , u = n || Sb.createContainer(o, I_.ConcurrentRoot, null, !1, null, "", a, a, a, null);
                    e || Yh.set(t, {
                        fiber: u,
                        store: o
                    });
                    let f, d, p = !1, g = null;
                    return {
                        async configure(v={}) {
                            let y;
                            g = new Promise(ce => y = ce);
                            let {gl: S, size: E, scene: w, events: A, onCreated: T, shadows: R=!1, linear: N=!1, flat: D=!1, legacy: U=!1, orthographic: z=!1, frameloop: I="always", dpr: V=[1, 2], performance: B, raycaster: P, camera: G, onPointerMissed: K} = v
                              , ee = o.getState()
                              , te = ee.gl;
                            if (!ee.gl) {
                                const ce = {
                                    canvas: t,
                                    powerPreference: "high-performance",
                                    antialias: !0,
                                    alpha: !0
                                }
                                  , k = typeof S == "function" ? await S(ce) : S;
                                c2(k) ? te = k : te = new XC({
                                    ...ce,
                                    ...S
                                }),
                                ee.set({
                                    gl: te
                                })
                            }
                            let oe = ee.raycaster;
                            oe || ee.set({
                                raycaster: oe = new rC
                            });
                            const {params: q, ...F} = P || {};
                            if (gi.equ(F, oe, fp) || vu(oe, {
                                ...F
                            }),
                            gi.equ(q, oe.params, fp) || vu(oe, {
                                params: {
                                    ...oe.params,
                                    ...q
                                }
                            }),
                            !ee.camera || ee.camera === d && !gi.equ(d, G, fp)) {
                                d = G;
                                const ce = G?.isCamera
                                  , k = ce ? G : z ? new sp(0,0,0,0,.1,1e3) : new _s(75,0,.1,1e3);
                                ce || (k.position.z = 5,
                                G && (vu(k, G),
                                k.manual || ("aspect"in G || "left"in G || "right"in G || "bottom"in G || "top"in G) && (k.manual = !0,
                                k.updateProjectionMatrix())),
                                !ee.camera && !(G != null && G.rotation) && k.lookAt(0, 0, 0)),
                                ee.set({
                                    camera: k
                                }),
                                oe.camera = k
                            }
                            if (!ee.scene) {
                                let ce;
                                w != null && w.isScene ? (ce = w,
                                Gy(ce, o, "", {})) : (ce = new iM,
                                Gy(ce, o, "", {}),
                                w && vu(ce, w)),
                                ee.set({
                                    scene: ce
                                })
                            }
                            A && !ee.events.handlers && ee.set({
                                events: A(o)
                            });
                            const X = Qz(t, E);
                            if (gi.equ(X, ee.size, fp) || ee.setSize(X.width, X.height, X.top, X.left),
                            V && ee.viewport.dpr !== s2(V) && ee.setDpr(V),
                            ee.frameloop !== I && ee.setFrameloop(I),
                            ee.onPointerMissed || ee.set({
                                onPointerMissed: K
                            }),
                            B && !gi.equ(B, ee.performance, fp) && ee.set(ce => ({
                                performance: {
                                    ...ce.performance,
                                    ...B
                                }
                            })),
                            !ee.xr) {
                                var $;
                                const ce = (Ae, ie) => {
                                    const Me = o.getState();
                                    Me.frameloop !== "never" && A2(Ae, !0, Me, ie)
                                }
                                  , k = () => {
                                    const Ae = o.getState();
                                    Ae.gl.xr.enabled = Ae.gl.xr.isPresenting,
                                    Ae.gl.xr.setAnimationLoop(Ae.gl.xr.isPresenting ? ce : null),
                                    Ae.gl.xr.isPresenting || Cb(Ae)
                                }
                                  , pe = {
                                    connect() {
                                        const Ae = o.getState().gl;
                                        Ae.xr.addEventListener("sessionstart", k),
                                        Ae.xr.addEventListener("sessionend", k)
                                    },
                                    disconnect() {
                                        const Ae = o.getState().gl;
                                        Ae.xr.removeEventListener("sessionstart", k),
                                        Ae.xr.removeEventListener("sessionend", k)
                                    }
                                };
                                typeof (($ = te.xr) == null ? void 0 : $.addEventListener) == "function" && pe.connect(),
                                ee.set({
                                    xr: pe
                                })
                            }
                            if (te.shadowMap) {
                                const ce = te.shadowMap.enabled
                                  , k = te.shadowMap.type;
                                if (te.shadowMap.enabled = !!R,
                                gi.boo(R))
                                    te.shadowMap.type = ng;
                                else if (gi.str(R)) {
                                    var ne;
                                    const pe = {
                                        basic: f1,
                                        percentage: xd,
                                        soft: ng,
                                        variance: _h
                                    };
                                    te.shadowMap.type = (ne = pe[R]) != null ? ne : ng
                                } else
                                    gi.obj(R) && Object.assign(te.shadowMap, R);
                                (ce !== te.shadowMap.enabled || k !== te.shadowMap.type) && (te.shadowMap.needsUpdate = !0)
                            }
                            return xn.enabled = !U,
                            p || (te.outputColorSpace = N ? tu : Gs,
                            te.toneMapping = D ? Lr : W_),
                            ee.legacy !== U && ee.set( () => ({
                                legacy: U
                            })),
                            ee.linear !== N && ee.set( () => ({
                                linear: N
                            })),
                            ee.flat !== D && ee.set( () => ({
                                flat: D
                            })),
                            S && !gi.fun(S) && !c2(S) && !gi.equ(S, te, fp) && vu(te, S),
                            f = T,
                            p = !0,
                            y(),
                            this
                        },
                        render(v) {
                            return !p && !g && this.configure(),
                            g.then( () => {
                                Sb.updateContainer((0,
                                gn.jsx)(Jz, {
                                    store: o,
                                    children: v,
                                    onCreated: f,
                                    rootElement: t
                                }), u, null, () => {}
                                )
                            }
                            ),
                            o
                        },
                        unmount() {
                            M2(t)
                        }
                    }
                }
                function Jz({store: t, children: e, onCreated: n, rootElement: i}) {
                    return Kg( () => {
                        const a = t.getState();
                        a.set(o => ({
                            internal: {
                                ...o.internal,
                                active: !0
                            }
                        })),
                        n && n(a),
                        t.getState().events.connected || a.events.connect == null || a.events.connect(i)
                    }
                    , []),
                    (0,
                    gn.jsx)(u2.Provider, {
                        value: t,
                        children: e
                    })
                }
                function M2(t, e) {
                    const n = Yh.get(t)
                      , i = n?.fiber;
                    if (i) {
                        const a = n?.store.getState();
                        a && (a.internal.active = !1),
                        Sb.updateContainer(null, i, null, () => {
                            a && setTimeout( () => {
                                try {
                                    var o, u, f, d;
                                    a.events.disconnect == null || a.events.disconnect(),
                                    (o = a.gl) == null || (u = o.renderLists) == null || u.dispose == null || u.dispose(),
                                    (f = a.gl) == null || f.forceContextLoss == null || f.forceContextLoss(),
                                    (d = a.gl) != null && d.xr && a.xr.disconnect(),
                                    Cz(a.scene),
                                    Yh.delete(t),
                                    e && e(t)
                                } catch {}
                            }
                            , 500)
                        }
                        )
                    }
                }
                const $z = new Set
                  , eB = new Set
                  , tB = new Set;
                function xb(t, e) {
                    if (t.size)
                        for (const {callback: n} of t.values())
                            n(e)
                }
                function $g(t, e) {
                    switch (t) {
                    case "before":
                        return xb($z, e);
                    case "after":
                        return xb(eB, e);
                    case "tail":
                        return xb(tB, e)
                    }
                }
                let Mb, bb;
                function Tb(t, e, n) {
                    let i = e.clock.getDelta();
                    e.frameloop === "never" && typeof t == "number" && (i = t - e.clock.elapsedTime,
                    e.clock.oldTime = e.clock.elapsedTime,
                    e.clock.elapsedTime = t),
                    Mb = e.internal.subscribers;
                    for (let a = 0; a < Mb.length; a++)
                        bb = Mb[a],
                        bb.ref.current(bb.store.getState(), i, n);
                    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
                    e.internal.frames = Math.max(0, e.internal.frames - 1),
                    e.frameloop === "always" ? 1 : e.internal.frames
                }
                let Zy = !1, Ab = !1, Eb, b2, dp;
                function T2(t) {
                    b2 = requestAnimationFrame(T2),
                    Zy = !0,
                    Eb = 0,
                    $g("before", t),
                    Ab = !0;
                    for (const n of Yh.values()) {
                        var e;
                        dp = n.store.getState(),
                        dp.internal.active && (dp.frameloop === "always" || dp.internal.frames > 0) && !((e = dp.gl.xr) != null && e.isPresenting) && (Eb += Tb(t, dp))
                    }
                    if (Ab = !1,
                    $g("after", t),
                    Eb === 0)
                        return $g("tail", t),
                        Zy = !1,
                        cancelAnimationFrame(b2)
                }
                function Cb(t, e=1) {
                    var n;
                    if (!t)
                        return Yh.forEach(i => Cb(i.store.getState(), e));
                    (n = t.gl.xr) != null && n.isPresenting || !t.internal.active || t.frameloop === "never" || (e > 1 ? t.internal.frames = Math.min(60, t.internal.frames + e) : Ab ? t.internal.frames = 2 : t.internal.frames = 1,
                    Zy || (Zy = !0,
                    requestAnimationFrame(T2)))
                }
                function A2(t, e=!0, n, i) {
                    if (e && $g("before", t),
                    n)
                        Tb(t, n, i);
                    else
                        for (const a of Yh.values())
                            Tb(t, a.store.getState());
                    e && $g("after", t)
                }
                const wb = {
                    onClick: ["click", !1],
                    onContextMenu: ["contextmenu", !1],
                    onDoubleClick: ["dblclick", !1],
                    onWheel: ["wheel", !0],
                    onPointerDown: ["pointerdown", !0],
                    onPointerUp: ["pointerup", !0],
                    onPointerLeave: ["pointerleave", !0],
                    onPointerMove: ["pointermove", !0],
                    onPointerCancel: ["pointercancel", !0],
                    onLostPointerCapture: ["lostpointercapture", !0]
                };
                function nB(t) {
                    const {handlePointer: e} = Iz(t);
                    return {
                        priority: 1,
                        enabled: !0,
                        compute(n, i, a) {
                            i.pointer.set(n.offsetX / i.size.width * 2 - 1, -(n.offsetY / i.size.height) * 2 + 1),
                            i.raycaster.setFromCamera(i.pointer, i.camera)
                        },
                        connected: void 0,
                        handlers: Object.keys(wb).reduce( (n, i) => ({
                            ...n,
                            [i]: e(i)
                        }), {}),
                        update: () => {
                            var n;
                            const {events: i, internal: a} = t.getState();
                            (n = a.lastEvent) != null && n.current && i.handlers && i.handlers.onPointerMove(a.lastEvent.current)
                        }
                        ,
                        connect: n => {
                            const {set: i, events: a} = t.getState();
                            if (a.disconnect == null || a.disconnect(),
                            i(o => ({
                                events: {
                                    ...o.events,
                                    connected: n
                                }
                            })),
                            a.handlers)
                                for (const o in a.handlers) {
                                    const u = a.handlers[o]
                                      , [f,d] = wb[o];
                                    n.addEventListener(f, u, {
                                        passive: d
                                    })
                                }
                        }
                        ,
                        disconnect: () => {
                            const {set: n, events: i} = t.getState();
                            if (i.connected) {
                                if (i.handlers)
                                    for (const a in i.handlers) {
                                        const o = i.handlers[a]
                                          , [u] = wb[a];
                                        i.connected.removeEventListener(u, o)
                                    }
                                n(a => ({
                                    events: {
                                        ...a.events,
                                        connected: void 0
                                    }
                                }))
                            }
                        }
                    }
                }
                function E2(t, e) {
                    let n;
                    return (...i) => {
                        window.clearTimeout(n),
                        n = window.setTimeout( () => t(...i), e)
                    }
                }
                function iB({debounce: t, scroll: e, polyfill: n, offsetSize: i}={
                    debounce: 0,
                    scroll: !1,
                    offsetSize: !1
                }) {
                    const a = n || (typeof window > "u" ? class {
                    }
                    : window.ResizeObserver);
                    if (!a)
                        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
                    const [o,u] = (0,
                    gt.useState)({
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0,
                        bottom: 0,
                        right: 0,
                        x: 0,
                        y: 0
                    })
                      , f = (0,
                    gt.useRef)({
                        element: null,
                        scrollContainers: null,
                        resizeObserver: null,
                        lastBounds: o,
                        orientationHandler: null
                    })
                      , d = t ? typeof t == "number" ? t : t.scroll : null
                      , p = t ? typeof t == "number" ? t : t.resize : null
                      , g = (0,
                    gt.useRef)(!1);
                    (0,
                    gt.useEffect)( () => (g.current = !0,
                    () => {
                        g.current = !1
                    }
                    ));
                    const [v,y,S] = (0,
                    gt.useMemo)( () => {
                        const T = () => {
                            if (!f.current.element)
                                return;
                            const {left: R, top: N, width: D, height: U, bottom: z, right: I, x: V, y: B} = f.current.element.getBoundingClientRect()
                              , P = {
                                left: R,
                                top: N,
                                width: D,
                                height: U,
                                bottom: z,
                                right: I,
                                x: V,
                                y: B
                            };
                            f.current.element instanceof HTMLElement && i && (P.height = f.current.element.offsetHeight,
                            P.width = f.current.element.offsetWidth),
                            Object.freeze(P),
                            g.current && !oB(f.current.lastBounds, P) && u(f.current.lastBounds = P)
                        }
                        ;
                        return [T, p ? E2(T, p) : T, d ? E2(T, d) : T]
                    }
                    , [u, i, d, p]);
                    function E() {
                        f.current.scrollContainers && (f.current.scrollContainers.forEach(T => T.removeEventListener("scroll", S, !0)),
                        f.current.scrollContainers = null),
                        f.current.resizeObserver && (f.current.resizeObserver.disconnect(),
                        f.current.resizeObserver = null),
                        f.current.orientationHandler && ("orientation"in screen && "removeEventListener"in screen.orientation ? screen.orientation.removeEventListener("change", f.current.orientationHandler) : "onorientationchange"in window && window.removeEventListener("orientationchange", f.current.orientationHandler))
                    }
                    function w() {
                        f.current.element && (f.current.resizeObserver = new a(S),
                        f.current.resizeObserver.observe(f.current.element),
                        e && f.current.scrollContainers && f.current.scrollContainers.forEach(T => T.addEventListener("scroll", S, {
                            capture: !0,
                            passive: !0
                        })),
                        f.current.orientationHandler = () => {
                            S()
                        }
                        ,
                        "orientation"in screen && "addEventListener"in screen.orientation ? screen.orientation.addEventListener("change", f.current.orientationHandler) : "onorientationchange"in window && window.addEventListener("orientationchange", f.current.orientationHandler))
                    }
                    const A = T => {
                        !T || T === f.current.element || (E(),
                        f.current.element = T,
                        f.current.scrollContainers = C2(T),
                        w())
                    }
                    ;
                    return aB(S, !!e),
                    sB(y),
                    (0,
                    gt.useEffect)( () => {
                        E(),
                        w()
                    }
                    , [e, S, y]),
                    (0,
                    gt.useEffect)( () => E, []),
                    [A, o, v]
                }
                function sB(t) {
                    (0,
                    gt.useEffect)( () => {
                        const e = t;
                        return window.addEventListener("resize", e),
                        () => {
                            window.removeEventListener("resize", e)
                        }
                    }
                    , [t])
                }
                function aB(t, e) {
                    (0,
                    gt.useEffect)( () => {
                        if (e) {
                            const n = t;
                            return window.addEventListener("scroll", n, {
                                capture: !0,
                                passive: !0
                            }),
                            () => {
                                window.removeEventListener("scroll", n, !0)
                            }
                        }
                    }
                    , [t, e])
                }
                function C2(t) {
                    const e = [];
                    if (!t || t === document.body)
                        return e;
                    const {overflow: n, overflowX: i, overflowY: a} = window.getComputedStyle(t);
                    return [n, i, a].some(o => o === "auto" || o === "scroll") && e.push(t),
                    [...e, ...C2(t.parentElement)]
                }
                const rB = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
                  , oB = (t, e) => rB.every(n => t[n] === e[n]);
                var o8 = l1()
                  , l8 = QC()
                  , c8 = hb();
                function lB({ref: t, children: e, fallback: n, resize: i, style: a, gl: o, events: u=nB, eventSource: f, eventPrefix: d, shadows: p, linear: g, flat: v, legacy: y, orthographic: S, frameloop: E, dpr: w, performance: A, raycaster: T, camera: R, scene: N, onPointerMissed: D, onCreated: U, ...z}) {
                    gt.useMemo( () => kz(BL), []);
                    const I = bz()
                      , [V,B] = iB({
                        scroll: !0,
                        debounce: {
                            scroll: 50,
                            resize: 0
                        },
                        ...i
                    })
                      , P = gt.useRef(null)
                      , G = gt.useRef(null);
                    gt.useImperativeHandle(t, () => P.current);
                    const K = i2(D)
                      , [ee,te] = gt.useState(!1)
                      , [oe,q] = gt.useState(!1);
                    if (ee)
                        throw ee;
                    if (oe)
                        throw oe;
                    const F = gt.useRef(null);
                    return Kg( () => {
                        const X = P.current;
                        if (B.width > 0 && B.height > 0 && X) {
                            F.current || (F.current = Kz(X));
                            async function $() {
                                await F.current.configure({
                                    gl: o,
                                    scene: N,
                                    events: u,
                                    shadows: p,
                                    linear: g,
                                    flat: v,
                                    legacy: y,
                                    orthographic: S,
                                    frameloop: E,
                                    dpr: w,
                                    performance: A,
                                    raycaster: T,
                                    camera: R,
                                    size: B,
                                    onPointerMissed: (...ne) => K.current == null ? void 0 : K.current(...ne),
                                    onCreated: ne => {
                                        ne.events.connect == null || ne.events.connect(f ? xz(f) ? f.current : f : G.current),
                                        d && ne.setEvents({
                                            compute: (ce, k) => {
                                                const pe = ce[d + "X"]
                                                  , Ae = ce[d + "Y"];
                                                k.pointer.set(pe / k.size.width * 2 - 1, -(Ae / k.size.height) * 2 + 1),
                                                k.raycaster.setFromCamera(k.pointer, k.camera)
                                            }
                                        }),
                                        U?.(ne)
                                    }
                                }),
                                F.current.render((0,
                                gn.jsx)(I, {
                                    children: (0,
                                    gn.jsx)(Az, {
                                        set: q,
                                        children: (0,
                                        gn.jsx)(gt.Suspense, {
                                            fallback: (0,
                                            gn.jsx)(Tz, {
                                                set: te
                                            }),
                                            children: e ?? null
                                        })
                                    })
                                }))
                            }
                            $()
                        }
                    }
                    ),
                    gt.useEffect( () => {
                        const X = P.current;
                        if (X)
                            return () => M2(X)
                    }
                    , []),
                    (0,
                    gn.jsx)("div", {
                        ref: G,
                        style: {
                            position: "relative",
                            width: "100%",
                            height: "100%",
                            overflow: "hidden",
                            pointerEvents: f ? "none" : "auto",
                            ...a
                        },
                        ...z,
                        children: (0,
                        gn.jsx)("div", {
                            ref: V,
                            style: {
                                width: "100%",
                                height: "100%"
                            },
                            children: (0,
                            gn.jsx)("canvas", {
                                ref: P,
                                style: {
                                    display: "block"
                                },
                                children: n
                            })
                        })
                    })
                }
                function cB(t) {
                    return (0,
                    gn.jsx)($C, {
                        children: (0,
                        gn.jsx)(lB, {
                            ...t
                        })
                    })
                }
                const Rb = "15.1.22";
                var uB = ln(( (t, e) => {
                    function n(i) {
                        if (Array.isArray(i))
                            return i
                    }
                    e.exports = n,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , hB = ln(( (t, e) => {
                    function n(i, a) {
                        var o = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
                        if (o != null) {
                            var u, f, d, p, g = [], v = !0, y = !1;
                            try {
                                if (d = (o = o.call(i)).next,
                                a === 0) {
                                    if (Object(o) !== o)
                                        return;
                                    v = !1
                                } else
                                    for (; !(v = (u = d.call(o)).done) && (g.push(u.value),
                                    g.length !== a); v = !0)
                                        ;
                            } catch (S) {
                                y = !0,
                                f = S
                            } finally {
                                try {
                                    if (!v && o.return != null && (p = o.return(),
                                    Object(p) !== p))
                                        return
                                } finally {
                                    if (y)
                                        throw f
                                }
                            }
                            return g
                        }
                    }
                    e.exports = n,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , fB = ln(( (t, e) => {
                    function n(i, a) {
                        (a == null || a > i.length) && (a = i.length);
                        for (var o = 0, u = Array(a); o < a; o++)
                            u[o] = i[o];
                        return u
                    }
                    e.exports = n,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , dB = ln(( (t, e) => {
                    var n = fB();
                    function i(a, o) {
                        if (a) {
                            if (typeof a == "string")
                                return n(a, o);
                            var u = {}.toString.call(a).slice(8, -1);
                            return u === "Object" && a.constructor && (u = a.constructor.name),
                            u === "Map" || u === "Set" ? Array.from(a) : u === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u) ? n(a, o) : void 0
                        }
                    }
                    e.exports = i,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , pB = ln(( (t, e) => {
                    function n() {
                        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }
                    e.exports = n,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , mB = ln(( (t, e) => {
                    var n = uB()
                      , i = hB()
                      , a = dB()
                      , o = pB();
                    function u(f, d) {
                        return n(f) || i(f, d) || a(f, d) || o()
                    }
                    e.exports = u,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , gB = ln(( (t, e) => {
                    function n(i, a) {
                        if (!(i instanceof a))
                            throw new TypeError("Cannot call a class as a function")
                    }
                    e.exports = n,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , w2 = ln(( (t, e) => {
                    function n(i) {
                        "@babel/helpers - typeof";
                        return e.exports = n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
                            return typeof a
                        }
                        : function(a) {
                            return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
                        }
                        ,
                        e.exports.__esModule = !0,
                        e.exports.default = e.exports,
                        n(i)
                    }
                    e.exports = n,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , vB = ln(( (t, e) => {
                    var n = w2().default;
                    function i(a, o) {
                        if (n(a) != "object" || !a)
                            return a;
                        var u = a[Symbol.toPrimitive];
                        if (u !== void 0) {
                            var f = u.call(a, o || "default");
                            if (n(f) != "object")
                                return f;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return (o === "string" ? String : Number)(a)
                    }
                    e.exports = i,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , _B = ln(( (t, e) => {
                    var n = w2().default
                      , i = vB();
                    function a(o) {
                        var u = i(o, "string");
                        return n(u) == "symbol" ? u : u + ""
                    }
                    e.exports = a,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , yB = ln(( (t, e) => {
                    var n = _B();
                    function i(o, u) {
                        for (var f = 0; f < u.length; f++) {
                            var d = u[f];
                            d.enumerable = d.enumerable || !1,
                            d.configurable = !0,
                            "value"in d && (d.writable = !0),
                            Object.defineProperty(o, n(d.key), d)
                        }
                    }
                    function a(o, u, f) {
                        return u && i(o.prototype, u),
                        f && i(o, f),
                        Object.defineProperty(o, "prototype", {
                            writable: !1
                        }),
                        o
                    }
                    e.exports = a,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
                }
                ))
                  , R2 = ln(( (t, e) => {
                    (function(n, i) {
                        typeof t == "object" && typeof e < "u" ? i(t, mB(), gB(), yB()) : typeof define == "function" && define.amd ? define(["exports", "@babel/runtime/helpers/slicedToArray", "@babel/runtime/helpers/classCallCheck", "@babel/runtime/helpers/createClass"], i) : (n = typeof globalThis < "u" ? globalThis : n || self,
                        i(n.automationEvents = {}, n._slicedToArray, n._classCallCheck, n._createClass))
                    }
                    )(t, (function(n, i, a, o) {
                        "use strict";
                        var u = function(F, X, $) {
                            return {
                                endTime: X,
                                insertTime: $,
                                type: "exponentialRampToValue",
                                value: F
                            }
                        }
                          , f = function(F, X, $) {
                            return {
                                endTime: X,
                                insertTime: $,
                                type: "linearRampToValue",
                                value: F
                            }
                        }
                          , d = function(F, X) {
                            return {
                                startTime: X,
                                type: "setValue",
                                value: F
                            }
                        }
                          , p = function(F, X, $) {
                            return {
                                duration: $,
                                startTime: X,
                                type: "setValueCurve",
                                values: F
                            }
                        }
                          , g = function(F, X, $) {
                            var ne = $.startTime
                              , ce = $.target
                              , k = $.timeConstant;
                            return ce + (X - ce) * Math.exp((ne - F) / k)
                        }
                          , v = function(F) {
                            return F.type === "exponentialRampToValue"
                        }
                          , y = function(F) {
                            return F.type === "linearRampToValue"
                        }
                          , S = function(F) {
                            return v(F) || y(F)
                        }
                          , E = function(F) {
                            return F.type === "setValue"
                        }
                          , w = function(F) {
                            return F.type === "setValueCurve"
                        }
                          , A = function(F, X, $, ne) {
                            var ce = F[X];
                            return ce === void 0 ? ne : S(ce) || E(ce) ? ce.value : w(ce) ? ce.values[ce.values.length - 1] : g($, A(F, X - 1, ce.startTime, ne), ce)
                        }
                          , T = function(F, X, $, ne, ce) {
                            return $ === void 0 ? [ne.insertTime, ce] : S($) ? [$.endTime, $.value] : E($) ? [$.startTime, $.value] : w($) ? [$.startTime + $.duration, $.values[$.values.length - 1]] : [$.startTime, A(F, X - 1, $.startTime, ce)]
                        }
                          , R = function(F) {
                            return F.type === "cancelAndHold"
                        }
                          , N = function(F) {
                            return F.type === "cancelScheduledValues"
                        }
                          , D = function(F) {
                            return R(F) || N(F) ? F.cancelTime : v(F) || y(F) ? F.endTime : F.startTime
                        }
                          , U = function(F, X, $, ne) {
                            var ce = ne.endTime
                              , k = ne.value;
                            return $ === k ? k : 0 < $ && 0 < k || $ < 0 && k < 0 ? $ * Math.pow(k / $, (F - X) / (ce - X)) : 0
                        }
                          , z = function(F, X, $, ne) {
                            var ce = ne.endTime
                              , k = ne.value;
                            return $ + (F - X) / (ce - X) * (k - $)
                        }
                          , I = function(F, X) {
                            var $ = Math.floor(X)
                              , ne = Math.ceil(X);
                            return $ === ne ? F[$] : (1 - (X - $)) * F[$] + (1 - (ne - X)) * F[ne]
                        }
                          , V = function(F, X) {
                            var $ = X.duration
                              , ne = X.startTime
                              , ce = X.values;
                            return I(ce, (F - ne) / $ * (ce.length - 1))
                        }
                          , B = function(F) {
                            return F.type === "setTarget"
                        }
                          , P = (function() {
                            function q(F) {
                                a(this, q),
                                this._automationEvents = [],
                                this._currenTime = 0,
                                this._defaultValue = F
                            }
                            return o(q, [{
                                key: Symbol.iterator,
                                value: function() {
                                    return this._automationEvents[Symbol.iterator]()
                                }
                            }, {
                                key: "add",
                                value: function(X) {
                                    var $ = D(X);
                                    if (R(X) || N(X)) {
                                        var ne = this._automationEvents.findIndex(function(Q) {
                                            return N(X) && w(Q) ? Q.startTime + Q.duration >= $ : D(Q) >= $
                                        })
                                          , ce = this._automationEvents[ne];
                                        if (ne !== -1 && (this._automationEvents = this._automationEvents.slice(0, ne)),
                                        R(X)) {
                                            var k = this._automationEvents[this._automationEvents.length - 1];
                                            if (ce !== void 0 && S(ce)) {
                                                if (k !== void 0 && B(k))
                                                    throw new Error("The internal list is malformed.");
                                                var pe = k === void 0 ? ce.insertTime : w(k) ? k.startTime + k.duration : D(k)
                                                  , Ae = k === void 0 ? this._defaultValue : w(k) ? k.values[k.values.length - 1] : k.value
                                                  , ie = v(ce) ? U($, pe, Ae, ce) : z($, pe, Ae, ce)
                                                  , Me = v(ce) ? u(ie, $, this._currenTime) : f(ie, $, this._currenTime);
                                                this._automationEvents.push(Me)
                                            }
                                            if (k !== void 0 && B(k) && this._automationEvents.push(d(this.getValue($), $)),
                                            k !== void 0 && w(k) && k.startTime + k.duration > $) {
                                                var we = $ - k.startTime
                                                  , Te = (k.values.length - 1) / k.duration
                                                  , Je = Math.max(2, 1 + Math.ceil(we * Te))
                                                  , Ze = we / (Je - 1) * Te
                                                  , Ct = k.values.slice(0, Je);
                                                if (Ze < 1)
                                                    for (var bt = 1; bt < Je; bt += 1) {
                                                        var Ue = Ze * bt % 1;
                                                        Ct[bt] = k.values[bt - 1] * (1 - Ue) + k.values[bt] * Ue
                                                    }
                                                this._automationEvents[this._automationEvents.length - 1] = p(Ct, k.startTime, we)
                                            }
                                        }
                                    } else {
                                        var ve = this._automationEvents.findIndex(function(Q) {
                                            return D(Q) > $
                                        })
                                          , Ce = ve === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[ve - 1];
                                        if (Ce !== void 0 && w(Ce) && D(Ce) + Ce.duration > $)
                                            return !1;
                                        var qe = v(X) ? u(X.value, X.endTime, this._currenTime) : y(X) ? f(X.value, $, this._currenTime) : X;
                                        if (ve === -1)
                                            this._automationEvents.push(qe);
                                        else {
                                            if (w(X) && $ + X.duration > D(this._automationEvents[ve]))
                                                return !1;
                                            this._automationEvents.splice(ve, 0, qe)
                                        }
                                    }
                                    return !0
                                }
                            }, {
                                key: "flush",
                                value: function(X) {
                                    var $ = this._automationEvents.findIndex(function(k) {
                                        return D(k) > X
                                    });
                                    if ($ > 1) {
                                        var ne = this._automationEvents.slice($ - 1)
                                          , ce = ne[0];
                                        B(ce) && ne.unshift(d(A(this._automationEvents, $ - 2, ce.startTime, this._defaultValue), ce.startTime)),
                                        this._automationEvents = ne
                                    }
                                }
                            }, {
                                key: "getValue",
                                value: function(X) {
                                    if (this._automationEvents.length === 0)
                                        return this._defaultValue;
                                    var $ = this._automationEvents.findIndex(function(Je) {
                                        return D(Je) > X
                                    })
                                      , ne = this._automationEvents[$]
                                      , ce = ($ === -1 ? this._automationEvents.length : $) - 1
                                      , k = this._automationEvents[ce];
                                    if (k !== void 0 && B(k) && (ne === void 0 || !S(ne) || ne.insertTime > X))
                                        return g(X, A(this._automationEvents, ce - 1, k.startTime, this._defaultValue), k);
                                    if (k !== void 0 && E(k) && (ne === void 0 || !S(ne)))
                                        return k.value;
                                    if (k !== void 0 && w(k) && (ne === void 0 || !S(ne) || k.startTime + k.duration > X))
                                        return X < k.startTime + k.duration ? V(X, k) : k.values[k.values.length - 1];
                                    if (k !== void 0 && S(k) && (ne === void 0 || !S(ne)))
                                        return k.value;
                                    if (ne !== void 0 && v(ne)) {
                                        var pe = i(T(this._automationEvents, ce, k, ne, this._defaultValue), 2)
                                          , Ae = pe[0]
                                          , ie = pe[1];
                                        return U(X, Ae, ie, ne)
                                    }
                                    if (ne !== void 0 && y(ne)) {
                                        var Me = i(T(this._automationEvents, ce, k, ne, this._defaultValue), 2)
                                          , we = Me[0]
                                          , Te = Me[1];
                                        return z(X, we, Te, ne)
                                    }
                                    return this._defaultValue
                                }
                            }])
                        }
                        )()
                          , G = function(F) {
                            return {
                                cancelTime: F,
                                type: "cancelAndHold"
                            }
                        }
                          , K = function(F) {
                            return {
                                cancelTime: F,
                                type: "cancelScheduledValues"
                            }
                        }
                          , ee = function(F, X) {
                            return {
                                endTime: X,
                                type: "exponentialRampToValue",
                                value: F
                            }
                        }
                          , te = function(F, X) {
                            return {
                                endTime: X,
                                type: "linearRampToValue",
                                value: F
                            }
                        }
                          , oe = function(F, X, $) {
                            return {
                                startTime: X,
                                target: F,
                                timeConstant: $,
                                type: "setTarget"
                            }
                        };
                        n.AutomationEventList = P,
                        n.createCancelAndHoldAutomationEvent = G,
                        n.createCancelScheduledValuesAutomationEvent = K,
                        n.createExponentialRampToValueAutomationEvent = ee,
                        n.createLinearRampToValueAutomationEvent = te,
                        n.createSetTargetAutomationEvent = oe,
                        n.createSetValueAutomationEvent = d,
                        n.createSetValueCurveAutomationEvent = p
                    }
                    ))
                }
                ))
                  , SB = R2();
                const xB = () => new DOMException("","AbortError")
                  , MB = t => (e, n, [i,a,o], u) => {
                    t(e[a], [n, i, o], f => f[0] === n && f[1] === i, u)
                }
                  , bB = t => (e, n, i) => {
                    const a = [];
                    for (let o = 0; o < i.numberOfInputs; o += 1)
                        a.push(new Set);
                    t.set(e, {
                        activeInputs: a,
                        outputs: new Set,
                        passiveInputs: new WeakMap,
                        renderer: n
                    })
                }
                  , TB = t => (e, n) => {
                    t.set(e, {
                        activeInputs: new Set,
                        passiveInputs: new WeakMap,
                        renderer: n
                    })
                }
                  , pp = new WeakSet
                  , N2 = new WeakMap
                  , Nb = new WeakMap
                  , D2 = new WeakMap
                  , Db = new WeakMap
                  , Qy = new WeakMap
                  , O2 = new WeakMap
                  , Ob = new WeakMap
                  , Ub = new WeakMap
                  , Lb = new WeakMap
                  , U2 = {
                    construct() {
                        return U2
                    }
                }
                  , AB = t => {
                    try {
                        new new Proxy(t,U2)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , L2 = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/
                  , I2 = (t, e) => {
                    const n = [];
                    let i = t.replace(/^[\s]+/, "")
                      , a = i.match(L2);
                    for (; a !== null; ) {
                        const o = a[1].slice(1, -1)
                          , u = a[0].replace(/([\s]+)?;?$/, "").replace(o, new URL(o,e).toString());
                        n.push(u),
                        i = i.slice(a[0].length).replace(/^[\s]+/, ""),
                        a = i.match(L2)
                    }
                    return [n.join(";"), i]
                }
                  , z2 = t => {
                    if (t !== void 0 && !Array.isArray(t))
                        throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")
                }
                  , B2 = t => {
                    if (!AB(t))
                        throw new TypeError("The given value for processorCtor should be a constructor.");
                    if (t.prototype === null || typeof t.prototype != "object")
                        throw new TypeError("The given value for processorCtor should have a prototype.")
                }
                  , EB = (t, e, n, i, a, o, u, f, d, p, g, v, y) => {
                    let S = 0;
                    return (E, w, A={
                        credentials: "omit"
                    }) => {
                        const T = g.get(E);
                        if (T !== void 0 && T.has(w))
                            return Promise.resolve();
                        const R = p.get(E);
                        if (R !== void 0) {
                            const U = R.get(w);
                            if (U !== void 0)
                                return U
                        }
                        const N = o(E)
                          , D = N.audioWorklet === void 0 ? a(w).then( ([U,z]) => {
                            const [I,V] = I2(U, z);
                            return n(`${I};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${V}
})})(window,'_AWGS')`)
                        }
                        ).then( () => {
                            const U = y._AWGS.pop();
                            if (U === void 0)
                                throw new SyntaxError;
                            i(N.currentTime, N.sampleRate, () => U(class {
                            }
                            , void 0, (z, I) => {
                                if (z.trim() === "")
                                    throw e();
                                const V = Ub.get(N);
                                if (V !== void 0) {
                                    if (V.has(z))
                                        throw e();
                                    B2(I),
                                    z2(I.parameterDescriptors),
                                    V.set(z, I)
                                } else
                                    B2(I),
                                    z2(I.parameterDescriptors),
                                    Ub.set(N, new Map([[z, I]]))
                            }
                            , N.sampleRate, void 0, void 0))
                        }
                        ) : Promise.all([a(w), Promise.resolve(t(v, v))]).then( ([[U,z],I]) => {
                            const V = S + 1;
                            S = V;
                            const [B,P] = I2(U, z)
                              , G = `${B};((AudioWorkletProcessor,registerProcessor)=>{${P}
})(${I ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${I ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${I ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${V}',class extends AudioWorkletProcessor{process(){return !1}})`
                              , K = new Blob([G],{
                                type: "application/javascript; charset=utf-8"
                            })
                              , ee = URL.createObjectURL(K);
                            return N.audioWorklet.addModule(ee, A).then( () => {
                                if (f(N))
                                    return N;
                                const te = u(N);
                                return te.audioWorklet.addModule(ee, A).then( () => te)
                            }
                            ).then(te => {
                                if (d === null)
                                    throw new SyntaxError;
                                try {
                                    new d(te,`__sac${V}`)
                                } catch {
                                    throw new SyntaxError
                                }
                            }
                            ).finally( () => URL.revokeObjectURL(ee))
                        }
                        );
                        return R === void 0 ? p.set(E, new Map([[w, D]])) : R.set(w, D),
                        D.then( () => {
                            const U = g.get(E);
                            U === void 0 ? g.set(E, new Set([w])) : U.add(w)
                        }
                        ).finally( () => {
                            const U = p.get(E);
                            U !== void 0 && U.delete(w)
                        }
                        ),
                        D
                    }
                }
                  , Mo = (t, e) => {
                    const n = t.get(e);
                    if (n === void 0)
                        throw new Error("A value with the given key could not be found.");
                    return n
                }
                  , Ky = (t, e) => {
                    const n = Array.from(t).filter(e);
                    if (n.length > 1)
                        throw Error("More than one element was found.");
                    if (n.length === 0)
                        throw Error("No element was found.");
                    const [i] = n;
                    return t.delete(i),
                    i
                }
                  , P2 = (t, e, n, i) => {
                    const a = Mo(t, e)
                      , o = Ky(a, u => u[0] === n && u[1] === i);
                    return a.size === 0 && t.delete(e),
                    o
                }
                  , ev = t => Mo(O2, t)
                  , mp = t => {
                    if (pp.has(t))
                        throw new Error("The AudioNode is already stored.");
                    pp.add(t),
                    ev(t).forEach(e => e(!0))
                }
                  , V2 = t => "port"in t
                  , tv = t => {
                    if (!pp.has(t))
                        throw new Error("The AudioNode is not stored.");
                    pp.delete(t),
                    ev(t).forEach(e => e(!1))
                }
                  , Ib = (t, e) => {
                    !V2(t) && e.every(n => n.size === 0) && tv(t)
                }
                  , CB = (t, e, n, i, a, o, u, f, d, p, g, v, y) => {
                    const S = new WeakMap;
                    return (E, w, A, T, R) => {
                        const {activeInputs: N, passiveInputs: D} = o(w)
                          , {outputs: U} = o(E)
                          , z = f(E)
                          , I = V => {
                            const B = d(w)
                              , P = d(E);
                            if (V)
                                t(N, E, P2(D, E, A, T), !1),
                                !R && !v(E) && n(P, B, A, T),
                                y(w) && mp(w);
                            else {
                                e(D, T, i(N, E, A, T), !1),
                                !R && !v(E) && a(P, B, A, T);
                                const G = u(w);
                                if (G === 0)
                                    g(w) && Ib(w, N);
                                else {
                                    const K = S.get(w);
                                    K !== void 0 && clearTimeout(K),
                                    S.set(w, setTimeout( () => {
                                        g(w) && Ib(w, N)
                                    }
                                    , G * 1e3))
                                }
                            }
                        }
                        ;
                        return p(U, [w, A, T], V => V[0] === w && V[1] === A && V[2] === T, !0) ? (z.add(I),
                        g(E) ? t(N, E, [A, T, I], !0) : e(D, T, [E, A, I], !0),
                        !0) : !1
                    }
                }
                  , wB = t => (e, n, [i,a,o], u) => {
                    const f = e.get(i);
                    f === void 0 ? e.set(i, new Set([[a, n, o]])) : t(f, [a, n, o], d => d[0] === a && d[1] === n, u)
                }
                  , RB = t => (e, n) => {
                    const i = t(e, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    n.connect(i).connect(e.destination);
                    const a = () => {
                        n.removeEventListener("ended", a),
                        n.disconnect(i),
                        i.disconnect()
                    }
                    ;
                    n.addEventListener("ended", a)
                }
                  , NB = t => (e, n) => {
                    t(e).add(n)
                }
                  , DB = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    fftSize: 2048,
                    maxDecibels: -30,
                    minDecibels: -100,
                    smoothingTimeConstant: .8
                }
                  , OB = (t, e, n, i, a, o) => class extends t {
                    constructor(f, d) {
                        const p = a(f)
                          , g = i(p, {
                            ...DB,
                            ...d
                        })
                          , v = o(p) ? e() : null;
                        super(f, !1, g, v),
                        this._nativeAnalyserNode = g
                    }
                    get fftSize() {
                        return this._nativeAnalyserNode.fftSize
                    }
                    set fftSize(f) {
                        this._nativeAnalyserNode.fftSize = f
                    }
                    get frequencyBinCount() {
                        return this._nativeAnalyserNode.frequencyBinCount
                    }
                    get maxDecibels() {
                        return this._nativeAnalyserNode.maxDecibels
                    }
                    set maxDecibels(f) {
                        const d = this._nativeAnalyserNode.maxDecibels;
                        if (this._nativeAnalyserNode.maxDecibels = f,
                        !(f > this._nativeAnalyserNode.minDecibels))
                            throw this._nativeAnalyserNode.maxDecibels = d,
                            n()
                    }
                    get minDecibels() {
                        return this._nativeAnalyserNode.minDecibels
                    }
                    set minDecibels(f) {
                        const d = this._nativeAnalyserNode.minDecibels;
                        if (this._nativeAnalyserNode.minDecibels = f,
                        !(this._nativeAnalyserNode.maxDecibels > f))
                            throw this._nativeAnalyserNode.minDecibels = d,
                            n()
                    }
                    get smoothingTimeConstant() {
                        return this._nativeAnalyserNode.smoothingTimeConstant
                    }
                    set smoothingTimeConstant(f) {
                        this._nativeAnalyserNode.smoothingTimeConstant = f
                    }
                    getByteFrequencyData(f) {
                        this._nativeAnalyserNode.getByteFrequencyData(f)
                    }
                    getByteTimeDomainData(f) {
                        this._nativeAnalyserNode.getByteTimeDomainData(f)
                    }
                    getFloatFrequencyData(f) {
                        this._nativeAnalyserNode.getFloatFrequencyData(f)
                    }
                    getFloatTimeDomainData(f) {
                        this._nativeAnalyserNode.getFloatTimeDomainData(f)
                    }
                }
                  , js = (t, e) => t.context === e
                  , UB = (t, e, n) => () => {
                    const i = new WeakMap
                      , a = async (o, u) => {
                        let f = e(o);
                        return js(f, u) || (f = t(u, {
                            channelCount: f.channelCount,
                            channelCountMode: f.channelCountMode,
                            channelInterpretation: f.channelInterpretation,
                            fftSize: f.fftSize,
                            maxDecibels: f.maxDecibels,
                            minDecibels: f.minDecibels,
                            smoothingTimeConstant: f.smoothingTimeConstant
                        })),
                        i.set(u, f),
                        await n(o, u, f),
                        f
                    }
                    ;
                    return {
                        render(o, u) {
                            const f = i.get(u);
                            return f !== void 0 ? Promise.resolve(f) : a(o, u)
                        }
                    }
                }
                  , Jy = t => {
                    try {
                        t.copyToChannel(new Float32Array(1), 0, -1)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , ml = () => new DOMException("","IndexSizeError")
                  , zb = t => {
                    t.getChannelData = (e => n => {
                        try {
                            return e.call(t, n)
                        } catch (i) {
                            throw i.code === 12 ? ml() : i
                        }
                    }
                    )(t.getChannelData)
                }
                  , LB = {
                    numberOfChannels: 1
                }
                  , IB = (t, e, n, i, a, o, u, f) => {
                    let d = null;
                    return class XR {
                        constructor(g) {
                            if (a === null)
                                throw new Error("Missing the native OfflineAudioContext constructor.");
                            const {length: v, numberOfChannels: y, sampleRate: S} = {
                                ...LB,
                                ...g
                            };
                            d === null && (d = new a(1,1,44100));
                            const E = i !== null && e(o, o) ? new i({
                                length: v,
                                numberOfChannels: y,
                                sampleRate: S
                            }) : d.createBuffer(y, v, S);
                            if (E.numberOfChannels === 0)
                                throw n();
                            return typeof E.copyFromChannel != "function" ? (u(E),
                            zb(E)) : e(Jy, () => Jy(E)) || f(E),
                            t.add(E),
                            E
                        }
                        static[Symbol.hasInstance](g) {
                            return g !== null && typeof g == "object" && Object.getPrototypeOf(g) === XR.prototype || t.has(g)
                        }
                    }
                }
                  , Fa = -34028234663852886e22
                  , Sa = -Fa
                  , hc = t => pp.has(t)
                  , zB = {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }
                  , BB = (t, e, n, i, a, o, u, f) => class extends t {
                    constructor(p, g) {
                        const v = o(p)
                          , y = {
                            ...zB,
                            ...g
                        }
                          , S = a(v, y)
                          , E = u(v)
                          , w = E ? e() : null;
                        super(p, !1, S, w),
                        this._audioBufferSourceNodeRenderer = w,
                        this._isBufferNullified = !1,
                        this._isBufferSet = y.buffer !== null,
                        this._nativeAudioBufferSourceNode = S,
                        this._onended = null,
                        this._playbackRate = n(this, E, S.playbackRate, Sa, Fa)
                    }
                    get buffer() {
                        return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer
                    }
                    set buffer(p) {
                        if (this._nativeAudioBufferSourceNode.buffer = p,
                        p !== null) {
                            if (this._isBufferSet)
                                throw i();
                            this._isBufferSet = !0
                        }
                    }
                    get loop() {
                        return this._nativeAudioBufferSourceNode.loop
                    }
                    set loop(p) {
                        this._nativeAudioBufferSourceNode.loop = p
                    }
                    get loopEnd() {
                        return this._nativeAudioBufferSourceNode.loopEnd
                    }
                    set loopEnd(p) {
                        this._nativeAudioBufferSourceNode.loopEnd = p
                    }
                    get loopStart() {
                        return this._nativeAudioBufferSourceNode.loopStart
                    }
                    set loopStart(p) {
                        this._nativeAudioBufferSourceNode.loopStart = p
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(p) {
                        const g = typeof p == "function" ? f(this, p) : null;
                        this._nativeAudioBufferSourceNode.onended = g;
                        const v = this._nativeAudioBufferSourceNode.onended;
                        this._onended = v !== null && v === g ? p : v
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    start(p=0, g=0, v) {
                        if (this._nativeAudioBufferSourceNode.start(p, g, v),
                        this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = v === void 0 ? [p, g] : [p, g, v]),
                        this.context.state !== "closed") {
                            mp(this);
                            const y = () => {
                                this._nativeAudioBufferSourceNode.removeEventListener("ended", y),
                                hc(this) && tv(this)
                            }
                            ;
                            this._nativeAudioBufferSourceNode.addEventListener("ended", y)
                        }
                    }
                    stop(p=0) {
                        this._nativeAudioBufferSourceNode.stop(p),
                        this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = p)
                    }
                }
                  , PB = (t, e, n, i, a) => () => {
                    const o = new WeakMap;
                    let u = null
                      , f = null;
                    const d = async (p, g) => {
                        let v = n(p);
                        const y = js(v, g);
                        return y || (v = e(g, {
                            buffer: v.buffer,
                            channelCount: v.channelCount,
                            channelCountMode: v.channelCountMode,
                            channelInterpretation: v.channelInterpretation,
                            loop: v.loop,
                            loopEnd: v.loopEnd,
                            loopStart: v.loopStart,
                            playbackRate: v.playbackRate.value
                        }),
                        u !== null && v.start(...u),
                        f !== null && v.stop(f)),
                        o.set(g, v),
                        y ? await t(g, p.playbackRate, v.playbackRate) : await i(g, p.playbackRate, v.playbackRate),
                        await a(p, g, v),
                        v
                    }
                    ;
                    return {
                        set start(p) {
                            u = p
                        },
                        set stop(p) {
                            f = p
                        },
                        render(p, g) {
                            const v = o.get(g);
                            return v !== void 0 ? Promise.resolve(v) : d(p, g)
                        }
                    }
                }
                  , VB = t => "playbackRate"in t
                  , FB = t => "frequency"in t && "gain"in t
                  , HB = t => "offset"in t
                  , GB = t => !("frequency"in t) && "gain"in t
                  , kB = t => "detune"in t && "frequency"in t && !("gain"in t)
                  , qB = t => "pan"in t
                  , xa = t => Mo(N2, t)
                  , nv = t => Mo(D2, t)
                  , Bb = (t, e) => {
                    const {activeInputs: n} = xa(t);
                    n.forEach(a => a.forEach( ([o]) => {
                        e.includes(t) || Bb(o, [...e, t])
                    }
                    ));
                    const i = VB(t) ? [t.playbackRate] : V2(t) ? Array.from(t.parameters.values()) : FB(t) ? [t.Q, t.detune, t.frequency, t.gain] : HB(t) ? [t.offset] : GB(t) ? [t.gain] : kB(t) ? [t.detune, t.frequency] : qB(t) ? [t.pan] : [];
                    for (const a of i) {
                        const o = nv(a);
                        o !== void 0 && o.activeInputs.forEach( ([u]) => Bb(u, e))
                    }
                    hc(t) && tv(t)
                }
                  , $y = t => {
                    Bb(t.destination, [])
                }
                  , F2 = t => t === void 0 || typeof t == "number" || typeof t == "string" && (t === "balanced" || t === "interactive" || t === "playback")
                  , XB = (t, e, n, i, a, o, u, f, d) => class extends t {
                    constructor(g={}) {
                        if (d === null)
                            throw new Error("Missing the native AudioContext constructor.");
                        let v;
                        try {
                            v = new d(g)
                        } catch (E) {
                            throw E.code === 12 && E.message === "sampleRate is not in range" ? n() : E
                        }
                        if (v === null)
                            throw i();
                        if (!F2(g.latencyHint))
                            throw new TypeError(`The provided value '${g.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                        if (g.sampleRate !== void 0 && v.sampleRate !== g.sampleRate)
                            throw n();
                        super(v, 2);
                        const {latencyHint: y} = g
                          , {sampleRate: S} = v;
                        if (this._baseLatency = typeof v.baseLatency == "number" ? v.baseLatency : y === "balanced" ? 512 / S : y === "interactive" || y === void 0 ? 256 / S : y === "playback" ? 1024 / S : Math.max(2, Math.min(128, Math.round(y * S / 128))) * 128 / S,
                        this._nativeAudioContext = v,
                        d.name === "webkitAudioContext" ? (this._nativeGainNode = v.createGain(),
                        this._nativeOscillatorNode = v.createOscillator(),
                        this._nativeGainNode.gain.value = 1e-37,
                        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(v.destination),
                        this._nativeOscillatorNode.start()) : (this._nativeGainNode = null,
                        this._nativeOscillatorNode = null),
                        this._state = null,
                        v.state === "running") {
                            this._state = "suspended";
                            const E = () => {
                                this._state === "suspended" && (this._state = null),
                                v.removeEventListener("statechange", E)
                            }
                            ;
                            v.addEventListener("statechange", E)
                        }
                    }
                    get baseLatency() {
                        return this._baseLatency
                    }
                    get state() {
                        return this._state !== null ? this._state : this._nativeAudioContext.state
                    }
                    close() {
                        return this.state === "closed" ? this._nativeAudioContext.close().then( () => {
                            throw e()
                        }
                        ) : (this._state === "suspended" && (this._state = null),
                        this._nativeAudioContext.close().then( () => {
                            this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(),
                            this._nativeGainNode.disconnect(),
                            this._nativeOscillatorNode.disconnect()),
                            $y(this)
                        }
                        ))
                    }
                    createMediaElementSource(g) {
                        return new a(this,{
                            mediaElement: g
                        })
                    }
                    createMediaStreamDestination() {
                        return new o(this)
                    }
                    createMediaStreamSource(g) {
                        return new u(this,{
                            mediaStream: g
                        })
                    }
                    createMediaStreamTrackSource(g) {
                        return new f(this,{
                            mediaStreamTrack: g
                        })
                    }
                    resume() {
                        return this._state === "suspended" ? new Promise( (g, v) => {
                            const y = () => {
                                this._nativeAudioContext.removeEventListener("statechange", y),
                                this._nativeAudioContext.state === "running" ? g() : this.resume().then(g, v)
                            }
                            ;
                            this._nativeAudioContext.addEventListener("statechange", y)
                        }
                        ) : this._nativeAudioContext.resume().catch(g => {
                            throw g === void 0 || g.code === 15 ? e() : g
                        }
                        )
                    }
                    suspend() {
                        return this._nativeAudioContext.suspend().catch(g => {
                            throw g === void 0 ? e() : g
                        }
                        )
                    }
                }
                  , WB = (t, e, n, i, a, o, u, f) => class extends t {
                    constructor(p, g) {
                        const v = o(p)
                          , y = u(v)
                          , S = a(v, g, y)
                          , E = y ? e(f) : null;
                        super(p, !1, S, E),
                        this._isNodeOfNativeOfflineAudioContext = y,
                        this._nativeAudioDestinationNode = S
                    }
                    get channelCount() {
                        return this._nativeAudioDestinationNode.channelCount
                    }
                    set channelCount(p) {
                        if (this._isNodeOfNativeOfflineAudioContext)
                            throw i();
                        if (p > this._nativeAudioDestinationNode.maxChannelCount)
                            throw n();
                        this._nativeAudioDestinationNode.channelCount = p
                    }
                    get channelCountMode() {
                        return this._nativeAudioDestinationNode.channelCountMode
                    }
                    set channelCountMode(p) {
                        if (this._isNodeOfNativeOfflineAudioContext)
                            throw i();
                        this._nativeAudioDestinationNode.channelCountMode = p
                    }
                    get maxChannelCount() {
                        return this._nativeAudioDestinationNode.maxChannelCount
                    }
                }
                  , YB = t => {
                    const e = new WeakMap
                      , n = async (i, a) => {
                        const o = a.destination;
                        return e.set(a, o),
                        await t(i, a, o),
                        o
                    }
                    ;
                    return {
                        render(i, a) {
                            const o = e.get(a);
                            return o !== void 0 ? Promise.resolve(o) : n(i, a)
                        }
                    }
                }
                  , jB = (t, e, n, i, a, o, u, f) => (d, p) => {
                    const g = p.listener
                      , v = () => {
                        const U = new Float32Array(1)
                          , z = e(p, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: 9
                        })
                          , I = u(p);
                        let V = !1
                          , B = [0, 0, -1, 0, 1, 0]
                          , P = [0, 0, 0];
                        const G = () => {
                            if (V)
                                return;
                            V = !0;
                            const oe = i(p, 256, 9, 0);
                            oe.onaudioprocess = ({inputBuffer: q}) => {
                                const F = [o(q, U, 0), o(q, U, 1), o(q, U, 2), o(q, U, 3), o(q, U, 4), o(q, U, 5)];
                                F.some( ($, ne) => $ !== B[ne]) && (g.setOrientation(...F),
                                B = F);
                                const X = [o(q, U, 6), o(q, U, 7), o(q, U, 8)];
                                X.some( ($, ne) => $ !== P[ne]) && (g.setPosition(...X),
                                P = X)
                            }
                            ,
                            z.connect(oe)
                        }
                          , K = oe => q => {
                            q !== B[oe] && (B[oe] = q,
                            g.setOrientation(...B))
                        }
                          , ee = oe => q => {
                            q !== P[oe] && (P[oe] = q,
                            g.setPosition(...P))
                        }
                          , te = (oe, q, F) => {
                            const X = n(p, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: q
                            });
                            X.connect(z, 0, oe),
                            X.start(),
                            Object.defineProperty(X.offset, "defaultValue", {
                                get() {
                                    return q
                                }
                            });
                            const $ = t({
                                context: d
                            }, I, X.offset, Sa, Fa);
                            return f($, "value", ne => () => ne.call($), ne => ce => {
                                try {
                                    ne.call($, ce)
                                } catch (k) {
                                    if (k.code !== 9)
                                        throw k
                                }
                                G(),
                                I && F(ce)
                            }
                            ),
                            $.cancelAndHoldAtTime = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.cancelAndHoldAtTime),
                            $.cancelScheduledValues = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.cancelScheduledValues),
                            $.exponentialRampToValueAtTime = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.exponentialRampToValueAtTime),
                            $.linearRampToValueAtTime = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.linearRampToValueAtTime),
                            $.setTargetAtTime = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.setTargetAtTime),
                            $.setValueAtTime = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.setValueAtTime),
                            $.setValueCurveAtTime = (ne => I ? () => {
                                throw a()
                            }
                            : (...ce) => {
                                const k = ne.apply($, ce);
                                return G(),
                                k
                            }
                            )($.setValueCurveAtTime),
                            $
                        }
                        ;
                        return {
                            forwardX: te(0, 0, K(0)),
                            forwardY: te(1, 0, K(1)),
                            forwardZ: te(2, -1, K(2)),
                            positionX: te(6, 0, ee(0)),
                            positionY: te(7, 0, ee(1)),
                            positionZ: te(8, 0, ee(2)),
                            upX: te(3, 0, K(3)),
                            upY: te(4, 1, K(4)),
                            upZ: te(5, 0, K(5))
                        }
                    }
                      , {forwardX: y, forwardY: S, forwardZ: E, positionX: w, positionY: A, positionZ: T, upX: R, upY: N, upZ: D} = g.forwardX === void 0 ? v() : g;
                    return {
                        get forwardX() {
                            return y
                        },
                        get forwardY() {
                            return S
                        },
                        get forwardZ() {
                            return E
                        },
                        get positionX() {
                            return w
                        },
                        get positionY() {
                            return A
                        },
                        get positionZ() {
                            return T
                        },
                        get upX() {
                            return R
                        },
                        get upY() {
                            return N
                        },
                        get upZ() {
                            return D
                        }
                    }
                }
                  , eS = t => "context"in t
                  , iv = t => eS(t[0])
                  , jh = (t, e, n, i) => {
                    for (const a of t)
                        if (n(a)) {
                            if (i)
                                return !1;
                            throw Error("The set contains at least one similar element.")
                        }
                    return t.add(e),
                    !0
                }
                  , H2 = (t, e, [n,i], a) => {
                    jh(t, [e, n, i], o => o[0] === e && o[1] === n, a)
                }
                  , G2 = (t, [e,n,i], a) => {
                    const o = t.get(e);
                    o === void 0 ? t.set(e, new Set([[n, i]])) : jh(o, [n, i], u => u[0] === n, a)
                }
                  , gp = t => "inputs"in t
                  , tS = (t, e, n, i) => {
                    if (gp(e)) {
                        const a = e.inputs[i];
                        return t.connect(a, n, 0),
                        [a, n, 0]
                    }
                    return t.connect(e, n, i),
                    [e, n, i]
                }
                  , k2 = (t, e, n) => {
                    for (const i of t)
                        if (i[0] === e && i[1] === n)
                            return t.delete(i),
                            i;
                    return null
                }
                  , ZB = (t, e, n) => Ky(t, i => i[0] === e && i[1] === n)
                  , q2 = (t, e) => {
                    if (!ev(t).delete(e))
                        throw new Error("Missing the expected event listener.")
                }
                  , X2 = (t, e, n) => {
                    const i = Mo(t, e)
                      , a = Ky(i, o => o[0] === n);
                    return i.size === 0 && t.delete(e),
                    a
                }
                  , nS = (t, e, n, i) => {
                    gp(e) ? t.disconnect(e.inputs[i], n, 0) : t.disconnect(e, n, i)
                }
                  , pi = t => Mo(Nb, t)
                  , sv = t => Mo(Db, t)
                  , Zh = t => Ob.has(t)
                  , iS = t => !pp.has(t)
                  , W2 = (t, e) => new Promise(n => {
                    if (e !== null)
                        n(!0);
                    else {
                        const i = t.createScriptProcessor(256, 1, 1)
                          , a = t.createGain()
                          , o = t.createBuffer(1, 2, 44100)
                          , u = o.getChannelData(0);
                        u[0] = 1,
                        u[1] = 1;
                        const f = t.createBufferSource();
                        f.buffer = o,
                        f.loop = !0,
                        f.connect(i).connect(t.destination),
                        f.connect(a),
                        f.disconnect(a),
                        i.onaudioprocess = d => {
                            const p = d.inputBuffer.getChannelData(0);
                            Array.prototype.some.call(p, g => g === 1) ? n(!0) : n(!1),
                            f.stop(),
                            i.onaudioprocess = null,
                            f.disconnect(i),
                            i.disconnect(t.destination)
                        }
                        ,
                        f.start()
                    }
                }
                )
                  , Pb = (t, e) => {
                    const n = new Map;
                    for (const i of t)
                        for (const a of i) {
                            const o = n.get(a);
                            n.set(a, o === void 0 ? 1 : o + 1)
                        }
                    n.forEach( (i, a) => e(a, i))
                }
                  , sS = t => "context"in t
                  , QB = t => {
                    const e = new Map;
                    t.connect = (n => (i, a=0, o=0) => {
                        const u = sS(i) ? n(i, a, o) : n(i, a)
                          , f = e.get(i);
                        return f === void 0 ? e.set(i, [{
                            input: o,
                            output: a
                        }]) : f.every(d => d.input !== o || d.output !== a) && f.push({
                            input: o,
                            output: a
                        }),
                        u
                    }
                    )(t.connect.bind(t)),
                    t.disconnect = (n => (i, a, o) => {
                        if (n.apply(t),
                        i === void 0)
                            e.clear();
                        else if (typeof i == "number")
                            for (const [u,f] of e) {
                                const d = f.filter(p => p.output !== i);
                                d.length === 0 ? e.delete(u) : e.set(u, d)
                            }
                        else if (e.has(i))
                            if (a === void 0)
                                e.delete(i);
                            else {
                                const u = e.get(i);
                                if (u !== void 0) {
                                    const f = u.filter(d => d.output !== a && (d.input !== o || o === void 0));
                                    f.length === 0 ? e.delete(i) : e.set(i, f)
                                }
                            }
                        for (const [u,f] of e)
                            f.forEach(d => {
                                sS(u) ? t.connect(u, d.output, d.input) : t.connect(u, d.output)
                            }
                            )
                    }
                    )(t.disconnect)
                }
                  , KB = (t, e, n, i) => {
                    const {activeInputs: a, passiveInputs: o} = nv(e)
                      , {outputs: u} = xa(t)
                      , f = ev(t)
                      , d = p => {
                        const g = pi(t)
                          , v = sv(e);
                        p ? (H2(a, t, X2(o, t, n), !1),
                        !i && !Zh(t) && g.connect(v, n)) : (G2(o, ZB(a, t, n), !1),
                        !i && !Zh(t) && g.disconnect(v, n))
                    }
                    ;
                    return jh(u, [e, n], p => p[0] === e && p[1] === n, !0) ? (f.add(d),
                    hc(t) ? H2(a, t, [n, d], !0) : G2(o, [t, n, d], !0),
                    !0) : !1
                }
                  , JB = (t, e, n, i) => {
                    const {activeInputs: a, passiveInputs: o} = xa(e)
                      , u = k2(a[i], t, n);
                    return u === null ? [P2(o, t, n, i)[2], !1] : [u[2], !0]
                }
                  , $B = (t, e, n) => {
                    const {activeInputs: i, passiveInputs: a} = nv(e)
                      , o = k2(i, t, n);
                    return o === null ? [X2(a, t, n)[1], !1] : [o[2], !0]
                }
                  , Vb = (t, e, n, i, a) => {
                    const [o,u] = JB(t, n, i, a);
                    if (o !== null && (q2(t, o),
                    u && !e && !Zh(t) && nS(pi(t), pi(n), i, a)),
                    hc(n)) {
                        const {activeInputs: f} = xa(n);
                        Ib(n, f)
                    }
                }
                  , Fb = (t, e, n, i) => {
                    const [a,o] = $B(t, n, i);
                    a !== null && (q2(t, a),
                    o && !e && !Zh(t) && pi(t).disconnect(sv(n), i))
                }
                  , e5 = (t, e) => {
                    const n = xa(t)
                      , i = [];
                    for (const a of n.outputs)
                        iv(a) ? Vb(t, e, ...a) : Fb(t, e, ...a),
                        i.push(a[0]);
                    return n.outputs.clear(),
                    i
                }
                  , t5 = (t, e, n) => {
                    const i = xa(t)
                      , a = [];
                    for (const o of i.outputs)
                        o[1] === n && (iv(o) ? Vb(t, e, ...o) : Fb(t, e, ...o),
                        a.push(o[0]),
                        i.outputs.delete(o));
                    return a
                }
                  , n5 = (t, e, n, i, a) => {
                    const o = xa(t);
                    return Array.from(o.outputs).filter(u => u[0] === n && (i === void 0 || u[1] === i) && (a === void 0 || u[2] === a)).map(u => (iv(u) ? Vb(t, e, ...u) : Fb(t, e, ...u),
                    o.outputs.delete(u),
                    u[0]))
                }
                  , i5 = (t, e, n, i, a, o, u, f, d, p, g, v, y, S, E, w) => class extends p {
                    constructor(T, R, N, D) {
                        super(N),
                        this._context = T,
                        this._nativeAudioNode = N;
                        const U = g(T);
                        v(U) && n(W2, () => W2(U, w)) !== !0 && QB(N),
                        Nb.set(this, N),
                        O2.set(this, new Set),
                        T.state !== "closed" && R && mp(this),
                        t(this, D, N)
                    }
                    get channelCount() {
                        return this._nativeAudioNode.channelCount
                    }
                    set channelCount(T) {
                        this._nativeAudioNode.channelCount = T
                    }
                    get channelCountMode() {
                        return this._nativeAudioNode.channelCountMode
                    }
                    set channelCountMode(T) {
                        this._nativeAudioNode.channelCountMode = T
                    }
                    get channelInterpretation() {
                        return this._nativeAudioNode.channelInterpretation
                    }
                    set channelInterpretation(T) {
                        this._nativeAudioNode.channelInterpretation = T
                    }
                    get context() {
                        return this._context
                    }
                    get numberOfInputs() {
                        return this._nativeAudioNode.numberOfInputs
                    }
                    get numberOfOutputs() {
                        return this._nativeAudioNode.numberOfOutputs
                    }
                    connect(T, R=0, N=0) {
                        if (R < 0 || R >= this._nativeAudioNode.numberOfOutputs)
                            throw a();
                        const D = E(g(this._context));
                        if (y(T) || S(T))
                            throw o();
                        if (eS(T)) {
                            const z = pi(T);
                            try {
                                const I = tS(this._nativeAudioNode, z, R, N)
                                  , V = iS(this);
                                (D || V) && this._nativeAudioNode.disconnect(...I),
                                this.context.state !== "closed" && !V && iS(T) && mp(T)
                            } catch (I) {
                                throw I.code === 12 ? o() : I
                            }
                            return e(this, T, R, N, D) && Pb(d([this], T), i(D)),
                            T
                        }
                        const U = sv(T);
                        if (U.name === "playbackRate" && U.maxValue === 1024)
                            throw u();
                        try {
                            this._nativeAudioNode.connect(U, R),
                            (D || iS(this)) && this._nativeAudioNode.disconnect(U, R)
                        } catch (z) {
                            throw z.code === 12 ? o() : z
                        }
                        KB(this, T, R, D) && Pb(d([this], T), i(D))
                    }
                    disconnect(T, R, N) {
                        let D;
                        const U = E(g(this._context));
                        if (T === void 0)
                            D = e5(this, U);
                        else if (typeof T == "number") {
                            if (T < 0 || T >= this.numberOfOutputs)
                                throw a();
                            D = t5(this, U, T)
                        } else {
                            if (R !== void 0 && (R < 0 || R >= this.numberOfOutputs) || eS(T) && N !== void 0 && (N < 0 || N >= T.numberOfInputs))
                                throw a();
                            if (D = n5(this, U, T, R, N),
                            D.length === 0)
                                throw o()
                        }
                        for (const z of D)
                            Pb(d([this], z), f)
                    }
                }
                  , s5 = (t, e, n, i, a, o, u, f, d, p, g, v, y) => (S, E, w, A=null, T=null) => {
                    const R = w.value
                      , N = new SB.AutomationEventList(R)
                      , D = E ? i(N) : null
                      , U = {
                        get defaultValue() {
                            return R
                        },
                        get maxValue() {
                            return A === null ? w.maxValue : A
                        },
                        get minValue() {
                            return T === null ? w.minValue : T
                        },
                        get value() {
                            return w.value
                        },
                        set value(z) {
                            w.value = z,
                            U.setValueAtTime(z, S.context.currentTime)
                        },
                        cancelAndHoldAtTime(z) {
                            if (typeof w.cancelAndHoldAtTime == "function")
                                D === null && N.flush(S.context.currentTime),
                                N.add(a(z)),
                                w.cancelAndHoldAtTime(z);
                            else {
                                const I = Array.from(N).pop();
                                D === null && N.flush(S.context.currentTime),
                                N.add(a(z));
                                const V = Array.from(N).pop();
                                w.cancelScheduledValues(z),
                                I !== V && V !== void 0 && (V.type === "exponentialRampToValue" ? w.exponentialRampToValueAtTime(V.value, V.endTime) : V.type === "linearRampToValue" ? w.linearRampToValueAtTime(V.value, V.endTime) : V.type === "setValue" ? w.setValueAtTime(V.value, V.startTime) : V.type === "setValueCurve" && w.setValueCurveAtTime(V.values, V.startTime, V.duration))
                            }
                            return U
                        },
                        cancelScheduledValues(z) {
                            return D === null && N.flush(S.context.currentTime),
                            N.add(o(z)),
                            w.cancelScheduledValues(z),
                            U
                        },
                        exponentialRampToValueAtTime(z, I) {
                            if (z === 0)
                                throw new RangeError;
                            if (!Number.isFinite(I) || I < 0)
                                throw new RangeError;
                            const V = S.context.currentTime;
                            return D === null && N.flush(V),
                            Array.from(N).length === 0 && (N.add(p(R, V)),
                            w.setValueAtTime(R, V)),
                            N.add(u(z, I)),
                            w.exponentialRampToValueAtTime(z, I),
                            U
                        },
                        linearRampToValueAtTime(z, I) {
                            const V = S.context.currentTime;
                            return D === null && N.flush(V),
                            Array.from(N).length === 0 && (N.add(p(R, V)),
                            w.setValueAtTime(R, V)),
                            N.add(f(z, I)),
                            w.linearRampToValueAtTime(z, I),
                            U
                        },
                        setTargetAtTime(z, I, V) {
                            return D === null && N.flush(S.context.currentTime),
                            N.add(d(z, I, V)),
                            w.setTargetAtTime(z, I, V),
                            U
                        },
                        setValueAtTime(z, I) {
                            return D === null && N.flush(S.context.currentTime),
                            N.add(p(z, I)),
                            w.setValueAtTime(z, I),
                            U
                        },
                        setValueCurveAtTime(z, I, V) {
                            const B = z instanceof Float32Array ? z : new Float32Array(z);
                            if (v !== null && v.name === "webkitAudioContext") {
                                const P = I + V
                                  , G = S.context.sampleRate
                                  , K = Math.ceil(I * G)
                                  , ee = Math.floor(P * G)
                                  , te = ee - K
                                  , oe = new Float32Array(te);
                                for (let F = 0; F < te; F += 1) {
                                    const X = (B.length - 1) / V * ((K + F) / G - I)
                                      , $ = Math.floor(X)
                                      , ne = Math.ceil(X);
                                    oe[F] = $ === ne ? B[$] : (1 - (X - $)) * B[$] + (1 - (ne - X)) * B[ne]
                                }
                                D === null && N.flush(S.context.currentTime),
                                N.add(g(oe, I, V)),
                                w.setValueCurveAtTime(oe, I, V);
                                const q = ee / G;
                                q < P && y(U, oe[oe.length - 1], q),
                                y(U, B[B.length - 1], P)
                            } else
                                D === null && N.flush(S.context.currentTime),
                                N.add(g(B, I, V)),
                                w.setValueCurveAtTime(B, I, V);
                            return U
                        }
                    };
                    return n.set(U, w),
                    e.set(U, S),
                    t(U, D),
                    U
                }
                  , a5 = t => ({
                    replay(e) {
                        for (const n of t)
                            if (n.type === "exponentialRampToValue") {
                                const {endTime: i, value: a} = n;
                                e.exponentialRampToValueAtTime(a, i)
                            } else if (n.type === "linearRampToValue") {
                                const {endTime: i, value: a} = n;
                                e.linearRampToValueAtTime(a, i)
                            } else if (n.type === "setTarget") {
                                const {startTime: i, target: a, timeConstant: o} = n;
                                e.setTargetAtTime(a, i, o)
                            } else if (n.type === "setValue") {
                                const {startTime: i, value: a} = n;
                                e.setValueAtTime(a, i)
                            } else if (n.type === "setValueCurve") {
                                const {duration: i, startTime: a, values: o} = n;
                                e.setValueCurveAtTime(o, a, i)
                            } else
                                throw new Error("Can't apply an unknown automation.")
                    }
                });
                var Y2 = class {
                    constructor(t) {
                        this._map = new Map(t)
                    }
                    get size() {
                        return this._map.size
                    }
                    entries() {
                        return this._map.entries()
                    }
                    forEach(t, e=null) {
                        return this._map.forEach( (n, i) => t.call(e, n, i, this))
                    }
                    get(t) {
                        return this._map.get(t)
                    }
                    has(t) {
                        return this._map.has(t)
                    }
                    keys() {
                        return this._map.keys()
                    }
                    values() {
                        return this._map.values()
                    }
                }
                ;
                const r5 = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: 1,
                    numberOfOutputs: 1,
                    parameterData: {},
                    processorOptions: {}
                }
                  , o5 = (t, e, n, i, a, o, u, f, d, p, g, v, y, S) => class extends e {
                    constructor(w, A, T) {
                        var R;
                        const N = f(w)
                          , D = d(N)
                          , U = g({
                            ...r5,
                            ...T
                        });
                        y(U);
                        const z = Ub.get(N)
                          , I = z?.get(A)
                          , V = a(D || N.state !== "closed" ? N : (R = u(N)) !== null && R !== void 0 ? R : N, D ? null : w.baseLatency, p, A, I, U)
                          , B = D ? i(A, U, I) : null;
                        super(w, !0, V, B);
                        const P = [];
                        V.parameters.forEach( (K, ee) => {
                            const te = n(this, D, K);
                            P.push([ee, te])
                        }
                        ),
                        this._nativeAudioWorkletNode = V,
                        this._onprocessorerror = null,
                        this._parameters = new Y2(P),
                        D && t(N, this);
                        const {activeInputs: G} = o(this);
                        v(V, G)
                    }
                    get onprocessorerror() {
                        return this._onprocessorerror
                    }
                    set onprocessorerror(w) {
                        const A = typeof w == "function" ? S(this, w) : null;
                        this._nativeAudioWorkletNode.onprocessorerror = A;
                        const T = this._nativeAudioWorkletNode.onprocessorerror;
                        this._onprocessorerror = T !== null && T === A ? w : T
                    }
                    get parameters() {
                        return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters
                    }
                    get port() {
                        return this._nativeAudioWorkletNode.port
                    }
                }
                ;
                function aS(t, e, n, i, a) {
                    if (typeof t.copyFromChannel == "function")
                        e[n].byteLength === 0 && (e[n] = new Float32Array(128)),
                        t.copyFromChannel(e[n], i, a);
                    else {
                        const o = t.getChannelData(i);
                        if (e[n].byteLength === 0)
                            e[n] = o.slice(a, a + 128);
                        else {
                            const u = new Float32Array(o.buffer,a * Float32Array.BYTES_PER_ELEMENT,128);
                            e[n].set(u)
                        }
                    }
                }
                const j2 = (t, e, n, i, a) => {
                    typeof t.copyToChannel == "function" ? e[n].byteLength !== 0 && t.copyToChannel(e[n], i, a) : e[n].byteLength !== 0 && t.getChannelData(i).set(e[n], a)
                }
                  , rS = (t, e) => {
                    const n = [];
                    for (let i = 0; i < t; i += 1) {
                        const a = []
                          , o = typeof e == "number" ? e : e[i];
                        for (let u = 0; u < o; u += 1)
                            a.push(new Float32Array(128));
                        n.push(a)
                    }
                    return n
                }
                  , l5 = (t, e) => Mo(Mo(Lb, t), pi(e))
                  , c5 = async (t, e, n, i, a, o, u) => {
                    const f = e === null ? Math.ceil(t.context.length / 128) * 128 : e.length
                      , d = i.channelCount * i.numberOfInputs
                      , p = a.reduce( (A, T) => A + T, 0)
                      , g = p === 0 ? null : n.createBuffer(p, f, n.sampleRate);
                    if (o === void 0)
                        throw new Error("Missing the processor constructor.");
                    const v = xa(t)
                      , y = await l5(n, t)
                      , S = rS(i.numberOfInputs, i.channelCount)
                      , E = rS(i.numberOfOutputs, a)
                      , w = Array.from(t.parameters.keys()).reduce( (A, T) => ({
                        ...A,
                        [T]: new Float32Array(128)
                    }), {});
                    for (let A = 0; A < f; A += 128) {
                        if (i.numberOfInputs > 0 && e !== null)
                            for (let T = 0; T < i.numberOfInputs; T += 1)
                                for (let R = 0; R < i.channelCount; R += 1)
                                    aS(e, S[T], R, R, A);
                        o.parameterDescriptors !== void 0 && e !== null && o.parameterDescriptors.forEach( ({name: T}, R) => {
                            aS(e, w, T, d + R, A)
                        }
                        );
                        for (let T = 0; T < i.numberOfInputs; T += 1)
                            for (let R = 0; R < a[T]; R += 1)
                                E[T][R].byteLength === 0 && (E[T][R] = new Float32Array(128));
                        try {
                            const T = S.map( (N, D) => v.activeInputs[D].size === 0 ? [] : N)
                              , R = u(A / n.sampleRate, n.sampleRate, () => y.process(T, E, w));
                            if (g !== null)
                                for (let N = 0, D = 0; N < i.numberOfOutputs; N += 1) {
                                    for (let U = 0; U < a[N]; U += 1)
                                        j2(g, E[N], U, D + U, A);
                                    D += a[N]
                                }
                            if (!R)
                                break
                        } catch (T) {
                            t.dispatchEvent(new ErrorEvent("processorerror",{
                                colno: T.colno,
                                filename: T.filename,
                                lineno: T.lineno,
                                message: T.message
                            }));
                            break
                        }
                    }
                    return g
                }
                  , u5 = (t, e, n, i, a, o, u, f, d, p, g, v, y, S, E, w) => (A, T, R) => {
                    const N = new WeakMap;
                    let D = null;
                    const U = async (z, I) => {
                        let V = g(z)
                          , B = null;
                        const P = js(V, I)
                          , G = Array.isArray(T.outputChannelCount) ? T.outputChannelCount : Array.from(T.outputChannelCount);
                        if (v === null) {
                            const K = G.reduce( (q, F) => q + F, 0)
                              , ee = a(I, {
                                channelCount: Math.max(1, K),
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                numberOfOutputs: Math.max(1, K)
                            })
                              , te = [];
                            for (let q = 0; q < z.numberOfOutputs; q += 1)
                                te.push(i(I, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: G[q]
                                }));
                            const oe = u(I, {
                                channelCount: T.channelCount,
                                channelCountMode: T.channelCountMode,
                                channelInterpretation: T.channelInterpretation,
                                gain: 1
                            });
                            oe.connect = e.bind(null, te),
                            oe.disconnect = d.bind(null, te),
                            B = [ee, te, oe]
                        } else
                            P || (V = new v(I,A));
                        if (N.set(I, B === null ? V : B[2]),
                        B !== null) {
                            if (D === null) {
                                if (R === void 0)
                                    throw new Error("Missing the processor constructor.");
                                if (y === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const F = z.channelCount * z.numberOfInputs
                                  , X = R.parameterDescriptors === void 0 ? 0 : R.parameterDescriptors.length
                                  , $ = F + X;
                                D = c5(z, $ === 0 ? null : await (async () => {
                                    const ce = new y($,Math.ceil(z.context.length / 128) * 128,I.sampleRate)
                                      , k = []
                                      , pe = [];
                                    for (let Me = 0; Me < T.numberOfInputs; Me += 1)
                                        k.push(u(ce, {
                                            channelCount: T.channelCount,
                                            channelCountMode: T.channelCountMode,
                                            channelInterpretation: T.channelInterpretation,
                                            gain: 1
                                        })),
                                        pe.push(a(ce, {
                                            channelCount: T.channelCount,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            numberOfOutputs: T.channelCount
                                        }));
                                    const Ae = await Promise.all(Array.from(z.parameters.values()).map(async Me => {
                                        const we = o(ce, {
                                            channelCount: 1,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            offset: Me.value
                                        });
                                        return await S(ce, Me, we.offset),
                                        we
                                    }
                                    ))
                                      , ie = i(ce, {
                                        channelCount: 1,
                                        channelCountMode: "explicit",
                                        channelInterpretation: "speakers",
                                        numberOfInputs: Math.max(1, F + X)
                                    });
                                    for (let Me = 0; Me < T.numberOfInputs; Me += 1) {
                                        k[Me].connect(pe[Me]);
                                        for (let we = 0; we < T.channelCount; we += 1)
                                            pe[Me].connect(ie, we, Me * T.channelCount + we)
                                    }
                                    for (const [Me,we] of Ae.entries())
                                        we.connect(ie, 0, F + Me),
                                        we.start(0);
                                    return ie.connect(ce.destination),
                                    await Promise.all(k.map(Me => E(z, ce, Me))),
                                    w(ce)
                                }
                                )(), I, T, G, R, p)
                            }
                            const K = await D
                              , ee = n(I, {
                                buffer: null,
                                channelCount: 2,
                                channelCountMode: "max",
                                channelInterpretation: "speakers",
                                loop: !1,
                                loopEnd: 0,
                                loopStart: 0,
                                playbackRate: 1
                            })
                              , [te,oe,q] = B;
                            K !== null && (ee.buffer = K,
                            ee.start(0)),
                            ee.connect(te);
                            for (let F = 0, X = 0; F < z.numberOfOutputs; F += 1) {
                                const $ = oe[F];
                                for (let ne = 0; ne < G[F]; ne += 1)
                                    te.connect($, X + ne, ne);
                                X += G[F]
                            }
                            return q
                        }
                        if (P)
                            for (const [K,ee] of z.parameters.entries())
                                await t(I, ee, V.parameters.get(K));
                        else
                            for (const [K,ee] of z.parameters.entries())
                                await S(I, ee, V.parameters.get(K));
                        return await E(z, I, V),
                        V
                    }
                    ;
                    return {
                        render(z, I) {
                            f(I, z);
                            const V = N.get(I);
                            return V !== void 0 ? Promise.resolve(V) : U(z, I)
                        }
                    }
                }
                  , h5 = (t, e, n, i, a, o, u, f, d, p, g, v, y, S, E, w, A, T, R, N) => class extends E {
                    constructor(U, z) {
                        super(U, z),
                        this._nativeContext = U,
                        this._audioWorklet = t === void 0 ? void 0 : {
                            addModule: (I, V) => t(this, I, V)
                        }
                    }
                    get audioWorklet() {
                        return this._audioWorklet
                    }
                    createAnalyser() {
                        return new e(this)
                    }
                    createBiquadFilter() {
                        return new a(this)
                    }
                    createBuffer(U, z, I) {
                        return new n({
                            length: z,
                            numberOfChannels: U,
                            sampleRate: I
                        })
                    }
                    createBufferSource() {
                        return new i(this)
                    }
                    createChannelMerger(U=6) {
                        return new o(this,{
                            numberOfInputs: U
                        })
                    }
                    createChannelSplitter(U=6) {
                        return new u(this,{
                            numberOfOutputs: U
                        })
                    }
                    createConstantSource() {
                        return new f(this)
                    }
                    createConvolver() {
                        return new d(this)
                    }
                    createDelay(U=1) {
                        return new g(this,{
                            maxDelayTime: U
                        })
                    }
                    createDynamicsCompressor() {
                        return new v(this)
                    }
                    createGain() {
                        return new y(this)
                    }
                    createIIRFilter(U, z) {
                        return new S(this,{
                            feedback: z,
                            feedforward: U
                        })
                    }
                    createOscillator() {
                        return new w(this)
                    }
                    createPanner() {
                        return new A(this)
                    }
                    createPeriodicWave(U, z, I={
                        disableNormalization: !1
                    }) {
                        return new T(this,{
                            ...I,
                            imag: z,
                            real: U
                        })
                    }
                    createStereoPanner() {
                        return new R(this)
                    }
                    createWaveShaper() {
                        return new N(this)
                    }
                    decodeAudioData(U, z, I) {
                        return p(this._nativeContext, U).then(V => (typeof z == "function" && z(V),
                        V), V => {
                            throw typeof I == "function" && I(V),
                            V
                        }
                        )
                    }
                }
                  , f5 = {
                    Q: 1,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    detune: 0,
                    frequency: 350,
                    gain: 0,
                    type: "lowpass"
                }
                  , d5 = (t, e, n, i, a, o, u, f) => class extends t {
                    constructor(p, g) {
                        const v = o(p)
                          , y = a(v, {
                            ...f5,
                            ...g
                        })
                          , S = u(v)
                          , E = S ? n() : null;
                        super(p, !1, y, E),
                        this._Q = e(this, S, y.Q, Sa, Fa),
                        this._detune = e(this, S, y.detune, 1200 * Math.log2(Sa), -1200 * Math.log2(Sa)),
                        this._frequency = e(this, S, y.frequency, p.sampleRate / 2, 0),
                        this._gain = e(this, S, y.gain, 40 * Math.log10(Sa), Fa),
                        this._nativeBiquadFilterNode = y,
                        f(this, 1)
                    }
                    get detune() {
                        return this._detune
                    }
                    get frequency() {
                        return this._frequency
                    }
                    get gain() {
                        return this._gain
                    }
                    get Q() {
                        return this._Q
                    }
                    get type() {
                        return this._nativeBiquadFilterNode.type
                    }
                    set type(p) {
                        this._nativeBiquadFilterNode.type = p
                    }
                    getFrequencyResponse(p, g, v) {
                        try {
                            this._nativeBiquadFilterNode.getFrequencyResponse(p, g, v)
                        } catch (y) {
                            throw y.code === 11 ? i() : y
                        }
                        if (p.length !== g.length || g.length !== v.length)
                            throw i()
                    }
                }
                  , p5 = (t, e, n, i, a) => () => {
                    const o = new WeakMap
                      , u = async (f, d) => {
                        let p = n(f);
                        const g = js(p, d);
                        return g || (p = e(d, {
                            Q: p.Q.value,
                            channelCount: p.channelCount,
                            channelCountMode: p.channelCountMode,
                            channelInterpretation: p.channelInterpretation,
                            detune: p.detune.value,
                            frequency: p.frequency.value,
                            gain: p.gain.value,
                            type: p.type
                        })),
                        o.set(d, p),
                        g ? (await t(d, f.Q, p.Q),
                        await t(d, f.detune, p.detune),
                        await t(d, f.frequency, p.frequency),
                        await t(d, f.gain, p.gain)) : (await i(d, f.Q, p.Q),
                        await i(d, f.detune, p.detune),
                        await i(d, f.frequency, p.frequency),
                        await i(d, f.gain, p.gain)),
                        await a(f, d, p),
                        p
                    }
                    ;
                    return {
                        render(f, d) {
                            const p = o.get(d);
                            return p !== void 0 ? Promise.resolve(p) : u(f, d)
                        }
                    }
                }
                  , m5 = (t, e) => (n, i) => {
                    const a = e.get(n);
                    if (a !== void 0)
                        return a;
                    const o = t.get(n);
                    if (o !== void 0)
                        return o;
                    try {
                        const u = i();
                        return u instanceof Promise ? (t.set(n, u),
                        u.catch( () => !1).then(f => (t.delete(n),
                        e.set(n, f),
                        f))) : (e.set(n, u),
                        u)
                    } catch {
                        return e.set(n, !1),
                        !1
                    }
                }
                  , g5 = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: 6
                }
                  , v5 = (t, e, n, i, a) => class extends t {
                    constructor(u, f) {
                        const d = i(u)
                          , p = n(d, {
                            ...g5,
                            ...f
                        })
                          , g = a(d) ? e() : null;
                        super(u, !1, p, g)
                    }
                }
                  , _5 = (t, e, n) => () => {
                    const i = new WeakMap
                      , a = async (o, u) => {
                        let f = e(o);
                        return js(f, u) || (f = t(u, {
                            channelCount: f.channelCount,
                            channelCountMode: f.channelCountMode,
                            channelInterpretation: f.channelInterpretation,
                            numberOfInputs: f.numberOfInputs
                        })),
                        i.set(u, f),
                        await n(o, u, f),
                        f
                    }
                    ;
                    return {
                        render(o, u) {
                            const f = i.get(u);
                            return f !== void 0 ? Promise.resolve(f) : a(o, u)
                        }
                    }
                }
                  , y5 = {
                    channelCount: 6,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    numberOfOutputs: 6
                }
                  , S5 = (t, e, n, i, a, o) => class extends t {
                    constructor(f, d) {
                        const p = i(f)
                          , g = n(p, o({
                            ...y5,
                            ...d
                        }))
                          , v = a(p) ? e() : null;
                        super(f, !1, g, v)
                    }
                }
                  , x5 = (t, e, n) => () => {
                    const i = new WeakMap
                      , a = async (o, u) => {
                        let f = e(o);
                        return js(f, u) || (f = t(u, {
                            channelCount: f.channelCount,
                            channelCountMode: f.channelCountMode,
                            channelInterpretation: f.channelInterpretation,
                            numberOfOutputs: f.numberOfOutputs
                        })),
                        i.set(u, f),
                        await n(o, u, f),
                        f
                    }
                    ;
                    return {
                        render(o, u) {
                            const f = i.get(u);
                            return f !== void 0 ? Promise.resolve(f) : a(o, u)
                        }
                    }
                }
                  , M5 = t => (e, n, i) => t(n, e, i)
                  , b5 = t => (e, n, i=0, a=0) => {
                    const o = e[i];
                    if (o === void 0)
                        throw t();
                    return sS(n) ? o.connect(n, 0, a) : o.connect(n, 0)
                }
                  , T5 = t => (e, n) => {
                    const i = t(e, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    });
                    return i.buffer = e.createBuffer(1, 2, 44100),
                    i.loop = !0,
                    i.connect(n),
                    i.start(),
                    () => {
                        i.stop(),
                        i.disconnect(n)
                    }
                }
                  , A5 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    offset: 1
                }
                  , E5 = (t, e, n, i, a, o, u) => class extends t {
                    constructor(d, p) {
                        const g = a(d)
                          , v = i(g, {
                            ...A5,
                            ...p
                        })
                          , y = o(g)
                          , S = y ? n() : null;
                        super(d, !1, v, S),
                        this._constantSourceNodeRenderer = S,
                        this._nativeConstantSourceNode = v,
                        this._offset = e(this, y, v.offset, Sa, Fa),
                        this._onended = null
                    }
                    get offset() {
                        return this._offset
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(d) {
                        const p = typeof d == "function" ? u(this, d) : null;
                        this._nativeConstantSourceNode.onended = p;
                        const g = this._nativeConstantSourceNode.onended;
                        this._onended = g !== null && g === p ? d : g
                    }
                    start(d=0) {
                        if (this._nativeConstantSourceNode.start(d),
                        this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = d),
                        this.context.state !== "closed") {
                            mp(this);
                            const p = () => {
                                this._nativeConstantSourceNode.removeEventListener("ended", p),
                                hc(this) && tv(this)
                            }
                            ;
                            this._nativeConstantSourceNode.addEventListener("ended", p)
                        }
                    }
                    stop(d=0) {
                        this._nativeConstantSourceNode.stop(d),
                        this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = d)
                    }
                }
                  , C5 = (t, e, n, i, a) => () => {
                    const o = new WeakMap;
                    let u = null
                      , f = null;
                    const d = async (p, g) => {
                        let v = n(p);
                        const y = js(v, g);
                        return y || (v = e(g, {
                            channelCount: v.channelCount,
                            channelCountMode: v.channelCountMode,
                            channelInterpretation: v.channelInterpretation,
                            offset: v.offset.value
                        }),
                        u !== null && v.start(u),
                        f !== null && v.stop(f)),
                        o.set(g, v),
                        y ? await t(g, p.offset, v.offset) : await i(g, p.offset, v.offset),
                        await a(p, g, v),
                        v
                    }
                    ;
                    return {
                        set start(p) {
                            u = p
                        },
                        set stop(p) {
                            f = p
                        },
                        render(p, g) {
                            const v = o.get(g);
                            return v !== void 0 ? Promise.resolve(v) : d(p, g)
                        }
                    }
                }
                  , w5 = t => e => (t[0] = e,
                t[0])
                  , R5 = {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    disableNormalization: !1
                }
                  , N5 = (t, e, n, i, a, o) => class extends t {
                    constructor(f, d) {
                        const p = i(f)
                          , g = {
                            ...R5,
                            ...d
                        }
                          , v = n(p, g)
                          , y = a(p) ? e() : null;
                        super(f, !1, v, y),
                        this._isBufferNullified = !1,
                        this._nativeConvolverNode = v,
                        g.buffer !== null && o(this, g.buffer.duration)
                    }
                    get buffer() {
                        return this._isBufferNullified ? null : this._nativeConvolverNode.buffer
                    }
                    set buffer(f) {
                        if (this._nativeConvolverNode.buffer = f,
                        f === null && this._nativeConvolverNode.buffer !== null) {
                            const d = this._nativeConvolverNode.context;
                            this._nativeConvolverNode.buffer = d.createBuffer(1, 1, d.sampleRate),
                            this._isBufferNullified = !0,
                            o(this, 0)
                        } else
                            this._isBufferNullified = !1,
                            o(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration)
                    }
                    get normalize() {
                        return this._nativeConvolverNode.normalize
                    }
                    set normalize(f) {
                        this._nativeConvolverNode.normalize = f
                    }
                }
                  , D5 = (t, e, n) => () => {
                    const i = new WeakMap
                      , a = async (o, u) => {
                        let f = e(o);
                        return js(f, u) || (f = t(u, {
                            buffer: f.buffer,
                            channelCount: f.channelCount,
                            channelCountMode: f.channelCountMode,
                            channelInterpretation: f.channelInterpretation,
                            disableNormalization: !f.normalize
                        })),
                        i.set(u, f),
                        gp(f) ? await n(o, u, f.inputs[0]) : await n(o, u, f),
                        f
                    }
                    ;
                    return {
                        render(o, u) {
                            const f = i.get(u);
                            return f !== void 0 ? Promise.resolve(f) : a(o, u)
                        }
                    }
                }
                  , O5 = (t, e) => (n, i, a) => {
                    if (e === null)
                        throw new Error("Missing the native OfflineAudioContext constructor.");
                    try {
                        return new e(n,i,a)
                    } catch (o) {
                        throw o.name === "SyntaxError" ? t() : o
                    }
                }
                  , U5 = () => new DOMException("","DataCloneError")
                  , Z2 = t => {
                    const {port1: e, port2: n} = new MessageChannel;
                    return new Promise(i => {
                        const a = () => {
                            n.onmessage = null,
                            e.close(),
                            n.close(),
                            i()
                        }
                        ;
                        n.onmessage = () => a();
                        try {
                            e.postMessage(t, [t])
                        } catch {} finally {
                            a()
                        }
                    }
                    )
                }
                  , L5 = (t, e, n, i, a, o, u, f, d, p, g) => (v, y) => {
                    const S = u(v) ? v : o(v);
                    if (a.has(y)) {
                        const E = n();
                        return Promise.reject(E)
                    }
                    try {
                        a.add(y)
                    } catch {}
                    return e(d, () => d(S)) ? S.decodeAudioData(y).then(E => (Z2(y).catch( () => {}
                    ),
                    e(f, () => f(E)) || g(E),
                    t.add(E),
                    E)) : new Promise( (E, w) => {
                        const A = async () => {
                            try {
                                await Z2(y)
                            } catch {}
                        }
                          , T = R => {
                            w(R),
                            A()
                        }
                        ;
                        try {
                            S.decodeAudioData(y, R => {
                                typeof R.copyFromChannel != "function" && (p(R),
                                zb(R)),
                                t.add(R),
                                A().then( () => E(R))
                            }
                            , R => {
                                T(R === null ? i() : R)
                            }
                            )
                        } catch (R) {
                            T(R)
                        }
                    }
                    )
                }
                  , I5 = (t, e, n, i, a, o, u, f) => (d, p) => {
                    const g = e.get(d);
                    if (g === void 0)
                        throw new Error("Missing the expected cycle count.");
                    const v = f(o(d.context));
                    if (g === p) {
                        if (e.delete(d),
                        !v && u(d)) {
                            const y = i(d)
                              , {outputs: S} = n(d);
                            for (const E of S)
                                if (iv(E))
                                    t(y, i(E[0]), E[1], E[2]);
                                else {
                                    const w = a(E[0]);
                                    y.connect(w, E[1])
                                }
                        }
                    } else
                        e.set(d, g - p)
                }
                  , z5 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    delayTime: 0,
                    maxDelayTime: 1
                }
                  , B5 = (t, e, n, i, a, o, u) => class extends t {
                    constructor(d, p) {
                        const g = a(d)
                          , v = {
                            ...z5,
                            ...p
                        }
                          , y = i(g, v)
                          , S = o(g)
                          , E = S ? n(v.maxDelayTime) : null;
                        super(d, !1, y, E),
                        this._delayTime = e(this, S, y.delayTime),
                        u(this, v.maxDelayTime)
                    }
                    get delayTime() {
                        return this._delayTime
                    }
                }
                  , P5 = (t, e, n, i, a) => o => {
                    const u = new WeakMap
                      , f = async (d, p) => {
                        let g = n(d);
                        const v = js(g, p);
                        return v || (g = e(p, {
                            channelCount: g.channelCount,
                            channelCountMode: g.channelCountMode,
                            channelInterpretation: g.channelInterpretation,
                            delayTime: g.delayTime.value,
                            maxDelayTime: o
                        })),
                        u.set(p, g),
                        v ? await t(p, d.delayTime, g.delayTime) : await i(p, d.delayTime, g.delayTime),
                        await a(d, p, g),
                        g
                    }
                    ;
                    return {
                        render(d, p) {
                            const g = u.get(p);
                            return g !== void 0 ? Promise.resolve(g) : f(d, p)
                        }
                    }
                }
                  , V5 = t => (e, n, i, a) => t(e[a], o => o[0] === n && o[1] === i)
                  , F5 = t => (e, n) => {
                    t(e).delete(n)
                }
                  , H5 = t => "delayTime"in t
                  , G5 = (t, e, n) => function i(a, o) {
                    const u = eS(o) ? o : n(t, o);
                    if (H5(u))
                        return [];
                    if (a[0] === u)
                        return [a];
                    if (a.includes(u))
                        return [];
                    const {outputs: f} = e(u);
                    return Array.from(f).map(d => i([...a, u], d[0])).reduce( (d, p) => d.concat(p), [])
                }
                  , oS = (t, e, n) => {
                    const i = e[n];
                    if (i === void 0)
                        throw t();
                    return i
                }
                  , k5 = t => (e, n=void 0, i=void 0, a=0) => n === void 0 ? e.forEach(o => o.disconnect()) : typeof n == "number" ? oS(t, e, n).disconnect() : sS(n) ? i === void 0 ? e.forEach(o => o.disconnect(n)) : a === void 0 ? oS(t, e, i).disconnect(n, 0) : oS(t, e, i).disconnect(n, 0, a) : i === void 0 ? e.forEach(o => o.disconnect(n)) : oS(t, e, i).disconnect(n, 0)
                  , q5 = {
                    attack: .003,
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    knee: 30,
                    ratio: 12,
                    release: .25,
                    threshold: -24
                }
                  , X5 = (t, e, n, i, a, o, u, f) => class extends t {
                    constructor(p, g) {
                        const v = o(p)
                          , y = i(v, {
                            ...q5,
                            ...g
                        })
                          , S = u(v)
                          , E = S ? n() : null;
                        super(p, !1, y, E),
                        this._attack = e(this, S, y.attack),
                        this._knee = e(this, S, y.knee),
                        this._nativeDynamicsCompressorNode = y,
                        this._ratio = e(this, S, y.ratio),
                        this._release = e(this, S, y.release),
                        this._threshold = e(this, S, y.threshold),
                        f(this, .006)
                    }
                    get attack() {
                        return this._attack
                    }
                    get channelCount() {
                        return this._nativeDynamicsCompressorNode.channelCount
                    }
                    set channelCount(p) {
                        const g = this._nativeDynamicsCompressorNode.channelCount;
                        if (this._nativeDynamicsCompressorNode.channelCount = p,
                        p > 2)
                            throw this._nativeDynamicsCompressorNode.channelCount = g,
                            a()
                    }
                    get channelCountMode() {
                        return this._nativeDynamicsCompressorNode.channelCountMode
                    }
                    set channelCountMode(p) {
                        const g = this._nativeDynamicsCompressorNode.channelCountMode;
                        if (this._nativeDynamicsCompressorNode.channelCountMode = p,
                        p === "max")
                            throw this._nativeDynamicsCompressorNode.channelCountMode = g,
                            a()
                    }
                    get knee() {
                        return this._knee
                    }
                    get ratio() {
                        return this._ratio
                    }
                    get reduction() {
                        return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction
                    }
                    get release() {
                        return this._release
                    }
                    get threshold() {
                        return this._threshold
                    }
                }
                  , W5 = (t, e, n, i, a) => () => {
                    const o = new WeakMap
                      , u = async (f, d) => {
                        let p = n(f);
                        const g = js(p, d);
                        return g || (p = e(d, {
                            attack: p.attack.value,
                            channelCount: p.channelCount,
                            channelCountMode: p.channelCountMode,
                            channelInterpretation: p.channelInterpretation,
                            knee: p.knee.value,
                            ratio: p.ratio.value,
                            release: p.release.value,
                            threshold: p.threshold.value
                        })),
                        o.set(d, p),
                        g ? (await t(d, f.attack, p.attack),
                        await t(d, f.knee, p.knee),
                        await t(d, f.ratio, p.ratio),
                        await t(d, f.release, p.release),
                        await t(d, f.threshold, p.threshold)) : (await i(d, f.attack, p.attack),
                        await i(d, f.knee, p.knee),
                        await i(d, f.ratio, p.ratio),
                        await i(d, f.release, p.release),
                        await i(d, f.threshold, p.threshold)),
                        await a(f, d, p),
                        p
                    }
                    ;
                    return {
                        render(f, d) {
                            const p = o.get(d);
                            return p !== void 0 ? Promise.resolve(p) : u(f, d)
                        }
                    }
                }
                  , Y5 = () => new DOMException("","EncodingError")
                  , j5 = t => e => new Promise( (n, i) => {
                    if (t === null) {
                        i(new SyntaxError);
                        return
                    }
                    const a = t.document.head;
                    if (a === null)
                        i(new SyntaxError);
                    else {
                        const o = t.document.createElement("script")
                          , u = new Blob([e],{
                            type: "application/javascript"
                        })
                          , f = URL.createObjectURL(u)
                          , d = t.onerror
                          , p = () => {
                            t.onerror = d,
                            URL.revokeObjectURL(f)
                        }
                        ;
                        t.onerror = (g, v, y, S, E) => {
                            if (v === f || v === t.location.href && y === 1 && S === 1)
                                return p(),
                                i(E),
                                !1;
                            if (d !== null)
                                return d(g, v, y, S, E)
                        }
                        ,
                        o.onerror = () => {
                            p(),
                            i(new SyntaxError)
                        }
                        ,
                        o.onload = () => {
                            p(),
                            n()
                        }
                        ,
                        o.src = f,
                        o.type = "module",
                        a.appendChild(o)
                    }
                }
                )
                  , Z5 = t => class {
                    constructor(n) {
                        this._nativeEventTarget = n,
                        this._listeners = new WeakMap
                    }
                    addEventListener(n, i, a) {
                        if (i !== null) {
                            let o = this._listeners.get(i);
                            o === void 0 && (o = t(this, i),
                            typeof i == "function" && this._listeners.set(i, o)),
                            this._nativeEventTarget.addEventListener(n, o, a)
                        }
                    }
                    dispatchEvent(n) {
                        return this._nativeEventTarget.dispatchEvent(n)
                    }
                    removeEventListener(n, i, a) {
                        const o = i === null ? void 0 : this._listeners.get(i);
                        this._nativeEventTarget.removeEventListener(n, o === void 0 ? null : o, a)
                    }
                }
                  , Q5 = t => (e, n, i) => {
                    Object.defineProperties(t, {
                        currentFrame: {
                            configurable: !0,
                            get() {
                                return Math.round(e * n)
                            }
                        },
                        currentTime: {
                            configurable: !0,
                            get() {
                                return e
                            }
                        }
                    });
                    try {
                        return i()
                    } finally {
                        t !== null && (delete t.currentFrame,
                        delete t.currentTime)
                    }
                }
                  , K5 = t => async e => {
                    try {
                        const n = await fetch(e);
                        if (n.ok)
                            return [await n.text(), n.url]
                    } catch {}
                    throw t()
                }
                  , J5 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    gain: 1
                }
                  , $5 = (t, e, n, i, a, o) => class extends t {
                    constructor(f, d) {
                        const p = a(f)
                          , g = i(p, {
                            ...J5,
                            ...d
                        })
                          , v = o(p)
                          , y = v ? n() : null;
                        super(f, !1, g, y),
                        this._gain = e(this, v, g.gain, Sa, Fa)
                    }
                    get gain() {
                        return this._gain
                    }
                }
                  , eP = (t, e, n, i, a) => () => {
                    const o = new WeakMap
                      , u = async (f, d) => {
                        let p = n(f);
                        const g = js(p, d);
                        return g || (p = e(d, {
                            channelCount: p.channelCount,
                            channelCountMode: p.channelCountMode,
                            channelInterpretation: p.channelInterpretation,
                            gain: p.gain.value
                        })),
                        o.set(d, p),
                        g ? await t(d, f.gain, p.gain) : await i(d, f.gain, p.gain),
                        await a(f, d, p),
                        p
                    }
                    ;
                    return {
                        render(f, d) {
                            const p = o.get(d);
                            return p !== void 0 ? Promise.resolve(p) : u(f, d)
                        }
                    }
                }
                  , tP = (t, e) => n => e(t, n)
                  , nP = t => e => {
                    const n = t(e);
                    if (n.renderer === null)
                        throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
                    return n.renderer
                }
                  , iP = t => e => {
                    var n;
                    return (n = t.get(e)) !== null && n !== void 0 ? n : 0
                }
                  , sP = t => e => {
                    const n = t(e);
                    if (n.renderer === null)
                        throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
                    return n.renderer
                }
                  , aP = t => e => t.get(e)
                  , $i = () => new DOMException("","InvalidStateError")
                  , rP = t => e => {
                    const n = t.get(e);
                    if (n === void 0)
                        throw $i();
                    return n
                }
                  , oP = (t, e) => n => {
                    let i = t.get(n);
                    if (i !== void 0)
                        return i;
                    if (e === null)
                        throw new Error("Missing the native OfflineAudioContext constructor.");
                    return i = new e(1,1,44100),
                    t.set(n, i),
                    i
                }
                  , lP = t => e => {
                    const n = t.get(e);
                    if (n === void 0)
                        throw new Error("The context has no set of AudioWorkletNodes.");
                    return n
                }
                  , lS = () => new DOMException("","InvalidAccessError")
                  , cP = t => {
                    t.getFrequencyResponse = (e => (n, i, a) => {
                        if (n.length !== i.length || i.length !== a.length)
                            throw lS();
                        return e.call(t, n, i, a)
                    }
                    )(t.getFrequencyResponse)
                }
                  , uP = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers"
                }
                  , hP = (t, e, n, i, a, o) => class extends t {
                    constructor(f, d) {
                        const p = i(f)
                          , g = a(p)
                          , v = {
                            ...uP,
                            ...d
                        }
                          , y = e(p, g ? null : f.baseLatency, v)
                          , S = g ? n(v.feedback, v.feedforward) : null;
                        super(f, !1, y, S),
                        cP(y),
                        this._nativeIIRFilterNode = y,
                        o(this, 1)
                    }
                    getFrequencyResponse(f, d, p) {
                        return this._nativeIIRFilterNode.getFrequencyResponse(f, d, p)
                    }
                }
                  , Q2 = (t, e, n, i, a, o, u, f, d, p, g) => {
                    const v = p.length;
                    let y = f;
                    for (let S = 0; S < v; S += 1) {
                        let E = n[0] * p[S];
                        for (let w = 1; w < a; w += 1) {
                            const A = y - w & d - 1;
                            E += n[w] * o[A],
                            E -= t[w] * u[A]
                        }
                        for (let w = a; w < i; w += 1)
                            E += n[w] * o[y - w & d - 1];
                        for (let w = a; w < e; w += 1)
                            E -= t[w] * u[y - w & d - 1];
                        o[y] = p[S],
                        u[y] = E,
                        y = y + 1 & d - 1,
                        g[S] = E
                    }
                    return y
                }
                  , fP = (t, e, n, i) => {
                    const a = n instanceof Float64Array ? n : new Float64Array(n)
                      , o = i instanceof Float64Array ? i : new Float64Array(i)
                      , u = a.length
                      , f = o.length
                      , d = Math.min(u, f);
                    if (a[0] !== 1) {
                        for (let E = 0; E < u; E += 1)
                            o[E] /= a[0];
                        for (let E = 1; E < f; E += 1)
                            a[E] /= a[0]
                    }
                    const p = 32
                      , g = new Float32Array(p)
                      , v = new Float32Array(p)
                      , y = e.createBuffer(t.numberOfChannels, t.length, t.sampleRate)
                      , S = t.numberOfChannels;
                    for (let E = 0; E < S; E += 1) {
                        const w = t.getChannelData(E)
                          , A = y.getChannelData(E);
                        g.fill(0),
                        v.fill(0),
                        Q2(a, u, o, f, d, g, v, 0, p, w, A)
                    }
                    return y
                }
                  , dP = (t, e, n, i, a) => (o, u) => {
                    const f = new WeakMap;
                    let d = null;
                    const p = async (g, v) => {
                        let y = null
                          , S = e(g);
                        const E = js(S, v);
                        if (v.createIIRFilter === void 0 ? y = t(v, {
                            buffer: null,
                            channelCount: 2,
                            channelCountMode: "max",
                            channelInterpretation: "speakers",
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            playbackRate: 1
                        }) : E || (S = v.createIIRFilter(u, o)),
                        f.set(v, y === null ? S : y),
                        y !== null) {
                            if (d === null) {
                                if (n === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const A = new n(g.context.destination.channelCount,g.context.length,v.sampleRate);
                                d = (async () => (await i(g, A, A.destination),
                                fP(await a(A), v, o, u)))()
                            }
                            const w = await d;
                            return y.buffer = w,
                            y.start(0),
                            y
                        }
                        return await i(g, v, S),
                        S
                    }
                    ;
                    return {
                        render(g, v) {
                            const y = f.get(v);
                            return y !== void 0 ? Promise.resolve(y) : p(g, v)
                        }
                    }
                }
                  , pP = (t, e, n, i, a, o) => u => (f, d) => {
                    const p = t.get(f);
                    if (p === void 0) {
                        if (!u && o(f)) {
                            const g = i(f)
                              , {outputs: v} = n(f);
                            for (const y of v)
                                if (iv(y))
                                    e(g, i(y[0]), y[1], y[2]);
                                else {
                                    const S = a(y[0]);
                                    g.disconnect(S, y[1])
                                }
                        }
                        t.set(f, d)
                    } else
                        t.set(f, p + d)
                }
                  , mP = (t, e) => n => e(t.get(n)) || e(n)
                  , gP = (t, e) => n => t.has(n) || e(n)
                  , vP = (t, e) => n => t.has(n) || e(n)
                  , _P = (t, e) => n => e(t.get(n)) || e(n)
                  , yP = t => e => t !== null && e instanceof t
                  , SP = t => e => t !== null && typeof t.AudioNode == "function" && e instanceof t.AudioNode
                  , xP = t => e => t !== null && typeof t.AudioParam == "function" && e instanceof t.AudioParam
                  , MP = (t, e) => n => t(n) || e(n)
                  , bP = t => e => t !== null && e instanceof t
                  , TP = t => t !== null && t.isSecureContext
                  , AP = (t, e, n, i) => class extends t {
                    constructor(o, u) {
                        const f = n(o)
                          , d = e(f, u);
                        if (i(f))
                            throw TypeError();
                        super(o, !0, d, null),
                        this._nativeMediaElementAudioSourceNode = d
                    }
                    get mediaElement() {
                        return this._nativeMediaElementAudioSourceNode.mediaElement
                    }
                }
                  , EP = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers"
                }
                  , CP = (t, e, n, i) => class extends t {
                    constructor(o, u) {
                        const f = n(o);
                        if (i(f))
                            throw new TypeError;
                        const d = e(f, {
                            ...EP,
                            ...u
                        });
                        super(o, !1, d, null),
                        this._nativeMediaStreamAudioDestinationNode = d
                    }
                    get stream() {
                        return this._nativeMediaStreamAudioDestinationNode.stream
                    }
                }
                  , wP = (t, e, n, i) => class extends t {
                    constructor(o, u) {
                        const f = n(o)
                          , d = e(f, u);
                        if (i(f))
                            throw new TypeError;
                        super(o, !0, d, null),
                        this._nativeMediaStreamAudioSourceNode = d
                    }
                    get mediaStream() {
                        return this._nativeMediaStreamAudioSourceNode.mediaStream
                    }
                }
                  , RP = (t, e, n) => class extends t {
                    constructor(a, o) {
                        const u = e(n(a), o);
                        super(a, !0, u, null)
                    }
                }
                  , NP = (t, e, n, i, a) => class extends i {
                    constructor(u={}) {
                        if (a === null)
                            throw new Error("Missing the native AudioContext constructor.");
                        let f;
                        try {
                            f = new a(u)
                        } catch (g) {
                            throw g.code === 12 && g.message === "sampleRate is not in range" ? e() : g
                        }
                        if (f === null)
                            throw n();
                        if (!F2(u.latencyHint))
                            throw new TypeError(`The provided value '${u.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                        if (u.sampleRate !== void 0 && f.sampleRate !== u.sampleRate)
                            throw e();
                        super(f, 2);
                        const {latencyHint: d} = u
                          , {sampleRate: p} = f;
                        if (this._baseLatency = typeof f.baseLatency == "number" ? f.baseLatency : d === "balanced" ? 512 / p : d === "interactive" || d === void 0 ? 256 / p : d === "playback" ? 1024 / p : Math.max(2, Math.min(128, Math.round(d * p / 128))) * 128 / p,
                        this._nativeAudioContext = f,
                        a.name === "webkitAudioContext" ? (this._nativeGainNode = f.createGain(),
                        this._nativeOscillatorNode = f.createOscillator(),
                        this._nativeGainNode.gain.value = 1e-37,
                        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(f.destination),
                        this._nativeOscillatorNode.start()) : (this._nativeGainNode = null,
                        this._nativeOscillatorNode = null),
                        this._state = null,
                        f.state === "running") {
                            this._state = "suspended";
                            const g = () => {
                                this._state === "suspended" && (this._state = null),
                                f.removeEventListener("statechange", g)
                            }
                            ;
                            f.addEventListener("statechange", g)
                        }
                    }
                    get baseLatency() {
                        return this._baseLatency
                    }
                    get state() {
                        return this._state !== null ? this._state : this._nativeAudioContext.state
                    }
                    close() {
                        return this.state === "closed" ? this._nativeAudioContext.close().then( () => {
                            throw t()
                        }
                        ) : (this._state === "suspended" && (this._state = null),
                        this._nativeAudioContext.close().then( () => {
                            this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(),
                            this._nativeGainNode.disconnect(),
                            this._nativeOscillatorNode.disconnect()),
                            $y(this)
                        }
                        ))
                    }
                    resume() {
                        return this._state === "suspended" ? new Promise( (u, f) => {
                            const d = () => {
                                this._nativeAudioContext.removeEventListener("statechange", d),
                                this._nativeAudioContext.state === "running" ? u() : this.resume().then(u, f)
                            }
                            ;
                            this._nativeAudioContext.addEventListener("statechange", d)
                        }
                        ) : this._nativeAudioContext.resume().catch(u => {
                            throw u === void 0 || u.code === 15 ? t() : u
                        }
                        )
                    }
                    suspend() {
                        return this._nativeAudioContext.suspend().catch(u => {
                            throw u === void 0 ? t() : u
                        }
                        )
                    }
                }
                  , DP = (t, e, n, i, a, o) => class extends n {
                    constructor(f, d) {
                        super(f),
                        this._nativeContext = f,
                        Qy.set(this, f),
                        i(f) && a.set(f, new Set),
                        this._destination = new t(this,d),
                        this._listener = e(this, f),
                        this._onstatechange = null
                    }
                    get currentTime() {
                        return this._nativeContext.currentTime
                    }
                    get destination() {
                        return this._destination
                    }
                    get listener() {
                        return this._listener
                    }
                    get onstatechange() {
                        return this._onstatechange
                    }
                    set onstatechange(f) {
                        const d = typeof f == "function" ? o(this, f) : null;
                        this._nativeContext.onstatechange = d;
                        const p = this._nativeContext.onstatechange;
                        this._onstatechange = p !== null && p === d ? f : p
                    }
                    get sampleRate() {
                        return this._nativeContext.sampleRate
                    }
                    get state() {
                        return this._nativeContext.state
                    }
                }
                  , Qh = t => {
                    const e = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
                    try {
                        const n = t.decodeAudioData(e.buffer, () => {}
                        );
                        return n === void 0 ? !1 : (n.catch( () => {}
                        ),
                        !0)
                    } catch {}
                    return !1
                }
                  , OP = {
                    numberOfChannels: 1
                }
                  , UP = (t, e, n, i, a) => class extends i {
                    constructor(u) {
                        const {length: f, numberOfChannels: d, sampleRate: p} = {
                            ...OP,
                            ...u
                        }
                          , g = n(d, f, p);
                        t(Qh, () => Qh(g)) || g.addEventListener("statechange", ( () => {
                            let v = 0;
                            const y = S => {
                                this._state === "running" && (v > 0 ? (g.removeEventListener("statechange", y),
                                S.stopImmediatePropagation(),
                                this._waitForThePromiseToSettle(S)) : v += 1)
                            }
                            ;
                            return y
                        }
                        )()),
                        super(g, d),
                        this._length = f,
                        this._nativeOfflineAudioContext = g,
                        this._state = null
                    }
                    get length() {
                        return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
                    }
                    get state() {
                        return this._state === null ? this._nativeOfflineAudioContext.state : this._state
                    }
                    startRendering() {
                        return this._state === "running" ? Promise.reject(e()) : (this._state = "running",
                        a(this.destination, this._nativeOfflineAudioContext).finally( () => {
                            this._state = null,
                            $y(this)
                        }
                        ))
                    }
                    _waitForThePromiseToSettle(u) {
                        this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(u) : setTimeout( () => this._waitForThePromiseToSettle(u))
                    }
                }
                  , LP = (t, e) => (n, i, a) => {
                    const o = new Set;
                    return n.connect = (u => (f, d=0, p=0) => {
                        const g = o.size === 0;
                        if (e(f))
                            return u.call(n, f, d, p),
                            t(o, [f, d, p], v => v[0] === f && v[1] === d && v[2] === p, !0),
                            g && i(),
                            f;
                        u.call(n, f, d),
                        t(o, [f, d], v => v[0] === f && v[1] === d, !0),
                        g && i()
                    }
                    )(n.connect),
                    n.disconnect = (u => (f, d, p) => {
                        const g = o.size > 0;
                        if (f === void 0)
                            u.apply(n),
                            o.clear();
                        else if (typeof f == "number") {
                            u.call(n, f);
                            for (const y of o)
                                y[1] === f && o.delete(y)
                        } else {
                            e(f) ? u.call(n, f, d, p) : u.call(n, f, d);
                            for (const y of o)
                                y[0] === f && (d === void 0 || y[1] === d) && (p === void 0 || y[2] === p) && o.delete(y)
                        }
                        const v = o.size === 0;
                        g && v && a()
                    }
                    )(n.disconnect),
                    n
                }
                  , vi = (t, e, n) => {
                    const i = e[n];
                    i !== void 0 && i !== t[n] && (t[n] = i)
                }
                  , ls = (t, e) => {
                    vi(t, e, "channelCount"),
                    vi(t, e, "channelCountMode"),
                    vi(t, e, "channelInterpretation")
                }
                  , K2 = t => typeof t.getFloatTimeDomainData == "function"
                  , IP = t => {
                    t.getFloatTimeDomainData = e => {
                        const n = new Uint8Array(e.length);
                        t.getByteTimeDomainData(n);
                        const i = Math.max(n.length, t.fftSize);
                        for (let a = 0; a < i; a += 1)
                            e[a] = (n[a] - 128) * .0078125;
                        return e
                    }
                }
                  , zP = (t, e) => (n, i) => {
                    const a = n.createAnalyser();
                    if (ls(a, i),
                    !(i.maxDecibels > i.minDecibels))
                        throw e();
                    return vi(a, i, "fftSize"),
                    vi(a, i, "maxDecibels"),
                    vi(a, i, "minDecibels"),
                    vi(a, i, "smoothingTimeConstant"),
                    t(K2, () => K2(a)) || IP(a),
                    a
                }
                  , BP = t => t === null ? null : t.hasOwnProperty("AudioBuffer") ? t.AudioBuffer : null
                  , Di = (t, e, n) => {
                    const i = e[n];
                    i !== void 0 && i !== t[n].value && (t[n].value = i)
                }
                  , PP = t => {
                    t.start = (e => {
                        let n = !1;
                        return (i=0, a=0, o) => {
                            if (n)
                                throw $i();
                            e.call(t, i, a, o),
                            n = !0
                        }
                    }
                    )(t.start)
                }
                  , Hb = t => {
                    t.start = (e => (n=0, i=0, a) => {
                        if (typeof a == "number" && a < 0 || i < 0 || n < 0)
                            throw new RangeError("The parameters can't be negative.");
                        e.call(t, n, i, a)
                    }
                    )(t.start)
                }
                  , Gb = t => {
                    t.stop = (e => (n=0) => {
                        if (n < 0)
                            throw new RangeError("The parameter can't be negative.");
                        e.call(t, n)
                    }
                    )(t.stop)
                }
                  , VP = (t, e, n, i, a, o, u, f, d, p, g) => (v, y) => {
                    const S = v.createBufferSource();
                    return ls(S, y),
                    Di(S, y, "playbackRate"),
                    vi(S, y, "buffer"),
                    vi(S, y, "loop"),
                    vi(S, y, "loopEnd"),
                    vi(S, y, "loopStart"),
                    e(n, () => n(v)) || PP(S),
                    e(i, () => i(v)) || d(S),
                    e(a, () => a(v)) || p(S, v),
                    e(o, () => o(v)) || Hb(S),
                    e(u, () => u(v)) || g(S, v),
                    e(f, () => f(v)) || Gb(S),
                    t(v, S),
                    S
                }
                  , FP = t => t === null ? null : t.hasOwnProperty("AudioContext") ? t.AudioContext : t.hasOwnProperty("webkitAudioContext") ? t.webkitAudioContext : null
                  , HP = (t, e) => (n, i, a) => {
                    const o = n.destination;
                    if (o.channelCount !== i)
                        try {
                            o.channelCount = i
                        } catch {}
                    a && o.channelCountMode !== "explicit" && (o.channelCountMode = "explicit"),
                    o.maxChannelCount === 0 && Object.defineProperty(o, "maxChannelCount", {
                        value: i
                    });
                    const u = t(n, {
                        channelCount: i,
                        channelCountMode: o.channelCountMode,
                        channelInterpretation: o.channelInterpretation,
                        gain: 1
                    });
                    return e(u, "channelCount", f => () => f.call(u), f => d => {
                        f.call(u, d);
                        try {
                            o.channelCount = d
                        } catch (p) {
                            if (d > o.maxChannelCount)
                                throw p
                        }
                    }
                    ),
                    e(u, "channelCountMode", f => () => f.call(u), f => d => {
                        f.call(u, d),
                        o.channelCountMode = d
                    }
                    ),
                    e(u, "channelInterpretation", f => () => f.call(u), f => d => {
                        f.call(u, d),
                        o.channelInterpretation = d
                    }
                    ),
                    Object.defineProperty(u, "maxChannelCount", {
                        get: () => o.maxChannelCount
                    }),
                    u.connect(o),
                    u
                }
                  , GP = t => t === null ? null : t.hasOwnProperty("AudioWorkletNode") ? t.AudioWorkletNode : null
                  , kP = t => {
                    const {port1: e} = new MessageChannel;
                    try {
                        e.postMessage(t)
                    } finally {
                        e.close()
                    }
                }
                  , qP = (t, e, n, i, a) => (o, u, f, d, p, g) => {
                    if (f !== null)
                        try {
                            const v = new f(o,d,g)
                              , y = new Map;
                            let S = null;
                            if (Object.defineProperties(v, {
                                channelCount: {
                                    get: () => g.channelCount,
                                    set: () => {
                                        throw t()
                                    }
                                },
                                channelCountMode: {
                                    get: () => "explicit",
                                    set: () => {
                                        throw t()
                                    }
                                },
                                onprocessorerror: {
                                    get: () => S,
                                    set: E => {
                                        typeof S == "function" && v.removeEventListener("processorerror", S),
                                        S = typeof E == "function" ? E : null,
                                        typeof S == "function" && v.addEventListener("processorerror", S)
                                    }
                                }
                            }),
                            v.addEventListener = (E => (...w) => {
                                if (w[0] === "processorerror") {
                                    const A = typeof w[1] == "function" ? w[1] : typeof w[1] == "object" && w[1] !== null && typeof w[1].handleEvent == "function" ? w[1].handleEvent : null;
                                    if (A !== null) {
                                        const T = y.get(w[1]);
                                        T !== void 0 ? w[1] = T : (w[1] = R => {
                                            R.type === "error" ? (Object.defineProperties(R, {
                                                type: {
                                                    value: "processorerror"
                                                }
                                            }),
                                            A(R)) : A(new ErrorEvent(w[0],{
                                                ...R
                                            }))
                                        }
                                        ,
                                        y.set(A, w[1]))
                                    }
                                }
                                return E.call(v, "error", w[1], w[2]),
                                E.call(v, ...w)
                            }
                            )(v.addEventListener),
                            v.removeEventListener = (E => (...w) => {
                                if (w[0] === "processorerror") {
                                    const A = y.get(w[1]);
                                    A !== void 0 && (y.delete(w[1]),
                                    w[1] = A)
                                }
                                return E.call(v, "error", w[1], w[2]),
                                E.call(v, w[0], w[1], w[2])
                            }
                            )(v.removeEventListener),
                            g.numberOfOutputs !== 0) {
                                const E = n(o, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "discrete",
                                    gain: 0
                                });
                                return v.connect(E).connect(o.destination),
                                a(v, () => E.disconnect(), () => E.connect(o.destination))
                            }
                            return v
                        } catch (v) {
                            throw v.code === 11 ? i() : v
                        }
                    if (p === void 0)
                        throw i();
                    return kP(g),
                    e(o, u, p, g)
                }
                  , J2 = (t, e) => t === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(t * e)))))
                  , XP = t => new Promise( (e, n) => {
                    const {port1: i, port2: a} = new MessageChannel;
                    i.onmessage = ({data: o}) => {
                        i.close(),
                        a.close(),
                        e(o)
                    }
                    ,
                    i.onmessageerror = ({data: o}) => {
                        i.close(),
                        a.close(),
                        n(o)
                    }
                    ,
                    a.postMessage(t)
                }
                )
                  , WP = async (t, e) => new t(await XP(e))
                  , YP = (t, e, n, i) => {
                    let a = Lb.get(t);
                    a === void 0 && (a = new WeakMap,
                    Lb.set(t, a));
                    const o = WP(n, i);
                    return a.set(e, o),
                    o
                }
                  , jP = (t, e, n, i, a, o, u, f, d, p, g, v, y) => (S, E, w, A) => {
                    if (A.numberOfInputs === 0 && A.numberOfOutputs === 0)
                        throw d();
                    const T = Array.isArray(A.outputChannelCount) ? A.outputChannelCount : Array.from(A.outputChannelCount);
                    if (T.some(ve => ve < 1))
                        throw d();
                    if (T.length !== A.numberOfOutputs)
                        throw e();
                    if (A.channelCountMode !== "explicit")
                        throw d();
                    const R = A.channelCount * A.numberOfInputs
                      , N = T.reduce( (ve, Ce) => ve + Ce, 0)
                      , D = w.parameterDescriptors === void 0 ? 0 : w.parameterDescriptors.length;
                    if (R + D > 6 || N > 6)
                        throw d();
                    const U = new MessageChannel
                      , z = []
                      , I = [];
                    for (let ve = 0; ve < A.numberOfInputs; ve += 1)
                        z.push(u(S, {
                            channelCount: A.channelCount,
                            channelCountMode: A.channelCountMode,
                            channelInterpretation: A.channelInterpretation,
                            gain: 1
                        })),
                        I.push(a(S, {
                            channelCount: A.channelCount,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: A.channelCount
                        }));
                    const V = [];
                    if (w.parameterDescriptors !== void 0)
                        for (const {defaultValue: ve, maxValue: Ce, minValue: qe, name: Q} of w.parameterDescriptors) {
                            const Ke = o(S, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: A.parameterData[Q] !== void 0 ? A.parameterData[Q] : ve === void 0 ? 0 : ve
                            });
                            Object.defineProperties(Ke.offset, {
                                defaultValue: {
                                    get: () => ve === void 0 ? 0 : ve
                                },
                                maxValue: {
                                    get: () => Ce === void 0 ? Sa : Ce
                                },
                                minValue: {
                                    get: () => qe === void 0 ? Fa : qe
                                }
                            }),
                            V.push(Ke)
                        }
                    const B = i(S, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "speakers",
                        numberOfInputs: Math.max(1, R + D)
                    })
                      , P = J2(E, S.sampleRate)
                      , G = f(S, P, R + D, Math.max(1, N))
                      , K = a(S, {
                        channelCount: Math.max(1, N),
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        numberOfOutputs: Math.max(1, N)
                    })
                      , ee = [];
                    for (let ve = 0; ve < A.numberOfOutputs; ve += 1)
                        ee.push(i(S, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: T[ve]
                        }));
                    for (let ve = 0; ve < A.numberOfInputs; ve += 1) {
                        z[ve].connect(I[ve]);
                        for (let Ce = 0; Ce < A.channelCount; Ce += 1)
                            I[ve].connect(B, Ce, ve * A.channelCount + Ce)
                    }
                    const te = new Y2(w.parameterDescriptors === void 0 ? [] : w.parameterDescriptors.map( ({name: ve}, Ce) => {
                        const qe = V[Ce];
                        return qe.connect(B, 0, R + Ce),
                        qe.start(0),
                        [ve, qe.offset]
                    }
                    ));
                    B.connect(G);
                    let oe = A.channelInterpretation
                      , q = null;
                    const F = A.numberOfOutputs === 0 ? [G] : ee
                      , X = {
                        get bufferSize() {
                            return P
                        },
                        get channelCount() {
                            return A.channelCount
                        },
                        set channelCount(ve) {
                            throw n()
                        },
                        get channelCountMode() {
                            return A.channelCountMode
                        },
                        set channelCountMode(ve) {
                            throw n()
                        },
                        get channelInterpretation() {
                            return oe
                        },
                        set channelInterpretation(ve) {
                            for (const Ce of z)
                                Ce.channelInterpretation = ve;
                            oe = ve
                        },
                        get context() {
                            return G.context
                        },
                        get inputs() {
                            return z
                        },
                        get numberOfInputs() {
                            return A.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return A.numberOfOutputs
                        },
                        get onprocessorerror() {
                            return q
                        },
                        set onprocessorerror(ve) {
                            typeof q == "function" && X.removeEventListener("processorerror", q),
                            q = typeof ve == "function" ? ve : null,
                            typeof q == "function" && X.addEventListener("processorerror", q)
                        },
                        get parameters() {
                            return te
                        },
                        get port() {
                            return U.port2
                        },
                        addEventListener(...ve) {
                            return G.addEventListener(ve[0], ve[1], ve[2])
                        },
                        connect: t.bind(null, F),
                        disconnect: p.bind(null, F),
                        dispatchEvent(...ve) {
                            return G.dispatchEvent(ve[0])
                        },
                        removeEventListener(...ve) {
                            return G.removeEventListener(ve[0], ve[1], ve[2])
                        }
                    }
                      , $ = new Map;
                    U.port1.addEventListener = (ve => (...Ce) => {
                        if (Ce[0] === "message") {
                            const qe = typeof Ce[1] == "function" ? Ce[1] : typeof Ce[1] == "object" && Ce[1] !== null && typeof Ce[1].handleEvent == "function" ? Ce[1].handleEvent : null;
                            if (qe !== null) {
                                const Q = $.get(Ce[1]);
                                Q !== void 0 ? Ce[1] = Q : (Ce[1] = Ke => {
                                    g(S.currentTime, S.sampleRate, () => qe(Ke))
                                }
                                ,
                                $.set(qe, Ce[1]))
                            }
                        }
                        return ve.call(U.port1, Ce[0], Ce[1], Ce[2])
                    }
                    )(U.port1.addEventListener),
                    U.port1.removeEventListener = (ve => (...Ce) => {
                        if (Ce[0] === "message") {
                            const qe = $.get(Ce[1]);
                            qe !== void 0 && ($.delete(Ce[1]),
                            Ce[1] = qe)
                        }
                        return ve.call(U.port1, Ce[0], Ce[1], Ce[2])
                    }
                    )(U.port1.removeEventListener);
                    let ne = null;
                    Object.defineProperty(U.port1, "onmessage", {
                        get: () => ne,
                        set: ve => {
                            typeof ne == "function" && U.port1.removeEventListener("message", ne),
                            ne = typeof ve == "function" ? ve : null,
                            typeof ne == "function" && (U.port1.addEventListener("message", ne),
                            U.port1.start())
                        }
                    }),
                    w.prototype.port = U.port1;
                    let ce = null;
                    YP(S, X, w, A).then(ve => ce = ve);
                    const k = rS(A.numberOfInputs, A.channelCount)
                      , pe = rS(A.numberOfOutputs, T)
                      , Ae = w.parameterDescriptors === void 0 ? [] : w.parameterDescriptors.reduce( (ve, {name: Ce}) => ({
                        ...ve,
                        [Ce]: new Float32Array(128)
                    }), {});
                    let ie = !0;
                    const Me = () => {
                        A.numberOfOutputs > 0 && G.disconnect(K);
                        for (let ve = 0, Ce = 0; ve < A.numberOfOutputs; ve += 1) {
                            const qe = ee[ve];
                            for (let Q = 0; Q < T[ve]; Q += 1)
                                K.disconnect(qe, Ce + Q, Q);
                            Ce += T[ve]
                        }
                    }
                      , we = new Map;
                    G.onaudioprocess = ({inputBuffer: ve, outputBuffer: Ce}) => {
                        if (ce !== null) {
                            const qe = v(X);
                            for (let Q = 0; Q < P; Q += 128) {
                                for (let Ke = 0; Ke < A.numberOfInputs; Ke += 1)
                                    for (let Ve = 0; Ve < A.channelCount; Ve += 1)
                                        aS(ve, k[Ke], Ve, Ve, Q);
                                w.parameterDescriptors !== void 0 && w.parameterDescriptors.forEach( ({name: Ke}, Ve) => {
                                    aS(ve, Ae, Ke, R + Ve, Q)
                                }
                                );
                                for (let Ke = 0; Ke < A.numberOfInputs; Ke += 1)
                                    for (let Ve = 0; Ve < T[Ke]; Ve += 1)
                                        pe[Ke][Ve].byteLength === 0 && (pe[Ke][Ve] = new Float32Array(128));
                                try {
                                    const Ke = k.map( (Ve, ft) => {
                                        if (qe[ft].size > 0)
                                            return we.set(ft, P / 128),
                                            Ve;
                                        const ke = we.get(ft);
                                        return ke === void 0 ? [] : (Ve.every(Nt => Nt.every(Z => Z === 0)) && (ke === 1 ? we.delete(ft) : we.set(ft, ke - 1)),
                                        Ve)
                                    }
                                    );
                                    ie = g(S.currentTime + Q / S.sampleRate, S.sampleRate, () => ce.process(Ke, pe, Ae));
                                    for (let Ve = 0, ft = 0; Ve < A.numberOfOutputs; Ve += 1) {
                                        for (let ke = 0; ke < T[Ve]; ke += 1)
                                            j2(Ce, pe[Ve], ke, ft + ke, Q);
                                        ft += T[Ve]
                                    }
                                } catch (Ke) {
                                    ie = !1,
                                    X.dispatchEvent(new ErrorEvent("processorerror",{
                                        colno: Ke.colno,
                                        filename: Ke.filename,
                                        lineno: Ke.lineno,
                                        message: Ke.message
                                    }))
                                }
                                if (!ie) {
                                    for (let Ke = 0; Ke < A.numberOfInputs; Ke += 1) {
                                        z[Ke].disconnect(I[Ke]);
                                        for (let Ve = 0; Ve < A.channelCount; Ve += 1)
                                            I[Q].disconnect(B, Ve, Ke * A.channelCount + Ve)
                                    }
                                    if (w.parameterDescriptors !== void 0) {
                                        const Ke = w.parameterDescriptors.length;
                                        for (let Ve = 0; Ve < Ke; Ve += 1) {
                                            const ft = V[Ve];
                                            ft.disconnect(B, 0, R + Ve),
                                            ft.stop()
                                        }
                                    }
                                    B.disconnect(G),
                                    G.onaudioprocess = null,
                                    Te ? Me() : Ct();
                                    break
                                }
                            }
                        }
                    }
                    ;
                    let Te = !1;
                    const Je = u(S, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    })
                      , Ze = () => G.connect(Je).connect(S.destination)
                      , Ct = () => {
                        G.disconnect(Je),
                        Je.disconnect()
                    }
                      , bt = () => {
                        if (ie) {
                            Ct(),
                            A.numberOfOutputs > 0 && G.connect(K);
                            for (let ve = 0, Ce = 0; ve < A.numberOfOutputs; ve += 1) {
                                const qe = ee[ve];
                                for (let Q = 0; Q < T[ve]; Q += 1)
                                    K.connect(qe, Ce + Q, Q);
                                Ce += T[ve]
                            }
                        }
                        Te = !0
                    }
                      , Ue = () => {
                        ie && (Ze(),
                        Me()),
                        Te = !1
                    }
                    ;
                    return Ze(),
                    y(X, bt, Ue)
                }
                  , $2 = (t, e) => {
                    const n = t.createBiquadFilter();
                    return ls(n, e),
                    Di(n, e, "Q"),
                    Di(n, e, "detune"),
                    Di(n, e, "frequency"),
                    Di(n, e, "gain"),
                    vi(n, e, "type"),
                    n
                }
                  , ZP = (t, e) => (n, i) => {
                    const a = n.createChannelMerger(i.numberOfInputs);
                    return t !== null && t.name === "webkitAudioContext" && e(n, a),
                    ls(a, i),
                    a
                }
                  , QP = t => {
                    const e = t.numberOfOutputs;
                    Object.defineProperty(t, "channelCount", {
                        get: () => e,
                        set: n => {
                            if (n !== e)
                                throw $i()
                        }
                    }),
                    Object.defineProperty(t, "channelCountMode", {
                        get: () => "explicit",
                        set: n => {
                            if (n !== "explicit")
                                throw $i()
                        }
                    }),
                    Object.defineProperty(t, "channelInterpretation", {
                        get: () => "discrete",
                        set: n => {
                            if (n !== "discrete")
                                throw $i()
                        }
                    })
                }
                  , av = (t, e) => {
                    const n = t.createChannelSplitter(e.numberOfOutputs);
                    return ls(n, e),
                    QP(n),
                    n
                }
                  , KP = (t, e, n, i, a) => (o, u) => {
                    if (o.createConstantSource === void 0)
                        return n(o, u);
                    const f = o.createConstantSource();
                    return ls(f, u),
                    Di(f, u, "offset"),
                    e(i, () => i(o)) || Hb(f),
                    e(a, () => a(o)) || Gb(f),
                    t(o, f),
                    f
                }
                  , vp = (t, e) => (t.connect = e.connect.bind(e),
                t.disconnect = e.disconnect.bind(e),
                t)
                  , JP = (t, e, n, i) => (a, {offset: o, ...u}) => {
                    const f = a.createBuffer(1, 2, 44100)
                      , d = e(a, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    })
                      , p = n(a, {
                        ...u,
                        gain: o
                    })
                      , g = f.getChannelData(0);
                    g[0] = 1,
                    g[1] = 1,
                    d.buffer = f,
                    d.loop = !0;
                    const v = {
                        get bufferSize() {},
                        get channelCount() {
                            return p.channelCount
                        },
                        set channelCount(E) {
                            p.channelCount = E
                        },
                        get channelCountMode() {
                            return p.channelCountMode
                        },
                        set channelCountMode(E) {
                            p.channelCountMode = E
                        },
                        get channelInterpretation() {
                            return p.channelInterpretation
                        },
                        set channelInterpretation(E) {
                            p.channelInterpretation = E
                        },
                        get context() {
                            return p.context
                        },
                        get inputs() {
                            return []
                        },
                        get numberOfInputs() {
                            return d.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return p.numberOfOutputs
                        },
                        get offset() {
                            return p.gain
                        },
                        get onended() {
                            return d.onended
                        },
                        set onended(E) {
                            d.onended = E
                        },
                        addEventListener(...E) {
                            return d.addEventListener(E[0], E[1], E[2])
                        },
                        dispatchEvent(...E) {
                            return d.dispatchEvent(E[0])
                        },
                        removeEventListener(...E) {
                            return d.removeEventListener(E[0], E[1], E[2])
                        },
                        start(E=0) {
                            d.start.call(d, E)
                        },
                        stop(E=0) {
                            d.stop.call(d, E)
                        }
                    }
                      , y = () => d.connect(p)
                      , S = () => d.disconnect(p);
                    return t(a, d),
                    i(vp(v, p), y, S)
                }
                  , $P = (t, e) => (n, i) => {
                    const a = n.createConvolver();
                    if (ls(a, i),
                    i.disableNormalization === a.normalize && (a.normalize = !i.disableNormalization),
                    vi(a, i, "buffer"),
                    i.channelCount > 2 || (e(a, "channelCount", o => () => o.call(a), o => u => {
                        if (u > 2)
                            throw t();
                        return o.call(a, u)
                    }
                    ),
                    i.channelCountMode === "max"))
                        throw t();
                    return e(a, "channelCountMode", o => () => o.call(a), o => u => {
                        if (u === "max")
                            throw t();
                        return o.call(a, u)
                    }
                    ),
                    a
                }
                  , ew = (t, e) => {
                    const n = t.createDelay(e.maxDelayTime);
                    return ls(n, e),
                    Di(n, e, "delayTime"),
                    n
                }
                  , e6 = t => (e, n) => {
                    const i = e.createDynamicsCompressor();
                    if (ls(i, n),
                    n.channelCount > 2 || n.channelCountMode === "max")
                        throw t();
                    return Di(i, n, "attack"),
                    Di(i, n, "knee"),
                    Di(i, n, "ratio"),
                    Di(i, n, "release"),
                    Di(i, n, "threshold"),
                    i
                }
                  , Ha = (t, e) => {
                    const n = t.createGain();
                    return ls(n, e),
                    Di(n, e, "gain"),
                    n
                }
                  , t6 = t => (e, n, i) => {
                    if (e.createIIRFilter === void 0)
                        return t(e, n, i);
                    const a = e.createIIRFilter(i.feedforward, i.feedback);
                    return ls(a, i),
                    a
                }
                ;
                function n6(t, e) {
                    const n = e[0] * e[0] + e[1] * e[1];
                    return [(t[0] * e[0] + t[1] * e[1]) / n, (t[1] * e[0] - t[0] * e[1]) / n]
                }
                function i6(t, e) {
                    return [t[0] * e[0] - t[1] * e[1], t[0] * e[1] + t[1] * e[0]]
                }
                function tw(t, e) {
                    let n = [0, 0];
                    for (let i = t.length - 1; i >= 0; i -= 1)
                        n = i6(n, e),
                        n[0] += t[i];
                    return n
                }
                const s6 = (t, e, n, i) => (a, o, {channelCount: u, channelCountMode: f, channelInterpretation: d, feedback: p, feedforward: g}) => {
                    const v = J2(o, a.sampleRate)
                      , y = p instanceof Float64Array ? p : new Float64Array(p)
                      , S = g instanceof Float64Array ? g : new Float64Array(g)
                      , E = y.length
                      , w = S.length
                      , A = Math.min(E, w);
                    if (E === 0 || E > 20)
                        throw i();
                    if (y[0] === 0)
                        throw e();
                    if (w === 0 || w > 20)
                        throw i();
                    if (S[0] === 0)
                        throw e();
                    if (y[0] !== 1) {
                        for (let I = 0; I < w; I += 1)
                            S[I] /= y[0];
                        for (let I = 1; I < E; I += 1)
                            y[I] /= y[0]
                    }
                    const T = n(a, v, u, u);
                    T.channelCount = u,
                    T.channelCountMode = f,
                    T.channelInterpretation = d;
                    const R = 32
                      , N = []
                      , D = []
                      , U = [];
                    for (let I = 0; I < u; I += 1) {
                        N.push(0);
                        const V = new Float32Array(R)
                          , B = new Float32Array(R);
                        V.fill(0),
                        B.fill(0),
                        D.push(V),
                        U.push(B)
                    }
                    T.onaudioprocess = I => {
                        const V = I.inputBuffer
                          , B = I.outputBuffer
                          , P = V.numberOfChannels;
                        for (let G = 0; G < P; G += 1) {
                            const K = V.getChannelData(G)
                              , ee = B.getChannelData(G);
                            N[G] = Q2(y, E, S, w, A, D[G], U[G], N[G], R, K, ee)
                        }
                    }
                    ;
                    const z = a.sampleRate / 2;
                    return vp({
                        get bufferSize() {
                            return v
                        },
                        get channelCount() {
                            return T.channelCount
                        },
                        set channelCount(I) {
                            T.channelCount = I
                        },
                        get channelCountMode() {
                            return T.channelCountMode
                        },
                        set channelCountMode(I) {
                            T.channelCountMode = I
                        },
                        get channelInterpretation() {
                            return T.channelInterpretation
                        },
                        set channelInterpretation(I) {
                            T.channelInterpretation = I
                        },
                        get context() {
                            return T.context
                        },
                        get inputs() {
                            return [T]
                        },
                        get numberOfInputs() {
                            return T.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return T.numberOfOutputs
                        },
                        addEventListener(...I) {
                            return T.addEventListener(I[0], I[1], I[2])
                        },
                        dispatchEvent(...I) {
                            return T.dispatchEvent(I[0])
                        },
                        getFrequencyResponse(I, V, B) {
                            if (I.length !== V.length || V.length !== B.length)
                                throw t();
                            const P = I.length;
                            for (let G = 0; G < P; G += 1) {
                                const K = -Math.PI * (I[G] / z)
                                  , ee = [Math.cos(K), Math.sin(K)]
                                  , te = n6(tw(S, ee), tw(y, ee));
                                V[G] = Math.sqrt(te[0] * te[0] + te[1] * te[1]),
                                B[G] = Math.atan2(te[1], te[0])
                            }
                        },
                        removeEventListener(...I) {
                            return T.removeEventListener(I[0], I[1], I[2])
                        }
                    }, T)
                }
                  , a6 = (t, e) => t.createMediaElementSource(e.mediaElement)
                  , r6 = (t, e) => {
                    const n = t.createMediaStreamDestination();
                    return ls(n, e),
                    n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", {
                        get: () => 0
                    }),
                    n
                }
                  , o6 = (t, {mediaStream: e}) => {
                    const n = e.getAudioTracks();
                    n.sort( (o, u) => o.id < u.id ? -1 : o.id > u.id ? 1 : 0);
                    const i = n.slice(0, 1)
                      , a = t.createMediaStreamSource(new MediaStream(i));
                    return Object.defineProperty(a, "mediaStream", {
                        value: e
                    }),
                    a
                }
                  , l6 = (t, e) => (n, {mediaStreamTrack: i}) => {
                    if (typeof n.createMediaStreamTrackSource == "function")
                        return n.createMediaStreamTrackSource(i);
                    const a = new MediaStream([i])
                      , o = n.createMediaStreamSource(a);
                    if (i.kind !== "audio")
                        throw t();
                    if (e(n))
                        throw new TypeError;
                    return o
                }
                  , c6 = t => t === null ? null : t.hasOwnProperty("OfflineAudioContext") ? t.OfflineAudioContext : t.hasOwnProperty("webkitOfflineAudioContext") ? t.webkitOfflineAudioContext : null
                  , u6 = (t, e, n, i, a, o) => (u, f) => {
                    const d = u.createOscillator();
                    return ls(d, f),
                    Di(d, f, "detune"),
                    Di(d, f, "frequency"),
                    f.periodicWave !== void 0 ? d.setPeriodicWave(f.periodicWave) : vi(d, f, "type"),
                    e(n, () => n(u)) || Hb(d),
                    e(i, () => i(u)) || o(d, u),
                    e(a, () => a(u)) || Gb(d),
                    t(u, d),
                    d
                }
                  , h6 = t => (e, n) => {
                    const i = e.createPanner();
                    return i.orientationX === void 0 ? t(e, n) : (ls(i, n),
                    Di(i, n, "orientationX"),
                    Di(i, n, "orientationY"),
                    Di(i, n, "orientationZ"),
                    Di(i, n, "positionX"),
                    Di(i, n, "positionY"),
                    Di(i, n, "positionZ"),
                    vi(i, n, "coneInnerAngle"),
                    vi(i, n, "coneOuterAngle"),
                    vi(i, n, "coneOuterGain"),
                    vi(i, n, "distanceModel"),
                    vi(i, n, "maxDistance"),
                    vi(i, n, "panningModel"),
                    vi(i, n, "refDistance"),
                    vi(i, n, "rolloffFactor"),
                    i)
                }
                  , f6 = (t, e, n, i, a, o, u, f, d, p) => (g, {coneInnerAngle: v, coneOuterAngle: y, coneOuterGain: S, distanceModel: E, maxDistance: w, orientationX: A, orientationY: T, orientationZ: R, panningModel: N, positionX: D, positionY: U, positionZ: z, refDistance: I, rolloffFactor: V, ...B}) => {
                    const P = g.createPanner();
                    if (B.channelCount > 2 || B.channelCountMode === "max")
                        throw u();
                    ls(P, B);
                    const G = {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete"
                    }
                      , K = n(g, {
                        ...G,
                        channelInterpretation: "speakers",
                        numberOfInputs: 6
                    })
                      , ee = i(g, {
                        ...B,
                        gain: 1
                    })
                      , te = i(g, {
                        ...G,
                        gain: 1
                    })
                      , oe = i(g, {
                        ...G,
                        gain: 0
                    })
                      , q = i(g, {
                        ...G,
                        gain: 0
                    })
                      , F = i(g, {
                        ...G,
                        gain: 0
                    })
                      , X = i(g, {
                        ...G,
                        gain: 0
                    })
                      , $ = i(g, {
                        ...G,
                        gain: 0
                    })
                      , ne = a(g, 256, 6, 1)
                      , ce = o(g, {
                        ...G,
                        curve: new Float32Array([1, 1]),
                        oversample: "none"
                    });
                    let k = [A, T, R]
                      , pe = [D, U, z];
                    const Ae = new Float32Array(1);
                    ne.onaudioprocess = ({inputBuffer: Te}) => {
                        const Je = [d(Te, Ae, 0), d(Te, Ae, 1), d(Te, Ae, 2)];
                        Je.some( (Ct, bt) => Ct !== k[bt]) && (P.setOrientation(...Je),
                        k = Je);
                        const Ze = [d(Te, Ae, 3), d(Te, Ae, 4), d(Te, Ae, 5)];
                        Ze.some( (Ct, bt) => Ct !== pe[bt]) && (P.setPosition(...Ze),
                        pe = Ze)
                    }
                    ,
                    Object.defineProperty(oe.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(q.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(F.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(X.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty($.gain, "defaultValue", {
                        get: () => 0
                    });
                    const ie = {
                        get bufferSize() {},
                        get channelCount() {
                            return P.channelCount
                        },
                        set channelCount(Te) {
                            if (Te > 2)
                                throw u();
                            ee.channelCount = Te,
                            P.channelCount = Te
                        },
                        get channelCountMode() {
                            return P.channelCountMode
                        },
                        set channelCountMode(Te) {
                            if (Te === "max")
                                throw u();
                            ee.channelCountMode = Te,
                            P.channelCountMode = Te
                        },
                        get channelInterpretation() {
                            return P.channelInterpretation
                        },
                        set channelInterpretation(Te) {
                            ee.channelInterpretation = Te,
                            P.channelInterpretation = Te
                        },
                        get coneInnerAngle() {
                            return P.coneInnerAngle
                        },
                        set coneInnerAngle(Te) {
                            P.coneInnerAngle = Te
                        },
                        get coneOuterAngle() {
                            return P.coneOuterAngle
                        },
                        set coneOuterAngle(Te) {
                            P.coneOuterAngle = Te
                        },
                        get coneOuterGain() {
                            return P.coneOuterGain
                        },
                        set coneOuterGain(Te) {
                            if (Te < 0 || Te > 1)
                                throw e();
                            P.coneOuterGain = Te
                        },
                        get context() {
                            return P.context
                        },
                        get distanceModel() {
                            return P.distanceModel
                        },
                        set distanceModel(Te) {
                            P.distanceModel = Te
                        },
                        get inputs() {
                            return [ee]
                        },
                        get maxDistance() {
                            return P.maxDistance
                        },
                        set maxDistance(Te) {
                            if (Te < 0)
                                throw new RangeError;
                            P.maxDistance = Te
                        },
                        get numberOfInputs() {
                            return P.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return P.numberOfOutputs
                        },
                        get orientationX() {
                            return te.gain
                        },
                        get orientationY() {
                            return oe.gain
                        },
                        get orientationZ() {
                            return q.gain
                        },
                        get panningModel() {
                            return P.panningModel
                        },
                        set panningModel(Te) {
                            P.panningModel = Te
                        },
                        get positionX() {
                            return F.gain
                        },
                        get positionY() {
                            return X.gain
                        },
                        get positionZ() {
                            return $.gain
                        },
                        get refDistance() {
                            return P.refDistance
                        },
                        set refDistance(Te) {
                            if (Te < 0)
                                throw new RangeError;
                            P.refDistance = Te
                        },
                        get rolloffFactor() {
                            return P.rolloffFactor
                        },
                        set rolloffFactor(Te) {
                            if (Te < 0)
                                throw new RangeError;
                            P.rolloffFactor = Te
                        },
                        addEventListener(...Te) {
                            return ee.addEventListener(Te[0], Te[1], Te[2])
                        },
                        dispatchEvent(...Te) {
                            return ee.dispatchEvent(Te[0])
                        },
                        removeEventListener(...Te) {
                            return ee.removeEventListener(Te[0], Te[1], Te[2])
                        }
                    };
                    v !== ie.coneInnerAngle && (ie.coneInnerAngle = v),
                    y !== ie.coneOuterAngle && (ie.coneOuterAngle = y),
                    S !== ie.coneOuterGain && (ie.coneOuterGain = S),
                    E !== ie.distanceModel && (ie.distanceModel = E),
                    w !== ie.maxDistance && (ie.maxDistance = w),
                    A !== ie.orientationX.value && (ie.orientationX.value = A),
                    T !== ie.orientationY.value && (ie.orientationY.value = T),
                    R !== ie.orientationZ.value && (ie.orientationZ.value = R),
                    N !== ie.panningModel && (ie.panningModel = N),
                    D !== ie.positionX.value && (ie.positionX.value = D),
                    U !== ie.positionY.value && (ie.positionY.value = U),
                    z !== ie.positionZ.value && (ie.positionZ.value = z),
                    I !== ie.refDistance && (ie.refDistance = I),
                    V !== ie.rolloffFactor && (ie.rolloffFactor = V),
                    (k[0] !== 1 || k[1] !== 0 || k[2] !== 0) && P.setOrientation(...k),
                    (pe[0] !== 0 || pe[1] !== 0 || pe[2] !== 0) && P.setPosition(...pe);
                    const Me = () => {
                        ee.connect(P),
                        t(ee, ce, 0, 0),
                        ce.connect(te).connect(K, 0, 0),
                        ce.connect(oe).connect(K, 0, 1),
                        ce.connect(q).connect(K, 0, 2),
                        ce.connect(F).connect(K, 0, 3),
                        ce.connect(X).connect(K, 0, 4),
                        ce.connect($).connect(K, 0, 5),
                        K.connect(ne).connect(g.destination)
                    }
                      , we = () => {
                        ee.disconnect(P),
                        f(ee, ce, 0, 0),
                        ce.disconnect(te),
                        te.disconnect(K),
                        ce.disconnect(oe),
                        oe.disconnect(K),
                        ce.disconnect(q),
                        q.disconnect(K),
                        ce.disconnect(F),
                        F.disconnect(K),
                        ce.disconnect(X),
                        X.disconnect(K),
                        ce.disconnect($),
                        $.disconnect(K),
                        K.disconnect(ne),
                        ne.disconnect(g.destination)
                    }
                    ;
                    return p(vp(ie, P), Me, we)
                }
                  , d6 = t => (e, {disableNormalization: n, imag: i, real: a}) => {
                    const o = i instanceof Float32Array ? i : new Float32Array(i)
                      , u = a instanceof Float32Array ? a : new Float32Array(a)
                      , f = e.createPeriodicWave(u, o, {
                        disableNormalization: n
                    });
                    if (Array.from(i).length < 2)
                        throw t();
                    return f
                }
                  , rv = (t, e, n, i) => t.createScriptProcessor(e, n, i)
                  , p6 = (t, e) => (n, i) => {
                    const a = i.channelCountMode;
                    if (a === "clamped-max")
                        throw e();
                    if (n.createStereoPanner === void 0)
                        return t(n, i);
                    const o = n.createStereoPanner();
                    return ls(o, i),
                    Di(o, i, "pan"),
                    Object.defineProperty(o, "channelCountMode", {
                        get: () => a,
                        set: u => {
                            if (u !== a)
                                throw e()
                        }
                    }),
                    o
                }
                  , m6 = (t, e, n, i, a, o) => {
                    const f = new Float32Array([1, 1])
                      , d = Math.PI / 2
                      , p = {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete"
                    }
                      , g = {
                        ...p,
                        oversample: "none"
                    }
                      , v = (E, w, A, T) => {
                        const R = new Float32Array(16385)
                          , N = new Float32Array(16385);
                        for (let B = 0; B < 16385; B += 1) {
                            const P = B / 16384 * d;
                            R[B] = Math.cos(P),
                            N[B] = Math.sin(P)
                        }
                        const D = n(E, {
                            ...p,
                            gain: 0
                        })
                          , U = i(E, {
                            ...g,
                            curve: R
                        })
                          , z = i(E, {
                            ...g,
                            curve: f
                        })
                          , I = n(E, {
                            ...p,
                            gain: 0
                        })
                          , V = i(E, {
                            ...g,
                            curve: N
                        });
                        return {
                            connectGraph() {
                                w.connect(D),
                                w.connect(z.inputs === void 0 ? z : z.inputs[0]),
                                w.connect(I),
                                z.connect(A),
                                A.connect(U.inputs === void 0 ? U : U.inputs[0]),
                                A.connect(V.inputs === void 0 ? V : V.inputs[0]),
                                U.connect(D.gain),
                                V.connect(I.gain),
                                D.connect(T, 0, 0),
                                I.connect(T, 0, 1)
                            },
                            disconnectGraph() {
                                w.disconnect(D),
                                w.disconnect(z.inputs === void 0 ? z : z.inputs[0]),
                                w.disconnect(I),
                                z.disconnect(A),
                                A.disconnect(U.inputs === void 0 ? U : U.inputs[0]),
                                A.disconnect(V.inputs === void 0 ? V : V.inputs[0]),
                                U.disconnect(D.gain),
                                V.disconnect(I.gain),
                                D.disconnect(T, 0, 0),
                                I.disconnect(T, 0, 1)
                            }
                        }
                    }
                      , y = (E, w, A, T) => {
                        const R = new Float32Array(16385)
                          , N = new Float32Array(16385)
                          , D = new Float32Array(16385)
                          , U = new Float32Array(16385)
                          , z = Math.floor(16385 / 2);
                        for (let F = 0; F < 16385; F += 1)
                            if (F > z) {
                                const X = (F - z) / (16384 - z) * d;
                                R[F] = Math.cos(X),
                                N[F] = Math.sin(X),
                                D[F] = 0,
                                U[F] = 1
                            } else {
                                const X = F / (16384 - z) * d;
                                R[F] = 1,
                                N[F] = 0,
                                D[F] = Math.cos(X),
                                U[F] = Math.sin(X)
                            }
                        const I = e(E, {
                            channelCount: 2,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: 2
                        })
                          , V = n(E, {
                            ...p,
                            gain: 0
                        })
                          , B = i(E, {
                            ...g,
                            curve: R
                        })
                          , P = n(E, {
                            ...p,
                            gain: 0
                        })
                          , G = i(E, {
                            ...g,
                            curve: N
                        })
                          , K = i(E, {
                            ...g,
                            curve: f
                        })
                          , ee = n(E, {
                            ...p,
                            gain: 0
                        })
                          , te = i(E, {
                            ...g,
                            curve: D
                        })
                          , oe = n(E, {
                            ...p,
                            gain: 0
                        })
                          , q = i(E, {
                            ...g,
                            curve: U
                        });
                        return {
                            connectGraph() {
                                w.connect(I),
                                w.connect(K.inputs === void 0 ? K : K.inputs[0]),
                                I.connect(V, 0),
                                I.connect(P, 0),
                                I.connect(ee, 1),
                                I.connect(oe, 1),
                                K.connect(A),
                                A.connect(B.inputs === void 0 ? B : B.inputs[0]),
                                A.connect(G.inputs === void 0 ? G : G.inputs[0]),
                                A.connect(te.inputs === void 0 ? te : te.inputs[0]),
                                A.connect(q.inputs === void 0 ? q : q.inputs[0]),
                                B.connect(V.gain),
                                G.connect(P.gain),
                                te.connect(ee.gain),
                                q.connect(oe.gain),
                                V.connect(T, 0, 0),
                                ee.connect(T, 0, 0),
                                P.connect(T, 0, 1),
                                oe.connect(T, 0, 1)
                            },
                            disconnectGraph() {
                                w.disconnect(I),
                                w.disconnect(K.inputs === void 0 ? K : K.inputs[0]),
                                I.disconnect(V, 0),
                                I.disconnect(P, 0),
                                I.disconnect(ee, 1),
                                I.disconnect(oe, 1),
                                K.disconnect(A),
                                A.disconnect(B.inputs === void 0 ? B : B.inputs[0]),
                                A.disconnect(G.inputs === void 0 ? G : G.inputs[0]),
                                A.disconnect(te.inputs === void 0 ? te : te.inputs[0]),
                                A.disconnect(q.inputs === void 0 ? q : q.inputs[0]),
                                B.disconnect(V.gain),
                                G.disconnect(P.gain),
                                te.disconnect(ee.gain),
                                q.disconnect(oe.gain),
                                V.disconnect(T, 0, 0),
                                ee.disconnect(T, 0, 0),
                                P.disconnect(T, 0, 1),
                                oe.disconnect(T, 0, 1)
                            }
                        }
                    }
                      , S = (E, w, A, T, R) => {
                        if (w === 1)
                            return v(E, A, T, R);
                        if (w === 2)
                            return y(E, A, T, R);
                        throw a()
                    }
                    ;
                    return (E, {channelCount: w, channelCountMode: A, pan: T, ...R}) => {
                        if (A === "max")
                            throw a();
                        const N = t(E, {
                            ...R,
                            channelCount: 1,
                            channelCountMode: A,
                            numberOfInputs: 2
                        })
                          , D = n(E, {
                            ...R,
                            channelCount: w,
                            channelCountMode: A,
                            gain: 1
                        })
                          , U = n(E, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            gain: T
                        });
                        let {connectGraph: z, disconnectGraph: I} = S(E, w, D, U, N);
                        Object.defineProperty(U.gain, "defaultValue", {
                            get: () => 0
                        }),
                        Object.defineProperty(U.gain, "maxValue", {
                            get: () => 1
                        }),
                        Object.defineProperty(U.gain, "minValue", {
                            get: () => -1
                        });
                        const V = {
                            get bufferSize() {},
                            get channelCount() {
                                return D.channelCount
                            },
                            set channelCount(K) {
                                D.channelCount !== K && (B && I(),
                                {connectGraph: z, disconnectGraph: I} = S(E, K, D, U, N),
                                B && z()),
                                D.channelCount = K
                            },
                            get channelCountMode() {
                                return D.channelCountMode
                            },
                            set channelCountMode(K) {
                                if (K === "clamped-max" || K === "max")
                                    throw a();
                                D.channelCountMode = K
                            },
                            get channelInterpretation() {
                                return D.channelInterpretation
                            },
                            set channelInterpretation(K) {
                                D.channelInterpretation = K
                            },
                            get context() {
                                return D.context
                            },
                            get inputs() {
                                return [D]
                            },
                            get numberOfInputs() {
                                return D.numberOfInputs
                            },
                            get numberOfOutputs() {
                                return D.numberOfOutputs
                            },
                            get pan() {
                                return U.gain
                            },
                            addEventListener(...K) {
                                return D.addEventListener(K[0], K[1], K[2])
                            },
                            dispatchEvent(...K) {
                                return D.dispatchEvent(K[0])
                            },
                            removeEventListener(...K) {
                                return D.removeEventListener(K[0], K[1], K[2])
                            }
                        };
                        let B = !1;
                        const P = () => {
                            z(),
                            B = !0
                        }
                          , G = () => {
                            I(),
                            B = !1
                        }
                        ;
                        return o(vp(V, N), P, G)
                    }
                }
                  , g6 = (t, e, n, i, a, o, u) => (f, d) => {
                    const p = f.createWaveShaper();
                    if (o !== null && o.name === "webkitAudioContext" && f.createGain().gain.automationRate === void 0)
                        return n(f, d);
                    ls(p, d);
                    const g = d.curve === null || d.curve instanceof Float32Array ? d.curve : new Float32Array(d.curve);
                    if (g !== null && g.length < 2)
                        throw e();
                    vi(p, {
                        curve: g
                    }, "curve"),
                    vi(p, d, "oversample");
                    let v = null
                      , y = !1;
                    return u(p, "curve", w => () => w.call(p), w => A => (w.call(p, A),
                    y && (i(A) && v === null ? v = t(f, p) : !i(A) && v !== null && (v(),
                    v = null)),
                    A)),
                    a(p, () => {
                        y = !0,
                        i(p.curve) && (v = t(f, p))
                    }
                    , () => {
                        y = !1,
                        v !== null && (v(),
                        v = null)
                    }
                    )
                }
                  , v6 = (t, e, n, i, a) => (o, {curve: u, oversample: f, ...d}) => {
                    const p = o.createWaveShaper()
                      , g = o.createWaveShaper();
                    ls(p, d),
                    ls(g, d);
                    const v = n(o, {
                        ...d,
                        gain: 1
                    })
                      , y = n(o, {
                        ...d,
                        gain: -1
                    })
                      , S = n(o, {
                        ...d,
                        gain: 1
                    })
                      , E = n(o, {
                        ...d,
                        gain: -1
                    });
                    let w = null
                      , A = !1
                      , T = null;
                    const R = {
                        get bufferSize() {},
                        get channelCount() {
                            return p.channelCount
                        },
                        set channelCount(U) {
                            v.channelCount = U,
                            y.channelCount = U,
                            p.channelCount = U,
                            S.channelCount = U,
                            g.channelCount = U,
                            E.channelCount = U
                        },
                        get channelCountMode() {
                            return p.channelCountMode
                        },
                        set channelCountMode(U) {
                            v.channelCountMode = U,
                            y.channelCountMode = U,
                            p.channelCountMode = U,
                            S.channelCountMode = U,
                            g.channelCountMode = U,
                            E.channelCountMode = U
                        },
                        get channelInterpretation() {
                            return p.channelInterpretation
                        },
                        set channelInterpretation(U) {
                            v.channelInterpretation = U,
                            y.channelInterpretation = U,
                            p.channelInterpretation = U,
                            S.channelInterpretation = U,
                            g.channelInterpretation = U,
                            E.channelInterpretation = U
                        },
                        get context() {
                            return p.context
                        },
                        get curve() {
                            return T
                        },
                        set curve(U) {
                            if (U !== null && U.length < 2)
                                throw e();
                            if (U === null)
                                p.curve = U,
                                g.curve = U;
                            else {
                                const z = U.length
                                  , I = new Float32Array(z + 2 - z % 2)
                                  , V = new Float32Array(z + 2 - z % 2);
                                I[0] = U[0],
                                V[0] = -U[z - 1];
                                const B = Math.ceil((z + 1) / 2)
                                  , P = (z + 1) / 2 - 1;
                                for (let G = 1; G < B; G += 1) {
                                    const K = G / B * P
                                      , ee = Math.floor(K)
                                      , te = Math.ceil(K);
                                    I[G] = ee === te ? U[ee] : (1 - (K - ee)) * U[ee] + (1 - (te - K)) * U[te],
                                    V[G] = ee === te ? -U[z - 1 - ee] : -((1 - (K - ee)) * U[z - 1 - ee]) - (1 - (te - K)) * U[z - 1 - te]
                                }
                                I[B] = z % 2 === 1 ? U[B - 1] : (U[B - 2] + U[B - 1]) / 2,
                                p.curve = I,
                                g.curve = V
                            }
                            T = U,
                            A && (i(T) && w === null ? w = t(o, v) : w !== null && (w(),
                            w = null))
                        },
                        get inputs() {
                            return [v]
                        },
                        get numberOfInputs() {
                            return p.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return p.numberOfOutputs
                        },
                        get oversample() {
                            return p.oversample
                        },
                        set oversample(U) {
                            p.oversample = U,
                            g.oversample = U
                        },
                        addEventListener(...U) {
                            return v.addEventListener(U[0], U[1], U[2])
                        },
                        dispatchEvent(...U) {
                            return v.dispatchEvent(U[0])
                        },
                        removeEventListener(...U) {
                            return v.removeEventListener(U[0], U[1], U[2])
                        }
                    };
                    u !== null && (R.curve = u instanceof Float32Array ? u : new Float32Array(u)),
                    f !== R.oversample && (R.oversample = f);
                    const N = () => {
                        v.connect(p).connect(S),
                        v.connect(y).connect(g).connect(E).connect(S),
                        A = !0,
                        i(T) && (w = t(o, v))
                    }
                      , D = () => {
                        v.disconnect(p),
                        p.disconnect(S),
                        v.disconnect(y),
                        y.disconnect(g),
                        g.disconnect(E),
                        E.disconnect(S),
                        A = !1,
                        w !== null && (w(),
                        w = null)
                    }
                    ;
                    return a(vp(R, S), N, D)
                }
                  , Zs = () => new DOMException("","NotSupportedError")
                  , _6 = {
                    numberOfChannels: 1
                }
                  , y6 = (t, e, n, i, a) => class extends t {
                    constructor(u, f, d) {
                        let p;
                        if (typeof u == "number" && f !== void 0 && d !== void 0)
                            p = {
                                length: f,
                                numberOfChannels: u,
                                sampleRate: d
                            };
                        else if (typeof u == "object")
                            p = u;
                        else
                            throw new Error("The given parameters are not valid.");
                        const {length: g, numberOfChannels: v, sampleRate: y} = {
                            ..._6,
                            ...p
                        }
                          , S = i(v, g, y);
                        e(Qh, () => Qh(S)) || S.addEventListener("statechange", ( () => {
                            let E = 0;
                            const w = A => {
                                this._state === "running" && (E > 0 ? (S.removeEventListener("statechange", w),
                                A.stopImmediatePropagation(),
                                this._waitForThePromiseToSettle(A)) : E += 1)
                            }
                            ;
                            return w
                        }
                        )()),
                        super(S, v),
                        this._length = g,
                        this._nativeOfflineAudioContext = S,
                        this._state = null
                    }
                    get length() {
                        return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
                    }
                    get state() {
                        return this._state === null ? this._nativeOfflineAudioContext.state : this._state
                    }
                    startRendering() {
                        return this._state === "running" ? Promise.reject(n()) : (this._state = "running",
                        a(this.destination, this._nativeOfflineAudioContext).finally( () => {
                            this._state = null,
                            $y(this)
                        }
                        ))
                    }
                    _waitForThePromiseToSettle(u) {
                        this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(u) : setTimeout( () => this._waitForThePromiseToSettle(u))
                    }
                }
                  , S6 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    detune: 0,
                    frequency: 440,
                    periodicWave: void 0,
                    type: "sine"
                }
                  , x6 = (t, e, n, i, a, o, u) => class extends t {
                    constructor(d, p) {
                        const g = a(d)
                          , v = {
                            ...S6,
                            ...p
                        }
                          , y = n(g, v)
                          , S = o(g)
                          , E = S ? i() : null
                          , w = d.sampleRate / 2;
                        super(d, !1, y, E),
                        this._detune = e(this, S, y.detune, 153600, -153600),
                        this._frequency = e(this, S, y.frequency, w, -w),
                        this._nativeOscillatorNode = y,
                        this._onended = null,
                        this._oscillatorNodeRenderer = E,
                        this._oscillatorNodeRenderer !== null && v.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = v.periodicWave)
                    }
                    get detune() {
                        return this._detune
                    }
                    get frequency() {
                        return this._frequency
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(d) {
                        const p = typeof d == "function" ? u(this, d) : null;
                        this._nativeOscillatorNode.onended = p;
                        const g = this._nativeOscillatorNode.onended;
                        this._onended = g !== null && g === p ? d : g
                    }
                    get type() {
                        return this._nativeOscillatorNode.type
                    }
                    set type(d) {
                        this._nativeOscillatorNode.type = d,
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null)
                    }
                    setPeriodicWave(d) {
                        this._nativeOscillatorNode.setPeriodicWave(d),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = d)
                    }
                    start(d=0) {
                        if (this._nativeOscillatorNode.start(d),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = d),
                        this.context.state !== "closed") {
                            mp(this);
                            const p = () => {
                                this._nativeOscillatorNode.removeEventListener("ended", p),
                                hc(this) && tv(this)
                            }
                            ;
                            this._nativeOscillatorNode.addEventListener("ended", p)
                        }
                    }
                    stop(d=0) {
                        this._nativeOscillatorNode.stop(d),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = d)
                    }
                }
                  , M6 = (t, e, n, i, a) => () => {
                    const o = new WeakMap;
                    let u = null
                      , f = null
                      , d = null;
                    const p = async (g, v) => {
                        let y = n(g);
                        const S = js(y, v);
                        return S || (y = e(v, {
                            channelCount: y.channelCount,
                            channelCountMode: y.channelCountMode,
                            channelInterpretation: y.channelInterpretation,
                            detune: y.detune.value,
                            frequency: y.frequency.value,
                            periodicWave: u === null ? void 0 : u,
                            type: y.type
                        }),
                        f !== null && y.start(f),
                        d !== null && y.stop(d)),
                        o.set(v, y),
                        S ? (await t(v, g.detune, y.detune),
                        await t(v, g.frequency, y.frequency)) : (await i(v, g.detune, y.detune),
                        await i(v, g.frequency, y.frequency)),
                        await a(g, v, y),
                        y
                    }
                    ;
                    return {
                        set periodicWave(g) {
                            u = g
                        },
                        set start(g) {
                            f = g
                        },
                        set stop(g) {
                            d = g
                        },
                        render(g, v) {
                            const y = o.get(v);
                            return y !== void 0 ? Promise.resolve(y) : p(g, v)
                        }
                    }
                }
                  , b6 = {
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    coneInnerAngle: 360,
                    coneOuterAngle: 360,
                    coneOuterGain: 0,
                    distanceModel: "inverse",
                    maxDistance: 1e4,
                    orientationX: 1,
                    orientationY: 0,
                    orientationZ: 0,
                    panningModel: "equalpower",
                    positionX: 0,
                    positionY: 0,
                    positionZ: 0,
                    refDistance: 1,
                    rolloffFactor: 1
                }
                  , T6 = (t, e, n, i, a, o, u) => class extends t {
                    constructor(d, p) {
                        const g = a(d)
                          , v = n(g, {
                            ...b6,
                            ...p
                        })
                          , y = o(g)
                          , S = y ? i() : null;
                        super(d, !1, v, S),
                        this._nativePannerNode = v,
                        this._orientationX = e(this, y, v.orientationX, Sa, Fa),
                        this._orientationY = e(this, y, v.orientationY, Sa, Fa),
                        this._orientationZ = e(this, y, v.orientationZ, Sa, Fa),
                        this._positionX = e(this, y, v.positionX, Sa, Fa),
                        this._positionY = e(this, y, v.positionY, Sa, Fa),
                        this._positionZ = e(this, y, v.positionZ, Sa, Fa),
                        u(this, 1)
                    }
                    get coneInnerAngle() {
                        return this._nativePannerNode.coneInnerAngle
                    }
                    set coneInnerAngle(d) {
                        this._nativePannerNode.coneInnerAngle = d
                    }
                    get coneOuterAngle() {
                        return this._nativePannerNode.coneOuterAngle
                    }
                    set coneOuterAngle(d) {
                        this._nativePannerNode.coneOuterAngle = d
                    }
                    get coneOuterGain() {
                        return this._nativePannerNode.coneOuterGain
                    }
                    set coneOuterGain(d) {
                        this._nativePannerNode.coneOuterGain = d
                    }
                    get distanceModel() {
                        return this._nativePannerNode.distanceModel
                    }
                    set distanceModel(d) {
                        this._nativePannerNode.distanceModel = d
                    }
                    get maxDistance() {
                        return this._nativePannerNode.maxDistance
                    }
                    set maxDistance(d) {
                        this._nativePannerNode.maxDistance = d
                    }
                    get orientationX() {
                        return this._orientationX
                    }
                    get orientationY() {
                        return this._orientationY
                    }
                    get orientationZ() {
                        return this._orientationZ
                    }
                    get panningModel() {
                        return this._nativePannerNode.panningModel
                    }
                    set panningModel(d) {
                        this._nativePannerNode.panningModel = d
                    }
                    get positionX() {
                        return this._positionX
                    }
                    get positionY() {
                        return this._positionY
                    }
                    get positionZ() {
                        return this._positionZ
                    }
                    get refDistance() {
                        return this._nativePannerNode.refDistance
                    }
                    set refDistance(d) {
                        this._nativePannerNode.refDistance = d
                    }
                    get rolloffFactor() {
                        return this._nativePannerNode.rolloffFactor
                    }
                    set rolloffFactor(d) {
                        this._nativePannerNode.rolloffFactor = d
                    }
                }
                  , A6 = (t, e, n, i, a, o, u, f, d, p) => () => {
                    const g = new WeakMap;
                    let v = null;
                    const y = async (S, E) => {
                        let w = null
                          , A = o(S);
                        const T = {
                            channelCount: A.channelCount,
                            channelCountMode: A.channelCountMode,
                            channelInterpretation: A.channelInterpretation
                        }
                          , R = {
                            ...T,
                            coneInnerAngle: A.coneInnerAngle,
                            coneOuterAngle: A.coneOuterAngle,
                            coneOuterGain: A.coneOuterGain,
                            distanceModel: A.distanceModel,
                            maxDistance: A.maxDistance,
                            panningModel: A.panningModel,
                            refDistance: A.refDistance,
                            rolloffFactor: A.rolloffFactor
                        }
                          , N = js(A, E);
                        if ("bufferSize"in A ? w = i(E, {
                            ...T,
                            gain: 1
                        }) : N || (A = a(E, {
                            ...R,
                            orientationX: A.orientationX.value,
                            orientationY: A.orientationY.value,
                            orientationZ: A.orientationZ.value,
                            positionX: A.positionX.value,
                            positionY: A.positionY.value,
                            positionZ: A.positionZ.value
                        })),
                        g.set(E, w === null ? A : w),
                        w !== null) {
                            if (v === null) {
                                if (u === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const G = new u(6,S.context.length,E.sampleRate)
                                  , K = e(G, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: 6
                                });
                                K.connect(G.destination),
                                v = (async () => {
                                    const ee = await Promise.all([S.orientationX, S.orientationY, S.orientationZ, S.positionX, S.positionY, S.positionZ].map(async (te, oe) => {
                                        const q = n(G, {
                                            channelCount: 1,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            offset: oe === 0 ? 1 : 0
                                        });
                                        return await f(G, te, q.offset),
                                        q
                                    }
                                    ));
                                    for (let te = 0; te < 6; te += 1)
                                        ee[te].connect(K, 0, te),
                                        ee[te].start(0);
                                    return p(G)
                                }
                                )()
                            }
                            const D = await v
                              , U = i(E, {
                                ...T,
                                gain: 1
                            });
                            await d(S, E, U);
                            const z = [];
                            for (let G = 0; G < D.numberOfChannels; G += 1)
                                z.push(D.getChannelData(G));
                            let I = [z[0][0], z[1][0], z[2][0]]
                              , V = [z[3][0], z[4][0], z[5][0]]
                              , B = i(E, {
                                ...T,
                                gain: 1
                            })
                              , P = a(E, {
                                ...R,
                                orientationX: I[0],
                                orientationY: I[1],
                                orientationZ: I[2],
                                positionX: V[0],
                                positionY: V[1],
                                positionZ: V[2]
                            });
                            U.connect(B).connect(P.inputs[0]),
                            P.connect(w);
                            for (let G = 128; G < D.length; G += 128) {
                                const K = [z[0][G], z[1][G], z[2][G]]
                                  , ee = [z[3][G], z[4][G], z[5][G]];
                                if (K.some( (te, oe) => te !== I[oe]) || ee.some( (te, oe) => te !== V[oe])) {
                                    I = K,
                                    V = ee;
                                    const te = G / E.sampleRate;
                                    B.gain.setValueAtTime(0, te),
                                    B = i(E, {
                                        ...T,
                                        gain: 0
                                    }),
                                    P = a(E, {
                                        ...R,
                                        orientationX: I[0],
                                        orientationY: I[1],
                                        orientationZ: I[2],
                                        positionX: V[0],
                                        positionY: V[1],
                                        positionZ: V[2]
                                    }),
                                    B.gain.setValueAtTime(1, te),
                                    U.connect(B).connect(P.inputs[0]),
                                    P.connect(w)
                                }
                            }
                            return w
                        }
                        return N ? (await t(E, S.orientationX, A.orientationX),
                        await t(E, S.orientationY, A.orientationY),
                        await t(E, S.orientationZ, A.orientationZ),
                        await t(E, S.positionX, A.positionX),
                        await t(E, S.positionY, A.positionY),
                        await t(E, S.positionZ, A.positionZ)) : (await f(E, S.orientationX, A.orientationX),
                        await f(E, S.orientationY, A.orientationY),
                        await f(E, S.orientationZ, A.orientationZ),
                        await f(E, S.positionX, A.positionX),
                        await f(E, S.positionY, A.positionY),
                        await f(E, S.positionZ, A.positionZ)),
                        gp(A) ? await d(S, E, A.inputs[0]) : await d(S, E, A),
                        A
                    }
                    ;
                    return {
                        render(S, E) {
                            const w = g.get(E);
                            return w !== void 0 ? Promise.resolve(w) : y(S, E)
                        }
                    }
                }
                  , E6 = {
                    disableNormalization: !1
                }
                  , C6 = (t, e, n, i) => class WR {
                    constructor(o, u) {
                        const f = t(e(o), i({
                            ...E6,
                            ...u
                        }));
                        return n.add(f),
                        f
                    }
                    static[Symbol.hasInstance](o) {
                        return o !== null && typeof o == "object" && Object.getPrototypeOf(o) === WR.prototype || n.has(o)
                    }
                }
                  , w6 = (t, e) => (n, i, a) => (t(i).replay(a),
                e(i, n, a))
                  , R6 = (t, e, n) => async (i, a, o) => {
                    const u = t(i);
                    await Promise.all(u.activeInputs.map( (f, d) => Array.from(f).map(async ([p,g]) => {
                        const v = await e(p).render(p, a)
                          , y = i.context.destination;
                        !n(p) && (i !== y || !n(i)) && v.connect(o, g, d)
                    }
                    )).reduce( (f, d) => [...f, ...d], []))
                }
                  , N6 = (t, e, n) => async (i, a, o) => {
                    const u = e(i);
                    await Promise.all(Array.from(u.activeInputs).map(async ([f,d]) => {
                        const p = await t(f).render(f, a);
                        n(f) || p.connect(o, d)
                    }
                    ))
                }
                  , D6 = (t, e, n, i) => a => t(Qh, () => Qh(a)) ? Promise.resolve(t(i, i)).then(o => {
                    if (!o) {
                        const u = n(a, 512, 0, 1);
                        a.oncomplete = () => {
                            u.onaudioprocess = null,
                            u.disconnect()
                        }
                        ,
                        u.onaudioprocess = () => a.currentTime,
                        u.connect(a.destination)
                    }
                    return a.startRendering()
                }
                ) : new Promise(o => {
                    const u = e(a, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    a.oncomplete = f => {
                        u.disconnect(),
                        o(f.renderedBuffer)
                    }
                    ,
                    u.connect(a.destination),
                    a.startRendering()
                }
                )
                  , O6 = t => (e, n) => {
                    t.set(e, n)
                }
                  , U6 = t => (e, n) => t.set(e, n)
                  , L6 = (t, e, n, i, a, o, u, f) => (d, p) => n(d).render(d, p).then( () => Promise.all(Array.from(i(p)).map(g => n(g).render(g, p)))).then( () => a(p)).then(g => (typeof g.copyFromChannel != "function" ? (u(g),
                zb(g)) : e(o, () => o(g)) || f(g),
                t.add(g),
                g))
                  , I6 = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    pan: 0
                }
                  , z6 = (t, e, n, i, a, o) => class extends t {
                    constructor(f, d) {
                        const p = a(f)
                          , g = n(p, {
                            ...I6,
                            ...d
                        })
                          , v = o(p)
                          , y = v ? i() : null;
                        super(f, !1, g, y),
                        this._pan = e(this, v, g.pan)
                    }
                    get pan() {
                        return this._pan
                    }
                }
                  , B6 = (t, e, n, i, a) => () => {
                    const o = new WeakMap
                      , u = async (f, d) => {
                        let p = n(f);
                        const g = js(p, d);
                        return g || (p = e(d, {
                            channelCount: p.channelCount,
                            channelCountMode: p.channelCountMode,
                            channelInterpretation: p.channelInterpretation,
                            pan: p.pan.value
                        })),
                        o.set(d, p),
                        g ? await t(d, f.pan, p.pan) : await i(d, f.pan, p.pan),
                        gp(p) ? await a(f, d, p.inputs[0]) : await a(f, d, p),
                        p
                    }
                    ;
                    return {
                        render(f, d) {
                            const p = o.get(d);
                            return p !== void 0 ? Promise.resolve(p) : u(f, d)
                        }
                    }
                }
                  , P6 = t => () => {
                    if (t === null)
                        return !1;
                    try {
                        new t({
                            length: 1,
                            sampleRate: 44100
                        })
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , V6 = (t, e) => async () => {
                    if (t === null)
                        return !0;
                    if (e === null)
                        return !1;
                    const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{
                        type: "application/javascript; charset=utf-8"
                    })
                      , i = new e(1,128,44100)
                      , a = URL.createObjectURL(n);
                    let o = !1
                      , u = !1;
                    try {
                        await i.audioWorklet.addModule(a);
                        const f = new t(i,"a",{
                            numberOfOutputs: 0
                        })
                          , d = i.createOscillator();
                        f.port.onmessage = () => o = !0,
                        f.onprocessorerror = () => u = !0,
                        d.connect(f),
                        d.start(0),
                        await i.startRendering(),
                        await new Promise(p => setTimeout(p))
                    } catch {} finally {
                        URL.revokeObjectURL(a)
                    }
                    return o && !u
                }
                  , F6 = (t, e) => () => {
                    if (e === null)
                        return Promise.resolve(!1);
                    const n = new e(1,1,44100)
                      , i = t(n, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    return new Promise(a => {
                        n.oncomplete = () => {
                            i.disconnect(),
                            a(n.currentTime !== 0)
                        }
                        ,
                        n.startRendering()
                    }
                    )
                }
                  , nw = () => new DOMException("","UnknownError")
                  , H6 = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    curve: null,
                    oversample: "none"
                }
                  , G6 = (t, e, n, i, a, o, u) => class extends t {
                    constructor(d, p) {
                        const g = a(d)
                          , v = n(g, {
                            ...H6,
                            ...p
                        })
                          , y = o(g) ? i() : null;
                        super(d, !0, v, y),
                        this._isCurveNullified = !1,
                        this._nativeWaveShaperNode = v,
                        u(this, 1)
                    }
                    get curve() {
                        return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve
                    }
                    set curve(d) {
                        if (d === null)
                            this._isCurveNullified = !0,
                            this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
                        else {
                            if (d.length < 2)
                                throw e();
                            this._isCurveNullified = !1,
                            this._nativeWaveShaperNode.curve = d
                        }
                    }
                    get oversample() {
                        return this._nativeWaveShaperNode.oversample
                    }
                    set oversample(d) {
                        this._nativeWaveShaperNode.oversample = d
                    }
                }
                  , k6 = (t, e, n) => () => {
                    const i = new WeakMap
                      , a = async (o, u) => {
                        let f = e(o);
                        return js(f, u) || (f = t(u, {
                            channelCount: f.channelCount,
                            channelCountMode: f.channelCountMode,
                            channelInterpretation: f.channelInterpretation,
                            curve: f.curve,
                            oversample: f.oversample
                        })),
                        i.set(u, f),
                        gp(f) ? await n(o, u, f.inputs[0]) : await n(o, u, f),
                        f
                    }
                    ;
                    return {
                        render(o, u) {
                            const f = i.get(u);
                            return f !== void 0 ? Promise.resolve(f) : a(o, u)
                        }
                    }
                }
                  , q6 = () => typeof window > "u" ? null : window
                  , X6 = (t, e) => n => {
                    n.copyFromChannel = (i, a, o=0) => {
                        const u = t(o)
                          , f = t(a);
                        if (f >= n.numberOfChannels)
                            throw e();
                        const d = n.length
                          , p = n.getChannelData(f)
                          , g = i.length;
                        for (let v = u < 0 ? -u : 0; v + u < d && v < g; v += 1)
                            i[v] = p[v + u]
                    }
                    ,
                    n.copyToChannel = (i, a, o=0) => {
                        const u = t(o)
                          , f = t(a);
                        if (f >= n.numberOfChannels)
                            throw e();
                        const d = n.length
                          , p = n.getChannelData(f)
                          , g = i.length;
                        for (let v = u < 0 ? -u : 0; v + u < d && v < g; v += 1)
                            p[v + u] = i[v]
                    }
                }
                  , W6 = t => e => {
                    e.copyFromChannel = (n => (i, a, o=0) => {
                        const u = t(o)
                          , f = t(a);
                        if (u < e.length)
                            return n.call(e, i, f, u)
                    }
                    )(e.copyFromChannel),
                    e.copyToChannel = (n => (i, a, o=0) => {
                        const u = t(o)
                          , f = t(a);
                        if (u < e.length)
                            return n.call(e, i, f, u)
                    }
                    )(e.copyToChannel)
                }
                  , Y6 = t => (e, n) => {
                    const i = n.createBuffer(1, 1, 44100);
                    e.buffer === null && (e.buffer = i),
                    t(e, "buffer", a => () => {
                        const o = a.call(e);
                        return o === i ? null : o
                    }
                    , a => o => a.call(e, o === null ? i : o))
                }
                  , j6 = (t, e) => (n, i) => {
                    i.channelCount = 1,
                    i.channelCountMode = "explicit",
                    Object.defineProperty(i, "channelCount", {
                        get: () => 1,
                        set: () => {
                            throw t()
                        }
                    }),
                    Object.defineProperty(i, "channelCountMode", {
                        get: () => "explicit",
                        set: () => {
                            throw t()
                        }
                    });
                    const a = n.createBufferSource();
                    e(i, () => {
                        const f = i.numberOfInputs;
                        for (let d = 0; d < f; d += 1)
                            a.connect(i, 0, d)
                    }
                    , () => a.disconnect(i))
                }
                  , iw = (t, e, n) => t.copyFromChannel === void 0 ? t.getChannelData(n)[0] : (t.copyFromChannel(e, n),
                e[0])
                  , sw = t => {
                    if (t === null)
                        return !1;
                    const e = t.length;
                    return e % 2 !== 0 ? t[Math.floor(e / 2)] !== 0 : t[e / 2 - 1] + t[e / 2] !== 0
                }
                  , ov = (t, e, n, i) => {
                    let a = t;
                    for (; !a.hasOwnProperty(e); )
                        a = Object.getPrototypeOf(a);
                    const {get: o, set: u} = Object.getOwnPropertyDescriptor(a, e);
                    Object.defineProperty(t, e, {
                        get: n(o),
                        set: i(u)
                    })
                }
                  , Z6 = t => ({
                    ...t,
                    outputChannelCount: t.outputChannelCount !== void 0 ? t.outputChannelCount : t.numberOfInputs === 1 && t.numberOfOutputs === 1 ? [t.channelCount] : Array.from({
                        length: t.numberOfOutputs
                    }, () => 1)
                })
                  , Q6 = t => ({
                    ...t,
                    channelCount: t.numberOfOutputs
                })
                  , K6 = t => {
                    const {imag: e, real: n} = t;
                    return e === void 0 ? n === void 0 ? {
                        ...t,
                        imag: [0, 0],
                        real: [0, 0]
                    } : {
                        ...t,
                        imag: Array.from(n, () => 0),
                        real: n
                    } : n === void 0 ? {
                        ...t,
                        imag: e,
                        real: Array.from(e, () => 0)
                    } : {
                        ...t,
                        imag: e,
                        real: n
                    }
                }
                  , aw = (t, e, n) => {
                    try {
                        t.setValueAtTime(e, n)
                    } catch (i) {
                        if (i.code !== 9)
                            throw i;
                        aw(t, e, n + 1e-7)
                    }
                }
                  , J6 = t => {
                    const e = t.createBufferSource();
                    e.start();
                    try {
                        e.start()
                    } catch {
                        return !0
                    }
                    return !1
                }
                  , $6 = t => {
                    const e = t.createBufferSource();
                    e.buffer = t.createBuffer(1, 1, 44100);
                    try {
                        e.start(0, 1)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , eV = t => {
                    const e = t.createBufferSource();
                    e.start();
                    try {
                        e.stop()
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , kb = t => {
                    const e = t.createOscillator();
                    try {
                        e.start(-1)
                    } catch (n) {
                        return n instanceof RangeError
                    }
                    return !1
                }
                  , rw = t => {
                    const e = t.createBuffer(1, 1, 44100)
                      , n = t.createBufferSource();
                    n.buffer = e,
                    n.start(),
                    n.stop();
                    try {
                        return n.stop(),
                        !0
                    } catch {
                        return !1
                    }
                }
                  , qb = t => {
                    const e = t.createOscillator();
                    try {
                        e.stop(-1)
                    } catch (n) {
                        return n instanceof RangeError
                    }
                    return !1
                }
                  , tV = t => {
                    const {port1: e, port2: n} = new MessageChannel;
                    try {
                        e.postMessage(t)
                    } finally {
                        e.close(),
                        n.close()
                    }
                }
                  , nV = t => {
                    t.start = (e => (n=0, i=0, a) => {
                        const o = t.buffer
                          , u = o === null ? i : Math.min(o.duration, i);
                        o !== null && u > o.duration - .5 / t.context.sampleRate ? e.call(t, n, 0, 0) : e.call(t, n, u, a)
                    }
                    )(t.start)
                }
                  , ow = (t, e) => {
                    const n = e.createGain();
                    t.connect(n);
                    const i = (a => () => {
                        a.call(t, n),
                        t.removeEventListener("ended", i)
                    }
                    )(t.disconnect);
                    t.addEventListener("ended", i),
                    vp(t, n),
                    t.stop = (a => {
                        let o = !1;
                        return (u=0) => {
                            if (o)
                                try {
                                    a.call(t, u)
                                } catch {
                                    n.gain.setValueAtTime(0, u)
                                }
                            else
                                a.call(t, u),
                                o = !0
                        }
                    }
                    )(t.stop)
                }
                  , _p = (t, e) => n => {
                    const i = {
                        value: t
                    };
                    return Object.defineProperties(n, {
                        currentTarget: i,
                        target: i
                    }),
                    typeof e == "function" ? e.call(t, n) : e.handleEvent.call(t, n)
                }
                ;
                var Kh = R2();
                const iV = MB(jh)
                  , sV = wB(jh)
                  , aV = V5(Ky)
                  , lw = new WeakMap
                  , rV = iP(lw)
                  , Vr = m5(new Map, new WeakMap)
                  , gl = q6()
                  , cw = zP(Vr, ml)
                  , Xb = nP(xa)
                  , Es = R6(xa, Xb, Zh)
                  , oV = UB(cw, pi, Es)
                  , li = rP(Qy)
                  , fc = c6(gl)
                  , Jn = bP(fc)
                  , uw = new WeakMap
                  , hw = Z5(_p)
                  , yp = FP(gl)
                  , Wb = yP(yp)
                  , Yb = SP(gl)
                  , fw = xP(gl)
                  , lv = GP(gl)
                  , Hi = i5(bB(N2), CB(iV, sV, tS, aV, nS, xa, rV, ev, pi, jh, hc, Zh, iS), Vr, pP(Ob, nS, xa, pi, sv, hc), ml, lS, Zs, I5(tS, Ob, xa, pi, sv, li, hc, Jn), G5(uw, xa, Mo), hw, li, Wb, Yb, fw, Jn, lv)
                  , lV = OB(Hi, oV, ml, cw, li, Jn)
                  , jb = new WeakSet
                  , dw = BP(gl)
                  , pw = w5(new Uint32Array(1))
                  , Zb = X6(pw, ml)
                  , Qb = W6(pw)
                  , mw = IB(jb, Vr, Zs, dw, fc, P6(dw), Zb, Qb)
                  , cS = RB(Ha)
                  , gw = N6(Xb, nv, Zh)
                  , vl = M5(gw)
                  , Sp = VP(cS, Vr, J6, $6, eV, kb, rw, qb, nV, Y6(ov), ow)
                  , _l = w6(sP(nv), gw)
                  , cV = PB(vl, Sp, pi, _l, Es)
                  , bo = s5(TB(D2), uw, Db, a5, Kh.createCancelAndHoldAutomationEvent, Kh.createCancelScheduledValuesAutomationEvent, Kh.createExponentialRampToValueAutomationEvent, Kh.createLinearRampToValueAutomationEvent, Kh.createSetTargetAutomationEvent, Kh.createSetValueAutomationEvent, Kh.createSetValueCurveAutomationEvent, yp, aw)
                  , uV = BB(Hi, cV, bo, $i, Sp, li, Jn, _p)
                  , hV = WB(Hi, YB, ml, $i, HP(Ha, ov), li, Jn, Es)
                  , fV = p5(vl, $2, pi, _l, Es)
                  , Jh = U6(lw)
                  , dV = d5(Hi, bo, fV, lS, $2, li, Jn, Jh)
                  , _u = LP(jh, Yb)
                  , yu = ZP(yp, j6($i, _u))
                  , pV = v5(Hi, _5(yu, pi, Es), yu, li, Jn)
                  , mV = S5(Hi, x5(av, pi, Es), av, li, Jn, Q6)
                  , xp = KP(cS, Vr, JP(cS, Sp, Ha, _u), kb, qb)
                  , gV = E5(Hi, bo, C5(vl, xp, pi, _l, Es), xp, li, Jn, _p)
                  , vw = $P(Zs, ov)
                  , vV = N5(Hi, D5(vw, pi, Es), vw, li, Jn, Jh)
                  , _V = B5(Hi, bo, P5(vl, ew, pi, _l, Es), ew, li, Jn, Jh)
                  , _w = e6(Zs)
                  , yV = X5(Hi, bo, W5(vl, _w, pi, _l, Es), _w, Zs, li, Jn, Jh)
                  , SV = $5(Hi, bo, eP(vl, Ha, pi, _l, Es), Ha, li, Jn)
                  , xV = s6(lS, $i, rv, Zs)
                  , uS = D6(Vr, Ha, rv, F6(Ha, fc))
                  , MV = dP(Sp, pi, fc, Es, uS)
                  , bV = hP(Hi, t6(xV), MV, li, Jn, Jh)
                  , TV = jB(bo, yu, xp, rv, Zs, iw, Jn, ov)
                  , yw = new WeakMap
                  , Kb = DP(hV, TV, hw, Jn, yw, _p)
                  , Sw = u6(cS, Vr, kb, rw, qb, ow)
                  , AV = x6(Hi, bo, Sw, M6(vl, Sw, pi, _l, Es), li, Jn, _p)
                  , xw = T5(Sp)
                  , hS = g6(xw, $i, v6(xw, $i, Ha, sw, _u), sw, _u, yp, ov)
                  , Mw = h6(f6(tS, $i, yu, Ha, rv, hS, Zs, nS, iw, _u))
                  , EV = T6(Hi, bo, Mw, A6(vl, yu, xp, Ha, Mw, pi, fc, _l, Es, uS), li, Jn, Jh)
                  , CV = C6(d6(ml), li, new WeakSet, K6)
                  , bw = p6(m6(yu, av, Ha, hS, Zs, _u), Zs)
                  , wV = z6(Hi, bo, bw, B6(vl, bw, pi, _l, Es), li, Jn)
                  , RV = G6(Hi, $i, hS, k6(hS, pi, Es), li, Jn, Jh)
                  , Tw = TP(gl)
                  , Jb = Q5(gl)
                  , Aw = new WeakMap
                  , NV = oP(Aw, fc)
                  , DV = Tw ? EB(Vr, Zs, j5(gl), Jb, K5(xB), li, NV, Jn, lv, new WeakMap, new WeakMap, V6(lv, fc), gl) : void 0
                  , OV = MP(Wb, Jn)
                  , UV = L5(jb, Vr, U5, Y5, new WeakSet, li, OV, Jy, Qh, Zb, Qb)
                  , Ew = h5(DV, lV, mw, uV, dV, pV, mV, gV, vV, UV, _V, yV, SV, bV, Kb, AV, EV, CV, wV, RV)
                  , LV = AP(Hi, a6, li, Jn)
                  , IV = CP(Hi, r6, li, Jn)
                  , zV = wP(Hi, o6, li, Jn)
                  , BV = RP(Hi, l6($i, Jn), li)
                  , PV = XB(Ew, $i, Zs, nw, LV, IV, zV, BV, yp)
                  , $b = lP(yw)
                  , VV = NB($b)
                  , Cw = b5(ml)
                  , FV = F5($b)
                  , ww = k5(ml)
                  , Rw = new WeakMap
                  , HV = qP($i, jP(Cw, ml, $i, yu, av, xp, Ha, rv, Zs, ww, Jb, tP(Rw, Mo), _u), Ha, Zs, _u)
                  , GV = u5(vl, Cw, Sp, yu, av, xp, Ha, FV, ww, Jb, pi, lv, fc, _l, Es, uS)
                  , kV = aP(Aw)
                  , qV = O6(Rw)
                  , Nw = Tw ? o5(VV, Hi, bo, GV, HV, xa, kV, li, Jn, lv, Z6, qV, tV, _p) : void 0
                  , F8 = NP($i, Zs, nw, Kb, yp)
                  , Dw = O5(Zs, fc)
                  , Ow = L6(jb, Vr, Xb, $b, uS, Jy, Zb, Qb)
                  , H8 = UP(Vr, $i, Dw, Kb, Ow)
                  , XV = y6(Ew, Vr, $i, Dw, Ow)
                  , WV = mP(Qy, Wb)
                  , YV = gP(Nb, Yb)
                  , jV = vP(Db, fw)
                  , ZV = _P(Qy, Jn);
                function Fr(t) {
                    return t === void 0
                }
                function Mn(t) {
                    return t !== void 0
                }
                function QV(t) {
                    return typeof t == "function"
                }
                function Su(t) {
                    return typeof t == "number"
                }
                function $h(t) {
                    return Object.prototype.toString.call(t) === "[object Object]" && t.constructor === Object
                }
                function KV(t) {
                    return typeof t == "boolean"
                }
                function or(t) {
                    return Array.isArray(t)
                }
                function dc(t) {
                    return typeof t == "string"
                }
                function fS(t) {
                    return dc(t) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t)
                }
                function kt(t, e) {
                    if (!t)
                        throw new Error(e)
                }
                function Hr(t, e, n=1 / 0) {
                    if (!(e <= t && t <= n))
                        throw new RangeError(`Value must be within [${e}, ${n}], got: ${t}`)
                }
                function Uw(t) {
                    !t.isOffline && t.state !== "running" && dS('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')
                }
                let Lw = !1
                  , Iw = !1;
                function zw(t) {
                    Lw = t
                }
                function JV(t) {
                    Fr(t) && Lw && !Iw && (Iw = !0,
                    dS("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"))
                }
                let Bw = console;
                function $V(...t) {
                    Bw.log(...t)
                }
                function dS(...t) {
                    Bw.warn(...t)
                }
                function eF(t) {
                    return new PV(t)
                }
                function tF(t, e, n) {
                    return new XV(t,e,n)
                }
                const lr = typeof self == "object" ? self : null
                  , nF = lr && (lr.hasOwnProperty("AudioContext") || lr.hasOwnProperty("webkitAudioContext"));
                function iF(t, e, n) {
                    return kt(Mn(Nw), "AudioWorkletNode only works in a secure context (https or localhost)"),
                    new (t instanceof lr?.BaseAudioContext ? lr?.AudioWorkletNode : Nw)(t,e,n)
                }
                function To(t, e, n, i) {
                    var a = arguments.length, o = a < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, n) : i, u;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        o = Reflect.decorate(t, e, n, i);
                    else
                        for (var f = t.length - 1; f >= 0; f--)
                            (u = t[f]) && (o = (a < 3 ? u(o) : a > 3 ? u(e, n, o) : u(e, n)) || o);
                    return a > 3 && o && Object.defineProperty(e, n, o),
                    o
                }
                function Gi(t, e, n, i) {
                    function a(o) {
                        return o instanceof n ? o : new n(function(u) {
                            u(o)
                        }
                        )
                    }
                    return new (n || (n = Promise))(function(o, u) {
                        function f(g) {
                            try {
                                p(i.next(g))
                            } catch (v) {
                                u(v)
                            }
                        }
                        function d(g) {
                            try {
                                p(i.throw(g))
                            } catch (v) {
                                u(v)
                            }
                        }
                        function p(g) {
                            g.done ? o(g.value) : a(g.value).then(f, d)
                        }
                        p((i = i.apply(t, e || [])).next())
                    }
                    )
                }
                var sF = class {
                    constructor(t, e, n, i) {
                        this._callback = t,
                        this._type = e,
                        this._minimumUpdateInterval = Math.max(128 / (i || 44100), .001),
                        this.updateInterval = n,
                        this._createClock()
                    }
                    _createWorker() {
                        const t = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`],{
                            type: "text/javascript"
                        })
                          , e = URL.createObjectURL(t)
                          , n = new Worker(e);
                        n.onmessage = this._callback.bind(this),
                        this._worker = n
                    }
                    _createTimeout() {
                        this._timeout = setTimeout( () => {
                            this._createTimeout(),
                            this._callback()
                        }
                        , this._updateInterval * 1e3)
                    }
                    _createClock() {
                        if (this._type === "worker")
                            try {
                                this._createWorker()
                            } catch {
                                this._type = "timeout",
                                this._createClock()
                            }
                        else
                            this._type === "timeout" && this._createTimeout()
                    }
                    _disposeClock() {
                        this._timeout && clearTimeout(this._timeout),
                        this._worker && (this._worker.terminate(),
                        this._worker.onmessage = null)
                    }
                    get updateInterval() {
                        return this._updateInterval
                    }
                    set updateInterval(t) {
                        var e;
                        this._updateInterval = Math.max(t, this._minimumUpdateInterval),
                        this._type === "worker" && ((e = this._worker) === null || e === void 0 || e.postMessage(this._updateInterval * 1e3))
                    }
                    get type() {
                        return this._type
                    }
                    set type(t) {
                        this._disposeClock(),
                        this._type = t,
                        this._createClock()
                    }
                    dispose() {
                        this._disposeClock()
                    }
                }
                ;
                function ef(t) {
                    return jV(t)
                }
                function xu(t) {
                    return YV(t)
                }
                function pS(t) {
                    return ZV(t)
                }
                function Mp(t) {
                    return WV(t)
                }
                function aF(t) {
                    return t instanceof mw
                }
                function rF(t, e) {
                    return t === "value" || ef(e) || xu(e) || aF(e)
                }
                function tf(t, ...e) {
                    if (!e.length)
                        return t;
                    const n = e.shift();
                    if ($h(t) && $h(n))
                        for (const i in n)
                            rF(i, n[i]) ? t[i] = n[i] : $h(n[i]) ? (t[i] || Object.assign(t, {
                                [i]: {}
                            }),
                            tf(t[i], n[i])) : Object.assign(t, {
                                [i]: n[i]
                            });
                    return tf(t, ...e)
                }
                function oF(t, e) {
                    return t.length === e.length && t.every( (n, i) => e[i] === n)
                }
                function Xt(t, e, n=[], i) {
                    const a = {}
                      , o = Array.from(e);
                    if ($h(o[0]) && i && !Reflect.has(o[0], i) && (Object.keys(o[0]).some(u => Reflect.has(t, u)) || (tf(a, {
                        [i]: o[0]
                    }),
                    n.splice(n.indexOf(i), 1),
                    o.shift())),
                    o.length === 1 && $h(o[0]))
                        tf(a, o[0]);
                    else
                        for (let u = 0; u < n.length; u++)
                            Mn(o[u]) && (a[n[u]] = o[u]);
                    return tf(t, a)
                }
                function lF(t) {
                    return t.constructor.getDefaults()
                }
                function bp(t, e) {
                    return Fr(t) ? e : t
                }
                function eT(t, e) {
                    return e.forEach(n => {
                        Reflect.has(t, n) && delete t[n]
                    }
                    ),
                    t
                }
                var pc = class {
                    constructor() {
                        this.debug = !1,
                        this._wasDisposed = !1
                    }
                    static getDefaults() {
                        return {}
                    }
                    log(...t) {
                        (this.debug || lr && this.toString() === lr.TONE_DEBUG_CLASS) && $V(this, ...t)
                    }
                    dispose() {
                        return this._wasDisposed = !0,
                        this
                    }
                    get disposed() {
                        return this._wasDisposed
                    }
                    toString() {
                        return this.name
                    }
                }
                ;
                pc.version = Rb;
                const tT = 1e-6;
                function Tp(t, e) {
                    return t > e + tT
                }
                function nT(t, e) {
                    return Tp(t, e) || Ao(t, e)
                }
                function mS(t, e) {
                    return t + tT < e
                }
                function Ao(t, e) {
                    return Math.abs(t - e) < tT
                }
                function cF(t, e, n) {
                    return Math.max(Math.min(t, n), e)
                }
                var yl = class YR extends pc {
                    constructor() {
                        super(),
                        this.name = "Timeline",
                        this._timeline = [];
                        const e = Xt(YR.getDefaults(), arguments, ["memory"]);
                        this.memory = e.memory,
                        this.increasing = e.increasing
                    }
                    static getDefaults() {
                        return {
                            memory: 1 / 0,
                            increasing: !1
                        }
                    }
                    get length() {
                        return this._timeline.length
                    }
                    add(e) {
                        if (kt(Reflect.has(e, "time"), "Timeline: events must have a time attribute"),
                        e.time = e.time.valueOf(),
                        this.increasing && this.length) {
                            const n = this._timeline[this.length - 1];
                            kt(nT(e.time, n.time), "The time must be greater than or equal to the last scheduled time"),
                            this._timeline.push(e)
                        } else {
                            const n = this._search(e.time);
                            this._timeline.splice(n + 1, 0, e)
                        }
                        if (this.length > this.memory) {
                            const n = this.length - this.memory;
                            this._timeline.splice(0, n)
                        }
                        return this
                    }
                    remove(e) {
                        const n = this._timeline.indexOf(e);
                        return n !== -1 && this._timeline.splice(n, 1),
                        this
                    }
                    get(e, n="time") {
                        const i = this._search(e, n);
                        return i !== -1 ? this._timeline[i] : null
                    }
                    peek() {
                        return this._timeline[0]
                    }
                    shift() {
                        return this._timeline.shift()
                    }
                    getAfter(e, n="time") {
                        const i = this._search(e, n);
                        return i + 1 < this._timeline.length ? this._timeline[i + 1] : null
                    }
                    getBefore(e) {
                        const n = this._timeline.length;
                        if (n > 0 && this._timeline[n - 1].time < e)
                            return this._timeline[n - 1];
                        const i = this._search(e);
                        return i - 1 >= 0 ? this._timeline[i - 1] : null
                    }
                    cancel(e) {
                        if (this._timeline.length > 1) {
                            let n = this._search(e);
                            if (n >= 0)
                                if (Ao(this._timeline[n].time, e)) {
                                    for (let i = n; i >= 0 && Ao(this._timeline[i].time, e); i--)
                                        n = i;
                                    this._timeline = this._timeline.slice(0, n)
                                } else
                                    this._timeline = this._timeline.slice(0, n + 1);
                            else
                                this._timeline = []
                        } else
                            this._timeline.length === 1 && nT(this._timeline[0].time, e) && (this._timeline = []);
                        return this
                    }
                    cancelBefore(e) {
                        const n = this._search(e);
                        return n >= 0 && (this._timeline = this._timeline.slice(n + 1)),
                        this
                    }
                    previousEvent(e) {
                        const n = this._timeline.indexOf(e);
                        return n > 0 ? this._timeline[n - 1] : null
                    }
                    _search(e, n="time") {
                        if (this._timeline.length === 0)
                            return -1;
                        let i = 0;
                        const a = this._timeline.length;
                        let o = a;
                        if (a > 0 && this._timeline[a - 1][n] <= e)
                            return a - 1;
                        for (; i < o; ) {
                            let u = Math.floor(i + (o - i) / 2);
                            const f = this._timeline[u]
                              , d = this._timeline[u + 1];
                            if (Ao(f[n], e)) {
                                for (let p = u; p < this._timeline.length; p++) {
                                    const g = this._timeline[p];
                                    if (Ao(g[n], e))
                                        u = p;
                                    else
                                        break
                                }
                                return u
                            } else {
                                if (mS(f[n], e) && Tp(d[n], e))
                                    return u;
                                Tp(f[n], e) ? o = u : i = u + 1
                            }
                        }
                        return -1
                    }
                    _iterate(e, n=0, i=this._timeline.length - 1) {
                        this._timeline.slice(n, i + 1).forEach(e)
                    }
                    forEach(e) {
                        return this._iterate(e),
                        this
                    }
                    forEachBefore(e, n) {
                        const i = this._search(e);
                        return i !== -1 && this._iterate(n, 0, i),
                        this
                    }
                    forEachAfter(e, n) {
                        const i = this._search(e);
                        return this._iterate(n, i + 1),
                        this
                    }
                    forEachBetween(e, n, i) {
                        let a = this._search(e)
                          , o = this._search(n);
                        return a !== -1 && o !== -1 ? (this._timeline[a].time !== e && (a += 1),
                        this._timeline[o].time === n && (o -= 1),
                        this._iterate(i, a, o)) : a === -1 && this._iterate(i, 0, o),
                        this
                    }
                    forEachFrom(e, n) {
                        let i = this._search(e);
                        for (; i >= 0 && this._timeline[i].time >= e; )
                            i--;
                        return this._iterate(n, i + 1),
                        this
                    }
                    forEachAtTime(e, n) {
                        const i = this._search(e);
                        if (i !== -1 && Ao(this._timeline[i].time, e)) {
                            let a = i;
                            for (let o = i; o >= 0 && Ao(this._timeline[o].time, e); o--)
                                a = o;
                            this._iterate(o => {
                                n(o)
                            }
                            , a, i)
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._timeline = [],
                        this
                    }
                }
                ;
                const Pw = [];
                function gS(t) {
                    Pw.push(t)
                }
                function uF(t) {
                    Pw.forEach(e => e(t))
                }
                const Vw = [];
                function vS(t) {
                    Vw.push(t)
                }
                function hF(t) {
                    Vw.forEach(e => e(t))
                }
                var iT = class jR extends pc {
                    constructor() {
                        super(...arguments),
                        this.name = "Emitter"
                    }
                    on(e, n) {
                        return e.split(/\W+/).forEach(i => {
                            Fr(this._events) && (this._events = {}),
                            this._events.hasOwnProperty(i) || (this._events[i] = []),
                            this._events[i].push(n)
                        }
                        ),
                        this
                    }
                    once(e, n) {
                        const i = (...a) => {
                            n(...a),
                            this.off(e, i)
                        }
                        ;
                        return this.on(e, i),
                        this
                    }
                    off(e, n) {
                        return e.split(/\W+/).forEach(i => {
                            if (Fr(this._events) && (this._events = {}),
                            this._events.hasOwnProperty(i))
                                if (Fr(n))
                                    this._events[i] = [];
                                else {
                                    const a = this._events[i];
                                    for (let o = a.length - 1; o >= 0; o--)
                                        a[o] === n && a.splice(o, 1)
                                }
                        }
                        ),
                        this
                    }
                    emit(e, ...n) {
                        if (this._events && this._events.hasOwnProperty(e)) {
                            const i = this._events[e].slice(0);
                            for (let a = 0, o = i.length; a < o; a++)
                                i[a].apply(this, n)
                        }
                        return this
                    }
                    static mixin(e) {
                        ["on", "once", "off", "emit"].forEach(n => {
                            const i = Object.getOwnPropertyDescriptor(jR.prototype, n);
                            Object.defineProperty(e.prototype, n, i)
                        }
                        )
                    }
                    dispose() {
                        return super.dispose(),
                        this._events = void 0,
                        this
                    }
                }
                  , Fw = class extends iT {
                    constructor() {
                        super(...arguments),
                        this.isOffline = !1
                    }
                    toJSON() {
                        return {}
                    }
                }
                  , sT = class ZR extends Fw {
                    constructor() {
                        var e, n;
                        super(),
                        this.name = "Context",
                        this._constants = new Map,
                        this._timeouts = new yl,
                        this._timeoutIds = 0,
                        this._initialized = !1,
                        this._closeStarted = !1,
                        this.isOffline = !1,
                        this._workletPromise = null;
                        const i = Xt(ZR.getDefaults(), arguments, ["context"]);
                        i.context ? (this._context = i.context,
                        this._latencyHint = ((e = arguments[0]) === null || e === void 0 ? void 0 : e.latencyHint) || "") : (this._context = eF({
                            latencyHint: i.latencyHint
                        }),
                        this._latencyHint = i.latencyHint),
                        this._ticker = new sF(this.emit.bind(this, "tick"),i.clockSource,i.updateInterval,this._context.sampleRate),
                        this.on("tick", this._timeoutLoop.bind(this)),
                        this._context.onstatechange = () => {
                            this.emit("statechange", this.state)
                        }
                        ,
                        this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = i.lookAhead
                    }
                    static getDefaults() {
                        return {
                            clockSource: "worker",
                            latencyHint: "interactive",
                            lookAhead: .1,
                            updateInterval: .05
                        }
                    }
                    initialize() {
                        return this._initialized || (uF(this),
                        this._initialized = !0),
                        this
                    }
                    createAnalyser() {
                        return this._context.createAnalyser()
                    }
                    createOscillator() {
                        return this._context.createOscillator()
                    }
                    createBufferSource() {
                        return this._context.createBufferSource()
                    }
                    createBiquadFilter() {
                        return this._context.createBiquadFilter()
                    }
                    createBuffer(e, n, i) {
                        return this._context.createBuffer(e, n, i)
                    }
                    createChannelMerger(e) {
                        return this._context.createChannelMerger(e)
                    }
                    createChannelSplitter(e) {
                        return this._context.createChannelSplitter(e)
                    }
                    createConstantSource() {
                        return this._context.createConstantSource()
                    }
                    createConvolver() {
                        return this._context.createConvolver()
                    }
                    createDelay(e) {
                        return this._context.createDelay(e)
                    }
                    createDynamicsCompressor() {
                        return this._context.createDynamicsCompressor()
                    }
                    createGain() {
                        return this._context.createGain()
                    }
                    createIIRFilter(e, n) {
                        return this._context.createIIRFilter(e, n)
                    }
                    createPanner() {
                        return this._context.createPanner()
                    }
                    createPeriodicWave(e, n, i) {
                        return this._context.createPeriodicWave(e, n, i)
                    }
                    createStereoPanner() {
                        return this._context.createStereoPanner()
                    }
                    createWaveShaper() {
                        return this._context.createWaveShaper()
                    }
                    createMediaStreamSource(e) {
                        return kt(Mp(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaStreamSource(e)
                    }
                    createMediaElementSource(e) {
                        return kt(Mp(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaElementSource(e)
                    }
                    createMediaStreamDestination() {
                        return kt(Mp(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaStreamDestination()
                    }
                    decodeAudioData(e) {
                        return this._context.decodeAudioData(e)
                    }
                    get currentTime() {
                        return this._context.currentTime
                    }
                    get state() {
                        return this._context.state
                    }
                    get sampleRate() {
                        return this._context.sampleRate
                    }
                    get listener() {
                        return this.initialize(),
                        this._listener
                    }
                    set listener(e) {
                        kt(!this._initialized, "The listener cannot be set after initialization."),
                        this._listener = e
                    }
                    get transport() {
                        return this.initialize(),
                        this._transport
                    }
                    set transport(e) {
                        kt(!this._initialized, "The transport cannot be set after initialization."),
                        this._transport = e
                    }
                    get draw() {
                        return this.initialize(),
                        this._draw
                    }
                    set draw(e) {
                        kt(!this._initialized, "Draw cannot be set after initialization."),
                        this._draw = e
                    }
                    get destination() {
                        return this.initialize(),
                        this._destination
                    }
                    set destination(e) {
                        kt(!this._initialized, "The destination cannot be set after initialization."),
                        this._destination = e
                    }
                    createAudioWorkletNode(e, n) {
                        return iF(this.rawContext, e, n)
                    }
                    addAudioWorkletModule(e) {
                        return Gi(this, void 0, void 0, function*() {
                            kt(Mn(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"),
                            this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(e)),
                            yield this._workletPromise
                        })
                    }
                    workletsAreReady() {
                        return Gi(this, void 0, void 0, function*() {
                            (yield this._workletPromise) ? this._workletPromise : Promise.resolve()
                        })
                    }
                    get updateInterval() {
                        return this._ticker.updateInterval
                    }
                    set updateInterval(e) {
                        this._ticker.updateInterval = e
                    }
                    get clockSource() {
                        return this._ticker.type
                    }
                    set clockSource(e) {
                        this._ticker.type = e
                    }
                    get lookAhead() {
                        return this._lookAhead
                    }
                    set lookAhead(e) {
                        this._lookAhead = e,
                        this.updateInterval = e ? e / 2 : .01
                    }
                    get latencyHint() {
                        return this._latencyHint
                    }
                    get rawContext() {
                        return this._context
                    }
                    now() {
                        return this._context.currentTime + this._lookAhead
                    }
                    immediate() {
                        return this._context.currentTime
                    }
                    resume() {
                        return Mp(this._context) ? this._context.resume() : Promise.resolve()
                    }
                    close() {
                        return Gi(this, void 0, void 0, function*() {
                            Mp(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0,
                            yield this._context.close()),
                            this._initialized && hF(this)
                        })
                    }
                    getConstant(e) {
                        if (this._constants.has(e))
                            return this._constants.get(e);
                        {
                            const n = this._context.createBuffer(1, 128, this._context.sampleRate)
                              , i = n.getChannelData(0);
                            for (let o = 0; o < i.length; o++)
                                i[o] = e;
                            const a = this._context.createBufferSource();
                            return a.channelCount = 1,
                            a.channelCountMode = "explicit",
                            a.buffer = n,
                            a.loop = !0,
                            a.start(0),
                            this._constants.set(e, a),
                            a
                        }
                    }
                    dispose() {
                        return super.dispose(),
                        this._ticker.dispose(),
                        this._timeouts.dispose(),
                        Object.keys(this._constants).map(e => this._constants[e].disconnect()),
                        this.close(),
                        this
                    }
                    _timeoutLoop() {
                        const e = this.now();
                        this._timeouts.forEachBefore(e, n => {
                            n.callback(),
                            this._timeouts.remove(n)
                        }
                        )
                    }
                    setTimeout(e, n) {
                        this._timeoutIds++;
                        const i = this.now();
                        return this._timeouts.add({
                            callback: e,
                            id: this._timeoutIds,
                            time: i + n
                        }),
                        this._timeoutIds
                    }
                    clearTimeout(e) {
                        return this._timeouts.forEach(n => {
                            n.id === e && this._timeouts.remove(n)
                        }
                        ),
                        this
                    }
                    clearInterval(e) {
                        return this.clearTimeout(e)
                    }
                    setInterval(e, n) {
                        const i = ++this._timeoutIds
                          , a = () => {
                            const o = this.now();
                            this._timeouts.add({
                                callback: () => {
                                    e(),
                                    a()
                                }
                                ,
                                id: i,
                                time: o + n
                            })
                        }
                        ;
                        return a(),
                        i
                    }
                }
                  , fF = class extends Fw {
                    constructor() {
                        super(...arguments),
                        this.lookAhead = 0,
                        this.latencyHint = 0,
                        this.isOffline = !1
                    }
                    createAnalyser() {
                        return {}
                    }
                    createOscillator() {
                        return {}
                    }
                    createBufferSource() {
                        return {}
                    }
                    createBiquadFilter() {
                        return {}
                    }
                    createBuffer(t, e, n) {
                        return {}
                    }
                    createChannelMerger(t) {
                        return {}
                    }
                    createChannelSplitter(t) {
                        return {}
                    }
                    createConstantSource() {
                        return {}
                    }
                    createConvolver() {
                        return {}
                    }
                    createDelay(t) {
                        return {}
                    }
                    createDynamicsCompressor() {
                        return {}
                    }
                    createGain() {
                        return {}
                    }
                    createIIRFilter(t, e) {
                        return {}
                    }
                    createPanner() {
                        return {}
                    }
                    createPeriodicWave(t, e, n) {
                        return {}
                    }
                    createStereoPanner() {
                        return {}
                    }
                    createWaveShaper() {
                        return {}
                    }
                    createMediaStreamSource(t) {
                        return {}
                    }
                    createMediaElementSource(t) {
                        return {}
                    }
                    createMediaStreamDestination() {
                        return {}
                    }
                    decodeAudioData(t) {
                        return Promise.resolve({})
                    }
                    createAudioWorkletNode(t, e) {
                        return {}
                    }
                    get rawContext() {
                        return {}
                    }
                    addAudioWorkletModule(t) {
                        return Gi(this, void 0, void 0, function*() {
                            return Promise.resolve()
                        })
                    }
                    resume() {
                        return Promise.resolve()
                    }
                    setTimeout(t, e) {
                        return 0
                    }
                    clearTimeout(t) {
                        return this
                    }
                    setInterval(t, e) {
                        return 0
                    }
                    clearInterval(t) {
                        return this
                    }
                    getConstant(t) {
                        return {}
                    }
                    get currentTime() {
                        return 0
                    }
                    get state() {
                        return {}
                    }
                    get sampleRate() {
                        return 0
                    }
                    get listener() {
                        return {}
                    }
                    get transport() {
                        return {}
                    }
                    get draw() {
                        return {}
                    }
                    set draw(t) {}
                    get destination() {
                        return {}
                    }
                    set destination(t) {}
                    now() {
                        return 0
                    }
                    immediate() {
                        return 0
                    }
                }
                ;
                function _i(t, e) {
                    or(e) ? e.forEach(n => _i(t, n)) : Object.defineProperty(t, e, {
                        enumerable: !0,
                        writable: !1
                    })
                }
                function Hw(t, e) {
                    or(e) ? e.forEach(n => Hw(t, n)) : Object.defineProperty(t, e, {
                        writable: !0
                    })
                }
                const Xn = () => {}
                ;
                var Eo = class Qs extends pc {
                    constructor() {
                        super(),
                        this.name = "ToneAudioBuffer",
                        this.onload = Xn;
                        const e = Xt(Qs.getDefaults(), arguments, ["url", "onload", "onerror"]);
                        this.reverse = e.reverse,
                        this.onload = e.onload,
                        dc(e.url) ? this.load(e.url).catch(e.onerror) : e.url && this.set(e.url)
                    }
                    static getDefaults() {
                        return {
                            onerror: Xn,
                            onload: Xn,
                            reverse: !1
                        }
                    }
                    get sampleRate() {
                        return this._buffer ? this._buffer.sampleRate : Co().sampleRate
                    }
                    set(e) {
                        return e instanceof Qs ? e.loaded ? this._buffer = e.get() : e.onload = () => {
                            this.set(e),
                            this.onload(this)
                        }
                        : this._buffer = e,
                        this._reversed && this._reverse(),
                        this
                    }
                    get() {
                        return this._buffer
                    }
                    load(e) {
                        return Gi(this, void 0, void 0, function*() {
                            const n = Qs.load(e).then(i => {
                                this.set(i),
                                this.onload(this)
                            }
                            );
                            Qs.downloads.push(n);
                            try {
                                yield n
                            } finally {
                                const i = Qs.downloads.indexOf(n);
                                Qs.downloads.splice(i, 1)
                            }
                            return this
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffer = void 0,
                        this
                    }
                    fromArray(e) {
                        const n = or(e) && e[0].length > 0
                          , i = n ? e.length : 1
                          , a = n ? e[0].length : e.length
                          , o = Co()
                          , u = o.createBuffer(i, a, o.sampleRate)
                          , f = !n && i === 1 ? [e] : e;
                        for (let d = 0; d < i; d++)
                            u.copyToChannel(f[d], d);
                        return this._buffer = u,
                        this
                    }
                    toMono(e) {
                        if (Su(e))
                            this.fromArray(this.toArray(e));
                        else {
                            let n = new Float32Array(this.length);
                            const i = this.numberOfChannels;
                            for (let a = 0; a < i; a++) {
                                const o = this.toArray(a);
                                for (let u = 0; u < o.length; u++)
                                    n[u] += o[u]
                            }
                            n = n.map(a => a / i),
                            this.fromArray(n)
                        }
                        return this
                    }
                    toArray(e) {
                        if (Su(e))
                            return this.getChannelData(e);
                        if (this.numberOfChannels === 1)
                            return this.toArray(0);
                        {
                            const n = [];
                            for (let i = 0; i < this.numberOfChannels; i++)
                                n[i] = this.getChannelData(i);
                            return n
                        }
                    }
                    getChannelData(e) {
                        return this._buffer ? this._buffer.getChannelData(e) : new Float32Array(0)
                    }
                    slice(e, n=this.duration) {
                        kt(this.loaded, "Buffer is not loaded");
                        const i = Math.floor(e * this.sampleRate)
                          , a = Math.floor(n * this.sampleRate);
                        kt(i < a, "The start time must be less than the end time");
                        const o = a - i
                          , u = Co().createBuffer(this.numberOfChannels, o, this.sampleRate);
                        for (let f = 0; f < this.numberOfChannels; f++)
                            u.copyToChannel(this.getChannelData(f).subarray(i, a), f);
                        return new Qs(u)
                    }
                    _reverse() {
                        if (this.loaded)
                            for (let e = 0; e < this.numberOfChannels; e++)
                                this.getChannelData(e).reverse();
                        return this
                    }
                    get loaded() {
                        return this.length > 0
                    }
                    get duration() {
                        return this._buffer ? this._buffer.duration : 0
                    }
                    get length() {
                        return this._buffer ? this._buffer.length : 0
                    }
                    get numberOfChannels() {
                        return this._buffer ? this._buffer.numberOfChannels : 0
                    }
                    get reverse() {
                        return this._reversed
                    }
                    set reverse(e) {
                        this._reversed !== e && (this._reversed = e,
                        this._reverse())
                    }
                    static fromArray(e) {
                        return new Qs().fromArray(e)
                    }
                    static fromUrl(e) {
                        return Gi(this, void 0, void 0, function*() {
                            return yield new Qs().load(e)
                        })
                    }
                    static load(e) {
                        return Gi(this, void 0, void 0, function*() {
                            const n = Qs.baseUrl === "" || Qs.baseUrl.endsWith("/") ? Qs.baseUrl : Qs.baseUrl + "/"
                              , i = yield fetch(n + e);
                            if (!i.ok)
                                throw new Error(`could not load url: ${e}`);
                            const a = yield i.arrayBuffer();
                            return yield Co().decodeAudioData(a)
                        })
                    }
                    static supportsType(e) {
                        const n = e.split(".")
                          , i = n[n.length - 1];
                        return document.createElement("audio").canPlayType("audio/" + i) !== ""
                    }
                    static loaded() {
                        return Gi(this, void 0, void 0, function*() {
                            for (yield Promise.resolve(); Qs.downloads.length; )
                                yield Qs.downloads[0]
                        })
                    }
                }
                ;
                Eo.baseUrl = "",
                Eo.downloads = [];
                var _S = class extends sT {
                    constructor() {
                        super({
                            clockSource: "offline",
                            context: pS(arguments[0]) ? arguments[0] : tF(arguments[0], arguments[1] * arguments[2], arguments[2]),
                            lookAhead: 0,
                            updateInterval: pS(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
                        }),
                        this.name = "OfflineContext",
                        this._currentTime = 0,
                        this.isOffline = !0,
                        this._duration = pS(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1]
                    }
                    now() {
                        return this._currentTime
                    }
                    get currentTime() {
                        return this._currentTime
                    }
                    _renderClock(t) {
                        return Gi(this, void 0, void 0, function*() {
                            let e = 0;
                            for (; this._duration - this._currentTime >= 0; ) {
                                this.emit("tick"),
                                this._currentTime += 128 / this.sampleRate,
                                e++;
                                const n = Math.floor(this.sampleRate / 128);
                                t && e % n === 0 && (yield new Promise(i => setTimeout(i, 1)))
                            }
                        })
                    }
                    render() {
                        return Gi(this, arguments, void 0, function*(t=!0) {
                            return yield this.workletsAreReady(),
                            yield this._renderClock(t),
                            new Eo(yield this._context.startRendering())
                        })
                    }
                    close() {
                        return Promise.resolve()
                    }
                }
                ;
                const Gw = new fF;
                let nf = Gw;
                function Co() {
                    return nf === Gw && nF && dF(new sT),
                    nf
                }
                function dF(t, e=!1) {
                    e && nf.dispose(),
                    Mp(t) ? nf = new sT(t) : pS(t) ? nf = new _S(t) : nf = t
                }
                function pF() {
                    return nf.resume()
                }
                if (lr && !lr.TONE_SILENCE_LOGGING) {
                    let t = "v";
                    Rb === "dev" && (t = "");
                    const e = ` * Tone.js ${t}${Rb} * `;
                    console.log(`%c${e}`, "background: #000; color: #fff")
                }
                function mF(t) {
                    return Math.pow(10, t / 20)
                }
                function gF(t) {
                    return 20 * (Math.log(t) / Math.LN10)
                }
                function kw(t) {
                    return Math.pow(2, t / 12)
                }
                let yS = 440;
                function vF() {
                    return yS
                }
                function _F(t) {
                    yS = t
                }
                function sf(t) {
                    return Math.round(qw(t))
                }
                function qw(t) {
                    return 69 + 12 * Math.log2(t / yS)
                }
                function Xw(t) {
                    return yS * Math.pow(2, (t - 69) / 12)
                }
                var yF = class QR extends pc {
                    constructor(e, n, i) {
                        super(),
                        this.defaultUnits = "s",
                        this._val = n,
                        this._units = i,
                        this.context = e,
                        this._expressions = this._getExpressions()
                    }
                    _getExpressions() {
                        return {
                            hz: {
                                method: e => this._frequencyToUnits(parseFloat(e)),
                                regexp: /^(\d+(?:\.\d+)?)hz$/i
                            },
                            i: {
                                method: e => this._ticksToUnits(parseInt(e, 10)),
                                regexp: /^(\d+)i$/i
                            },
                            m: {
                                method: e => this._beatsToUnits(parseInt(e, 10) * this._getTimeSignature()),
                                regexp: /^(\d+)m$/i
                            },
                            n: {
                                method: (e, n) => {
                                    const i = parseInt(e, 10)
                                      , a = n === "." ? 1.5 : 1;
                                    return i === 1 ? this._beatsToUnits(this._getTimeSignature()) * a : this._beatsToUnits(4 / i) * a
                                }
                                ,
                                regexp: /^(\d+)n(\.?)$/i
                            },
                            number: {
                                method: e => this._expressions[this.defaultUnits].method.call(this, e),
                                regexp: /^(\d+(?:\.\d+)?)$/
                            },
                            s: {
                                method: e => this._secondsToUnits(parseFloat(e)),
                                regexp: /^(\d+(?:\.\d+)?)s$/
                            },
                            samples: {
                                method: e => parseInt(e, 10) / this.context.sampleRate,
                                regexp: /^(\d+)samples$/
                            },
                            t: {
                                method: e => {
                                    const n = parseInt(e, 10);
                                    return this._beatsToUnits(8 / (Math.floor(n) * 3))
                                }
                                ,
                                regexp: /^(\d+)t$/i
                            },
                            tr: {
                                method: (e, n, i) => {
                                    let a = 0;
                                    return e && e !== "0" && (a += this._beatsToUnits(this._getTimeSignature() * parseFloat(e))),
                                    n && n !== "0" && (a += this._beatsToUnits(parseFloat(n))),
                                    i && i !== "0" && (a += this._beatsToUnits(parseFloat(i) / 4)),
                                    a
                                }
                                ,
                                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
                            }
                        }
                    }
                    valueOf() {
                        if (this._val instanceof QR && this.fromType(this._val),
                        Fr(this._val))
                            return this._noArg();
                        if (dc(this._val) && Fr(this._units)) {
                            for (const e in this._expressions)
                                if (this._expressions[e].regexp.test(this._val.trim())) {
                                    this._units = e;
                                    break
                                }
                        } else if ($h(this._val)) {
                            let e = 0;
                            for (const n in this._val)
                                if (Mn(this._val[n])) {
                                    const i = this._val[n]
                                      , a = new this.constructor(this.context,n).valueOf() * i;
                                    e += a
                                }
                            return e
                        }
                        if (Mn(this._units)) {
                            const e = this._expressions[this._units]
                              , n = this._val.toString().trim().match(e.regexp);
                            return n ? e.method.apply(this, n.slice(1)) : e.method.call(this, this._val)
                        } else
                            return dc(this._val) ? parseFloat(this._val) : this._val
                    }
                    _frequencyToUnits(e) {
                        return 1 / e
                    }
                    _beatsToUnits(e) {
                        return 60 / this._getBpm() * e
                    }
                    _secondsToUnits(e) {
                        return e
                    }
                    _ticksToUnits(e) {
                        return e * this._beatsToUnits(1) / this._getPPQ()
                    }
                    _noArg() {
                        return this._now()
                    }
                    _getBpm() {
                        return this.context.transport.bpm.value
                    }
                    _getTimeSignature() {
                        return this.context.transport.timeSignature
                    }
                    _getPPQ() {
                        return this.context.transport.PPQ
                    }
                    fromType(e) {
                        switch (this._units = void 0,
                        this.defaultUnits) {
                        case "s":
                            this._val = e.toSeconds();
                            break;
                        case "i":
                            this._val = e.toTicks();
                            break;
                        case "hz":
                            this._val = e.toFrequency();
                            break;
                        case "midi":
                            this._val = e.toMidi();
                            break
                        }
                        return this
                    }
                    toFrequency() {
                        return 1 / this.toSeconds()
                    }
                    toSamples() {
                        return this.toSeconds() * this.context.sampleRate
                    }
                    toMilliseconds() {
                        return this.toSeconds() * 1e3
                    }
                }
                  , af = class CS extends yF {
                    constructor() {
                        super(...arguments),
                        this.name = "TimeClass"
                    }
                    _getExpressions() {
                        return Object.assign(super._getExpressions(), {
                            now: {
                                method: e => this._now() + new this.constructor(this.context,e).valueOf(),
                                regexp: /^\+(.+)/
                            },
                            quantize: {
                                method: e => {
                                    const n = new CS(this.context,e).valueOf();
                                    return this._secondsToUnits(this.context.transport.nextSubdivision(n))
                                }
                                ,
                                regexp: /^@(.+)/
                            }
                        })
                    }
                    quantize(e, n=1) {
                        const i = new this.constructor(this.context,e).valueOf()
                          , a = this.valueOf();
                        return a + (Math.round(a / i) * i - a) * n
                    }
                    toNotation() {
                        const e = this.toSeconds()
                          , n = ["1m"];
                        for (let o = 1; o < 9; o++) {
                            const u = Math.pow(2, o);
                            n.push(u + "n."),
                            n.push(u + "n"),
                            n.push(u + "t")
                        }
                        n.push("0");
                        let i = n[0]
                          , a = new CS(this.context,n[0]).toSeconds();
                        return n.forEach(o => {
                            const u = new CS(this.context,o).toSeconds();
                            Math.abs(u - e) < Math.abs(a - e) && (i = o,
                            a = u)
                        }
                        ),
                        i
                    }
                    toBarsBeatsSixteenths() {
                        const e = this._beatsToUnits(1);
                        let n = this.valueOf() / e;
                        n = parseFloat(n.toFixed(4));
                        const i = Math.floor(n / this._getTimeSignature());
                        let a = n % 1 * 4;
                        n = Math.floor(n) % this._getTimeSignature();
                        const o = a.toString();
                        return o.length > 3 && (a = parseFloat(parseFloat(o).toFixed(3))),
                        [i, n, a].join(":")
                    }
                    toTicks() {
                        const e = this._beatsToUnits(1);
                        return this.valueOf() / e * this._getPPQ()
                    }
                    toSeconds() {
                        return this.valueOf()
                    }
                    toMidi() {
                        return sf(this.toFrequency())
                    }
                    _now() {
                        return this.context.now()
                    }
                }
                  , Mu = class dv extends af {
                    constructor() {
                        super(...arguments),
                        this.name = "Frequency",
                        this.defaultUnits = "hz"
                    }
                    static get A4() {
                        return vF()
                    }
                    static set A4(e) {
                        _F(e)
                    }
                    _getExpressions() {
                        return Object.assign({}, super._getExpressions(), {
                            midi: {
                                regexp: /^(\d+(?:\.\d+)?midi)/,
                                method(e) {
                                    return this.defaultUnits === "midi" ? e : dv.mtof(e)
                                }
                            },
                            note: {
                                regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
                                method(e, n) {
                                    const i = SF[e.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
                                    return this.defaultUnits === "midi" ? i : dv.mtof(i)
                                }
                            },
                            tr: {
                                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                                method(e, n, i) {
                                    let a = 1;
                                    return e && e !== "0" && (a *= this._beatsToUnits(this._getTimeSignature() * parseFloat(e))),
                                    n && n !== "0" && (a *= this._beatsToUnits(parseFloat(n))),
                                    i && i !== "0" && (a *= this._beatsToUnits(parseFloat(i) / 4)),
                                    a
                                }
                            }
                        })
                    }
                    transpose(e) {
                        return new dv(this.context,this.valueOf() * kw(e))
                    }
                    harmonize(e) {
                        return e.map(n => this.transpose(n))
                    }
                    toMidi() {
                        return sf(this.valueOf())
                    }
                    toNote() {
                        const e = this.toFrequency()
                          , n = Math.log2(e / dv.A4);
                        let i = Math.round(12 * n) + 57;
                        const a = Math.floor(i / 12);
                        return a < 0 && (i += -12 * a),
                        xF[i % 12] + a.toString()
                    }
                    toSeconds() {
                        return 1 / super.toSeconds()
                    }
                    toTicks() {
                        const e = this._beatsToUnits(1)
                          , n = this.valueOf() / e;
                        return Math.floor(n * this._getPPQ())
                    }
                    _noArg() {
                        return 0
                    }
                    _frequencyToUnits(e) {
                        return e
                    }
                    _ticksToUnits(e) {
                        return 1 / (e * 60 / (this._getBpm() * this._getPPQ()))
                    }
                    _beatsToUnits(e) {
                        return 1 / super._beatsToUnits(e)
                    }
                    _secondsToUnits(e) {
                        return 1 / e
                    }
                    static mtof(e) {
                        return Xw(e)
                    }
                    static ftom(e) {
                        return sf(e)
                    }
                }
                ;
                const SF = {
                    cbbb: -3,
                    cbb: -2,
                    cb: -1,
                    c: 0,
                    "c#": 1,
                    cx: 2,
                    "c##": 2,
                    "c###": 3,
                    "cx#": 3,
                    "c#x": 3,
                    dbbb: -1,
                    dbb: 0,
                    db: 1,
                    d: 2,
                    "d#": 3,
                    dx: 4,
                    "d##": 4,
                    "d###": 5,
                    "dx#": 5,
                    "d#x": 5,
                    ebbb: 1,
                    ebb: 2,
                    eb: 3,
                    e: 4,
                    "e#": 5,
                    ex: 6,
                    "e##": 6,
                    "e###": 7,
                    "ex#": 7,
                    "e#x": 7,
                    fbbb: 2,
                    fbb: 3,
                    fb: 4,
                    f: 5,
                    "f#": 6,
                    fx: 7,
                    "f##": 7,
                    "f###": 8,
                    "fx#": 8,
                    "f#x": 8,
                    gbbb: 4,
                    gbb: 5,
                    gb: 6,
                    g: 7,
                    "g#": 8,
                    gx: 9,
                    "g##": 9,
                    "g###": 10,
                    "gx#": 10,
                    "g#x": 10,
                    abbb: 6,
                    abb: 7,
                    ab: 8,
                    a: 9,
                    "a#": 10,
                    ax: 11,
                    "a##": 11,
                    "a###": 12,
                    "ax#": 12,
                    "a#x": 12,
                    bbbb: 8,
                    bbb: 9,
                    bb: 10,
                    b: 11,
                    "b#": 12,
                    bx: 13,
                    "b##": 13,
                    "b###": 14,
                    "bx#": 14,
                    "b#x": 14
                }
                  , xF = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
                var cv = class extends af {
                    constructor() {
                        super(...arguments),
                        this.name = "TransportTime"
                    }
                    _now() {
                        return this.context.transport.seconds
                    }
                }
                  , Sl = class wS extends pc {
                    constructor() {
                        super();
                        const e = Xt(wS.getDefaults(), arguments, ["context"]);
                        this.defaultContext ? this.context = this.defaultContext : this.context = e.context
                    }
                    static getDefaults() {
                        return {
                            context: Co()
                        }
                    }
                    now() {
                        return this.context.currentTime + this.context.lookAhead
                    }
                    immediate() {
                        return this.context.currentTime
                    }
                    get sampleTime() {
                        return 1 / this.context.sampleRate
                    }
                    get blockTime() {
                        return 128 / this.context.sampleRate
                    }
                    toSeconds(e) {
                        return JV(e),
                        new af(this.context,e).toSeconds()
                    }
                    toFrequency(e) {
                        return new Mu(this.context,e).toFrequency()
                    }
                    toTicks(e) {
                        return new cv(this.context,e).toTicks()
                    }
                    _getPartialProperties(e) {
                        const n = this.get();
                        return Object.keys(n).forEach(i => {
                            Fr(e[i]) && delete n[i]
                        }
                        ),
                        n
                    }
                    get() {
                        const e = lF(this);
                        return Object.keys(e).forEach(n => {
                            if (Reflect.has(this, n)) {
                                const i = this[n];
                                Mn(i) && Mn(i.value) && Mn(i.setValueAtTime) ? e[n] = i.value : i instanceof wS ? e[n] = i._getPartialProperties(e[n]) : or(i) || Su(i) || dc(i) || KV(i) ? e[n] = i : delete e[n]
                            }
                        }
                        ),
                        e
                    }
                    set(e) {
                        return Object.keys(e).forEach(n => {
                            Reflect.has(this, n) && Mn(this[n]) && (this[n] && Mn(this[n].value) && Mn(this[n].setValueAtTime) ? this[n].value !== e[n] && (this[n].value = e[n]) : this[n]instanceof wS ? this[n].set(e[n]) : this[n] = e[n])
                        }
                        ),
                        this
                    }
                }
                  , aT = class extends yl {
                    constructor(t="stopped") {
                        super(),
                        this.name = "StateTimeline",
                        this._initial = t,
                        this.setStateAtTime(this._initial, 0)
                    }
                    getValueAtTime(t) {
                        const e = this.get(t);
                        return e !== null ? e.state : this._initial
                    }
                    setStateAtTime(t, e, n) {
                        return Hr(e, 0),
                        this.add(Object.assign({}, n, {
                            state: t,
                            time: e
                        })),
                        this
                    }
                    getLastState(t, e) {
                        const n = this._search(e);
                        for (let i = n; i >= 0; i--) {
                            const a = this._timeline[i];
                            if (a.state === t)
                                return a
                        }
                    }
                    getNextState(t, e) {
                        const n = this._search(e);
                        if (n !== -1)
                            for (let i = n; i < this._timeline.length; i++) {
                                const a = this._timeline[i];
                                if (a.state === t)
                                    return a
                            }
                    }
                }
                  , es = class mT extends Sl {
                    constructor() {
                        const e = Xt(mT.getDefaults(), arguments, ["param", "units", "convert"]);
                        for (super(e),
                        this.name = "Param",
                        this.overridden = !1,
                        this._minOutput = 1e-7,
                        kt(Mn(e.param) && (ef(e.param) || e.param instanceof mT), "param must be an AudioParam"); !ef(e.param); )
                            e.param = e.param._param;
                        this._swappable = Mn(e.swappable) ? e.swappable : !1,
                        this._swappable ? (this.input = this.context.createGain(),
                        this._param = e.param,
                        this.input.connect(this._param)) : this._param = this.input = e.param,
                        this._events = new yl(1e3),
                        this._initialValue = this._param.defaultValue,
                        this.units = e.units,
                        this.convert = e.convert,
                        this._minValue = e.minValue,
                        this._maxValue = e.maxValue,
                        Mn(e.value) && e.value !== this._toType(this._initialValue) && this.setValueAtTime(e.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(Sl.getDefaults(), {
                            convert: !0,
                            units: "number"
                        })
                    }
                    get value() {
                        const e = this.now();
                        return this.getValueAtTime(e)
                    }
                    set value(e) {
                        this.cancelScheduledValues(this.now()),
                        this.setValueAtTime(e, this.now())
                    }
                    get minValue() {
                        return Mn(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue
                    }
                    get maxValue() {
                        return Mn(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue
                    }
                    _is(e, n) {
                        return this.units === n
                    }
                    _assertRange(e) {
                        return Mn(this.maxValue) && Mn(this.minValue) && Hr(e, this._fromType(this.minValue), this._fromType(this.maxValue)),
                        e
                    }
                    _fromType(e) {
                        return this.convert && !this.overridden ? this._is(e, "time") ? this.toSeconds(e) : this._is(e, "decibels") ? mF(e) : this._is(e, "frequency") ? this.toFrequency(e) : e : this.overridden ? 0 : e
                    }
                    _toType(e) {
                        return this.convert && this.units === "decibels" ? gF(e) : e
                    }
                    setValueAtTime(e, n) {
                        const i = this.toSeconds(n)
                          , a = this._fromType(e);
                        return kt(isFinite(a) && isFinite(i), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`),
                        this._assertRange(a),
                        this.log(this.units, "setValueAtTime", e, i),
                        this._events.add({
                            time: i,
                            type: "setValueAtTime",
                            value: a
                        }),
                        this._param.setValueAtTime(a, i),
                        this
                    }
                    getValueAtTime(e) {
                        const n = Math.max(this.toSeconds(e), 0)
                          , i = this._events.getAfter(n)
                          , a = this._events.get(n);
                        let o = this._initialValue;
                        if (a === null)
                            o = this._initialValue;
                        else if (a.type === "setTargetAtTime" && (i === null || i.type === "setValueAtTime")) {
                            const u = this._events.getBefore(a.time);
                            let f;
                            u === null ? f = this._initialValue : f = u.value,
                            a.type === "setTargetAtTime" && (o = this._exponentialApproach(a.time, f, a.value, a.constant, n))
                        } else if (i === null)
                            o = a.value;
                        else if (i.type === "linearRampToValueAtTime" || i.type === "exponentialRampToValueAtTime") {
                            let u = a.value;
                            if (a.type === "setTargetAtTime") {
                                const f = this._events.getBefore(a.time);
                                f === null ? u = this._initialValue : u = f.value
                            }
                            i.type === "linearRampToValueAtTime" ? o = this._linearInterpolate(a.time, u, i.time, i.value, n) : o = this._exponentialInterpolate(a.time, u, i.time, i.value, n)
                        } else
                            o = a.value;
                        return this._toType(o)
                    }
                    setRampPoint(e) {
                        e = this.toSeconds(e);
                        let n = this.getValueAtTime(e);
                        return this.cancelAndHoldAtTime(e),
                        this._fromType(n) === 0 && (n = this._toType(this._minOutput)),
                        this.setValueAtTime(n, e),
                        this
                    }
                    linearRampToValueAtTime(e, n) {
                        const i = this._fromType(e)
                          , a = this.toSeconds(n);
                        return kt(isFinite(i) && isFinite(a), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`),
                        this._assertRange(i),
                        this._events.add({
                            time: a,
                            type: "linearRampToValueAtTime",
                            value: i
                        }),
                        this.log(this.units, "linearRampToValueAtTime", e, a),
                        this._param.linearRampToValueAtTime(i, a),
                        this
                    }
                    exponentialRampToValueAtTime(e, n) {
                        let i = this._fromType(e);
                        i = Ao(i, 0) ? this._minOutput : i,
                        this._assertRange(i);
                        const a = this.toSeconds(n);
                        return kt(isFinite(i) && isFinite(a), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`),
                        this._events.add({
                            time: a,
                            type: "exponentialRampToValueAtTime",
                            value: i
                        }),
                        this.log(this.units, "exponentialRampToValueAtTime", e, a),
                        this._param.exponentialRampToValueAtTime(i, a),
                        this
                    }
                    exponentialRampTo(e, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.exponentialRampToValueAtTime(e, i + this.toSeconds(n)),
                        this
                    }
                    linearRampTo(e, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.linearRampToValueAtTime(e, i + this.toSeconds(n)),
                        this
                    }
                    targetRampTo(e, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.exponentialApproachValueAtTime(e, i, n),
                        this
                    }
                    exponentialApproachValueAtTime(e, n, i) {
                        n = this.toSeconds(n),
                        i = this.toSeconds(i);
                        const a = Math.log(i + 1) / Math.log(200);
                        return this.setTargetAtTime(e, n, a),
                        this.cancelAndHoldAtTime(n + i * .9),
                        this.linearRampToValueAtTime(e, n + i),
                        this
                    }
                    setTargetAtTime(e, n, i) {
                        const a = this._fromType(e);
                        kt(isFinite(i) && i > 0, "timeConstant must be a number greater than 0");
                        const o = this.toSeconds(n);
                        return this._assertRange(a),
                        kt(isFinite(a) && isFinite(o), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`),
                        this._events.add({
                            constant: i,
                            time: o,
                            type: "setTargetAtTime",
                            value: a
                        }),
                        this.log(this.units, "setTargetAtTime", e, o, i),
                        this._param.setTargetAtTime(a, o, i),
                        this
                    }
                    setValueCurveAtTime(e, n, i, a=1) {
                        i = this.toSeconds(i),
                        n = this.toSeconds(n);
                        const o = this._fromType(e[0]) * a;
                        this.setValueAtTime(this._toType(o), n);
                        const u = i / (e.length - 1);
                        for (let f = 1; f < e.length; f++) {
                            const d = this._fromType(e[f]) * a;
                            this.linearRampToValueAtTime(this._toType(d), n + f * u)
                        }
                        return this
                    }
                    cancelScheduledValues(e) {
                        const n = this.toSeconds(e);
                        return kt(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(e)}`),
                        this._events.cancel(n),
                        this._param.cancelScheduledValues(n),
                        this.log(this.units, "cancelScheduledValues", n),
                        this
                    }
                    cancelAndHoldAtTime(e) {
                        const n = this.toSeconds(e)
                          , i = this._fromType(this.getValueAtTime(n));
                        kt(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(e)}`),
                        this.log(this.units, "cancelAndHoldAtTime", n, "value=" + i);
                        const a = this._events.get(n)
                          , o = this._events.getAfter(n);
                        return a && Ao(a.time, n) ? o ? (this._param.cancelScheduledValues(o.time),
                        this._events.cancel(o.time)) : (this._param.cancelAndHoldAtTime(n),
                        this._events.cancel(n + this.sampleTime)) : o && (this._param.cancelScheduledValues(o.time),
                        this._events.cancel(o.time),
                        o.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(i), n) : o.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(i), n)),
                        this._events.add({
                            time: n,
                            type: "setValueAtTime",
                            value: i
                        }),
                        this._param.setValueAtTime(i, n),
                        this
                    }
                    rampTo(e, n=.1, i) {
                        return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(e, n, i) : this.linearRampTo(e, n, i),
                        this
                    }
                    apply(e) {
                        const n = this.context.currentTime;
                        e.setValueAtTime(this.getValueAtTime(n), n);
                        const i = this._events.get(n);
                        if (i && i.type === "setTargetAtTime") {
                            const a = this._events.getAfter(i.time)
                              , o = a ? a.time : n + 2
                              , u = (o - n) / 10;
                            for (let f = n; f < o; f += u)
                                e.linearRampToValueAtTime(this.getValueAtTime(f), f)
                        }
                        return this._events.forEachAfter(this.context.currentTime, a => {
                            a.type === "cancelScheduledValues" ? e.cancelScheduledValues(a.time) : a.type === "setTargetAtTime" ? e.setTargetAtTime(a.value, a.time, a.constant) : e[a.type](a.value, a.time)
                        }
                        ),
                        this
                    }
                    setParam(e) {
                        kt(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
                        const n = this.input;
                        return n.disconnect(this._param),
                        this.apply(e),
                        this._param = e,
                        n.connect(this._param),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._events.dispose(),
                        this
                    }
                    get defaultValue() {
                        return this._toType(this._param.defaultValue)
                    }
                    _exponentialApproach(e, n, i, a, o) {
                        return i + (n - i) * Math.exp(-(o - e) / a)
                    }
                    _linearInterpolate(e, n, i, a, o) {
                        return n + (a - n) * ((o - e) / (i - e))
                    }
                    _exponentialInterpolate(e, n, i, a, o) {
                        return n * Math.pow(a / n, (o - e) / (i - e))
                    }
                }
                  , dn = class RS extends Sl {
                    constructor() {
                        super(...arguments),
                        this._internalChannels = []
                    }
                    get numberOfInputs() {
                        return Mn(this.input) ? ef(this.input) || this.input instanceof es ? 1 : this.input.numberOfInputs : 0
                    }
                    get numberOfOutputs() {
                        return Mn(this.output) ? this.output.numberOfOutputs : 0
                    }
                    _isAudioNode(e) {
                        return Mn(e) && (e instanceof RS || xu(e))
                    }
                    _getInternalNodes() {
                        const e = this._internalChannels.slice(0);
                        return this._isAudioNode(this.input) && e.push(this.input),
                        this._isAudioNode(this.output) && this.input !== this.output && e.push(this.output),
                        e
                    }
                    _setChannelProperties(e) {
                        this._getInternalNodes().forEach(n => {
                            n.channelCount = e.channelCount,
                            n.channelCountMode = e.channelCountMode,
                            n.channelInterpretation = e.channelInterpretation
                        }
                        )
                    }
                    _getChannelProperties() {
                        const e = this._getInternalNodes();
                        kt(e.length > 0, "ToneAudioNode does not have any internal nodes");
                        const n = e[0];
                        return {
                            channelCount: n.channelCount,
                            channelCountMode: n.channelCountMode,
                            channelInterpretation: n.channelInterpretation
                        }
                    }
                    get channelCount() {
                        return this._getChannelProperties().channelCount
                    }
                    set channelCount(e) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelCount: e
                        }))
                    }
                    get channelCountMode() {
                        return this._getChannelProperties().channelCountMode
                    }
                    set channelCountMode(e) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelCountMode: e
                        }))
                    }
                    get channelInterpretation() {
                        return this._getChannelProperties().channelInterpretation
                    }
                    set channelInterpretation(e) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelInterpretation: e
                        }))
                    }
                    connect(e, n=0, i=0) {
                        return bu(this, e, n, i),
                        this
                    }
                    toDestination() {
                        return this.connect(this.context.destination),
                        this
                    }
                    toMaster() {
                        return dS("toMaster() has been renamed toDestination()"),
                        this.toDestination()
                    }
                    disconnect(e, n=0, i=0) {
                        return MF(this, e, n, i),
                        this
                    }
                    chain(...e) {
                        return rT(this, ...e),
                        this
                    }
                    fan(...e) {
                        return e.forEach(n => this.connect(n)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        Mn(this.input) && (this.input instanceof RS ? this.input.dispose() : xu(this.input) && this.input.disconnect()),
                        Mn(this.output) && (this.output instanceof RS ? this.output.dispose() : xu(this.output) && this.output.disconnect()),
                        this._internalChannels = [],
                        this
                    }
                }
                ;
                function rT(...t) {
                    const e = t.shift();
                    t.reduce( (n, i) => (n instanceof dn ? n.connect(i) : xu(n) && bu(n, i),
                    i), e)
                }
                function bu(t, e, n=0, i=0) {
                    for (kt(Mn(t), "Cannot connect from undefined node"),
                    kt(Mn(e), "Cannot connect to undefined node"),
                    (e instanceof dn || xu(e)) && kt(e.numberOfInputs > 0, "Cannot connect to node with no inputs"),
                    kt(t.numberOfOutputs > 0, "Cannot connect from node with no outputs"); e instanceof dn || e instanceof es; )
                        Mn(e.input) && (e = e.input);
                    for (; t instanceof dn; )
                        Mn(t.output) && (t = t.output);
                    ef(e) ? t.connect(e, n) : t.connect(e, n, i)
                }
                function MF(t, e, n=0, i=0) {
                    if (Mn(e))
                        for (; e instanceof dn; )
                            e = e.input;
                    for (; !xu(t); )
                        Mn(t.output) && (t = t.output);
                    ef(e) ? t.disconnect(e, n) : xu(e) ? t.disconnect(e, n, i) : t.disconnect()
                }
                var ki = class KR extends dn {
                    constructor() {
                        const e = Xt(KR.getDefaults(), arguments, ["gain", "units"]);
                        super(e),
                        this.name = "Gain",
                        this._gainNode = this.context.createGain(),
                        this.input = this._gainNode,
                        this.output = this._gainNode,
                        this.gain = new es({
                            context: this.context,
                            convert: e.convert,
                            param: this._gainNode.gain,
                            units: e.units,
                            value: e.gain,
                            minValue: e.minValue,
                            maxValue: e.maxValue
                        }),
                        _i(this, "gain")
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            convert: !0,
                            gain: 1,
                            units: "gain"
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.disconnect(),
                        this.gain.dispose(),
                        this
                    }
                }
                  , Ap = class extends dn {
                    constructor(t) {
                        super(t),
                        this.onended = Xn,
                        this._startTime = -1,
                        this._stopTime = -1,
                        this._timeout = -1,
                        this.output = new ki({
                            context: this.context,
                            gain: 0
                        }),
                        this._gainNode = this.output,
                        this.getStateAtTime = function(e) {
                            const n = this.toSeconds(e);
                            return this._startTime !== -1 && n >= this._startTime && (this._stopTime === -1 || n <= this._stopTime) ? "started" : "stopped"
                        }
                        ,
                        this._fadeIn = t.fadeIn,
                        this._fadeOut = t.fadeOut,
                        this._curve = t.curve,
                        this.onended = t.onended
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            curve: "linear",
                            fadeIn: 0,
                            fadeOut: 0,
                            onended: Xn
                        })
                    }
                    _startGain(t, e=1) {
                        kt(this._startTime === -1, "Source cannot be started more than once");
                        const n = this.toSeconds(this._fadeIn);
                        return this._startTime = t + n,
                        this._startTime = Math.max(this._startTime, this.context.currentTime),
                        n > 0 ? (this._gainNode.gain.setValueAtTime(0, t),
                        this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(e, t + n) : this._gainNode.gain.exponentialApproachValueAtTime(e, t, n)) : this._gainNode.gain.setValueAtTime(e, t),
                        this
                    }
                    stop(t) {
                        return this.log("stop", t),
                        this._stopGain(this.toSeconds(t)),
                        this
                    }
                    _stopGain(t) {
                        kt(this._startTime !== -1, "'start' must be called before 'stop'"),
                        this.cancelStop();
                        const e = this.toSeconds(this._fadeOut);
                        return this._stopTime = this.toSeconds(t) + e,
                        this._stopTime = Math.max(this._stopTime, this.now()),
                        e > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, e, t) : this._gainNode.gain.targetRampTo(0, e, t) : (this._gainNode.gain.cancelAndHoldAtTime(t),
                        this._gainNode.gain.setValueAtTime(0, t)),
                        this.context.clearTimeout(this._timeout),
                        this._timeout = this.context.setTimeout( () => {
                            const n = this._curve === "exponential" ? e * 2 : 0;
                            this._stopSource(this.now() + n),
                            this._onended()
                        }
                        , this._stopTime - this.context.currentTime),
                        this
                    }
                    _onended() {
                        if (this.onended !== Xn && (this.onended(this),
                        this.onended = Xn,
                        !this.context.isOffline)) {
                            const t = () => this.dispose();
                            typeof requestIdleCallback < "u" ? requestIdleCallback(t) : setTimeout(t, 10)
                        }
                    }
                    get state() {
                        return this.getStateAtTime(this.now())
                    }
                    cancelStop() {
                        return this.log("cancelStop"),
                        kt(this._startTime !== -1, "Source is not started"),
                        this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime),
                        this.context.clearTimeout(this._timeout),
                        this._stopTime = -1,
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.dispose(),
                        this.onended = Xn,
                        this
                    }
                }
                  , bF = class JR extends Ap {
                    constructor() {
                        const e = Xt(JR.getDefaults(), arguments, ["offset"]);
                        super(e),
                        this.name = "ToneConstantSource",
                        this._source = this.context.createConstantSource(),
                        bu(this._source, this._gainNode),
                        this.offset = new es({
                            context: this.context,
                            convert: e.convert,
                            param: this._source.offset,
                            units: e.units,
                            value: e.offset,
                            minValue: e.minValue,
                            maxValue: e.maxValue
                        })
                    }
                    static getDefaults() {
                        return Object.assign(Ap.getDefaults(), {
                            convert: !0,
                            offset: 1,
                            units: "number"
                        })
                    }
                    start(e) {
                        const n = this.toSeconds(e);
                        return this.log("start", n),
                        this._startGain(n),
                        this._source.start(n),
                        this
                    }
                    _stopSource(e) {
                        this._source.stop(e)
                    }
                    dispose() {
                        return super.dispose(),
                        this.state === "started" && this.stop(),
                        this._source.disconnect(),
                        this.offset.dispose(),
                        this
                    }
                }
                  , Cs = class $R extends dn {
                    constructor() {
                        const e = Xt($R.getDefaults(), arguments, ["value", "units"]);
                        super(e),
                        this.name = "Signal",
                        this.override = !0,
                        this.output = this._constantSource = new bF({
                            context: this.context,
                            convert: e.convert,
                            offset: e.value,
                            units: e.units,
                            minValue: e.minValue,
                            maxValue: e.maxValue
                        }),
                        this._constantSource.start(0),
                        this.input = this._param = this._constantSource.offset
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            convert: !0,
                            units: "number",
                            value: 0
                        })
                    }
                    connect(e, n=0, i=0) {
                        return oT(this, e, n, i),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._param.dispose(),
                        this._constantSource.dispose(),
                        this
                    }
                    setValueAtTime(e, n) {
                        return this._param.setValueAtTime(e, n),
                        this
                    }
                    getValueAtTime(e) {
                        return this._param.getValueAtTime(e)
                    }
                    setRampPoint(e) {
                        return this._param.setRampPoint(e),
                        this
                    }
                    linearRampToValueAtTime(e, n) {
                        return this._param.linearRampToValueAtTime(e, n),
                        this
                    }
                    exponentialRampToValueAtTime(e, n) {
                        return this._param.exponentialRampToValueAtTime(e, n),
                        this
                    }
                    exponentialRampTo(e, n, i) {
                        return this._param.exponentialRampTo(e, n, i),
                        this
                    }
                    linearRampTo(e, n, i) {
                        return this._param.linearRampTo(e, n, i),
                        this
                    }
                    targetRampTo(e, n, i) {
                        return this._param.targetRampTo(e, n, i),
                        this
                    }
                    exponentialApproachValueAtTime(e, n, i) {
                        return this._param.exponentialApproachValueAtTime(e, n, i),
                        this
                    }
                    setTargetAtTime(e, n, i) {
                        return this._param.setTargetAtTime(e, n, i),
                        this
                    }
                    setValueCurveAtTime(e, n, i, a) {
                        return this._param.setValueCurveAtTime(e, n, i, a),
                        this
                    }
                    cancelScheduledValues(e) {
                        return this._param.cancelScheduledValues(e),
                        this
                    }
                    cancelAndHoldAtTime(e) {
                        return this._param.cancelAndHoldAtTime(e),
                        this
                    }
                    rampTo(e, n, i) {
                        return this._param.rampTo(e, n, i),
                        this
                    }
                    get value() {
                        return this._param.value
                    }
                    set value(e) {
                        this._param.value = e
                    }
                    get convert() {
                        return this._param.convert
                    }
                    set convert(e) {
                        this._param.convert = e
                    }
                    get units() {
                        return this._param.units
                    }
                    get overridden() {
                        return this._param.overridden
                    }
                    set overridden(e) {
                        this._param.overridden = e
                    }
                    get maxValue() {
                        return this._param.maxValue
                    }
                    get minValue() {
                        return this._param.minValue
                    }
                    apply(e) {
                        return this._param.apply(e),
                        this
                    }
                }
                ;
                function oT(t, e, n, i) {
                    (e instanceof es || ef(e) || e instanceof Cs && e.override) && (e.cancelScheduledValues(0),
                    e.setValueAtTime(0, 0),
                    e instanceof Cs && (e.overridden = !0)),
                    bu(t, e, n, i)
                }
                var TF = class e3 extends es {
                    constructor() {
                        const e = Xt(e3.getDefaults(), arguments, ["value"]);
                        super(e),
                        this.name = "TickParam",
                        this._events = new yl(1 / 0),
                        this._multiplier = 1,
                        this._multiplier = e.multiplier,
                        this._events.cancel(0),
                        this._events.add({
                            ticks: 0,
                            time: 0,
                            type: "setValueAtTime",
                            value: this._fromType(e.value)
                        }),
                        this.setValueAtTime(e.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(es.getDefaults(), {
                            multiplier: 1,
                            units: "hertz",
                            value: 1
                        })
                    }
                    setTargetAtTime(e, n, i) {
                        n = this.toSeconds(n),
                        this.setRampPoint(n);
                        const a = this._fromType(e)
                          , o = this._events.get(n)
                          , u = Math.round(Math.max(1 / i, 1));
                        for (let f = 0; f <= u; f++) {
                            const d = i * f + n
                              , p = this._exponentialApproach(o.time, o.value, a, i, d);
                            this.linearRampToValueAtTime(this._toType(p), d)
                        }
                        return this
                    }
                    setValueAtTime(e, n) {
                        const i = this.toSeconds(n);
                        super.setValueAtTime(e, n);
                        const a = this._events.get(i)
                          , o = this._events.previousEvent(a)
                          , u = this._getTicksUntilEvent(o, i);
                        return a.ticks = Math.max(u, 0),
                        this
                    }
                    linearRampToValueAtTime(e, n) {
                        const i = this.toSeconds(n);
                        super.linearRampToValueAtTime(e, n);
                        const a = this._events.get(i)
                          , o = this._events.previousEvent(a)
                          , u = this._getTicksUntilEvent(o, i);
                        return a.ticks = Math.max(u, 0),
                        this
                    }
                    exponentialRampToValueAtTime(e, n) {
                        n = this.toSeconds(n);
                        const i = this._fromType(e)
                          , a = this._events.get(n)
                          , o = Math.round(Math.max((n - a.time) * 10, 1))
                          , u = (n - a.time) / o;
                        for (let f = 0; f <= o; f++) {
                            const d = u * f + a.time
                              , p = this._exponentialInterpolate(a.time, a.value, n, i, d);
                            this.linearRampToValueAtTime(this._toType(p), d)
                        }
                        return this
                    }
                    _getTicksUntilEvent(e, n) {
                        if (e === null)
                            e = {
                                ticks: 0,
                                time: 0,
                                type: "setValueAtTime",
                                value: 0
                            };
                        else if (Fr(e.ticks)) {
                            const u = this._events.previousEvent(e);
                            e.ticks = this._getTicksUntilEvent(u, e.time)
                        }
                        const i = this._fromType(this.getValueAtTime(e.time));
                        let a = this._fromType(this.getValueAtTime(n));
                        const o = this._events.get(n);
                        return o && o.time === n && o.type === "setValueAtTime" && (a = this._fromType(this.getValueAtTime(n - this.sampleTime))),
                        .5 * (n - e.time) * (i + a) + e.ticks
                    }
                    getTicksAtTime(e) {
                        const n = this.toSeconds(e)
                          , i = this._events.get(n);
                        return Math.max(this._getTicksUntilEvent(i, n), 0)
                    }
                    getDurationOfTicks(e, n) {
                        const i = this.toSeconds(n)
                          , a = this.getTicksAtTime(n);
                        return this.getTimeOfTick(a + e) - i
                    }
                    getTimeOfTick(e) {
                        const n = this._events.get(e, "ticks")
                          , i = this._events.getAfter(e, "ticks");
                        if (n && n.ticks === e)
                            return n.time;
                        if (n && i && i.type === "linearRampToValueAtTime" && n.value !== i.value) {
                            const a = this._fromType(this.getValueAtTime(n.time))
                              , o = (this._fromType(this.getValueAtTime(i.time)) - a) / (i.time - n.time)
                              , u = Math.sqrt(Math.pow(a, 2) - 2 * o * (n.ticks - e))
                              , f = (-a + u) / o
                              , d = (-a - u) / o;
                            return (f > 0 ? f : d) + n.time
                        } else
                            return n ? n.value === 0 ? 1 / 0 : n.time + (e - n.ticks) / n.value : e / this._initialValue
                    }
                    ticksToTime(e, n) {
                        return this.getDurationOfTicks(e, n)
                    }
                    timeToTicks(e, n) {
                        const i = this.toSeconds(n)
                          , a = this.toSeconds(e)
                          , o = this.getTicksAtTime(i);
                        return this.getTicksAtTime(i + a) - o
                    }
                    _fromType(e) {
                        return this.units === "bpm" && this.multiplier ? 1 / (60 / e / this.multiplier) : super._fromType(e)
                    }
                    _toType(e) {
                        return this.units === "bpm" && this.multiplier ? e / this.multiplier * 60 : super._toType(e)
                    }
                    get multiplier() {
                        return this._multiplier
                    }
                    set multiplier(e) {
                        const n = this.value;
                        this._multiplier = e,
                        this.cancelScheduledValues(0),
                        this.setValueAtTime(n, 0)
                    }
                }
                  , AF = class t3 extends Cs {
                    constructor() {
                        const e = Xt(t3.getDefaults(), arguments, ["value"]);
                        super(e),
                        this.name = "TickSignal",
                        this.input = this._param = new TF({
                            context: this.context,
                            convert: e.convert,
                            multiplier: e.multiplier,
                            param: this._constantSource.offset,
                            units: e.units,
                            value: e.value
                        })
                    }
                    static getDefaults() {
                        return Object.assign(Cs.getDefaults(), {
                            multiplier: 1,
                            units: "hertz",
                            value: 1
                        })
                    }
                    ticksToTime(e, n) {
                        return this._param.ticksToTime(e, n)
                    }
                    timeToTicks(e, n) {
                        return this._param.timeToTicks(e, n)
                    }
                    getTimeOfTick(e) {
                        return this._param.getTimeOfTick(e)
                    }
                    getDurationOfTicks(e, n) {
                        return this._param.getDurationOfTicks(e, n)
                    }
                    getTicksAtTime(e) {
                        return this._param.getTicksAtTime(e)
                    }
                    get multiplier() {
                        return this._param.multiplier
                    }
                    set multiplier(e) {
                        this._param.multiplier = e
                    }
                    dispose() {
                        return super.dispose(),
                        this._param.dispose(),
                        this
                    }
                }
                  , EF = class n3 extends Sl {
                    constructor() {
                        const e = Xt(n3.getDefaults(), arguments, ["frequency"]);
                        super(e),
                        this.name = "TickSource",
                        this._state = new aT,
                        this._tickOffset = new yl,
                        this._ticksAtTime = new yl,
                        this._secondsAtTime = new yl,
                        this.frequency = new AF({
                            context: this.context,
                            units: e.units,
                            value: e.frequency
                        }),
                        _i(this, "frequency"),
                        this._state.setStateAtTime("stopped", 0),
                        this.setTicksAtTime(0, 0)
                    }
                    static getDefaults() {
                        return Object.assign({
                            frequency: 1,
                            units: "hertz"
                        }, Sl.getDefaults())
                    }
                    get state() {
                        return this.getStateAtTime(this.now())
                    }
                    start(e, n) {
                        const i = this.toSeconds(e);
                        return this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i),
                        Mn(n) && this.setTicksAtTime(n, i),
                        this._ticksAtTime.cancel(i),
                        this._secondsAtTime.cancel(i)),
                        this
                    }
                    stop(e) {
                        const n = this.toSeconds(e);
                        if (this._state.getValueAtTime(n) === "stopped") {
                            const i = this._state.get(n);
                            i && i.time > 0 && (this._tickOffset.cancel(i.time),
                            this._state.cancel(i.time))
                        }
                        return this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this.setTicksAtTime(0, n),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n),
                        this
                    }
                    pause(e) {
                        const n = this.toSeconds(e);
                        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n)),
                        this
                    }
                    cancel(e) {
                        return e = this.toSeconds(e),
                        this._state.cancel(e),
                        this._tickOffset.cancel(e),
                        this._ticksAtTime.cancel(e),
                        this._secondsAtTime.cancel(e),
                        this
                    }
                    getTicksAtTime(e) {
                        const n = this.toSeconds(e)
                          , i = this._state.getLastState("stopped", n)
                          , a = this._ticksAtTime.get(n)
                          , o = {
                            state: "paused",
                            time: n
                        };
                        this._state.add(o);
                        let u = a || i
                          , f = a ? a.ticks : 0
                          , d = null;
                        return this._state.forEachBetween(u.time, n + this.sampleTime, p => {
                            let g = u.time;
                            const v = this._tickOffset.get(p.time);
                            v && v.time >= u.time && (f = v.ticks,
                            g = v.time),
                            u.state === "started" && p.state !== "started" && (f += this.frequency.getTicksAtTime(p.time) - this.frequency.getTicksAtTime(g),
                            p.time !== o.time && (d = {
                                state: p.state,
                                time: p.time,
                                ticks: f
                            })),
                            u = p
                        }
                        ),
                        this._state.remove(o),
                        d && this._ticksAtTime.add(d),
                        f
                    }
                    get ticks() {
                        return this.getTicksAtTime(this.now())
                    }
                    set ticks(e) {
                        this.setTicksAtTime(e, this.now())
                    }
                    get seconds() {
                        return this.getSecondsAtTime(this.now())
                    }
                    set seconds(e) {
                        const n = this.now()
                          , i = this.frequency.timeToTicks(e, n);
                        this.setTicksAtTime(i, n)
                    }
                    getSecondsAtTime(e) {
                        e = this.toSeconds(e);
                        const n = this._state.getLastState("stopped", e)
                          , i = {
                            state: "paused",
                            time: e
                        };
                        this._state.add(i);
                        const a = this._secondsAtTime.get(e);
                        let o = a || n
                          , u = a ? a.seconds : 0
                          , f = null;
                        return this._state.forEachBetween(o.time, e + this.sampleTime, d => {
                            let p = o.time;
                            const g = this._tickOffset.get(d.time);
                            g && g.time >= o.time && (u = g.seconds,
                            p = g.time),
                            o.state === "started" && d.state !== "started" && (u += d.time - p,
                            d.time !== i.time && (f = {
                                state: d.state,
                                time: d.time,
                                seconds: u
                            })),
                            o = d
                        }
                        ),
                        this._state.remove(i),
                        f && this._secondsAtTime.add(f),
                        u
                    }
                    setTicksAtTime(e, n) {
                        return n = this.toSeconds(n),
                        this._tickOffset.cancel(n),
                        this._tickOffset.add({
                            seconds: this.frequency.getDurationOfTicks(e, n),
                            ticks: e,
                            time: n
                        }),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n),
                        this
                    }
                    getStateAtTime(e) {
                        return e = this.toSeconds(e),
                        this._state.getValueAtTime(e)
                    }
                    getTimeOfTick(e, n=this.now()) {
                        const i = this._tickOffset.get(n)
                          , a = this._state.get(n)
                          , o = Math.max(i.time, a.time)
                          , u = this.frequency.getTicksAtTime(o) + e - i.ticks;
                        return this.frequency.getTimeOfTick(u)
                    }
                    forEachTickBetween(e, n, i) {
                        let a = this._state.get(e);
                        this._state.forEachBetween(e, n, u => {
                            a && a.state === "started" && u.state !== "started" && this.forEachTickBetween(Math.max(a.time, e), u.time - this.sampleTime, i),
                            a = u
                        }
                        );
                        let o = null;
                        if (a && a.state === "started") {
                            const u = Math.max(a.time, e)
                              , f = this.frequency.getTicksAtTime(u)
                              , d = f - this.frequency.getTicksAtTime(a.time);
                            let p = Math.ceil(d) - d;
                            p = Ao(p, 1) ? 0 : p;
                            let g = this.frequency.getTimeOfTick(f + p);
                            for (; g < n; ) {
                                try {
                                    i(g, Math.round(this.getTicksAtTime(g)))
                                } catch (v) {
                                    o = v;
                                    break
                                }
                                g += this.frequency.getDurationOfTicks(1, g)
                            }
                        }
                        if (o)
                            throw o;
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._state.dispose(),
                        this._tickOffset.dispose(),
                        this._ticksAtTime.dispose(),
                        this._secondsAtTime.dispose(),
                        this.frequency.dispose(),
                        this
                    }
                }
                  , Ww = class i3 extends Sl {
                    constructor() {
                        const e = Xt(i3.getDefaults(), arguments, ["callback", "frequency"]);
                        super(e),
                        this.name = "Clock",
                        this.callback = Xn,
                        this._lastUpdate = 0,
                        this._state = new aT("stopped"),
                        this._boundLoop = this._loop.bind(this),
                        this.callback = e.callback,
                        this._tickSource = new EF({
                            context: this.context,
                            frequency: e.frequency,
                            units: e.units
                        }),
                        this._lastUpdate = 0,
                        this.frequency = this._tickSource.frequency,
                        _i(this, "frequency"),
                        this._state.setStateAtTime("stopped", 0),
                        this.context.on("tick", this._boundLoop)
                    }
                    static getDefaults() {
                        return Object.assign(Sl.getDefaults(), {
                            callback: Xn,
                            frequency: 1,
                            units: "hertz"
                        })
                    }
                    get state() {
                        return this._state.getValueAtTime(this.now())
                    }
                    start(e, n) {
                        Uw(this.context);
                        const i = this.toSeconds(e);
                        return this.log("start", i),
                        this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i),
                        this._tickSource.start(i, n),
                        i < this._lastUpdate && this.emit("start", i, n)),
                        this
                    }
                    stop(e) {
                        const n = this.toSeconds(e);
                        return this.log("stop", n),
                        this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this._tickSource.stop(n),
                        n < this._lastUpdate && this.emit("stop", n),
                        this
                    }
                    pause(e) {
                        const n = this.toSeconds(e);
                        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n),
                        this._tickSource.pause(n),
                        n < this._lastUpdate && this.emit("pause", n)),
                        this
                    }
                    get ticks() {
                        return Math.ceil(this.getTicksAtTime(this.now()))
                    }
                    set ticks(e) {
                        this._tickSource.ticks = e
                    }
                    get seconds() {
                        return this._tickSource.seconds
                    }
                    set seconds(e) {
                        this._tickSource.seconds = e
                    }
                    getSecondsAtTime(e) {
                        return this._tickSource.getSecondsAtTime(e)
                    }
                    setTicksAtTime(e, n) {
                        return this._tickSource.setTicksAtTime(e, n),
                        this
                    }
                    getTimeOfTick(e, n=this.now()) {
                        return this._tickSource.getTimeOfTick(e, n)
                    }
                    getTicksAtTime(e) {
                        return this._tickSource.getTicksAtTime(e)
                    }
                    nextTickTime(e, n) {
                        const i = this.toSeconds(n)
                          , a = this.getTicksAtTime(i);
                        return this._tickSource.getTimeOfTick(a + e, i)
                    }
                    _loop() {
                        const e = this._lastUpdate
                          , n = this.now();
                        this._lastUpdate = n,
                        this.log("loop", e, n),
                        e !== n && (this._state.forEachBetween(e, n, i => {
                            switch (i.state) {
                            case "started":
                                const a = this._tickSource.getTicksAtTime(i.time);
                                this.emit("start", i.time, a);
                                break;
                            case "stopped":
                                i.time !== 0 && this.emit("stop", i.time);
                                break;
                            case "paused":
                                this.emit("pause", i.time);
                                break
                            }
                        }
                        ),
                        this._tickSource.forEachTickBetween(e, n, (i, a) => {
                            this.callback(i, a)
                        }
                        ))
                    }
                    getStateAtTime(e) {
                        const n = this.toSeconds(e);
                        return this._state.getValueAtTime(n)
                    }
                    dispose() {
                        return super.dispose(),
                        this.context.off("tick", this._boundLoop),
                        this._tickSource.dispose(),
                        this._state.dispose(),
                        this
                    }
                }
                ;
                iT.mixin(Ww);
                var SS = class s3 extends dn {
                    constructor() {
                        const e = Xt(s3.getDefaults(), arguments, ["volume"]);
                        super(e),
                        this.name = "Volume",
                        this.input = this.output = new ki({
                            context: this.context,
                            gain: e.volume,
                            units: "decibels"
                        }),
                        this.volume = this.output.gain,
                        _i(this, "volume"),
                        this._unmutedVolume = e.volume,
                        this.mute = e.mute
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            mute: !1,
                            volume: 0
                        })
                    }
                    get mute() {
                        return this.volume.value === -1 / 0
                    }
                    set mute(e) {
                        !this.mute && e ? (this._unmutedVolume = this.volume.value,
                        this.volume.value = -1 / 0) : this.mute && !e && (this.volume.value = this._unmutedVolume)
                    }
                    dispose() {
                        return super.dispose(),
                        this.input.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                  , CF = class a3 extends dn {
                    constructor() {
                        const e = Xt(a3.getDefaults(), arguments);
                        super(e),
                        this.name = "Destination",
                        this.input = new SS({
                            context: this.context
                        }),
                        this.output = new ki({
                            context: this.context
                        }),
                        this.volume = this.input.volume,
                        rT(this.input, this.output, this.context.rawContext.destination),
                        this.mute = e.mute,
                        this._internalChannels = [this.input, this.context.rawContext.destination, this.output]
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            mute: !1,
                            volume: 0
                        })
                    }
                    get mute() {
                        return this.input.mute
                    }
                    set mute(e) {
                        this.input.mute = e
                    }
                    chain(...e) {
                        return this.input.disconnect(),
                        e.unshift(this.input),
                        e.push(this.output),
                        rT(...e),
                        this
                    }
                    get maxChannelCount() {
                        return this.context.rawContext.destination.maxChannelCount
                    }
                    dispose() {
                        return super.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                ;
                gS(t => {
                    t.destination = new CF({
                        context: t
                    })
                }
                ),
                vS(t => {
                    t.destination.dispose()
                }
                );
                var wF = class extends dn {
                    constructor() {
                        super(...arguments),
                        this.name = "Listener",
                        this.positionX = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.positionX
                        }),
                        this.positionY = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.positionY
                        }),
                        this.positionZ = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.positionZ
                        }),
                        this.forwardX = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardX
                        }),
                        this.forwardY = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardY
                        }),
                        this.forwardZ = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardZ
                        }),
                        this.upX = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.upX
                        }),
                        this.upY = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.upY
                        }),
                        this.upZ = new es({
                            context: this.context,
                            param: this.context.rawContext.listener.upZ
                        })
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            positionX: 0,
                            positionY: 0,
                            positionZ: 0,
                            forwardX: 0,
                            forwardY: 0,
                            forwardZ: -1,
                            upX: 0,
                            upY: 1,
                            upZ: 0
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.positionX.dispose(),
                        this.positionY.dispose(),
                        this.positionZ.dispose(),
                        this.forwardX.dispose(),
                        this.forwardY.dispose(),
                        this.forwardZ.dispose(),
                        this.upX.dispose(),
                        this.upY.dispose(),
                        this.upZ.dispose(),
                        this
                    }
                }
                ;
                gS(t => {
                    t.listener = new wF({
                        context: t
                    })
                }
                ),
                vS(t => {
                    t.listener.dispose()
                }
                );
                var RF = class r3 extends pc {
                    constructor() {
                        super(),
                        this.name = "ToneAudioBuffers",
                        this._buffers = new Map,
                        this._loadingCount = 0;
                        const e = Xt(r3.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
                        this.baseUrl = e.baseUrl,
                        Object.keys(e.urls).forEach(n => {
                            this._loadingCount++;
                            const i = e.urls[n];
                            this.add(n, i, this._bufferLoaded.bind(this, e.onload), e.onerror)
                        }
                        )
                    }
                    static getDefaults() {
                        return {
                            baseUrl: "",
                            onerror: Xn,
                            onload: Xn,
                            urls: {}
                        }
                    }
                    has(e) {
                        return this._buffers.has(e.toString())
                    }
                    get(e) {
                        return kt(this.has(e), `ToneAudioBuffers has no buffer named: ${e}`),
                        this._buffers.get(e.toString())
                    }
                    _bufferLoaded(e) {
                        this._loadingCount--,
                        this._loadingCount === 0 && e && e()
                    }
                    get loaded() {
                        return Array.from(this._buffers).every( ([e,n]) => n.loaded)
                    }
                    add(e, n, i=Xn, a=Xn) {
                        return dc(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""),
                        this._buffers.set(e.toString(), new Eo(this.baseUrl + n,i,a))) : this._buffers.set(e.toString(), new Eo(n,i,a)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffers.forEach(e => e.dispose()),
                        this._buffers.clear(),
                        this
                    }
                }
                  , Yw = class o3 extends Mu {
                    constructor() {
                        super(...arguments),
                        this.name = "MidiClass",
                        this.defaultUnits = "midi"
                    }
                    _frequencyToUnits(e) {
                        return sf(super._frequencyToUnits(e))
                    }
                    _ticksToUnits(e) {
                        return sf(super._ticksToUnits(e))
                    }
                    _beatsToUnits(e) {
                        return sf(super._beatsToUnits(e))
                    }
                    _secondsToUnits(e) {
                        return sf(super._secondsToUnits(e))
                    }
                    toMidi() {
                        return this.valueOf()
                    }
                    toFrequency() {
                        return Xw(this.toMidi())
                    }
                    transpose(e) {
                        return new o3(this.context,this.toMidi() + e)
                    }
                }
                  , Ep = class extends cv {
                    constructor() {
                        super(...arguments),
                        this.name = "Ticks",
                        this.defaultUnits = "i"
                    }
                    _now() {
                        return this.context.transport.ticks
                    }
                    _beatsToUnits(t) {
                        return this._getPPQ() * t
                    }
                    _secondsToUnits(t) {
                        return Math.floor(t / (60 / this._getBpm()) * this._getPPQ())
                    }
                    _ticksToUnits(t) {
                        return t
                    }
                    toTicks() {
                        return this.valueOf()
                    }
                    toSeconds() {
                        return this.valueOf() / this._getPPQ() * (60 / this._getBpm())
                    }
                }
                  , NF = class extends Sl {
                    constructor() {
                        super(...arguments),
                        this.name = "Draw",
                        this.expiration = .25,
                        this.anticipation = .008,
                        this._events = new yl,
                        this._boundDrawLoop = this._drawLoop.bind(this),
                        this._animationFrame = -1
                    }
                    schedule(t, e) {
                        return this._events.add({
                            callback: t,
                            time: this.toSeconds(e)
                        }),
                        this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)),
                        this
                    }
                    cancel(t) {
                        return this._events.cancel(this.toSeconds(t)),
                        this
                    }
                    _drawLoop() {
                        const t = this.context.currentTime;
                        this._events.forEachBefore(t + this.anticipation, e => {
                            t - e.time <= this.expiration && e.callback(),
                            this._events.remove(e)
                        }
                        ),
                        this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop))
                    }
                    dispose() {
                        return super.dispose(),
                        this._events.dispose(),
                        cancelAnimationFrame(this._animationFrame),
                        this
                    }
                }
                ;
                gS(t => {
                    t.draw = new NF({
                        context: t
                    })
                }
                ),
                vS(t => {
                    t.draw.dispose()
                }
                );
                var DF = class extends pc {
                    constructor() {
                        super(...arguments),
                        this.name = "IntervalTimeline",
                        this._root = null,
                        this._length = 0
                    }
                    add(t) {
                        kt(Mn(t.time), "Events must have a time property"),
                        kt(Mn(t.duration), "Events must have a duration parameter"),
                        t.time = t.time.valueOf();
                        let e = new OF(t.time,t.time + t.duration,t);
                        for (this._root === null ? this._root = e : this._root.insert(e),
                        this._length++; e !== null; )
                            e.updateHeight(),
                            e.updateMax(),
                            this._rebalance(e),
                            e = e.parent;
                        return this
                    }
                    remove(t) {
                        if (this._root !== null) {
                            const e = [];
                            this._root.search(t.time, e);
                            for (const n of e)
                                if (n.event === t) {
                                    this._removeNode(n),
                                    this._length--;
                                    break
                                }
                        }
                        return this
                    }
                    get length() {
                        return this._length
                    }
                    cancel(t) {
                        return this.forEachFrom(t, e => this.remove(e)),
                        this
                    }
                    _setRoot(t) {
                        this._root = t,
                        this._root !== null && (this._root.parent = null)
                    }
                    _replaceNodeInParent(t, e) {
                        t.parent !== null ? (t.isLeftChild() ? t.parent.left = e : t.parent.right = e,
                        this._rebalance(t.parent)) : this._setRoot(e)
                    }
                    _removeNode(t) {
                        if (t.left === null && t.right === null)
                            this._replaceNodeInParent(t, null);
                        else if (t.right === null)
                            this._replaceNodeInParent(t, t.left);
                        else if (t.left === null)
                            this._replaceNodeInParent(t, t.right);
                        else {
                            const e = t.getBalance();
                            let n, i = null;
                            if (e > 0)
                                if (t.left.right === null)
                                    n = t.left,
                                    n.right = t.right,
                                    i = n;
                                else {
                                    for (n = t.left.right; n.right !== null; )
                                        n = n.right;
                                    n.parent && (n.parent.right = n.left,
                                    i = n.parent,
                                    n.left = t.left,
                                    n.right = t.right)
                                }
                            else if (t.right.left === null)
                                n = t.right,
                                n.left = t.left,
                                i = n;
                            else {
                                for (n = t.right.left; n.left !== null; )
                                    n = n.left;
                                n.parent && (n.parent.left = n.right,
                                i = n.parent,
                                n.left = t.left,
                                n.right = t.right)
                            }
                            t.parent !== null ? t.isLeftChild() ? t.parent.left = n : t.parent.right = n : this._setRoot(n),
                            i && this._rebalance(i)
                        }
                        t.dispose()
                    }
                    _rotateLeft(t) {
                        const e = t.parent
                          , n = t.isLeftChild()
                          , i = t.right;
                        i && (t.right = i.left,
                        i.left = t),
                        e !== null ? n ? e.left = i : e.right = i : this._setRoot(i)
                    }
                    _rotateRight(t) {
                        const e = t.parent
                          , n = t.isLeftChild()
                          , i = t.left;
                        i && (t.left = i.right,
                        i.right = t),
                        e !== null ? n ? e.left = i : e.right = i : this._setRoot(i)
                    }
                    _rebalance(t) {
                        const e = t.getBalance();
                        e > 1 && t.left ? t.left.getBalance() < 0 ? this._rotateLeft(t.left) : this._rotateRight(t) : e < -1 && t.right && (t.right.getBalance() > 0 ? this._rotateRight(t.right) : this._rotateLeft(t))
                    }
                    get(t) {
                        if (this._root !== null) {
                            const e = [];
                            if (this._root.search(t, e),
                            e.length > 0) {
                                let n = e[0];
                                for (let i = 1; i < e.length; i++)
                                    e[i].low > n.low && (n = e[i]);
                                return n.event
                            }
                        }
                        return null
                    }
                    forEach(t) {
                        if (this._root !== null) {
                            const e = [];
                            this._root.traverse(n => e.push(n)),
                            e.forEach(n => {
                                n.event && t(n.event)
                            }
                            )
                        }
                        return this
                    }
                    forEachAtTime(t, e) {
                        if (this._root !== null) {
                            const n = [];
                            this._root.search(t, n),
                            n.forEach(i => {
                                i.event && e(i.event)
                            }
                            )
                        }
                        return this
                    }
                    forEachFrom(t, e) {
                        if (this._root !== null) {
                            const n = [];
                            this._root.searchAfter(t, n),
                            n.forEach(i => {
                                i.event && e(i.event)
                            }
                            )
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._root !== null && this._root.traverse(t => t.dispose()),
                        this._root = null,
                        this
                    }
                }
                  , OF = class {
                    constructor(t, e, n) {
                        this._left = null,
                        this._right = null,
                        this.parent = null,
                        this.height = 0,
                        this.event = n,
                        this.low = t,
                        this.high = e,
                        this.max = this.high
                    }
                    insert(t) {
                        t.low <= this.low ? this.left === null ? this.left = t : this.left.insert(t) : this.right === null ? this.right = t : this.right.insert(t)
                    }
                    search(t, e) {
                        t > this.max || (this.left !== null && this.left.search(t, e),
                        this.low <= t && this.high > t && e.push(this),
                        !(this.low > t) && this.right !== null && this.right.search(t, e))
                    }
                    searchAfter(t, e) {
                        this.low >= t && (e.push(this),
                        this.left !== null && this.left.searchAfter(t, e)),
                        this.right !== null && this.right.searchAfter(t, e)
                    }
                    traverse(t) {
                        t(this),
                        this.left !== null && this.left.traverse(t),
                        this.right !== null && this.right.traverse(t)
                    }
                    updateHeight() {
                        this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0
                    }
                    updateMax() {
                        this.max = this.high,
                        this.left !== null && (this.max = Math.max(this.max, this.left.max)),
                        this.right !== null && (this.max = Math.max(this.max, this.right.max))
                    }
                    getBalance() {
                        let t = 0;
                        return this.left !== null && this.right !== null ? t = this.left.height - this.right.height : this.left !== null ? t = this.left.height + 1 : this.right !== null && (t = -(this.right.height + 1)),
                        t
                    }
                    isLeftChild() {
                        return this.parent !== null && this.parent.left === this
                    }
                    get left() {
                        return this._left
                    }
                    set left(t) {
                        this._left = t,
                        t !== null && (t.parent = this),
                        this.updateHeight(),
                        this.updateMax()
                    }
                    get right() {
                        return this._right
                    }
                    set right(t) {
                        this._right = t,
                        t !== null && (t.parent = this),
                        this.updateHeight(),
                        this.updateMax()
                    }
                    dispose() {
                        this.parent = null,
                        this._left = null,
                        this._right = null,
                        this.event = null
                    }
                }
                  , UF = class extends pc {
                    constructor(t) {
                        super(),
                        this.name = "TimelineValue",
                        this._timeline = new yl({
                            memory: 10
                        }),
                        this._initialValue = t
                    }
                    set(t, e) {
                        return this._timeline.add({
                            value: t,
                            time: e
                        }),
                        this
                    }
                    get(t) {
                        const e = this._timeline.get(t);
                        return e ? e.value : this._initialValue
                    }
                }
                  , uv = class l3 extends dn {
                    constructor() {
                        super(Xt(l3.getDefaults(), arguments, ["context"]))
                    }
                    connect(e, n=0, i=0) {
                        return oT(this, e, n, i),
                        this
                    }
                }
                  , xS = class c3 extends uv {
                    constructor() {
                        const e = Xt(c3.getDefaults(), arguments, ["mapping", "length"]);
                        super(e),
                        this.name = "WaveShaper",
                        this._shaper = this.context.createWaveShaper(),
                        this.input = this._shaper,
                        this.output = this._shaper,
                        or(e.mapping) || e.mapping instanceof Float32Array ? this.curve = Float32Array.from(e.mapping) : QV(e.mapping) && this.setMap(e.mapping, e.length)
                    }
                    static getDefaults() {
                        return Object.assign(Cs.getDefaults(), {
                            length: 1024
                        })
                    }
                    setMap(e, n=1024) {
                        const i = new Float32Array(n);
                        for (let a = 0, o = n; a < o; a++)
                            i[a] = e(a / (o - 1) * 2 - 1, a);
                        return this.curve = i,
                        this
                    }
                    get curve() {
                        return this._shaper.curve
                    }
                    set curve(e) {
                        this._shaper.curve = e
                    }
                    get oversample() {
                        return this._shaper.oversample
                    }
                    set oversample(e) {
                        kt(["none", "2x", "4x"].some(n => n.includes(e)), "oversampling must be either 'none', '2x', or '4x'"),
                        this._shaper.oversample = e
                    }
                    dispose() {
                        return super.dispose(),
                        this._shaper.disconnect(),
                        this
                    }
                }
                  , LF = class u3 extends uv {
                    constructor() {
                        const e = Xt(u3.getDefaults(), arguments, ["value"]);
                        super(e),
                        this.name = "Pow",
                        this._exponentScaler = this.input = this.output = new xS({
                            context: this.context,
                            mapping: this._expFunc(e.value),
                            length: 8192
                        }),
                        this._exponent = e.value
                    }
                    static getDefaults() {
                        return Object.assign(uv.getDefaults(), {
                            value: 1
                        })
                    }
                    _expFunc(e) {
                        return n => Math.pow(Math.abs(n), e)
                    }
                    get value() {
                        return this._exponent
                    }
                    set value(e) {
                        this._exponent = e,
                        this._exponentScaler.setMap(this._expFunc(this._exponent))
                    }
                    dispose() {
                        return super.dispose(),
                        this._exponentScaler.dispose(),
                        this
                    }
                }
                  , hv = class gT {
                    constructor(e, n) {
                        this.id = gT._eventId++,
                        this._remainderTime = 0;
                        const i = Object.assign(gT.getDefaults(), n);
                        this.transport = e,
                        this.callback = i.callback,
                        this._once = i.once,
                        this.time = Math.floor(i.time),
                        this._remainderTime = i.time - this.time
                    }
                    static getDefaults() {
                        return {
                            callback: Xn,
                            once: !1,
                            time: 0
                        }
                    }
                    get floatTime() {
                        return this.time + this._remainderTime
                    }
                    invoke(e) {
                        if (this.callback) {
                            const n = this.transport.bpm.getDurationOfTicks(1, e);
                            this.callback(e + this._remainderTime * n),
                            this._once && this.transport.clear(this.id)
                        }
                    }
                    dispose() {
                        return this.callback = void 0,
                        this
                    }
                }
                ;
                hv._eventId = 0;
                var IF = class h3 extends hv {
                    constructor(e, n) {
                        super(e, n),
                        this._currentId = -1,
                        this._nextId = -1,
                        this._nextTick = this.time,
                        this._boundRestart = this._restart.bind(this);
                        const i = Object.assign(h3.getDefaults(), n);
                        this.duration = i.duration,
                        this._interval = i.interval,
                        this._nextTick = i.time,
                        this.transport.on("start", this._boundRestart),
                        this.transport.on("loopStart", this._boundRestart),
                        this.transport.on("ticks", this._boundRestart),
                        this.context = this.transport.context,
                        this._restart()
                    }
                    static getDefaults() {
                        return Object.assign({}, hv.getDefaults(), {
                            duration: 1 / 0,
                            interval: 1,
                            once: !1
                        })
                    }
                    invoke(e) {
                        this._createEvents(e),
                        super.invoke(e)
                    }
                    _createEvent() {
                        return mS(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new Ep(this.context,this._nextTick).toSeconds()) : -1
                    }
                    _createEvents(e) {
                        mS(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval,
                        this._currentId = this._nextId,
                        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Ep(this.context,this._nextTick).toSeconds()))
                    }
                    _restart(e) {
                        this.transport.clear(this._currentId),
                        this.transport.clear(this._nextId),
                        this._nextTick = this.floatTime;
                        const n = this.transport.getTicksAtTime(e);
                        Tp(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval),
                        this._currentId = this._createEvent(),
                        this._nextTick += this._interval,
                        this._nextId = this._createEvent()
                    }
                    dispose() {
                        return super.dispose(),
                        this.transport.clear(this._currentId),
                        this.transport.clear(this._nextId),
                        this.transport.off("start", this._boundRestart),
                        this.transport.off("loopStart", this._boundRestart),
                        this.transport.off("ticks", this._boundRestart),
                        this
                    }
                }
                  , jw = class f3 extends Sl {
                    constructor() {
                        const e = Xt(f3.getDefaults(), arguments);
                        super(e),
                        this.name = "Transport",
                        this._loop = new UF(!1),
                        this._loopStart = 0,
                        this._loopEnd = 0,
                        this._scheduledEvents = {},
                        this._timeline = new yl,
                        this._repeatedEvents = new DF,
                        this._syncedSignals = [],
                        this._swingAmount = 0,
                        this._ppq = e.ppq,
                        this._clock = new Ww({
                            callback: this._processTick.bind(this),
                            context: this.context,
                            frequency: 0,
                            units: "bpm"
                        }),
                        this._bindClockEvents(),
                        this.bpm = this._clock.frequency,
                        this._clock.frequency.multiplier = e.ppq,
                        this.bpm.setValueAtTime(e.bpm, 0),
                        _i(this, "bpm"),
                        this._timeSignature = e.timeSignature,
                        this._swingTicks = e.ppq / 2
                    }
                    static getDefaults() {
                        return Object.assign(Sl.getDefaults(), {
                            bpm: 120,
                            loopEnd: "4m",
                            loopStart: 0,
                            ppq: 192,
                            swing: 0,
                            swingSubdivision: "8n",
                            timeSignature: 4
                        })
                    }
                    _processTick(e, n) {
                        if (this._loop.get(e) && n >= this._loopEnd && (this.emit("loopEnd", e),
                        this._clock.setTicksAtTime(this._loopStart, e),
                        n = this._loopStart,
                        this.emit("loopStart", e, this._clock.getSecondsAtTime(e)),
                        this.emit("loop", e)),
                        this._swingAmount > 0 && n % this._ppq !== 0 && n % (this._swingTicks * 2) !== 0) {
                            const i = n % (this._swingTicks * 2) / (this._swingTicks * 2)
                              , a = Math.sin(i * Math.PI) * this._swingAmount;
                            e += new Ep(this.context,this._swingTicks * 2 / 3).toSeconds() * a
                        }
                        zw(!0),
                        this._timeline.forEachAtTime(n, i => i.invoke(e)),
                        zw(!1)
                    }
                    schedule(e, n) {
                        const i = new hv(this,{
                            callback: e,
                            time: new cv(this.context,n).toTicks()
                        });
                        return this._addEvent(i, this._timeline)
                    }
                    scheduleRepeat(e, n, i, a=1 / 0) {
                        const o = new IF(this,{
                            callback: e,
                            duration: new af(this.context,a).toTicks(),
                            interval: new af(this.context,n).toTicks(),
                            time: new cv(this.context,i).toTicks()
                        });
                        return this._addEvent(o, this._repeatedEvents)
                    }
                    scheduleOnce(e, n) {
                        const i = new hv(this,{
                            callback: e,
                            once: !0,
                            time: new cv(this.context,n).toTicks()
                        });
                        return this._addEvent(i, this._timeline)
                    }
                    clear(e) {
                        if (this._scheduledEvents.hasOwnProperty(e)) {
                            const n = this._scheduledEvents[e.toString()];
                            n.timeline.remove(n.event),
                            n.event.dispose(),
                            delete this._scheduledEvents[e.toString()]
                        }
                        return this
                    }
                    _addEvent(e, n) {
                        return this._scheduledEvents[e.id.toString()] = {
                            event: e,
                            timeline: n
                        },
                        n.add(e),
                        e.id
                    }
                    cancel(e=0) {
                        const n = this.toTicks(e);
                        return this._timeline.forEachFrom(n, i => this.clear(i.id)),
                        this._repeatedEvents.forEachFrom(n, i => this.clear(i.id)),
                        this
                    }
                    _bindClockEvents() {
                        this._clock.on("start", (e, n) => {
                            n = new Ep(this.context,n).toSeconds(),
                            this.emit("start", e, n)
                        }
                        ),
                        this._clock.on("stop", e => {
                            this.emit("stop", e)
                        }
                        ),
                        this._clock.on("pause", e => {
                            this.emit("pause", e)
                        }
                        )
                    }
                    get state() {
                        return this._clock.getStateAtTime(this.now())
                    }
                    start(e, n) {
                        this.context.resume();
                        let i;
                        return Mn(n) && (i = this.toTicks(n)),
                        this._clock.start(e, i),
                        this
                    }
                    stop(e) {
                        return this._clock.stop(e),
                        this
                    }
                    pause(e) {
                        return this._clock.pause(e),
                        this
                    }
                    toggle(e) {
                        return e = this.toSeconds(e),
                        this._clock.getStateAtTime(e) !== "started" ? this.start(e) : this.stop(e),
                        this
                    }
                    get timeSignature() {
                        return this._timeSignature
                    }
                    set timeSignature(e) {
                        or(e) && (e = e[0] / e[1] * 4),
                        this._timeSignature = e
                    }
                    get loopStart() {
                        return new af(this.context,this._loopStart,"i").toSeconds()
                    }
                    set loopStart(e) {
                        this._loopStart = this.toTicks(e)
                    }
                    get loopEnd() {
                        return new af(this.context,this._loopEnd,"i").toSeconds()
                    }
                    set loopEnd(e) {
                        this._loopEnd = this.toTicks(e)
                    }
                    get loop() {
                        return this._loop.get(this.now())
                    }
                    set loop(e) {
                        this._loop.set(e, this.now())
                    }
                    setLoopPoints(e, n) {
                        return this.loopStart = e,
                        this.loopEnd = n,
                        this
                    }
                    get swing() {
                        return this._swingAmount
                    }
                    set swing(e) {
                        this._swingAmount = e
                    }
                    get swingSubdivision() {
                        return new Ep(this.context,this._swingTicks).toNotation()
                    }
                    set swingSubdivision(e) {
                        this._swingTicks = this.toTicks(e)
                    }
                    get position() {
                        const e = this.now()
                          , n = this._clock.getTicksAtTime(e);
                        return new Ep(this.context,n).toBarsBeatsSixteenths()
                    }
                    set position(e) {
                        this.ticks = this.toTicks(e)
                    }
                    get seconds() {
                        return this._clock.seconds
                    }
                    set seconds(e) {
                        const n = this.now();
                        this.ticks = this._clock.frequency.timeToTicks(e, n)
                    }
                    get progress() {
                        if (this.loop) {
                            const e = this.now();
                            return (this._clock.getTicksAtTime(e) - this._loopStart) / (this._loopEnd - this._loopStart)
                        } else
                            return 0
                    }
                    get ticks() {
                        return this._clock.ticks
                    }
                    set ticks(e) {
                        if (this._clock.ticks !== e) {
                            const n = this.now();
                            if (this.state === "started") {
                                const i = this._clock.getTicksAtTime(n)
                                  , a = n + this._clock.frequency.getDurationOfTicks(Math.ceil(i) - i, n);
                                this.emit("stop", a),
                                this._clock.setTicksAtTime(e, a),
                                this.emit("start", a, this._clock.getSecondsAtTime(a))
                            } else
                                this.emit("ticks", n),
                                this._clock.setTicksAtTime(e, n)
                        }
                    }
                    getTicksAtTime(e) {
                        return this._clock.getTicksAtTime(e)
                    }
                    getSecondsAtTime(e) {
                        return this._clock.getSecondsAtTime(e)
                    }
                    get PPQ() {
                        return this._clock.frequency.multiplier
                    }
                    set PPQ(e) {
                        this._clock.frequency.multiplier = e
                    }
                    nextSubdivision(e) {
                        if (e = this.toTicks(e),
                        this.state !== "started")
                            return 0;
                        {
                            const n = this.now()
                              , i = this.getTicksAtTime(n)
                              , a = e - i % e;
                            return this._clock.nextTickTime(a, n)
                        }
                    }
                    syncSignal(e, n) {
                        const i = this.now();
                        let a = this.bpm
                          , o = 1 / (60 / a.getValueAtTime(i) / this.PPQ)
                          , u = [];
                        if (e.units === "time") {
                            const d = .015625 / o
                              , p = new ki(d)
                              , g = new LF(-1)
                              , v = new ki(d);
                            a.chain(p, g, v),
                            a = v,
                            o = 1 / o,
                            u = [p, g, v]
                        }
                        n || (e.getValueAtTime(i) !== 0 ? n = e.getValueAtTime(i) / o : n = 0);
                        const f = new ki(n);
                        return a.connect(f),
                        f.connect(e._param),
                        u.push(f),
                        this._syncedSignals.push({
                            initial: e.value,
                            nodes: u,
                            signal: e
                        }),
                        e.value = 0,
                        this
                    }
                    unsyncSignal(e) {
                        for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
                            const i = this._syncedSignals[n];
                            i.signal === e && (i.nodes.forEach(a => a.dispose()),
                            i.signal.value = i.initial,
                            this._syncedSignals.splice(n, 1))
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._clock.dispose(),
                        Hw(this, "bpm"),
                        this._timeline.dispose(),
                        this._repeatedEvents.dispose(),
                        this
                    }
                }
                ;
                iT.mixin(jw),
                gS(t => {
                    t.transport = new jw({
                        context: t
                    })
                }
                ),
                vS(t => {
                    t.transport.dispose()
                }
                );
                var Ma = class extends dn {
                    constructor(t) {
                        super(t),
                        this.input = void 0,
                        this._state = new aT("stopped"),
                        this._synced = !1,
                        this._scheduled = [],
                        this._syncedStart = Xn,
                        this._syncedStop = Xn,
                        this._state.memory = 100,
                        this._state.increasing = !0,
                        this._volume = this.output = new SS({
                            context: this.context,
                            mute: t.mute,
                            volume: t.volume
                        }),
                        this.volume = this._volume.volume,
                        _i(this, "volume"),
                        this.onstop = t.onstop
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            mute: !1,
                            onstop: Xn,
                            volume: 0
                        })
                    }
                    get state() {
                        return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now())
                    }
                    get mute() {
                        return this._volume.mute
                    }
                    set mute(t) {
                        this._volume.mute = t
                    }
                    _clampToCurrentTime(t) {
                        return this._synced ? t : Math.max(t, this.context.currentTime)
                    }
                    start(t, e, n) {
                        let i = Fr(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
                        if (i = this._clampToCurrentTime(i),
                        !this._synced && this._state.getValueAtTime(i) === "started")
                            kt(Tp(i, this._state.get(i).time), "Start time must be strictly greater than previous start time"),
                            this._state.cancel(i),
                            this._state.setStateAtTime("started", i),
                            this.log("restart", i),
                            this.restart(i, e, n);
                        else if (this.log("start", i),
                        this._state.setStateAtTime("started", i),
                        this._synced) {
                            const a = this._state.get(i);
                            a && (a.offset = this.toSeconds(bp(e, 0)),
                            a.duration = n ? this.toSeconds(n) : void 0);
                            const o = this.context.transport.schedule(u => {
                                this._start(u, e, n)
                            }
                            , i);
                            this._scheduled.push(o),
                            this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > i && this._syncedStart(this.now(), this.context.transport.seconds)
                        } else
                            Uw(this.context),
                            this._start(i, e, n);
                        return this
                    }
                    stop(t) {
                        let e = Fr(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
                        if (e = this._clampToCurrentTime(e),
                        this._state.getValueAtTime(e) === "started" || Mn(this._state.getNextState("started", e))) {
                            if (this.log("stop", e),
                            !this._synced)
                                this._stop(e);
                            else {
                                const n = this.context.transport.schedule(this._stop.bind(this), e);
                                this._scheduled.push(n)
                            }
                            this._state.cancel(e),
                            this._state.setStateAtTime("stopped", e)
                        }
                        return this
                    }
                    restart(t, e, n) {
                        return t = this.toSeconds(t),
                        this._state.getValueAtTime(t) === "started" && (this._state.cancel(t),
                        this._restart(t, e, n)),
                        this
                    }
                    sync() {
                        return this._synced || (this._synced = !0,
                        this._syncedStart = (t, e) => {
                            if (Tp(e, 0)) {
                                const n = this._state.get(e);
                                if (n && n.state === "started" && n.time !== e) {
                                    const i = e - this.toSeconds(n.time);
                                    let a;
                                    n.duration && (a = this.toSeconds(n.duration) - i),
                                    this._start(t, this.toSeconds(n.offset) + i, a)
                                }
                            }
                        }
                        ,
                        this._syncedStop = t => {
                            const e = this.context.transport.getSecondsAtTime(Math.max(t - this.sampleTime, 0));
                            this._state.getValueAtTime(e) === "started" && this._stop(t)
                        }
                        ,
                        this.context.transport.on("start", this._syncedStart),
                        this.context.transport.on("loopStart", this._syncedStart),
                        this.context.transport.on("stop", this._syncedStop),
                        this.context.transport.on("pause", this._syncedStop),
                        this.context.transport.on("loopEnd", this._syncedStop)),
                        this
                    }
                    unsync() {
                        return this._synced && (this.context.transport.off("stop", this._syncedStop),
                        this.context.transport.off("pause", this._syncedStop),
                        this.context.transport.off("loopEnd", this._syncedStop),
                        this.context.transport.off("start", this._syncedStart),
                        this.context.transport.off("loopStart", this._syncedStart)),
                        this._synced = !1,
                        this._scheduled.forEach(t => this.context.transport.clear(t)),
                        this._scheduled = [],
                        this._state.cancel(0),
                        this._stop(0),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this.onstop = Xn,
                        this.unsync(),
                        this._volume.dispose(),
                        this._state.dispose(),
                        this
                    }
                }
                  , lT = class d3 extends Ap {
                    constructor() {
                        const e = Xt(d3.getDefaults(), arguments, ["url", "onload"]);
                        super(e),
                        this.name = "ToneBufferSource",
                        this._source = this.context.createBufferSource(),
                        this._internalChannels = [this._source],
                        this._sourceStarted = !1,
                        this._sourceStopped = !1,
                        bu(this._source, this._gainNode),
                        this._source.onended = () => this._stopSource(),
                        this.playbackRate = new es({
                            context: this.context,
                            param: this._source.playbackRate,
                            units: "positive",
                            value: e.playbackRate
                        }),
                        this.loop = e.loop,
                        this.loopStart = e.loopStart,
                        this.loopEnd = e.loopEnd,
                        this._buffer = new Eo(e.url,e.onload,e.onerror),
                        this._internalChannels.push(this._source)
                    }
                    static getDefaults() {
                        return Object.assign(Ap.getDefaults(), {
                            url: new Eo,
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            onload: Xn,
                            onerror: Xn,
                            playbackRate: 1
                        })
                    }
                    get fadeIn() {
                        return this._fadeIn
                    }
                    set fadeIn(e) {
                        this._fadeIn = e
                    }
                    get fadeOut() {
                        return this._fadeOut
                    }
                    set fadeOut(e) {
                        this._fadeOut = e
                    }
                    get curve() {
                        return this._curve
                    }
                    set curve(e) {
                        this._curve = e
                    }
                    start(e, n, i, a=1) {
                        kt(this.buffer.loaded, "buffer is either not set or not loaded");
                        const o = this.toSeconds(e);
                        this._startGain(o, a),
                        this.loop ? n = bp(n, this.loopStart) : n = bp(n, 0);
                        let u = Math.max(this.toSeconds(n), 0);
                        if (this.loop) {
                            const f = this.toSeconds(this.loopEnd) || this.buffer.duration
                              , d = this.toSeconds(this.loopStart)
                              , p = f - d;
                            nT(u, f) && (u = (u - d) % p + d),
                            Ao(u, this.buffer.duration) && (u = 0)
                        }
                        if (this._source.buffer = this.buffer.get(),
                        this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration,
                        mS(u, this.buffer.duration) && (this._sourceStarted = !0,
                        this._source.start(o, u)),
                        Mn(i)) {
                            let f = this.toSeconds(i);
                            f = Math.max(f, 0),
                            this.stop(o + f)
                        }
                        return this
                    }
                    _stopSource(e) {
                        !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0,
                        this._source.stop(this.toSeconds(e)),
                        this._onended())
                    }
                    get loopStart() {
                        return this._source.loopStart
                    }
                    set loopStart(e) {
                        this._source.loopStart = this.toSeconds(e)
                    }
                    get loopEnd() {
                        return this._source.loopEnd
                    }
                    set loopEnd(e) {
                        this._source.loopEnd = this.toSeconds(e)
                    }
                    get buffer() {
                        return this._buffer
                    }
                    set buffer(e) {
                        this._buffer.set(e)
                    }
                    get loop() {
                        return this._source.loop
                    }
                    set loop(e) {
                        this._source.loop = e,
                        this._sourceStarted && this.cancelStop()
                    }
                    dispose() {
                        return super.dispose(),
                        this._source.onended = null,
                        this._source.disconnect(),
                        this._buffer.dispose(),
                        this.playbackRate.dispose(),
                        this
                    }
                }
                  , Zw = class p3 extends Ma {
                    constructor() {
                        const e = Xt(p3.getDefaults(), arguments, ["type"]);
                        super(e),
                        this.name = "Noise",
                        this._source = null,
                        this._playbackRate = e.playbackRate,
                        this.type = e.type,
                        this._fadeIn = e.fadeIn,
                        this._fadeOut = e.fadeOut
                    }
                    static getDefaults() {
                        return Object.assign(Ma.getDefaults(), {
                            fadeIn: 0,
                            fadeOut: 0,
                            playbackRate: 1,
                            type: "white"
                        })
                    }
                    get type() {
                        return this._type
                    }
                    set type(e) {
                        if (kt(e in Qw, "Noise: invalid type: " + e),
                        this._type !== e && (this._type = e,
                        this.state === "started")) {
                            const n = this.now();
                            this._stop(n),
                            this._start(n)
                        }
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(e) {
                        this._playbackRate = e,
                        this._source && (this._source.playbackRate.value = e)
                    }
                    _start(e) {
                        const n = Qw[this._type];
                        this._source = new lT({
                            url: n,
                            context: this.context,
                            fadeIn: this._fadeIn,
                            fadeOut: this._fadeOut,
                            loop: !0,
                            onended: () => this.onstop(this),
                            playbackRate: this._playbackRate
                        }).connect(this.output),
                        this._source.start(this.toSeconds(e), Math.random() * (n.duration - .001))
                    }
                    _stop(e) {
                        this._source && (this._source.stop(this.toSeconds(e)),
                        this._source = null)
                    }
                    get fadeIn() {
                        return this._fadeIn
                    }
                    set fadeIn(e) {
                        this._fadeIn = e,
                        this._source && (this._source.fadeIn = this._fadeIn)
                    }
                    get fadeOut() {
                        return this._fadeOut
                    }
                    set fadeOut(e) {
                        this._fadeOut = e,
                        this._source && (this._source.fadeOut = this._fadeOut)
                    }
                    _restart(e) {
                        this._stop(e),
                        this._start(e)
                    }
                    dispose() {
                        return super.dispose(),
                        this._source && this._source.disconnect(),
                        this
                    }
                }
                ;
                const Cp = 44100 * 5
                  , cT = 2
                  , mc = {
                    brown: null,
                    pink: null,
                    white: null
                }
                  , Qw = {
                    get brown() {
                        if (!mc.brown) {
                            const t = [];
                            for (let e = 0; e < cT; e++) {
                                const n = new Float32Array(Cp);
                                t[e] = n;
                                let i = 0;
                                for (let a = 0; a < Cp; a++) {
                                    const o = Math.random() * 2 - 1;
                                    n[a] = (i + .02 * o) / 1.02,
                                    i = n[a],
                                    n[a] *= 3.5
                                }
                            }
                            mc.brown = new Eo().fromArray(t)
                        }
                        return mc.brown
                    },
                    get pink() {
                        if (!mc.pink) {
                            const t = [];
                            for (let e = 0; e < cT; e++) {
                                const n = new Float32Array(Cp);
                                t[e] = n;
                                let i, a, o, u, f, d, p;
                                i = a = o = u = f = d = p = 0;
                                for (let g = 0; g < Cp; g++) {
                                    const v = Math.random() * 2 - 1;
                                    i = .99886 * i + v * .0555179,
                                    a = .99332 * a + v * .0750759,
                                    o = .969 * o + v * .153852,
                                    u = .8665 * u + v * .3104856,
                                    f = .55 * f + v * .5329522,
                                    d = -.7616 * d - v * .016898,
                                    n[g] = i + a + o + u + f + d + p + v * .5362,
                                    n[g] *= .11,
                                    p = v * .115926
                                }
                            }
                            mc.pink = new Eo().fromArray(t)
                        }
                        return mc.pink
                    },
                    get white() {
                        if (!mc.white) {
                            const t = [];
                            for (let e = 0; e < cT; e++) {
                                const n = new Float32Array(Cp);
                                t[e] = n;
                                for (let i = 0; i < Cp; i++)
                                    n[i] = Math.random() * 2 - 1
                            }
                            mc.white = new Eo().fromArray(t)
                        }
                        return mc.white
                    }
                };
                function rf(t, e) {
                    return Gi(this, void 0, void 0, function*() {
                        const n = e / t.context.sampleRate
                          , i = new _S(1,n,t.context.sampleRate);
                        return new t.constructor(Object.assign(t.get(), {
                            frequency: 2 / n,
                            detune: 0,
                            context: i
                        })).toDestination().start(0),
                        (yield i.render()).getChannelData(0)
                    })
                }
                var zF = class m3 extends Ap {
                    constructor() {
                        const e = Xt(m3.getDefaults(), arguments, ["frequency", "type"]);
                        super(e),
                        this.name = "ToneOscillatorNode",
                        this._oscillator = this.context.createOscillator(),
                        this._internalChannels = [this._oscillator],
                        bu(this._oscillator, this._gainNode),
                        this.type = e.type,
                        this.frequency = new es({
                            context: this.context,
                            param: this._oscillator.frequency,
                            units: "frequency",
                            value: e.frequency
                        }),
                        this.detune = new es({
                            context: this.context,
                            param: this._oscillator.detune,
                            units: "cents",
                            value: e.detune
                        }),
                        _i(this, ["frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(Ap.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            type: "sine"
                        })
                    }
                    start(e) {
                        const n = this.toSeconds(e);
                        return this.log("start", n),
                        this._startGain(n),
                        this._oscillator.start(n),
                        this
                    }
                    _stopSource(e) {
                        this._oscillator.stop(e)
                    }
                    setPeriodicWave(e) {
                        return this._oscillator.setPeriodicWave(e),
                        this
                    }
                    get type() {
                        return this._oscillator.type
                    }
                    set type(e) {
                        this._oscillator.type = e
                    }
                    dispose() {
                        return super.dispose(),
                        this.state === "started" && this.stop(),
                        this._oscillator.disconnect(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this
                    }
                }
                  , cr = class of extends Ma {
                    constructor() {
                        const e = Xt(of.getDefaults(), arguments, ["frequency", "type"]);
                        super(e),
                        this.name = "Oscillator",
                        this._oscillator = null,
                        this.frequency = new Cs({
                            context: this.context,
                            units: "frequency",
                            value: e.frequency
                        }),
                        _i(this, "frequency"),
                        this.detune = new Cs({
                            context: this.context,
                            units: "cents",
                            value: e.detune
                        }),
                        _i(this, "detune"),
                        this._partials = e.partials,
                        this._partialCount = e.partialCount,
                        this._type = e.type,
                        e.partialCount && e.type !== "custom" && (this._type = this.baseType + e.partialCount.toString()),
                        this.phase = e.phase
                    }
                    static getDefaults() {
                        return Object.assign(Ma.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            partialCount: 0,
                            partials: [],
                            phase: 0,
                            type: "sine"
                        })
                    }
                    _start(e) {
                        const n = this.toSeconds(e);
                        this._oscillator = new zF({
                            context: this.context,
                            onended: () => this.onstop(this)
                        }),
                        this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type,
                        this._oscillator.connect(this.output),
                        this.frequency.connect(this._oscillator.frequency),
                        this.detune.connect(this._oscillator.detune),
                        this._oscillator.start(n)
                    }
                    _stop(e) {
                        const n = this.toSeconds(e);
                        this._oscillator && this._oscillator.stop(n)
                    }
                    _restart(e) {
                        const n = this.toSeconds(e);
                        return this.log("restart", n),
                        this._oscillator && this._oscillator.cancelStop(),
                        this._state.cancel(n),
                        this
                    }
                    syncFrequency() {
                        return this.context.transport.syncSignal(this.frequency),
                        this
                    }
                    unsyncFrequency() {
                        return this.context.transport.unsyncSignal(this.frequency),
                        this
                    }
                    _getCachedPeriodicWave() {
                        if (this._type === "custom")
                            return of._periodicWaveCache.find(e => e.phase === this._phase && oF(e.partials, this._partials));
                        {
                            const e = of._periodicWaveCache.find(n => n.type === this._type && n.phase === this._phase);
                            return this._partialCount = e ? e.partialCount : this._partialCount,
                            e
                        }
                    }
                    get type() {
                        return this._type
                    }
                    set type(e) {
                        this._type = e;
                        const n = ["sine", "square", "sawtooth", "triangle"].indexOf(e) !== -1;
                        if (this._phase === 0 && n)
                            this._wave = void 0,
                            this._partialCount = 0,
                            this._oscillator !== null && (this._oscillator.type = e);
                        else {
                            const i = this._getCachedPeriodicWave();
                            if (Mn(i)) {
                                const {partials: a, wave: o} = i;
                                this._wave = o,
                                this._partials = a,
                                this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave)
                            } else {
                                const [a,o] = this._getRealImaginary(e, this._phase);
                                this._wave = this.context.createPeriodicWave(a, o),
                                this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave),
                                of._periodicWaveCache.push({
                                    imag: o,
                                    partialCount: this._partialCount,
                                    partials: this._partials,
                                    phase: this._phase,
                                    real: a,
                                    type: this._type,
                                    wave: this._wave
                                }),
                                of._periodicWaveCache.length > 100 && of._periodicWaveCache.shift()
                            }
                        }
                    }
                    get baseType() {
                        return this._type.replace(this.partialCount.toString(), "")
                    }
                    set baseType(e) {
                        this.partialCount && this._type !== "custom" && e !== "custom" ? this.type = e + this.partialCount : this.type = e
                    }
                    get partialCount() {
                        return this._partialCount
                    }
                    set partialCount(e) {
                        Hr(e, 0);
                        let n = this._type;
                        const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
                        if (i && (n = i[1]),
                        this._type !== "custom")
                            e === 0 ? this.type = n : this.type = n + e.toString();
                        else {
                            const a = new Float32Array(e);
                            this._partials.forEach( (o, u) => a[u] = o),
                            this._partials = Array.from(a),
                            this.type = this._type
                        }
                    }
                    _getRealImaginary(e, n) {
                        let i = 2048;
                        const a = new Float32Array(i)
                          , o = new Float32Array(i);
                        let u = 1;
                        if (e === "custom") {
                            if (u = this._partials.length + 1,
                            this._partialCount = this._partials.length,
                            i = u,
                            this._partials.length === 0)
                                return [a, o]
                        } else {
                            const f = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(e);
                            f ? (u = parseInt(f[2], 10) + 1,
                            this._partialCount = parseInt(f[2], 10),
                            e = f[1],
                            u = Math.max(u, 2),
                            i = u) : this._partialCount = 0,
                            this._partials = []
                        }
                        for (let f = 1; f < i; ++f) {
                            const d = 2 / (f * Math.PI);
                            let p;
                            switch (e) {
                            case "sine":
                                p = f <= u ? 1 : 0,
                                this._partials[f - 1] = p;
                                break;
                            case "square":
                                p = f & 1 ? 2 * d : 0,
                                this._partials[f - 1] = p;
                                break;
                            case "sawtooth":
                                p = d * (f & 1 ? 1 : -1),
                                this._partials[f - 1] = p;
                                break;
                            case "triangle":
                                f & 1 ? p = 2 * (d * d) * (f - 1 >> 1 & 1 ? -1 : 1) : p = 0,
                                this._partials[f - 1] = p;
                                break;
                            case "custom":
                                p = this._partials[f - 1];
                                break;
                            default:
                                throw new TypeError("Oscillator: invalid type: " + e)
                            }
                            p !== 0 ? (a[f] = -p * Math.sin(n * f),
                            o[f] = p * Math.cos(n * f)) : (a[f] = 0,
                            o[f] = 0)
                        }
                        return [a, o]
                    }
                    _inverseFFT(e, n, i) {
                        let a = 0;
                        const o = e.length;
                        for (let u = 0; u < o; u++)
                            a += e[u] * Math.cos(u * i) + n[u] * Math.sin(u * i);
                        return a
                    }
                    getInitialValue() {
                        const [e,n] = this._getRealImaginary(this._type, 0);
                        let i = 0;
                        const a = Math.PI * 2
                          , o = 32;
                        for (let u = 0; u < o; u++)
                            i = Math.max(this._inverseFFT(e, n, u / o * a), i);
                        return cF(-this._inverseFFT(e, n, this._phase) / i, -1, 1)
                    }
                    get partials() {
                        return this._partials.slice(0, this.partialCount)
                    }
                    set partials(e) {
                        this._partials = e,
                        this._partialCount = this._partials.length,
                        e.length && (this.type = "custom")
                    }
                    get phase() {
                        return this._phase * (180 / Math.PI)
                    }
                    set phase(e) {
                        this._phase = e * Math.PI / 180,
                        this.type = this._type
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._oscillator !== null && this._oscillator.dispose(),
                        this._wave = void 0,
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this
                    }
                }
                ;
                cr._periodicWaveCache = [];
                var BF = class extends uv {
                    constructor() {
                        super(...arguments),
                        this.name = "AudioToGain",
                        this._norm = new xS({
                            context: this.context,
                            mapping: t => (t + 1) / 2
                        }),
                        this.input = this._norm,
                        this.output = this._norm
                    }
                    dispose() {
                        return super.dispose(),
                        this._norm.dispose(),
                        this
                    }
                }
                  , MS = class g3 extends Cs {
                    constructor() {
                        const e = Xt(g3.getDefaults(), arguments, ["value"]);
                        super(e),
                        this.name = "Multiply",
                        this.override = !1,
                        this._mult = this.input = this.output = new ki({
                            context: this.context,
                            minValue: e.minValue,
                            maxValue: e.maxValue
                        }),
                        this.factor = this._param = this._mult.gain,
                        this.factor.setValueAtTime(e.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(Cs.getDefaults(), {
                            value: 0
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._mult.dispose(),
                        this
                    }
                }
                  , Kw = class v3 extends Ma {
                    constructor() {
                        const e = Xt(v3.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
                        super(e),
                        this.name = "AMOscillator",
                        this._modulationScale = new BF({
                            context: this.context
                        }),
                        this._modulationNode = new ki({
                            context: this.context
                        }),
                        this._carrier = new cr({
                            context: this.context,
                            detune: e.detune,
                            frequency: e.frequency,
                            onstop: () => this.onstop(this),
                            phase: e.phase,
                            type: e.type
                        }),
                        this.frequency = this._carrier.frequency,
                        this.detune = this._carrier.detune,
                        this._modulator = new cr({
                            context: this.context,
                            phase: e.phase,
                            type: e.modulationType
                        }),
                        this.harmonicity = new MS({
                            context: this.context,
                            units: "positive",
                            value: e.harmonicity
                        }),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this._modulator.chain(this._modulationScale, this._modulationNode.gain),
                        this._carrier.chain(this._modulationNode, this.output),
                        _i(this, ["frequency", "detune", "harmonicity"])
                    }
                    static getDefaults() {
                        return Object.assign(cr.getDefaults(), {
                            harmonicity: 1,
                            modulationType: "square"
                        })
                    }
                    _start(e) {
                        this._modulator.start(e),
                        this._carrier.start(e)
                    }
                    _stop(e) {
                        this._modulator.stop(e),
                        this._carrier.stop(e)
                    }
                    _restart(e) {
                        this._modulator.restart(e),
                        this._carrier.restart(e)
                    }
                    get type() {
                        return this._carrier.type
                    }
                    set type(e) {
                        this._carrier.type = e
                    }
                    get baseType() {
                        return this._carrier.baseType
                    }
                    set baseType(e) {
                        this._carrier.baseType = e
                    }
                    get partialCount() {
                        return this._carrier.partialCount
                    }
                    set partialCount(e) {
                        this._carrier.partialCount = e
                    }
                    get modulationType() {
                        return this._modulator.type
                    }
                    set modulationType(e) {
                        this._modulator.type = e
                    }
                    get phase() {
                        return this._carrier.phase
                    }
                    set phase(e) {
                        this._carrier.phase = e,
                        this._modulator.phase = e
                    }
                    get partials() {
                        return this._carrier.partials
                    }
                    set partials(e) {
                        this._carrier.partials = e
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this.harmonicity.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this._modulationNode.dispose(),
                        this._modulationScale.dispose(),
                        this
                    }
                }
                  , Jw = class _3 extends Ma {
                    constructor() {
                        const e = Xt(_3.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
                        super(e),
                        this.name = "FMOscillator",
                        this._modulationNode = new ki({
                            context: this.context,
                            gain: 0
                        }),
                        this._carrier = new cr({
                            context: this.context,
                            detune: e.detune,
                            frequency: 0,
                            onstop: () => this.onstop(this),
                            phase: e.phase,
                            type: e.type
                        }),
                        this.detune = this._carrier.detune,
                        this.frequency = new Cs({
                            context: this.context,
                            units: "frequency",
                            value: e.frequency
                        }),
                        this._modulator = new cr({
                            context: this.context,
                            phase: e.phase,
                            type: e.modulationType
                        }),
                        this.harmonicity = new MS({
                            context: this.context,
                            units: "positive",
                            value: e.harmonicity
                        }),
                        this.modulationIndex = new MS({
                            context: this.context,
                            units: "positive",
                            value: e.modulationIndex
                        }),
                        this.frequency.connect(this._carrier.frequency),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this.frequency.chain(this.modulationIndex, this._modulationNode),
                        this._modulator.connect(this._modulationNode.gain),
                        this._modulationNode.connect(this._carrier.frequency),
                        this._carrier.connect(this.output),
                        this.detune.connect(this._modulator.detune),
                        _i(this, ["modulationIndex", "frequency", "detune", "harmonicity"])
                    }
                    static getDefaults() {
                        return Object.assign(cr.getDefaults(), {
                            harmonicity: 1,
                            modulationIndex: 2,
                            modulationType: "square"
                        })
                    }
                    _start(e) {
                        this._modulator.start(e),
                        this._carrier.start(e)
                    }
                    _stop(e) {
                        this._modulator.stop(e),
                        this._carrier.stop(e)
                    }
                    _restart(e) {
                        return this._modulator.restart(e),
                        this._carrier.restart(e),
                        this
                    }
                    get type() {
                        return this._carrier.type
                    }
                    set type(e) {
                        this._carrier.type = e
                    }
                    get baseType() {
                        return this._carrier.baseType
                    }
                    set baseType(e) {
                        this._carrier.baseType = e
                    }
                    get partialCount() {
                        return this._carrier.partialCount
                    }
                    set partialCount(e) {
                        this._carrier.partialCount = e
                    }
                    get modulationType() {
                        return this._modulator.type
                    }
                    set modulationType(e) {
                        this._modulator.type = e
                    }
                    get phase() {
                        return this._carrier.phase
                    }
                    set phase(e) {
                        this._carrier.phase = e,
                        this._modulator.phase = e
                    }
                    get partials() {
                        return this._carrier.partials
                    }
                    set partials(e) {
                        this._carrier.partials = e
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.harmonicity.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this._modulationNode.dispose(),
                        this.modulationIndex.dispose(),
                        this
                    }
                }
                  , uT = class y3 extends Ma {
                    constructor() {
                        const e = Xt(y3.getDefaults(), arguments, ["frequency", "width"]);
                        super(e),
                        this.name = "PulseOscillator",
                        this._widthGate = new ki({
                            context: this.context,
                            gain: 0
                        }),
                        this._thresh = new xS({
                            context: this.context,
                            mapping: n => n <= 0 ? -1 : 1
                        }),
                        this.width = new Cs({
                            context: this.context,
                            units: "audioRange",
                            value: e.width
                        }),
                        this._triangle = new cr({
                            context: this.context,
                            detune: e.detune,
                            frequency: e.frequency,
                            onstop: () => this.onstop(this),
                            phase: e.phase,
                            type: "triangle"
                        }),
                        this.frequency = this._triangle.frequency,
                        this.detune = this._triangle.detune,
                        this._triangle.chain(this._thresh, this.output),
                        this.width.chain(this._widthGate, this._thresh),
                        _i(this, ["width", "frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(Ma.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            phase: 0,
                            type: "pulse",
                            width: .2
                        })
                    }
                    _start(e) {
                        e = this.toSeconds(e),
                        this._triangle.start(e),
                        this._widthGate.gain.setValueAtTime(1, e)
                    }
                    _stop(e) {
                        e = this.toSeconds(e),
                        this._triangle.stop(e),
                        this._widthGate.gain.cancelScheduledValues(e),
                        this._widthGate.gain.setValueAtTime(0, e)
                    }
                    _restart(e) {
                        this._triangle.restart(e),
                        this._widthGate.gain.cancelScheduledValues(e),
                        this._widthGate.gain.setValueAtTime(1, e)
                    }
                    get phase() {
                        return this._triangle.phase
                    }
                    set phase(e) {
                        this._triangle.phase = e
                    }
                    get type() {
                        return "pulse"
                    }
                    get baseType() {
                        return "pulse"
                    }
                    get partials() {
                        return []
                    }
                    get partialCount() {
                        return 0
                    }
                    set carrierType(e) {
                        this._triangle.type = e
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._triangle.dispose(),
                        this.width.dispose(),
                        this._widthGate.dispose(),
                        this._thresh.dispose(),
                        this
                    }
                }
                  , $w = class S3 extends Ma {
                    constructor() {
                        const e = Xt(S3.getDefaults(), arguments, ["frequency", "type", "spread"]);
                        super(e),
                        this.name = "FatOscillator",
                        this._oscillators = [],
                        this.frequency = new Cs({
                            context: this.context,
                            units: "frequency",
                            value: e.frequency
                        }),
                        this.detune = new Cs({
                            context: this.context,
                            units: "cents",
                            value: e.detune
                        }),
                        this._spread = e.spread,
                        this._type = e.type,
                        this._phase = e.phase,
                        this._partials = e.partials,
                        this._partialCount = e.partialCount,
                        this.count = e.count,
                        _i(this, ["frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(cr.getDefaults(), {
                            count: 3,
                            spread: 20,
                            type: "sawtooth"
                        })
                    }
                    _start(e) {
                        e = this.toSeconds(e),
                        this._forEach(n => n.start(e))
                    }
                    _stop(e) {
                        e = this.toSeconds(e),
                        this._forEach(n => n.stop(e))
                    }
                    _restart(e) {
                        this._forEach(n => n.restart(e))
                    }
                    _forEach(e) {
                        for (let n = 0; n < this._oscillators.length; n++)
                            e(this._oscillators[n], n)
                    }
                    get type() {
                        return this._type
                    }
                    set type(e) {
                        this._type = e,
                        this._forEach(n => n.type = e)
                    }
                    get spread() {
                        return this._spread
                    }
                    set spread(e) {
                        if (this._spread = e,
                        this._oscillators.length > 1) {
                            const n = -e / 2
                              , i = e / (this._oscillators.length - 1);
                            this._forEach( (a, o) => a.detune.value = n + i * o)
                        }
                    }
                    get count() {
                        return this._oscillators.length
                    }
                    set count(e) {
                        if (Hr(e, 1),
                        this._oscillators.length !== e) {
                            this._forEach(n => n.dispose()),
                            this._oscillators = [];
                            for (let n = 0; n < e; n++) {
                                const i = new cr({
                                    context: this.context,
                                    volume: -6 - e * 1.1,
                                    type: this._type,
                                    phase: this._phase + n / e * 360,
                                    partialCount: this._partialCount,
                                    onstop: n === 0 ? () => this.onstop(this) : Xn
                                });
                                this.type === "custom" && (i.partials = this._partials),
                                this.frequency.connect(i.frequency),
                                this.detune.connect(i.detune),
                                i.detune.overridden = !1,
                                i.connect(this.output),
                                this._oscillators[n] = i
                            }
                            this.spread = this._spread,
                            this.state === "started" && this._forEach(n => n.start())
                        }
                    }
                    get phase() {
                        return this._phase
                    }
                    set phase(e) {
                        this._phase = e,
                        this._forEach( (n, i) => n.phase = this._phase + i / this.count * 360)
                    }
                    get baseType() {
                        return this._oscillators[0].baseType
                    }
                    set baseType(e) {
                        this._forEach(n => n.baseType = e),
                        this._type = this._oscillators[0].type
                    }
                    get partials() {
                        return this._oscillators[0].partials
                    }
                    set partials(e) {
                        this._partials = e,
                        this._partialCount = this._partials.length,
                        e.length && (this._type = "custom",
                        this._forEach(n => n.partials = e))
                    }
                    get partialCount() {
                        return this._oscillators[0].partialCount
                    }
                    set partialCount(e) {
                        this._partialCount = e,
                        this._forEach(n => n.partialCount = e),
                        this._type = this._oscillators[0].type
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this._forEach(e => e.dispose()),
                        this
                    }
                }
                  , eR = class x3 extends Ma {
                    constructor() {
                        const e = Xt(x3.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
                        super(e),
                        this.name = "PWMOscillator",
                        this.sourceType = "pwm",
                        this._scale = new MS({
                            context: this.context,
                            value: 2
                        }),
                        this._pulse = new uT({
                            context: this.context,
                            frequency: e.modulationFrequency
                        }),
                        this._pulse.carrierType = "sine",
                        this.modulationFrequency = this._pulse.frequency,
                        this._modulator = new cr({
                            context: this.context,
                            detune: e.detune,
                            frequency: e.frequency,
                            onstop: () => this.onstop(this),
                            phase: e.phase
                        }),
                        this.frequency = this._modulator.frequency,
                        this.detune = this._modulator.detune,
                        this._modulator.chain(this._scale, this._pulse.width),
                        this._pulse.connect(this.output),
                        _i(this, ["modulationFrequency", "frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(Ma.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            modulationFrequency: .4,
                            phase: 0,
                            type: "pwm"
                        })
                    }
                    _start(e) {
                        e = this.toSeconds(e),
                        this._modulator.start(e),
                        this._pulse.start(e)
                    }
                    _stop(e) {
                        e = this.toSeconds(e),
                        this._modulator.stop(e),
                        this._pulse.stop(e)
                    }
                    _restart(e) {
                        this._modulator.restart(e),
                        this._pulse.restart(e)
                    }
                    get type() {
                        return "pwm"
                    }
                    get baseType() {
                        return "pwm"
                    }
                    get partials() {
                        return []
                    }
                    get partialCount() {
                        return 0
                    }
                    get phase() {
                        return this._modulator.phase
                    }
                    set phase(e) {
                        this._modulator.phase = e
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._pulse.dispose(),
                        this._scale.dispose(),
                        this._modulator.dispose(),
                        this
                    }
                }
                ;
                const tR = {
                    am: Kw,
                    fat: $w,
                    fm: Jw,
                    oscillator: cr,
                    pulse: uT,
                    pwm: eR
                };
                var nR = class M3 extends Ma {
                    constructor() {
                        const e = Xt(M3.getDefaults(), arguments, ["frequency", "type"]);
                        super(e),
                        this.name = "OmniOscillator",
                        this.frequency = new Cs({
                            context: this.context,
                            units: "frequency",
                            value: e.frequency
                        }),
                        this.detune = new Cs({
                            context: this.context,
                            units: "cents",
                            value: e.detune
                        }),
                        _i(this, ["frequency", "detune"]),
                        this.set(e)
                    }
                    static getDefaults() {
                        return Object.assign(cr.getDefaults(), Jw.getDefaults(), Kw.getDefaults(), $w.getDefaults(), uT.getDefaults(), eR.getDefaults())
                    }
                    _start(e) {
                        this._oscillator.start(e)
                    }
                    _stop(e) {
                        this._oscillator.stop(e)
                    }
                    _restart(e) {
                        return this._oscillator.restart(e),
                        this
                    }
                    get type() {
                        let e = "";
                        return ["am", "fm", "fat"].some(n => this._sourceType === n) && (e = this._sourceType),
                        e + this._oscillator.type
                    }
                    set type(e) {
                        e.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = e.substr(2)) : e.substr(0, 2) === "am" ? (this._createNewOscillator("am"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = e.substr(2)) : e.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = e.substr(3)) : e === "pwm" ? (this._createNewOscillator("pwm"),
                        this._oscillator = this._oscillator) : e === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = e)
                    }
                    get partials() {
                        return this._oscillator.partials
                    }
                    set partials(e) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = e)
                    }
                    get partialCount() {
                        return this._oscillator.partialCount
                    }
                    set partialCount(e) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = e)
                    }
                    set(e) {
                        return Reflect.has(e, "type") && e.type && (this.type = e.type),
                        super.set(e),
                        this
                    }
                    _createNewOscillator(e) {
                        if (e !== this._sourceType) {
                            this._sourceType = e;
                            const n = tR[e]
                              , i = this.now();
                            if (this._oscillator) {
                                const a = this._oscillator;
                                a.stop(i),
                                this.context.setTimeout( () => a.dispose(), this.blockTime)
                            }
                            this._oscillator = new n({
                                context: this.context
                            }),
                            this.frequency.connect(this._oscillator.frequency),
                            this.detune.connect(this._oscillator.detune),
                            this._oscillator.connect(this.output),
                            this._oscillator.onstop = () => this.onstop(this),
                            this.state === "started" && this._oscillator.start(i)
                        }
                    }
                    get phase() {
                        return this._oscillator.phase
                    }
                    set phase(e) {
                        this._oscillator.phase = e
                    }
                    get sourceType() {
                        return this._sourceType
                    }
                    set sourceType(e) {
                        let n = "sine";
                        this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type),
                        e === "fm" ? this.type = "fm" + n : e === "am" ? this.type = "am" + n : e === "fat" ? this.type = "fat" + n : e === "oscillator" ? this.type = n : e === "pulse" ? this.type = "pulse" : e === "pwm" && (this.type = "pwm")
                    }
                    _getOscType(e, n) {
                        return e instanceof tR[n]
                    }
                    get baseType() {
                        return this._oscillator.baseType
                    }
                    set baseType(e) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && e !== "pulse" && e !== "pwm" && (this._oscillator.baseType = e)
                    }
                    get width() {
                        if (this._getOscType(this._oscillator, "pulse"))
                            return this._oscillator.width
                    }
                    get count() {
                        if (this._getOscType(this._oscillator, "fat"))
                            return this._oscillator.count
                    }
                    set count(e) {
                        this._getOscType(this._oscillator, "fat") && Su(e) && (this._oscillator.count = e)
                    }
                    get spread() {
                        if (this._getOscType(this._oscillator, "fat"))
                            return this._oscillator.spread
                    }
                    set spread(e) {
                        this._getOscType(this._oscillator, "fat") && Su(e) && (this._oscillator.spread = e)
                    }
                    get modulationType() {
                        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
                            return this._oscillator.modulationType
                    }
                    set modulationType(e) {
                        (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && dc(e) && (this._oscillator.modulationType = e)
                    }
                    get modulationIndex() {
                        if (this._getOscType(this._oscillator, "fm"))
                            return this._oscillator.modulationIndex
                    }
                    get harmonicity() {
                        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
                            return this._oscillator.harmonicity
                    }
                    get modulationFrequency() {
                        if (this._getOscType(this._oscillator, "pwm"))
                            return this._oscillator.modulationFrequency
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            return rf(this, e)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.detune.dispose(),
                        this.frequency.dispose(),
                        this._oscillator.dispose(),
                        this
                    }
                }
                ;
                function iR(t, e=1 / 0) {
                    const n = new WeakMap;
                    return function(i, a) {
                        Reflect.defineProperty(i, a, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return n.get(this)
                            },
                            set: function(o) {
                                Hr(o, t, e),
                                n.set(this, o)
                            }
                        })
                    }
                }
                function gc(t, e=1 / 0) {
                    const n = new WeakMap;
                    return function(i, a) {
                        Reflect.defineProperty(i, a, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return n.get(this)
                            },
                            set: function(o) {
                                Hr(this.toSeconds(o), t, e),
                                n.set(this, o)
                            }
                        })
                    }
                }
                var sR = class b3 extends Ma {
                    constructor() {
                        const e = Xt(b3.getDefaults(), arguments, ["url", "onload"]);
                        super(e),
                        this.name = "Player",
                        this._activeSources = new Set,
                        this._buffer = new Eo({
                            onload: this._onload.bind(this, e.onload),
                            onerror: e.onerror,
                            reverse: e.reverse,
                            url: e.url
                        }),
                        this.autostart = e.autostart,
                        this._loop = e.loop,
                        this._loopStart = e.loopStart,
                        this._loopEnd = e.loopEnd,
                        this._playbackRate = e.playbackRate,
                        this.fadeIn = e.fadeIn,
                        this.fadeOut = e.fadeOut
                    }
                    static getDefaults() {
                        return Object.assign(Ma.getDefaults(), {
                            autostart: !1,
                            fadeIn: 0,
                            fadeOut: 0,
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            onload: Xn,
                            onerror: Xn,
                            playbackRate: 1,
                            reverse: !1
                        })
                    }
                    load(e) {
                        return Gi(this, void 0, void 0, function*() {
                            return yield this._buffer.load(e),
                            this._onload(),
                            this
                        })
                    }
                    _onload(e=Xn) {
                        e(),
                        this.autostart && this.start()
                    }
                    _onSourceEnd(e) {
                        this.onstop(this),
                        this._activeSources.delete(e),
                        this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()),
                        this._state.setStateAtTime("stopped", this.now()))
                    }
                    start(e, n, i) {
                        return super.start(e, n, i),
                        this
                    }
                    _start(e, n, i) {
                        this._loop ? n = bp(n, this._loopStart) : n = bp(n, 0);
                        const a = this.toSeconds(n)
                          , o = i;
                        i = bp(i, Math.max(this._buffer.duration - a, 0));
                        let u = this.toSeconds(i);
                        u = u / this._playbackRate,
                        e = this.toSeconds(e);
                        const f = new lT({
                            url: this._buffer,
                            context: this.context,
                            fadeIn: this.fadeIn,
                            fadeOut: this.fadeOut,
                            loop: this._loop,
                            loopEnd: this._loopEnd,
                            loopStart: this._loopStart,
                            onended: this._onSourceEnd.bind(this),
                            playbackRate: this._playbackRate
                        }).connect(this.output);
                        !this._loop && !this._synced && (this._state.cancel(e + u),
                        this._state.setStateAtTime("stopped", e + u, {
                            implicitEnd: !0
                        })),
                        this._activeSources.add(f),
                        this._loop && Fr(o) ? f.start(e, a) : f.start(e, a, u - this.toSeconds(this.fadeOut))
                    }
                    _stop(e) {
                        const n = this.toSeconds(e);
                        this._activeSources.forEach(i => i.stop(n))
                    }
                    restart(e, n, i) {
                        return super.restart(e, n, i),
                        this
                    }
                    _restart(e, n, i) {
                        var a;
                        (a = [...this._activeSources].pop()) === null || a === void 0 || a.stop(e),
                        this._start(e, n, i)
                    }
                    seek(e, n) {
                        const i = this.toSeconds(n);
                        if (this._state.getValueAtTime(i) === "started") {
                            const a = this.toSeconds(e);
                            this._stop(i),
                            this._start(i, a)
                        }
                        return this
                    }
                    setLoopPoints(e, n) {
                        return this.loopStart = e,
                        this.loopEnd = n,
                        this
                    }
                    get loopStart() {
                        return this._loopStart
                    }
                    set loopStart(e) {
                        this._loopStart = e,
                        this.buffer.loaded && Hr(this.toSeconds(e), 0, this.buffer.duration),
                        this._activeSources.forEach(n => {
                            n.loopStart = e
                        }
                        )
                    }
                    get loopEnd() {
                        return this._loopEnd
                    }
                    set loopEnd(e) {
                        this._loopEnd = e,
                        this.buffer.loaded && Hr(this.toSeconds(e), 0, this.buffer.duration),
                        this._activeSources.forEach(n => {
                            n.loopEnd = e
                        }
                        )
                    }
                    get buffer() {
                        return this._buffer
                    }
                    set buffer(e) {
                        this._buffer.set(e)
                    }
                    get loop() {
                        return this._loop
                    }
                    set loop(e) {
                        if (this._loop !== e && (this._loop = e,
                        this._activeSources.forEach(n => {
                            n.loop = e
                        }
                        ),
                        e)) {
                            const n = this._state.getNextState("stopped", this.now());
                            n && this._state.cancel(n.time)
                        }
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(e) {
                        this._playbackRate = e;
                        const n = this.now()
                          , i = this._state.getNextState("stopped", n);
                        i && i.implicitEnd && (this._state.cancel(i.time),
                        this._activeSources.forEach(a => a.cancelStop())),
                        this._activeSources.forEach(a => {
                            a.playbackRate.setValueAtTime(e, n)
                        }
                        )
                    }
                    get reverse() {
                        return this._buffer.reverse
                    }
                    set reverse(e) {
                        this._buffer.reverse = e
                    }
                    get loaded() {
                        return this._buffer.loaded
                    }
                    dispose() {
                        return super.dispose(),
                        this._activeSources.forEach(e => e.dispose()),
                        this._activeSources.clear(),
                        this._buffer.dispose(),
                        this
                    }
                }
                ;
                To([gc(0)], sR.prototype, "fadeIn", void 0),
                To([gc(0)], sR.prototype, "fadeOut", void 0);
                var PF = class extends uv {
                    constructor() {
                        super(...arguments),
                        this.name = "GainToAudio",
                        this._norm = new xS({
                            context: this.context,
                            mapping: t => Math.abs(t) * 2 - 1
                        }),
                        this.input = this._norm,
                        this.output = this._norm
                    }
                    dispose() {
                        return super.dispose(),
                        this._norm.dispose(),
                        this
                    }
                }
                  , wp = class T3 extends dn {
                    constructor() {
                        const e = Xt(T3.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
                        super(e),
                        this.name = "Envelope",
                        this._sig = new Cs({
                            context: this.context,
                            value: 0
                        }),
                        this.output = this._sig,
                        this.input = void 0,
                        this.attack = e.attack,
                        this.decay = e.decay,
                        this.sustain = e.sustain,
                        this.release = e.release,
                        this.attackCurve = e.attackCurve,
                        this.releaseCurve = e.releaseCurve,
                        this.decayCurve = e.decayCurve
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            attack: .01,
                            attackCurve: "linear",
                            decay: .1,
                            decayCurve: "exponential",
                            release: 1,
                            releaseCurve: "exponential",
                            sustain: .5
                        })
                    }
                    get value() {
                        return this.getValueAtTime(this.now())
                    }
                    _getCurve(e, n) {
                        if (dc(e))
                            return e;
                        {
                            let i;
                            for (i in bS)
                                if (bS[i][n] === e)
                                    return i;
                            return e
                        }
                    }
                    _setCurve(e, n, i) {
                        if (dc(i) && Reflect.has(bS, i)) {
                            const a = bS[i];
                            $h(a) ? e !== "_decayCurve" && (this[e] = a[n]) : this[e] = a
                        } else if (or(i) && e !== "_decayCurve")
                            this[e] = i;
                        else
                            throw new Error("Envelope: invalid curve: " + i)
                    }
                    get attackCurve() {
                        return this._getCurve(this._attackCurve, "In")
                    }
                    set attackCurve(e) {
                        this._setCurve("_attackCurve", "In", e)
                    }
                    get releaseCurve() {
                        return this._getCurve(this._releaseCurve, "Out")
                    }
                    set releaseCurve(e) {
                        this._setCurve("_releaseCurve", "Out", e)
                    }
                    get decayCurve() {
                        return this._getCurve(this._decayCurve, "Out")
                    }
                    set decayCurve(e) {
                        this._setCurve("_decayCurve", "Out", e)
                    }
                    triggerAttack(e, n=1) {
                        this.log("triggerAttack", e, n),
                        e = this.toSeconds(e);
                        let i = this.toSeconds(this.attack);
                        const a = this.toSeconds(this.decay)
                          , o = this.getValueAtTime(e);
                        if (o > 0) {
                            const u = 1 / i;
                            i = (1 - o) / u
                        }
                        if (i < this.sampleTime)
                            this._sig.cancelScheduledValues(e),
                            this._sig.setValueAtTime(n, e);
                        else if (this._attackCurve === "linear")
                            this._sig.linearRampTo(n, i, e);
                        else if (this._attackCurve === "exponential")
                            this._sig.targetRampTo(n, i, e);
                        else {
                            this._sig.cancelAndHoldAtTime(e);
                            let u = this._attackCurve;
                            for (let f = 1; f < u.length; f++)
                                if (u[f - 1] <= o && o <= u[f]) {
                                    u = this._attackCurve.slice(f),
                                    u[0] = o;
                                    break
                                }
                            this._sig.setValueCurveAtTime(u, e, i, n)
                        }
                        if (a && this.sustain < 1) {
                            const u = n * this.sustain
                              , f = e + i;
                            this.log("decay", f),
                            this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(u, a + f) : this._sig.exponentialApproachValueAtTime(u, f, a)
                        }
                        return this
                    }
                    triggerRelease(e) {
                        this.log("triggerRelease", e),
                        e = this.toSeconds(e);
                        const n = this.getValueAtTime(e);
                        if (n > 0) {
                            const i = this.toSeconds(this.release);
                            i < this.sampleTime ? this._sig.setValueAtTime(0, e) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, i, e) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, i, e) : (kt(or(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"),
                            this._sig.cancelAndHoldAtTime(e),
                            this._sig.setValueCurveAtTime(this._releaseCurve, e, i, n))
                        }
                        return this
                    }
                    getValueAtTime(e) {
                        return this._sig.getValueAtTime(e)
                    }
                    triggerAttackRelease(e, n, i=1) {
                        return n = this.toSeconds(n),
                        this.triggerAttack(n, i),
                        this.triggerRelease(n + this.toSeconds(e)),
                        this
                    }
                    cancel(e) {
                        return this._sig.cancelScheduledValues(this.toSeconds(e)),
                        this
                    }
                    connect(e, n=0, i=0) {
                        return oT(this, e, n, i),
                        this
                    }
                    asArray() {
                        return Gi(this, arguments, void 0, function*(e=1024) {
                            const n = e / this.context.sampleRate
                              , i = new _S(1,n,this.context.sampleRate)
                              , a = this.toSeconds(this.attack) + this.toSeconds(this.decay)
                              , o = a + this.toSeconds(this.release)
                              , u = o * .1
                              , f = o + u
                              , d = new this.constructor(Object.assign(this.get(), {
                                attack: n * this.toSeconds(this.attack) / f,
                                decay: n * this.toSeconds(this.decay) / f,
                                release: n * this.toSeconds(this.release) / f,
                                context: i
                            }));
                            return d._sig.toDestination(),
                            d.triggerAttackRelease(n * (a + u) / f, 0),
                            (yield i.render()).getChannelData(0)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._sig.dispose(),
                        this
                    }
                }
                ;
                To([gc(0)], wp.prototype, "attack", void 0),
                To([gc(0)], wp.prototype, "decay", void 0),
                To([iR(0, 1)], wp.prototype, "sustain", void 0),
                To([gc(0)], wp.prototype, "release", void 0);
                const bS = ( () => {
                    let e, n;
                    const i = [];
                    for (e = 0; e < 128; e++)
                        i[e] = Math.sin(e / 127 * (Math.PI / 2));
                    const a = []
                      , o = 6.4;
                    for (e = 0; e < 127; e++)
                        n = e / 127,
                        a[e] = (Math.sin(n * (Math.PI * 2) * o - Math.PI / 2) + 1) / 10 + n * .83;
                    a[127] = 1;
                    const u = []
                      , f = 5;
                    for (e = 0; e < 128; e++)
                        u[e] = Math.ceil(e / 127 * f) / f;
                    const d = [];
                    for (e = 0; e < 128; e++)
                        n = e / 127,
                        d[e] = .5 * (1 - Math.cos(Math.PI * n));
                    const p = [];
                    for (e = 0; e < 128; e++) {
                        n = e / 127;
                        const y = Math.pow(n, 3) * 4 + .2
                          , S = Math.cos(y * Math.PI * 2 * n);
                        p[e] = Math.abs(S * (1 - n))
                    }
                    function g(y) {
                        const S = new Array(y.length);
                        for (let E = 0; E < y.length; E++)
                            S[E] = 1 - y[E];
                        return S
                    }
                    function v(y) {
                        return y.slice(0).reverse()
                    }
                    return {
                        bounce: {
                            In: g(p),
                            Out: p
                        },
                        cosine: {
                            In: i,
                            Out: v(i)
                        },
                        exponential: "exponential",
                        linear: "linear",
                        ripple: {
                            In: a,
                            Out: g(a)
                        },
                        sine: {
                            In: d,
                            Out: g(d)
                        },
                        step: {
                            In: u,
                            Out: g(u)
                        }
                    }
                }
                )();
                var Rp = class A3 extends dn {
                    constructor() {
                        const e = Xt(A3.getDefaults(), arguments);
                        super(e),
                        this._scheduledEvents = [],
                        this._synced = !1,
                        this._original_triggerAttack = this.triggerAttack,
                        this._original_triggerRelease = this.triggerRelease,
                        this._syncedRelease = n => this._original_triggerRelease(n),
                        this._volume = this.output = new SS({
                            context: this.context,
                            volume: e.volume
                        }),
                        this.volume = this._volume.volume,
                        _i(this, "volume")
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            volume: 0
                        })
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 0),
                        this.context.transport.on("stop", this._syncedRelease),
                        this.context.transport.on("pause", this._syncedRelease),
                        this.context.transport.on("loopEnd", this._syncedRelease)),
                        this
                    }
                    _syncState() {
                        let e = !1;
                        return this._synced || (this._synced = !0,
                        e = !0),
                        e
                    }
                    _syncMethod(e, n) {
                        const i = this["_original_" + e] = this[e];
                        this[e] = (...a) => {
                            const o = a[n]
                              , u = this.context.transport.schedule(f => {
                                a[n] = f,
                                i.apply(this, a)
                            }
                            , o);
                            this._scheduledEvents.push(u)
                        }
                    }
                    unsync() {
                        return this._scheduledEvents.forEach(e => this.context.transport.clear(e)),
                        this._scheduledEvents = [],
                        this._synced && (this._synced = !1,
                        this.triggerAttack = this._original_triggerAttack,
                        this.triggerRelease = this._original_triggerRelease,
                        this.context.transport.off("stop", this._syncedRelease),
                        this.context.transport.off("pause", this._syncedRelease),
                        this.context.transport.off("loopEnd", this._syncedRelease)),
                        this
                    }
                    triggerAttackRelease(e, n, i, a) {
                        const o = this.toSeconds(i)
                          , u = this.toSeconds(n);
                        return this.triggerAttack(e, o, a),
                        this.triggerRelease(o + u),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._volume.dispose(),
                        this.unsync(),
                        this._scheduledEvents = [],
                        this
                    }
                }
                  , fv = class E3 extends Rp {
                    constructor() {
                        const e = Xt(E3.getDefaults(), arguments);
                        super(e),
                        this.portamento = e.portamento,
                        this.onsilence = e.onsilence
                    }
                    static getDefaults() {
                        return Object.assign(Rp.getDefaults(), {
                            detune: 0,
                            onsilence: Xn,
                            portamento: 0
                        })
                    }
                    triggerAttack(e, n, i=1) {
                        this.log("triggerAttack", e, n, i);
                        const a = this.toSeconds(n);
                        return this._triggerEnvelopeAttack(a, i),
                        this.setNote(e, a),
                        this
                    }
                    triggerRelease(e) {
                        this.log("triggerRelease", e);
                        const n = this.toSeconds(e);
                        return this._triggerEnvelopeRelease(n),
                        this
                    }
                    setNote(e, n) {
                        const i = this.toSeconds(n)
                          , a = e instanceof Mu ? e.toFrequency() : e;
                        if (this.portamento > 0 && this.getLevelAtTime(i) > .05) {
                            const o = this.toSeconds(this.portamento);
                            this.frequency.exponentialRampTo(a, o, i)
                        } else
                            this.frequency.setValueAtTime(a, i);
                        return this
                    }
                }
                ;
                To([gc(0)], fv.prototype, "portamento", void 0);
                var VF = class C3 extends wp {
                    constructor() {
                        super(Xt(C3.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])),
                        this.name = "AmplitudeEnvelope",
                        this._gainNode = new ki({
                            context: this.context,
                            gain: 0
                        }),
                        this.output = this._gainNode,
                        this.input = this._gainNode,
                        this._sig.connect(this._gainNode.gain),
                        this.output = this._gainNode,
                        this.input = this._gainNode
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.dispose(),
                        this
                    }
                }
                  , TS = class w3 extends fv {
                    constructor() {
                        const e = Xt(w3.getDefaults(), arguments);
                        super(e),
                        this.name = "Synth",
                        this.oscillator = new nR(Object.assign({
                            context: this.context,
                            detune: e.detune,
                            onstop: () => this.onsilence(this)
                        }, e.oscillator)),
                        this.frequency = this.oscillator.frequency,
                        this.detune = this.oscillator.detune,
                        this.envelope = new VF(Object.assign({
                            context: this.context
                        }, e.envelope)),
                        this.oscillator.chain(this.envelope, this.output),
                        _i(this, ["oscillator", "frequency", "detune", "envelope"])
                    }
                    static getDefaults() {
                        return Object.assign(fv.getDefaults(), {
                            envelope: Object.assign(eT(wp.getDefaults(), Object.keys(dn.getDefaults())), {
                                attack: .005,
                                decay: .1,
                                release: 1,
                                sustain: .3
                            }),
                            oscillator: Object.assign(eT(nR.getDefaults(), [...Object.keys(Ma.getDefaults()), "frequency", "detune"]), {
                                type: "triangle"
                            })
                        })
                    }
                    _triggerEnvelopeAttack(e, n) {
                        if (this.envelope.triggerAttack(e, n),
                        this.oscillator.start(e),
                        this.envelope.sustain === 0) {
                            const i = this.toSeconds(this.envelope.attack)
                              , a = this.toSeconds(this.envelope.decay);
                            this.oscillator.stop(e + i + a)
                        }
                    }
                    _triggerEnvelopeRelease(e) {
                        this.envelope.triggerRelease(e),
                        this.oscillator.stop(e + this.toSeconds(this.envelope.release))
                    }
                    getLevelAtTime(e) {
                        return e = this.toSeconds(e),
                        this.envelope.getValueAtTime(e)
                    }
                    dispose() {
                        return super.dispose(),
                        this.oscillator.dispose(),
                        this.envelope.dispose(),
                        this
                    }
                }
                  , aR = class R3 extends TS {
                    constructor() {
                        const e = Xt(R3.getDefaults(), arguments);
                        super(e),
                        this.name = "MembraneSynth",
                        this.portamento = 0,
                        this.pitchDecay = e.pitchDecay,
                        this.octaves = e.octaves,
                        _i(this, ["oscillator", "envelope"])
                    }
                    static getDefaults() {
                        return tf(fv.getDefaults(), TS.getDefaults(), {
                            envelope: {
                                attack: .001,
                                attackCurve: "exponential",
                                decay: .4,
                                release: 1.4,
                                sustain: .01
                            },
                            octaves: 10,
                            oscillator: {
                                type: "sine"
                            },
                            pitchDecay: .05
                        })
                    }
                    setNote(e, n) {
                        const i = this.toSeconds(n)
                          , a = this.toFrequency(e instanceof Mu ? e.toFrequency() : e)
                          , o = a * this.octaves;
                        return this.oscillator.frequency.setValueAtTime(o, i),
                        this.oscillator.frequency.exponentialRampToValueAtTime(a, i + this.toSeconds(this.pitchDecay)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this
                    }
                }
                ;
                To([iR(0)], aR.prototype, "octaves", void 0),
                To([gc(0)], aR.prototype, "pitchDecay", void 0);
                const rR = new Set;
                function hT(t) {
                    rR.add(t)
                }
                function oR(t, e) {
                    const n = `registerProcessor("${t}", ${e})`;
                    rR.add(n)
                }
                hT(`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`);
                const FF = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
                hT(FF),
                hT(`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`);
                const HF = "feedback-comb-filter";
                oR(HF, `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`);
                var GF = class N3 extends Rp {
                    constructor() {
                        const e = Xt(N3.getDefaults(), arguments, ["voice", "options"]);
                        super(e),
                        this.name = "PolySynth",
                        this._availableVoices = [],
                        this._activeVoices = [],
                        this._voices = [],
                        this._gcTimeout = -1,
                        this._averageActiveVoices = 0,
                        this._syncedRelease = a => this.releaseAll(a),
                        kt(!Su(e.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
                        const n = e.voice.getDefaults();
                        this.options = Object.assign(n, e.options),
                        this.voice = e.voice,
                        this.maxPolyphony = e.maxPolyphony,
                        this._dummyVoice = this._getNextAvailableVoice();
                        const i = this._voices.indexOf(this._dummyVoice);
                        this._voices.splice(i, 1),
                        this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1)
                    }
                    static getDefaults() {
                        return Object.assign(Rp.getDefaults(), {
                            maxPolyphony: 32,
                            options: {},
                            voice: TS
                        })
                    }
                    get activeVoices() {
                        return this._activeVoices.length
                    }
                    _makeVoiceAvailable(e) {
                        this._availableVoices.push(e);
                        const n = this._activeVoices.findIndex(i => i.voice === e);
                        this._activeVoices.splice(n, 1)
                    }
                    _getNextAvailableVoice() {
                        if (this._availableVoices.length)
                            return this._availableVoices.shift();
                        if (this._voices.length < this.maxPolyphony) {
                            const e = new this.voice(Object.assign(this.options, {
                                context: this.context,
                                onsilence: this._makeVoiceAvailable.bind(this)
                            }));
                            return kt(e instanceof fv, "Voice must extend Monophonic class"),
                            e.connect(this.output),
                            this._voices.push(e),
                            e
                        } else
                            dS("Max polyphony exceeded. Note dropped.")
                    }
                    _collectGarbage() {
                        if (this._averageActiveVoices = Math.max(this._averageActiveVoices * .95, this.activeVoices),
                        this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
                            const e = this._availableVoices.shift()
                              , n = this._voices.indexOf(e);
                            this._voices.splice(n, 1),
                            this.context.isOffline || e.dispose()
                        }
                    }
                    _triggerAttack(e, n, i) {
                        e.forEach(a => {
                            const o = new Yw(this.context,a).toMidi()
                              , u = this._getNextAvailableVoice();
                            u && (u.triggerAttack(a, n, i),
                            this._activeVoices.push({
                                midi: o,
                                voice: u,
                                released: !1
                            }),
                            this.log("triggerAttack", a, n))
                        }
                        )
                    }
                    _triggerRelease(e, n) {
                        e.forEach(i => {
                            const a = new Yw(this.context,i).toMidi()
                              , o = this._activeVoices.find( ({midi: u, released: f}) => u === a && !f);
                            o && (o.voice.triggerRelease(n),
                            o.released = !0,
                            this.log("triggerRelease", i, n))
                        }
                        )
                    }
                    _scheduleEvent(e, n, i, a) {
                        kt(!this.disposed, "Synth was already disposed"),
                        i <= this.now() ? e === "attack" ? this._triggerAttack(n, i, a) : this._triggerRelease(n, i) : this.context.setTimeout( () => {
                            this.disposed || this._scheduleEvent(e, n, i, a)
                        }
                        , i - this.now())
                    }
                    triggerAttack(e, n, i) {
                        Array.isArray(e) || (e = [e]);
                        const a = this.toSeconds(n);
                        return this._scheduleEvent("attack", e, a, i),
                        this
                    }
                    triggerRelease(e, n) {
                        Array.isArray(e) || (e = [e]);
                        const i = this.toSeconds(n);
                        return this._scheduleEvent("release", e, i),
                        this
                    }
                    triggerAttackRelease(e, n, i, a) {
                        const o = this.toSeconds(i);
                        if (this.triggerAttack(e, o, a),
                        or(n)) {
                            kt(or(e), "If the duration is an array, the notes must also be an array"),
                            e = e;
                            for (let u = 0; u < e.length; u++) {
                                const f = n[Math.min(u, n.length - 1)]
                                  , d = this.toSeconds(f);
                                kt(d > 0, "The duration must be greater than 0"),
                                this.triggerRelease(e[u], o + d)
                            }
                        } else {
                            const u = this.toSeconds(n);
                            kt(u > 0, "The duration must be greater than 0"),
                            this.triggerRelease(e, o + u)
                        }
                        return this
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 1),
                        this.context.transport.on("stop", this._syncedRelease),
                        this.context.transport.on("pause", this._syncedRelease),
                        this.context.transport.on("loopEnd", this._syncedRelease)),
                        this
                    }
                    set(e) {
                        const n = eT(e, ["onsilence", "context"]);
                        return this.options = tf(this.options, n),
                        this._voices.forEach(i => i.set(n)),
                        this._dummyVoice.set(n),
                        this
                    }
                    get() {
                        return this._dummyVoice.get()
                    }
                    releaseAll(e) {
                        const n = this.toSeconds(e);
                        return this._activeVoices.forEach( ({voice: i}) => {
                            i.triggerRelease(n)
                        }
                        ),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._dummyVoice.dispose(),
                        this._voices.forEach(e => e.dispose()),
                        this._activeVoices = [],
                        this._availableVoices = [],
                        this.context.clearInterval(this._gcTimeout),
                        this
                    }
                }
                  , lR = class D3 extends Rp {
                    constructor() {
                        const e = Xt(D3.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
                        super(e),
                        this.name = "Sampler",
                        this._activeSources = new Map;
                        const n = {};
                        Object.keys(e.urls).forEach(i => {
                            const a = parseInt(i, 10);
                            if (kt(fS(i) || Su(a) && isFinite(a), `url key is neither a note or midi pitch: ${i}`),
                            fS(i)) {
                                const o = new Mu(this.context,i).toMidi();
                                n[o] = e.urls[i]
                            } else
                                Su(a) && isFinite(a) && (n[a] = e.urls[a])
                        }
                        ),
                        this._buffers = new RF({
                            urls: n,
                            onload: e.onload,
                            baseUrl: e.baseUrl,
                            onerror: e.onerror
                        }),
                        this.attack = e.attack,
                        this.release = e.release,
                        this.curve = e.curve,
                        this._buffers.loaded && Promise.resolve().then(e.onload)
                    }
                    static getDefaults() {
                        return Object.assign(Rp.getDefaults(), {
                            attack: 0,
                            baseUrl: "",
                            curve: "exponential",
                            onload: Xn,
                            onerror: Xn,
                            release: .1,
                            urls: {}
                        })
                    }
                    _findClosest(e) {
                        let i = 0;
                        for (; i < 96; ) {
                            if (this._buffers.has(e + i))
                                return -i;
                            if (this._buffers.has(e - i))
                                return i;
                            i++
                        }
                        throw new Error(`No available buffers for note: ${e}`)
                    }
                    triggerAttack(e, n, i=1) {
                        return this.log("triggerAttack", e, n, i),
                        Array.isArray(e) || (e = [e]),
                        e.forEach(a => {
                            const o = qw(new Mu(this.context,a).toFrequency())
                              , u = Math.round(o)
                              , f = o - u
                              , d = this._findClosest(u)
                              , p = u - d
                              , g = this._buffers.get(p)
                              , v = kw(d + f)
                              , y = new lT({
                                url: g,
                                context: this.context,
                                curve: this.curve,
                                fadeIn: this.attack,
                                fadeOut: this.release,
                                playbackRate: v
                            }).connect(this.output);
                            y.start(n, 0, g.duration / v, i),
                            or(this._activeSources.get(u)) || this._activeSources.set(u, []),
                            this._activeSources.get(u).push(y),
                            y.onended = () => {
                                if (this._activeSources && this._activeSources.has(u)) {
                                    const S = this._activeSources.get(u)
                                      , E = S.indexOf(y);
                                    E !== -1 && S.splice(E, 1)
                                }
                            }
                        }
                        ),
                        this
                    }
                    triggerRelease(e, n) {
                        return this.log("triggerRelease", e, n),
                        Array.isArray(e) || (e = [e]),
                        e.forEach(i => {
                            const a = new Mu(this.context,i).toMidi();
                            if (this._activeSources.has(a) && this._activeSources.get(a).length) {
                                const o = this._activeSources.get(a);
                                n = this.toSeconds(n),
                                o.forEach(u => {
                                    u.stop(n)
                                }
                                ),
                                this._activeSources.set(a, [])
                            }
                        }
                        ),
                        this
                    }
                    releaseAll(e) {
                        const n = this.toSeconds(e);
                        return this._activeSources.forEach(i => {
                            for (; i.length; )
                                i.shift().stop(n)
                        }
                        ),
                        this
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 1)),
                        this
                    }
                    triggerAttackRelease(e, n, i, a=1) {
                        const o = this.toSeconds(i);
                        return this.triggerAttack(e, o, a),
                        or(n) ? (kt(or(e), "notes must be an array when duration is array"),
                        e.forEach( (u, f) => {
                            const d = n[Math.min(f, n.length - 1)];
                            this.triggerRelease(u, o + this.toSeconds(d))
                        }
                        )) : this.triggerRelease(e, o + this.toSeconds(n)),
                        this
                    }
                    add(e, n, i) {
                        if (kt(fS(e) || isFinite(e), `note must be a pitch or midi: ${e}`),
                        fS(e)) {
                            const a = new Mu(this.context,e).toMidi();
                            this._buffers.add(a, n, i)
                        } else
                            this._buffers.add(e, n, i);
                        return this
                    }
                    get loaded() {
                        return this._buffers.loaded
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffers.dispose(),
                        this._activeSources.forEach(e => {
                            e.forEach(n => n.dispose())
                        }
                        ),
                        this._activeSources.clear(),
                        this
                    }
                }
                ;
                To([gc(0)], lR.prototype, "attack", void 0),
                To([gc(0)], lR.prototype, "release", void 0);
                var kF = class O3 extends dn {
                    constructor() {
                        const e = Xt(O3.getDefaults(), arguments, ["fade"]);
                        super(e),
                        this.name = "CrossFade",
                        this._panner = this.context.createStereoPanner(),
                        this._split = this.context.createChannelSplitter(2),
                        this._g2a = new PF({
                            context: this.context
                        }),
                        this.a = new ki({
                            context: this.context,
                            gain: 0
                        }),
                        this.b = new ki({
                            context: this.context,
                            gain: 0
                        }),
                        this.output = new ki({
                            context: this.context
                        }),
                        this._internalChannels = [this.a, this.b],
                        this.fade = new Cs({
                            context: this.context,
                            units: "normalRange",
                            value: e.fade
                        }),
                        _i(this, "fade"),
                        this.context.getConstant(1).connect(this._panner),
                        this._panner.connect(this._split),
                        this._panner.channelCount = 1,
                        this._panner.channelCountMode = "explicit",
                        bu(this._split, this.a.gain, 0),
                        bu(this._split, this.b.gain, 1),
                        this.fade.chain(this._g2a, this._panner.pan),
                        this.a.connect(this.output),
                        this.b.connect(this.output)
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            fade: .5
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.a.dispose(),
                        this.b.dispose(),
                        this.output.dispose(),
                        this.fade.dispose(),
                        this._g2a.dispose(),
                        this._panner.disconnect(),
                        this._split.disconnect(),
                        this
                    }
                }
                  , cR = class extends dn {
                    constructor(t) {
                        super(t),
                        this.name = "Effect",
                        this._dryWet = new kF({
                            context: this.context
                        }),
                        this.wet = this._dryWet.fade,
                        this.effectSend = new ki({
                            context: this.context
                        }),
                        this.effectReturn = new ki({
                            context: this.context
                        }),
                        this.input = new ki({
                            context: this.context
                        }),
                        this.output = this._dryWet,
                        this.input.fan(this._dryWet.a, this.effectSend),
                        this.effectReturn.connect(this._dryWet.b),
                        this.wet.setValueAtTime(t.wet, 0),
                        this._internalChannels = [this.effectReturn, this.effectSend],
                        _i(this, "wet")
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            wet: 1
                        })
                    }
                    connectEffect(t) {
                        return this._internalChannels.push(t),
                        this.effectSend.chain(t, this.effectReturn),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._dryWet.dispose(),
                        this.effectSend.dispose(),
                        this.effectReturn.dispose(),
                        this.wet.dispose(),
                        this
                    }
                }
                  , qF = class U3 extends dn {
                    constructor() {
                        const e = Xt(U3.getDefaults(), arguments, ["pan"]);
                        super(e),
                        this.name = "Panner",
                        this._panner = this.context.createStereoPanner(),
                        this.input = this._panner,
                        this.output = this._panner,
                        this.pan = new es({
                            context: this.context,
                            param: this._panner.pan,
                            value: e.pan,
                            minValue: -1,
                            maxValue: 1
                        }),
                        this._panner.channelCount = e.channelCount,
                        this._panner.channelCountMode = "explicit",
                        _i(this, "pan")
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            pan: 0,
                            channelCount: 1
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._panner.disconnect(),
                        this.pan.dispose(),
                        this
                    }
                }
                ;
                const XF = "bit-crusher"
                  , WF = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
                oR(XF, WF);
                var YF = class L3 extends dn {
                    constructor() {
                        const e = Xt(L3.getDefaults(), arguments, ["channels"]);
                        super(e),
                        this.name = "Merge",
                        this._merger = this.output = this.input = this.context.createChannelMerger(e.channels)
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            channels: 2
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._merger.disconnect(),
                        this
                    }
                }
                ;
                const G8 = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100]
                  , k8 = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];
                var jF = class I3 extends cR {
                    constructor() {
                        const e = Xt(I3.getDefaults(), arguments, ["decay"]);
                        super(e),
                        this.name = "Reverb",
                        this._convolver = this.context.createConvolver(),
                        this.ready = Promise.resolve();
                        const n = this.toSeconds(e.decay);
                        Hr(n, .001),
                        this._decay = n;
                        const i = this.toSeconds(e.preDelay);
                        Hr(i, 0),
                        this._preDelay = i,
                        this.generate(),
                        this.connectEffect(this._convolver)
                    }
                    static getDefaults() {
                        return Object.assign(cR.getDefaults(), {
                            decay: 1.5,
                            preDelay: .01
                        })
                    }
                    get decay() {
                        return this._decay
                    }
                    set decay(e) {
                        e = this.toSeconds(e),
                        Hr(e, .001),
                        this._decay = e,
                        this.generate()
                    }
                    get preDelay() {
                        return this._preDelay
                    }
                    set preDelay(e) {
                        e = this.toSeconds(e),
                        Hr(e, 0),
                        this._preDelay = e,
                        this.generate()
                    }
                    generate() {
                        return Gi(this, void 0, void 0, function*() {
                            const e = this.ready
                              , n = new _S(2,this._decay + this._preDelay,this.context.sampleRate)
                              , i = new Zw({
                                context: n
                            })
                              , a = new Zw({
                                context: n
                            })
                              , o = new YF({
                                context: n
                            });
                            i.connect(o, 0, 0),
                            a.connect(o, 0, 1);
                            const u = new ki({
                                context: n
                            }).toDestination();
                            o.connect(u),
                            i.start(0),
                            a.start(0),
                            u.gain.setValueAtTime(0, 0),
                            u.gain.setValueAtTime(1, this._preDelay),
                            u.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
                            const f = n.render();
                            return this.ready = f.then(Xn),
                            yield e,
                            this._convolver.buffer = (yield f).get(),
                            this
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._convolver.disconnect(),
                        this
                    }
                }
                  , fT = class ws extends dn {
                    constructor() {
                        const e = Xt(ws.getDefaults(), arguments, ["solo"]);
                        super(e),
                        this.name = "Solo",
                        this.input = this.output = new ki({
                            context: this.context
                        }),
                        ws._allSolos.has(this.context) || ws._allSolos.set(this.context, new Set),
                        ws._allSolos.get(this.context).add(this),
                        this.solo = e.solo
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            solo: !1
                        })
                    }
                    get solo() {
                        return this._isSoloed()
                    }
                    set solo(e) {
                        e ? this._addSolo() : this._removeSolo(),
                        ws._allSolos.get(this.context).forEach(n => n._updateSolo())
                    }
                    get muted() {
                        return this.input.gain.value === 0
                    }
                    _addSolo() {
                        ws._soloed.has(this.context) || ws._soloed.set(this.context, new Set),
                        ws._soloed.get(this.context).add(this)
                    }
                    _removeSolo() {
                        ws._soloed.has(this.context) && ws._soloed.get(this.context).delete(this)
                    }
                    _isSoloed() {
                        return ws._soloed.has(this.context) && ws._soloed.get(this.context).has(this)
                    }
                    _noSolos() {
                        return !ws._soloed.has(this.context) || ws._soloed.has(this.context) && ws._soloed.get(this.context).size === 0
                    }
                    _updateSolo() {
                        this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0
                    }
                    dispose() {
                        return super.dispose(),
                        ws._allSolos.get(this.context).delete(this),
                        this._removeSolo(),
                        this
                    }
                }
                ;
                fT._allSolos = new Map,
                fT._soloed = new Map;
                var ZF = class z3 extends dn {
                    constructor() {
                        const e = Xt(z3.getDefaults(), arguments, ["pan", "volume"]);
                        super(e),
                        this.name = "PanVol",
                        this._panner = this.input = new qF({
                            context: this.context,
                            pan: e.pan,
                            channelCount: e.channelCount
                        }),
                        this.pan = this._panner.pan,
                        this._volume = this.output = new SS({
                            context: this.context,
                            volume: e.volume
                        }),
                        this.volume = this._volume.volume,
                        this._panner.connect(this._volume),
                        this.mute = e.mute,
                        _i(this, ["pan", "volume"])
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            mute: !1,
                            pan: 0,
                            volume: 0,
                            channelCount: 1
                        })
                    }
                    get mute() {
                        return this._volume.mute
                    }
                    set mute(e) {
                        this._volume.mute = e
                    }
                    dispose() {
                        return super.dispose(),
                        this._panner.dispose(),
                        this.pan.dispose(),
                        this._volume.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                  , QF = class pv extends dn {
                    constructor() {
                        const e = Xt(pv.getDefaults(), arguments, ["volume", "pan"]);
                        super(e),
                        this.name = "Channel",
                        this._solo = this.input = new fT({
                            solo: e.solo,
                            context: this.context
                        }),
                        this._panVol = this.output = new ZF({
                            context: this.context,
                            pan: e.pan,
                            volume: e.volume,
                            mute: e.mute,
                            channelCount: e.channelCount
                        }),
                        this.pan = this._panVol.pan,
                        this.volume = this._panVol.volume,
                        this._solo.connect(this._panVol),
                        _i(this, ["pan", "volume"])
                    }
                    static getDefaults() {
                        return Object.assign(dn.getDefaults(), {
                            pan: 0,
                            volume: 0,
                            mute: !1,
                            solo: !1,
                            channelCount: 1
                        })
                    }
                    get solo() {
                        return this._solo.solo
                    }
                    set solo(e) {
                        this._solo.solo = e
                    }
                    get muted() {
                        return this._solo.muted || this.mute
                    }
                    get mute() {
                        return this._panVol.mute
                    }
                    set mute(e) {
                        this._panVol.mute = e
                    }
                    _getBus(e) {
                        return pv.buses.has(e) || pv.buses.set(e, new ki({
                            context: this.context
                        })),
                        pv.buses.get(e)
                    }
                    send(e, n=0) {
                        const i = this._getBus(e)
                          , a = new ki({
                            context: this.context,
                            units: "decibels",
                            gain: n
                        });
                        return this.connect(a),
                        a.connect(i),
                        a
                    }
                    receive(e) {
                        return this._getBus(e).connect(this),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._panVol.dispose(),
                        this.pan.dispose(),
                        this.volume.dispose(),
                        this._solo.dispose(),
                        this
                    }
                }
                ;
                QF.buses = new Map;
                const q8 = Co().transport
                  , X8 = Co().destination
                  , W8 = Co().destination
                  , Y8 = Co().listener
                  , j8 = Co().draw
                  , Z8 = Co()
                  , Ga = c1.gizmoRuntime.tweaks({
                    sphereCount: {
                        index: 0,
                        name: "Sphere Count",
                        type: "slider",
                        value: 800,
                        min: 100,
                        max: 2e3,
                        step: 50
                    },
                    glowColor: {
                        index: 1,
                        name: "Glow Color",
                        type: "color",
                        value: "#FF69B4"
                    },
                    glowIntensity: {
                        index: 2,
                        name: "Glow Intensity",
                        type: "slider",
                        value: 2.5,
                        min: .5,
                        max: 10,
                        step: .1
                    },
                    roughness: {
                        index: 3,
                        name: "Surface Roughness",
                        type: "slider",
                        value: .2,
                        min: 0,
                        max: 1,
                        step: .05
                    },
                    metalness: {
                        index: 4,
                        name: "Surface Metalness",
                        type: "slider",
                        value: .5,
                        min: 0,
                        max: 1,
                        step: .05
                    },
                    jiggleAmount: {
                        index: 5,
                        name: "Jiggle Strength",
                        type: "slider",
                        value: .05,
                        min: 0,
                        max: .5,
                        step: .01
                    },
                    bgColor: {
                        index: 6,
                        name: "Background",
                        type: "color",
                        value: "#000000"
                    },
                    useOppositeIris: {
                        index: 7,
                        name: "Opposite Iris Color",
                        type: "toggle",
                        value: !0,
                        group: "iris"
                    },
                    irisColor: {
                        index: 8,
                        name: "Iris Color",
                        type: "color",
                        value: "#000000",
                        group: "iris"
                    },
                    irisSize: {
                        index: 9,
                        name: "Iris Size",
                        type: "slider",
                        value: .35,
                        min: .1,
                        max: .6,
                        step: .05,
                        group: "iris"
                    },
                    titleText: {
                        index: 10,
                        name: "Title",
                        type: "text",
                        value: "Touch to Glow",
                        group: "ui"
                    },
                    titleColor: {
                        index: 11,
                        name: "Title Color",
                        type: "color",
                        value: "#FFFFFF",
                        group: "ui"
                    },
                    titleVisible: {
                        index: 12,
                        name: "Show Title",
                        type: "toggle",
                        value: !0,
                        group: "ui"
                    },
                    titleSize: {
                        index: 13,
                        name: "Title Size",
                        type: "slider",
                        value: 24,
                        min: 12,
                        max: 48,
                        step: 1,
                        group: "ui"
                    }
                })
                  , uR = ["#EFB63F", "#E93323", "#2227F5", "#8762F6", "#D9D9D9", "#A0522D", "#E432B7", "#53B5F9", "#FFDD46", "#325a30", "#75F94C"]
                  , dT = 2;
                function KF({count: t, roughness: e, metalness: n, jiggleAmount: i, lightPositions: a, activeLights: o, irisColor: u, irisSize: f, useOppositeIris: d}) {
                    const p = (0,
                    gt.useRef)(null)
                      , g = (0,
                    gt.useRef)(null)
                      , {viewport: v} = f2()
                      , y = (0,
                    gt.useRef)(null)
                      , S = (0,
                    gt.useRef)(!1)
                      , E = (0,
                    gt.useRef)(new Map);
                    (0,
                    gt.useEffect)( () => {
                        const I = new jF({
                            decay: 2,
                            wet: .4
                        }).toDestination();
                        return y.current = new GF(TS,{
                            oscillator: {
                                type: "sine"
                            },
                            envelope: {
                                attack: .005,
                                decay: .3,
                                sustain: .1,
                                release: .5
                            }
                        }).connect(I),
                        () => {
                            y.current?.dispose(),
                            I.dispose()
                        }
                    }
                    , []);
                    const w = (0,
                    gt.useMemo)( () => {
                        const I = [];
                        for (let V = 0; V < t; V++) {
                            const B = (Math.random() - .5) * v.width * 1.5
                              , P = (Math.random() - .5) * v.height * 1.5
                              , G = (Math.random() - .5) * 4 - 1
                              , K = .05 + Math.random() * .25
                              , ee = new ut(uR[Math.floor(Math.random() * uR.length)])
                              , te = new ut(1 - ee.r,1 - ee.g,1 - ee.b);
                            I.push({
                                x: B,
                                y: P,
                                z: G,
                                size: K,
                                color: ee,
                                invertedColor: te,
                                phase: Math.random() * Math.PI * 2,
                                irisDir: new J(0,0,1),
                                wasLit: !1
                            })
                        }
                        return I
                    }
                    , [t, v.width, v.height])
                      , A = (0,
                    gt.useMemo)( () => new zn, [])
                      , T = (0,
                    gt.useMemo)( () => new zn, [])
                      , R = (0,
                    gt.useMemo)( () => new J, []);
                    (0,
                    gt.useMemo)( () => new J, []);
                    const N = (0,
                    gt.useMemo)( () => new J, [])
                      , D = (0,
                    gt.useMemo)( () => new J, [])
                      , U = ["C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5"]
                      , z = async I => {
                        S.current || (await pF(),
                        S.current = !0);
                        const V = U[I % U.length];
                        y.current?.triggerAttackRelease(V, "0.1n")
                    }
                    ;
                    return mb(I => {
                        if (!p.current || !g.current)
                            return;
                        const V = I.clock.getElapsedTime();
                        w.forEach( (B, P) => {
                            N.set(B.x, B.y, B.z);
                            let G = null
                              , K = 1 / 0
                              , ee = 0;
                            for (let X = 0; X < dT; X++)
                                if (o[X]) {
                                    const $ = N.distanceToSquared(a[X]);
                                    $ < K && (K = $,
                                    G = a[X]);
                                    const ne = Math.sqrt($);
                                    ee = Math.max(ee, Math.max(0, 1 - ne / 2.5))
                                }
                            const te = Math.sin(V * 10 + B.phase) * i * ee
                              , oe = R.set(B.x + te, B.y + te, B.z)
                              , q = ee > .3;
                            if (q && !B.wasLit) {
                                const X = Date.now();
                                X - (E.current.get(P) || 0) > 200 && (z(P),
                                E.current.set(P, X))
                            }
                            B.wasLit = q,
                            A.position.copy(oe),
                            A.scale.setScalar(B.size),
                            A.updateMatrix(),
                            p.current.setMatrixAt(P, A.matrix),
                            p.current.setColorAt(P, B.color),
                            G ? D.subVectors(G, oe).normalize() : D.set(0, 0, 1),
                            B.irisDir.lerp(D, .08);
                            const F = oe.clone().add(B.irisDir.clone().multiplyScalar(B.size * .85));
                            T.position.copy(F),
                            T.scale.setScalar(B.size * f),
                            T.updateMatrix(),
                            g.current.setMatrixAt(P, T.matrix),
                            d ? g.current.setColorAt(P, B.invertedColor) : g.current.setColorAt(P, new ut(u))
                        }
                        ),
                        p.current.instanceMatrix.needsUpdate = !0,
                        p.current.instanceColor && (p.current.instanceColor.needsUpdate = !0),
                        g.current.instanceMatrix.needsUpdate = !0,
                        g.current.instanceColor && (g.current.instanceColor.needsUpdate = !0)
                    }
                    ),
                    (0,
                    gn.jsxs)("group", {
                        children: [(0,
                        gn.jsxs)("instancedMesh", {
                            ref: p,
                            args: [null, null, t],
                            castShadow: !0,
                            receiveShadow: !0,
                            children: [(0,
                            gn.jsx)("sphereGeometry", {
                                args: [1, 24, 24]
                            }), (0,
                            gn.jsx)("meshStandardMaterial", {
                                roughness: e,
                                metalness: n
                            })]
                        }), (0,
                        gn.jsxs)("instancedMesh", {
                            ref: g,
                            args: [null, null, t],
                            children: [(0,
                            gn.jsx)("sphereGeometry", {
                                args: [1, 12, 12]
                            }), (0,
                            gn.jsx)("meshStandardMaterial", {
                                roughness: .1,
                                metalness: .8
                            })]
                        })]
                    })
                }
                function JF({lightPos: t, glowColor: e, glowIntensity: n, active: i}) {
                    const a = (0,
                    gt.useRef)(null);
                    return mb( () => {
                        a.current && (a.current.position.copy(t),
                        a.current.intensity = i ? n : 0)
                    }
                    ),
                    (0,
                    gn.jsx)("pointLight", {
                        ref: a,
                        color: e,
                        distance: 10,
                        decay: 2,
                        castShadow: !0
                    })
                }
                function $F({lightPos: t, glowColor: e, active: n}) {
                    const i = (0,
                    gt.useRef)(null);
                    return mb( () => {
                        if (i.current) {
                            i.current.position.copy(t),
                            i.current.position.z -= .2;
                            const a = i.current.material;
                            a.opacity = n ? .8 : 0
                        }
                    }
                    ),
                    (0,
                    gn.jsxs)("mesh", {
                        ref: i,
                        children: [(0,
                        gn.jsx)("sphereGeometry", {
                            args: [.1, 16, 16]
                        }), (0,
                        gn.jsx)("meshBasicMaterial", {
                            color: e,
                            transparent: !0
                        })]
                    })
                }
                function e8({lightPositions: t, setActiveLights: e}) {
                    const {camera: n} = f2()
                      , i = (0,
                    gt.useRef)(new Map)
                      , a = (o, u) => {
                        const f = o / window.innerWidth * 2 - 1
                          , d = -(u / window.innerHeight) * 2 + 1
                          , p = new J(f,d,.5);
                        p.unproject(n);
                        const g = p.sub(n.position).normalize()
                          , v = -n.position.z / g.z
                          , y = n.position.clone().add(g.multiplyScalar(v));
                        return new J(y.x,y.y,1)
                    }
                    ;
                    return (0,
                    gt.useEffect)( () => {
                        const o = p => {
                            const g = [!1, !1]
                              , v = new Set;
                            for (let y = 0; y < Math.min(p.length, dT); y++) {
                                const S = p[y];
                                if (v.add(S.identifier),
                                !i.current.has(S.identifier)) {
                                    for (let w = 0; w < dT; w++)
                                        if (!Array.from(i.current.values()).includes(w)) {
                                            i.current.set(S.identifier, w);
                                            break
                                        }
                                }
                                const E = i.current.get(S.identifier);
                                if (E !== void 0) {
                                    const w = a(S.clientX, S.clientY);
                                    t[E].copy(w),
                                    g[E] = !0
                                }
                            }
                            for (const y of i.current.keys())
                                v.has(y) || i.current.delete(y);
                            e([...g])
                        }
                          , u = p => {
                            o(p.touches),
                            c1.gizmoRuntime.performHaptic("light")
                        }
                          , f = p => {
                            o(p.touches)
                        }
                          , d = p => {
                            o(p.touches)
                        }
                        ;
                        return window.addEventListener("touchstart", u),
                        window.addEventListener("touchmove", f),
                        window.addEventListener("touchend", d),
                        window.addEventListener("touchcancel", d),
                        () => {
                            window.removeEventListener("touchstart", u),
                            window.removeEventListener("touchmove", f),
                            window.removeEventListener("touchend", d),
                            window.removeEventListener("touchcancel", d)
                        }
                    }
                    , [n, t, e]),
                    null
                }
                function t8() {
                    const t = (0,
                    gt.useMemo)( () => [new J(0,0,2), new J(0,0,2)], [])
                      , [e,n] = (0,
                    gt.useState)([!1, !1])
                      , i = Ga.sphereCount.useState()
                      , a = Ga.glowColor.useState()
                      , o = Ga.glowIntensity.useState()
                      , u = Ga.roughness.useState()
                      , f = Ga.metalness.useState()
                      , d = Ga.jiggleAmount.useState()
                      , p = Ga.bgColor.useState()
                      , g = Ga.useOppositeIris.useState()
                      , v = Ga.irisColor.useState()
                      , y = Ga.irisSize.useState()
                      , S = Ga.titleText.useState()
                      , E = Ga.titleColor.useState()
                      , w = Ga.titleVisible.useState()
                      , A = Ga.titleSize.useState()
                      , T = e.some(R => R);
                    return (0,
                    gn.jsxs)("div", {
                        className: "h-screen w-screen overflow-hidden relative",
                        style: {
                            backgroundColor: p
                        },
                        children: [w && (0,
                        gn.jsx)("div", {
                            className: "absolute top-10 left-0 w-full text-center pointer-events-none z-10 transition-opacity duration-500",
                            style: {
                                color: E,
                                fontSize: `${A}px`,
                                opacity: T ? .2 : 1,
                                fontWeight: "bold",
                                textShadow: "0 2px 10px rgba(0,0,0,0.5)"
                            },
                            children: S
                        }), (0,
                        gn.jsxs)(cB, {
                            shadows: !0,
                            camera: {
                                position: [0, 0, 5],
                                fov: 50
                            },
                            gl: {
                                antialias: !0
                            },
                            dpr: [1, 2],
                            children: [(0,
                            gn.jsx)("color", {
                                attach: "background",
                                args: [p]
                            }), (0,
                            gn.jsx)("ambientLight", {
                                intensity: .2
                            }), t.map( (R, N) => (0,
                            gn.jsxs)(gt.Fragment, {
                                children: [(0,
                                gn.jsx)(JF, {
                                    lightPos: R,
                                    glowColor: a,
                                    glowIntensity: o,
                                    active: e[N]
                                }), (0,
                                gn.jsx)($F, {
                                    lightPos: R,
                                    glowColor: a,
                                    active: e[N]
                                })]
                            }, N)), (0,
                            gn.jsx)("directionalLight", {
                                position: [-5, 5, 5],
                                intensity: .3
                            }), (0,
                            gn.jsxs)(gt.Suspense, {
                                fallback: null,
                                children: [(0,
                                gn.jsx)(KF, {
                                    count: i,
                                    roughness: u,
                                    metalness: f,
                                    jiggleAmount: d,
                                    lightPositions: t,
                                    activeLights: e,
                                    irisColor: v,
                                    irisSize: y,
                                    useOppositeIris: g
                                }), (0,
                                gn.jsx)(e8, {
                                    lightPositions: t,
                                    setActiveLights: n
                                })]
                            })]
                        })]
                    })
                }
                var n8 = o1();
                window.React = gt.default,
                window.gizmoRuntime = n8.gizmoRuntime;
                var i8 = class extends gt.Component {
                    render() {
                        return (0,
                        gn.jsx)(t8, {})
                    }
                }
                ;
                GN.createRoot(document.getElementById("application")).render((0,
                gn.jsx)(i8, {}));

                //# sourceMappingURL=app.js.map
            </script>
        </div>
    </body>
</html>
